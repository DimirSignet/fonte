{"sha": "53feb3fa56af7260e607844524b7e5a9be49ecc1", "log": "Convert to maven 2  ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Chronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+\n+/**\n+ * Chronology provides access to the individual date time fields for a\n+ * chronological calendar system.\n+ * <p>\n+ * Various chronologies are supported by subclasses including ISO\n+ * and GregorianJulian. To construct a Chronology you should use the\n+ * factory methods on the chronology subclass in the chrono package.\n+ * <p>\n+ * For example, to obtain the current time in the coptic calendar system:\n+ * <pre>\n+ * DateTime dt = new DateTime(CopticChronology.getInstance());\n+ * </pre>\n+ * <p>\n+ * The provided chronology implementations are:\n+ * <ul>\n+ * <li>ISO - Based on the ISO8601 standard and suitable for use after about 1600\n+ * <li>GJ - Historically accurate calendar with Julian followed by Gregorian\n+ * <li>Gregorian - The Gregorian calendar system used for all time (proleptic)\n+ * <li>Julian - The Julian calendar system used for all time (proleptic)\n+ * <li>Buddhist - The Buddhist calendar system which is an offset in years from GJ\n+ * <li>Coptic - The Coptic calendar system which defines 30 day months\n+ * <li>Ethiopic - The Ethiopic calendar system which defines 30 day months\n+ * </ul>\n+ * Hopefully future releases will contain more chronologies.\n+ * <p>\n+ * This class defines a number of fields with names from the ISO8601 standard.\n+ * It does not 'strongly' define these fields however, thus implementations\n+ * are free to interpret the field names as they wish.\n+ * For example, a week could be defined as 10 days and a month as 40 days in a\n+ * special WeirdChronology implementation. Clearly the GJ and ISO\n+ * implementations provided use the field names as you would expect.\n+ *\n+ * @see org.joda.time.chrono.ISOChronology\n+ * @see org.joda.time.chrono.GJChronology\n+ * @see org.joda.time.chrono.GregorianChronology\n+ * @see org.joda.time.chrono.JulianChronology\n+ * @see org.joda.time.chrono.CopticChronology\n+ * @see org.joda.time.chrono.BuddhistChronology\n+ * @see org.joda.time.chrono.EthiopicChronology\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class Chronology {\n+\n+    /**\n+     * Returns the DateTimeZone that this Chronology operates in, or null if\n+     * unspecified.\n+     *\n+     * @return the DateTimeZone, null if unspecified\n+     */\n+    public abstract DateTimeZone getZone();\n+\n+    /**\n+     * Returns an instance of this Chronology that operates in the UTC time\n+     * zone. Chronologies that do not operate in a time zone or are already\n+     * UTC must return themself.\n+     *\n+     * @return a version of this chronology that ignores time zones\n+     */\n+    public abstract Chronology withUTC();\n+    \n+    /**\n+     * Returns an instance of this Chronology that operates in any time zone.\n+     *\n+     * @return a version of this chronology with a specific time zone\n+     * @param zone to use, or default if null\n+     * @see org.joda.time.chrono.ZonedChronology\n+     */\n+    public abstract Chronology withZone(DateTimeZone zone);\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, and millisecond values. The set of given values must refer\n+     * to a valid datetime, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param millisOfDay millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the values are invalid\n+     */\n+    public abstract long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay);\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, hour, minute, second, and millisecond values. The set of\n+     * given values must refer to a valid datetime, or else an\n+     * IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the values are invalid\n+     */\n+    public abstract long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                           int hourOfDay, int minuteOfHour,\n+                           int secondOfMinute, int millisOfSecond);\n+\n+    /**\n+     * Returns a datetime millisecond instant, from from the given instant,\n+     * hour, minute, second, and millisecond values. The set of given values\n+     * must refer to a valid datetime, or else an IllegalArgumentException is\n+     * thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param instant instant to start from\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the values are invalid\n+     */\n+    public abstract long getDateTimeMillis(long instant,\n+                           int hourOfDay, int minuteOfHour,\n+                           int secondOfMinute, int millisOfSecond);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates whether the values are valid for the fields of a partial instant.\n+     *\n+     * @param partial  the partial instant to validate\n+     * @param values  the values to validate, not null, match fields in partial\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public abstract void validate(ReadablePartial partial, int[] values);\n+\n+    /**\n+     * Gets the values of a partial from an instant.\n+     *\n+     * @param partial  the partial instant to use\n+     * @param instant  the instant to query\n+     * @return the values of this partial extracted from the instant\n+     */\n+    public abstract int[] get(ReadablePartial partial, long instant);\n+\n+    /**\n+     * Sets the partial into the instant.\n+     *\n+     * @param partial  the partial instant to use\n+     * @param instant  the instant to update\n+     * @return the updated instant\n+     */\n+    public abstract long set(ReadablePartial partial, long instant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the values of a period from an interval.\n+     *\n+     * @param period  the period instant to use\n+     * @param startInstant  the start instant of an interval to query\n+     * @param endInstant  the start instant of an interval to query\n+     * @return the values of the period extracted from the interval\n+     */\n+    public abstract int[] get(ReadablePeriod period, long startInstant, long endInstant);\n+\n+    /**\n+     * Gets the values of a period from an interval.\n+     *\n+     * @param period  the period instant to use\n+     * @param duration  the duration to query\n+     * @return the values of the period extracted from the duration\n+     */\n+    public abstract int[] get(ReadablePeriod period, long duration);\n+\n+    /**\n+     * Adds the period to the instant, specifying the number of times to add.\n+     *\n+     * @param period  the period to add, null means add nothing\n+     * @param instant  the instant to add to\n+     * @param scalar  the number of times to add\n+     * @return the updated instant\n+     */\n+    public abstract long add(ReadablePeriod period, long instant, int scalar);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds the duration to the instant, specifying the number of times to add.\n+     *\n+     * @param instant  the instant to add to\n+     * @param duration  the duration to add\n+     * @param scalar  the number of times to add\n+     * @return the updated instant\n+     */\n+    public abstract long add(long instant, long duration, int scalar);\n+\n+    // Millis\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField millis();\n+\n+    /**\n+     * Get the millis of second field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField millisOfSecond();\n+\n+    /**\n+     * Get the millis of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField millisOfDay();\n+\n+    // Second\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the seconds duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField seconds();\n+\n+    /**\n+     * Get the second of minute field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField secondOfMinute();\n+\n+    /**\n+     * Get the second of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField secondOfDay();\n+\n+    // Minute\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the minutes duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField minutes();\n+\n+    /**\n+     * Get the minute of hour field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField minuteOfHour();\n+\n+    /**\n+     * Get the minute of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField minuteOfDay();\n+\n+    // Hour\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hours duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField hours();\n+\n+    /**\n+     * Get the hour of day (0-23) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField hourOfDay();\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField clockhourOfDay();\n+\n+    // Halfday\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the halfdays duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField halfdays();\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField hourOfHalfday();\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField clockhourOfHalfday();\n+\n+    /**\n+     * Get the AM(0) PM(1) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField halfdayOfDay();\n+\n+    // Day\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the days duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField days();\n+\n+    /**\n+     * Get the day of week field for this chronology.\n+     *\n+     * <p>DayOfWeek values are defined in {@link DateTimeConstants}.\n+     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField dayOfWeek();\n+\n+    /**\n+     * Get the day of month field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField dayOfMonth();\n+\n+    /**\n+     * Get the day of year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField dayOfYear();\n+\n+    // Week\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the weeks duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField weeks();\n+\n+    /**\n+     * Get the week of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField weekOfWeekyear();\n+\n+    // Weekyear\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the weekyears duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField weekyears();\n+\n+    /**\n+     * Get the year of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField weekyear();\n+\n+    /**\n+     * Get the year of a week based year in a century field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract  DateTimeField weekyearOfCentury();\n+\n+    // Month\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the months duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField months();\n+\n+    /**\n+     * Get the month of year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField monthOfYear();\n+\n+    // Year\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the years duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField years();\n+\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField year();\n+\n+    /**\n+     * Get the year of era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField yearOfEra();\n+\n+    /**\n+     * Get the year of century field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField yearOfCentury();\n+\n+    // Century\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the centuries duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField centuries();\n+\n+    /**\n+     * Get the century of era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField centuryOfEra();\n+\n+    // Era\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the eras duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public abstract DurationField eras();\n+\n+    /**\n+     * Get the era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public abstract DateTimeField era();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public abstract String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DateMidnight.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BaseDateTime;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * DateMidnight defines a date where the time component is fixed at midnight.\n+ * The class uses a time zone, thus midnight is local unless a UTC time zone is used.\n+ * <p>\n+ * It is important to emphasise that this class represents the time of midnight on\n+ * any given day.\n+ * Note that midnight is defined as 00:00, which is at the very start of a day.\n+ * <p>\n+ * This class does not represent a day, but the millisecond instant at midnight.\n+ * If you need a class that represents the whole day, then an {@link Interval} or\n+ * a {@link LocalDate} may be more suitable.\n+ * <p>\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getDayOfMonth()</code>\n+ * <li><code>dayOfMonth().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ *\n+ * <p>\n+ * DateMidnight is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class DateMidnight\n+        extends BaseDateTime\n+        implements ReadableDateTime, Serializable {\n+    \n+    /** Serialization lock */\n+    private static final long serialVersionUID = 156371964018738L;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n+     * The constructed object will have a local time of midnight.\n+     */\n+    public DateMidnight() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public DateMidnight(DateTimeZone zone) {\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateMidnight(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     * The constructed object will have a local time of midnight.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public DateMidnight(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public DateMidnight(long instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateMidnight(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used. Otherwise, ISO default is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateMidnight(Object instant) {\n+        super(instant, (Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used, but with the time zone adjusted.\n+     * Otherwise, ISO is used in the specified time zone.\n+     * If the specified time zone is null, the default zone is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param zone  the time zone, null means default time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateMidnight(Object instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Any chronology implied by the object (such as GregorianCalendar does)\n+     * is ignored.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateMidnight(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     * The constructed object will have a local time of midnight.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public DateMidnight(int year, int monthOfYear, int dayOfMonth) {\n+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) {\n+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * The constructed object will have a local time of midnight.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n+        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);\n+    }\n+\n+    /**\n+     * Rounds the specified instant to midnight.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param chronology  the chronology to use, not null\n+     * @return the updated instant, rounded to midnight\n+     */\n+    protected long checkInstant(long instant, Chronology chronology) {\n+        return chronology.dayOfMonth().roundFloor(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with a different millisecond instant.\n+     * The returned object will have a local time of midnight.\n+     * <p>\n+     * Only the millis will change, the chronology and time zone are kept.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    public DateMidnight withMillis(long newMillis) {\n+        Chronology chrono = getChronology();\n+        newMillis = checkInstant(newMillis, chrono);\n+        return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with a different chronology, potentially\n+     * changing the day in unexpected ways.\n+     * <p>\n+     * This method creates a new DateMidnight using the midnight millisecond value\n+     * and the new chronology. If the same or similar chronology is specified, but\n+     * with a different time zone, the day may change. This occurs because the new\n+     * DateMidnight rounds down the millisecond value to get to midnight, and the\n+     * time zone change may result in a rounding down to a different day.\n+     * <p>\n+     * For example, changing time zone from London (+00:00) to Paris (+01:00) will\n+     * retain the same day, but changing from Paris to London will change the day.\n+     * (When its midnight in London its the same day in Paris, but when its midnight\n+     * in Paris its still the previous day in London)\n+     * <p>\n+     * To avoid these unusual effects, use {@link #withZoneRetainFields(DateTimeZone)}\n+     * to change time zones.\n+     *\n+     * @param newChronology  the new chronology\n+     * @return a copy of this instant with a different chronology\n+     */\n+    public DateMidnight withChronology(Chronology newChronology) {\n+        return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with a different time zone, preserving the day\n+     * The returned object will have a local time of midnight in the new zone on\n+     * the same day as the original instant.\n+     *\n+     * @param newZone  the new time zone, null means default\n+     * @return a copy of this instant with a different time zone\n+     */\n+    public DateMidnight withZoneRetainFields(DateTimeZone newZone) {\n+        newZone = DateTimeUtils.getZone(newZone);\n+        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n+        if (newZone == originalZone) {\n+            return this;\n+        }\n+        \n+        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n+        return new DateMidnight(millis, getChronology().withZone(newZone));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the partial set of fields replacing those\n+     * from this instance.\n+     * <p>\n+     * For example, if the partial is a <code>LocalDate</code> then the date fields\n+     * would be changed in the returned instance.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this datetime, null ignored\n+     * @return a copy of this datetime with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public DateMidnight withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withMillis(getChronology().set(partial, getMillis()));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day of month\n+     * field would be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * DateTime updated = dt.dayOfMonth().setCopy(6);\n+     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this datetime with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public DateMidnight withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * DateMidnight added = dt.withFieldAdded(DateTimeFieldType.year(), 6);\n+     * DateMidnight added = dt.plusYears(6);\n+     * DateMidnight added = dt.year().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this datetime with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight withDurationAdded(long durationToAdd, int scalar) {\n+        if (durationToAdd == 0 || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+        if (durationToAdd == null || scalar == 0) {\n+            return this;\n+        }\n+        return withDurationAdded(durationToAdd.getMillis(), scalar);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(period, getMillis(), scalar);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified duration added.\n+     * <p>\n+     * If the amount is zero, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration, in millis, to add to this one\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight plus(long duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight plus(ReadableDuration duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date plus the specified number of years.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateMidnight added = dt.plusYears(6);\n+     * DateMidnight added = dt.plus(Period.years(6));\n+     * DateMidnight added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new datetime plus the increased years\n+     * @since 1.1\n+     */\n+    public DateMidnight plusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().add(getMillis(), years);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date plus the specified number of months.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateMidnight added = dt.plusMonths(6);\n+     * DateMidnight added = dt.plus(Period.months(6));\n+     * DateMidnight added = dt.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new datetime plus the increased months\n+     * @since 1.1\n+     */\n+    public DateMidnight plusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().add(getMillis(), months);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date plus the specified number of weeks.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateMidnight added = dt.plusWeeks(6);\n+     * DateMidnight added = dt.plus(Period.weeks(6));\n+     * DateMidnight added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new datetime plus the increased weeks\n+     * @since 1.1\n+     */\n+    public DateMidnight plusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().add(getMillis(), weeks);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date plus the specified number of days.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateMidnight added = dt.plusDays(6);\n+     * DateMidnight added = dt.plus(Period.days(6));\n+     * DateMidnight added = dt.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new datetime plus the increased days\n+     * @since 1.1\n+     */\n+    public DateMidnight plusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().add(getMillis(), days);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration, in millis, to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight minus(long duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight minus(ReadableDuration duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this datetime with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateMidnight minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date minus the specified number of years.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusYears(6);\n+     * DateTime subtracted = dt.minus(Period.years(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new datetime minus the increased years\n+     * @since 1.1\n+     */\n+    public DateMidnight minusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().subtract(getMillis(), years);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date minus the specified number of months.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateMidnight subtracted = dt.minusMonths(6);\n+     * DateMidnight subtracted = dt.minus(Period.months(6));\n+     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new datetime minus the increased months\n+     * @since 1.1\n+     */\n+    public DateMidnight minusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().subtract(getMillis(), months);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date minus the specified number of weeks.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateMidnight subtracted = dt.minusWeeks(6);\n+     * DateMidnight subtracted = dt.minus(Period.weeks(6));\n+     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to subtract, may be negative\n+     * @return the new datetime minus the increased weeks\n+     * @since 1.1\n+     */\n+    public DateMidnight minusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().subtract(getMillis(), weeks);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date minus the specified number of days.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateMidnight subtracted = dt.minusDays(6);\n+     * DateMidnight subtracted = dt.minus(Period.days(6));\n+     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new datetime minus the increased days\n+     * @since 1.1\n+     */\n+    public DateMidnight minusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().subtract(getMillis(), days);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many useful methods.\n+     *\n+     * @param type  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        DateTimeField field = type.getField(getChronology());\n+        if (field.isSupported() == false) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return new Property(this, field);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a <code>YearMonthDay</code> using the\n+     * same date and chronology.\n+     * \n+     * @return a YearMonthDay using the same millis and chronology\n+     * @deprecated Use LocalDate instead of YearMonthDay\n+     */\n+    public YearMonthDay toYearMonthDay() {\n+        return new YearMonthDay(getMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts this object to a <code>LocalDate</code> with the\n+     * same date and chronology.\n+     *\n+     * @return a LocalDate with the same date and chronology\n+     * @since 1.3\n+     */\n+    public LocalDate toLocalDate() {\n+        return new LocalDate(getMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts this object to an <code>Interval</code> encompassing\n+     * the whole of this day.\n+     * <p>\n+     * The interval starts at midnight 00:00 and ends at 00:00 the following day,\n+     * (which is not included in the interval, as intervals are half-open).\n+     * \n+     * @return an interval over the day\n+     */\n+    public Interval toInterval() {\n+        Chronology chrono = getChronology();\n+        long start = getMillis();\n+        long end = DurationFieldType.days().getField(chrono).add(start, 1);\n+        return new Interval(start, end, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the era field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * era changed.\n+     *\n+     * @param era  the era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withEra(int era) {\n+        return withMillis(getChronology().era().set(getMillis(), era));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the century of era field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * century of era changed.\n+     *\n+     * @param centuryOfEra  the centurey of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withCenturyOfEra(int centuryOfEra) {\n+        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the year of era field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of era changed.\n+     *\n+     * @param yearOfEra  the year of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withYearOfEra(int yearOfEra) {\n+        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the year of century field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of century changed.\n+     *\n+     * @param yearOfCentury  the year of century to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withYearOfCentury(int yearOfCentury) {\n+        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the year field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year changed.\n+     *\n+     * @param year  the year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withYear(int year) {\n+        return withMillis(getChronology().year().set(getMillis(), year));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the weekyear field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * weekyear changed.\n+     *\n+     * @param weekyear  the weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withWeekyear(int weekyear) {\n+        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the month of year field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withMonthOfYear(int monthOfYear) {\n+        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the week of weekyear field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * week of weekyear changed.\n+     *\n+     * @param weekOfWeekyear  the week of weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) {\n+        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the day of year field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of year changed.\n+     *\n+     * @param dayOfYear  the day of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withDayOfYear(int dayOfYear) {\n+        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the day of month field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of month changed.\n+     *\n+     * @param dayOfMonth  the day of month to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withDayOfMonth(int dayOfMonth) {\n+        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the day of week field updated.\n+     * <p>\n+     * DateMidnight is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of week changed.\n+     *\n+     * @param dayOfWeek  the day of week to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateMidnight withDayOfWeek(int dayOfWeek) {\n+        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n+    }\n+\n+    // Date properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property which provides access to advanced functionality.\n+     * \n+     * @return the era property\n+     */\n+    public Property era() {\n+        return new Property(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property which provides access to advanced functionality.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property which provides access to advanced functionality.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property which provides access to advanced functionality.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property which provides access to advanced functionality.\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property which provides access to advanced functionality.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property which provides access to advanced functionality.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property which provides access to advanced functionality.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property which provides access to advanced functionality.\n+     * \n+     * @return the day of year property\n+     */\n+    public Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property which provides access to advanced functionality.\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of week property which provides access to advanced functionality.\n+     * \n+     * @return the day of week property\n+     */\n+    public Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * DateMidnight.Property binds a DateMidnight to a DateTimeField allowing powerful\n+     * datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * DateMidnight dt = new DateMidnight(1972, 12, 3);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.monthOfYear().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return new instances\n+     * of DateMidnight - they do not modify the original. The example below yields two\n+     * independent immutable date objects 20 years apart.\n+     * <pre>\n+     * DateMidnight dt = new DateMidnight(1972, 12, 3);\n+     * DateMidnight dt20 = dt.year().addToCopy(20);\n+     * </pre>\n+     * Serious modification of dates (ie. more than just changing one or two fields)\n+     * should use the {@link org.joda.time.MutableDateTime MutableDateTime} class.\n+     * <p>\n+     * DateMidnight.Property itself is thread-safe and immutable.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.0\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+    \n+        /** Serialization lock */\n+        private static final long serialVersionUID = 257629620L;\n+        \n+        /** The instant this property is working against */\n+        private DateMidnight iInstant;\n+        /** The field this property is working against */\n+        private DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(DateMidnight instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+\n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+\n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (DateMidnight) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+\n+        /**\n+         * Gets the milliseconds of the datetime that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getMillis();\n+        }\n+\n+        /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+\n+        /**\n+         * Gets the datetime being used.\n+         * \n+         * @return the datetime\n+         */\n+        public DateMidnight getDateMidnight() {\n+            return iInstant;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this DateMidnight.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateMidnight addToCopy(int value) {\n+            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n+        }\n+\n+        /**\n+         * Adds to this field in a copy of this DateMidnight.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateMidnight addToCopy(long value) {\n+            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n+        }\n+\n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this DateMidnight.\n+         * A wrapped operation only changes this field.\n+         * Thus 31st January addWrapField one day goes to the 1st January.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateMidnight addWrapFieldToCopy(int value) {\n+            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the DateMidnight.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateMidnight setCopy(int value) {\n+            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));\n+        }\n+    \n+        /**\n+         * Sets this field in a copy of the DateMidnight to a parsed text value.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public DateMidnight setCopy(String text, Locale locale) {\n+            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the DateMidnight to a parsed text value.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateMidnight to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the DateMidnight with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public DateMidnight setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new DateMidnight with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * This operation is useful for obtaining a DateTime on the last day\n+         * of the month, as month lengths vary.\n+         * <pre>\n+         * DateMidnight lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n+         * </pre>\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the DateMidnight with this field set to its maximum\n+         * @since 1.2\n+         */\n+        public DateMidnight withMaximumValue() {\n+            return setCopy(getMaximumValue());\n+        }\n+        \n+        /**\n+         * Returns a new DateMidnight with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The DateMidnight attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the DateMidnight with this field set to its minimum\n+         * @since 1.2\n+         */\n+        public DateMidnight withMinimumValue() {\n+            return setCopy(getMinimumValue());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this DateMidnight.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundFloorCopy() {\n+            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n+        }\n+\n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this DateMidnight.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundCeilingCopy() {\n+            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n+        }\n+\n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,\n+         * favoring the floor if halfway.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundHalfFloorCopy() {\n+            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n+        }\n+\n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,\n+         * favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundHalfCeilingCopy() {\n+            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n+        }\n+\n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight.\n+         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.\n+         *\n+         * @return a copy of the DateMidnight with the field value changed\n+         */\n+        public DateMidnight roundHalfEvenCopy() {\n+            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DateTime.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BaseDateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * DateTime is the standard implementation of an unmodifiable datetime class.\n+ * <p>\n+ * <code>DateTime</code> is the most widely used implementation of\n+ * {@link ReadableInstant}. As with all instants, it represents an exact\n+ * point on the time-line, but limited to the precision of milliseconds.\n+ * A <code>DateTime</code> calculates its fields with respect to a\n+ * {@link DateTimeZone time zone}.\n+ * <p>\n+ * Internally, the class holds two pieces of data. Firstly, it holds the\n+ * datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.\n+ * Secondly, it holds a {@link Chronology} which determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is {@link ISOChronology} which is the agreed\n+ * international standard and compatible with the modern Gregorian calendar.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ * <p>\n+ * DateTime is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Kandarp Shah\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see MutableDateTime\n+ */\n+public final class DateTime\n+        extends BaseDateTime\n+        implements ReadableDateTime, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -5171125899451703815L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n+     */\n+    public DateTime() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public DateTime(DateTimeZone zone) {\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateTime(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public DateTime(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public DateTime(long instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateTime(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used. Otherwise, ISO default is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateTime(Object instant) {\n+        super(instant, (Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used, but with the time zone adjusted.\n+     * Otherwise, ISO is used in the specified time zone.\n+     * If the specified time zone is null, the default zone is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param zone  the time zone, null means default time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateTime(Object instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Any chronology implied by the object (such as GregorianCalendar does)\n+     * is ignored.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISO in default zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public DateTime(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @since 2.0\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour) {\n+        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param zone  the time zone, null means default time zone\n+     * @since 2.0\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            DateTimeZone zone) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, 0, 0, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @since 2.0\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            Chronology chronology) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, 0, 0, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @since 2.0\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute) {\n+        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param zone  the time zone, null means default time zone\n+     * @since 2.0\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            DateTimeZone zone) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, 0, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @since 2.0\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            Chronology chronology) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            DateTimeZone zone) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public DateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as a DateTime by returning <code>this</code>.\n+     * \n+     * @return <code>this</code>\n+     */\n+    public DateTime toDateTime() {\n+        return this;\n+    }\n+\n+    /**\n+     * Get this object as a DateTime using ISOChronology in the default zone,\n+     * returning <code>this</code> if possible.\n+     * \n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTimeISO() {\n+        if (getChronology() == ISOChronology.getInstance()) {\n+            return this;\n+        }\n+        return super.toDateTimeISO();\n+    }\n+\n+    /**\n+     * Get this object as a DateTime, returning <code>this</code> if possible.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        if (getZone() == zone) {\n+            return this;\n+        }\n+        return super.toDateTime(zone);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime, returning <code>this</code> if possible.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime(Chronology chronology) {\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        if (getChronology() == chronology) {\n+            return this;\n+        }\n+        return super.toDateTime(chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with different millis.\n+     * <p>\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     * Only the millis will change, the chronology and time zone are kept.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this datetime with different millis\n+     */\n+    public DateTime withMillis(long newMillis) {\n+        return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with a different chronology.\n+     * <p>\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     * Only the chronology will change, the millis are kept.\n+     *\n+     * @param newChronology  the new chronology, null means ISO default\n+     * @return a copy of this datetime with a different chronology\n+     */\n+    public DateTime withChronology(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with a different time zone, preserving the\n+     * millisecond instant.\n+     * <p>\n+     * This method is useful for finding the local time in another timezone.\n+     * For example, if this instant holds 12:30 in Europe/London, the result\n+     * from this method with Europe/Paris would be 13:30.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * This method changes the time zone, and does not change the\n+     * millisecond instant, with the effect that the field values usually change.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newZone  the new time zone\n+     * @return a copy of this datetime with a different time zone\n+     * @see #withZoneRetainFields\n+     */\n+    public DateTime withZone(DateTimeZone newZone) {\n+        return withChronology(getChronology().withZone(newZone));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with a different time zone, preserving the\n+     * field values.\n+     * <p>\n+     * This method is useful for finding the millisecond time in another timezone.\n+     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n+     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * This method changes the time zone and the millisecond instant to keep\n+     * the field values the same.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newZone  the new time zone, null means default\n+     * @return a copy of this datetime with a different time zone\n+     * @see #withZone\n+     */\n+    public DateTime withZoneRetainFields(DateTimeZone newZone) {\n+        newZone = DateTimeUtils.getZone(newZone);\n+        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n+        if (newZone == originalZone) {\n+            return this;\n+        }\n+        \n+        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n+        return new DateTime(millis, getChronology().withZone(newZone));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the specified date, retaining the time fields.\n+     * <p>\n+     * If the date is already the date passed in, then <code>this</code> is returned.\n+     * <p>\n+     * To set a single field use the properties, for example:\n+     * <pre>\n+     * DateTime set = monthOfYear().setCopy(6);\n+     * </pre>\n+     *\n+     * @param year  the new year value\n+     * @param monthOfYear  the new monthOfYear value\n+     * @param dayOfMonth  the new dayOfMonth value\n+     * @return a copy of this datetime with a different date\n+     * @throws IllegalArgumentException if any value if invalid\n+     */\n+    public DateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n+        Chronology chrono = getChronology();\n+        long instant = getMillis();\n+        instant = chrono.year().set(instant, year);\n+        instant = chrono.monthOfYear().set(instant, monthOfYear);\n+        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified time, retaining the date fields.\n+     * <p>\n+     * If the time is already the time passed in, then <code>this</code> is returned.\n+     * <p>\n+     * To set a single field use the properties, for example:\n+     * <pre>\n+     * DateTime set = dt.hourOfDay().setCopy(6);\n+     * </pre>\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @return a copy of this datetime with a different time\n+     * @throws IllegalArgumentException if any value if invalid\n+     */\n+    public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+        Chronology chrono = getChronology();\n+        long instant = getMillis();\n+        instant = chrono.hourOfDay().set(instant, hourOfDay);\n+        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n+        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n+        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the partial set of fields replacing those\n+     * from this instance.\n+     * <p>\n+     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n+     * would be changed in the returned instance.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this datetime, null ignored\n+     * @return a copy of this datetime with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public DateTime withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withMillis(getChronology().set(partial, getMillis()));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n+     * field would be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * DateTime updated = dt.dayOfMonth().setCopy(6);\n+     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this datetime with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public DateTime withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * DateTime added = dt.plusYears(6);\n+     * DateTime added = dt.plus(Period.years(6));\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this datetime with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime withDurationAdded(long durationToAdd, int scalar) {\n+        if (durationToAdd == 0 || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+        if (durationToAdd == null || scalar == 0) {\n+            return this;\n+        }\n+        return withDurationAdded(durationToAdd.getMillis(), scalar);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(period, getMillis(), scalar);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \n+     * @param duration  the duration, in millis, to add to this one\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime plus(long duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \n+     * @param duration  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime plus(ReadableDuration duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified period added.\n+     * <p>\n+     * This method will add each element of the period one by one, from largest\n+     * to smallest, adjusting the datetime to be accurate between each.\n+     * <p>\n+     * Thus, adding a period of one month and one day to 2007-03-31 will\n+     * work as follows:\n+     * First add one month and adjust, resulting in 2007-04-30\n+     * Then add one day and adjust, resulting in 2007-05-01.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime plus the specified number of years.\n+     * <p>\n+     * The calculation will do its best to only change the year field\n+     * retaining the same month of year.\n+     * However, in certain circumstances, it may be necessary to alter\n+     * smaller fields. For example, 2008-02-29 plus one year cannot result\n+     * in 2009-02-29, so the day of month is adjusted to 2009-02-28.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.plusYears(6);\n+     * DateTime added = dt.plus(Period.years(6));\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new datetime plus the increased years\n+     * @since 1.1\n+     */\n+    public DateTime plusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().add(getMillis(), years);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of months.\n+     * <p>\n+     * The calculation will do its best to only change the month field\n+     * retaining the same day of month.\n+     * However, in certain circumstances, it may be necessary to alter\n+     * smaller fields. For example, 2007-03-31 plus one month cannot result\n+     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.plusMonths(6);\n+     * DateTime added = dt.plus(Period.months(6));\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new datetime plus the increased months\n+     * @since 1.1\n+     */\n+    public DateTime plusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().add(getMillis(), months);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of weeks.\n+     * <p>\n+     * The calculation operates as if it were adding the equivalent in days.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.plusWeeks(6);\n+     * DateTime added = dt.plus(Period.weeks(6));\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new datetime plus the increased weeks\n+     * @since 1.1\n+     */\n+    public DateTime plusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().add(getMillis(), weeks);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of days.\n+     * <p>\n+     * The calculation will do its best to only change the day field\n+     * retaining the same time of day.\n+     * However, in certain circumstances, typically daylight savings cutover,\n+     * it may be necessary to alter the time fields.\n+     * <p>\n+     * In spring an hour is typically removed. If adding one day results in\n+     * the time being within the cutover then the time is adjusted to be\n+     * within summer time. For example, if the cutover is from 01:59 to 03:00\n+     * and the result of this method would have been 02:30, then the result\n+     * will be adjusted to 03:30.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.plusDays(6);\n+     * DateTime added = dt.plus(Period.days(6));\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new datetime plus the increased days\n+     * @since 1.1\n+     */\n+    public DateTime plusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().add(getMillis(), days);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of hours.\n+     * <p>\n+     * The calculation will add a duration equivalent to the number of hours\n+     * expressed in milliseconds.\n+     * <p>\n+     * For example, if a spring daylight savings cutover is from 01:59 to 03:00\n+     * then adding one hour to 01:30 will result in 03:30. This is a duration\n+     * of one hour later, even though the hour field value changed from 1 to 3.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.plusHours(6);\n+     * DateTime added = dt.plus(Period.hours(6));\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new datetime plus the increased hours\n+     * @since 1.1\n+     */\n+    public DateTime plusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().add(getMillis(), hours);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of minutes.\n+     * <p>\n+     * The calculation will add a duration equivalent to the number of minutes\n+     * expressed in milliseconds.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.plusMinutes(6);\n+     * DateTime added = dt.plus(Period.minutes(6));\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new datetime plus the increased minutes\n+     * @since 1.1\n+     */\n+    public DateTime plusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().add(getMillis(), minutes);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of seconds.\n+     * <p>\n+     * The calculation will add a duration equivalent to the number of seconds\n+     * expressed in milliseconds.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.plusSeconds(6);\n+     * DateTime added = dt.plus(Period.seconds(6));\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new datetime plus the increased seconds\n+     * @since 1.1\n+     */\n+    public DateTime plusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().add(getMillis(), seconds);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of millis.\n+     * <p>\n+     * The calculation will add a duration equivalent to the number of milliseconds.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime added = dt.plusMillis(6);\n+     * DateTime added = dt.plus(Period.millis(6));\n+     * DateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new datetime plus the increased millis\n+     * @since 1.1\n+     */\n+    public DateTime plusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().add(getMillis(), millis);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \n+     * @param duration  the duration, in millis, to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime minus(long duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime minus(ReadableDuration duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified period taken away.\n+     * <p>\n+     * This method will subtract each element of the period one by one, from\n+     * largest to smallest, adjusting the datetime to be accurate between each.\n+     * <p>\n+     * Thus, subtracting a period of one month and one day from 2007-05-31 will\n+     * work as follows:\n+     * First subtract one month and adjust, resulting in 2007-04-30\n+     * Then subtract one day and adjust, resulting in 2007-04-29.\n+     * Note that the day has been adjusted by two.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this datetime with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime minus the specified number of years.\n+     * <p>\n+     * The calculation will do its best to only change the year field\n+     * retaining the same month of year.\n+     * However, in certain circumstances, it may be necessary to alter\n+     * smaller fields. For example, 2008-02-29 minus one year cannot result\n+     * in 2007-02-29, so the day of month is adjusted to 2007-02-28.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusYears(6);\n+     * DateTime subtracted = dt.minus(Period.years(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new datetime minus the increased years\n+     * @since 1.1\n+     */\n+    public DateTime minusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().subtract(getMillis(), years);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of months.\n+     * <p>\n+     * The calculation will do its best to only change the month field\n+     * retaining the same day of month.\n+     * However, in certain circumstances, it may be necessary to alter\n+     * smaller fields. For example, 2007-05-31 minus one month cannot result\n+     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusMonths(6);\n+     * DateTime subtracted = dt.minus(Period.months(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new datetime minus the increased months\n+     * @since 1.1\n+     */\n+    public DateTime minusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().subtract(getMillis(), months);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of weeks.\n+     * <p>\n+     * The calculation operates as if it were subtracting the equivalent in days.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusWeeks(6);\n+     * DateTime subtracted = dt.minus(Period.weeks(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to subtract, may be negative\n+     * @return the new datetime minus the increased weeks\n+     * @since 1.1\n+     */\n+    public DateTime minusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().subtract(getMillis(), weeks);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of days.\n+     * <p>\n+     * The calculation will do its best to only change the day field\n+     * retaining the same time of day.\n+     * However, in certain circumstances, typically daylight savings cutover,\n+     * it may be necessary to alter the time fields.\n+     * <p>\n+     * In spring an hour is typically removed. If subtracting one day results\n+     * in the time being within the cutover then the time is adjusted to be\n+     * within summer time. For example, if the cutover is from 01:59 to 03:00\n+     * and the result of this method would have been 02:30, then the result\n+     * will be adjusted to 03:30.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusDays(6);\n+     * DateTime subtracted = dt.minus(Period.days(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new datetime minus the increased days\n+     * @since 1.1\n+     */\n+    public DateTime minusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().subtract(getMillis(), days);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of hours.\n+     * <p>\n+     * The calculation will subtract a duration equivalent to the number of\n+     * hours expressed in milliseconds.\n+     * <p>\n+     * For example, if a spring daylight savings cutover is from 01:59 to 03:00\n+     * then subtracting one hour from 03:30 will result in 01:30. This is a\n+     * duration of one hour earlier, even though the hour field value changed\n+     * from 3 to 1.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusHours(6);\n+     * DateTime subtracted = dt.minus(Period.hours(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to subtract, may be negative\n+     * @return the new datetime minus the increased hours\n+     * @since 1.1\n+     */\n+    public DateTime minusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().subtract(getMillis(), hours);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of minutes.\n+     * <p>\n+     * The calculation will subtract a duration equivalent to the number of\n+     * minutes expressed in milliseconds.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusMinutes(6);\n+     * DateTime subtracted = dt.minus(Period.minutes(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to subtract, may be negative\n+     * @return the new datetime minus the increased minutes\n+     * @since 1.1\n+     */\n+    public DateTime minusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().subtract(getMillis(), minutes);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of seconds.\n+     * <p>\n+     * The calculation will subtract a duration equivalent to the number of\n+     * seconds expressed in milliseconds.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusSeconds(6);\n+     * DateTime subtracted = dt.minus(Period.seconds(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to subtract, may be negative\n+     * @return the new datetime minus the increased seconds\n+     * @since 1.1\n+     */\n+    public DateTime minusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().subtract(getMillis(), seconds);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of millis.\n+     * <p>\n+     * The calculation will subtract a duration equivalent to the number of\n+     * milliseconds.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * DateTime subtracted = dt.minusMillis(6);\n+     * DateTime subtracted = dt.minus(Period.millis(6));\n+     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n+     * </pre>\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     *\n+     * @param millis  the amount of millis to subtract, may be negative\n+     * @return the new datetime minus the increased millis\n+     * @since 1.1\n+     */\n+    public DateTime minusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().subtract(getMillis(), millis);\n+        return withMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many useful methods.\n+     *\n+     * @param type  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        DateTimeField field = type.getField(getChronology());\n+        if (field.isSupported() == false) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return new Property(this, field);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a <code>DateMidnight</code> using the\n+     * same millis and chronology.\n+     * \n+     * @return a DateMidnight using the same millis and chronology\n+     */\n+    public DateMidnight toDateMidnight() {\n+        return new DateMidnight(getMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts this object to a <code>YearMonthDay</code> using the\n+     * same millis and chronology.\n+     * \n+     * @return a YearMonthDay using the same millis and chronology\n+     * @deprecated Use LocalDate instead of YearMonthDay\n+     */\n+    public YearMonthDay toYearMonthDay() {\n+        return new YearMonthDay(getMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts this object to a <code>TimeOfDay</code> using the\n+     * same millis and chronology.\n+     * \n+     * @return a TimeOfDay using the same millis and chronology\n+     * @deprecated Use LocalTime instead of TimeOfDay\n+     */\n+    public TimeOfDay toTimeOfDay() {\n+        return new TimeOfDay(getMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts this object to a <code>LocalDateTime</code> with\n+     * the same datetime and chronology.\n+     *\n+     * @return a LocalDateTime with the same datetime and chronology\n+     * @since 1.3\n+     */\n+    public LocalDateTime toLocalDateTime() {\n+        return new LocalDateTime(getMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts this object to a <code>LocalDate</code> with the\n+     * same date and chronology.\n+     *\n+     * @return a LocalDate with the same date and chronology\n+     * @since 1.3\n+     */\n+    public LocalDate toLocalDate() {\n+        return new LocalDate(getMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts this object to a <code>LocalTime</code> with the\n+     * same time and chronology.\n+     *\n+     * @return a LocalTime with the same time and chronology\n+     * @since 1.3\n+     */\n+    public LocalTime toLocalTime() {\n+        return new LocalTime(getMillis(), getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the era field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * era changed.\n+     *\n+     * @param era  the era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withEra(int era) {\n+        return withMillis(getChronology().era().set(getMillis(), era));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the century of era field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * century of era changed.\n+     *\n+     * @param centuryOfEra  the centurey of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withCenturyOfEra(int centuryOfEra) {\n+        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the year of era field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of era changed.\n+     *\n+     * @param yearOfEra  the year of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withYearOfEra(int yearOfEra) {\n+        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the year of century field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of century changed.\n+     *\n+     * @param yearOfCentury  the year of century to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withYearOfCentury(int yearOfCentury) {\n+        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the year field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year changed.\n+     *\n+     * @param year  the year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withYear(int year) {\n+        return withMillis(getChronology().year().set(getMillis(), year));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the weekyear field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * weekyear changed.\n+     *\n+     * @param weekyear  the weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withWeekyear(int weekyear) {\n+        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the month of year field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withMonthOfYear(int monthOfYear) {\n+        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the week of weekyear field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * week of weekyear changed.\n+     *\n+     * @param weekOfWeekyear  the week of weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withWeekOfWeekyear(int weekOfWeekyear) {\n+        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the day of year field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of year changed.\n+     *\n+     * @param dayOfYear  the day of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withDayOfYear(int dayOfYear) {\n+        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the day of month field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of month changed.\n+     *\n+     * @param dayOfMonth  the day of month to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withDayOfMonth(int dayOfMonth) {\n+        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the day of week field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of week changed.\n+     *\n+     * @param dayOfWeek  the day of week to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withDayOfWeek(int dayOfWeek) {\n+        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the hour of day field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * hour of day changed.\n+     *\n+     * @param hour  the hour of day to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withHourOfDay(int hour) {\n+        return withMillis(getChronology().hourOfDay().set(getMillis(), hour));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the minute of hour updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * minute of hour changed.\n+     *\n+     * @param minute  the minute of hour to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withMinuteOfHour(int minute) {\n+        return withMillis(getChronology().minuteOfHour().set(getMillis(), minute));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the second of minute field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * second of minute changed.\n+     *\n+     * @param second  the second of minute to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withSecondOfMinute(int second) {\n+        return withMillis(getChronology().secondOfMinute().set(getMillis(), second));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the millis of second field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * millis of second changed.\n+     *\n+     * @param millis  the millis of second to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withMillisOfSecond(int millis) {\n+        return withMillis(getChronology().millisOfSecond().set(getMillis(), millis));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the millis of day field updated.\n+     * <p>\n+     * DateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * millis of day changed.\n+     *\n+     * @param millis  the millis of day to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public DateTime withMillisOfDay(int millis) {\n+        return withMillis(getChronology().millisOfDay().set(getMillis(), millis));\n+    }\n+\n+    // Date properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property which provides access to advanced functionality.\n+     * \n+     * @return the era property\n+     */\n+    public Property era() {\n+        return new Property(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property which provides access to advanced functionality.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property which provides access to advanced functionality.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property which provides access to advanced functionality.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property which provides access to advanced functionality.\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property which provides access to advanced functionality.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property which provides access to advanced functionality.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property which provides access to advanced functionality.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property which provides access to advanced functionality.\n+     * \n+     * @return the day of year property\n+     */\n+    public Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property which provides access to advanced functionality.\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of week property which provides access to advanced functionality.\n+     * \n+     * @return the day of week property\n+     */\n+    public Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n+    }\n+\n+    // Time properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property which provides access to advanced functionality.\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of day property which provides access to advanced functionality.\n+     * \n+     * @return the minute of day property\n+     */\n+    public Property minuteOfDay() {\n+        return new Property(this, getChronology().minuteOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property which provides access to advanced functionality.\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of day property which provides access to advanced functionality.\n+     * \n+     * @return the second of day property\n+     */\n+    public Property secondOfDay() {\n+        return new Property(this, getChronology().secondOfDay());\n+    }\n+\n+    /**\n+     * Get the second of minute field property which provides access to advanced functionality.\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of day property which provides access to advanced functionality.\n+     * \n+     * @return the millis of day property\n+     */\n+    public Property millisOfDay() {\n+        return new Property(this, getChronology().millisOfDay());\n+    }\n+\n+    /**\n+     * Get the millis of second property which provides access to advanced functionality.\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, getChronology().millisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * DateTime.Property binds a DateTime to a DateTimeField allowing powerful\n+     * datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.month().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return new instances\n+     * of DateTime - they do not modify the original. The example below yields two\n+     * independent immutable date objects 20 years apart.\n+     * <pre>\n+     * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);\n+     * DateTime dt20 = dt.year().addToCopy(20);\n+     * </pre>\n+     * Serious modification of dates (ie. more than just changing one or two fields)\n+     * should use the {@link org.joda.time.MutableDateTime MutableDateTime} class.\n+     * <p>\n+     * DateTime.Propery itself is thread-safe and immutable, as well as the\n+     * DateTime being operated on.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.0\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -6983323811635733510L;\n+        \n+        /** The instant this property is working against */\n+        private DateTime iInstant;\n+        /** The field this property is working against */\n+        private DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(DateTime instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+\n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (DateTime) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the milliseconds of the datetime that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getMillis();\n+        }\n+        \n+        /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n+         * Gets the datetime being used.\n+         * \n+         * @return the datetime\n+         */\n+        public DateTime getDateTime() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this DateTime.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateTime addToCopy(int value) {\n+            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field in a copy of this DateTime.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateTime addToCopy(long value) {\n+            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this DateTime.\n+         * A wrapped operation only changes this field.\n+         * Thus 31st January addWrapField one day goes to the 1st January.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateTime addWrapFieldToCopy(int value) {\n+            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the DateTime.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public DateTime setCopy(int value) {\n+            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the DateTime to a parsed text value.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public DateTime setCopy(String text, Locale locale) {\n+            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the DateTime to a parsed text value.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         * This operation is faster than converting a DateTime to a MutableDateTime\n+         * and back again when setting one field. When setting multiple fields,\n+         * it is generally quicker to make the conversion to MutableDateTime.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the DateTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public DateTime setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new DateTime with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * This operation is useful for obtaining a DateTime on the last day\n+         * of the month, as month lengths vary.\n+         * <pre>\n+         * DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n+         * </pre>\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the DateTime with this field set to its maximum\n+         * @since 1.2\n+         */\n+        public DateTime withMaximumValue() {\n+            return setCopy(getMaximumValue());\n+        }\n+        \n+        /**\n+         * Returns a new DateTime with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The DateTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the DateTime with this field set to its minimum\n+         * @since 1.2\n+         */\n+        public DateTime withMinimumValue() {\n+            return setCopy(getMinimumValue());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this DateTime.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundFloorCopy() {\n+            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this DateTime.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundCeilingCopy() {\n+            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n+         * favoring the floor if halfway.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundHalfFloorCopy() {\n+            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this DateTime,\n+         * favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundHalfCeilingCopy() {\n+            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * DateTime.  If halfway, the ceiling is favored over the floor only if\n+         * it makes this field's value even.\n+         *\n+         * @return a copy of the DateTime with the field value changed\n+         */\n+        public DateTime roundHalfEvenCopy() {\n+            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DateTimeComparator.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * DateTimeComparator provides comparators to compare one date with another.\n+ * <p>\n+ * Dates may be specified using any object recognised by the\n+ * {@link org.joda.time.convert.ConverterManager ConverterManager} class.\n+ * <p>\n+ * The default objects recognised by the comparator are:\n+ * <ul>\n+ * <li>ReadableInstant\n+ * <li>String\n+ * <li>Calendar\n+ * <li>Date\n+ * <li>Long (milliseconds)\n+ * <li>null (now)\n+ * </ul>\n+ *\n+ * <p>\n+ * DateTimeComparator is thread-safe and immutable.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DateTimeComparator implements Comparator<Object>, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -6097339773320178364L;\n+\n+    /** Singleton instance */\n+    private static final DateTimeComparator ALL_INSTANCE = new DateTimeComparator(null, null);\n+    /** Singleton instance */\n+    private static final DateTimeComparator DATE_INSTANCE = new DateTimeComparator(DateTimeFieldType.dayOfYear(), null);\n+    /** Singleton instance */\n+    private static final DateTimeComparator TIME_INSTANCE = new DateTimeComparator(null, DateTimeFieldType.dayOfYear());\n+\n+    /** The lower limit of fields to compare, null if no limit */\n+    private final DateTimeFieldType iLowerLimit;\n+    /** The upper limit of fields to compare, null if no limit */\n+    private final DateTimeFieldType iUpperLimit;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a DateTimeComparator the compares the entire date time value.\n+     * \n+     * @return a comparator over all fields\n+     */\n+    public static DateTimeComparator getInstance() {\n+        return ALL_INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a DateTimeComparator with a lower limit only. Fields of a\n+     * magnitude less than the lower limit are excluded from comparisons.\n+     *\n+     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n+     * @return a comparator over all fields above the lower limit\n+     */\n+    public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit) {\n+        return getInstance(lowerLimit, null);\n+    }\n+\n+    /**\n+     * Returns a DateTimeComparator with a lower and upper limit. Fields of a\n+     * magnitude less than the lower limit are excluded from comparisons.\n+     * Fields of a magnitude greater than or equal to the upper limit are also\n+     * excluded from comparisons. Either limit may be specified as null, which\n+     * indicates an unbounded limit.\n+     *\n+     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n+     * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit\n+     * @return a comparator over all fields between the limits\n+     */\n+    public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) {\n+        if (lowerLimit == null && upperLimit == null) {\n+            return ALL_INSTANCE;\n+        }\n+        if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) {\n+            return DATE_INSTANCE;\n+        }\n+        if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) {\n+            return TIME_INSTANCE;\n+        }\n+        return new DateTimeComparator(lowerLimit, upperLimit);\n+    }\n+\n+    /**\n+     * Returns a comparator that only considers date fields.\n+     * Time of day is ignored.\n+     * \n+     * @return a comparator over all date fields\n+     */\n+    public static DateTimeComparator getDateOnlyInstance() {\n+        return DATE_INSTANCE;\n+    }\n+\n+    /**\n+     * Returns a comparator that only considers time fields.\n+     * Date is ignored.\n+     * \n+     * @return a comparator over all time fields\n+     */\n+    public static DateTimeComparator getTimeOnlyInstance() {\n+        return TIME_INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     * \n+     * @param lowerLimit  the lower field limit, null means no limit\n+     * @param upperLimit  the upper field limit, null means no limit\n+     */\n+    protected DateTimeComparator(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) {\n+        super();\n+        iLowerLimit = lowerLimit;\n+        iUpperLimit = upperLimit;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field type that represents the lower limit of comparison.\n+     * \n+     * @return the field type, null if no upper limit\n+     */\n+    public DateTimeFieldType getLowerLimit() {\n+        return iLowerLimit;\n+    }\n+\n+    /**\n+     * Gets the field type that represents the upper limit of comparison.\n+     * \n+     * @return the field type, null if no upper limit\n+     */\n+    public DateTimeFieldType getUpperLimit() {\n+        return iUpperLimit;\n+    }\n+\n+    /**\n+     * Compare two objects against only the range of date time fields as\n+     * specified in the constructor.\n+     * \n+     * @param lhsObj  the first object,\n+     *      logically on the left of a &lt; comparison, null means now\n+     * @param rhsObj  the second object,\n+     *      logically on the right of a &lt; comparison, null means now\n+     * @return zero if order does not matter,\n+     *      negative value if lhsObj &lt; rhsObj, positive value otherwise.\n+     * @throws IllegalArgumentException if either argument is not supported\n+     */\n+    public int compare(Object lhsObj, Object rhsObj) {\n+        InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj);\n+        Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null);\n+        long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono);\n+        \n+        conv = ConverterManager.getInstance().getInstantConverter(rhsObj);\n+        Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null);\n+        long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono);\n+\n+        if (iLowerLimit != null) {\n+            lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis);\n+            rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis);\n+        }\n+\n+        if (iUpperLimit != null) {\n+            lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis);\n+            rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis);\n+        }\n+\n+        if (lhsMillis < rhsMillis) {\n+            return -1;\n+        } else if (lhsMillis > rhsMillis) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Support serialization singletons.\n+     * \n+     * @return the resolved singleton instance\n+     */\n+    private Object readResolve() {\n+        return getInstance(iLowerLimit, iUpperLimit);\n+    }\n+\n+    /**\n+     * Compares this comparator to another.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object object) {\n+        if (object instanceof DateTimeComparator) {\n+            DateTimeComparator other = (DateTimeComparator) object;\n+            return (iLowerLimit == other.getLowerLimit() ||\n+                    (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) &&\n+                   (iUpperLimit == other.getUpperLimit() ||\n+                    (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit())));\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a suitable hashcode.\n+     * \n+     * @return the hashcode\n+     */\n+    public int hashCode() {\n+        return (iLowerLimit == null ? 0 : iLowerLimit.hashCode()) +\n+               (123 * (iUpperLimit == null ? 0 : iUpperLimit.hashCode()));\n+    }\n+\n+    /**\n+     * Gets a debugging string.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        if (iLowerLimit == iUpperLimit) {\n+            return \"DateTimeComparator[\"\n+                + (iLowerLimit == null ? \"\" : iLowerLimit.getName())\n+                + \"]\";\n+        } else {\n+            return \"DateTimeComparator[\"\n+                + (iLowerLimit == null ? \"\" : iLowerLimit.getName())\n+                + \"-\"\n+                + (iUpperLimit == null ? \"\" : iUpperLimit.getName())\n+                + \"]\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DateTimeConstants.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * DateTimeConstants is a non-instantiable class of constants used in\n+ * the date time system. These are the ISO8601 constants, but should be\n+ * used by all chronologies.\n+ * <p>\n+ * DateTimeConstants is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DateTimeConstants {\n+\n+    // These are ints not enumerations as they represent genuine int values\n+    /** Constant (1) representing January, the first month (ISO) */\n+    public static final int JANUARY = 1;\n+\n+    /** Constant (2) representing February, the second month (ISO) */\n+    public static final int FEBRUARY = 2;\n+\n+    /** Constant (3) representing March, the third month (ISO) */\n+    public static final int MARCH = 3;\n+\n+    /** Constant (4) representing April, the fourth month (ISO) */\n+    public static final int APRIL = 4;\n+\n+    /** Constant (5) representing May, the fifth month (ISO) */\n+    public static final int MAY = 5;\n+\n+    /** Constant (6) representing June, the sixth month (ISO) */\n+    public static final int JUNE = 6;\n+\n+    /** Constant (7) representing July, the seventh month (ISO) */\n+    public static final int JULY = 7;\n+\n+    /** Constant (8) representing August, the eighth month (ISO) */\n+    public static final int AUGUST = 8;\n+\n+    /** Constant (9) representing September, the nineth month (ISO) */\n+    public static final int SEPTEMBER = 9;\n+\n+    /** Constant (10) representing October, the tenth month (ISO) */\n+    public static final int OCTOBER = 10;\n+\n+    /** Constant (11) representing November, the eleventh month (ISO) */\n+    public static final int NOVEMBER = 11;\n+\n+    /** Constant (12) representing December, the twelfth month (ISO) */\n+    public static final int DECEMBER = 12;\n+\n+    // These are ints not enumerations as they represent genuine int values\n+    /** Constant (1) representing Monday, the first day of the week (ISO) */\n+    public static final int MONDAY = 1;\n+\n+    /** Constant (2) representing Tuesday, the second day of the week (ISO) */\n+    public static final int TUESDAY = 2;\n+\n+    /** Constant (3) representing Wednesday, the third day of the week (ISO) */\n+    public static final int WEDNESDAY = 3;\n+\n+    /** Constant (4) representing Thursday, the fourth day of the week (ISO) */\n+    public static final int THURSDAY = 4;\n+\n+    /** Constant (5) representing Friday, the fifth day of the week (ISO) */\n+    public static final int FRIDAY = 5;\n+\n+    /** Constant (6) representing Saturday, the sixth day of the week (ISO) */\n+    public static final int SATURDAY = 6;\n+\n+    /** Constant (7) representing Sunday, the seventh day of the week (ISO) */\n+    public static final int SUNDAY = 7;\n+\n+\n+    /** Constant (0) representing AM, the morning (from Calendar) */\n+    public static final int AM = 0;\n+\n+    /** Constant (1) representing PM, the afternoon (from Calendar) */\n+    public static final int PM = 1;\n+\n+\n+    /** Constant (0) representing BC, years before zero (from Calendar) */\n+    public static final int BC = 0;\n+    /** Alternative constant (0) representing BCE, Before Common Era (secular) */\n+    public static final int BCE = 0;\n+\n+    /**\n+     * Constant (1) representing AD, years after zero (from Calendar).\n+     * <p>\n+     * All new chronologies with differrent Era values should try to assign\n+     * eras as follows. The era that was in force at 1970-01-01 (ISO) is assigned\n+     * the value 1. Earlier eras are assigned sequentially smaller numbers.\n+     * Later eras are assigned sequentially greater numbers.\n+     */\n+    public static final int AD = 1;\n+    /**\n+     * Alternative constant (1) representing CE, Common Era (secular).\n+     * <p>\n+     * All new chronologies with differrent Era values should try to assign\n+     * eras as follows. The era that was in force at 1970-01-01 (ISO) is assigned\n+     * the value 1. Earlier eras are assigned sequentially smaller numbers.\n+     * Later eras are assigned sequentially greater numbers.\n+     */\n+    public static final int CE = 1;\n+\n+\n+    /** Milliseconds in one second (1000) (ISO) */\n+    public static final int MILLIS_PER_SECOND = 1000;\n+\n+    /** Seconds in one minute (60) (ISO) */\n+    public static final int SECONDS_PER_MINUTE = 60;\n+    /** Milliseconds in one minute (ISO) */\n+    public static final int MILLIS_PER_MINUTE = MILLIS_PER_SECOND * SECONDS_PER_MINUTE;\n+\n+    /** Minutes in one hour (ISO) */\n+    public static final int MINUTES_PER_HOUR = 60;\n+    /** Seconds in one hour (ISO) */\n+    public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    /** Milliseconds in one hour (ISO) */\n+    public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;\n+\n+    /** Hours in a typical day (24) (ISO). Due to time zone offset changes, the\n+     * number of hours per day can vary. */\n+    public static final int HOURS_PER_DAY = 24;\n+    /** Minutes in a typical day (ISO). Due to time zone offset changes, the number\n+     * of minutes per day can vary. */\n+    public static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;\n+    /** Seconds in a typical day (ISO). Due to time zone offset changes, the number\n+     * of seconds per day can vary. */\n+    public static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n+    /** Milliseconds in a typical day (ISO). Due to time zone offset changes, the\n+     * number of milliseconds per day can vary. */\n+    public static final int MILLIS_PER_DAY = MILLIS_PER_HOUR * HOURS_PER_DAY;\n+\n+    /** Days in one week (7) (ISO) */\n+    public static final int DAYS_PER_WEEK = 7;\n+    /** Hours in a typical week. Due to time zone offset changes, the number of\n+     * hours per week can vary. */\n+    public static final int HOURS_PER_WEEK = HOURS_PER_DAY * DAYS_PER_WEEK;\n+    /** Minutes in a typical week (ISO). Due to time zone offset changes, the number\n+     * of minutes per week can vary. */\n+    public static final int MINUTES_PER_WEEK = MINUTES_PER_DAY * DAYS_PER_WEEK;\n+    /** Seconds in a typical week (ISO). Due to time zone offset changes, the number\n+     * of seconds per week can vary. */\n+    public static final int SECONDS_PER_WEEK = SECONDS_PER_DAY * DAYS_PER_WEEK;\n+    /** Milliseconds in a typical week (ISO). Due to time zone offset changes, the\n+     * number of milliseconds per week can vary. */\n+    public static final int MILLIS_PER_WEEK = MILLIS_PER_DAY * DAYS_PER_WEEK;\n+\n+    /**\n+     * Restrictive constructor\n+     */\n+    protected DateTimeConstants() {\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Defines the calculation engine for date and time fields.\n+ * The interface defines a set of methods that manipulate a millisecond datetime\n+ * with regards to a single field, such as monthOfYear or secondOfMinute.\n+ * <p>\n+ * This design is extensible so, if you wish, you can extract a different field from\n+ * the milliseconds. A number of standard implementations are provided to assist.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class DateTimeField {\n+\n+    /**\n+     * Get the type of the field.\n+     * \n+     * @return field type\n+     */\n+    public abstract DateTimeFieldType getType();\n+\n+    /**\n+     * Get the name of the field.\n+     * <p>\n+     * By convention, names follow a pattern of \"dddOfRrr\", where \"ddd\" represents\n+     * the (singular) duration unit field name and \"Rrr\" represents the (singular)\n+     * duration range field name. If the range field is not applicable, then\n+     * the name of the field is simply the (singular) duration field name.\n+     * \n+     * @return field name\n+     */\n+    public abstract String getName();\n+\n+    /**\n+     * Returns true if this field is supported.\n+     * \n+     * @return true if this field is supported\n+     */\n+    public abstract boolean isSupported();\n+\n+    /**\n+     * Returns true if the set method is lenient. If so, it accepts values that\n+     * are out of bounds. For example, a lenient day of month field accepts 32\n+     * for January, converting it to February 1.\n+     * \n+     * @return true if this field is lenient\n+     */\n+    public abstract boolean isLenient();\n+\n+    // Main access API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the value of the field, in the units of the field\n+     */\n+    public abstract int get(long instant);\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsText(long instant, Locale locale);\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsText(long instant);\n+\n+    /**\n+     * Get the human-readable, text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsText(ReadablePartial partial, int fieldValue, Locale locale);\n+\n+    /**\n+     * Get the human-readable, text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsText(ReadablePartial partial, Locale locale);\n+\n+    /**\n+     * Get the human-readable, text value of this field from the field value.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param fieldValue  the numeric value to convert to text\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsText(int fieldValue, Locale locale);\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the\n+     * milliseconds.  If the specified locale is null, the default locale is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the short text value of the field\n+     */\n+    public abstract String getAsShortText(long instant, Locale locale);\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the\n+     * milliseconds.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the short text value of the field\n+     */\n+    public abstract String getAsShortText(long instant);\n+\n+    /**\n+     * Get the human-readable, short text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale);\n+\n+    /**\n+     * Get the human-readable, short text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsShortText(ReadablePartial partial, Locale locale);\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the field value.\n+     * If the specified locale is null, the default locale is used.\n+     *\n+     * @param fieldValue  the numeric value to convert to text\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public abstract String getAsShortText(int fieldValue, Locale locale);\n+\n+    /**\n+     * Adds a value (which may be negative) to the millis value,\n+     * overflowing into larger fields if necessary.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field, larger fields will increase as required.\n+     * Smaller fields should be unaffected, except where the result would be\n+     * an invalid value for a smaller field. In this case the smaller field is\n+     * adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 add six months is 2001-02-20<br>\n+     * 2000-08-20 add twenty months is 2002-04-20<br>\n+     * 2000-08-20 add minus nine months is 1999-11-20<br>\n+     * 2001-01-31 add one month  is 2001-02-28<br>\n+     * 2001-01-31 add two months is 2001-03-31<br>\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public abstract long add(long instant, int value);\n+\n+    /**\n+     * Adds a value (which may be negative) to the millis value,\n+     * overflowing into larger fields if necessary.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the long value to add, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if value is too large\n+     * @see #add(long,int)\n+     */\n+    public abstract long add(long instant, long value);\n+\n+    /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * throwing an exception if the maximum size of the instant is reached.\n+     * <p>\n+     * The value will be added to this field, overflowing into larger fields\n+     * if necessary. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * Partial instants only contain some fields. This may result in a maximum\n+     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this\n+     * limit is breached by the add an exception is thrown.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 add six months is 2000-02-20<br>\n+     * 2000-08-20 add twenty months is 2000-04-20<br>\n+     * 2000-08-20 add minus nine months is 2000-11-20<br>\n+     * 2001-01-31 add one month  is 2001-02-28<br>\n+     * 2001-01-31 add two months is 2001-03-31<br>\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n+     */\n+    public abstract int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);\n+\n+    /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * wrapping the whole partial if the maximum size of the partial is reached.\n+     * <p>\n+     * The value will be added to this field, overflowing into larger fields\n+     * if necessary. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * Partial instants only contain some fields. This may result in a maximum\n+     * possible value, such as TimeOfDay normally being limited to 23:59:59:999.\n+     * If ths limit is reached by the addition, this method will wrap back to\n+     * 00:00:00.000. In fact, you would generally only use this method for\n+     * classes that have a limitation such as this.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 10:20:30 add 20 minutes is 10:40:30<br>\n+     * 10:20:30 add 45 minutes is 11:05:30<br>\n+     * 10:20:30 add 16 hours is 02:20:30<br>\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the partial\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n+     */\n+    public abstract int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);\n+\n+    /**\n+     * Adds a value (which may be negative) to the millis value,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addWrapField six months is 2000-02-20<br>\n+     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>\n+     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addWrapField one month  is 2001-02-28<br>\n+     * 2001-01-31 addWrapField two months is 2001-03-31<br>\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public abstract long addWrapField(long instant, int value) ;\n+\n+    /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addWrapField six months is 2000-02-20<br>\n+     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>\n+     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addWrapField one month  is 2001-02-28<br>\n+     * 2001-01-31 addWrapField two months is 2001-03-31<br>\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public abstract int getDifference(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public abstract long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Sets a value in the milliseconds supplied.\n+     * <p>\n+     * The value of this field will be set.\n+     * If the value is invalid, an exception if thrown.\n+     * <p>\n+     * If setting this field would make other fields invalid, then those fields\n+     * may be changed. For example if the current date is the 31st January, and\n+     * the month is set to February, the day would be invalid. Instead, the day\n+     * would be changed to the closest value - the 28th/29th February as appropriate.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  the value to set, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract long set(long instant, int value);\n+\n+    /**\n+     * Sets a value using the specified partial instant.\n+     * <p>\n+     * The value of this field (specified by the index) will be set.\n+     * If the value is invalid, an exception if thrown.\n+     * <p>\n+     * If setting this field would make other fields invalid, then those fields\n+     * may be changed. For example if the current date is the 31st January, and\n+     * the month is set to February, the day would be invalid. Instead, the day\n+     * would be changed to the closest value - the 28th/29th February as appropriate.\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values of the partial instant which should be updated\n+     * @param newValue  the value to set, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue);\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * If setting this field would make other fields invalid, then those fields\n+     * may be changed. For example if the current date is the 31st January, and\n+     * the month is set to February, the day would be invalid. Instead, the day\n+     * would be changed to the closest value - the 28th/29th February as appropriate.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public abstract long set(long instant, String text, Locale locale);\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text value.\n+     * <p>\n+     * If setting this field would make other fields invalid, then those fields\n+     * may be changed. For example if the current date is the 31st January, and\n+     * the month is set to February, the day would be invalid. Instead, the day\n+     * would be changed to the closest value - the 28th/29th February as appropriate.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public abstract long set(long instant, String text);\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * If setting this field would make other fields invalid, then those fields\n+     * may be changed. For example if the current date is the 31st January, and\n+     * the month is set to February, the day would be invalid. Instead, the day\n+     * would be changed to the closest value - the 28th/29th February as appropriate.\n+     *\n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values of the partial instant which should be updated\n+     * @param text  the text value to set\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public abstract int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale);\n+\n+    // Extra information API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public abstract DurationField getDurationField();\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public abstract DurationField getRangeDurationField();\n+\n+    /**\n+     * Returns whether this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return true, a non leap year would return\n+     * false.\n+     * \n+     * @param instant  the instant to check for leap status\n+     * @return true if the field is 'leap'\n+     */\n+    public abstract boolean isLeap(long instant);\n+\n+    /**\n+     * Gets the amount by which this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return one, a non leap year would return\n+     * zero.\n+     * \n+     * @param instant  the instant to check for leap status\n+     * @return the amount, in units of the leap duration field, that the field is leap\n+     */\n+    public abstract int getLeapAmount(long instant);\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     * \n+     * @return the leap duration field if field can be leap, null if it can't\n+     */\n+    public abstract DurationField getLeapDurationField();\n+\n+    /**\n+     * Get the minimum allowable value for this field.\n+     * \n+     * @return the minimum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMinimumValue();\n+\n+    /**\n+     * Get the minimum value for this field evaluated at the specified time.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public abstract int getMinimumValue(long instant);\n+\n+    /**\n+     * Get the minimum value for this field evaluated at the specified time.\n+     * \n+     * @param instant  the partial instant to query\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public abstract int getMinimumValue(ReadablePartial instant);\n+\n+    /**\n+     * Get the minimum value for this field using the partial instant and\n+     * the specified values.\n+     * \n+     * @param instant  the partial instant to query\n+     * @param values  the values to use\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public abstract int getMinimumValue(ReadablePartial instant, int[] values);\n+\n+    /**\n+     * Get the maximum allowable value for this field.\n+     * \n+     * @return the maximum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMaximumValue();\n+\n+    /**\n+     * Get the maximum value for this field evaluated at the specified time.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public abstract int getMaximumValue(long instant);\n+\n+    /**\n+     * Get the maximum value for this field evaluated at the specified time.\n+     * \n+     * @param instant  the partial instant to query\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public abstract int getMaximumValue(ReadablePartial instant);\n+\n+    /**\n+     * Get the maximum value for this field using the partial instant and\n+     * the specified values.\n+     * \n+     * @param instant  the partial instant to query\n+     * @param values  the values to use\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public abstract int getMaximumValue(ReadablePartial instant, int[] values);\n+\n+    /**\n+     * Get the maximum text value for this field.\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum text length\n+     */\n+    public abstract int getMaximumTextLength(Locale locale);\n+\n+    /**\n+     * Get the maximum short text value for this field.\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum short text length\n+     */\n+    public abstract int getMaximumShortTextLength(Locale locale);\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Round to the lowest whole unit of this field. After rounding, the value\n+     * of this field and all fields of a higher magnitude are retained. The\n+     * fractional millis that cannot be expressed in whole increments of this\n+     * field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * lowest whole hour is 2002-11-02T23:00:00.000.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundFloor(long instant);\n+\n+    /**\n+     * Round to the highest whole unit of this field. The value of this field\n+     * and all fields of a higher magnitude may be incremented in order to\n+     * achieve this result. The fractional millis that cannot be expressed in\n+     * whole increments of this field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * highest whole hour is 2002-11-03T00:00:00.000.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundCeiling(long instant);\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor or is exactly halfway, this function\n+     * behaves like roundFloor. If the millisecond value is closer to the\n+     * ceiling, this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundHalfFloor(long instant);\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling or is exactly halfway,\n+     * this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundHalfCeiling(long instant);\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling, this function behaves\n+     * like roundCeiling.\n+     * <p>\n+     * If the millisecond value is exactly halfway between the floor and\n+     * ceiling, the ceiling is chosen over the floor only if it makes this\n+     * field's value even.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundHalfEven(long instant);\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field. In other\n+     * words, calling remainder returns the duration that roundFloor would\n+     * subtract.\n+     * <p>\n+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by\n+     * hour is 34 minutes and 56.789 seconds.\n+     *\n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the\n+     * remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public abstract long remainder(long instant);\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public abstract String toString();\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DateTimeFieldType.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Identifies a field, such as year or minuteOfHour, in a chronology-neutral way.\n+ * <p>\n+ * A field type defines the type of the field, such as hourOfDay.\n+ * If does not directly enable any calculations, however it does provide a\n+ * {@link #getField(Chronology)} method that returns the actual calculation engine\n+ * for a particular chronology.\n+ * It also provides access to the related {@link DurationFieldType}s.\n+ * <p>\n+ * Instances of <code>DateTimeFieldType</code> are singletons.\n+ * They can be compared using <code>==</code>.\n+ * <p>\n+ * If required, you can create your own field, for example a quarterOfYear.\n+ * You must create a subclass of <code>DateTimeFieldType</code> that defines the field type.\n+ * This class returns the actual calculation engine from {@link #getField(Chronology)}.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class DateTimeFieldType implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -42615285973990L;\n+\n+    /** Ordinal values for standard field types. */\n+    static final byte\n+        ERA = 1,\n+        YEAR_OF_ERA = 2,\n+        CENTURY_OF_ERA = 3,\n+        YEAR_OF_CENTURY = 4,\n+        YEAR = 5,\n+        DAY_OF_YEAR = 6,\n+        MONTH_OF_YEAR = 7,\n+        DAY_OF_MONTH = 8,\n+        WEEKYEAR_OF_CENTURY = 9,\n+        WEEKYEAR = 10,\n+        WEEK_OF_WEEKYEAR = 11,\n+        DAY_OF_WEEK = 12,\n+        HALFDAY_OF_DAY = 13,\n+        HOUR_OF_HALFDAY = 14,\n+        CLOCKHOUR_OF_HALFDAY = 15,\n+        CLOCKHOUR_OF_DAY = 16,\n+        HOUR_OF_DAY = 17,\n+        MINUTE_OF_DAY = 18,\n+        MINUTE_OF_HOUR = 19,\n+        SECOND_OF_DAY = 20,\n+        SECOND_OF_MINUTE = 21,\n+        MILLIS_OF_DAY = 22,\n+        MILLIS_OF_SECOND = 23;\n+\n+    /** The era field type. */\n+    private static final DateTimeFieldType ERA_TYPE = new StandardDateTimeFieldType(\n+        \"era\", ERA, DurationFieldType.eras(), null);\n+    /** The yearOfEra field type. */\n+    private static final DateTimeFieldType YEAR_OF_ERA_TYPE = new StandardDateTimeFieldType(\n+        \"yearOfEra\", YEAR_OF_ERA, DurationFieldType.years(), DurationFieldType.eras());\n+    /** The centuryOfEra field type. */\n+    private static final DateTimeFieldType CENTURY_OF_ERA_TYPE = new StandardDateTimeFieldType(\n+        \"centuryOfEra\", CENTURY_OF_ERA, DurationFieldType.centuries(), DurationFieldType.eras());\n+    /** The yearOfCentury field type. */\n+    private static final DateTimeFieldType YEAR_OF_CENTURY_TYPE = new StandardDateTimeFieldType(\n+        \"yearOfCentury\", YEAR_OF_CENTURY, DurationFieldType.years(), DurationFieldType.centuries());\n+    /** The year field type. */\n+    private static final DateTimeFieldType YEAR_TYPE = new StandardDateTimeFieldType(\n+        \"year\", YEAR, DurationFieldType.years(), null);\n+    /** The dayOfYear field type. */\n+    private static final DateTimeFieldType DAY_OF_YEAR_TYPE = new StandardDateTimeFieldType(\n+        \"dayOfYear\", DAY_OF_YEAR, DurationFieldType.days(), DurationFieldType.years());\n+    /** The monthOfYear field type. */\n+    private static final DateTimeFieldType MONTH_OF_YEAR_TYPE = new StandardDateTimeFieldType(\n+        \"monthOfYear\", MONTH_OF_YEAR, DurationFieldType.months(), DurationFieldType.years());\n+    /** The dayOfMonth field type. */\n+    private static final DateTimeFieldType DAY_OF_MONTH_TYPE = new StandardDateTimeFieldType(\n+        \"dayOfMonth\", DAY_OF_MONTH, DurationFieldType.days(), DurationFieldType.months());\n+    /** The weekyearOfCentury field type. */\n+    private static final DateTimeFieldType WEEKYEAR_OF_CENTURY_TYPE = new StandardDateTimeFieldType(\n+        \"weekyearOfCentury\", WEEKYEAR_OF_CENTURY, DurationFieldType.weekyears(), DurationFieldType.centuries());\n+    /** The weekyear field type. */\n+    private static final DateTimeFieldType WEEKYEAR_TYPE = new StandardDateTimeFieldType(\n+        \"weekyear\", WEEKYEAR, DurationFieldType.weekyears(), null);\n+    /** The weekOfWeekyear field type. */\n+    private static final DateTimeFieldType WEEK_OF_WEEKYEAR_TYPE = new StandardDateTimeFieldType(\n+        \"weekOfWeekyear\", WEEK_OF_WEEKYEAR, DurationFieldType.weeks(), DurationFieldType.weekyears());\n+    /** The dayOfWeek field type. */\n+    private static final DateTimeFieldType DAY_OF_WEEK_TYPE = new StandardDateTimeFieldType(\n+        \"dayOfWeek\", DAY_OF_WEEK, DurationFieldType.days(), DurationFieldType.weeks());\n+\n+    /** The halfday field type. */\n+    private static final DateTimeFieldType HALFDAY_OF_DAY_TYPE = new StandardDateTimeFieldType(\n+        \"halfdayOfDay\", HALFDAY_OF_DAY, DurationFieldType.halfdays(), DurationFieldType.days());\n+    /** The hourOfHalfday field type. */\n+    private static final DateTimeFieldType HOUR_OF_HALFDAY_TYPE = new StandardDateTimeFieldType(\n+        \"hourOfHalfday\", HOUR_OF_HALFDAY, DurationFieldType.hours(), DurationFieldType.halfdays());\n+    /** The clockhourOfHalfday field type. */\n+    private static final DateTimeFieldType CLOCKHOUR_OF_HALFDAY_TYPE = new StandardDateTimeFieldType(\n+        \"clockhourOfHalfday\", CLOCKHOUR_OF_HALFDAY, DurationFieldType.hours(), DurationFieldType.halfdays());\n+    /** The clockhourOfDay field type. */\n+    private static final DateTimeFieldType CLOCKHOUR_OF_DAY_TYPE = new StandardDateTimeFieldType(\n+        \"clockhourOfDay\", CLOCKHOUR_OF_DAY, DurationFieldType.hours(), DurationFieldType.days());\n+    /** The hourOfDay field type. */\n+    private static final DateTimeFieldType HOUR_OF_DAY_TYPE = new StandardDateTimeFieldType(\n+        \"hourOfDay\", HOUR_OF_DAY, DurationFieldType.hours(), DurationFieldType.days());\n+    /** The minuteOfDay field type. */\n+    private static final DateTimeFieldType MINUTE_OF_DAY_TYPE = new StandardDateTimeFieldType(\n+        \"minuteOfDay\", MINUTE_OF_DAY, DurationFieldType.minutes(), DurationFieldType.days());\n+    /** The minuteOfHour field type. */\n+    private static final DateTimeFieldType MINUTE_OF_HOUR_TYPE = new StandardDateTimeFieldType(\n+        \"minuteOfHour\", MINUTE_OF_HOUR, DurationFieldType.minutes(), DurationFieldType.hours());\n+    /** The secondOfDay field type. */\n+    private static final DateTimeFieldType SECOND_OF_DAY_TYPE = new StandardDateTimeFieldType(\n+        \"secondOfDay\", SECOND_OF_DAY, DurationFieldType.seconds(), DurationFieldType.days());\n+    /** The secondOfMinute field type. */\n+    private static final DateTimeFieldType SECOND_OF_MINUTE_TYPE = new StandardDateTimeFieldType(\n+        \"secondOfMinute\", SECOND_OF_MINUTE, DurationFieldType.seconds(), DurationFieldType.minutes());\n+    /** The millisOfDay field type. */\n+    private static final DateTimeFieldType MILLIS_OF_DAY_TYPE = new StandardDateTimeFieldType(\n+        \"millisOfDay\", MILLIS_OF_DAY, DurationFieldType.millis(), DurationFieldType.days());\n+    /** The millisOfSecond field type. */\n+    private static final DateTimeFieldType MILLIS_OF_SECOND_TYPE = new StandardDateTimeFieldType(\n+        \"millisOfSecond\", MILLIS_OF_SECOND, DurationFieldType.millis(), DurationFieldType.seconds());\n+\n+    /** The name of the field. */\n+    private final String iName;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  the name to use\n+     */\n+    protected DateTimeFieldType(String name) {\n+        super();\n+        iName = name;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis of second field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType millisOfSecond() {\n+        return MILLIS_OF_SECOND_TYPE;\n+    }\n+\n+    /**\n+     * Get the millis of day field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType millisOfDay() {\n+        return MILLIS_OF_DAY_TYPE;\n+    }\n+\n+    /**\n+     * Get the second of minute field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType secondOfMinute() {\n+        return SECOND_OF_MINUTE_TYPE;\n+    }\n+\n+    /**\n+     * Get the second of day field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType secondOfDay() {\n+        return SECOND_OF_DAY_TYPE;\n+    }\n+\n+    /**\n+     * Get the minute of hour field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType minuteOfHour() {\n+        return MINUTE_OF_HOUR_TYPE;\n+    }\n+\n+    /**\n+     * Get the minute of day field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType minuteOfDay() {\n+        return MINUTE_OF_DAY_TYPE;\n+    }\n+\n+    /**\n+     * Get the hour of day (0-23) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType hourOfDay() {\n+        return HOUR_OF_DAY_TYPE;\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType clockhourOfDay() {\n+        return CLOCKHOUR_OF_DAY_TYPE;\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType hourOfHalfday() {\n+        return HOUR_OF_HALFDAY_TYPE;\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType clockhourOfHalfday() {\n+        return CLOCKHOUR_OF_HALFDAY_TYPE;\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType halfdayOfDay() {\n+        return HALFDAY_OF_DAY_TYPE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the day of week field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType dayOfWeek() {\n+        return DAY_OF_WEEK_TYPE;\n+    }\n+\n+    /**\n+     * Get the day of month field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType dayOfMonth() {\n+        return DAY_OF_MONTH_TYPE;\n+    }\n+\n+    /**\n+     * Get the day of year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType dayOfYear() {\n+        return DAY_OF_YEAR_TYPE;\n+    }\n+\n+    /**\n+     * Get the week of a week based year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType weekOfWeekyear() {\n+        return WEEK_OF_WEEKYEAR_TYPE;\n+    }\n+\n+    /**\n+     * Get the year of a week based year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType weekyear() {\n+        return WEEKYEAR_TYPE;\n+    }\n+\n+    /**\n+     * Get the year of a week based year within a century field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType weekyearOfCentury() {\n+        return WEEKYEAR_OF_CENTURY_TYPE;\n+    }\n+\n+    /**\n+     * Get the month of year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType monthOfYear() {\n+        return MONTH_OF_YEAR_TYPE;\n+    }\n+\n+    /**\n+     * Get the year field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType year() {\n+        return YEAR_TYPE;\n+    }\n+\n+    /**\n+     * Get the year of era field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType yearOfEra() {\n+        return YEAR_OF_ERA_TYPE;\n+    }\n+\n+    /**\n+     * Get the year of century field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType yearOfCentury() {\n+        return YEAR_OF_CENTURY_TYPE;\n+    }\n+\n+    /**\n+     * Get the century of era field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType centuryOfEra() {\n+        return CENTURY_OF_ERA_TYPE;\n+    }\n+\n+    /**\n+     * Get the era field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType era() {\n+        return ERA_TYPE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the name of the field.\n+     * <p>\n+     * By convention, names follow a pattern of \"dddOfRrr\", where \"ddd\" represents\n+     * the (singular) duration unit field name and \"Rrr\" represents the (singular)\n+     * duration range field name. If the range field is not applicable, then\n+     * the name of the field is simply the (singular) duration field name.\n+     * \n+     * @return field name\n+     */\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * Get the duration unit of the field.\n+     * \n+     * @return duration unit of the field, never null\n+     */\n+    public abstract DurationFieldType getDurationType();\n+\n+    /**\n+     * Get the duration range of the field.\n+     * \n+     * @return duration range of the field, null if unbounded\n+     */\n+    public abstract DurationFieldType getRangeDurationType();\n+\n+    /**\n+     * Gets a suitable field for this type from the given Chronology.\n+     *\n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n+     * @return a suitable field\n+     */\n+    public abstract DateTimeField getField(Chronology chronology);\n+\n+    /**\n+     * Checks whether this field supported in the given Chronology.\n+     *\n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n+     * @return true if supported\n+     */\n+    public boolean isSupported(Chronology chronology) {\n+        return getField(chronology).isSupported();\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return getName();\n+    }\n+\n+    private static class StandardDateTimeFieldType extends DateTimeFieldType {\n+        /** Serialization version */\n+        private static final long serialVersionUID = -9937958251642L;\n+\n+        /** The ordinal of the standard field type, for switch statements */\n+        private final byte iOrdinal;\n+\n+        /** The unit duration of the field. */\n+        private final transient DurationFieldType iUnitType;\n+        /** The range duration of the field. */\n+        private final transient DurationFieldType iRangeType;\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param name  the name to use\n+         * @param ordinal  the byte value for the oridinal index\n+         * @param unitType  the unit duration type\n+         * @param rangeType  the range duration type\n+         */\n+        StandardDateTimeFieldType(String name, byte ordinal,\n+                                  DurationFieldType unitType, DurationFieldType rangeType) {\n+            super(name);\n+            iOrdinal = ordinal;\n+            iUnitType = unitType;\n+            iRangeType = rangeType;\n+        }\n+\n+        /** @inheritdoc */\n+        public DurationFieldType getDurationType() {\n+            return iUnitType;\n+        }\n+\n+        /** @inheritdoc */\n+        public DurationFieldType getRangeDurationType() {\n+            return iRangeType;\n+        }\n+\n+        /** @inheritdoc */\n+        public DateTimeField getField(Chronology chronology) {\n+            chronology = DateTimeUtils.getChronology(chronology);\n+\n+            switch (iOrdinal) {\n+                case ERA:\n+                    return chronology.era();\n+                case YEAR_OF_ERA:\n+                    return chronology.yearOfEra();\n+                case CENTURY_OF_ERA:\n+                    return chronology.centuryOfEra();\n+                case YEAR_OF_CENTURY:\n+                    return chronology.yearOfCentury();\n+                case YEAR:\n+                    return chronology.year();\n+                case DAY_OF_YEAR:\n+                    return chronology.dayOfYear();\n+                case MONTH_OF_YEAR:\n+                    return chronology.monthOfYear();\n+                case DAY_OF_MONTH:\n+                    return chronology.dayOfMonth();\n+                case WEEKYEAR_OF_CENTURY:\n+                    return chronology.weekyearOfCentury();\n+                case WEEKYEAR:\n+                    return chronology.weekyear();\n+                case WEEK_OF_WEEKYEAR:\n+                    return chronology.weekOfWeekyear();\n+                case DAY_OF_WEEK:\n+                    return chronology.dayOfWeek();\n+                case HALFDAY_OF_DAY:\n+                    return chronology.halfdayOfDay();\n+                case HOUR_OF_HALFDAY:\n+                    return chronology.hourOfHalfday();\n+                case CLOCKHOUR_OF_HALFDAY:\n+                    return chronology.clockhourOfHalfday();\n+                case CLOCKHOUR_OF_DAY:\n+                    return chronology.clockhourOfDay();\n+                case HOUR_OF_DAY:\n+                    return chronology.hourOfDay();\n+                case MINUTE_OF_DAY:\n+                    return chronology.minuteOfDay();\n+                case MINUTE_OF_HOUR:\n+                    return chronology.minuteOfHour();\n+                case SECOND_OF_DAY:\n+                    return chronology.secondOfDay();\n+                case SECOND_OF_MINUTE:\n+                    return chronology.secondOfMinute();\n+                case MILLIS_OF_DAY:\n+                    return chronology.millisOfDay();\n+                case MILLIS_OF_SECOND:\n+                    return chronology.millisOfSecond();\n+                default:\n+                    // Shouldn't happen.\n+                    throw new InternalError();\n+            }\n+        }\n+\n+        /**\n+         * Ensure a singleton is returned.\n+         * \n+         * @return the singleton type\n+         */\n+        private Object readResolve() {\n+            switch (iOrdinal) {\n+                case ERA:\n+                    return ERA_TYPE;\n+                case YEAR_OF_ERA:\n+                    return YEAR_OF_ERA_TYPE;\n+                case CENTURY_OF_ERA:\n+                    return CENTURY_OF_ERA_TYPE;\n+                case YEAR_OF_CENTURY:\n+                    return YEAR_OF_CENTURY_TYPE;\n+                case YEAR:\n+                    return YEAR_TYPE;\n+                case DAY_OF_YEAR:\n+                    return DAY_OF_YEAR_TYPE;\n+                case MONTH_OF_YEAR:\n+                    return MONTH_OF_YEAR_TYPE;\n+                case DAY_OF_MONTH:\n+                    return DAY_OF_MONTH_TYPE;\n+                case WEEKYEAR_OF_CENTURY:\n+                    return WEEKYEAR_OF_CENTURY_TYPE;\n+                case WEEKYEAR:\n+                    return WEEKYEAR_TYPE;\n+                case WEEK_OF_WEEKYEAR:\n+                    return WEEK_OF_WEEKYEAR_TYPE;\n+                case DAY_OF_WEEK:\n+                    return DAY_OF_WEEK_TYPE;\n+                case HALFDAY_OF_DAY:\n+                    return HALFDAY_OF_DAY_TYPE;\n+                case HOUR_OF_HALFDAY:\n+                    return HOUR_OF_HALFDAY_TYPE;\n+                case CLOCKHOUR_OF_HALFDAY:\n+                    return CLOCKHOUR_OF_HALFDAY_TYPE;\n+                case CLOCKHOUR_OF_DAY:\n+                    return CLOCKHOUR_OF_DAY_TYPE;\n+                case HOUR_OF_DAY:\n+                    return HOUR_OF_DAY_TYPE;\n+                case MINUTE_OF_DAY:\n+                    return MINUTE_OF_DAY_TYPE;\n+                case MINUTE_OF_HOUR:\n+                    return MINUTE_OF_HOUR_TYPE;\n+                case SECOND_OF_DAY:\n+                    return SECOND_OF_DAY_TYPE;\n+                case SECOND_OF_MINUTE:\n+                    return SECOND_OF_MINUTE_TYPE;\n+                case MILLIS_OF_DAY:\n+                    return MILLIS_OF_DAY_TYPE;\n+                case MILLIS_OF_SECOND:\n+                    return MILLIS_OF_SECOND_TYPE;\n+                default:\n+                    // Shouldn't happen.\n+                    return this;\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DateTimeUtils.java\n+/*\n+ *  Copyright 2001-2010 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.lang.reflect.Method;\n+import java.text.DateFormatSymbols;\n+import java.util.Locale;\n+\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * DateTimeUtils provide public utility methods for the date-time library.\n+ * <p>\n+ * DateTimeUtils is thread-safe although shared static variables are used.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class DateTimeUtils {\n+\n+    /** The singleton instance of the system millisecond provider. */\n+    private static final SystemMillisProvider SYSTEM_MILLIS_PROVIDER = new SystemMillisProvider();\n+    /** The millisecond provider currently in use. */\n+    private static volatile MillisProvider cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n+\n+    /**\n+     * Restrictive constructor\n+     */\n+    protected DateTimeUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current time in milliseconds.\n+     * <p>\n+     * By default this returns <code>System.currentTimeMillis()</code>.\n+     * This may be changed using other methods in this class.\n+     * \n+     * @return the current time in milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public static final long currentTimeMillis() {\n+        return cMillisProvider.getMillis();\n+    }\n+\n+    /**\n+     * Resets the current time to return the system time.\n+     * <p>\n+     * This method changes the behaviour of {@link #currentTimeMillis()}.\n+     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.\n+     * \n+     * @throws SecurityException if the application does not have sufficient security rights\n+     */\n+    public static final void setCurrentMillisSystem() throws SecurityException {\n+        checkPermission();\n+        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n+    }\n+\n+    /**\n+     * Sets the current time to return a fixed millisecond time.\n+     * <p>\n+     * This method changes the behaviour of {@link #currentTimeMillis()}.\n+     * Whenever the current time is queried, the same millisecond time will be returned.\n+     * \n+     * @param fixedMillis  the fixed millisecond time to use\n+     * @throws SecurityException if the application does not have sufficient security rights\n+     */\n+    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n+        checkPermission();\n+        cMillisProvider = new FixedMillisProvider(fixedMillis);\n+    }\n+\n+    /**\n+     * Sets the current time to return the system time plus an offset.\n+     * <p>\n+     * This method changes the behaviour of {@link #currentTimeMillis()}.\n+     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used\n+     * and then offset by adding the millisecond value specified here.\n+     * \n+     * @param offsetMillis  the fixed millisecond time to use\n+     * @throws SecurityException if the application does not have sufficient security rights\n+     */\n+    public static final void setCurrentMillisOffset(long offsetMillis) throws SecurityException {\n+        checkPermission();\n+        if (offsetMillis == 0) {\n+            cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n+        } else {\n+            cMillisProvider = new OffsetMillisProvider(offsetMillis);\n+        }\n+    }\n+\n+    /**\n+     * Sets the provider of the current time to class specified.\n+     * <p>\n+     * This method changes the behaviour of {@link #currentTimeMillis()}.\n+     * Whenever the current time is queried, the specified class will be called.\n+     * \n+     * @param millisProvider  the provider of the current time to use, not null\n+     * @throws SecurityException if the application does not have sufficient security rights\n+     * @since 2.0\n+     */\n+    public static final void setCurrentMillisProvider(MillisProvider millisProvider) throws SecurityException {\n+        if (millisProvider == null) {\n+            throw new IllegalArgumentException(\"The MillisProvider must not be null\");\n+        }\n+        checkPermission();\n+        cMillisProvider = millisProvider;\n+    }\n+\n+    /**\n+     * Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.\n+     * \n+     * @throws SecurityException if the provider may not be changed\n+     */\n+    private static void checkPermission() throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millisecond instant from the specified instant object handling null.\n+     * <p>\n+     * If the instant object is <code>null</code>, the {@link #currentTimeMillis()}\n+     * will be returned. Otherwise, the millis from the object are returned.\n+     * \n+     * @param instant  the instant to examine, null means now\n+     * @return the time in milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public static final long getInstantMillis(ReadableInstant instant) {\n+        if (instant == null) {\n+            return DateTimeUtils.currentTimeMillis();\n+        }\n+        return instant.getMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology from the specified instant object handling null.\n+     * <p>\n+     * If the instant object is <code>null</code>, or the instant's chronology is\n+     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n+     * Otherwise, the chronology from the object is returned.\n+     * \n+     * @param instant  the instant to examine, null means ISO in the default zone\n+     * @return the chronology, never null\n+     */\n+    public static final Chronology getInstantChronology(ReadableInstant instant) {\n+        if (instant == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        Chronology chrono = instant.getChronology();\n+        if (chrono == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology from the specified instant based interval handling null.\n+     * <p>\n+     * The chronology is obtained from the start if that is not null, or from the\n+     * end if the start is null. The result is additionally checked, and if still\n+     * null then {@link ISOChronology#getInstance()} will be returned.\n+     * \n+     * @param start  the instant to examine and use as the primary source of the chronology\n+     * @param end  the instant to examine and use as the secondary source of the chronology\n+     * @return the chronology, never null\n+     */\n+    public static final Chronology getIntervalChronology(ReadableInstant start, ReadableInstant end) {\n+        Chronology chrono = null;\n+        if (start != null) {\n+            chrono = start.getChronology();\n+        } else if (end != null) {\n+            chrono = end.getChronology();\n+        }\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology from the specified interval object handling null.\n+     * <p>\n+     * If the interval object is <code>null</code>, or the interval's chronology is\n+     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n+     * Otherwise, the chronology from the object is returned.\n+     * \n+     * @param interval  the interval to examine, null means ISO in the default zone\n+     * @return the chronology, never null\n+     */\n+    public static final Chronology getIntervalChronology(ReadableInterval interval) {\n+        if (interval == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        Chronology chrono = interval.getChronology();\n+        if (chrono == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the interval handling null.\n+     * <p>\n+     * If the interval is <code>null</code>, an interval representing now\n+     * to now in the {@link ISOChronology#getInstance() ISOChronology}\n+     * will be returned. Otherwise, the interval specified is returned.\n+     * \n+     * @param interval  the interval to use, null means now to now\n+     * @return the interval, never null\n+     * @since 1.1\n+     */\n+    public static final ReadableInterval getReadableInterval(ReadableInterval interval) {\n+        if (interval == null) {\n+            long now = DateTimeUtils.currentTimeMillis();\n+            interval = new Interval(now, now);\n+        }\n+        return interval;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology handling null.\n+     * <p>\n+     * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n+     * will be returned. Otherwise, the chronology is returned.\n+     * \n+     * @param chrono  the chronology to use, null means ISO in the default zone\n+     * @return the chronology, never null\n+     */\n+    public static final Chronology getChronology(Chronology chrono) {\n+        if (chrono == null) {\n+            return ISOChronology.getInstance();\n+        }\n+        return chrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the zone handling null.\n+     * <p>\n+     * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}\n+     * will be returned. Otherwise, the zone specified is returned.\n+     * \n+     * @param zone  the time zone to use, null means the default zone\n+     * @return the time zone, never null\n+     */\n+    public static final DateTimeZone getZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            return DateTimeZone.getDefault();\n+        }\n+        return zone;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the period type handling null.\n+     * <p>\n+     * If the zone is <code>null</code>, {@link PeriodType#standard()}\n+     * will be returned. Otherwise, the type specified is returned.\n+     * \n+     * @param type  the time zone to use, null means the standard type\n+     * @return the type to use, never null\n+     */\n+    public static final PeriodType getPeriodType(PeriodType type) {\n+        if (type == null) {\n+            return PeriodType.standard();\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millisecond duration from the specified duration object handling null.\n+     * <p>\n+     * If the duration object is <code>null</code>, zero will be returned.\n+     * Otherwise, the millis from the object are returned.\n+     * \n+     * @param duration  the duration to examine, null means zero\n+     * @return the duration in milliseconds\n+     */\n+    public static final long getDurationMillis(ReadableDuration duration) {\n+        if (duration == null) {\n+            return 0L;\n+        }\n+        return duration.getMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the partial is contiguous.\n+     * <p>\n+     * A partial is contiguous if one field starts where another ends.\n+     * <p>\n+     * For example <code>LocalDate</code> is contiguous because DayOfMonth has\n+     * the same range (Month) as the unit of the next field (MonthOfYear), and\n+     * MonthOfYear has the same range (Year) as the unit of the next field (Year).\n+     * <p>\n+     * Similarly, <code>LocalTime</code> is contiguous, as it consists of\n+     * MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how\n+     * the names of each field 'join up').\n+     * <p>\n+     * However, a Year/HourOfDay partial is not contiguous because the range\n+     * field Day is not equal to the next field Year.\n+     * Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because\n+     * the range Month is not equal to the next field Day.\n+     * \n+     * @param partial  the partial to check\n+     * @return true if the partial is contiguous\n+     * @throws IllegalArgumentException if the partial is null\n+     * @since 1.1\n+     */\n+    public static final boolean isContiguous(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"Partial must not be null\");\n+        }\n+        DurationFieldType lastType = null;\n+        for (int i = 0; i < partial.size(); i++) {\n+            DateTimeField loopField = partial.getField(i);\n+            if (i > 0) {\n+                if (loopField.getRangeDurationField().getType() != lastType) {\n+                    return false;\n+                }\n+            }\n+            lastType = loopField.getDurationField().getType();\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the {@link DateFormatSymbols} based on the given locale.\n+     * <p>\n+     * If JDK 6 or newer is being used, DateFormatSymbols.getInstance(locale) will\n+     * be used in order to allow the use of locales defined as extensions.\n+     * Otherwise, new DateFormatSymbols(locale) will be used.\n+     * See JDK 6 {@link DateFormatSymbols} for further information.\n+     * \n+     * @param locale  the {@link Locale} used to get the correct {@link DateFormatSymbols}\n+     * @return the symbols\n+     * @since 2.0\n+     */\n+    public static final DateFormatSymbols getDateFormatSymbols(Locale locale) {\n+        try {        \t\n+        \tMethod method = DateFormatSymbols.class.getMethod(\"getInstance\", new Class[] {Locale.class});        \t\n+        \treturn (DateFormatSymbols) method.invoke(null, new Object[] {locale});        \t\n+        } catch (Exception ex) {\n+        \treturn new DateFormatSymbols(locale);\n+        } \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A millisecond provider, allowing control of the system clock.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 2.0 (previously private)\n+     */\n+    public static interface MillisProvider {\n+        /**\n+         * Gets the current time.\n+         * <p>\n+         * Implementations of this method must be thread-safe.\n+         * \n+         * @return the current time in milliseconds\n+         */\n+        long getMillis();\n+    }\n+\n+    /**\n+     * System millis provider.\n+     */\n+    static class SystemMillisProvider implements MillisProvider {\n+        /**\n+         * Gets the current time.\n+         * @return the current time in millis\n+         */\n+        public long getMillis() {\n+            return System.currentTimeMillis();\n+        }\n+    }\n+\n+    /**\n+     * Fixed millisecond provider.\n+     */\n+    static class FixedMillisProvider implements MillisProvider {\n+        /** The fixed millis value. */\n+        private final long iMillis;\n+        \n+        /**\n+         * Constructor.\n+         * @param offsetMillis  the millis offset\n+         */\n+        FixedMillisProvider(long fixedMillis) {\n+            iMillis = fixedMillis;\n+        }\n+        \n+        /**\n+         * Gets the current time.\n+         * @return the current time in millis\n+         */\n+        public long getMillis() {\n+            return iMillis;\n+        }\n+    }\n+\n+    /**\n+     * Offset from system millis provider.\n+     */\n+    static class OffsetMillisProvider implements MillisProvider {\n+        /** The millis offset. */\n+        private final long iMillis;\n+        \n+        /**\n+         * Constructor.\n+         * @param offsetMillis  the millis offset\n+         */\n+        OffsetMillisProvider(long offsetMillis) {\n+            iMillis = offsetMillis;\n+        }\n+        \n+        /**\n+         * Gets the current time.\n+         * @return the current time in millis\n+         */\n+        public long getMillis() {\n+            return System.currentTimeMillis() + iMillis;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DateTimeZone.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.lang.ref.Reference;\n+import java.lang.ref.SoftReference;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TimeZone;\n+\n+import org.joda.time.chrono.BaseChronology;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.DateTimeFormatterBuilder;\n+import org.joda.time.format.FormatUtils;\n+import org.joda.time.tz.DefaultNameProvider;\n+import org.joda.time.tz.FixedDateTimeZone;\n+import org.joda.time.tz.NameProvider;\n+import org.joda.time.tz.Provider;\n+import org.joda.time.tz.UTCProvider;\n+import org.joda.time.tz.ZoneInfoProvider;\n+\n+/**\n+ * DateTimeZone represents a time zone.\n+ * <p>\n+ * A time zone is a system of rules to convert time from one geographic \n+ * location to another. For example, Paris, France is one hour ahead of\n+ * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.\n+ * <p>\n+ * All time zone rules are expressed, for historical reasons, relative to\n+ * Greenwich, London. Local time in Greenwich is referred to as Greenwich Mean\n+ * Time (GMT).  This is similar, but not precisely identical, to Universal \n+ * Coordinated Time, or UTC. This library only uses the term UTC.\n+ * <p>\n+ * Using this system, America/Los_Angeles is expressed as UTC-08:00, or UTC-07:00\n+ * in the summer. The offset -08:00 indicates that America/Los_Angeles time is\n+ * obtained from UTC by adding -08:00, that is, by subtracting 8 hours.\n+ * <p>\n+ * The offset differs in the summer because of daylight saving time, or DST.\n+ * The following definitions of time are generally used:\n+ * <ul>\n+ * <li>UTC - The reference time.\n+ * <li>Standard Time - The local time without a daylight saving time offset.\n+ * For example, in Paris, standard time is UTC+01:00.\n+ * <li>Daylight Saving Time - The local time with a daylight saving time \n+ * offset. This offset is typically one hour, but not always. It is typically\n+ * used in most countries away from the equator.  In Paris, daylight saving \n+ * time is UTC+02:00.\n+ * <li>Wall Time - This is what a local clock on the wall reads. This will be\n+ * either Standard Time or Daylight Saving Time depending on the time of year\n+ * and whether the location uses Daylight Saving Time.\n+ * </ul>\n+ * <p>\n+ * Unlike the Java TimeZone class, DateTimeZone is immutable. It also only\n+ * supports long format time zone ids. Thus EST and ECT are not accepted.\n+ * However, the factory that accepts a TimeZone will attempt to convert from\n+ * the old short id to a suitable long id.\n+ * <p>\n+ * DateTimeZone is thread-safe and immutable, and all subclasses must be as\n+ * well.\n+ * \n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class DateTimeZone implements Serializable {\n+    \n+    /** Serialization version. */\n+    private static final long serialVersionUID = 5546345482340108586L;\n+\n+    /** The time zone for Universal Coordinated Time */\n+    public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n+\n+    /** The instance that is providing time zones. */\n+    private static Provider cProvider;\n+    /** The instance that is providing time zone names. */\n+    private static NameProvider cNameProvider;\n+    /** The set of ID strings. */\n+    private static Set<String> cAvailableIDs;\n+    /** The default time zone. */\n+    private static volatile DateTimeZone cDefault;\n+    /** A formatter for printing and parsing zones. */\n+    private static DateTimeFormatter cOffsetFormatter;\n+\n+    /** Cache that maps fixed offset strings to softly referenced DateTimeZones */\n+    private static Map<String, SoftReference<DateTimeZone>> iFixedOffsetCache;\n+\n+    /** Cache of old zone IDs to new zone IDs */\n+    private static Map<String, String> cZoneIdConversion;\n+\n+    static {\n+        setProvider0(null);\n+        setNameProvider0(null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the default time zone.\n+     * \n+     * @return the default datetime zone object\n+     */\n+    public static DateTimeZone getDefault() {\n+        DateTimeZone zone = cDefault;\n+        if (zone == null) {\n+            synchronized(DateTimeZone.class) {\n+                zone = cDefault;\n+                if (zone == null) {\n+                    DateTimeZone temp = null;\n+                    try {\n+                        try {\n+                            temp = forID(System.getProperty(\"user.timezone\"));\n+                        } catch (RuntimeException ex) {\n+                            // ignored\n+                        }\n+                        if (temp == null) {\n+                            temp = forTimeZone(TimeZone.getDefault());\n+                        }\n+                    } catch (IllegalArgumentException ex) {\n+                        // ignored\n+                    }\n+                    if (temp == null) {\n+                        temp = UTC;\n+                    }\n+                    cDefault = zone = temp;\n+                }\n+            }\n+        }\n+        return zone;\n+    }\n+\n+    /**\n+     * Sets the default time zone.\n+     * \n+     * @param zone  the default datetime zone object, must not be null\n+     * @throws IllegalArgumentException if the zone is null\n+     * @throws SecurityException if the application has insufficient security rights\n+     */\n+    public static void setDefault(DateTimeZone zone) throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n+        }\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n+        }\n+        synchronized(DateTimeZone.class) {\n+            cDefault = zone;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a time zone instance for the specified time zone id.\n+     * <p>\n+     * The time zone id may be one of those returned by getAvailableIDs.\n+     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n+     * All IDs must be specified in the long format.\n+     * The exception is UTC, which is an acceptable id.\n+     * <p>\n+     * Alternatively a locale independent, fixed offset, datetime zone can\n+     * be specified. The form <code>[+-]hh:mm</code> can be used.\n+     * \n+     * @param id  the ID of the datetime zone, null means default\n+     * @return the DateTimeZone object for the ID\n+     * @throws IllegalArgumentException if the ID is not recognised\n+     */\n+    public static DateTimeZone forID(String id) {\n+        if (id == null) {\n+            return getDefault();\n+        }\n+        if (id.equals(\"UTC\")) {\n+            return DateTimeZone.UTC;\n+        }\n+        DateTimeZone zone = cProvider.getZone(id);\n+        if (zone != null) {\n+            return zone;\n+        }\n+        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n+            int offset = parseOffset(id);\n+            if (offset == 0L) {\n+                return DateTimeZone.UTC;\n+            } else {\n+                id = printOffset(offset);\n+                return fixedOffsetZone(id, offset);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n+    }\n+\n+    /**\n+     * Gets a time zone instance for the specified offset to UTC in hours.\n+     * This method assumes standard length hours.\n+     * <p>\n+     * This factory is a convenient way of constructing zones with a fixed offset.\n+     * \n+     * @param hoursOffset  the offset in hours from UTC\n+     * @return the DateTimeZone object for the offset\n+     * @throws IllegalArgumentException if the offset is too large or too small\n+     */\n+    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n+        return forOffsetHoursMinutes(hoursOffset, 0);\n+    }\n+\n+    /**\n+     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n+     * This method assumes 60 minutes in an hour, and standard length minutes.\n+     * <p>\n+     * This factory is a convenient way of constructing zones with a fixed offset.\n+     * The minutes value is always positive and in the range 0 to 59.\n+     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n+     * \n+     * @param hoursOffset  the offset in hours from UTC\n+     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n+     * @return the DateTimeZone object for the offset\n+     * @throws IllegalArgumentException if the offset or minute is too large or too small\n+     */\n+    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n+        if (hoursOffset == 0 && minutesOffset == 0) {\n+            return DateTimeZone.UTC;\n+        }\n+        if (minutesOffset < 0 || minutesOffset > 59) {\n+            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n+        }\n+        int offset = 0;\n+        try {\n+            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n+            if (hoursInMinutes < 0) {\n+                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n+            } else {\n+                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n+            }\n+            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n+        } catch (ArithmeticException ex) {\n+            throw new IllegalArgumentException(\"Offset is too large\");\n+        }\n+        return forOffsetMillis(offset);\n+    }\n+\n+    /**\n+     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n+     *\n+     * @param millisOffset  the offset in millis from UTC\n+     * @return the DateTimeZone object for the offset\n+     */\n+    public static DateTimeZone forOffsetMillis(int millisOffset) {\n+        String id = printOffset(millisOffset);\n+        return fixedOffsetZone(id, millisOffset);\n+    }\n+\n+    /**\n+     * Gets a time zone instance for a JDK TimeZone.\n+     * <p>\n+     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n+     * excluded IDs are the short three letter form (except UTC). This \n+     * method will attempt to convert between time zones created using the\n+     * short IDs and the full version.\n+     * <p>\n+     * This method is not designed to parse time zones with rules created by\n+     * applications using <code>SimpleTimeZone</code> directly.\n+     * \n+     * @param zone  the zone to convert, null means default\n+     * @return the DateTimeZone object for the zone\n+     * @throws IllegalArgumentException if the zone is not recognised\n+     */\n+    public static DateTimeZone forTimeZone(TimeZone zone) {\n+        if (zone == null) {\n+            return getDefault();\n+        }\n+        final String id = zone.getID();\n+        if (id.equals(\"UTC\")) {\n+            return DateTimeZone.UTC;\n+        }\n+\n+        // Convert from old alias before consulting provider since they may differ.\n+        DateTimeZone dtz = null;\n+        String convId = getConvertedId(id);\n+        if (convId != null) {\n+            dtz = cProvider.getZone(convId);\n+        }\n+        if (dtz == null) {\n+            dtz = cProvider.getZone(id);\n+        }\n+        if (dtz != null) {\n+            return dtz;\n+        }\n+\n+        // Support GMT+/-hh:mm formats\n+        if (convId == null) {\n+            convId = zone.getDisplayName();\n+            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n+                convId = convId.substring(3);\n+                int offset = parseOffset(convId);\n+                if (offset == 0L) {\n+                    return DateTimeZone.UTC;\n+                } else {\n+                    convId = printOffset(offset);\n+                    return fixedOffsetZone(convId, offset);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the zone using a fixed offset amount.\n+     * \n+     * @param id  the zone id\n+     * @param offset  the offset in millis\n+     * @return the zone\n+     */\n+    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n+        if (offset == 0) {\n+            return DateTimeZone.UTC;\n+        }\n+        if (iFixedOffsetCache == null) {\n+            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n+        }\n+        DateTimeZone zone;\n+        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n+        if (ref != null) {\n+            zone = ref.get();\n+            if (zone != null) {\n+                return zone;\n+            }\n+        }\n+        zone = new FixedDateTimeZone(id, null, offset, offset);\n+        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n+        return zone;\n+    }\n+\n+    /**\n+     * Gets all the available IDs supported.\n+     * \n+     * @return an unmodifiable Set of String IDs\n+     */\n+    public static Set<String> getAvailableIDs() {\n+        return cAvailableIDs;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the zone provider factory.\n+     * <p>\n+     * The zone provider is a pluggable instance factory that supplies the\n+     * actual instances of DateTimeZone.\n+     * \n+     * @return the provider\n+     */\n+    public static Provider getProvider() {\n+        return cProvider;\n+    }\n+\n+    /**\n+     * Sets the zone provider factory.\n+     * <p>\n+     * The zone provider is a pluggable instance factory that supplies the\n+     * actual instances of DateTimeZone.\n+     * \n+     * @param provider  provider to use, or null for default\n+     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n+     * @throws IllegalArgumentException if the provider is invalid\n+     */\n+    public static void setProvider(Provider provider) throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n+        }\n+        setProvider0(provider);\n+    }\n+\n+    /**\n+     * Sets the zone provider factory without performing the security check.\n+     * \n+     * @param provider  provider to use, or null for default\n+     * @throws IllegalArgumentException if the provider is invalid\n+     */\n+    private static void setProvider0(Provider provider) {\n+        if (provider == null) {\n+            provider = getDefaultProvider();\n+        }\n+        Set<String> ids = provider.getAvailableIDs();\n+        if (ids == null || ids.size() == 0) {\n+            throw new IllegalArgumentException\n+                (\"The provider doesn't have any available ids\");\n+        }\n+        if (!ids.contains(\"UTC\")) {\n+            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n+        }\n+        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n+            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n+        }\n+        cProvider = provider;\n+        cAvailableIDs = ids;\n+    }\n+\n+    /**\n+     * Gets the default zone provider.\n+     * <p>\n+     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n+     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n+     * Then uses <code>UTCProvider</code>.\n+     * \n+     * @return the default name provider\n+     */\n+    private static Provider getDefaultProvider() {\n+        Provider provider = null;\n+\n+        try {\n+            String providerClass =\n+                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n+            if (providerClass != null) {\n+                try {\n+                    provider = (Provider) Class.forName(providerClass).newInstance();\n+                } catch (Exception ex) {\n+                    Thread thread = Thread.currentThread();\n+                    thread.getThreadGroup().uncaughtException(thread, ex);\n+                }\n+            }\n+        } catch (SecurityException ex) {\n+            // ignored\n+        }\n+\n+        if (provider == null) {\n+            try {\n+                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n+            } catch (Exception ex) {\n+                Thread thread = Thread.currentThread();\n+                thread.getThreadGroup().uncaughtException(thread, ex);\n+            }\n+        }\n+\n+        if (provider == null) {\n+            provider = new UTCProvider();\n+        }\n+\n+        return provider;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the name provider factory.\n+     * <p>\n+     * The name provider is a pluggable instance factory that supplies the\n+     * names of each DateTimeZone.\n+     * \n+     * @return the provider\n+     */\n+    public static NameProvider getNameProvider() {\n+        return cNameProvider;\n+    }\n+\n+    /**\n+     * Sets the name provider factory.\n+     * <p>\n+     * The name provider is a pluggable instance factory that supplies the\n+     * names of each DateTimeZone.\n+     * \n+     * @param nameProvider  provider to use, or null for default\n+     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n+     * @throws IllegalArgumentException if the provider is invalid\n+     */\n+    public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n+        }\n+        setNameProvider0(nameProvider);\n+    }\n+\n+    /**\n+     * Sets the name provider factory without performing the security check.\n+     * \n+     * @param nameProvider  provider to use, or null for default\n+     * @throws IllegalArgumentException if the provider is invalid\n+     */\n+    private static void setNameProvider0(NameProvider nameProvider) {\n+        if (nameProvider == null) {\n+            nameProvider = getDefaultNameProvider();\n+        }\n+        cNameProvider = nameProvider;\n+    }\n+\n+    /**\n+     * Gets the default name provider.\n+     * <p>\n+     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n+     * Then uses <code>DefaultNameProvider</code>.\n+     * \n+     * @return the default name provider\n+     */\n+    private static NameProvider getDefaultNameProvider() {\n+        NameProvider nameProvider = null;\n+        try {\n+            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n+            if (providerClass != null) {\n+                try {\n+                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n+                } catch (Exception ex) {\n+                    Thread thread = Thread.currentThread();\n+                    thread.getThreadGroup().uncaughtException(thread, ex);\n+                }\n+            }\n+        } catch (SecurityException ex) {\n+            // ignore\n+        }\n+\n+        if (nameProvider == null) {\n+            nameProvider = new DefaultNameProvider();\n+        }\n+\n+        return nameProvider;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts an old style id to a new style id.\n+     * \n+     * @param id  the old style id\n+     * @return the new style id, null if not found\n+     */\n+    private static synchronized String getConvertedId(String id) {\n+        Map<String, String> map = cZoneIdConversion;\n+        if (map == null) {\n+            // Backwards compatibility with TimeZone.\n+            map = new HashMap<String, String>();\n+            map.put(\"GMT\", \"UTC\");\n+            map.put(\"MIT\", \"Pacific/Apia\");\n+            map.put(\"HST\", \"Pacific/Honolulu\");\n+            map.put(\"AST\", \"America/Anchorage\");\n+            map.put(\"PST\", \"America/Los_Angeles\");\n+            map.put(\"MST\", \"America/Denver\");\n+            map.put(\"PNT\", \"America/Phoenix\");\n+            map.put(\"CST\", \"America/Chicago\");\n+            map.put(\"EST\", \"America/New_York\");\n+            map.put(\"IET\", \"America/Indianapolis\");\n+            map.put(\"PRT\", \"America/Puerto_Rico\");\n+            map.put(\"CNT\", \"America/St_Johns\");\n+            map.put(\"AGT\", \"America/Buenos_Aires\");\n+            map.put(\"BET\", \"America/Sao_Paulo\");\n+            map.put(\"WET\", \"Europe/London\");\n+            map.put(\"ECT\", \"Europe/Paris\");\n+            map.put(\"ART\", \"Africa/Cairo\");\n+            map.put(\"CAT\", \"Africa/Harare\");\n+            map.put(\"EET\", \"Europe/Bucharest\");\n+            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n+            map.put(\"MET\", \"Asia/Tehran\");\n+            map.put(\"NET\", \"Asia/Yerevan\");\n+            map.put(\"PLT\", \"Asia/Karachi\");\n+            map.put(\"IST\", \"Asia/Calcutta\");\n+            map.put(\"BST\", \"Asia/Dhaka\");\n+            map.put(\"VST\", \"Asia/Saigon\");\n+            map.put(\"CTT\", \"Asia/Shanghai\");\n+            map.put(\"JST\", \"Asia/Tokyo\");\n+            map.put(\"ACT\", \"Australia/Darwin\");\n+            map.put(\"AET\", \"Australia/Sydney\");\n+            map.put(\"SST\", \"Pacific/Guadalcanal\");\n+            map.put(\"NST\", \"Pacific/Auckland\");\n+            cZoneIdConversion = map;\n+        }\n+        return map.get(id);\n+    }\n+\n+    private static int parseOffset(String str) {\n+        // Can't use a real chronology if called during class\n+        // initialization. Offset parser doesn't need it anyhow.\n+        Chronology chrono = new BaseChronology() {\n+            public DateTimeZone getZone() {\n+                return null;\n+            }\n+            public Chronology withUTC() {\n+                return this;\n+            }\n+            public Chronology withZone(DateTimeZone zone) {\n+                return this;\n+            }\n+            public String toString() {\n+                return getClass().getName();\n+            }\n+        };\n+        return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n+    }\n+\n+    /**\n+     * Formats a timezone offset string.\n+     * <p>\n+     * This method is kept separate from the formatting classes to speed and\n+     * simplify startup and classloading.\n+     * \n+     * @param offset  the offset in milliseconds\n+     * @return the time zone string\n+     */\n+    private static String printOffset(int offset) {\n+        StringBuffer buf = new StringBuffer();\n+        if (offset >= 0) {\n+            buf.append('+');\n+        } else {\n+            buf.append('-');\n+            offset = -offset;\n+        }\n+\n+        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n+        FormatUtils.appendPaddedInteger(buf, hours, 2);\n+        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n+\n+        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n+        buf.append(':');\n+        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n+        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+        if (offset == 0) {\n+            return buf.toString();\n+        }\n+\n+        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n+        buf.append(':');\n+        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n+        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+        if (offset == 0) {\n+            return buf.toString();\n+        }\n+\n+        buf.append('.');\n+        FormatUtils.appendPaddedInteger(buf, offset, 3);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Gets a printer/parser for managing the offset id formatting.\n+     * \n+     * @return the formatter\n+     */\n+    private static synchronized DateTimeFormatter offsetFormatter() {\n+        if (cOffsetFormatter == null) {\n+            cOffsetFormatter = new DateTimeFormatterBuilder()\n+                .appendTimeZoneOffset(null, true, 2, 4)\n+                .toFormatter();\n+        }\n+        return cOffsetFormatter;\n+    }\n+\n+    // Instance fields and methods\n+    //--------------------------------------------------------------------\n+\n+    private final String iID;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param id  the id to use\n+     * @throws IllegalArgumentException if the id is null\n+     */\n+    protected DateTimeZone(String id) {\n+        if (id == null) {\n+            throw new IllegalArgumentException(\"Id must not be null\");\n+        }\n+        iID = id;\n+    }\n+\n+    // Principal methods\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * Gets the ID of this datetime zone.\n+     * \n+     * @return the ID of this datetime zone\n+     */\n+    public final String getID() {\n+        return iID;\n+    }\n+\n+    /**\n+     * Returns a non-localized name that is unique to this time zone. It can be\n+     * combined with id to form a unique key for fetching localized names.\n+     *\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @return name key or null if id should be used for names\n+     */\n+    public abstract String getNameKey(long instant);\n+\n+    /**\n+     * Gets the short name of this datetime zone suitable for display using\n+     * the default locale.\n+     * <p>\n+     * If the name is not available for the locale, then this method returns a\n+     * string in the format <code>[+-]hh:mm</code>.\n+     * \n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @return the human-readable short name in the default locale\n+     */\n+    public final String getShortName(long instant) {\n+        return getShortName(instant, null);\n+    }\n+\n+    /**\n+     * Gets the short name of this datetime zone suitable for display using\n+     * the specified locale.\n+     * <p>\n+     * If the name is not available for the locale, then this method returns a\n+     * string in the format <code>[+-]hh:mm</code>.\n+     * \n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param locale  the locale to get the name for\n+     * @return the human-readable short name in the specified locale\n+     */\n+    public String getShortName(long instant, Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        String nameKey = getNameKey(instant);\n+        if (nameKey == null) {\n+            return iID;\n+        }\n+        String name = cNameProvider.getShortName(locale, iID, nameKey);\n+        if (name != null) {\n+            return name;\n+        }\n+        return printOffset(getOffset(instant));\n+    }\n+\n+    /**\n+     * Gets the long name of this datetime zone suitable for display using\n+     * the default locale.\n+     * <p>\n+     * If the name is not available for the locale, then this method returns a\n+     * string in the format <code>[+-]hh:mm</code>.\n+     * \n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @return the human-readable long name in the default locale\n+     */\n+    public final String getName(long instant) {\n+        return getName(instant, null);\n+    }\n+\n+    /**\n+     * Gets the long name of this datetime zone suitable for display using\n+     * the specified locale.\n+     * <p>\n+     * If the name is not available for the locale, then this method returns a\n+     * string in the format <code>[+-]hh:mm</code>.\n+     * \n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param locale  the locale to get the name for\n+     * @return the human-readable long name in the specified locale\n+     */\n+    public String getName(long instant, Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        String nameKey = getNameKey(instant);\n+        if (nameKey == null) {\n+            return iID;\n+        }\n+        String name = cNameProvider.getName(locale, iID, nameKey);\n+        if (name != null) {\n+            return name;\n+        }\n+        return printOffset(getOffset(instant));\n+    }\n+\n+    /**\n+     * Gets the millisecond offset to add to UTC to get local time.\n+     * \n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @return the millisecond offset to add to UTC to get local time\n+     */\n+    public abstract int getOffset(long instant);\n+\n+    /**\n+     * Gets the millisecond offset to add to UTC to get local time.\n+     * \n+     * @param instant  instant to get the offset for, null means now\n+     * @return the millisecond offset to add to UTC to get local time\n+     */\n+    public final int getOffset(ReadableInstant instant) {\n+        if (instant == null) {\n+            return getOffset(DateTimeUtils.currentTimeMillis());\n+        }\n+        return getOffset(instant.getMillis());\n+    }\n+\n+    /**\n+     * Gets the standard millisecond offset to add to UTC to get local time,\n+     * when standard time is in effect.\n+     * \n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @return the millisecond offset to add to UTC to get local time\n+     */\n+    public abstract int getStandardOffset(long instant);\n+\n+    /**\n+     * Checks whether, at a particular instant, the offset is standard or not.\n+     * <p>\n+     * This method can be used to determine whether Summer Time (DST) applies.\n+     * As a general rule, if the offset at the specified instant is standard,\n+     * then either Winter time applies, or there is no Summer Time. If the\n+     * instant is not standard, then Summer Time applies.\n+     * <p>\n+     * The implementation of the method is simply whether {@link #getOffset(long)}\n+     * equals {@link #getStandardOffset(long)} at the specified instant.\n+     * \n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @return true if the offset at the given instant is the standard offset\n+     * @since 1.5\n+     */\n+    public boolean isStandardOffset(long instant) {\n+        return getOffset(instant) == getStandardOffset(instant);\n+    }\n+\n+    /**\n+     * Gets the millisecond offset to subtract from local time to get UTC time.\n+     * This offset can be used to undo adding the offset obtained by getOffset.\n+     *\n+     * <pre>\n+     * millisLocal == millisUTC   + getOffset(millisUTC)\n+     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n+     * </pre>\n+     *\n+     * NOTE: After calculating millisLocal, some error may be introduced. At\n+     * offset transitions (due to DST or other historical changes), ranges of\n+     * local times may map to different UTC times.\n+     * <p>\n+     * This method will return an offset suitable for calculating an instant\n+     * after any DST gap. For example, consider a zone with a cutover\n+     * from 01:00 to 01:59:<br />\n+     * Input: 00:00  Output: 00:00<br />\n+     * Input: 00:30  Output: 00:30<br />\n+     * Input: 01:00  Output: 02:00<br />\n+     * Input: 01:30  Output: 02:30<br />\n+     * Input: 02:00  Output: 02:00<br />\n+     * Input: 02:30  Output: 02:30<br />\n+     * <p>\n+     * NOTE: The behaviour of this method changed in v1.5, with the emphasis\n+     * on returning a consistent result later along the time-line (shown above).\n+     *\n+     * @param instantLocal  the millisecond instant, relative to this time zone, to\n+     * get the offset for\n+     * @return the millisecond offset to subtract from local time to get UTC time\n+     */\n+    public int getOffsetFromLocal(long instantLocal) {\n+        // get the offset at instantLocal (first estimate)\n+        int offsetLocal = getOffset(instantLocal);\n+        // adjust instantLocal using the estimate and recalc the offset\n+        int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n+        // if the offsets differ, we must be near a DST boundary\n+        if (offsetLocal != offsetAdjusted) {\n+            // we need to ensure that time is always after the DST gap\n+            // this happens naturally for positive offsets, but not for negative\n+            if ((offsetLocal - offsetAdjusted) < 0) {\n+                // if we just return offsetAdjusted then the time is pushed\n+                // back before the transition, whereas it should be\n+                // on or after the transition\n+                long nextLocal = nextTransition(instantLocal - offsetLocal);\n+                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n+                if (nextLocal != nextAdjusted) {\n+                    return offsetLocal;\n+                }\n+            }\n+        }\n+        return offsetAdjusted;\n+    }\n+\n+    /**\n+     * Converts a standard UTC instant to a local instant with the same\n+     * local time. This conversion is used before performing a calculation\n+     * so that the calculation can be done using a simple local zone.\n+     *\n+     * @param instantUTC  the UTC instant to convert to local\n+     * @return the local instant with the same local time\n+     * @throws ArithmeticException if the result overflows a long\n+     * @since 1.5\n+     */\n+    public long convertUTCToLocal(long instantUTC) {\n+        int offset = getOffset(instantUTC);\n+        long instantLocal = instantUTC + offset;\n+        // If there is a sign change, but the two values have the same sign...\n+        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n+            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n+        }\n+        return instantLocal;\n+    }\n+\n+    /**\n+     * Converts a local instant to a standard UTC instant with the same\n+     * local time. This conversion is used after performing a calculation\n+     * where the calculation was done using a simple local zone.\n+     *\n+     * @param instantLocal  the local instant to convert to UTC\n+     * @param strict  whether the conversion should reject non-existent local times\n+     * @return the UTC instant with the same local time, \n+     * @throws ArithmeticException if the result overflows a long\n+     * @throws IllegalArgumentException if the zone has no eqivalent local time\n+     * @since 1.5\n+     */\n+    public long convertLocalToUTC(long instantLocal, boolean strict) {\n+        // get the offset at instantLocal (first estimate)\n+        int offsetLocal = getOffset(instantLocal);\n+        // adjust instantLocal using the estimate and recalc the offset\n+        int offset = getOffset(instantLocal - offsetLocal);\n+        // if the offsets differ, we must be near a DST boundary\n+        if (offsetLocal != offset) {\n+            // if strict then always check if in DST gap\n+            // otherwise only check if zone in Western hemisphere (as the\n+            // value of offset is already correct for Eastern hemisphere)\n+            if (strict || offsetLocal < 0) {\n+                // determine if we are in the DST gap\n+                long nextLocal = nextTransition(instantLocal - offsetLocal);\n+                if (nextLocal == (instantLocal - offsetLocal)) {\n+                    nextLocal = Long.MAX_VALUE;\n+                }\n+                long nextAdjusted = nextTransition(instantLocal - offset);\n+                if (nextAdjusted == (instantLocal - offset)) {\n+                    nextAdjusted = Long.MAX_VALUE;\n+                }\n+                if (nextLocal != nextAdjusted) {\n+                    // yes we are in the DST gap\n+                    if (strict) {\n+                        // DST gap is not acceptable\n+                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n+                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n+                                \" (\" + getID() + \")\");\n+                    } else {\n+                        // DST gap is acceptable, but for the Western hemisphere\n+                        // the offset is wrong and will result in local times\n+                        // before the cutover so use the offsetLocal instead\n+                        offset = offsetLocal;\n+                    }\n+                }\n+            }\n+        }\n+        // check for overflow\n+        long instantUTC = instantLocal - offset;\n+        // If there is a sign change, but the two values have different signs...\n+        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n+            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n+        }\n+        return instantUTC;\n+    }\n+\n+    /**\n+     * Gets the millisecond instant in another zone keeping the same local time.\n+     * <p>\n+     * The conversion is performed by converting the specified UTC millis to local\n+     * millis in this zone, then converting back to UTC millis in the new zone.\n+     *\n+     * @param newZone  the new zone, null means default\n+     * @param oldInstant  the UTC millisecond instant to convert\n+     * @return the UTC millisecond instant with the same local time in the new zone\n+     */\n+    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n+        if (newZone == null) {\n+            newZone = DateTimeZone.getDefault();\n+        }\n+        if (newZone == this) {\n+            return oldInstant;\n+        }\n+        long instantLocal = oldInstant + getOffset(oldInstant);\n+        return instantLocal - newZone.getOffsetFromLocal(instantLocal);\n+    }\n+\n+//    //-----------------------------------------------------------------------\n+//    /**\n+//     * Checks if the given {@link LocalDateTime} is within an overlap.\n+//     * <p>\n+//     * When switching from Daylight Savings Time to standard time there is\n+//     * typically an overlap where the same clock hour occurs twice. This\n+//     * method identifies whether the local datetime refers to such an overlap.\n+//     * \n+//     * @param localDateTime  the time to check, not null\n+//     * @return true if the given datetime refers to an overlap\n+//     */\n+//    public boolean isLocalDateTimeOverlap(LocalDateTime localDateTime) {\n+//        if (isFixed()) {\n+//            return false;\n+//        }\n+//        long instantLocal = localDateTime.toDateTime(DateTimeZone.UTC).getMillis();\n+//        // get the offset at instantLocal (first estimate)\n+//        int offsetLocal = getOffset(instantLocal);\n+//        // adjust instantLocal using the estimate and recalc the offset\n+//        int offset = getOffset(instantLocal - offsetLocal);\n+//        // if the offsets differ, we must be near a DST boundary\n+//        if (offsetLocal != offset) {\n+//            long nextLocal = nextTransition(instantLocal - offsetLocal);\n+//            long nextAdjusted = nextTransition(instantLocal - offset);\n+//            if (nextLocal != nextAdjusted) {\n+//                // in DST gap\n+//                return false;\n+//            }\n+//            long diff = Math.abs(offset - offsetLocal);\n+//            DateTime dateTime = localDateTime.toDateTime(this);\n+//            DateTime adjusted = dateTime.plus(diff);\n+//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n+//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n+//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n+//                return true;\n+//            }\n+//            adjusted = dateTime.minus(diff);\n+//            if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n+//                    dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n+//                    dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n+//                return true;\n+//            }\n+//            return false;\n+//        }\n+//        return false;\n+//    }\n+//        \n+//        \n+//        DateTime dateTime = null;\n+//        try {\n+//            dateTime = localDateTime.toDateTime(this);\n+//        } catch (IllegalArgumentException ex) {\n+//            return false;  // it is a gap, not an overlap\n+//        }\n+//        long offset1 = Math.abs(getOffset(dateTime.getMillis() + 1) - getStandardOffset(dateTime.getMillis() + 1));\n+//        long offset2 = Math.abs(getOffset(dateTime.getMillis() - 1) - getStandardOffset(dateTime.getMillis() - 1));\n+//        long offset = Math.max(offset1, offset2);\n+//        if (offset == 0) {\n+//            return false;\n+//        }\n+//        DateTime adjusted = dateTime.plus(offset);\n+//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n+//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n+//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n+//            return true;\n+//        }\n+//        adjusted = dateTime.minus(offset);\n+//        if (dateTime.getHourOfDay() == adjusted.getHourOfDay() &&\n+//                dateTime.getMinuteOfHour() == adjusted.getMinuteOfHour() &&\n+//                dateTime.getSecondOfMinute() == adjusted.getSecondOfMinute()) {\n+//            return true;\n+//        }\n+//        return false;\n+        \n+//        long millis = dateTime.getMillis();\n+//        long nextTransition = nextTransition(millis);\n+//        long previousTransition = previousTransition(millis);\n+//        long deltaToPreviousTransition = millis - previousTransition;\n+//        long deltaToNextTransition = nextTransition - millis;\n+//        if (deltaToNextTransition < deltaToPreviousTransition) {\n+//            int offset = getOffset(nextTransition);\n+//            int standardOffset = getStandardOffset(nextTransition);\n+//            if (Math.abs(offset - standardOffset) >= deltaToNextTransition) {\n+//                return true;\n+//            }\n+//        } else  {\n+//            int offset = getOffset(previousTransition);\n+//            int standardOffset = getStandardOffset(previousTransition);\n+//            if (Math.abs(offset - standardOffset) >= deltaToPreviousTransition) {\n+//                return true;\n+//            }\n+//        }\n+//        return false;\n+//    }\n+\n+    /**\n+     * Checks if the given {@link LocalDateTime} is within a gap.\n+     * <p>\n+     * When switching from standard time to Daylight Savings Time there is\n+     * typically a gap where a clock hour is missing. This method identifies\n+     * whether the local datetime refers to such a gap.\n+     * \n+     * @param localDateTime  the time to check, not null\n+     * @return true if the given datetime refers to a gap\n+     * @since 1.6\n+     */\n+    public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {\n+        if (isFixed()) {\n+            return false;\n+        }\n+        try {\n+            localDateTime.toDateTime(this);\n+            return false;\n+        } catch (IllegalArgumentException ex) {\n+            return true;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if this time zone has no transitions.\n+     *\n+     * @return true if no transitions\n+     */\n+    public abstract boolean isFixed();\n+\n+    /**\n+     * Advances the given instant to where the time zone offset or name changes.\n+     * If the instant returned is exactly the same as passed in, then\n+     * no changes occur after the given instant.\n+     *\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n+     * @return milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public abstract long nextTransition(long instant);\n+\n+    /**\n+     * Retreats the given instant to where the time zone offset or name changes.\n+     * If the instant returned is exactly the same as passed in, then\n+     * no changes occur before the given instant.\n+     *\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n+     * @return milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public abstract long previousTransition(long instant);\n+\n+    // Basic methods\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * Get the datetime zone as a {@link java.util.TimeZone}.\n+     * \n+     * @return the closest matching TimeZone object\n+     */\n+    public java.util.TimeZone toTimeZone() {\n+        return java.util.TimeZone.getTimeZone(iID);\n+    }\n+\n+    /**\n+     * Compare this datetime zone with another.\n+     * \n+     * @param object the object to compare with\n+     * @return true if equal, based on the ID and all internal rules\n+     */\n+    public abstract boolean equals(Object object);\n+\n+    /**\n+     * Gets a hash code compatable with equals.\n+     * \n+     * @return suitable hashcode\n+     */\n+    public int hashCode() {\n+        return 57 + getID().hashCode();\n+    }\n+\n+    /**\n+     * Gets the datetime zone as a string, which is simply its ID.\n+     * @return the id of the zone\n+     */\n+    public String toString() {\n+        return getID();\n+    }\n+\n+    /**\n+     * By default, when DateTimeZones are serialized, only a \"stub\" object\n+     * referring to the id is written out. When the stub is read in, it\n+     * replaces itself with a DateTimeZone object.\n+     * @return a stub object to go in the stream\n+     */\n+    protected Object writeReplace() throws ObjectStreamException {\n+        return new Stub(iID);\n+    }\n+\n+    /**\n+     * Used to serialize DateTimeZones by id.\n+     */\n+    private static final class Stub implements Serializable {\n+        /** Serialization lock. */\n+        private static final long serialVersionUID = -6471952376487863581L;\n+        /** The ID of the zone. */\n+        private transient String iID;\n+\n+        /**\n+         * Constructor.\n+         * @param id  the id of the zone\n+         */\n+        Stub(String id) {\n+            iID = id;\n+        }\n+\n+        private void writeObject(ObjectOutputStream out) throws IOException {\n+            out.writeUTF(iID);\n+        }\n+\n+        private void readObject(ObjectInputStream in) throws IOException {\n+            iID = in.readUTF();\n+        }\n+\n+        private Object readResolve() throws ObjectStreamException {\n+            return forID(iID);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Days.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of days.\n+ * <p>\n+ * <code>Days</code> is an immutable period that can only store days.\n+ * It does not store years, months or hours for example. As such it is a\n+ * type-safe way of representing a number of days in an application.\n+ * <p>\n+ * The number of days is set in the constructor, and may be queried using\n+ * <code>getDays()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Days</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Days extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero days. */\n+    public static final Days ZERO = new Days(0);\n+    /** Constant representing one day. */\n+    public static final Days ONE = new Days(1);\n+    /** Constant representing two days. */\n+    public static final Days TWO = new Days(2);\n+    /** Constant representing three days. */\n+    public static final Days THREE = new Days(3);\n+    /** Constant representing four days. */\n+    public static final Days FOUR = new Days(4);\n+    /** Constant representing five days. */\n+    public static final Days FIVE = new Days(5);\n+    /** Constant representing six days. */\n+    public static final Days SIX = new Days(6);\n+    /** Constant representing seven days. */\n+    public static final Days SEVEN = new Days(7);\n+    /** Constant representing the maximum number of days that can be stored in this object. */\n+    public static final Days MAX_VALUE = new Days(Integer.MAX_VALUE);\n+    /** Constant representing the minimum number of days that can be stored in this object. */\n+    public static final Days MIN_VALUE = new Days(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.days());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380865L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Days</code> that may be cached.\n+     * <code>Days</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param days  the number of days to obtain an instance for\n+     * @return the instance of Days\n+     */\n+    public static Days days(int days) {\n+        switch (days) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case 4:\n+                return FOUR;\n+            case 5:\n+                return FIVE;\n+            case 6:\n+                return SIX;\n+            case 7:\n+                return SEVEN;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Days(days);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Days</code> representing the number of whole days\n+     * between the two specified datetimes. This method corectly handles\n+     * any daylight savings time changes that may occur during the interval.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Days daysBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.days());\n+        return Days.days(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Days</code> representing the number of whole days\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Days daysBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalDate && end instanceof LocalDate)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int days = chrono.days().getDifference(\n+                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n+            return Days.days(days);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Days.days(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Days</code> representing the number of whole days\n+     * in the specified interval. This method corectly handles any daylight\n+     * savings time changes that may occur during the interval.\n+     *\n+     * @param interval  the interval to extract days from, null returns zero\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Days daysIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Days.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days());\n+        return Days.days(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Days</code> representing the number of complete\n+     * standard length days in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, null returns zero\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Days standardDaysIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_DAY);\n+        return Days.days(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Days</code> by parsing a string in the ISO8601 format 'PnD'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * days component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in days\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Days parseDays(String periodStr) {\n+        if (periodStr == null) {\n+            return Days.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Days.days(p.getDays());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of days.\n+     * You should consider using the factory method {@link #days(int)}\n+     * instead of the constructor.\n+     *\n+     * @param days  the number of days to represent\n+     */\n+    private Days(int days) {\n+        super(days);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Days.days(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>days</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.days();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>days</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.days();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in days to a period in weeks assuming a\n+     * 7 day week.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of weeks for this number of days\n+     */\n+    public Weeks toStandardWeeks() {\n+        return Weeks.weeks(getValue() / DateTimeConstants.DAYS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Converts this period in days to a period in hours assuming a\n+     * 24 hour day.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of days\n+     * @throws ArithmeticException if the number of hours is too large to be represented\n+     */\n+    public Hours toStandardHours() {\n+        return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_DAY));\n+    }\n+\n+    /**\n+     * Converts this period in days to a period in minutes assuming a\n+     * 24 hour day and 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours\n+     * long and all hours are 60 minutes long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of minutes for this number of days\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     */\n+    public Minutes toStandardMinutes() {\n+        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_DAY));\n+    }\n+\n+    /**\n+     * Converts this period in days to a period in seconds assuming a\n+     * 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours\n+     * long, all hours are 60 minutes long and all minutes are 60 seconds long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of seconds for this number of days\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     */\n+    public Seconds toStandardSeconds() {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_DAY));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in days to a duration in milliseconds assuming a\n+     * 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all days are 24 hours\n+     * long, all hours are 60 minutes and all minutes are 60 seconds.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a duration equivalent to this number of days\n+     */\n+    public Duration toStandardDuration() {\n+        long days = getValue();  // assign to a long\n+        return new Duration(days * DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of days that this period represents.\n+     *\n+     * @return the number of days in the period\n+     */\n+    public int getDays() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of days added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new period plus the specified number of days\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days plus(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        return Days.days(FieldUtils.safeAdd(getValue(), days));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of days added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to add, may be negative, null means zero\n+     * @return the new period plus the specified number of days\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days plus(Days days) {\n+        if (days == null) {\n+            return this;\n+        }\n+        return plus(days.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of days taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to take away, may be negative\n+     * @return the new period minus the specified number of days\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days minus(int days) {\n+        return plus(FieldUtils.safeNegate(days));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of days taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of days\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days minus(Days days) {\n+        if (days == null) {\n+            return this;\n+        }\n+        return minus(days.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the days multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days multipliedBy(int scalar) {\n+        return Days.days(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the days divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Days dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Days.days(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the days value negated.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Days negated() {\n+        return Days.days(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this days instance greater than the specified number of days.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this days instance is greater than the specified one\n+     */\n+    public boolean isGreaterThan(Days other) {\n+        if (other == null) {\n+            return getValue() > 0;\n+        }\n+        return getValue() > other.getValue();\n+    }\n+\n+    /**\n+     * Is this days instance less than the specified number of days.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this days instance is less than the specified one\n+     */\n+    public boolean isLessThan(Days other) {\n+        if (other == null) {\n+            return getValue() < 0;\n+        }\n+        return getValue() < other.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P4D\" represents 4 days.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"P\" + String.valueOf(getValue()) + \"D\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Duration.java\n+/*\n+ *  Copyright 2001-2005,2008 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.base.BaseDuration;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * An immutable duration specifying a length of time in milliseconds.\n+ * <p>\n+ * A duration is defined by a fixed number of milliseconds.\n+ * There is no concept of fields, such as days or seconds, as these fields can vary in length.\n+ * A duration may be converted to a {@link Period} to obtain field values.\n+ * This conversion will typically cause a loss of precision however.\n+ * <p>\n+ * Duration is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class Duration\n+        extends BaseDuration\n+        implements ReadableDuration, Serializable {\n+\n+    /** Constant representing zero millisecond duration */\n+    public static final Duration ZERO = new Duration(0L);\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2471658376918L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create a duration with the specified number of days assuming that\n+     * there are the standard number of milliseconds in a day.\n+     * <p>\n+     * This method assumes that there are 24 hours in a day,\n+     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in\n+     * a second. This will be true for most days, however days with Daylight\n+     * Savings changes will not have 24 hours, so use this method with care.\n+     * <p>\n+     * A Duration is a representation of an amount of time. If you want to express\n+     * the concepts of 'days' you should consider using the {@link Days} class.\n+     *\n+     * @param days  the number of standard days in this duration\n+     * @return the duration, never null\n+     * @throws ArithmeticException if the days value is too large\n+     * @since 1.6\n+     */\n+    public static Duration standardDays(long days) {\n+        if (days == 0) {\n+            return ZERO;\n+        }\n+        return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY));\n+    }\n+\n+    /**\n+     * Create a duration with the specified number of hours assuming that\n+     * there are the standard number of milliseconds in an hour.\n+     * <p>\n+     * This method assumes that there are 60 minutes in an hour,\n+     * 60 seconds in a minute and 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * <p>\n+     * A Duration is a representation of an amount of time. If you want to express\n+     * the concepts of 'hours' you should consider using the {@link Hours} class.\n+     *\n+     * @param hours  the number of standard hours in this duration\n+     * @return the duration, never null\n+     * @throws ArithmeticException if the hours value is too large\n+     * @since 1.6\n+     */\n+    public static Duration standardHours(long hours) {\n+        if (hours == 0) {\n+            return ZERO;\n+        }\n+        return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR));\n+    }\n+\n+    /**\n+     * Create a duration with the specified number of minutes assuming that\n+     * there are the standard number of milliseconds in a minute.\n+     * <p>\n+     * This method assumes that there are 60 seconds in a minute and\n+     * 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * <p>\n+     * A Duration is a representation of an amount of time. If you want to express\n+     * the concepts of 'minutes' you should consider using the {@link Minutes} class.\n+     *\n+     * @param minutes  the number of standard minutes in this duration\n+     * @return the duration, never null\n+     * @throws ArithmeticException if the minutes value is too large\n+     * @since 1.6\n+     */\n+    public static Duration standardMinutes(long minutes) {\n+        if (minutes == 0) {\n+            return ZERO;\n+        }\n+        return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE));\n+    }\n+\n+    /**\n+     * Create a duration with the specified number of seconds assuming that\n+     * there are the standard number of milliseconds in a second.\n+     * <p>\n+     * This method assumes that there are 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * <p>\n+     * A Duration is a representation of an amount of time. If you want to express\n+     * the concepts of 'seconds' you should consider using the {@link Seconds} class.\n+     *\n+     * @param seconds  the number of standard seconds in this duration\n+     * @return the duration, never null\n+     * @throws ArithmeticException if the seconds value is too large\n+     * @since 1.6\n+     */\n+    public static Duration standardSeconds(long seconds) {\n+        if (seconds == 0) {\n+            return ZERO;\n+        }\n+        return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND));\n+    }\n+\n+    /**\n+     * Create a duration with the specified number of milliseconds.\n+     *\n+     * @param millis  the number of standard milliseconds in this duration\n+     * @return the duration, never null\n+     * @since 2.0\n+     */\n+    public static Duration millis(long millis) {\n+        if (millis == 0) {\n+            return ZERO;\n+        }\n+        return new Duration(millis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public Duration(long duration) {\n+        super(duration);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n+     */\n+    public Duration(long startInstant, long endInstant) {\n+        super(startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param start  interval start, null means now\n+     * @param end  interval end, null means now\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n+     */\n+    public Duration(ReadableInstant start, ReadableInstant end) {\n+        super(start, end);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     */\n+    public Duration(Object duration) {\n+        super(duration);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of this duration in days assuming that there are the\n+     * standard number of milliseconds in a day.\n+     * <p>\n+     * This method assumes that there are 24 hours in a day,\n+     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in\n+     * a second. This will be true for most days, however days with Daylight\n+     * Savings changes will not have 24 hours, so use this method with care.\n+     * <p>\n+     * This returns <code>getMillis() / MILLIS_PER_DAY</code>.\n+     * The result is an integer division, thus excess milliseconds are truncated.\n+     *\n+     * @return the length of the duration in standard seconds\n+     * @since 2.0\n+     */\n+    public long getStandardDays() {\n+        return getMillis() / DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    /**\n+     * Gets the length of this duration in hours assuming that there are the\n+     * standard number of milliseconds in an hour.\n+     * <p>\n+     * This method assumes that there are 60 minutes in an hour,\n+     * 60 seconds in a minute and 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * <p>\n+     * This returns <code>getMillis() / MILLIS_PER_HOUR</code>.\n+     * The result is an integer division, thus excess milliseconds are truncated.\n+     *\n+     * @return the length of the duration in standard seconds\n+     * @since 2.0\n+     */\n+    public long getStandardHours() {\n+        return getMillis() / DateTimeConstants.MILLIS_PER_HOUR;\n+    }\n+\n+    /**\n+     * Gets the length of this duration in minutes assuming that there are the\n+     * standard number of milliseconds in a minute.\n+     * <p>\n+     * This method assumes that there are 60 seconds in a minute and\n+     * 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * <p>\n+     * This returns <code>getMillis() / 60000</code>.\n+     * The result is an integer division, thus excess milliseconds are truncated.\n+     *\n+     * @return the length of the duration in standard seconds\n+     * @since 2.0\n+     */\n+    public long getStandardMinutes() {\n+        return getMillis() / DateTimeConstants.MILLIS_PER_MINUTE;\n+    }\n+\n+    /**\n+     * Gets the length of this duration in seconds assuming that there are the\n+     * standard number of milliseconds in a second.\n+     * <p>\n+     * This method assumes that there are 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * <p>\n+     * This returns <code>getMillis() / 1000</code>.\n+     * The result is an integer division, so 2999 millis returns 2 seconds.\n+     *\n+     * @return the length of the duration in standard seconds\n+     * @since 1.6\n+     */\n+    public long getStandardSeconds() {\n+        return getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this duration as an immutable <code>Duration</code> object\n+     * by returning <code>this</code>.\n+     * \n+     * @return <code>this</code>\n+     */\n+    public Duration toDuration() {\n+        return this;\n+    }\n+\n+    /**\n+     * Converts this duration to a period in days assuming that there are the\n+     * standard number of milliseconds in a day.\n+     * <p>\n+     * This method assumes that there are 24 hours in a day,\n+     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in\n+     * a second. This will be true for most days, however days with Daylight\n+     * Savings changes will not have 24 hours, so use this method with care.\n+     * \n+     * @return a period representing the number of standard days in this period, never null\n+     * @throws ArithmeticException if the number of days is too large to be represented\n+     * @since 2.0\n+     */\n+    public Days toStandardDays() {\n+        long days = getStandardDays();\n+        return Days.days(FieldUtils.safeToInt(days));\n+    }\n+\n+    /**\n+     * Converts this duration to a period in hours assuming that there are the\n+     * standard number of milliseconds in an hour.\n+     * <p>\n+     * This method assumes that there are 60 minutes in an hour,\n+     * 60 seconds in a minute and 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * \n+     * @return a period representing the number of standard hours in this period, never null\n+     * @throws ArithmeticException if the number of hours is too large to be represented\n+     * @since 2.0\n+     */\n+    public Hours toStandardHours() {\n+        long hours = getStandardHours();\n+        return Hours.hours(FieldUtils.safeToInt(hours));\n+    }\n+\n+    /**\n+     * Converts this duration to a period in minutes assuming that there are the\n+     * standard number of milliseconds in a minute.\n+     * <p>\n+     * This method assumes that there are 60 seconds in a minute and\n+     * 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * \n+     * @return a period representing the number of standard minutes in this period, never null\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     * @since 2.0\n+     */\n+    public Minutes toStandardMinutes() {\n+        long minutes = getStandardMinutes();\n+        return Minutes.minutes(FieldUtils.safeToInt(minutes));\n+    }\n+\n+    /**\n+     * Converts this duration to a period in seconds assuming that there are the\n+     * standard number of milliseconds in a second.\n+     * <p>\n+     * This method assumes that there are 1000 milliseconds in a second.\n+     * All currently supplied chronologies use this definition.\n+     * \n+     * @return a period representing the number of standard seconds in this period, never null\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     * @since 1.6\n+     */\n+    public Seconds toStandardSeconds() {\n+        long seconds = getStandardSeconds();\n+        return Seconds.seconds(FieldUtils.safeToInt(seconds));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new Duration instance with a different milisecond length.\n+     * \n+     * @param duration  the new length of the duration\n+     * @return the new duration instance\n+     */\n+    public Duration withMillis(long duration) {\n+        if (duration == getMillis()) {\n+            return this;\n+        }\n+        return new Duration(duration);\n+    }\n+\n+    /**\n+     * Returns a new duration with this length plus that specified multiplied by the scalar.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the addition is zero, this instance is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return the new duration instance\n+     */\n+    public Duration withDurationAdded(long durationToAdd, int scalar) {\n+        if (durationToAdd == 0 || scalar == 0) {\n+            return this;\n+        }\n+        long add = FieldUtils.safeMultiply(durationToAdd, scalar);\n+        long duration = FieldUtils.safeAdd(getMillis(), add);\n+        return new Duration(duration);\n+    }\n+\n+    /**\n+     * Returns a new duration with this length plus that specified multiplied by the scalar.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the addition is zero, this instance is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return the new duration instance\n+     */\n+    public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+        if (durationToAdd == null || scalar == 0) {\n+            return this;\n+        }\n+        return withDurationAdded(durationToAdd.getMillis(), scalar);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new duration with this length plus that specified.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the addition is zero, this instance is returned.\n+     * \n+     * @param amount  the duration to add to this one\n+     * @return the new duration instance\n+     */\n+    public Duration plus(long amount) {\n+        return withDurationAdded(amount, 1);\n+    }\n+\n+    /**\n+     * Returns a new duration with this length plus that specified.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the amount is zero, this instance is returned.\n+     * \n+     * @param amount  the duration to add to this one, null means zero\n+     * @return the new duration instance\n+     */\n+    public Duration plus(ReadableDuration amount) {\n+        if (amount == null) {\n+            return this;\n+        }\n+        return withDurationAdded(amount.getMillis(), 1);\n+    }\n+\n+    /**\n+     * Returns a new duration with this length minus that specified.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the addition is zero, this instance is returned.\n+     * \n+     * @param amount  the duration to take away from this one\n+     * @return the new duration instance\n+     */\n+    public Duration minus(long amount) {\n+        return withDurationAdded(amount, -1);\n+    }\n+\n+    /**\n+     * Returns a new duration with this length minus that specified.\n+     * This instance is immutable and is not altered.\n+     * <p>\n+     * If the amount is zero, this instance is returned.\n+     * \n+     * @param amount  the duration to take away from this one, null means zero\n+     * @return the new duration instance\n+     */\n+    public Duration minus(ReadableDuration amount) {\n+        if (amount == null) {\n+            return this;\n+        }\n+        return withDurationAdded(amount.getMillis(), -1);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DurationField.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines the calculation engine for duration fields.\n+ * The interface defines a set of methods that manipulate a millisecond duration\n+ * with regards to a single field, such as months or seconds.\n+ * <p>\n+ * This design is extensible so, if you wish, you can extract a different field from\n+ * the millisecond duration. A number of standard implementations are provided to assist.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class DurationField implements Comparable<DurationField> {\n+\n+    /**\n+     * Get the type of the field.\n+     * \n+     * @return field type\n+     */\n+    public abstract DurationFieldType getType();\n+\n+    /**\n+     * Get the name of the field.\n+     * <p>\n+     * By convention, names are plural.\n+     * \n+     * @return field name\n+     */\n+    public abstract String getName();\n+\n+    /**\n+     * Returns true if this field is supported.\n+     * \n+     * @return true if this field is supported\n+     */\n+    public abstract boolean isSupported();\n+\n+    /**\n+     * Is this field precise. A precise field can calculate its value from\n+     * milliseconds without needing a reference date. Put another way, a\n+     * precise field's unit size is not variable.\n+     * \n+     * @return true if precise\n+     * @see #getUnitMillis()\n+     */\n+    public abstract boolean isPrecise();\n+    \n+    /**\n+     * Returns the amount of milliseconds per unit value of this field. For\n+     * example, if this field represents \"seconds\", then this returns the\n+     * milliseconds in one second.\n+     * <p>\n+     * For imprecise fields, the unit size is variable, and so this method\n+     * returns a suitable average value.\n+     *\n+     * @return the unit size of this field, in milliseconds\n+     * @see #isPrecise()\n+     */\n+    public abstract long getUnitMillis();\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     * @throws ArithmeticException if the value is too large for an int\n+     */\n+    public abstract int getValue(long duration);\n+\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public abstract long getValueAsLong(long duration);\n+\n+    /**\n+     * Get the value of this field from the milliseconds relative to an\n+     * instant. For precise fields this method produces the same result as for\n+     * the single argument get method.\n+     * <p>\n+     * If the millisecond duration is positive, then the instant is treated as a\n+     * \"start instant\". If negative, the instant is treated as an \"end instant\".\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  the start instant to calculate relative to\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     * @throws ArithmeticException if the value is too large for an int\n+     */\n+    public abstract int getValue(long duration, long instant);\n+\n+    /**\n+     * Get the value of this field from the milliseconds relative to an\n+     * instant. For precise fields this method produces the same result as for\n+     * the single argument get method.\n+     * <p>\n+     * If the millisecond duration is positive, then the instant is treated as a\n+     * \"start instant\". If negative, the instant is treated as an \"end instant\".\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  the start instant to calculate relative to\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public abstract long getValueAsLong(long duration, long instant);\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public abstract long getMillis(int value);\n+\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public abstract long getMillis(long value);\n+\n+    /**\n+     * Get the millisecond duration of this field from its value relative to an\n+     * instant. For precise fields this method produces the same result as for\n+     * the single argument getMillis method.\n+     * <p>\n+     * If the value is positive, then the instant is treated as a \"start\n+     * instant\". If negative, the instant is treated as an \"end instant\".\n+     *\n+     * @param value  the value of the field, which may be negative\n+     * @param instant  the instant to calculate relative to\n+     * @return the millisecond duration that the field represents, which may be\n+     * negative\n+     */\n+    public abstract long getMillis(int value, long instant);\n+\n+    /**\n+     * Get the millisecond duration of this field from its value relative to an\n+     * instant. For precise fields this method produces the same result as for\n+     * the single argument getMillis method.\n+     * <p>\n+     * If the value is positive, then the instant is treated as a \"start\n+     * instant\". If negative, the instant is treated as an \"end instant\".\n+     *\n+     * @param value  the value of the field, which may be negative\n+     * @param instant  the instant to calculate relative to\n+     * @return the millisecond duration that the field represents, which may be\n+     * negative\n+     */\n+    public abstract long getMillis(long value, long instant);\n+\n+    /**\n+     * Adds a duration value (which may be negative) to the instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public abstract long add(long instant, int value);\n+\n+    /**\n+     * Adds a duration value (which may be negative) to the instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public abstract long add(long instant, long value);\n+\n+    /**\n+     * Subtracts a duration value (which may be negative) from the instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to subtract from\n+     * @param value  the value to subtract, in the units of the field\n+     * @return the updated milliseconds\n+     * @since 1.1\n+     */\n+    public long subtract(long instant, int value) {\n+        if (value == Integer.MIN_VALUE) {\n+            return subtract(instant, (long) value);\n+        }\n+        return add(instant, -value);\n+    }\n+\n+    /**\n+     * Subtracts a duration value (which may be negative) from the instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to subtract from\n+     * @param value  the value to subtract, in the units of the field\n+     * @return the updated milliseconds\n+     * @since 1.1\n+     */\n+    public long subtract(long instant, long value) {\n+        if (value == Long.MIN_VALUE) {\n+            throw new ArithmeticException(\"Long.MIN_VALUE cannot be negated\");\n+        }\n+        return add(instant, -value);\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public abstract int getDifference(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public abstract long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);\n+\n+    // Adding this definition would be backwards incompatible with earlier subclasses\n+    // This definition of compareTo was present in previous versions, and still applies\n+//    /**\n+//     * Compares this duration field with another duration field for ascending\n+//     * unit millisecond order. This ordering is inconsistent with equals, as it\n+//     * ignores name and precision.\n+//     *\n+//     * @param durationField  a duration field to check against\n+//     * @return negative value if this is less, 0 if equal, or positive value if greater\n+//     * @throws NullPointerException if the object is null\n+//     * @throws ClassCastException if the object type is not supported\n+//     */\n+//    public abstract int compareTo(DurationField durationField);\n+\n+    /**\n+     * Returns a localized unit name of this field, using the given value as an\n+     * aid. For example, the unit name may differ if it is plural.\n+     *\n+     * @param value the duration value to use for selecting a unit name\n+     * @param locale the locale to use for selecting a name, null for default\n+     */\n+    //String getUnitName(long value, Locale locale);\n+\n+    /**\n+     * Returns a localized unit name of this field, using the given value as an\n+     * aid. For example, the unit name may differ if it is plural.\n+     *\n+     * @param value the duration value to use for selecting a unit name\n+     */\n+    //String getUnitName(long value);\n+\n+    /**\n+     * Get the maximum length string returned by getUnitName.\n+     * \n+     * @param locale the locale to use for selecting a unit name, null for\n+     * default\n+     * @return the maximum name length\n+     */\n+    //int getMaximumUnitNameLength(Locale locale);\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public abstract String toString();\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/DurationFieldType.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Identifies a duration field, such as years or minutes, in a chronology-neutral way.\n+ * <p>\n+ * A duration field type defines the type of the field, such as hours.\n+ * If does not directly enable any calculations, however it does provide a\n+ * {@link #getField(Chronology)} method that returns the actual calculation engine\n+ * for a particular chronology.\n+ * <p>\n+ * Instances of <code>DurationFieldType</code> are singletons.\n+ * They can be compared using <code>==</code>.\n+ * <p>\n+ * If required, you can create your own field, for example a quarters.\n+ * You must create a subclass of <code>DurationFieldType</code> that defines the field type.\n+ * This class returns the actual calculation engine from {@link #getField(Chronology)}.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class DurationFieldType implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8765135187319L;\n+\n+    // Ordinals for standard field types.\n+    static final byte\n+        ERAS = 1,\n+        CENTURIES = 2,\n+        WEEKYEARS = 3,\n+        YEARS = 4,\n+        MONTHS = 5,\n+        WEEKS = 6,\n+        DAYS = 7,\n+        HALFDAYS = 8,\n+        HOURS = 9,\n+        MINUTES = 10,\n+        SECONDS = 11,\n+        MILLIS = 12;\n+\n+    /** The eras field type. */\n+    static final DurationFieldType ERAS_TYPE = new StandardDurationFieldType(\"eras\", ERAS);\n+    /** The centuries field type. */\n+    static final DurationFieldType CENTURIES_TYPE = new StandardDurationFieldType(\"centuries\", CENTURIES);\n+    /** The weekyears field type. */\n+    static final DurationFieldType WEEKYEARS_TYPE = new StandardDurationFieldType(\"weekyears\", WEEKYEARS);\n+    /** The years field type. */\n+    static final DurationFieldType YEARS_TYPE = new StandardDurationFieldType(\"years\", YEARS);\n+    /** The months field type. */\n+    static final DurationFieldType MONTHS_TYPE = new StandardDurationFieldType(\"months\", MONTHS);\n+    /** The weeks field type. */\n+    static final DurationFieldType WEEKS_TYPE = new StandardDurationFieldType(\"weeks\", WEEKS);\n+    /** The days field type. */\n+    static final DurationFieldType DAYS_TYPE = new StandardDurationFieldType(\"days\", DAYS);\n+    /** The halfdays field type. */\n+    static final DurationFieldType HALFDAYS_TYPE = new StandardDurationFieldType(\"halfdays\", HALFDAYS);\n+    /** The hours field type. */\n+    static final DurationFieldType HOURS_TYPE = new StandardDurationFieldType(\"hours\", HOURS);\n+    /** The minutes field type. */\n+    static final DurationFieldType MINUTES_TYPE = new StandardDurationFieldType(\"minutes\", MINUTES);\n+    /** The seconds field type. */\n+    static final DurationFieldType SECONDS_TYPE = new StandardDurationFieldType(\"seconds\", SECONDS);\n+    /** The millis field type. */\n+    static final DurationFieldType MILLIS_TYPE = new StandardDurationFieldType(\"millis\", MILLIS);\n+\n+    /** The name of the field type. */\n+    private final String iName;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param name  the name to use, which by convention, are plural.\n+     */\n+    protected DurationFieldType(String name) {\n+        super();\n+        iName = name;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType millis() {\n+        return MILLIS_TYPE;\n+    }\n+\n+    /**\n+     * Get the seconds field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType seconds() {\n+        return SECONDS_TYPE;\n+    }\n+\n+    /**\n+     * Get the minutes field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType minutes() {\n+        return MINUTES_TYPE;\n+    }\n+\n+    /**\n+     * Get the hours field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType hours() {\n+        return HOURS_TYPE;\n+    }\n+\n+    /**\n+     * Get the halfdays field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType halfdays() {\n+        return HALFDAYS_TYPE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the days field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType days() {\n+        return DAYS_TYPE;\n+    }\n+\n+    /**\n+     * Get the weeks field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType weeks() {\n+        return WEEKS_TYPE;\n+    }\n+\n+    /**\n+     * Get the weekyears field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType weekyears() {\n+        return WEEKYEARS_TYPE;\n+    }\n+\n+    /**\n+     * Get the months field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType months() {\n+        return MONTHS_TYPE;\n+    }\n+\n+    /**\n+     * Get the years field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType years() {\n+        return YEARS_TYPE;\n+    }\n+\n+    /**\n+     * Get the centuries field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType centuries() {\n+        return CENTURIES_TYPE;\n+    }\n+\n+    /**\n+     * Get the eras field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DurationFieldType eras() {\n+        return ERAS_TYPE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the name of the field.\n+     * By convention, names are plural.\n+     * \n+     * @return field name\n+     */\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * Gets a suitable field for this type from the given Chronology.\n+     *\n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n+     * @return a suitable field\n+     */\n+    public abstract DurationField getField(Chronology chronology);\n+\n+    /**\n+     * Checks whether this field supported in the given Chronology.\n+     *\n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n+     * @return true if supported\n+     */\n+    public boolean isSupported(Chronology chronology) {\n+        return getField(chronology).isSupported();\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return getName();\n+    }\n+\n+    private static class StandardDurationFieldType extends DurationFieldType {\n+        /** Serialization version */\n+        private static final long serialVersionUID = 31156755687123L;\n+\n+        /** The ordinal of the standard field type, for switch statements */\n+        private final byte iOrdinal;\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param name  the name to use\n+         */\n+        StandardDurationFieldType(String name, byte ordinal) {\n+            super(name);\n+            iOrdinal = ordinal;\n+        }\n+\n+        public DurationField getField(Chronology chronology) {\n+            chronology = DateTimeUtils.getChronology(chronology);\n+            \n+            switch (iOrdinal) {\n+                case ERAS:\n+                    return chronology.eras();\n+                case CENTURIES:\n+                    return chronology.centuries();\n+                case WEEKYEARS:\n+                    return chronology.weekyears();\n+                case YEARS:\n+                    return chronology.years();\n+                case MONTHS:\n+                    return chronology.months();\n+                case WEEKS:\n+                    return chronology.weeks();\n+                case DAYS:\n+                    return chronology.days();\n+                case HALFDAYS:\n+                    return chronology.halfdays();\n+                case HOURS:\n+                    return chronology.hours();\n+                case MINUTES:\n+                    return chronology.minutes();\n+                case SECONDS:\n+                    return chronology.seconds();\n+                case MILLIS:\n+                    return chronology.millis();\n+                default:\n+                    // Shouldn't happen.\n+                    throw new InternalError();\n+            }\n+        }\n+\n+        /**\n+         * Ensure a singleton is returned.\n+         * \n+         * @return the singleton type\n+         */\n+        private Object readResolve() {\n+            switch (iOrdinal) {\n+                case ERAS:\n+                    return ERAS_TYPE;\n+                case CENTURIES:\n+                    return CENTURIES_TYPE;\n+                case WEEKYEARS:\n+                    return WEEKYEARS_TYPE;\n+                case YEARS:\n+                    return YEARS_TYPE;\n+                case MONTHS:\n+                    return MONTHS_TYPE;\n+                case WEEKS:\n+                    return WEEKS_TYPE;\n+                case DAYS:\n+                    return DAYS_TYPE;\n+                case HALFDAYS:\n+                    return HALFDAYS_TYPE;\n+                case HOURS:\n+                    return HOURS_TYPE;\n+                case MINUTES:\n+                    return MINUTES_TYPE;\n+                case SECONDS:\n+                    return SECONDS_TYPE;\n+                case MILLIS:\n+                    return MILLIS_TYPE;\n+                default:\n+                    // Shouldn't happen.\n+                    return this;\n+            }\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Hours.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of hours.\n+ * <p>\n+ * <code>Hours</code> is an immutable period that can only store hours.\n+ * It does not store years, months or minutes for example. As such it is a\n+ * type-safe way of representing a number of hours in an application.\n+ * <p>\n+ * The number of hours is set in the constructor, and may be queried using\n+ * <code>getHours()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Hours</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Hours extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero hours. */\n+    public static final Hours ZERO = new Hours(0);\n+    /** Constant representing one hour. */\n+    public static final Hours ONE = new Hours(1);\n+    /** Constant representing two hours. */\n+    public static final Hours TWO = new Hours(2);\n+    /** Constant representing three hours. */\n+    public static final Hours THREE = new Hours(3);\n+    /** Constant representing four hours. */\n+    public static final Hours FOUR = new Hours(4);\n+    /** Constant representing five hours. */\n+    public static final Hours FIVE = new Hours(5);\n+    /** Constant representing six hours. */\n+    public static final Hours SIX = new Hours(6);\n+    /** Constant representing seven hours. */\n+    public static final Hours SEVEN = new Hours(7);\n+    /** Constant representing eight hours. */\n+    public static final Hours EIGHT = new Hours(8);\n+    /** Constant representing the maximum number of hours that can be stored in this object. */\n+    public static final Hours MAX_VALUE = new Hours(Integer.MAX_VALUE);\n+    /** Constant representing the minimum number of hours that can be stored in this object. */\n+    public static final Hours MIN_VALUE = new Hours(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.hours());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380864L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Hours</code> that may be cached.\n+     * <code>Hours</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param hours  the number of hours to obtain an instance for\n+     * @return the instance of Hours\n+     */\n+    public static Hours hours(int hours) {\n+        switch (hours) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case 4:\n+                return FOUR;\n+            case 5:\n+                return FIVE;\n+            case 6:\n+                return SIX;\n+            case 7:\n+                return SEVEN;\n+            case 8:\n+                return EIGHT;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Hours(hours);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Hours</code> representing the number of whole hours\n+     * between the two specified datetimes.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Hours hoursBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.hours());\n+        return Hours.hours(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Hours</code> representing the number of whole hours\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalTime</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Hours hoursBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalTime && end instanceof LocalTime)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int hours = chrono.hours().getDifference(\n+                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n+            return Hours.hours(hours);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Hours.hours(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Hours</code> representing the number of whole hours\n+     * in the specified interval.\n+     *\n+     * @param interval  the interval to extract hours from, null returns zero\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Hours hoursIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Hours.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours());\n+        return Hours.hours(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Hours</code> representing the number of complete\n+     * standard length hours in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, null returns zero\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Hours standardHoursIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_HOUR);\n+        return Hours.hours(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Hours</code> by parsing a string in the ISO8601 format 'PTnH'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * hours component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in hours\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Hours parseHours(String periodStr) {\n+        if (periodStr == null) {\n+            return Hours.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Hours.hours(p.getHours());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of hours.\n+     * You should consider using the factory method {@link #hours(int)}\n+     * instead of the constructor.\n+     *\n+     * @param hours  the number of hours to represent\n+     */\n+    private Hours(int hours) {\n+        super(hours);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Hours.hours(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>hours</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.hours();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>hours</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.hours();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in hours to a period in weeks assuming a\n+     * 7 day week and 24 hour day.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are 7 days\n+     * long and all days are 24 hours long.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole weeks for this number of hours\n+     */\n+    public Weeks toStandardWeeks() {\n+        return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Converts this period in hours to a period in days assuming a\n+     * 24 hour day.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours long.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole days for this number of hours\n+     */\n+    public Days toStandardDays() {\n+        return Days.days(getValue() / DateTimeConstants.HOURS_PER_DAY);\n+    }\n+\n+    /**\n+     * Converts this period in hours to a period in minutes assuming a\n+     * 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all hours are 60 minutes long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of minutes for this number of hours\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     */\n+    public Minutes toStandardMinutes() {\n+        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_HOUR));\n+    }\n+\n+    /**\n+     * Converts this period in hours to a period in seconds assuming a\n+     * 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all hours are\n+     * 60 minutes long and all minutes are 60 seconds long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of seconds for this number of hours\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     */\n+    public Seconds toStandardSeconds() {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_HOUR));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in hours to a duration in milliseconds assuming a\n+     * 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all hours are\n+     * 60 minutes and all minutes are 60 seconds. This might not be true for an\n+     * unusual chronology, for example one that takes leap seconds into account.\n+     * However, the method is included as it is a useful operation for many\n+     * applications and business rules.\n+     *\n+     * @return a duration equivalent to this number of hours\n+     */\n+    public Duration toStandardDuration() {\n+        long hours = getValue();  // assign to a long\n+        return new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of hours that this period represents.\n+     *\n+     * @return the number of hours in the period\n+     */\n+    public int getHours() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of hours added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new period plus the specified number of hours\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours plus(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        return Hours.hours(FieldUtils.safeAdd(getValue(), hours));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of hours added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to add, may be negative, null means zero\n+     * @return the new period plus the specified number of hours\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours plus(Hours hours) {\n+        if (hours == null) {\n+            return this;\n+        }\n+        return plus(hours.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of hours taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to take away, may be negative\n+     * @return the new period minus the specified number of hours\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours minus(int hours) {\n+        return plus(FieldUtils.safeNegate(hours));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of hours taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of hours\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours minus(Hours hours) {\n+        if (hours == null) {\n+            return this;\n+        }\n+        return minus(hours.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the hours multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours multipliedBy(int scalar) {\n+        return Hours.hours(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the hours divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Hours dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Hours.hours(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the hours value negated.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Hours negated() {\n+        return Hours.hours(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this hours instance greater than the specified number of hours.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this hours instance is greater than the specified one\n+     */\n+    public boolean isGreaterThan(Hours other) {\n+        if (other == null) {\n+            return getValue() > 0;\n+        }\n+        return getValue() > other.getValue();\n+    }\n+\n+    /**\n+     * Is this hours instance less than the specified number of hours.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this hours instance is less than the specified one\n+     */\n+    public boolean isLessThan(Hours other) {\n+        if (other == null) {\n+            return getValue() < 0;\n+        }\n+        return getValue() < other.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"PT4H\" represents 4 hours.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"PT\" + String.valueOf(getValue()) + \"H\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/IllegalFieldValueException.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Exception thrown when attempting to set a field outside its supported range.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.1\n+ */\n+public class IllegalFieldValueException extends IllegalArgumentException {\n+    \n+    /** Serialization lock. */\n+    private static final long serialVersionUID = 6305711765985447737L;\n+\n+    /**\n+     * Creates a message for the exception.\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value rejected\n+     * @param lowerBound  the lower bound allowed\n+     * @param upperBound  the uppe bound allowed\n+     * @param explain  an explanation\n+     * @return the message\n+     */\n+    private static String createMessage(String fieldName, Number value,\n+                                        Number lowerBound, Number upperBound, String explain) {\n+        StringBuffer buf = new StringBuffer()\n+            .append(\"Value \").append(value).append(\" for \").append(fieldName).append(' ');\n+\n+        if (lowerBound == null) {\n+            if (upperBound == null) {\n+                buf.append(\"is not supported\");\n+            } else {\n+                buf.append(\"must not be larger than \").append(upperBound);\n+            }\n+        } else if (upperBound == null) {\n+            buf.append(\"must not be smaller than \").append(lowerBound);\n+        } else {\n+            buf.append(\"must be in the range [\")\n+                .append(lowerBound)\n+                .append(',')\n+                .append(upperBound)\n+                .append(']');\n+        }\n+        if (explain != null) {\n+            buf.append(\": \").append(explain);\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Creates a message for the exception.\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value rejected\n+     * @return the message\n+     */\n+    private static String createMessage(String fieldName, String value) {\n+        StringBuffer buf = new StringBuffer().append(\"Value \");\n+\n+        if (value == null) {\n+            buf.append(\"null\");\n+        } else {\n+            buf.append('\"');\n+            buf.append(value);\n+            buf.append('\"');\n+        }\n+\n+        buf.append(\" for \").append(fieldName).append(' ').append(\"is not supported\");\n+        \n+        return buf.toString();\n+    }\n+\n+    private final DateTimeFieldType iDateTimeFieldType;\n+    private final DurationFieldType iDurationFieldType;\n+    private final String iFieldName;\n+    private final Number iNumberValue;\n+    private final String iStringValue;\n+    private final Number iLowerBound;\n+    private final Number iUpperBound;\n+    private String iMessage;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param fieldType  type of field being set\n+     * @param value  illegal value being set\n+     * @param lowerBound  lower legal field value, or null if not applicable\n+     * @param upperBound  upper legal field value, or null if not applicable\n+     */\n+    public IllegalFieldValueException(DateTimeFieldType fieldType,\n+                                      Number value, Number lowerBound, Number upperBound) {\n+        super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null));\n+        iDateTimeFieldType = fieldType;\n+        iDurationFieldType = null;\n+        iFieldName = fieldType.getName();\n+        iNumberValue = value;\n+        iStringValue = null;\n+        iLowerBound = lowerBound;\n+        iUpperBound = upperBound;\n+        iMessage = super.getMessage();\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param fieldType  type of field being set\n+     * @param value  illegal value being set\n+     * @param explain  an explanation\n+     * @since 1.5\n+     */\n+    public IllegalFieldValueException(DateTimeFieldType fieldType,\n+                                      Number value, String explain) {\n+        super(createMessage(fieldType.getName(), value, null, null, explain));\n+        iDateTimeFieldType = fieldType;\n+        iDurationFieldType = null;\n+        iFieldName = fieldType.getName();\n+        iNumberValue = value;\n+        iStringValue = null;\n+        iLowerBound = null;\n+        iUpperBound = null;\n+        iMessage = super.getMessage();\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param fieldType  type of field being set\n+     * @param value  illegal value being set\n+     * @param lowerBound  lower legal field value, or null if not applicable\n+     * @param upperBound  upper legal field value, or null if not applicable\n+     */\n+    public IllegalFieldValueException(DurationFieldType fieldType,\n+                                      Number value, Number lowerBound, Number upperBound) {\n+        super(createMessage(fieldType.getName(), value, lowerBound, upperBound, null));\n+        iDateTimeFieldType = null;\n+        iDurationFieldType = fieldType;\n+        iFieldName = fieldType.getName();\n+        iNumberValue = value;\n+        iStringValue = null;\n+        iLowerBound = lowerBound;\n+        iUpperBound = upperBound;\n+        iMessage = super.getMessage();\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param fieldName  name of field being set\n+     * @param value  illegal value being set\n+     * @param lowerBound  lower legal field value, or null if not applicable\n+     * @param upperBound  upper legal field value, or null if not applicable\n+     */\n+    public IllegalFieldValueException(String fieldName,\n+                                      Number value, Number lowerBound, Number upperBound) {\n+        super(createMessage(fieldName, value, lowerBound, upperBound, null));\n+        iDateTimeFieldType = null;\n+        iDurationFieldType = null;\n+        iFieldName = fieldName;\n+        iNumberValue = value;\n+        iStringValue = null;\n+        iLowerBound = lowerBound;\n+        iUpperBound = upperBound;\n+        iMessage = super.getMessage();\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param fieldType  type of field being set\n+     * @param value  illegal value being set\n+     */\n+    public IllegalFieldValueException(DateTimeFieldType fieldType, String value) {\n+        super(createMessage(fieldType.getName(), value));\n+        iDateTimeFieldType = fieldType;\n+        iDurationFieldType = null;\n+        iFieldName = fieldType.getName();\n+        iStringValue = value;\n+        iNumberValue = null;\n+        iLowerBound = null;\n+        iUpperBound = null;\n+        iMessage = super.getMessage();\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param fieldType  type of field being set\n+     * @param value  illegal value being set\n+     */\n+    public IllegalFieldValueException(DurationFieldType fieldType, String value) {\n+        super(createMessage(fieldType.getName(), value));\n+        iDateTimeFieldType = null;\n+        iDurationFieldType = fieldType;\n+        iFieldName = fieldType.getName();\n+        iStringValue = value;\n+        iNumberValue = null;\n+        iLowerBound = null;\n+        iUpperBound = null;\n+        iMessage = super.getMessage();\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param fieldName  name of field being set\n+     * @param value  illegal value being set\n+     */\n+    public IllegalFieldValueException(String fieldName, String value) {\n+        super(createMessage(fieldName, value));\n+        iDateTimeFieldType = null;\n+        iDurationFieldType = null;\n+        iFieldName = fieldName;\n+        iStringValue = value;\n+        iNumberValue = null;\n+        iLowerBound = null;\n+        iUpperBound = null;\n+        iMessage = super.getMessage();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the DateTimeFieldType whose value was invalid, or null if not applicable.\n+     * \n+     * @return the datetime field type\n+     */\n+    public DateTimeFieldType getDateTimeFieldType() {\n+        return iDateTimeFieldType;\n+    }\n+\n+    /**\n+     * Returns the DurationFieldType whose value was invalid, or null if not applicable.\n+     * \n+     * @return the duration field type\n+     */\n+    public DurationFieldType getDurationFieldType() {\n+        return iDurationFieldType;\n+    }\n+\n+    /**\n+     * Returns the name of the field whose value was invalid.\n+     * \n+     * @return the field name\n+     */\n+    public String getFieldName() {\n+        return iFieldName;\n+    }\n+\n+    /**\n+     * Returns the illegal integer value assigned to the field, or null if not applicable.\n+     * \n+     * @return the value\n+     */\n+    public Number getIllegalNumberValue() {\n+        return iNumberValue;\n+    }\n+\n+    /**\n+     * Returns the illegal string value assigned to the field, or null if not applicable.\n+     * \n+     * @return the value\n+     */\n+    public String getIllegalStringValue() {\n+        return iStringValue;\n+    }\n+\n+    /**\n+     * Returns the illegal value assigned to the field as a non-null string.\n+     * \n+     * @return the value\n+     */\n+    public String getIllegalValueAsString() {\n+        String value = iStringValue;\n+        if (value == null) {\n+            value = String.valueOf(iNumberValue);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the lower bound of the legal value range, or null if not applicable.\n+     * \n+     * @return the lower bound\n+     */\n+    public Number getLowerBound() {\n+        return iLowerBound;\n+    }\n+\n+    /**\n+     * Returns the upper bound of the legal value range, or null if not applicable.\n+     * \n+     * @return the upper bound\n+     */\n+    public Number getUpperBound() {\n+        return iUpperBound;\n+    }\n+\n+    public String getMessage() {\n+        return iMessage;\n+    }\n+\n+    /**\n+     * Provide additional detail by prepending a message to the existing message.\n+     * A colon is separator is automatically inserted between the messages.\n+     * @since 1.3\n+     */\n+    public void prependMessage(String message) {\n+        if (iMessage == null) {\n+            iMessage = message;\n+        } else if (message != null) {\n+            iMessage = message + \": \" + iMessage;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Instant.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.base.AbstractInstant;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * Instant is the standard implementation of a fully immutable instant in time.\n+ * <p>\n+ * <code>Instant</code> is an implementation of {@link ReadableInstant}.\n+ * As with all instants, it represents an exact point on the time-line,\n+ * but limited to the precision of milliseconds. An <code>Instant</code>\n+ * should be used to represent a point in time irrespective of any other\n+ * factor, such as chronology or time zone.\n+ * <p>\n+ * Internally, the class holds one piece of data, the instant as milliseconds\n+ * from the Java epoch of 1970-01-01T00:00:00Z.\n+ * <p>\n+ * For example, an Instant can be used to compare two <code>DateTime</code>\n+ * objects irrespective of chronology or time zone.\n+ * <pre>\n+ * boolean sameInstant = dt1.toInstant().equals(dt2.toInstant());\n+ * </pre>\n+ * Note that the following code will also perform the same check:\n+ * <pre>\n+ * boolean sameInstant = dt1.isEqual(dt2);\n+ * </pre>\n+ * <p>\n+ * Instant is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class Instant\n+        extends AbstractInstant\n+        implements ReadableInstant, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 3299096530934209741L;\n+\n+    /** The millis from 1970-01-01T00:00:00Z */\n+    private final long iMillis;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time.\n+     */\n+    public Instant() {\n+        super();\n+        iMillis = DateTimeUtils.currentTimeMillis();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public Instant(long instant) {\n+        super();\n+        iMillis = instant;\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public Instant(Object instant) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as an Instant by returning <code>this</code>.\n+     * \n+     * @return <code>this</code>\n+     */\n+    public Instant toInstant() {\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with different millis.\n+     * <p>\n+     * The returned object will be either be a new Instant or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    public Instant withMillis(long newMillis) {\n+        return (newMillis == iMillis ? this : new Instant(newMillis));\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instant with the duration added\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant withDurationAdded(long durationToAdd, int scalar) {\n+        if (durationToAdd == 0 || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(getMillis(), durationToAdd, scalar);\n+        return withMillis(instant);\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * \n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instant with the duration added\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+        if (durationToAdd == null || scalar == 0) {\n+            return this;\n+        }\n+        return withDurationAdded(durationToAdd.getMillis(), scalar);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to add to this one\n+     * @return a copy of this instant with the duration added\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant plus(long duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to add to this one, null means zero\n+     * @return a copy of this instant with the duration added\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant plus(ReadableDuration duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this instant with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this instant with the duration taken away\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant minus(long duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * \n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this instant with the duration taken away\n+     * @throws ArithmeticException if the new instant exceeds the capacity of a long\n+     */\n+    public Instant minus(ReadableDuration duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the instant.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the instant, which is ISO in the UTC zone.\n+     * <p>\n+     * This method returns {@link ISOChronology#getInstanceUTC()} which\n+     * corresponds to the definition of the Java epoch 1970-01-01T00:00:00Z.\n+     * \n+     * @return ISO in the UTC zone\n+     */\n+    public Chronology getChronology() {\n+        return ISOChronology.getInstanceUTC();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as a DateTime using ISOChronology in the default zone.\n+     * <p>\n+     * This method returns a DateTime object in the default zone.\n+     * This differs from the similarly named method on DateTime, DateMidnight\n+     * or MutableDateTime which retains the time zone. The difference is\n+     * because Instant really represents a time <i>without</i> a zone,\n+     * thus calling this method we really have no zone to 'retain' and\n+     * hence expect to switch to the default zone.\n+     * <p>\n+     * This method definition preserves compatibility with earlier versions\n+     * of Joda-Time.\n+     *\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime() {\n+        return new DateTime(getMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Get this object as a DateTime using ISOChronology in the default zone.\n+     * This method is identical to <code>toDateTime()</code>.\n+     * <p>\n+     * This method returns a DateTime object in the default zone.\n+     * This differs from the similarly named method on DateTime, DateMidnight\n+     * or MutableDateTime which retains the time zone. The difference is\n+     * because Instant really represents a time <i>without</i> a zone,\n+     * thus calling this method we really have no zone to 'retain' and\n+     * hence expect to switch to the default zone.\n+     * <p>\n+     * This method is deprecated because it is a duplicate of {@link #toDateTime()}.\n+     * However, removing it would cause the superclass implementation to be used,\n+     * which would create silent bugs in any caller depending on this implementation.\n+     * As such, the method itself is not currently planned to be removed.\n+     * <p>\n+     * This method definition preserves compatibility with earlier versions\n+     * of Joda-Time.\n+     *\n+     * @return a DateTime using the same millis with ISOChronology\n+     * @deprecated Use toDateTime() as it is identical\n+     */\n+    public DateTime toDateTimeISO() {\n+        return toDateTime();\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime using ISOChronology in the default zone.\n+     * <p>\n+     * This method returns a MutableDateTime object in the default zone.\n+     * This differs from the similarly named method on DateTime, DateMidnight\n+     * or MutableDateTime which retains the time zone. The difference is\n+     * because Instant really represents a time <i>without</i> a zone,\n+     * thus calling this method we really have no zone to 'retain' and\n+     * hence expect to switch to the default zone.\n+     * <p>\n+     * This method definition preserves compatibility with earlier versions\n+     * of Joda-Time.\n+     *\n+     * @return a MutableDateTime using the same millis\n+     */\n+    public MutableDateTime toMutableDateTime() {\n+        return new MutableDateTime(getMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime using ISOChronology in the default zone.\n+     * This method is identical to <code>toMutableDateTime()</code>.\n+     * <p>\n+     * This method returns a MutableDateTime object in the default zone.\n+     * This differs from the similarly named method on DateTime, DateMidnight\n+     * or MutableDateTime which retains the time zone. The difference is\n+     * because Instant really represents a time <i>without</i> a zone,\n+     * thus calling this method we really have no zone to 'retain' and\n+     * hence expect to switch to the default zone.\n+     * <p>\n+     * This method is deprecated because it is a duplicate of {@link #toMutableDateTime()}.\n+     * However, removing it would cause the superclass implementation to be used,\n+     * which would create silent bugs in any caller depending on this implementation.\n+     * As such, the method itself is not currently planned to be removed.\n+     * <p>\n+     * This method definition preserves compatibility with earlier versions\n+     * of Joda-Time.\n+     *\n+     * @return a MutableDateTime using the same millis with ISOChronology\n+     * @deprecated Use toMutableDateTime() as it is identical\n+     */\n+    public MutableDateTime toMutableDateTimeISO() {\n+        return toMutableDateTime();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Interval.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.base.BaseInterval;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.format.ISOPeriodFormat;\n+\n+/**\n+ * Interval is the standard implementation of an immutable time interval.\n+ * <p>\n+ * A time interval represents a period of time between two instants.\n+ * Intervals are inclusive of the start instant and exclusive of the end.\n+ * The end instant is always greater than or equal to the start instant.\n+ * <p>\n+ * Intervals have a fixed millisecond duration.\n+ * This is the difference between the start and end instants.\n+ * The duration is represented separately by {@link ReadableDuration}.\n+ * As a result, intervals are not comparable.\n+ * To compare the length of two intervals, you should compare their durations.\n+ * <p>\n+ * An interval can also be converted to a {@link ReadablePeriod}.\n+ * This represents the difference between the start and end points in terms of fields\n+ * such as years and days.\n+ * <p>\n+ * Interval is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Sean Geoghegan\n+ * @author Stephen Colebourne\n+ * @author Julen Parra\n+ * @since 1.0\n+ */\n+public final class Interval\n+        extends BaseInterval\n+        implements ReadableInterval, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4922451897541386752L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an interval from a start and end instant with the ISO\n+     * default chronology in the default time zone.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public Interval(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant with the ISO\n+     * default chronology in the specified time zone.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param zone  the time zone to use, null means default zone\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @since 1.5\n+     */\n+    public Interval(long startInstant, long endInstant, DateTimeZone zone) {\n+        super(startInstant, endInstant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant with the\n+     * specified chronology.\n+     * \n+     * @param chronology  the chronology to use, null is ISO default\n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public Interval(long startInstant, long endInstant, Chronology chronology) {\n+        super(startInstant, endInstant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * <p>\n+     * The chronology used is that of the start instant.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public Interval(ReadableInstant start, ReadableInstant end) {\n+        super(start, end);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a duration.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param duration  the duration of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public Interval(ReadableInstant start, ReadableDuration duration) {\n+        super(start, duration);\n+    }\n+\n+    /**\n+     * Constructs an interval from a millisecond duration and an end instant.\n+     * \n+     * @param duration  the duration of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public Interval(ReadableDuration duration, ReadableInstant end) {\n+        super(duration, end);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a time period.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param period  the period of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public Interval(ReadableInstant start, ReadablePeriod period) {\n+        super(start, period);\n+    }\n+\n+    /**\n+     * Constructs an interval from a time period and an end instant.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param period  the period of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public Interval(ReadablePeriod period, ReadableInstant end) {\n+        super(period, end);\n+    }\n+\n+    /**\n+     * Constructs a time interval by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInterval and String.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n+     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n+     * 'datetime/period' or 'period/datetime'.\n+     * \n+     * @param interval  the time interval to copy\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    public Interval(Object interval) {\n+        super(interval, null);\n+    }\n+\n+    /**\n+     * Constructs a time interval by converting or copying from another object,\n+     * overriding the chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInterval and String.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n+     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n+     * 'datetime/period' or 'period/datetime'.\n+     * \n+     * @param interval  the time interval to copy\n+     * @param chronology  the chronology to use, null means ISO default\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    public Interval(Object interval, Chronology chronology) {\n+        super(interval, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this interval as an immutable <code>Interval</code> object\n+     * by returning <code>this</code>.\n+     *\n+     * @return <code>this</code>\n+     */\n+    public Interval toInterval() {\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the overlap between this interval and another interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval overlaps another if it shares some common part of the\n+     * datetime continuum. This method returns the amount of the overlap,\n+     * only if the intervals actually do overlap.\n+     * If the intervals do not overlap, then null is returned.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n+     * <p>\n+     * The chronology of the returned interval is the same as that of\n+     * this interval (the chronology of the interval parameter is not used).\n+     * Note that the use of the chronology was only correctly implemented\n+     * in version 1.3.\n+     *\n+     * @param interval  the interval to examine, null means now\n+     * @return the overlap interval, null if no overlap\n+     * @since 1.1\n+     */\n+    public Interval overlap(ReadableInterval interval) {\n+        interval = DateTimeUtils.getReadableInterval(interval);\n+        if (overlaps(interval) == false) {\n+            return null;\n+        }\n+        long start = Math.max(getStartMillis(), interval.getStartMillis());\n+        long end = Math.min(getEndMillis(), interval.getEndMillis());\n+        return new Interval(start, end, getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the gap between this interval and another interval.\n+     * The other interval can be either before or after this interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval has a gap to another interval if there is a non-zero\n+     * duration between them. This method returns the amount of the gap only\n+     * if the intervals do actually have a gap between them.\n+     * If the intervals overlap or abut, then null is returned.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n+     * <p>\n+     * The chronology of the returned interval is the same as that of\n+     * this interval (the chronology of the interval parameter is not used).\n+     * Note that the use of the chronology was only correctly implemented\n+     * in version 1.3.\n+     *\n+     * @param interval  the interval to examine, null means now\n+     * @return the gap interval, null if no gap\n+     * @since 1.1\n+     */\n+    public Interval gap(ReadableInterval interval) {\n+        interval = DateTimeUtils.getReadableInterval(interval);\n+        long otherStart = interval.getStartMillis();\n+        long otherEnd = interval.getEndMillis();\n+        long thisStart = getStartMillis();\n+        long thisEnd = getEndMillis();\n+        if (thisStart > otherEnd) {\n+            return new Interval(otherEnd, thisStart, getChronology());\n+        } else if (otherStart > thisEnd) {\n+            return new Interval(thisEnd, otherStart, getChronology());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this interval abut with the interval specified.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval abuts if it starts immediately after, or ends immediately\n+     * before this interval without overlap.\n+     * A zero duration interval abuts with itself.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * [09:00 to 10:00) abuts [08:00 to 08:30)  = false (completely before)\n+     * [09:00 to 10:00) abuts [08:00 to 09:00)  = true\n+     * [09:00 to 10:00) abuts [08:00 to 09:01)  = false (overlaps)\n+     * \n+     * [09:00 to 10:00) abuts [09:00 to 09:00)  = true\n+     * [09:00 to 10:00) abuts [09:00 to 09:01)  = false (overlaps)\n+     * \n+     * [09:00 to 10:00) abuts [10:00 to 10:00)  = true\n+     * [09:00 to 10:00) abuts [10:00 to 10:30)  = true\n+     * \n+     * [09:00 to 10:00) abuts [10:30 to 11:00)  = false (completely after)\n+     * \n+     * [14:00 to 14:00) abuts [14:00 to 14:00)  = true\n+     * [14:00 to 14:00) abuts [14:00 to 15:00)  = true\n+     * [14:00 to 14:00) abuts [13:00 to 14:00)  = true\n+     * </pre>\n+     *\n+     * @param interval  the interval to examine, null means now\n+     * @return true if the interval abuts\n+     * @since 1.1\n+     */\n+    public boolean abuts(ReadableInterval interval) {\n+        if (interval == null) {\n+            long now = DateTimeUtils.currentTimeMillis();\n+            return (getStartMillis() == now || getEndMillis() == now);\n+        } else {\n+            return (interval.getEndMillis() == getStartMillis() ||\n+                    getEndMillis() == interval.getStartMillis());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new interval with the same start and end, but a different chronology.\n+     *\n+     * @param chronology  the chronology to use, null means ISO default\n+     * @return an interval with a different chronology\n+     */\n+    public Interval withChronology(Chronology chronology) {\n+        if (getChronology() == chronology) {\n+            return this;\n+        }\n+        return new Interval(getStartMillis(), getEndMillis(), chronology);\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified start millisecond instant.\n+     *\n+     * @param startInstant  the start instant for the new interval\n+     * @return an interval with the end from this interval and the specified start\n+     * @throws IllegalArgumentException if the resulting interval has end before start\n+     */\n+    public Interval withStartMillis(long startInstant) {\n+        if (startInstant == getStartMillis()) {\n+            return this;\n+        }\n+        return new Interval(startInstant, getEndMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified start instant.\n+     *\n+     * @param start  the start instant for the new interval, null means now\n+     * @return an interval with the end from this interval and the specified start\n+     * @throws IllegalArgumentException if the resulting interval has end before start\n+     */\n+    public Interval withStart(ReadableInstant start) {\n+        long startMillis = DateTimeUtils.getInstantMillis(start);\n+        return withStartMillis(startMillis);\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified start millisecond instant.\n+     *\n+     * @param endInstant  the end instant for the new interval\n+     * @return an interval with the start from this interval and the specified end\n+     * @throws IllegalArgumentException if the resulting interval has end before start\n+     */\n+    public Interval withEndMillis(long endInstant) {\n+        if (endInstant == getEndMillis()) {\n+            return this;\n+        }\n+        return new Interval(getStartMillis(), endInstant, getChronology());\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified end instant.\n+     *\n+     * @param end  the end instant for the new interval, null means now\n+     * @return an interval with the start from this interval and the specified end\n+     * @throws IllegalArgumentException if the resulting interval has end before start\n+     */\n+    public Interval withEnd(ReadableInstant end) {\n+        long endMillis = DateTimeUtils.getInstantMillis(end);\n+        return withEndMillis(endMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new interval with the specified duration after the start instant.\n+     *\n+     * @param duration  the duration to add to the start to get the new end instant, null means zero\n+     * @return an interval with the start from this interval and a calculated end\n+     * @throws IllegalArgumentException if the duration is negative\n+     */\n+    public Interval withDurationAfterStart(ReadableDuration duration) {\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        if (durationMillis == toDurationMillis()) {\n+            return this;\n+        }\n+        Chronology chrono = getChronology();\n+        long startMillis = getStartMillis();\n+        long endMillis = chrono.add(startMillis, durationMillis, 1);\n+        return new Interval(startMillis, endMillis, chrono);\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified duration before the end instant.\n+     *\n+     * @param duration  the duration to add to the start to get the new end instant, null means zero\n+     * @return an interval with the start from this interval and a calculated end\n+     * @throws IllegalArgumentException if the duration is negative\n+     */\n+    public Interval withDurationBeforeEnd(ReadableDuration duration) {\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        if (durationMillis == toDurationMillis()) {\n+            return this;\n+        }\n+        Chronology chrono = getChronology();\n+        long endMillis = getEndMillis();\n+        long startMillis = chrono.add(endMillis, durationMillis, -1);\n+        return new Interval(startMillis, endMillis, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new interval with the specified period after the start instant.\n+     *\n+     * @param period  the period to add to the start to get the new end instant, null means zero\n+     * @return an interval with the start from this interval and a calculated end\n+     * @throws IllegalArgumentException if the period is negative\n+     */\n+    public Interval withPeriodAfterStart(ReadablePeriod period) {\n+        if (period == null) {\n+            return withDurationAfterStart(null);\n+        }\n+        Chronology chrono = getChronology();\n+        long startMillis = getStartMillis();\n+        long endMillis = chrono.add(period, startMillis, 1);\n+        return new Interval(startMillis, endMillis, chrono);\n+    }\n+\n+    /**\n+     * Creates a new interval with the specified period before the end instant.\n+     *\n+     * @param period  the period to add to the start to get the new end instant, null means zero\n+     * @return an interval with the start from this interval and a calculated end\n+     * @throws IllegalArgumentException if the period is negative\n+     */\n+    public Interval withPeriodBeforeEnd(ReadablePeriod period) {\n+        if (period == null) {\n+            return withDurationBeforeEnd(null);\n+        }\n+        Chronology chrono = getChronology();\n+        long endMillis = getEndMillis();\n+        long startMillis = chrono.add(period, endMillis, -1);\n+        return new Interval(startMillis, endMillis, chrono);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/JodaTimePermission.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.security.BasicPermission;\n+\n+/**\n+ * JodaTimePermission is used for securing global method calls in the Joda-Time\n+ * library. Since this class extends BasicPermission, asterisks may be used to\n+ * denote wildcard permissions. The following permissions are supported:\n+ *\n+ * <pre>\n+ * DateTimeZone\n+ *   .setDefault                 Allows a default DateTimeZone to be set\n+ *   .setProvider                Allows the DateTimeZone instance provider to be set\n+ *   .setNameProvider            Allows the DateTimeZone name provider to be set\n+ *\n+ * ConverterManager\n+ *   .alterInstantConverters     Allows an instant converter to be added or removed\n+ *   .alterPartialConverters     Allows a partial converter to be added or removed\n+ *   .alterDurationConverters    Allows a duration converter to be added or removed\n+ *   .alterPeriodConverters      Allows a period converter to be added or removed\n+ *   .alterIntervalConverters    Allows an interval converter to be added or removed\n+ *\n+ * CurrentTime.setProvider       Allows the current time provider to be set\n+ * </pre>\n+ * <p>\n+ * JodaTimePermission is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class JodaTimePermission extends BasicPermission {\n+    \n+    /** Serialization version */\n+    private static final long serialVersionUID = 1408944367355875472L;\n+\n+    /**\n+     * Constructs a new permission object.\n+     * \n+     * @param name  the permission name\n+     */\n+    public JodaTimePermission(String name) {\n+        super(name);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/LocalDate.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.TimeZone;\n+\n+import org.joda.time.base.BaseLocal;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.PartialConverter;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * LocalDate is an immutable datetime class representing a date\n+ * without a time zone.\n+ * <p>\n+ * LocalDate implements the {@link ReadablePartial} interface.\n+ * To do this, the interface methods focus on the key fields -\n+ * Year, MonthOfYear and DayOfMonth.\n+ * However, <b>all</b> date fields may in fact be queried.\n+ * <p>\n+ * LocalDate differs from DateMidnight in that this class does not\n+ * have a time zone and does not represent a single instant in time.\n+ * <p>\n+ * Calculations on LocalDate are performed using a {@link Chronology}.\n+ * This chronology will be set internally to be in the UTC time zone\n+ * for all calculations.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getMonthOfYear()</code>\n+ * <li><code>monthOfYear().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ *\n+ * <p>\n+ * LocalDate is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.3\n+ */\n+public final class LocalDate\n+        extends BaseLocal\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -8775358157899L;\n+\n+    /** The index of the year field in the field array */\n+    private static final int YEAR = 0;\n+    /** The index of the monthOfYear field in the field array */\n+    private static final int MONTH_OF_YEAR = 1;\n+    /** The index of the dayOfMonth field in the field array */\n+    private static final int DAY_OF_MONTH = 2;\n+    /** Set of known duration types. */\n+    private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>();\n+    static {\n+        DATE_DURATION_TYPES.add(DurationFieldType.days());\n+        DATE_DURATION_TYPES.add(DurationFieldType.weeks());\n+        DATE_DURATION_TYPES.add(DurationFieldType.months());\n+        DATE_DURATION_TYPES.add(DurationFieldType.weekyears());\n+        DATE_DURATION_TYPES.add(DurationFieldType.years());\n+        DATE_DURATION_TYPES.add(DurationFieldType.centuries());\n+        // eras are supported, although the DurationField generally isn't\n+        DATE_DURATION_TYPES.add(DurationFieldType.eras());\n+    }\n+\n+    /** The local millis from 1970-01-01T00:00:00 */\n+    private long iLocalMillis;\n+    /** The chronology to use in UTC. */\n+    private Chronology iChronology;\n+    /** The cached hash code. */\n+    private transient volatile int iHash;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n+     * using exactly the same field values.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the LocalDate.\n+     * This is useful if you have been using the Calendar as a local date,\n+     * ignoring the zone.\n+     * <p>\n+     * One advantage of this method is that this method is unaffected if the\n+     * version of the time zone data differs between the JDK and Joda-Time.\n+     * That is because the local field values are transferred, calculated using\n+     * the JDK time zone data and without using the Joda-Time time zone data.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a LocalDate with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created LocalDate\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalDate fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new LocalDate(\n+            calendar.get(Calendar.YEAR),\n+            calendar.get(Calendar.MONTH) + 1,\n+            calendar.get(Calendar.DAY_OF_MONTH)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a LocalDate from a <code>java.util.Date</code>\n+     * using exactly the same field values.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the LocalDate.\n+     * This is useful if you have been using the Date as a local date,\n+     * ignoring the zone.\n+     * <p>\n+     * One advantage of this method is that this method is unaffected if the\n+     * version of the time zone data differs between the JDK and Joda-Time.\n+     * That is because the local field values are transferred, calculated using\n+     * the JDK time zone data and without using the Joda-Time time zone data.\n+     * <p>\n+     * This factory method always creates a LocalDate with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created LocalDate\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalDate fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new LocalDate(\n+            date.getYear() + 1900,\n+            date.getMonth() + 1,\n+            date.getDate()\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     */\n+    public LocalDate() {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public LocalDate(DateTimeZone zone) {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalDate(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public LocalDate(long instant) {\n+        this(instant, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public LocalDate(long instant, DateTimeZone zone) {\n+        this(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalDate(long instant, Chronology chronology) {\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        \n+        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n+        chronology = chronology.withUTC();\n+        iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\n+        iChronology = chronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * The time zone will be retrieved from the object if possible,\n+     * otherwise the default time zone will be used.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalDate(Object instant) {\n+        this(instant, (Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @param zone  the time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalDate(Object instant, DateTimeZone zone) {\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        Chronology chronology = converter.getChronology(instant, zone);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalDate(Object instant, Chronology chronology) {\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public LocalDate(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth) {\n+        this(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalDate(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+        iChronology = chronology;\n+        iLocalMillis = instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is three.\n+     * The supported fields are Year, MonthOfYear and DayOfMonth.\n+     * Note that all fields from day and above may in fact be queried via\n+     * other methods.\n+     *\n+     * @return the field count, three\n+     */\n+    public int size() {\n+        return 3;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     *\n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case MONTH_OF_YEAR:\n+                return chrono.monthOfYear();\n+            case DAY_OF_MONTH:\n+                return chrono.dayOfMonth();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * <p>\n+     * This method is required to support the <code>ReadablePartial</code>\n+     * interface. The supported fields are Year, MonthOfYear and DayOfMonth.\n+     * Note that all fields from day and above may in fact be queried via\n+     * other methods.\n+     *\n+     * @param index  the index, zero to two\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        switch (index) {\n+            case YEAR:\n+                return getChronology().year().get(getLocalMillis());\n+            case MONTH_OF_YEAR:\n+                return getChronology().monthOfYear().get(getLocalMillis());\n+            case DAY_OF_MONTH:\n+                return getChronology().dayOfMonth().get(getLocalMillis());\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This method gets the value of the specified field.\n+     * For example:\n+     * <pre>\n+     * LocalDate dt = LocalDate.nowDefaultZone();\n+     * int year = dt.get(DateTimeFieldType.year());\n+     * </pre>\n+     *\n+     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null or unsupported\n+     */\n+    public int get(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return fieldType.getField(getChronology()).get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Checks if the field type specified is supported by this\n+     * local date and chronology.\n+     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        DurationFieldType durType = type.getDurationType();\n+        if (DATE_DURATION_TYPES.contains(durType) ||\n+                durType.getField(getChronology()).getUnitMillis() >=\n+                    getChronology().days().getUnitMillis()) {\n+            return type.getField(getChronology()).isSupported();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the duration type specified is supported by this\n+     * local date and chronology.\n+     *\n+     * @param type  a duration type, usually obtained from DurationFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        DurationField field = type.getField(getChronology());\n+        if (DATE_DURATION_TYPES.contains(type) ||\n+            field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\n+            return field.isSupported();\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the local milliseconds from the Java epoch\n+     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00\n+     * @since 1.5 (previously private)\n+     */\n+    protected long getLocalMillis() {\n+        return iLocalMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the date.\n+     * \n+     * @return the Chronology that the date is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * field types and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return true;\n+        }\n+        if (partial instanceof LocalDate) {\n+            LocalDate other = (LocalDate) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return iLocalMillis == other.iLocalMillis;\n+            }\n+        }\n+        return super.equals(partial);\n+    }\n+\n+    /**\n+     * Gets a hash code for the instant as defined in <code>ReadablePartial</code>.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        // override for performance\n+        int hash = iHash;\n+        if (hash == 0) {\n+            hash = iHash = super.hashCode();\n+        }\n+        return hash;\n+    }\n+\n+    /**\n+     * Compares this partial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * The specified object must be a partial instance whose field types\n+     * match those of this partial.\n+     * <p>\n+     * NOTE: This implementation violates the Comparable contract.\n+     * This method will accept any instance of ReadablePartial as input.\n+     * However, it is possible that some implementations of ReadablePartial\n+     * exist that do not extend AbstractPartial, and thus will throw a\n+     * ClassCastException if compared in the opposite direction.\n+     * The cause of this problem is that ReadablePartial doesn't define\n+     * the compareTo() method, however we can't change that until v2.0.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(ReadablePartial partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return 0;\n+        }\n+        if (partial instanceof LocalDate) {\n+            LocalDate other = (LocalDate) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return (iLocalMillis < other.iLocalMillis ? -1 :\n+                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n+\n+            }\n+        }\n+        return super.compareTo(partial);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this LocalDate to a full datetime at the earliest valid time\n+     * for the date using the default time zone.\n+     * <p>\n+     * The time will normally be midnight, as that is the earliest time on\n+     * any given day. However, in some time zones when Daylight Savings Time\n+     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n+     * This method handles that situation by returning 01:00 on that date.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     * \n+     * @return this date as a datetime at the start of the day\n+     * @since 1.5\n+     */\n+    public DateTime toDateTimeAtStartOfDay() {\n+        return toDateTimeAtStartOfDay(null);\n+    }\n+\n+    /**\n+     * Converts this LocalDate to a full datetime at the earliest valid time\n+     * for the date using the specified time zone.\n+     * <p>\n+     * The time will normally be midnight, as that is the earliest time on\n+     * any given day. However, in some time zones when Daylight Savings Time\n+     * starts, there is no midnight because time jumps from 11:59 to 01:00.\n+     * This method handles that situation by returning 01:00 on that date.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param zone  the zone to use, null means default zone\n+     * @return this date as a datetime at the start of the day\n+     * @since 1.5\n+     */\n+    public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = getChronology().withZone(zone);\n+        long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;\n+        long instant = zone.convertLocalToUTC(localMillis, false);\n+        instant = chrono.dayOfMonth().roundFloor(instant);\n+        return new DateTime(instant, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this LocalDate to a full datetime using the default time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     * <p>\n+     * This method will throw an exception if the datetime that would be\n+     * created does not exist when the time zone is taken into account.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime() {\n+        return toDateTimeAtCurrentTime(null);\n+    }\n+\n+    /**\n+     * Converts this LocalDate to a full datetime using the specified time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     * <p>\n+     * This method will throw an exception if the datetime that would be\n+     * created does not exist when the time zone is taken into account.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param zone  the zone to use, null means default zone\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instantMillis = DateTimeUtils.currentTimeMillis();\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this LocalDate to a DateMidnight in the default time zone.\n+     * <p>\n+     * As from v1.5, you are recommended to avoid DateMidnight and use\n+     * {@link #toDateTimeAtStartOfDay()} instead because of the exception\n+     * detailed below.\n+     * <p>\n+     * This method will throw an exception if the default time zone switches\n+     * to Daylight Savings Time at midnight and this LocalDate represents\n+     * that switchover date. The problem is that there is no such time as\n+     * midnight on the required date, and as such an exception is thrown.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @return the DateMidnight instance in the default zone\n+     */\n+    public DateMidnight toDateMidnight() {\n+        return toDateMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this LocalDate to a DateMidnight.\n+     * <p>\n+     * As from v1.5, you are recommended to avoid DateMidnight and use\n+     * {@link #toDateTimeAtStartOfDay()} instead because of the exception\n+     * detailed below.\n+     * <p>\n+     * This method will throw an exception if the time zone switches\n+     * to Daylight Savings Time at midnight and this LocalDate represents\n+     * that switchover date. The problem is that there is no such time as\n+     * midnight on the required date, and as such an exception is thrown.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param zone  the zone to get the DateMidnight in, null means default zone\n+     * @return the DateMidnight instance\n+     */\n+    public DateMidnight toDateMidnight(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = getChronology().withZone(zone);\n+        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalDateTime using a LocalTime to fill in\n+     * the missing fields.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * LocalDate. The chronology of the time must also match.\n+     * If the time is null an exception is thrown.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param time  the time of day to use, must not be null\n+     * @return the LocalDateTime instance\n+     * @throws IllegalArgumentException if the time is null\n+     * @throws IllegalArgumentException if the chronology of the time does not match\n+     * @since 1.5\n+     */\n+    public LocalDateTime toLocalDateTime(LocalTime time) {\n+        if (time == null) {\n+            throw new IllegalArgumentException(\"The time must not be null\");\n+        }\n+        if (getChronology() != time.getChronology()) {\n+            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n+        }\n+        long localMillis = getLocalMillis() + time.getLocalMillis();\n+        return new LocalDateTime(localMillis, getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateTime using a LocalTime to fill in the\n+     * missing fields and using the default time zone.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * LocalDate. The chronology of the time must match.\n+     * If the time is null, the current time in the date's chronology is used.\n+     * <p>\n+     * This method will throw an exception if the datetime that would be\n+     * created does not exist when the time zone is taken into account.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @return the DateTime instance\n+     * @throws IllegalArgumentException if the chronology of the time does not match\n+     */\n+    public DateTime toDateTime(LocalTime time) {\n+        return toDateTime(time, null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateTime using a LocalTime to fill in the\n+     * missing fields.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * LocalDate plus the time zone. The chronology of the time must match.\n+     * If the time is null, the current time in the date's chronology is used.\n+     * <p>\n+     * This method will throw an exception if the datetime that would be\n+     * created does not exist when the time zone is taken into account.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @param zone  the zone to get the DateTime in, null means default\n+     * @return the DateTime instance\n+     * @throws IllegalArgumentException if the chronology of the time does not match\n+     */\n+    public DateTime toDateTime(LocalTime time, DateTimeZone zone) {\n+        if (time != null && getChronology() != time.getChronology()) {\n+            throw new IllegalArgumentException(\"The chronology of the time does not match\");\n+        }\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instant = DateTimeUtils.currentTimeMillis();\n+        instant = chrono.set(this, instant);\n+        if (time != null) {\n+            instant = chrono.set(time, instant);\n+        }\n+        return new DateTime(instant, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to an Interval representing the whole day\n+     * in the default time zone.\n+     * <p>\n+     * The interval may have more or less than 24 hours if this is a daylight\n+     * savings cutover date.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @return a interval over the day\n+     */\n+    public Interval toInterval() {\n+        return toInterval(null);\n+    }\n+\n+    /**\n+     * Converts this object to an Interval representing the whole day.\n+     * <p>\n+     * The interval may have more or less than 24 hours if this is a daylight\n+     * savings cutover date.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param zone  the zone to get the Interval in, null means default\n+     * @return a interval over the day\n+     */\n+    public Interval toInterval(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        DateTime start = toDateTimeAtStartOfDay(zone);\n+        DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);\n+        return new Interval(start, end);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the date time as a <code>java.util.Date</code>.\n+     * <p>\n+     * The <code>Date</code> object created has exactly the same year, month and day\n+     * as this date. The time will be set to the earliest valid time for that date.\n+     * <p>\n+     * Converting to a JDK Date is full of complications as the JDK Date constructor\n+     * doesn't behave as you might expect around DST transitions. This method works\n+     * by taking a first guess and then adjusting the JDK date until it has the\n+     * earliest valid instant. This also handles the situation where the JDK time\n+     * zone data differs from the Joda-Time time zone data.\n+     *\n+     * @return a Date initialised with this date, never null\n+     * @since 2.0\n+     */\n+    public Date toDate() {\n+        int dom = getDayOfMonth();\n+        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);\n+        LocalDate check = LocalDate.fromDateFields(date);\n+        if (check.isBefore(this)) {\n+            // DST gap (no midnight)\n+            // move forward in units of one hour until date correct\n+            while (check.equals(this) == false) {\n+                date.setTime(date.getTime() + 3600000);\n+                check = LocalDate.fromDateFields(date);\n+            }\n+            // move back in units of one second until date wrong\n+            while (date.getDate() == dom) {\n+                date.setTime(date.getTime() - 1000);\n+            }\n+            // fix result\n+            date.setTime(date.getTime() + 1000);\n+        } else if (check.equals(this)) {\n+            // check for DST overlap (two midnights)\n+            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n+            if (earlier.getDate() == dom) {\n+                date = earlier;\n+            }\n+        }\n+        return date;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with different local millis.\n+     * <p>\n+     * The returned object will be a new instance of the same type.\n+     * Only the millis will change, the chronology is kept.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n+     * @return a copy of this date with different millis\n+     */\n+    LocalDate withLocalMillis(long newMillis) {\n+        newMillis = iChronology.dayOfMonth().roundFloor(newMillis);\n+        return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the partial set of fields replacing\n+     * those from this instance.\n+     * <p>\n+     * For example, if the partial contains a year and a month then those two\n+     * fields will be changed in the returned instance.\n+     * Unsupported fields are ignored.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this date, null ignored\n+     * @return a copy of this date with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public LocalDate withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>monthOfYear</code> then the\n+     * month of year field will be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These two lines are equivalent:\n+     * <pre>\n+     * LocalDate updated = dt.withDayOfMonth(6);\n+     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this date with the field set\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public LocalDate withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * LocalDate added = dt.plusYears(6);\n+     * LocalDate added = dt.plus(Period.years(6));\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this date with the field updated\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        if (amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * <p>\n+     * Unsupported time fields are ignored, thus adding a period of 24 hours\n+     * will not have any effect.\n+     *\n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this date with the period added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDate withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getLocalMillis();\n+        Chronology chrono = getChronology();\n+        for (int i = 0; i < period.size(); i++) {\n+            long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n+            DurationFieldType type = period.getFieldType(i);\n+            if (isSupported(type)) {\n+                instant = type.getField(chrono).add(instant, value);\n+            }\n+        }\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * <p>\n+     * Unsupported time fields are ignored, thus adding a period of 24 hours\n+     * will not have any effect.\n+     *\n+     * @param period  the period to add to this one, null means zero\n+     * @return a copy of this date with the period added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDate plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date plus the specified number of years.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate added = dt.plusYears(6);\n+     * LocalDate added = dt.plus(Period.years(6));\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new LocalDate plus the increased years\n+     */\n+    public LocalDate plusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().add(getLocalMillis(), years);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date plus the specified number of months.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate added = dt.plusMonths(6);\n+     * LocalDate added = dt.plus(Period.months(6));\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new LocalDate plus the increased months\n+     */\n+    public LocalDate plusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().add(getLocalMillis(), months);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date plus the specified number of weeks.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate added = dt.plusWeeks(6);\n+     * LocalDate added = dt.plus(Period.weeks(6));\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new LocalDate plus the increased weeks\n+     */\n+    public LocalDate plusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date plus the specified number of days.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate added = dt.plusDays(6);\n+     * LocalDate added = dt.plus(Period.days(6));\n+     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new LocalDate plus the increased days\n+     */\n+    public LocalDate plusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().add(getLocalMillis(), days);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * <p>\n+     * Unsupported time fields are ignored, thus subtracting a period of 24 hours\n+     * will not have any effect.\n+     *\n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this LocalDate with the period taken away\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDate minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date minus the specified number of years.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate subtracted = dt.minusYears(6);\n+     * LocalDate subtracted = dt.minus(Period.years(6));\n+     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new LocalDate minus the increased years\n+     */\n+    public LocalDate minusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().subtract(getLocalMillis(), years);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date minus the specified number of months.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate subtracted = dt.minusMonths(6);\n+     * LocalDate subtracted = dt.minus(Period.months(6));\n+     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new LocalDate minus the increased months\n+     */\n+    public LocalDate minusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().subtract(getLocalMillis(), months);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date minus the specified number of weeks.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate subtracted = dt.minusWeeks(6);\n+     * LocalDate subtracted = dt.minus(Period.weeks(6));\n+     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to subtract, may be negative\n+     * @return the new LocalDate minus the increased weeks\n+     */\n+    public LocalDate minusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this date minus the specified number of days.\n+     * <p>\n+     * This LocalDate instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDate subtracted = dt.minusDays(6);\n+     * LocalDate subtracted = dt.minus(Period.days(6));\n+     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new LocalDate minus the increased days\n+     */\n+    public LocalDate minusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().subtract(getLocalMillis(), days);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many\n+     * useful methods.\n+     *\n+     * @param fieldType  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return new Property(this, fieldType.getField(getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     *\n+     * @return the era\n+     */\n+    public int getEra() {\n+        return getChronology().era().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     *\n+     * @return the year of era\n+     */\n+    public int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     *\n+     * @return the year of era\n+     */\n+    public int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     *\n+     * @return the year of century\n+     */\n+    public int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     *\n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getChronology().year().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * <p>\n+     * The weekyear is the year that matches with the weekOfWeekyear field.\n+     * In the standard ISO8601 week algorithm, the first week of the year\n+     * is that in which at least 4 days are in the year. As a result of this\n+     * definition, day 1 of the first week may be in the previous year.\n+     * The weekyear allows you to query the effective year for that day.\n+     *\n+     * @return the weekyear\n+     */\n+    public int getWeekyear() {\n+        return getChronology().weekyear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     *\n+     * @return the week of a week based year\n+     */\n+    public int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     *\n+     * @return the day of year\n+     */\n+    public int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n+     *\n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n+     *\n+     * @return the day of week\n+     */\n+    public int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getLocalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the era field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * era changed.\n+     *\n+     * @param era  the era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withEra(int era) {\n+        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the century of era field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * century of era changed.\n+     *\n+     * @param centuryOfEra  the centurey of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withCenturyOfEra(int centuryOfEra) {\n+        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the year of era field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of era changed.\n+     *\n+     * @param yearOfEra  the year of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withYearOfEra(int yearOfEra) {\n+        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the year of century field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of century changed.\n+     *\n+     * @param yearOfCentury  the year of century to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withYearOfCentury(int yearOfCentury) {\n+        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the year field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year changed.\n+     *\n+     * @param year  the year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withYear(int year) {\n+        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the weekyear field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * weekyear changed.\n+     *\n+     * @param weekyear  the weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withWeekyear(int weekyear) {\n+        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the month of year field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withMonthOfYear(int monthOfYear) {\n+        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the week of weekyear field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * week of weekyear changed.\n+     *\n+     * @param weekOfWeekyear  the week of weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\n+        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the day of year field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of year changed.\n+     *\n+     * @param dayOfYear  the day of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withDayOfYear(int dayOfYear) {\n+        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the day of month field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of month changed.\n+     *\n+     * @param dayOfMonth  the day of month to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withDayOfMonth(int dayOfMonth) {\n+        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the day of week field updated.\n+     * <p>\n+     * LocalDate is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of week changed.\n+     *\n+     * @param dayOfWeek  the day of week to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDate withDayOfWeek(int dayOfWeek) {\n+        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property which provides access to advanced functionality.\n+     *\n+     * @return the era property\n+     */\n+    public Property era() {\n+        return new Property(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property which provides access to advanced functionality.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property which provides access to advanced functionality.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property which provides access to advanced functionality.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property which provides access to advanced functionality.\n+     *\n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the weekyear property which provides access to advanced functionality.\n+     *\n+     * @return the weekyear property\n+     */\n+    public Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property which provides access to advanced functionality.\n+     *\n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property which provides access to advanced functionality.\n+     *\n+     * @return the week of a week based year property\n+     */\n+    public Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property which provides access to advanced functionality.\n+     *\n+     * @return the day of year property\n+     */\n+    public Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property which provides access to advanced functionality.\n+     *\n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of week property which provides access to advanced functionality.\n+     *\n+     * @return the day of week property\n+     */\n+    public Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-dd).\n+     *\n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.date().print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * LocalDate.Property binds a LocalDate to a DateTimeField allowing\n+     * powerful datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * LocalDate dt = new LocalDate(1972, 12, 3, 0, 0);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.month().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return\n+     * new instances of LocalDate - they do not modify the original. The example\n+     * below yields two independent immutable date objects 20 years apart.\n+     * <pre>\n+     * LocalDate dt = new LocalDate(1972, 12, 3);\n+     * LocalDate dt1920 = dt.year().setCopy(1920);\n+     * </pre>\n+     * <p>\n+     * LocalDate.Property itself is thread-safe and immutable, as well as the\n+     * LocalDate being operated on.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.3\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -3193829732634L;\n+        \n+        /** The instant this property is working against */\n+        private transient LocalDate iInstant;\n+        /** The field this property is working against */\n+        private transient DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(LocalDate instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+\n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (LocalDate) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the milliseconds of the date that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getLocalMillis();\n+        }\n+        \n+        /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n+         * Gets the LocalDate object linked to this property.\n+         * \n+         * @return the linked LocalDate\n+         */\n+        public LocalDate getLocalDate() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this LocalDate.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDate addToCopy(int value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this LocalDate.\n+         * A field wrapped operation only changes this field.\n+         * Thus 31st January addWrapField one day goes to the 1st January.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDate addWrapFieldToCopy(int value) {\n+            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the LocalDate.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDate setCopy(int value) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalDate to a parsed text value.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalDate setCopy(String text, Locale locale) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalDate to a parsed text value.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @return a copy of the LocalDate with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalDate setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new LocalDate with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * This operation is useful for obtaining a LocalDate on the last day\n+         * of the month, as month lengths vary.\n+         * <pre>\n+         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n+         * </pre>\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalDate with this field set to its maximum\n+         */\n+        public LocalDate withMaximumValue() {\n+            return setCopy(getMaximumValue());\n+        }\n+        \n+        /**\n+         * Returns a new LocalDate with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The LocalDate attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalDate with this field set to its minimum\n+         */\n+        public LocalDate withMinimumValue() {\n+            return setCopy(getMinimumValue());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this\n+         * LocalDate.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalDate\n+         * where the time is 10:30 would result in new LocalDate with the\n+         * time of 10:00.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate roundFloorCopy() {\n+            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this\n+         * LocalDate.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalDate\n+         * where the time is 10:30 would result in new LocalDate with the\n+         * time of 11:00.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate roundCeilingCopy() {\n+            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDate, favoring the floor if halfway.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate roundHalfFloorCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDate, favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate roundHalfCeilingCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDate.  If halfway, the ceiling is favored over the floor\n+         * only if it makes this field's value even.\n+         *\n+         * @return a copy of the LocalDate with the field value changed\n+         */\n+        public LocalDate roundHalfEvenCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/LocalDateTime.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import org.joda.time.base.BaseLocal;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.PartialConverter;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * LocalDateTime is an unmodifiable datetime class representing a\n+ * datetime without a time zone.\n+ * <p>\n+ * LocalDateTime implements the {@link ReadablePartial} interface.\n+ * To do this, certain methods focus on key fields Year, MonthOfYear,\n+ * DayOfYear and MillisOfDay.\n+ * However, <b>all</b> fields may in fact be queried.\n+ * <p>\n+ * Internally, LocalDateTime uses a single millisecond-based value to\n+ * represent the local datetime. This value is only used internally and\n+ * is not exposed to applications.\n+ * <p>\n+ * Calculations on LocalDateTime are performed using a {@link Chronology}.\n+ * This chronology will be set internally to be in the UTC time zone\n+ * for all calculations.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ *\n+ * <p>\n+ * LocalDateTime is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.3\n+ */\n+public final class LocalDateTime\n+        extends BaseLocal\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -268716875315837168L;\n+\n+    /** The index of the year field in the field array */\n+    private static final int YEAR = 0;\n+    /** The index of the monthOfYear field in the field array */\n+    private static final int MONTH_OF_YEAR = 1;\n+    /** The index of the dayOfMonth field in the field array */\n+    private static final int DAY_OF_MONTH = 2;\n+    /** The index of the millis field in the field array */\n+    private static final int MILLIS_OF_DAY = 3;\n+\n+    /** The local millis from 1970-01-01T00:00:00 */\n+    private long iLocalMillis;\n+    /** The chronology to use in UTC */\n+    private Chronology iChronology;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n+     * using exactly the same field values.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n+     * This is useful if you have been using the Calendar as a local date,\n+     * ignoring the zone.\n+     * <p>\n+     * One advantage of this method is that this method is unaffected if the\n+     * version of the time zone data differs between the JDK and Joda-Time.\n+     * That is because the local field values are transferred, calculated using\n+     * the JDK time zone data and without using the Joda-Time time zone data.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a LocalDateTime with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created LocalDateTime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new LocalDateTime(\n+            calendar.get(Calendar.YEAR),\n+            calendar.get(Calendar.MONTH) + 1,\n+            calendar.get(Calendar.DAY_OF_MONTH),\n+            calendar.get(Calendar.HOUR_OF_DAY),\n+            calendar.get(Calendar.MINUTE),\n+            calendar.get(Calendar.SECOND),\n+            calendar.get(Calendar.MILLISECOND)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n+     * using exactly the same field values.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the LocalDateTime.\n+     * This is useful if you have been using the Date as a local date,\n+     * ignoring the zone.\n+     * <p>\n+     * One advantage of this method is that this method is unaffected if the\n+     * version of the time zone data differs between the JDK and Joda-Time.\n+     * That is because the local field values are transferred, calculated using\n+     * the JDK time zone data and without using the Joda-Time time zone data.\n+     * <p>\n+     * This factory method always creates a LocalDateTime with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created LocalDateTime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalDateTime fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new LocalDateTime(\n+            date.getYear() + 1900,\n+            date.getMonth() + 1,\n+            date.getDate(),\n+            date.getHours(),\n+            date.getMinutes(),\n+            date.getSeconds(),\n+            (int) (date.getTime() % 1000)\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     */\n+    public LocalDateTime() {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public LocalDateTime(DateTimeZone zone) {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalDateTime(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public LocalDateTime(long instant) {\n+        this(instant, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public LocalDateTime(long instant, DateTimeZone zone) {\n+        this(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalDateTime(long instant, Chronology chronology) {\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        \n+        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n+        iLocalMillis = localMillis;\n+        iChronology = chronology.withUTC();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the object contains no time zone, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalDateTime(Object instant) {\n+        this(instant, (Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @param zone  the time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalDateTime(Object instant, DateTimeZone zone) {\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        Chronology chronology = converter.getChronology(instant, zone);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalDateTime(Object instant, Chronology chronology) {\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     */\n+    public LocalDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     */\n+    public LocalDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public LocalDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified date and time\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        iChronology = chronology;\n+        iLocalMillis = instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is four.\n+     * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n+     *\n+     * @return the field count, four\n+     */\n+    public int size() {\n+        return 4;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     *\n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case MONTH_OF_YEAR:\n+                return chrono.monthOfYear();\n+            case DAY_OF_MONTH:\n+                return chrono.dayOfMonth();\n+            case MILLIS_OF_DAY:\n+                return chrono.millisOfDay();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * <p>\n+     * This method is required to support the <code>ReadablePartial</code>\n+     * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n+     *\n+     * @param index  the index, zero to two\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        switch (index) {\n+            case YEAR:\n+                return getChronology().year().get(getLocalMillis());\n+            case MONTH_OF_YEAR:\n+                return getChronology().monthOfYear().get(getLocalMillis());\n+            case DAY_OF_MONTH:\n+                return getChronology().dayOfMonth().get(getLocalMillis());\n+            case MILLIS_OF_DAY:\n+                return getChronology().millisOfDay().get(getLocalMillis());\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This method gets the value of the specified field.\n+     * For example:\n+     * <pre>\n+     * DateTime dt = new DateTime();\n+     * int year = dt.get(DateTimeFieldType.year());\n+     * </pre>\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null\n+     */\n+    public int get(DateTimeFieldType type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        return type.getField(getChronology()).get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Checks if the field type specified is supported by this\n+     * local datetime and chronology.\n+     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        return type.getField(getChronology()).isSupported();\n+    }\n+\n+    /**\n+     * Checks if the duration type specified is supported by this\n+     * local datetime and chronology.\n+     *\n+     * @param type  a duration type, usually obtained from DurationFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        return type.getField(getChronology()).isSupported();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n+     *\n+     * @return the number of milliseconds since 1970-01-01T00:00:00\n+     * @since 1.5 (previously private)\n+     */\n+    protected long getLocalMillis() {\n+        return iLocalMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the datetime.\n+     *\n+     * @return the Chronology that the datetime is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * field types and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return true;\n+        }\n+        if (partial instanceof LocalDateTime) {\n+            LocalDateTime other = (LocalDateTime) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return iLocalMillis == other.iLocalMillis;\n+            }\n+        }\n+        return super.equals(partial);\n+    }\n+\n+    /**\n+     * Compares this partial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * The specified object must be a partial instance whose field types\n+     * match those of this partial.\n+     * <p>\n+     * NOTE: This implementation violates the Comparable contract.\n+     * This method will accept any instance of ReadablePartial as input.\n+     * However, it is possible that some implementations of ReadablePartial\n+     * exist that do not extend AbstractPartial, and thus will throw a\n+     * ClassCastException if compared in the opposite direction.\n+     * The cause of this problem is that ReadablePartial doesn't define\n+     * the compareTo() method, however we can't change that until v2.0.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(ReadablePartial partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return 0;\n+        }\n+        if (partial instanceof LocalDateTime) {\n+            LocalDateTime other = (LocalDateTime) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return (iLocalMillis < other.iLocalMillis ? -1 :\n+                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n+\n+            }\n+        }\n+        return super.compareTo(partial);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateTime using the default zone.\n+     * <p>\n+     * This method will throw an exception if the datetime that would be\n+     * created does not exist when the time zone is taken into account.\n+     * \n+     * @return <code>this</code>\n+     */\n+    public DateTime toDateTime() {\n+        return toDateTime((DateTimeZone) null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateTime using the specified zone.\n+     * <p>\n+     * This method will throw an exception if the datetime that would be\n+     * created does not exist when the time zone is taken into account.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        Chronology chrono = iChronology.withZone(zone);\n+        return new DateTime(\n+                getYear(), getMonthOfYear(), getDayOfMonth(),\n+                getHourOfDay(), getMinuteOfHour(),\n+                getSecondOfMinute(), getMillisOfSecond(), chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalDate with the same date and chronology.\n+     *\n+     * @return a LocalDate with the same date and chronology\n+     */\n+    public LocalDate toLocalDate() {\n+        return new LocalDate(getLocalMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts this object to a LocalTime with the same time and chronology.\n+     *\n+     * @return a LocalTime with the same time and chronology\n+     */\n+    public LocalTime toLocalTime() {\n+        return new LocalTime(getLocalMillis(), getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the date time as a <code>java.util.Date</code>.\n+     * <p>\n+     * The <code>Date</code> object created has exactly the same fields as this\n+     * date-time, except when the time would be invalid due to a daylight savings\n+     * gap. In that case, the time will be set to the earliest valid time after the gap.\n+     * <p>\n+     * In the case of a daylight savings overlap, the earlier instant is selected.\n+     * <p>\n+     * Converting to a JDK Date is full of complications as the JDK Date constructor\n+     * doesn't behave as you might expect around DST transitions. This method works\n+     * by taking a first guess and then adjusting. This also handles the situation\n+     * where the JDK time zone data differs from the Joda-Time time zone data.\n+     *\n+     * @return a Date initialised with this date-time, never null\n+     * @since 2.0\n+     */\n+    public Date toDate() {\n+        int dom = getDayOfMonth();\n+        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n+                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n+        date.setTime(date.getTime() + getMillisOfSecond());\n+        LocalDateTime check = LocalDateTime.fromDateFields(date);\n+        if (check.isBefore(this)) {\n+            // DST gap\n+            // move forward in units of one minute until equal/after\n+            while (check.isBefore(this)) {\n+                date.setTime(date.getTime() + 60000);\n+                check = LocalDateTime.fromDateFields(date);\n+            }\n+            // move back in units of one second until date wrong\n+            while (check.isBefore(this) == false) {\n+                date.setTime(date.getTime() - 1000);\n+                check = LocalDateTime.fromDateFields(date);\n+            }\n+            date.setTime(date.getTime() + 1000);\n+        } else if (check.equals(this)) {\n+            // check for DST overlap\n+            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n+            check = LocalDateTime.fromDateFields(earlier);\n+            if (check.equals(this)) {\n+                date = earlier;\n+            }\n+        }\n+        return date;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with different local millis.\n+     * <p>\n+     * The returned object will be a new instance of the same type.\n+     * Only the millis will change, the chronology is kept.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n+     * @return a copy of this datetime with different millis\n+     */\n+    LocalDateTime withLocalMillis(long newMillis) {\n+        return (newMillis == getLocalMillis() ? this : new LocalDateTime(newMillis, getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the specified date,\n+     * retaining the time fields.\n+     * <p>\n+     * If the date is already the date passed in, then <code>this</code> is returned.\n+     * <p>\n+     * To set a single field use the properties, for example:\n+     * <pre>\n+     * DateTime set = dt.monthOfYear().setCopy(6);\n+     * </pre>\n+     *\n+     * @param year  the new year value\n+     * @param monthOfYear  the new monthOfYear value\n+     * @param dayOfMonth  the new dayOfMonth value\n+     * @return a copy of this datetime with a different date\n+     * @throws IllegalArgumentException if any value if invalid\n+     */\n+    public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) {\n+        Chronology chrono = getChronology();\n+        long instant = getLocalMillis();\n+        instant = chrono.year().set(instant, year);\n+        instant = chrono.monthOfYear().set(instant, monthOfYear);\n+        instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified time,\n+     * retaining the date fields.\n+     * <p>\n+     * If the time is already the time passed in, then <code>this</code> is returned.\n+     * <p>\n+     * To set a single field use the properties, for example:\n+     * <pre>\n+     * LocalDateTime set = dt.hourOfDay().setCopy(6);\n+     * </pre>\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @return a copy of this datetime with a different time\n+     * @throws IllegalArgumentException if any value if invalid\n+     */\n+    public LocalDateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+        Chronology chrono = getChronology();\n+        long instant = getLocalMillis();\n+        instant = chrono.hourOfDay().set(instant, hourOfDay);\n+        instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n+        instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n+        instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the partial set of fields\n+     * replacing those from this instance.\n+     * <p>\n+     * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n+     * would be changed in the returned instance.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this datetime, null ignored\n+     * @return a copy of this datetime with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public LocalDateTime withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n+     * field would be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);\n+     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this datetime with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public LocalDateTime withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the value of the specified\n+     * field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * LocalDateTime added = dt.plusYears(6);\n+     * LocalDateTime added = dt.plus(Period.years(6));\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this datetime with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     *\n+     * @param durationToAdd  the duration to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+        if (durationToAdd == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     *\n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDateTime withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(period, getLocalMillis(), scalar);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the specified duration added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     *\n+     * @param duration  the duration to add to this one, null means zero\n+     * @return a copy of this datetime with the duration added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDateTime plus(ReadableDuration duration) {\n+        return withDurationAdded(duration, 1);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     *\n+     * @param period  the period to add to this one, null means zero\n+     * @return a copy of this datetime with the period added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDateTime plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime plus the specified number of years.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusYears(6);\n+     * LocalDateTime added = dt.plus(Period.years(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new LocalDateTime plus the increased years\n+     */\n+    public LocalDateTime plusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().add(getLocalMillis(), years);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of months.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusMonths(6);\n+     * LocalDateTime added = dt.plus(Period.months(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new LocalDateTime plus the increased months\n+     */\n+    public LocalDateTime plusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().add(getLocalMillis(), months);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of weeks.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusWeeks(6);\n+     * LocalDateTime added = dt.plus(Period.weeks(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new LocalDateTime plus the increased weeks\n+     */\n+    public LocalDateTime plusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of days.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusDays(6);\n+     * LocalDateTime added = dt.plus(Period.days(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new LocalDateTime plus the increased days\n+     */\n+    public LocalDateTime plusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().add(getLocalMillis(), days);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime plus the specified number of hours.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusHours(6);\n+     * LocalDateTime added = dt.plus(Period.hours(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new LocalDateTime plus the increased hours\n+     */\n+    public LocalDateTime plusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().add(getLocalMillis(), hours);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of minutes.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusMinutes(6);\n+     * LocalDateTime added = dt.plus(Period.minutes(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new LocalDateTime plus the increased minutes\n+     */\n+    public LocalDateTime plusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of seconds.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusSeconds(6);\n+     * LocalDateTime added = dt.plus(Period.seconds(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new LocalDateTime plus the increased seconds\n+     */\n+    public LocalDateTime plusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime plus the specified number of millis.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime added = dt.plusMillis(6);\n+     * LocalDateTime added = dt.plus(Period.millis(6));\n+     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new LocalDateTime plus the increased millis\n+     */\n+    public LocalDateTime plusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().add(getLocalMillis(), millis);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the specified duration taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     *\n+     * @param duration  the duration to reduce this instant by\n+     * @return a copy of this datetime with the duration taken away\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDateTime minus(ReadableDuration duration) {\n+        return withDurationAdded(duration, -1);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     *\n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this datetime with the period taken away\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalDateTime minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime minus the specified number of years.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusYears(6);\n+     * LocalDateTime subtracted = dt.minus(Period.years(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new LocalDateTime minus the increased years\n+     */\n+    public LocalDateTime minusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().years().subtract(getLocalMillis(), years);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of months.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusMonths(6);\n+     * LocalDateTime subtracted = dt.minus(Period.months(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new LocalDateTime minus the increased months\n+     */\n+    public LocalDateTime minusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().months().subtract(getLocalMillis(), months);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of weeks.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusWeeks(6);\n+     * LocalDateTime subtracted = dt.minus(Period.weeks(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n+     * </pre>\n+     *\n+     * @param weeks  the amount of weeks to subtract, may be negative\n+     * @return the new LocalDateTime minus the increased weeks\n+     */\n+    public LocalDateTime minusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of days.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusDays(6);\n+     * LocalDateTime subtracted = dt.minus(Period.days(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new LocalDateTime minus the increased days\n+     */\n+    public LocalDateTime minusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().days().subtract(getLocalMillis(), days);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime minus the specified number of hours.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusHours(6);\n+     * LocalDateTime subtracted = dt.minus(Period.hours(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to subtract, may be negative\n+     * @return the new LocalDateTime minus the increased hours\n+     */\n+    public LocalDateTime minusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of minutes.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusMinutes(6);\n+     * LocalDateTime subtracted = dt.minus(Period.minutes(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to subtract, may be negative\n+     * @return the new LocalDateTime minus the increased minutes\n+     */\n+    public LocalDateTime minusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of seconds.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusSeconds(6);\n+     * LocalDateTime subtracted = dt.minus(Period.seconds(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to subtract, may be negative\n+     * @return the new LocalDateTime minus the increased seconds\n+     */\n+    public LocalDateTime minusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime minus the specified number of millis.\n+     * <p>\n+     * This LocalDateTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalDateTime subtracted = dt.minusMillis(6);\n+     * LocalDateTime subtracted = dt.minus(Period.millis(6));\n+     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to subtract, may be negative\n+     * @return the new LocalDateTime minus the increased millis\n+     */\n+    public LocalDateTime minusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many\n+     * useful methods.\n+     *\n+     * @param fieldType  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return new Property(this, fieldType.getField(getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     *\n+     * @return the era\n+     */\n+    public int getEra() {\n+        return getChronology().era().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     *\n+     * @return the year of era\n+     */\n+    public int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     *\n+     * @return the year of era\n+     */\n+    public int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     *\n+     * @return the year of century\n+     */\n+    public int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     *\n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getChronology().year().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * <p>\n+     * The weekyear is the year that matches with the weekOfWeekyear field.\n+     * In the standard ISO8601 week algorithm, the first week of the year\n+     * is that in which at least 4 days are in the year. As a result of this\n+     * definition, day 1 of the first week may be in the previous year.\n+     * The weekyear allows you to query the effective year for that day.\n+     *\n+     * @return the weekyear\n+     */\n+    public int getWeekyear() {\n+        return getChronology().weekyear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     *\n+     * @return the week of a week based year\n+     */\n+    public int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     *\n+     * @return the day of year\n+     */\n+    public int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n+     *\n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n+     *\n+     * @return the day of week\n+     */\n+    public int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getLocalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    public int getMillisOfDay() {\n+        return getChronology().millisOfDay().get(getLocalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the era field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * era changed.\n+     *\n+     * @param era  the era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withEra(int era) {\n+        return withLocalMillis(getChronology().era().set(getLocalMillis(), era));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the century of era field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * century of era changed.\n+     *\n+     * @param centuryOfEra  the centurey of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withCenturyOfEra(int centuryOfEra) {\n+        return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the year of era field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of era changed.\n+     *\n+     * @param yearOfEra  the year of era to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withYearOfEra(int yearOfEra) {\n+        return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the year of century field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year of century changed.\n+     *\n+     * @param yearOfCentury  the year of century to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withYearOfCentury(int yearOfCentury) {\n+        return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the year field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year changed.\n+     *\n+     * @param year  the year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withYear(int year) {\n+        return withLocalMillis(getChronology().year().set(getLocalMillis(), year));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the weekyear field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * weekyear changed.\n+     *\n+     * @param weekyear  the weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withWeekyear(int weekyear) {\n+        return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the month of year field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withMonthOfYear(int monthOfYear) {\n+        return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the week of weekyear field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * week of weekyear changed.\n+     *\n+     * @param weekOfWeekyear  the week of weekyear to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) {\n+        return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the day of year field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of year changed.\n+     *\n+     * @param dayOfYear  the day of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withDayOfYear(int dayOfYear) {\n+        return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the day of month field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of month changed.\n+     *\n+     * @param dayOfMonth  the day of month to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n+        return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the day of week field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of week changed.\n+     *\n+     * @param dayOfWeek  the day of week to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withDayOfWeek(int dayOfWeek) {\n+        return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this datetime with the hour of day field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * hour of day changed.\n+     *\n+     * @param hour  the hour of day to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withHourOfDay(int hour) {\n+        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the minute of hour field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * minute of hour changed.\n+     *\n+     * @param minute  the minute of hour to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withMinuteOfHour(int minute) {\n+        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the second of minute field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * second of minute changed.\n+     *\n+     * @param second  the second of minute to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withSecondOfMinute(int second) {\n+        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the millis of second field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * millis of second changed.\n+     *\n+     * @param millis  the millis of second to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withMillisOfSecond(int millis) {\n+        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n+    }\n+\n+    /**\n+     * Returns a copy of this datetime with the millis of day field updated.\n+     * <p>\n+     * LocalDateTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * millis of day changed.\n+     *\n+     * @param millis  the millis of day to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalDateTime withMillisOfDay(int millis) {\n+        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era property which provides access to advanced functionality.\n+     *\n+     * @return the era property\n+     */\n+    public Property era() {\n+        return new Property(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property which provides access to advanced functionality.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property which provides access to advanced functionality.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property which provides access to advanced functionality.\n+     *\n+     * @return the year of era property\n+     */\n+    public Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property which provides access to advanced functionality.\n+     *\n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the weekyear property which provides access to advanced functionality.\n+     *\n+     * @return the weekyear property\n+     */\n+    public Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property which provides access to advanced functionality.\n+     *\n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property which provides access to advanced functionality.\n+     *\n+     * @return the week of a week based year property\n+     */\n+    public Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property which provides access to advanced functionality.\n+     *\n+     * @return the day of year property\n+     */\n+    public Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property which provides access to advanced functionality.\n+     *\n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of week property which provides access to advanced functionality.\n+     *\n+     * @return the day of week property\n+     */\n+    public Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property which provides access to advanced functionality.\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property which provides access to advanced functionality.\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of minute field property which provides access to advanced functionality.\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of second property which provides access to advanced functionality.\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, getChronology().millisOfSecond());\n+    }\n+\n+    /**\n+     * Get the millis of day property which provides access to advanced functionality.\n+     * \n+     * @return the millis of day property\n+     */\n+    public Property millisOfDay() {\n+        return new Property(this, getChronology().millisOfDay());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSS).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.dateTime().print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * LocalDateTime.Property binds a LocalDateTime to a DateTimeField allowing\n+     * powerful datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the year '1972' (as an int) and the month 'December' (as a String).\n+     * <pre>\n+     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n+     * int year = dt.year().get();\n+     * String monthStr = dt.month().getAsText();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow date modification. These return\n+     * new instances of LocalDateTime - they do not modify the original.\n+     * The example below yields two independent immutable date objects\n+     * 20 years apart.\n+     * <pre>\n+     * LocalDateTime dt = new LocalDateTime(1972, 12, 3, 0, 0);\n+     * LocalDateTime dt1920 = dt.year().setCopy(1920);\n+     * </pre>\n+     * <p>\n+     * LocalDateTime.Property itself is thread-safe and immutable, as well as the\n+     * LocalDateTime being operated on.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.3\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -358138762846288L;\n+        \n+        /** The instant this property is working against */\n+        private transient LocalDateTime iInstant;\n+        /** The field this property is working against */\n+        private transient DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(LocalDateTime instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+\n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (LocalDateTime) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the milliseconds of the datetime that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getLocalMillis();\n+        }\n+        \n+        /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n+         * Gets the LocalDateTime object linked to this property.\n+         * \n+         * @return the linked LocalDateTime\n+         */\n+        public LocalDateTime getLocalDateTime() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this LocalDateTime.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDateTime addToCopy(int value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field in a copy of this LocalDateTime.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDateTime addToCopy(long value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.\n+         * A field wrapped operation only changes this field.\n+         * Thus 31st January addWrapField one day goes to the 1st January.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDateTime addWrapFieldToCopy(int value) {\n+            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the LocalDateTime.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalDateTime setCopy(int value) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalDateTime setCopy(String text, Locale locale) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalDateTime to a parsed text value.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @return a copy of the LocalDateTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalDateTime setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new LocalDateTime with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * This operation is useful for obtaining a LocalDateTime on the last day\n+         * of the month, as month lengths vary.\n+         * <pre>\n+         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n+         * </pre>\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalDateTime with this field set to its maximum\n+         */\n+        public LocalDateTime withMaximumValue() {\n+            return setCopy(getMaximumValue());\n+        }\n+        \n+        /**\n+         * Returns a new LocalDateTime with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The LocalDateTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalDateTime with this field set to its minimum\n+         */\n+        public LocalDateTime withMinimumValue() {\n+            return setCopy(getMinimumValue());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this\n+         * LocalDateTime.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n+         * where the time is 10:30 would result in new LocalDateTime with the\n+         * time of 10:00.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime roundFloorCopy() {\n+            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this\n+         * LocalDateTime.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalDateTime\n+         * where the time is 10:30 would result in new LocalDateTime with the\n+         * time of 11:00.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime roundCeilingCopy() {\n+            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDateTime, favoring the floor if halfway.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime roundHalfFloorCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDateTime, favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime roundHalfCeilingCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalDateTime.  If halfway, the ceiling is favored over the floor\n+         * only if it makes this field's value even.\n+         *\n+         * @return a copy of the LocalDateTime with the field value changed\n+         */\n+        public LocalDateTime roundHalfEvenCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/LocalTime.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import org.joda.time.base.BaseLocal;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.PartialConverter;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * LocalTime is an immutable time class representing a time\n+ * without a time zone.\n+ * <p>\n+ * LocalTime implements the {@link ReadablePartial} interface.\n+ * To do this, the interface methods focus on the key fields -\n+ * HourOfDay, MinuteOfHour, SecondOfMinute and MillisOfSecond.\n+ * However, <b>all</b> time fields may in fact be queried.\n+ * <p>\n+ * Calculations on LocalTime are performed using a {@link Chronology}.\n+ * This chronology will be set internally to be in the UTC time zone\n+ * for all calculations.\n+ *\n+ * <p>Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value\n+ * <li>text value\n+ * <li>short text value\n+ * <li>maximum/minimum values\n+ * <li>add/subtract\n+ * <li>set\n+ * <li>rounding\n+ * </ul>\n+ *\n+ * <p>\n+ * LocalTime is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.3\n+ */\n+public final class LocalTime\n+        extends BaseLocal\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -12873158713873L;\n+\n+    /** Constant for midnight. */\n+    public static final LocalTime MIDNIGHT = new LocalTime(0, 0, 0, 0);\n+\n+    /** The index of the hourOfDay field in the field array */\n+    private static final int HOUR_OF_DAY = 0;\n+    /** The index of the minuteOfHour field in the field array */\n+    private static final int MINUTE_OF_HOUR = 1;\n+    /** The index of the secondOfMinute field in the field array */\n+    private static final int SECOND_OF_MINUTE = 2;\n+    /** The index of the millisOfSecond field in the field array */\n+    private static final int MILLIS_OF_SECOND = 3;\n+    /** Set of known duration types. */\n+    private static final Set<DurationFieldType> TIME_DURATION_TYPES = new HashSet<DurationFieldType>();\n+    static {\n+        TIME_DURATION_TYPES.add(DurationFieldType.millis());\n+        TIME_DURATION_TYPES.add(DurationFieldType.seconds());\n+        TIME_DURATION_TYPES.add(DurationFieldType.minutes());\n+        TIME_DURATION_TYPES.add(DurationFieldType.hours());\n+    }\n+\n+    /** The local millis from 1970-01-01T00:00:00 */\n+    private long iLocalMillis;\n+    /** The chronology to use, in UTC */\n+    private Chronology iChronology;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a LocalTime from the specified millis of day using the\n+     * ISO chronology.\n+     * <p>\n+     * The millisOfDay value may exceed the number of millis in one day,\n+     * but additional days will be ignored.\n+     * This method uses the UTC time zone internally.\n+     *\n+     * @param millisOfDay  the number of milliseconds into a day to convert\n+     */\n+    public static LocalTime fromMillisOfDay(long millisOfDay) {\n+        return fromMillisOfDay(millisOfDay, null);\n+    }\n+\n+    /**\n+     * Constructs a LocalTime from the specified millis of day using the\n+     * specified chronology.\n+     * <p>\n+     * The millisOfDay value may exceed the number of millis in one day,\n+     * but additional days will be ignored.\n+     * This method uses the UTC time zone internally.\n+     *\n+     * @param millisOfDay  the number of milliseconds into a day to convert\n+     * @param chrono  the chronology, null means ISO chronology\n+     */\n+    public static LocalTime fromMillisOfDay(long millisOfDay, Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono).withUTC();\n+        return new LocalTime(millisOfDay, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a LocalTime from a <code>java.util.Calendar</code>\n+     * using exactly the same field values.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the LocalTime.\n+     * This is useful if you have been using the Calendar as a local time,\n+     * ignoring the zone.\n+     * <p>\n+     * One advantage of this method is that this method is unaffected if the\n+     * version of the time zone data differs between the JDK and Joda-Time.\n+     * That is because the local field values are transferred, calculated using\n+     * the JDK time zone data and without using the Joda-Time time zone data.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a LocalTime with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created LocalTime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalTime fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new LocalTime(\n+            calendar.get(Calendar.HOUR_OF_DAY),\n+            calendar.get(Calendar.MINUTE),\n+            calendar.get(Calendar.SECOND),\n+            calendar.get(Calendar.MILLISECOND)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a LocalTime from a <code>java.util.Date</code>\n+     * using exactly the same field values.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the LocalTime.\n+     * This is useful if you have been using the Date as a local time,\n+     * ignoring the zone.\n+     * <p>\n+     * One advantage of this method is that this method is unaffected if the\n+     * version of the time zone data differs between the JDK and Joda-Time.\n+     * That is because the local field values are transferred, calculated using\n+     * the JDK time zone data and without using the Joda-Time time zone data.\n+     * <p>\n+     * This factory method always creates a LocalTime with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created LocalTime\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     */\n+    public static LocalTime fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new LocalTime(\n+            date.getHours(),\n+            date.getMinutes(),\n+            date.getSeconds(),\n+            (((int) (date.getTime() % 1000)) + 1000) % 1000\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     */\n+    public LocalTime() {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public LocalTime(DateTimeZone zone) {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current local time evaluated using\n+     * specified chronology and zone.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalTime(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the default zone.\n+     * <p>\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public LocalTime(long instant) {\n+        this(instant, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using ISO chronology in the specified zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public LocalTime(long instant, DateTimeZone zone) {\n+        this(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the local time defined by the specified\n+     * instant evaluated using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO chronology in the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalTime(long instant, Chronology chronology) {\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        \n+        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n+        chronology = chronology.withUTC();\n+        iLocalMillis = chronology.millisOfDay().get(localMillis);\n+        iChronology = chronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the object contains no time zone, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalTime(Object instant) {\n+        this(instant, (Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @param zone  the time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalTime(Object instant, DateTimeZone zone) {\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        Chronology chronology = converter.getChronology(instant, zone);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Once the constructor is completed, the zone is no longer used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePartial, ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.\n+     * The default String converter ignores the zone and only parses the field values.\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public LocalTime(Object instant, Chronology chronology) {\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser());\n+        iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the specified time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     */\n+    public LocalTime(\n+            int hourOfDay,\n+            int minuteOfHour) {\n+        this(hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     */\n+    public LocalTime(\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified time\n+     * using <code>ISOChronology</code>.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public LocalTime(\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute,\n+                millisOfSecond, ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified time\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public LocalTime(\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        long instant = chronology.getDateTimeMillis(\n+            0L, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        iChronology = chronology;\n+        iLocalMillis = instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is four.\n+     * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute\n+     * and MillisOfSecond.\n+     *\n+     * @return the field count, four\n+     */\n+    public int size() {\n+        return 4;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     *\n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case HOUR_OF_DAY:\n+                return chrono.hourOfDay();\n+            case MINUTE_OF_HOUR:\n+                return chrono.minuteOfHour();\n+            case SECOND_OF_MINUTE:\n+                return chrono.secondOfMinute();\n+            case MILLIS_OF_SECOND:\n+                return chrono.millisOfSecond();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * <p>\n+     * This method is required to support the <code>ReadablePartial</code>\n+     * interface. The supported fields are HourOfDay, MinuteOfHour,\n+     * SecondOfMinute and MillisOfSecond.\n+     *\n+     * @param index  the index, zero to three\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        switch (index) {\n+            case HOUR_OF_DAY:\n+                return getChronology().hourOfDay().get(getLocalMillis());\n+            case MINUTE_OF_HOUR:\n+                return getChronology().minuteOfHour().get(getLocalMillis());\n+            case SECOND_OF_MINUTE:\n+                return getChronology().secondOfMinute().get(getLocalMillis());\n+            case MILLIS_OF_SECOND:\n+                return getChronology().millisOfSecond().get(getLocalMillis());\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of time.\n+     * <p>\n+     * This method gets the value of the specified field.\n+     * For example:\n+     * <pre>\n+     * DateTime dt = new DateTime();\n+     * int hourOfDay = dt.get(DateTimeFieldType.hourOfDay());\n+     * </pre>\n+     *\n+     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null\n+     */\n+    public int get(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return fieldType.getField(getChronology()).get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Checks if the field type specified is supported by this\n+     * local time and chronology.\n+     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        if (isSupported(type.getDurationType()) == false) {\n+            return false;\n+        }\n+        DurationFieldType range = type.getRangeDurationType();\n+        return (isSupported(range) || range == DurationFieldType.days());\n+    }\n+\n+    /**\n+     * Checks if the duration type specified is supported by this\n+     * local time and chronology.\n+     *\n+     * @param type  a duration type, usually obtained from DurationFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        DurationField field = type.getField(getChronology());\n+        if (TIME_DURATION_TYPES.contains(type) ||\n+            field.getUnitMillis() < getChronology().days().getUnitMillis()) {\n+            return field.isSupported();\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the local milliseconds from the Java epoch\n+     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00\n+     * @since 1.5 (previously private)\n+     */\n+    protected long getLocalMillis() {\n+        return iLocalMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the time.\n+     * \n+     * @return the Chronology that the time is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * field types and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return true;\n+        }\n+        if (partial instanceof LocalTime) {\n+            LocalTime other = (LocalTime) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return iLocalMillis == other.iLocalMillis;\n+            }\n+        }\n+        return super.equals(partial);\n+    }\n+\n+    /**\n+     * Compares this partial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * The specified object must be a partial instance whose field types\n+     * match those of this partial.\n+     * <p>\n+     * NOTE: This implementation violates the Comparable contract.\n+     * This method will accept any instance of ReadablePartial as input.\n+     * However, it is possible that some implementations of ReadablePartial\n+     * exist that do not extend AbstractPartial, and thus will throw a\n+     * ClassCastException if compared in the opposite direction.\n+     * The cause of this problem is that ReadablePartial doesn't define\n+     * the compareTo() method, however we can't change that until v2.0.\n+     *\n+     * @param partial  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     */\n+    public int compareTo(ReadablePartial partial) {\n+        // override to perform faster\n+        if (this == partial) {\n+            return 0;\n+        }\n+        if (partial instanceof LocalTime) {\n+            LocalTime other = (LocalTime) partial;\n+            if (iChronology.equals(other.iChronology)) {\n+                return (iLocalMillis < other.iLocalMillis ? -1 :\n+                            (iLocalMillis == other.iLocalMillis ? 0 : 1));\n+\n+            }\n+        }\n+        return super.compareTo(partial);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with different local millis.\n+     * <p>\n+     * The returned object will be a new instance of the same type.\n+     * Only the millis will change, the chronology is kept.\n+     * The returned object will be either be a new instance or <code>this</code>.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00\n+     * @return a copy of this time with different millis\n+     */\n+    LocalTime withLocalMillis(long newMillis) {\n+        return (newMillis == getLocalMillis() ? this : new LocalTime(newMillis, getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the partial set of fields replacing\n+     * those from this instance.\n+     * <p>\n+     * For example, if the partial contains an hour and minute then those two\n+     * fields will be changed in the returned instance.\n+     * Unsupported fields are ignored.\n+     * If the partial is null, then <code>this</code> is returned.\n+     *\n+     * @param partial  the partial set of fields to apply to this time, null ignored\n+     * @return a copy of this time with a different set of fields\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    public LocalTime withFields(ReadablePartial partial) {\n+        if (partial == null) {\n+            return this;\n+        }\n+        return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the specified field set\n+     * to a new value.\n+     * <p>\n+     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n+     * field would be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * These lines are equivalent:\n+     * <pre>\n+     * LocalTime updated = dt.withHourOfDay(6);\n+     * LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this time with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public LocalTime withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the value of the specified\n+     * field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code>\n+     * is returned.\n+     * <p>\n+     * If the addition causes the maximum value of the field to be exceeded,\n+     * then the value will wrap. Thus 23:59 plus two minutes yields 00:01.\n+     * <p>\n+     * These lines are equivalent:\n+     * <pre>\n+     * LocalTime added = dt.plusHours(6);\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this time with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        if (amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusHours(int)}.\n+     *\n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this time with the period added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalTime withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().add(period, getLocalMillis(), scalar);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusHours(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @return a copy of this time with the period added\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalTime plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time plus the specified number of hours.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime added = dt.plusHours(6);\n+     * LocalTime added = dt.plus(Period.hours(6));\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new LocalTime plus the increased hours\n+     */\n+    public LocalTime plusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().add(getLocalMillis(), hours);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this time plus the specified number of minutes.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime added = dt.plusMinutes(6);\n+     * LocalTime added = dt.plus(Period.minutes(6));\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new LocalTime plus the increased minutes\n+     */\n+    public LocalTime plusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this time plus the specified number of seconds.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime added = dt.plusSeconds(6);\n+     * LocalTime added = dt.plus(Period.seconds(6));\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new LocalTime plus the increased seconds\n+     */\n+    public LocalTime plusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this time plus the specified number of millis.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime added = dt.plusMillis(6);\n+     * LocalTime added = dt.plus(Period.millis(6));\n+     * LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new LocalTime plus the increased millis\n+     */\n+    public LocalTime plusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().add(getLocalMillis(), millis);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusHours(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this time with the period taken away\n+     * @throws ArithmeticException if the result exceeds the internal capacity\n+     */\n+    public LocalTime minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time minus the specified number of hours.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime subtracted = dt.minusHours(6);\n+     * LocalTime subtracted = dt.minus(Period.hours(6));\n+     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to subtract, may be negative\n+     * @return the new LocalTime minus the increased hours\n+     */\n+    public LocalTime minusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this time minus the specified number of minutes.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime subtracted = dt.minusMinutes(6);\n+     * LocalTime subtracted = dt.minus(Period.minutes(6));\n+     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to subtract, may be negative\n+     * @return the new LocalTime minus the increased minutes\n+     */\n+    public LocalTime minusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this time minus the specified number of seconds.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime subtracted = dt.minusSeconds(6);\n+     * LocalTime subtracted = dt.minus(Period.seconds(6));\n+     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to subtract, may be negative\n+     * @return the new LocalTime minus the increased seconds\n+     */\n+    public LocalTime minusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n+        return withLocalMillis(instant);\n+    }\n+\n+    /**\n+     * Returns a copy of this time minus the specified number of millis.\n+     * <p>\n+     * This LocalTime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * LocalTime subtracted = dt.minusMillis(6);\n+     * LocalTime subtracted = dt.minus(Period.millis(6));\n+     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to subtract, may be negative\n+     * @return the new LocalTime minus the increased millis\n+     */\n+    public LocalTime minusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n+        return withLocalMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param fieldType  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        if (isSupported(fieldType) == false) {\n+            throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n+        }\n+        return new Property(this, fieldType.getField(getChronology()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getLocalMillis());\n+    }\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    public int getMillisOfDay() {\n+        return getChronology().millisOfDay().get(getLocalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the hour of day field updated.\n+     * <p>\n+     * LocalTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * hour of day changed.\n+     *\n+     * @param hour  the hour of day to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalTime withHourOfDay(int hour) {\n+        return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour));\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the minute of hour field updated.\n+     * <p>\n+     * LocalTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * minute of hour changed.\n+     *\n+     * @param minute  the minute of hour to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalTime withMinuteOfHour(int minute) {\n+        return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute));\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the second of minute field updated.\n+     * <p>\n+     * LocalTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * second of minute changed.\n+     *\n+     * @param second  the second of minute to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalTime withSecondOfMinute(int second) {\n+        return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second));\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the millis of second field updated.\n+     * <p>\n+     * LocalTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * millis of second changed.\n+     *\n+     * @param millis  the millis of second to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalTime withMillisOfSecond(int millis) {\n+        return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis));\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the millis of day field updated.\n+     * <p>\n+     * LocalTime is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * millis of day changed.\n+     *\n+     * @param millis  the millis of day to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public LocalTime withMillisOfDay(int millis) {\n+        return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property which provides access to advanced functionality.\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property which provides access to advanced functionality.\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of minute field property which provides access to advanced functionality.\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of second property which provides access to advanced functionality.\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, getChronology().millisOfSecond());\n+    }\n+\n+    /**\n+     * Get the millis of day property which provides access to advanced functionality.\n+     * \n+     * @return the millis of day property\n+     */\n+    public Property millisOfDay() {\n+        return new Property(this, getChronology().millisOfDay());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this LocalTime to a full datetime using the default time zone\n+     * setting the time fields from this instance and the date fields from\n+     * the current date.\n+     *\n+     * @return this time as a datetime using todays date\n+     */\n+    public DateTime toDateTimeToday() {\n+        return toDateTimeToday(null);\n+    }\n+\n+    /**\n+     * Converts this LocalTime to a full datetime using the specified time zone\n+     * setting the time fields from this instance and the date fields from\n+     * the current time.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this time as a datetime using todays date\n+     */\n+    public DateTime toDateTimeToday(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instantMillis = DateTimeUtils.currentTimeMillis();\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the time in ISO8601 format (HH:mm:ss.SSSZZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.time().print(this);\n+    }\n+\n+    /**\n+     * Output the time using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the time using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * LocalTime.Property binds a LocalTime to a DateTimeField allowing\n+     * powerful datetime functionality to be easily accessed.\n+     * <p>\n+     * The simplest use of this class is as an alternative get method, here used to\n+     * get the minute '30'.\n+     * <pre>\n+     * LocalTime dt = new LocalTime(12, 30);\n+     * int year = dt.minuteOfHour().get();\n+     * </pre>\n+     * <p>\n+     * Methods are also provided that allow time modification. These return\n+     * new instances of LocalTime - they do not modify the original. The example\n+     * below yields two independent immutable date objects 2 hours apart.\n+     * <pre>\n+     * LocalTime dt1230 = new LocalTime(12, 30);\n+     * LocalTime dt1430 = dt1230.hourOfDay().setCopy(14);\n+     * </pre>\n+     * <p>\n+     * LocalTime.Property itself is thread-safe and immutable, as well as the\n+     * LocalTime being operated on.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.3\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -325842547277223L;\n+        \n+        /** The instant this property is working against */\n+        private transient LocalTime iInstant;\n+        /** The field this property is working against */\n+        private transient DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(LocalTime instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+        \n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (LocalTime) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the milliseconds of the time that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getLocalMillis();\n+        }\n+        \n+        /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n+         * Gets the LocalTime object linked to this property.\n+         * \n+         * @return the linked LocalTime\n+         */\n+        public LocalTime getLocalTime() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to this field in a copy of this LocalTime.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime addCopy(int value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field in a copy of this LocalTime.\n+         * If the addition exceeds the maximum value (eg. 23:59) it will\n+         * wrap to the minimum value (eg. 00:00).\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime addCopy(long value) {\n+            return iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Adds to this field in a copy of this LocalTime.\n+         * If the addition exceeds the maximum value (eg. 23:59) then\n+         * an exception will be thrown.\n+         * Contrast this behaviour to {@link #addCopy(int)}.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the result is invalid\n+         */\n+        public LocalTime addNoWrapToCopy(int value) {\n+            long millis = iField.add(iInstant.getLocalMillis(), value);\n+            long rounded = iInstant.getChronology().millisOfDay().get(millis);\n+            if (rounded != millis) {\n+                throw new IllegalArgumentException(\"The addition exceeded the boundaries of LocalTime\");\n+            }\n+            return iInstant.withLocalMillis(millis);\n+        }\n+        \n+        /**\n+         * Adds to this field, possibly wrapped, in a copy of this LocalTime.\n+         * A field wrapped operation only changes this field.\n+         * Thus 10:59 plusWrapField one minute goes to 10:00.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to add to the field in the copy\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalTime addWrapFieldToCopy(int value) {\n+            return iInstant.withLocalMillis(iField.addWrapField(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the LocalTime.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public LocalTime setCopy(int value) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalTime to a parsed text value.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalTime setCopy(String text, Locale locale) {\n+            return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), text, locale));\n+        }\n+        \n+        /**\n+         * Sets this field in a copy of the LocalTime to a parsed text value.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @param text  the text value to set\n+         * @return a copy of the LocalTime with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public LocalTime setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new LocalTime with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalTime with this field set to its maximum\n+         */\n+        public LocalTime withMaximumValue() {\n+            return setCopy(getMaximumValue());\n+        }\n+        \n+        /**\n+         * Returns a new LocalTime with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The LocalTime attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the LocalTime with this field set to its minimum\n+         */\n+        public LocalTime withMinimumValue() {\n+            return setCopy(getMinimumValue());\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Rounds to the lowest whole unit of this field on a copy of this\n+         * LocalTime.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalTime\n+         * where the time is 10:30 would result in new LocalTime with the\n+         * time of 10:00.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime roundFloorCopy() {\n+            return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the highest whole unit of this field on a copy of this\n+         * LocalTime.\n+         * <p>\n+         * For example, rounding floor on the hourOfDay field of a LocalTime\n+         * where the time is 10:30 would result in new LocalTime with the\n+         * time of 11:00.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime roundCeilingCopy() {\n+            return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalTime, favoring the floor if halfway.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime roundHalfFloorCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalTime, favoring the ceiling if halfway.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime roundHalfCeilingCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis()));\n+        }\n+        \n+        /**\n+         * Rounds to the nearest whole unit of this field on a copy of this\n+         * LocalTime.  If halfway, the ceiling is favored over the floor\n+         * only if it makes this field's value even.\n+         *\n+         * @return a copy of the LocalTime with the field value changed\n+         */\n+        public LocalTime roundHalfEvenCopy() {\n+            return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis()));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Minutes.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of minutes.\n+ * <p>\n+ * <code>Minutes</code> is an immutable period that can only store minutes.\n+ * It does not store years, months or hours for example. As such it is a\n+ * type-safe way of representing a number of minutes in an application.\n+ * <p>\n+ * The number of minutes is set in the constructor, and may be queried using\n+ * <code>getMinutes()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Minutes</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Minutes extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero minutes. */\n+    public static final Minutes ZERO = new Minutes(0);\n+    /** Constant representing one minute. */\n+    public static final Minutes ONE = new Minutes(1);\n+    /** Constant representing two minutes. */\n+    public static final Minutes TWO = new Minutes(2);\n+    /** Constant representing three minutes. */\n+    public static final Minutes THREE = new Minutes(3);\n+    /** Constant representing the maximum number of minutes that can be stored in this object. */\n+    public static final Minutes MAX_VALUE = new Minutes(Integer.MAX_VALUE);\n+    /** Constant representing the minimum number of minutes that can be stored in this object. */\n+    public static final Minutes MIN_VALUE = new Minutes(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.minutes());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380863L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Minutes</code> that may be cached.\n+     * <code>Minutes</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param minutes  the number of minutes to obtain an instance for\n+     * @return the instance of Minutes\n+     */\n+    public static Minutes minutes(int minutes) {\n+        switch (minutes) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Minutes(minutes);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Minutes</code> representing the number of whole minutes\n+     * between the two specified datetimes.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Minutes minutesBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.minutes());\n+        return Minutes.minutes(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Minutes</code> representing the number of whole minutes\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalTime</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Minutes minutesBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalTime && end instanceof LocalTime)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int minutes = chrono.minutes().getDifference(\n+                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n+            return Minutes.minutes(minutes);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Minutes.minutes(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Minutes</code> representing the number of whole minutes\n+     * in the specified interval.\n+     *\n+     * @param interval  the interval to extract minutes from, null returns zero\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Minutes minutesIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Minutes.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes());\n+        return Minutes.minutes(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Minutes</code> representing the number of complete\n+     * standard length minutes in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to minutes using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of minutes from, null returns zero\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Minutes standardMinutesIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_MINUTE);\n+        return Minutes.minutes(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Minutes</code> by parsing a string in the ISO8601 format 'PTnM'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * minutes component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in minutes\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Minutes parseMinutes(String periodStr) {\n+        if (periodStr == null) {\n+            return Minutes.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Minutes.minutes(p.getMinutes());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of minutes.\n+     * You should consider using the factory method {@link #minutes(int)}\n+     * instead of the constructor.\n+     *\n+     * @param minutes  the number of minutes to represent\n+     */\n+    private Minutes(int minutes) {\n+        super(minutes);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Minutes.minutes(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>minutes</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.minutes();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>minutes</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.minutes();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in minutes to a period in weeks assuming a\n+     * 7 days week, 24 hour day and 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole weeks for this number of minutes\n+     */\n+    public Weeks toStandardWeeks() {\n+        return Weeks.weeks(getValue() / DateTimeConstants.MINUTES_PER_WEEK);\n+    }\n+\n+    /**\n+     * Converts this period in minutes to a period in days assuming a\n+     * 24 hour day and 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are\n+     * 24 hours long and all hours are 60 minutes long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole days for this number of minutes\n+     */\n+    public Days toStandardDays() {\n+        return Days.days(getValue() / DateTimeConstants.MINUTES_PER_DAY);\n+    }\n+\n+    /**\n+     * Converts this period in minutes to a period in hours assuming a\n+     * 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all hours are\n+     * 60 minutes long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of minutes\n+     */\n+    public Hours toStandardHours() {\n+        return Hours.hours(getValue() / DateTimeConstants.MINUTES_PER_HOUR);\n+    }\n+\n+    /**\n+     * Converts this period in minutes to a period in seconds assuming a\n+     * 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all minutes are\n+     * 60 seconds long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of seconds for this number of minutes\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     */\n+    public Seconds toStandardSeconds() {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_MINUTE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in minutes to a duration in milliseconds assuming a\n+     * 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all minutes are\n+     * 60 seconds long. This might not be true for an unusual chronology,\n+     * for example one that takes leap seconds into account.\n+     * However, the method is included as it is a useful operation for many\n+     * applications and business rules.\n+     *\n+     * @return a duration equivalent to this number of minutes\n+     */\n+    public Duration toStandardDuration() {\n+        long minutes = getValue();  // assign to a long\n+        return new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of minutes that this period represents.\n+     *\n+     * @return the number of minutes in the period\n+     */\n+    public int getMinutes() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of minutes added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new period plus the specified number of minutes\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes plus(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        return Minutes.minutes(FieldUtils.safeAdd(getValue(), minutes));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of minutes added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative, null means zero\n+     * @return the new period plus the specified number of minutes\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes plus(Minutes minutes) {\n+        if (minutes == null) {\n+            return this;\n+        }\n+        return plus(minutes.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of minutes taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to take away, may be negative\n+     * @return the new period minus the specified number of minutes\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes minus(int minutes) {\n+        return plus(FieldUtils.safeNegate(minutes));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of minutes taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of minutes\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes minus(Minutes minutes) {\n+        if (minutes == null) {\n+            return this;\n+        }\n+        return minus(minutes.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the minutes multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes multipliedBy(int scalar) {\n+        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the minutes divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Minutes dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Minutes.minutes(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the minutes value negated.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Minutes negated() {\n+        return Minutes.minutes(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this minutes instance greater than the specified number of minutes.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this minutes instance is greater than the specified one\n+     */\n+    public boolean isGreaterThan(Minutes other) {\n+        if (other == null) {\n+            return getValue() > 0;\n+        }\n+        return getValue() > other.getValue();\n+    }\n+\n+    /**\n+     * Is this minutes instance less than the specified number of minutes.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this minutes instance is less than the specified one\n+     */\n+    public boolean isLessThan(Minutes other) {\n+        if (other == null) {\n+            return getValue() < 0;\n+        }\n+        return getValue() < other.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"PT4M\" represents 4 minutes.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"PT\" + String.valueOf(getValue()) + \"M\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/MonthDay.java\n+/*\n+ *  Copyright 2001-2010 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BasePartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * MonthDay is an immutable partial supporting the monthOfYear and dayOfMonth fields.\n+ * <p>\n+ * NOTE: This class only supports the two fields listed above.\n+ * It is impossible to query any other fields, such as dayOfWeek or centuryOfEra.\n+ * <p>\n+ * Calculations on MonthDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * One use case for this class is to store a birthday without the year (to avoid\n+ * storing the age of the person).\n+ * This class can be used as the gMonthDay type in XML Schema.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getMonthOfYear()</code>\n+ * <li><code>monthOfYear().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * MonthDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Chris Pheby\n+ * @since 2.0\n+ */\n+public final class MonthDay\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2954560699050434609L;\n+\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.monthOfYear(),\n+        DateTimeFieldType.dayOfMonth(), };\n+\n+    /** The index of the monthOfYear field in the field array */\n+    public static final int MONTH_OF_YEAR = 0;\n+    /** The index of the day field in the field array */\n+    public static final int DAY_OF_MONTH = 1;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a MonthDay from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the MonthDay.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a MonthDay with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created MonthDay, never null\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology\n+     */\n+    public static MonthDay fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    /**\n+     * Constructs a MonthDay from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the MonthDay.\n+     * <p>\n+     * This factory method always creates a MonthDay with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created MonthDay, never null\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public static MonthDay fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new MonthDay(date.getMonth() + 1, date.getDate());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a MonthDay with the current monthOfYear, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     */\n+    public MonthDay() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with the current month-day, using ISOChronology in\n+     * the specified zone to extract the fields.\n+     * <p>\n+     * The constructor uses the specified time zone to obtain the current month-day.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     * \n+     * @param zone  the zone to use, null means default zone\n+     */\n+    public MonthDay(DateTimeZone zone) {\n+        super(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with the current month-day, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public MonthDay(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public MonthDay(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public MonthDay(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay from an Object that represents some form of time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The chronology used will be derived from the object, defaulting to ISO.\n+     *\n+     * @param instant  the date-time object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public MonthDay(Object instant) {\n+        super(instant, null, ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a MonthDay from an Object that represents some form of time,\n+     * using the specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     * The specified chronology overrides that of the object.\n+     *\n+     * @param instant  the date-time object, null means now\n+     * @param chronology  the chronology, null means ISO default\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public MonthDay(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with specified year and month\n+     * using <code>ISOChronology</code>.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public MonthDay(int monthOfYear, int dayOfMonth) {\n+        this(monthOfYear, dayOfMonth, null);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified monthOfYear and dayOfMonth\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\n+        super(new int[] {monthOfYear, dayOfMonth}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with chronology from this instance and new values.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    MonthDay(MonthDay partial, int[] values) {\n+        super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a MonthDay with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    MonthDay(MonthDay partial, Chronology chrono) {\n+        super(partial, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is two.\n+     * The supported fields are MonthOfYear and DayOfMonth.\n+     * Note that only these fields may be queried.\n+     *\n+     * @return the field count, two\n+     */\n+    public int size() {\n+        return 2;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field, never null\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+        case MONTH_OF_YEAR:\n+            return chrono.monthOfYear();\n+        case DAY_OF_MONTH:\n+            return chrono.dayOfMonth();\n+        default:\n+            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index, never null\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, Month, Day.\n+     *\n+     * @return the array of field types (cloned), largest to smallest, never null\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as MonthDay\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this month-day with a different chronology, never null\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public MonthDay withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            MonthDay newMonthDay = new MonthDay(this, newChronology);\n+            newChronology.validate(newMonthDay, getValues());\n+            return newMonthDay;\n+        }\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed in the returned instance.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * MonthDay updated = md.dayOfMonth().setCopy(6);\n+     * MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set, never null\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public MonthDay withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n+     * MonthDay added = md.plusDays(6);\n+     * MonthDay added = md.dayOfMonth().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated, never null\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new date-time exceeds the capacity\n+     */\n+    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added, never null\n+     * @throws ArithmeticException if the new date-time exceeds the capacity\n+     */\n+    public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusMonths(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added, never null\n+     * @throws ArithmeticException if the new month-day exceeds the capacity\n+     */\n+    public MonthDay plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day plus the specified number of months.\n+     * <p>\n+     * This month-day instance is immutable and unaffected by this method call.\n+     * The month will wrap at the end of the year from December to January.\n+     * The day will be adjusted to the last valid value if necessary.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * MonthDay added = md.plusMonths(6);\n+     * MonthDay added = md.plus(Period.months(6));\n+     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new month-day plus the increased months, never null\n+     */\n+    public MonthDay plusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), months);\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day plus the specified number of days.\n+     * <p>\n+     * This month-day instance is immutable and unaffected by this method call.\n+     * The month will wrap at the end of the year from December to January.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * MonthDay added = md.plusDays(6);\n+     * MonthDay added = md.plus(Period.days(6));\n+     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new month-day plus the increased days, never null\n+     */\n+    public MonthDay plusDays(int days) {\n+        return withFieldAdded(DurationFieldType.days(), days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusMonths(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away, never null\n+     * @throws ArithmeticException if the new month-day exceeds the capacity\n+     */\n+    public MonthDay minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day minus the specified number of months.\n+     * <p>\n+     * This MonthDay instance is immutable and unaffected by this method call.\n+     * The month will wrap at the end of the year from January to December.\n+     * The day will be adjusted to the last valid value if necessary.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * MonthDay subtracted = md.minusMonths(6);\n+     * MonthDay subtracted = md.minus(Period.months(6));\n+     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new month-day minus the increased months, never null\n+     */\n+    public MonthDay minusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day minus the specified number of months.\n+     * <p>\n+     * This month-day instance is immutable and unaffected by this method call.\n+     * The month will wrap at the end of the year from January to December.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * MonthDay subtracted = md.minusDays(6);\n+     * MonthDay subtracted = md.minus(Period.days(6));\n+     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new month-day minus the increased days, never null\n+     */\n+    public MonthDay minusDays(int days) {\n+        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalDate with the same month-day and chronology.\n+     *\n+     * @param year  the year to use, valid for chronology\n+     * @return a LocalDate with the same month-day and chronology, never null\n+     */\n+    public LocalDate toLocalDate(int year) {\n+        return new LocalDate(year, getMonthOfYear(), getDayOfMonth(), getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getValue(MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     *\n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getValue(DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this month-day with the month of year field updated.\n+     * <p>\n+     * MonthDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set, never null\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public MonthDay withMonthOfYear(int monthOfYear) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this month-day with the day of month field updated.\n+     * <p>\n+     * MonthDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of month changed.\n+     *\n+     * @param dayOMonth  the day of month to set\n+     * @return a copy of this object with the field set, never null\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public MonthDay withDayOfMonth(int dayOfMonth) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n+        return new MonthDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the month of year field property which provides access to advanced functionality.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field property which provides access to advanced functionality.\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the month-day in ISO8601 format (--MM-dd).\n+     *\n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        List<DateTimeFieldType> fields = new ArrayList<DateTimeFieldType>();\n+        fields.add(DateTimeFieldType.monthOfYear());\n+        fields.add(DateTimeFieldType.dayOfMonth());\n+        return ISODateTimeFormat.forFields(fields, true, true).print(this);\n+    }\n+\n+    /**\n+     * Output the month-day using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the month-day using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>MonthDay</code>.\n+     * <p>\n+     * This class binds a <code>YearMonth</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Chris Pheby\n+     * @since 2.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 5727734012190224363L;\n+\n+        /** The partial */\n+        private final MonthDay iBase;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(MonthDay partial, int fieldIndex) {\n+            super();\n+            iBase = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iBase.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iBase;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public MonthDay getMonthDay() {\n+            return iBase;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iBase.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this MonthDay.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public MonthDay addToCopy(int valueToAdd) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n+            return new MonthDay(iBase, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this MonthDay wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>--12-30</code> addWrapField one month returns <code>--01-30</code>.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public MonthDay addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n+            return new MonthDay(iBase, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the MonthDay.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public MonthDay setCopy(int value) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().set(iBase, iFieldIndex, newValues, value);\n+            return new MonthDay(iBase, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the MonthDay to a parsed text value.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public MonthDay setCopy(String text, Locale locale) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);\n+            return new MonthDay(iBase, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the MonthDay to a parsed text value.\n+         * <p>\n+         * The MonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the MonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public MonthDay setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Months.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of months.\n+ * <p>\n+ * <code>Months</code> is an immutable period that can only store months.\n+ * It does not store years, days or hours for example. As such it is a\n+ * type-safe way of representing a number of months in an application.\n+ * <p>\n+ * The number of months is set in the constructor, and may be queried using\n+ * <code>getMonths()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Months</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Months extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero months. */\n+    public static final Months ZERO = new Months(0);\n+    /** Constant representing one month. */\n+    public static final Months ONE = new Months(1);\n+    /** Constant representing two months. */\n+    public static final Months TWO = new Months(2);\n+    /** Constant representing three months. */\n+    public static final Months THREE = new Months(3);\n+    /** Constant representing four months. */\n+    public static final Months FOUR = new Months(4);\n+    /** Constant representing five months. */\n+    public static final Months FIVE = new Months(5);\n+    /** Constant representing six months. */\n+    public static final Months SIX = new Months(6);\n+    /** Constant representing seven months. */\n+    public static final Months SEVEN = new Months(7);\n+    /** Constant representing eight months. */\n+    public static final Months EIGHT = new Months(8);\n+    /** Constant representing nine months. */\n+    public static final Months NINE = new Months(9);\n+    /** Constant representing ten months. */\n+    public static final Months TEN = new Months(10);\n+    /** Constant representing eleven months. */\n+    public static final Months ELEVEN = new Months(11);\n+    /** Constant representing twelve months. */\n+    public static final Months TWELVE = new Months(12);\n+    /** Constant representing the maximum number of months that can be stored in this object. */\n+    public static final Months MAX_VALUE = new Months(Integer.MAX_VALUE);\n+    /** Constant representing the minimum number of months that can be stored in this object. */\n+    public static final Months MIN_VALUE = new Months(Integer.MIN_VALUE);\n+\n+    /** The parser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.months());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380867L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Months</code> that may be cached.\n+     * <code>Months</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param months  the number of months to obtain an instance for\n+     * @return the instance of Months\n+     */\n+    public static Months months(int months) {\n+        switch (months) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case 4:\n+                return FOUR;\n+            case 5:\n+                return FIVE;\n+            case 6:\n+                return SIX;\n+            case 7:\n+                return SEVEN;\n+            case 8:\n+                return EIGHT;\n+            case 9:\n+                return NINE;\n+            case 10:\n+                return TEN;\n+            case 11:\n+                return ELEVEN;\n+            case 12:\n+                return TWELVE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Months(months);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Months</code> representing the number of whole months\n+     * between the two specified datetimes. This method corectly handles\n+     * any daylight savings time changes that may occur during the interval.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in months\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Months monthsBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.months());\n+        return Months.months(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Months</code> representing the number of whole months\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in months\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Months monthsBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalDate && end instanceof LocalDate)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int months = chrono.months().getDifference(\n+                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n+            return Months.months(months);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Months.months(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Months</code> representing the number of whole months\n+     * in the specified interval. This method corectly handles any daylight\n+     * savings time changes that may occur during the interval.\n+     *\n+     * @param interval  the interval to extract months from, null returns zero\n+     * @return the period in months\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Months monthsIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Months.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months());\n+        return Months.months(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Months</code> by parsing a string in the ISO8601 format 'PnM'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * months component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in months\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Months parseMonths(String periodStr) {\n+        if (periodStr == null) {\n+            return Months.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Months.months(p.getMonths());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of months.\n+     * You should consider using the factory method {@link #months(int)}\n+     * instead of the constructor.\n+     *\n+     * @param months  the number of months to represent\n+     */\n+    private Months(int months) {\n+        super(months);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Months.months(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>months</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.months();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>months</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.months();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of months that this period represents.\n+     *\n+     * @return the number of months in the period\n+     */\n+    public int getMonths() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of months added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new period plus the specified number of months\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months plus(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        return Months.months(FieldUtils.safeAdd(getValue(), months));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of months added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to add, may be negative, null means zero\n+     * @return the new period plus the specified number of months\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months plus(Months months) {\n+        if (months == null) {\n+            return this;\n+        }\n+        return plus(months.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of months taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to take away, may be negative\n+     * @return the new period minus the specified number of months\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months minus(int months) {\n+        return plus(FieldUtils.safeNegate(months));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of months taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of months\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months minus(Months months) {\n+        if (months == null) {\n+            return this;\n+        }\n+        return minus(months.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the months multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months multipliedBy(int scalar) {\n+        return Months.months(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the months divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Months dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Months.months(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the months value negated.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Months negated() {\n+        return Months.months(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this months instance greater than the specified number of months.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this months instance is greater than the specified one\n+     */\n+    public boolean isGreaterThan(Months other) {\n+        if (other == null) {\n+            return getValue() > 0;\n+        }\n+        return getValue() > other.getValue();\n+    }\n+\n+    /**\n+     * Is this months instance less than the specified number of months.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this months instance is less than the specified one\n+     */\n+    public boolean isLessThan(Months other) {\n+        if (other == null) {\n+            return getValue() < 0;\n+        }\n+        return getValue() < other.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P4M\" represents 4 months.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"P\" + String.valueOf(getValue()) + \"M\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/MutableDateTime.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BaseDateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractReadableInstantFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * MutableDateTime is the standard implementation of a modifiable datetime class.\n+ * It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.\n+ * <p>\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n+ * <p>\n+ * Each individual field can be accessed in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>get numeric value\n+ * <li>set numeric value\n+ * <li>add to numeric value\n+ * <li>add to numeric value wrapping with the field\n+ * <li>get text vlaue\n+ * <li>get short text value\n+ * <li>set text value\n+ * <li>field maximum value\n+ * <li>field minimum value\n+ * </ul>\n+ *\n+ * <p>\n+ * MutableDateTime is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n+ * @author Guy Allard\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @author Mike Schrag\n+ * @since 1.0\n+ * @see DateTime\n+ */\n+public class MutableDateTime\n+        extends BaseDateTime\n+        implements ReadWritableDateTime, Cloneable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2852608688135209575L;\n+\n+    /** Rounding is disabled */\n+    public static final int ROUND_NONE = 0;\n+    /** Rounding mode as described by {@link DateTimeField#roundFloor} */\n+    public static final int ROUND_FLOOR = 1;\n+    /** Rounding mode as described by {@link DateTimeField#roundCeiling} */\n+    public static final int ROUND_CEILING = 2;\n+    /** Rounding mode as described by {@link DateTimeField#roundHalfFloor} */\n+    public static final int ROUND_HALF_FLOOR = 3;\n+    /** Rounding mode as described by {@link DateTimeField#roundHalfCeiling} */\n+    public static final int ROUND_HALF_CEILING = 4;\n+    /** Rounding mode as described by {@link DateTimeField#roundHalfEven} */\n+    public static final int ROUND_HALF_EVEN = 5;\n+\n+    /** The field to round on */\n+    private DateTimeField iRoundingField;\n+    /** The mode of rounding */\n+    private int iRoundingMode;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n+     */\n+    public MutableDateTime() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public MutableDateTime(DateTimeZone zone) {\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public MutableDateTime(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public MutableDateTime(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public MutableDateTime(long instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public MutableDateTime(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime.\n+     * <p>\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used. Otherwise, ISO default is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public MutableDateTime(Object instant) {\n+        super(instant, (Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object implies a chronology (such as GregorianCalendar does),\n+     * then that chronology will be used, but with the time zone adjusted.\n+     * Otherwise, ISO is used in the specified time zone.\n+     * If the specified time zone is null, the default zone is used.\n+     * Thus if a GregorianCalendar is passed in, the chronology used will\n+     * be GJ, but if a Date is passed in the chronology will be ISO.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param zone  the time zone, null means default time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public MutableDateTime(Object instant, DateTimeZone zone) {\n+        super(instant, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * Any chronology implied by the object (such as GregorianCalendar does)\n+     * is ignored.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public MutableDateTime(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public MutableDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    public MutableDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            DateTimeZone zone) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public MutableDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super(year, monthOfYear, dayOfMonth,\n+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field used for rounding this instant, returning null if rounding\n+     * is not enabled.\n+     * \n+     * @return the rounding field\n+     */\n+    public DateTimeField getRoundingField() {\n+        return iRoundingField;\n+    }\n+\n+    /**\n+     * Gets the rounding mode for this instant, returning ROUND_NONE if rounding\n+     * is not enabled.\n+     * \n+     * @return the rounding mode constant\n+     */\n+    public int getRoundingMode() {\n+        return iRoundingMode;\n+    }\n+\n+    /**\n+     * Sets the status of rounding to use the specified field and ROUND_FLOOR mode.\n+     * A null field will disable rounding.\n+     * Once set, the instant is then rounded using the new field and mode.\n+     * <p>\n+     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}\n+     * to be rounded. This can be used to control the precision of the instant,\n+     * for example by setting a rounding field of minuteOfDay, the seconds and\n+     * milliseconds will always be zero.\n+     *\n+     * @param field rounding field or null to disable\n+     */\n+    public void setRounding(DateTimeField field) {\n+        setRounding(field, MutableDateTime.ROUND_FLOOR);\n+    }\n+\n+    /**\n+     * Sets the status of rounding to use the specified field and mode.\n+     * A null field or mode of ROUND_NONE will disable rounding.\n+     * Once set, the instant is then rounded using the new field and mode.\n+     * <p>\n+     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}\n+     * to be rounded. This can be used to control the precision of the instant,\n+     * for example by setting a rounding field of minuteOfDay, the seconds and\n+     * milliseconds will always be zero.\n+     *\n+     * @param field  rounding field or null to disable\n+     * @param mode  rounding mode or ROUND_NONE to disable\n+     * @throws IllegalArgumentException if mode is unknown, no exception if field is null\n+     */\n+    public void setRounding(DateTimeField field, int mode) {\n+        if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {\n+            throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode);\n+        }\n+        iRoundingField = (mode == ROUND_NONE ? null : field);\n+        iRoundingMode = (field == null ? ROUND_NONE : mode);\n+        setMillis(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the milliseconds of the datetime.\n+     * <p>\n+     * All changes to the millisecond field occurs via this method.\n+     *\n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * datetime to\n+     */\n+    public void setMillis(long instant) {\n+        switch (iRoundingMode) {\n+            case ROUND_NONE:\n+                break;\n+            case ROUND_FLOOR:\n+                instant = iRoundingField.roundFloor(instant);\n+                break;\n+            case ROUND_CEILING:\n+                instant = iRoundingField.roundCeiling(instant);\n+                break;\n+            case ROUND_HALF_FLOOR:\n+                instant = iRoundingField.roundHalfFloor(instant);\n+                break;\n+            case ROUND_HALF_CEILING:\n+                instant = iRoundingField.roundHalfCeiling(instant);\n+                break;\n+            case ROUND_HALF_EVEN:\n+                instant = iRoundingField.roundHalfEven(instant);\n+                break;\n+        }\n+\n+        super.setMillis(instant);\n+    }\n+\n+    /**\n+     * Sets the millisecond instant of this instant from another.\n+     * <p>\n+     * This method does not change the chronology of this instant, just the\n+     * millisecond instant.\n+     * \n+     * @param instant  the instant to use, null means now\n+     */\n+    public void setMillis(ReadableInstant instant) {\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        setMillis(instantMillis);  // set via this class not super\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add an amount of time to the datetime.\n+     * \n+     * @param duration  the millis to add\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public void add(long duration) {\n+        setMillis(FieldUtils.safeAdd(getMillis(), duration));  // set via this class not super\n+    }\n+\n+    /**\n+     * Adds a duration to this instant.\n+     * <p>\n+     * This will typically change the value of most fields.\n+     *\n+     * @param duration  the duration to add, null means add zero\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public void add(ReadableDuration duration) {\n+        add(duration, 1);\n+    }\n+\n+    /**\n+     * Adds a duration to this instant specifying how many times to add.\n+     * <p>\n+     * This will typically change the value of most fields.\n+     *\n+     * @param duration  the duration to add, null means add zero\n+     * @param scalar  direction and amount to add, which may be negative\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public void add(ReadableDuration duration, int scalar) {\n+        if (duration != null) {\n+            add(FieldUtils.safeMultiply(duration.getMillis(), scalar));\n+        }\n+    }\n+\n+    /**\n+     * Adds a period to this instant.\n+     * <p>\n+     * This will typically change the value of most fields.\n+     *\n+     * @param period  the period to add, null means add zero\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public void add(ReadablePeriod period) {\n+        add(period, 1);\n+    }\n+\n+    /**\n+     * Adds a period to this instant specifying how many times to add.\n+     * <p>\n+     * This will typically change the value of most fields.\n+     *\n+     * @param period  the period to add, null means add zero\n+     * @param scalar  direction and amount to add, which may be negative\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public void add(ReadablePeriod period, int scalar) {\n+        if (period != null) {\n+            setMillis(getChronology().add(period, getMillis(), scalar));  // set via this class not super\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the chronology of the datetime.\n+     * <p>\n+     * All changes to the chronology occur via this method.\n+     * \n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n+     */\n+    public void setChronology(Chronology chronology) {\n+        super.setChronology(chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the time zone of the datetime, changing the chronology and field values.\n+     * <p>\n+     * Changing the zone using this method retains the millisecond instant.\n+     * The millisecond instant is adjusted in the new zone to compensate.\n+     * \n+     * chronology. Setting the time zone does not affect the millisecond value\n+     * of this instant.\n+     * <p>\n+     * If the chronology already has this time zone, no change occurs.\n+     *\n+     * @param newZone  the time zone to use, null means default zone\n+     * @see #setZoneRetainFields\n+     */\n+    public void setZone(DateTimeZone newZone) {\n+        newZone = DateTimeUtils.getZone(newZone);\n+        Chronology chrono = getChronology();\n+        if (chrono.getZone() != newZone) {\n+            setChronology(chrono.withZone(newZone));  // set via this class not super\n+        }\n+    }\n+\n+    /**\n+     * Sets the time zone of the datetime, changing the chronology and millisecond.\n+     * <p>\n+     * Changing the zone using this method retains the field values.\n+     * The millisecond instant is adjusted in the new zone to compensate.\n+     * <p>\n+     * If the chronology already has this time zone, no change occurs.\n+     *\n+     * @param newZone  the time zone to use, null means default zone\n+     * @see #setZone\n+     */\n+    public void setZoneRetainFields(DateTimeZone newZone) {\n+        newZone = DateTimeUtils.getZone(newZone);\n+        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n+        if (newZone == originalZone) {\n+            return;\n+        }\n+        \n+        long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n+        setChronology(getChronology().withZone(newZone));  // set via this class not super\n+        setMillis(millis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of one of the fields of the instant, such as hourOfDay.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n+     * @param value  the value to set the field to\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public void set(DateTimeFieldType type, int value) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        setMillis(type.getField(getChronology()).set(getMillis(), value));\n+    }\n+\n+    /**\n+     * Adds to the instant specifying the duration and multiple to add.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n+     * @param amount  the amount to add of this duration\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public void add(DurationFieldType type, int amount) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        setMillis(type.getField(getChronology()).add(getMillis(), amount));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the year to the specified value.\n+     *\n+     * @param year  the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setYear(final int year) {\n+        setMillis(getChronology().year().set(getMillis(), year));\n+    }\n+\n+    /**\n+     * Add a number of years to the date.\n+     *\n+     * @param years  the years to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addYears(final int years) {\n+        setMillis(getChronology().years().add(getMillis(), years));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the weekyear to the specified value.\n+     *\n+     * @param weekyear  the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setWeekyear(final int weekyear) {\n+        setMillis(getChronology().weekyear().set(getMillis(), weekyear));\n+    }\n+\n+    /**\n+     * Add a number of weekyears to the date.\n+     *\n+     * @param weekyears  the weekyears to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addWeekyears(final int weekyears) {\n+        setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the month of the year to the specified value.\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMonthOfYear(final int monthOfYear) {\n+        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n+    }\n+\n+    /**\n+     * Add a number of months to the date.\n+     *\n+     * @param months  the months to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMonths(final int months) {\n+        setMillis(getChronology().months().add(getMillis(), months));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the week of weekyear to the specified value.\n+     *\n+     * @param weekOfWeekyear the week of the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setWeekOfWeekyear(final int weekOfWeekyear) {\n+        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n+    }\n+\n+    /**\n+     * Add a number of weeks to the date.\n+     *\n+     * @param weeks  the weeks to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addWeeks(final int weeks) {\n+        setMillis(getChronology().weeks().add(getMillis(), weeks));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the day of year to the specified value.\n+     *\n+     * @param dayOfYear the day of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfYear(final int dayOfYear) {\n+        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n+    }\n+\n+    /**\n+     * Set the day of the month to the specified value.\n+     *\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfMonth(final int dayOfMonth) {\n+        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n+    }\n+\n+    /**\n+     * Set the day of week to the specified value.\n+     *\n+     * @param dayOfWeek  the day of the week\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfWeek(final int dayOfWeek) {\n+        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n+    }\n+\n+    /**\n+     * Add a number of days to the date.\n+     *\n+     * @param days  the days to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addDays(final int days) {\n+        setMillis(getChronology().days().add(getMillis(), days));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the hour of the day to the specified value.\n+     *\n+     * @param hourOfDay  the hour of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setHourOfDay(final int hourOfDay) {\n+        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));\n+    }\n+\n+    /**\n+     * Add a number of hours to the date.\n+     *\n+     * @param hours  the hours to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addHours(final int hours) {\n+        setMillis(getChronology().hours().add(getMillis(), hours));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the minute of the day to the specified value.\n+     *\n+     * @param minuteOfDay  the minute of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMinuteOfDay(final int minuteOfDay) {\n+        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));\n+    }\n+\n+    /**\n+     * Set the minute of the hour to the specified value.\n+     *\n+     * @param minuteOfHour  the minute of hour\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMinuteOfHour(final int minuteOfHour) {\n+        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));\n+    }\n+\n+    /**\n+     * Add a number of minutes to the date.\n+     *\n+     * @param minutes  the minutes to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMinutes(final int minutes) {\n+        setMillis(getChronology().minutes().add(getMillis(), minutes));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the second of the day to the specified value.\n+     *\n+     * @param secondOfDay  the second of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setSecondOfDay(final int secondOfDay) {\n+        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));\n+    }\n+\n+    /**\n+     * Set the second of the minute to the specified value.\n+     *\n+     * @param secondOfMinute  the second of minute\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setSecondOfMinute(final int secondOfMinute) {\n+        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));\n+    }\n+\n+    /**\n+     * Add a number of seconds to the date.\n+     *\n+     * @param seconds  the seconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addSeconds(final int seconds) {\n+        setMillis(getChronology().seconds().add(getMillis(), seconds));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the millis of the day to the specified value.\n+     *\n+     * @param millisOfDay  the millis of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillisOfDay(final int millisOfDay) {\n+        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n+    }\n+\n+    /**\n+     * Set the millis of the second to the specified value.\n+     *\n+     * @param millisOfSecond  the millis of second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillisOfSecond(final int millisOfSecond) {\n+        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));\n+    }\n+\n+    /**\n+     * Add a number of milliseconds to the date. The implementation of this\n+     * method differs from the {@link #add(long)} method in that a\n+     * DateTimeField performs the addition.\n+     *\n+     * @param millis  the milliseconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMillis(final int millis) {\n+        setMillis(getChronology().millis().add(getMillis(), millis));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the date from milliseconds.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param instant  an instant to copy the date from, time part ignored\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDate(final long instant) {\n+        setMillis(getChronology().millisOfDay().set(instant, getMillisOfDay()));\n+    }\n+\n+    /**\n+     * Set the date from another instant.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param instant  an instant to copy the date from, time part ignored\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    public void setDate(final ReadableInstant instant) {\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);\n+        DateTimeZone zone = instantChrono.getZone();\n+        if (zone != null) {\n+            instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);\n+        }\n+        setDate(instantMillis);\n+    }\n+\n+    /**\n+     * Set the date from fields.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDate(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth) {\n+        Chronology c = getChronology();\n+        long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n+        setDate(instantMidnight);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the time from milliseconds.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param millis  an instant to copy the time from, date part ignored\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setTime(final long millis) {\n+        int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis);\n+        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n+    }\n+\n+    /**\n+     * Set the time from another instant.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param instant  an instant to copy the time from, date part ignored\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    public void setTime(final ReadableInstant instant) {\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology instantChrono = DateTimeUtils.getInstantChronology(instant);\n+        DateTimeZone zone = instantChrono.getZone();\n+        if (zone != null) {\n+            instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis);\n+        }\n+        setTime(instantMillis);\n+    }\n+\n+    /**\n+     * Set the time from fields.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param hour  the hour\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setTime(\n+            final int hour,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond) {\n+        long instant = getChronology().getDateTimeMillis(\n+            getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);\n+        setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the date and time from fields.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDateTime(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth,\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond) {\n+        long instant = getChronology().getDateTimeMillis(\n+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        setMillis(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains many useful methods.\n+     *\n+     * @param type  the field type to get the chronology for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     * @since 1.2\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        DateTimeField field = type.getField(getChronology());\n+        if (field.isSupported() == false) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return new Property(this, field);\n+    }\n+\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     */\n+    public Property era() {\n+        return new Property(this, getChronology().era());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property centuryOfEra() {\n+        return new Property(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property yearOfCentury() {\n+        return new Property(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public Property yearOfEra() {\n+        return new Property(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public Property weekyear() {\n+        return new Property(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public Property weekOfWeekyear() {\n+        return new Property(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     */\n+    public Property dayOfYear() {\n+        return new Property(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * <p>\n+     * The values for day of month are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of week property.\n+     * <p>\n+     * The values for day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week property\n+     */\n+    public Property dayOfWeek() {\n+        return new Property(this, getChronology().dayOfWeek());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of day property\n+     * \n+     * @return the minute of day property\n+     */\n+    public Property minuteOfDay() {\n+        return new Property(this, getChronology().minuteOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of day property\n+     * \n+     * @return the second of day property\n+     */\n+    public Property secondOfDay() {\n+        return new Property(this, getChronology().secondOfDay());\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of day property\n+     * \n+     * @return the millis of day property\n+     */\n+    public Property millisOfDay() {\n+        return new Property(this, getChronology().millisOfDay());\n+    }\n+\n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, getChronology().millisOfSecond());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutableDateTime copy() {\n+        return (MutableDateTime) clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.dateTime().print(this);\n+    }\n+\n+    /**\n+     * MutableDateTime.Property binds a MutableDateTime to a\n+     * DateTimeField allowing powerful datetime functionality to be easily\n+     * accessed.\n+     * <p>\n+     * The example below shows how to use the property to change the value of a\n+     * MutableDateTime object.\n+     * <pre>\n+     * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 13, 32, 19, 123);\n+     * dt.year().add(20);\n+     * dt.second().roundFloor().minute().set(10);\n+     * </pre>\n+     * <p>\n+     * MutableDateTime.Propery itself is thread-safe and immutable, but the\n+     * MutableDateTime being operated on is not.\n+     *\n+     * @author Stephen Colebourne\n+     * @author Brian S O'Neill\n+     * @since 1.0\n+     */\n+    public static final class Property extends AbstractReadableInstantFieldProperty {\n+        \n+        /** Serialization version */\n+        private static final long serialVersionUID = -4481126543819298617L;\n+        \n+        /** The instant this property is working against */\n+        private MutableDateTime iInstant;\n+        /** The field this property is working against */\n+        private DateTimeField iField;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param instant  the instant to set\n+         * @param field  the field to use\n+         */\n+        Property(MutableDateTime instant, DateTimeField field) {\n+            super();\n+            iInstant = instant;\n+            iField = field;\n+        }\n+        \n+        /**\n+         * Writes the property in a safe serialization format.\n+         */\n+        private void writeObject(ObjectOutputStream oos) throws IOException {\n+            oos.writeObject(iInstant);\n+            oos.writeObject(iField.getType());\n+        }\n+\n+        /**\n+         * Reads the property from a safe serialization format.\n+         */\n+        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {\n+            iInstant = (MutableDateTime) oos.readObject();\n+            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n+            iField = type.getField(iInstant.getChronology());\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the field being used.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iField;\n+        }\n+        \n+        /**\n+         * Gets the milliseconds of the datetime that this property is linked to.\n+         * \n+         * @return the milliseconds\n+         */\n+        protected long getMillis() {\n+            return iInstant.getMillis();\n+        }\n+        \n+        /**\n+         * Gets the chronology of the datetime that this property is linked to.\n+         * \n+         * @return the chronology\n+         * @since 1.4\n+         */\n+        protected Chronology getChronology() {\n+            return iInstant.getChronology();\n+        }\n+        \n+        /**\n+         * Gets the mutable datetime being used.\n+         * \n+         * @return the mutable datetime\n+         */\n+        public MutableDateTime getMutableDateTime() {\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds a value to the millis value.\n+         * \n+         * @param value  the value to add\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#add(long,int)\n+         */\n+        public MutableDateTime add(int value) {\n+            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Adds a value to the millis value.\n+         * \n+         * @param value  the value to add\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#add(long,long)\n+         */\n+        public MutableDateTime add(long value) {\n+            iInstant.setMillis(getField().add(iInstant.getMillis(), value));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Adds a value, possibly wrapped, to the millis value.\n+         * \n+         * @param value  the value to add\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#addWrapField\n+         */\n+        public MutableDateTime addWrapField(int value) {\n+            iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value));\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets a value.\n+         * \n+         * @param value  the value to set.\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#set(long,int)\n+         */\n+        public MutableDateTime set(int value) {\n+            iInstant.setMillis(getField().set(iInstant.getMillis(), value));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Sets a text value.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         * @see DateTimeField#set(long,java.lang.String,java.util.Locale)\n+         */\n+        public MutableDateTime set(String text, Locale locale) {\n+            iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Sets a text value.\n+         * \n+         * @param text  the text value to set\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         * @see DateTimeField#set(long,java.lang.String)\n+         */\n+        public MutableDateTime set(String text) {\n+            set(text, null);\n+            return iInstant;\n+        }\n+        \n+        //-----------------------------------------------------------------------\n+        /**\n+         * Round to the lowest whole unit of this field.\n+         *\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#roundFloor\n+         */\n+        public MutableDateTime roundFloor() {\n+            iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+\n+        /**\n+         * Round to the highest whole unit of this field.\n+         *\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#roundCeiling\n+         */\n+        public MutableDateTime roundCeiling() {\n+            iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Round to the nearest whole unit of this field, favoring the floor if\n+         * halfway.\n+         *\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#roundHalfFloor\n+         */\n+        public MutableDateTime roundHalfFloor() {\n+            iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+        \n+        /**\n+         * Round to the nearest whole unit of this field, favoring the ceiling if\n+         * halfway.\n+         *\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#roundHalfCeiling\n+         */\n+        public MutableDateTime roundHalfCeiling() {\n+            iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+\n+        /**\n+         * Round to the nearest whole unit of this field. If halfway, the ceiling\n+         * is favored over the floor only if it makes this field's value even.\n+         *\n+         * @return the mutable datetime being used, so calls can be chained\n+         * @see DateTimeField#roundHalfEven\n+         */\n+        public MutableDateTime roundHalfEven() {\n+            iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));\n+            return iInstant;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/MutableInterval.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.base.BaseInterval;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.format.ISOPeriodFormat;\n+\n+/**\n+ * MutableInterval is the standard implementation of a mutable time interval.\n+ * <p>\n+ * A time interval represents a period of time between two instants.\n+ * Intervals are inclusive of the start instant and exclusive of the end.\n+ * The end instant is always greater than or equal to the start instant.\n+ * <p>\n+ * Intervals have a fixed millisecond duration.\n+ * This is the difference between the start and end instants.\n+ * The duration is represented separately by {@link ReadableDuration}.\n+ * As a result, intervals are not comparable.\n+ * To compare the length of two intervals, you should compare their durations.\n+ * <p>\n+ * An interval can also be converted to a {@link ReadablePeriod}.\n+ * This represents the difference between the start and end points in terms of fields\n+ * such as years and days.\n+ * <p>\n+ * If performing significant calculations on an interval, it may be faster to\n+ * convert an Interval object to a MutableInterval one.\n+ * <p>\n+ * MutableInterval is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class MutableInterval\n+        extends BaseInterval\n+        implements ReadWritableInterval, Cloneable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -5982824024992428470L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a zero length time interval from 1970-01-01 to 1970-01-01.\n+     */\n+    public MutableInterval() {\n+        super(0L, 0L, null);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant with the ISO default chronology.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public MutableInterval(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant with a chronology.\n+     * \n+     * @param chronology  the chronology to use, null is ISO default\n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public MutableInterval(long startInstant, long endInstant, Chronology chronology) {\n+        super(startInstant, endInstant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * <p>\n+     * The chronology used is that of the start instant.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public MutableInterval(ReadableInstant start, ReadableInstant end) {\n+        super(start, end);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a duration.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param duration  the duration of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public MutableInterval(ReadableInstant start, ReadableDuration duration) {\n+        super(start, duration);\n+    }\n+\n+    /**\n+     * Constructs an interval from a millisecond duration and an end instant.\n+     * \n+     * @param duration  the duration of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public MutableInterval(ReadableDuration duration, ReadableInstant end) {\n+        super(duration, end);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a time period.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param period  the period of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public MutableInterval(ReadableInstant start, ReadablePeriod period) {\n+        super(start, period);\n+    }\n+\n+    /**\n+     * Constructs an interval from a time period and an end instant.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param period  the period of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public MutableInterval(ReadablePeriod period, ReadableInstant end) {\n+        super(period, end);\n+    }\n+\n+    /**\n+     * Constructs a time interval by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInterval and String.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n+     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n+     * 'datetime/period' or 'period/datetime'.\n+     * \n+     * @param interval  the time interval to copy\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    public MutableInterval(Object interval) {\n+        super(interval, null);\n+    }\n+\n+    /**\n+     * Constructs a time interval by converting or copying from another object,\n+     * overriding the chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInterval and String.\n+     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}\n+     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n+     * 'datetime/period' or 'period/datetime'.\n+     * \n+     * @param interval  the time interval to copy\n+     * @param chronology  the chronology to use, null means ISO default\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    public MutableInterval(Object interval, Chronology chronology) {\n+        super(interval, chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets this interval from two millisecond instants retaining the chronology.\n+     *\n+     * @param startInstant  the start of the time interval\n+     * @param endInstant  the start of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setInterval(long startInstant, long endInstant) {\n+        super.setInterval(startInstant, endInstant, getChronology());\n+    }\n+\n+    /**\n+     * Sets this interval to be the same as another.\n+     *\n+     * @param interval  the interval to copy\n+     * @throws IllegalArgumentException if the interval is null\n+     */\n+    public void setInterval(ReadableInterval interval) {\n+        if (interval == null) {\n+            throw new IllegalArgumentException(\"Interval must not be null\");\n+        }\n+        long startMillis = interval.getStartMillis();\n+        long endMillis = interval.getEndMillis();\n+        Chronology chrono = interval.getChronology();\n+        super.setInterval(startMillis, endMillis, chrono);\n+    }\n+\n+    /**\n+     * Sets this interval from two instants, replacing the chronology with\n+     * that from the start instant.\n+     *\n+     * @param start  the start of the time interval\n+     * @param end  the start of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setInterval(ReadableInstant start, ReadableInstant end) {\n+        if (start == null && end == null) {\n+            long now = DateTimeUtils.currentTimeMillis();\n+            setInterval(now, now);\n+        } else {\n+            long startMillis = DateTimeUtils.getInstantMillis(start);\n+            long endMillis = DateTimeUtils.getInstantMillis(end);\n+            Chronology chrono = DateTimeUtils.getInstantChronology(start);\n+            super.setInterval(startMillis, endMillis, chrono);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the chronology of this time interval.\n+     *\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    public void setChronology(Chronology chrono) {\n+        super.setInterval(getStartMillis(), getEndMillis(), chrono);\n+    }\n+\n+    /**\n+     * Sets the start of this time interval.\n+     *\n+     * @param startInstant  the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setStartMillis(long startInstant) {\n+        super.setInterval(startInstant, getEndMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Sets the start of this time interval as an Instant.\n+     *\n+     * @param start  the start of the time interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setStart(ReadableInstant start) {\n+        long startMillis = DateTimeUtils.getInstantMillis(start);\n+        super.setInterval(startMillis, getEndMillis(), getChronology());\n+    }\n+\n+    /** \n+     * Sets the end of this time interval.\n+     *\n+     * @param endInstant  the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setEndMillis(long endInstant) {\n+        super.setInterval(getStartMillis(), endInstant, getChronology());\n+    }\n+\n+    /** \n+     * Sets the end of this time interval as an Instant.\n+     *\n+     * @param end  the end of the time interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    public void setEnd(ReadableInstant end) {\n+        long endMillis = DateTimeUtils.getInstantMillis(end);\n+        super.setInterval(getStartMillis(), endMillis, getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the duration of this time interval, preserving the start instant.\n+     *\n+     * @param duration  new duration for interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public void setDurationAfterStart(long duration) {\n+        setEndMillis(FieldUtils.safeAdd(getStartMillis(), duration));\n+    }\n+\n+    /**\n+     * Sets the duration of this time interval, preserving the end instant.\n+     *\n+     * @param duration  new duration for interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public void setDurationBeforeEnd(long duration) {\n+        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -duration));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the duration of this time interval, preserving the start instant.\n+     *\n+     * @param duration  new duration for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public void setDurationAfterStart(ReadableDuration duration) {\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        setEndMillis(FieldUtils.safeAdd(getStartMillis(), durationMillis));\n+    }\n+\n+    /**\n+     * Sets the duration of this time interval, preserving the end instant.\n+     *\n+     * @param duration  new duration for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public void setDurationBeforeEnd(ReadableDuration duration) {\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        setStartMillis(FieldUtils.safeAdd(getEndMillis(), -durationMillis));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the period of this time interval, preserving the start instant\n+     * and using the ISOChronology in the default zone for calculations.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public void setPeriodAfterStart(ReadablePeriod period) {\n+        if (period == null) {\n+            setEndMillis(getStartMillis());\n+        } else {\n+            setEndMillis(getChronology().add(period, getStartMillis(), 1));\n+        }\n+    }\n+\n+    /**\n+     * Sets the period of this time interval, preserving the end instant\n+     * and using the ISOChronology in the default zone for calculations.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public void setPeriodBeforeEnd(ReadablePeriod period) {\n+        if (period == null) {\n+            setStartMillis(getEndMillis());\n+        } else {\n+            setStartMillis(getChronology().add(period, getEndMillis(), -1));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutableInterval copy() {\n+        return (MutableInterval) clone();\n+    }\n+\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/MutablePeriod.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.base.BasePeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+\n+/**\n+ * Standard mutable time period implementation.\n+ * <p>\n+ * A time period is divided into a number of fields, such as hours and seconds.\n+ * Which fields are supported is defined by the PeriodType class.\n+ * The default is the standard period type, which supports years, months, weeks, days,\n+ * hours, minutes, seconds and millis.\n+ * <p>\n+ * When this time period is added to an instant, the effect is of adding each field in turn.\n+ * As a result, this takes into account daylight savings time.\n+ * Adding a time period of 1 day to the day before daylight savings starts will only add\n+ * 23 hours rather than 24 to ensure that the time remains the same.\n+ * If this is not the behaviour you want, then see {@link Duration}.\n+ * <p>\n+ * The definition of a period also affects the equals method. A period of 1\n+ * day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes.\n+ * This is because periods represent an abstracted definition of a time period\n+ * (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight\n+ * savings boundary). To compare the actual duration of two periods, convert\n+ * both to durations using toDuration, an operation that emphasises that the\n+ * result may differ according to the date you choose.\n+ * <p>\n+ * MutablePeriod is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see Period\n+ */\n+public class MutablePeriod\n+        extends BasePeriod\n+        implements ReadWritablePeriod, Cloneable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3436451121567212165L;\n+\n+    /**\n+     * Creates a zero-length period using the standard period type.\n+     */\n+    public MutablePeriod() {\n+        super(0L, null, null);\n+    }\n+\n+    /**\n+     * Creates a zero-length period using the specified period type.\n+     *\n+     * @param type  which set of fields this period supports\n+     */\n+    public MutablePeriod(PeriodType type) {\n+        super(0L, type, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using the standard set of fields.\n+     *\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public MutablePeriod(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using the standard set of fields.\n+     *\n+     * @param years  amount of years in this period\n+     * @param months  amount of months in this period\n+     * @param weeks  amount of weeks in this period\n+     * @param days  amount of days in this period\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public MutablePeriod(int years, int months, int weeks, int days,\n+                  int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports, null means AllType\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration using the standard\n+     * set of fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * For the standard period type this is the time fields only.\n+     * Thus the year, month, week and day fields will not be populated.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available precise field, hours in this case.\n+     * <p>\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you have two options:\n+     * <ul>\n+     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n+     * <li>specify a period type that contains precise definitions of the day and larger\n+     * fields, such as the UTC or precise types.\n+     * </ul>\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public MutablePeriod(long duration) {\n+        super(duration, null, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public MutablePeriod(long duration, PeriodType type) {\n+        super(duration, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration using the standard\n+     * set of fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param chronology  the chronology to use to split the duration, null means ISO default\n+     */\n+    public MutablePeriod(long duration, Chronology chronology) {\n+        super(duration, null, chronology);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chronology  the chronology to use to split the duration, null means ISO default\n+     */\n+    public MutablePeriod(long duration, PeriodType type, Chronology chronology) {\n+        super(duration, type, chronology);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public MutablePeriod(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public MutablePeriod(long startInstant, long endInstant, PeriodType type) {\n+        super(startInstant, endInstant, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     */\n+    public MutablePeriod(long startInstant, long endInstant, Chronology chrono) {\n+        super(startInstant, endInstant, null, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     */\n+    public MutablePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n+        super(startInstant, endInstant, type, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n+     * <p>\n+     * The chronology of the start instant is used, unless that is null when the\n+     * chronology of the end instant is used instead.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     * <p>\n+     * The chronology of the start instant is used, unless that is null when the\n+     * chronology of the end instant is used instead.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports, null means AllType\n+     */\n+    public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given start point and the duration.\n+     *\n+     * @param startInstant  the interval start, null means now\n+     * @param duration  the duration of the interval, null means zero-length\n+     */\n+    public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration) {\n+        super(startInstant, duration, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given start point and the duration.\n+     *\n+     * @param startInstant  the interval start, null means now\n+     * @param duration  the duration of the interval, null means zero-length\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n+        super(startInstant, duration, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given duration and end point.\n+     *\n+     * @param duration  the duration of the interval, null means zero-length\n+     * @param endInstant  the interval end, null means now\n+     */\n+    public MutablePeriod(ReadableDuration duration, ReadableInstant endInstant) {\n+        super(duration, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given duration and end point.\n+     *\n+     * @param duration  the duration of the interval, null means zero-length\n+     * @param endInstant  the interval end, null means now\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public MutablePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n+        super(duration, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePeriod, ReadableInterval and String.\n+     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n+     *\n+     * @param period  period to convert\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(Object period) {\n+        super(period, null, null);\n+    }\n+\n+    /**\n+     * Creates a period by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePeriod, ReadableInterval and String.\n+     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(Object period, PeriodType type) {\n+        super(period, type, null);\n+    }\n+\n+    /**\n+     * Creates a period by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePeriod, ReadableInterval and String.\n+     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n+     *\n+     * @param period  period to convert\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(Object period, Chronology chrono) {\n+        super(period, null, chrono);\n+    }\n+\n+    /**\n+     * Creates a period by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePeriod, ReadableInterval and String.\n+     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(Object period, PeriodType type, Chronology chrono) {\n+        super(period, type, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clears the period, setting all values back to zero.\n+     */\n+    public void clear() {\n+        super.setValues(new int[size()]);\n+    }\n+\n+    /**\n+     * Sets the value of one of the fields by index.\n+     *\n+     * @param index  the field index\n+     * @param value  the new value for the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public void setValue(int index, int value) {\n+        super.setValue(index, value);\n+    }\n+\n+    /**\n+     * Sets the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the period.\n+     *\n+     * @param field  a DurationFieldType instance that is supported by this period, not null\n+     * @param value  the new value for the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public void set(DurationFieldType field, int value) {\n+        super.setField(field, value);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from another ReadablePeriod.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public void setPeriod(ReadablePeriod period) {\n+        super.setPeriod(period);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public void setPeriod(int years, int months, int weeks, int days,\n+                          int hours, int minutes, int seconds, int millis) {\n+        super.setPeriod(years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from an interval using the ISO chronology\n+     * and dividing the fields using the period type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    public void setPeriod(ReadableInterval interval) {\n+        if (interval == null) {\n+            setPeriod(0L);\n+        } else {\n+            Chronology chrono = DateTimeUtils.getChronology(interval.getChronology());\n+            setPeriod(interval.getStartMillis(), interval.getEndMillis(), chrono);\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from two instants representing an interval.\n+     * <p>\n+     * The chronology of the start instant is used, unless that is null when the\n+     * chronology of the end instant is used instead.\n+     * \n+     * @param start  the start instant, null means now\n+     * @param end  the end instant, null means now\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    public void setPeriod(ReadableInstant start, ReadableInstant end) {\n+        if (start == end) {\n+            setPeriod(0L);\n+        } else {\n+            long startMillis = DateTimeUtils.getInstantMillis(start);\n+            long endMillis = DateTimeUtils.getInstantMillis(end);\n+            Chronology chrono = DateTimeUtils.getIntervalChronology(start, end);\n+            setPeriod(startMillis, endMillis, chrono);\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval using ISOChronology\n+     * and dividing the fields using the period type.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    public void setPeriod(long startInstant, long endInstant) {\n+        setPeriod(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param chrono  the chronology to use, not null\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    public void setPeriod(long startInstant, long endInstant, Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        setValues(chrono.get(this, startInstant, endInstant));\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    public void setPeriod(ReadableDuration duration) {\n+        setPeriod(duration, null);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n+     * \n+     * @param duration  the duration to set, null means zero length\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    public void setPeriod(ReadableDuration duration, Chronology chrono) {\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        setPeriod(durationMillis, chrono);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    public void setPeriod(long duration) {\n+        setPeriod(duration, null);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration.\n+     * <p>\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @param chrono  the chronology to use, not null\n+     * @throws ArithmeticException if the set exceeds the capacity of the period\n+     */\n+    public void setPeriod(long duration, Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        setValues(chrono.get(this, duration));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds to the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the period.\n+     *\n+     * @param field  a DurationFieldType instance that is supported by this period, not null\n+     * @param value  the value to add to the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public void add(DurationFieldType field, int value) {\n+        super.addField(field, value);\n+    }\n+\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadablePeriod period) {\n+        super.addPeriod(period);\n+    }\n+\n+    /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(int years, int months, int weeks, int days,\n+                       int hours, int minutes, int seconds, int millis) {\n+        setPeriod(\n+            FieldUtils.safeAdd(getYears(), years),\n+            FieldUtils.safeAdd(getMonths(), months),\n+            FieldUtils.safeAdd(getWeeks(), weeks),\n+            FieldUtils.safeAdd(getDays(), days),\n+            FieldUtils.safeAdd(getHours(), hours),\n+            FieldUtils.safeAdd(getMinutes(), minutes),\n+            FieldUtils.safeAdd(getSeconds(), seconds),\n+            FieldUtils.safeAdd(getMillis(), millis)\n+        );\n+    }\n+\n+    /**\n+     * Adds an interval to this one by dividing the interval into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadableInterval interval) {\n+        if (interval != null) {\n+            add(interval.toPeriod(getPeriodType()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * \n+     * @param duration  the duration to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(ReadableDuration duration) {\n+        if (duration != null) {\n+            add(new Period(duration.getMillis(), getPeriodType()));\n+        }\n+    }\n+\n+    /**\n+     * Adds a millisecond duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * <p>\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(long duration) {\n+        add(new Period(duration, getPeriodType()));\n+    }\n+\n+    /**\n+     * Adds a millisecond duration to this one by dividing the duration into\n+     * fields and calling {@link #add(ReadablePeriod)}.\n+     * <p>\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void add(long duration, Chronology chrono) {\n+        add(new Period(duration, getPeriodType(), chrono));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Merges all the fields from the specified period into this one.\n+     * <p>\n+     * Fields that are not present in the specified period are left unaltered.\n+     * \n+     * @param period  the period to set, null ignored\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public void mergePeriod(ReadablePeriod period) {\n+        super.mergePeriod(period);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    public int getYears() {\n+        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n+    }\n+\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    public int getMonths() {\n+        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n+    }\n+\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    public int getWeeks() {\n+        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n+    }\n+\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    public int getDays() {\n+        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    public int getHours() {\n+        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n+    }\n+\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    public int getMinutes() {\n+        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n+    }\n+\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    public int getSeconds() {\n+        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n+    }\n+\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    public int getMillis() {\n+        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    public void setYears(int years) {\n+        super.setField(DurationFieldType.years(), years);\n+    }\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addYears(int years) {\n+        super.addField(DurationFieldType.years(), years);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    public void setMonths(int months) {\n+        super.setField(DurationFieldType.months(), months);\n+    }\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMonths(int months) {\n+        super.addField(DurationFieldType.months(), months);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    public void setWeeks(int weeks) {\n+        super.setField(DurationFieldType.weeks(), weeks);\n+    }\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addWeeks(int weeks) {\n+        super.addField(DurationFieldType.weeks(), weeks);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    public void setDays(int days) {\n+        super.setField(DurationFieldType.days(), days);\n+    }\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addDays(int days) {\n+        super.addField(DurationFieldType.days(), days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    public void setHours(int hours) {\n+        super.setField(DurationFieldType.hours(), hours);\n+    }\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addHours(int hours) {\n+        super.addField(DurationFieldType.hours(), hours);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    public void setMinutes(int minutes) {\n+        super.setField(DurationFieldType.minutes(), minutes);\n+    }\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMinutes(int minutes) {\n+        super.addField(DurationFieldType.minutes(), minutes);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    public void setSeconds(int seconds) {\n+        super.setField(DurationFieldType.seconds(), seconds);\n+    }\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addSeconds(int seconds) {\n+        super.addField(DurationFieldType.seconds(), seconds);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    public void setMillis(int millis) {\n+        super.setField(DurationFieldType.millis(), millis);\n+    }\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    public void addMillis(int millis) {\n+        super.addField(DurationFieldType.millis(), millis);\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutablePeriod copy() {\n+        return (MutablePeriod) clone();\n+    }\n+\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Partial.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.joda.time.base.AbstractPartial;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Partial is an immutable partial datetime supporting any set of datetime fields.\n+ * <p>\n+ * A Partial instance can be used to hold any combination of fields.\n+ * The instance does not contain a time zone, so any datetime is local.\n+ * <p>\n+ * A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}.\n+ * This method compares each field on this partial with those of the instant\n+ * and determines if the partial matches the instant.\n+ * Given this definition, an empty Partial instance represents any datetime\n+ * and always matches.\n+ * <p>\n+ * Calculations on Partial are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>get(DateTimeFieldType.monthOfYear())</code>\n+ * <li><code>property(DateTimeFieldType.monthOfYear()).get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * Partial is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.1\n+ */\n+public final class Partial\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 12324121189002L;\n+\n+    /** The chronology in use. */\n+    private final Chronology iChronology;\n+    /** The set of field types. */\n+    private final DateTimeFieldType[] iTypes;\n+    /** The values of each field in this partial. */\n+    private final int[] iValues;\n+    /** The formatter to use, [0] may miss some fields, [1] doesn't miss any fields. */\n+    private transient DateTimeFormatter[] iFormatter;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a Partial with no fields or values, which can be considered\n+     * to represent any date.\n+     * <p>\n+     * This is most useful when constructing partials, for example:\n+     * <pre>\n+     * Partial p = new Partial()\n+     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n+     *     .with(DateTimeFieldType.hourOfDay(), 12)\n+     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n+     * </pre>\n+     * Note that, although this is a clean way to write code, it is fairly\n+     * inefficient internally.\n+     * <p>\n+     * The constructor uses the default ISO chronology.\n+     */\n+    public Partial() {\n+        this((Chronology) null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with no fields or values, which can be considered\n+     * to represent any date.\n+     * <p>\n+     * This is most useful when constructing partials, for example:\n+     * <pre>\n+     * Partial p = new Partial(chrono)\n+     *     .with(DateTimeFieldType.dayOfWeek(), 5)\n+     *     .with(DateTimeFieldType.hourOfDay(), 12)\n+     *     .with(DateTimeFieldType.minuteOfHour(), 20);\n+     * </pre>\n+     * Note that, although this is a clean way to write code, it is fairly\n+     * inefficient internally.\n+     *\n+     * @param chrono  the chronology, null means ISO\n+     */\n+    public Partial(Chronology chrono) {\n+        super();\n+        iChronology = DateTimeUtils.getChronology(chrono).withUTC();\n+        iTypes = new DateTimeFieldType[0];\n+        iValues = new int[0];\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified field and value.\n+     * <p>\n+     * The constructor uses the default ISO chronology.\n+     * \n+     * @param type  the single type to create the partial from, not null\n+     * @param value  the value to store\n+     * @throws IllegalArgumentException if the type or value is invalid\n+     */\n+    public Partial(DateTimeFieldType type, int value) {\n+        this(type, value, null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified field and value.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param type  the single type to create the partial from, not null\n+     * @param value  the value to store\n+     * @param chronology  the chronology, null means ISO\n+     * @throws IllegalArgumentException if the type or value is invalid\n+     */\n+    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        iChronology = chronology;\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The field type must not be null\");\n+        }\n+        iTypes = new DateTimeFieldType[] {type};\n+        iValues = new int[] {value};\n+        chronology.validate(this, iValues);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified fields and values.\n+     * The fields must be specified in the order largest to smallest.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param types  the types to create the partial from, not null\n+     * @param values  the values to store, not null\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    public Partial(DateTimeFieldType[] types, int[] values) {\n+        this(types, values, null);\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified fields and values.\n+     * The fields must be specified in the order largest to smallest.\n+     * <p>\n+     * The constructor uses the specified chronology.\n+     * \n+     * @param types  the types to create the partial from, not null\n+     * @param values  the values to store, not null\n+     * @param chronology  the chronology, null means ISO\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n+        iChronology = chronology;\n+        if (types == null) {\n+            throw new IllegalArgumentException(\"Types array must not be null\");\n+        }\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"Values array must not be null\");\n+        }\n+        if (values.length != types.length) {\n+            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n+        }\n+        if (types.length == 0) {\n+            iTypes = types;\n+            iValues = values;\n+            return;\n+        }\n+        for (int i = 0; i < types.length; i++) {\n+            if (types[i] == null) {\n+                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n+            }\n+        }\n+        DurationField lastUnitField = null;\n+        for (int i = 0; i < types.length; i++) {\n+            DateTimeFieldType loopType = types[i];\n+            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n+            if (i > 0) {\n+                int compare = lastUnitField.compareTo(loopUnitField);\n+                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n+                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                            types[i - 1].getName() + \" < \" + loopType.getName());\n+                } else if (compare == 0) {\n+                    if (types[i - 1].getRangeDurationType() == null) {\n+                        if (loopType.getRangeDurationType() == null) {\n+                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n+                        }\n+                    } else {\n+                        if (loopType.getRangeDurationType() == null) {\n+                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                    types[i - 1].getName() + \" < \" + loopType.getName());\n+                        }\n+                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n+                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n+                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n+                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                    types[i - 1].getName() + \" < \" + loopType.getName());\n+                        }\n+                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n+                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n+                        }\n+                    }\n+                }\n+            }\n+            lastUnitField = loopUnitField;\n+        }\n+        \n+        iTypes = (DateTimeFieldType[]) types.clone();\n+        chronology.validate(this, values);\n+        iValues = (int[]) values.clone();\n+    }\n+\n+    /**\n+     * Constructs a Partial by copying all the fields and types from\n+     * another partial.\n+     * <p>\n+     * This is most useful when copying from a YearMonthDay or TimeOfDay.\n+     */\n+    public Partial(ReadablePartial partial) {\n+        super();\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        iChronology = DateTimeUtils.getChronology(partial.getChronology()).withUTC();\n+        iTypes = new DateTimeFieldType[partial.size()];\n+        iValues = new int[partial.size()];\n+        for (int i = 0; i < partial.size(); i++) {\n+            iTypes[i] = partial.getFieldType(i);\n+            iValues[i] = partial.getValue(i);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified values.\n+     * This constructor assigns and performs no validation.\n+     * \n+     * @param partial  the partial to copy\n+     * @param values  the values to store\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    Partial(Partial partial, int[] values) {\n+        super();\n+        iChronology = partial.iChronology;\n+        iTypes = partial.iTypes;\n+        iValues = values;\n+    }\n+\n+    /**\n+     * Constructs a Partial with the specified chronology, fields and values.\n+     * This constructor assigns and performs no validation.\n+     * \n+     * @param chronology  the chronology\n+     * @param types  the types to create the partial from\n+     * @param values  the values to store\n+     * @throws IllegalArgumentException if the types or values are invalid\n+     */\n+    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n+        super();\n+        iChronology = chronology;\n+        iTypes = types;\n+        iValues = values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int size() {\n+        return iTypes.length;\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        return iTypes[index].getField(chrono);\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return iTypes[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that\n+     * this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest.\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) iTypes.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        return iValues[index];\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that\n+     * this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest.\n+     * Each value corresponds to the same array index as <code>getFieldTypes()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new Partial instance with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as Partial\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public Partial withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            Partial newPartial = new Partial(newChronology, iTypes, iValues);\n+            newChronology.validate(newPartial, iValues);\n+            return newPartial;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this date with the specified field set to a new value.\n+     * <p>\n+     * If this partial did not previously support the field, the new one will.\n+     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed/added in the returned instance.\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public Partial with(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"The field type must not be null\");\n+        }\n+        int index = indexOf(fieldType);\n+        if (index == -1) {\n+            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n+            int[] newValues = new int[newTypes.length];\n+            \n+            // find correct insertion point to keep largest-smallest order\n+            int i = 0;\n+            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n+            if (unitField.isSupported()) {\n+                for (; i < iTypes.length; i++) {\n+                    DateTimeFieldType loopType = iTypes[i];\n+                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n+                    if (loopUnitField.isSupported()) {\n+                        int compare = unitField.compareTo(loopUnitField);\n+                        if (compare > 0) {\n+                            break;\n+                        } else if (compare == 0) {\n+                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n+                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n+                            if (rangeField.compareTo(loopRangeField) > 0) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            System.arraycopy(iTypes, 0, newTypes, 0, i);\n+            System.arraycopy(iValues, 0, newValues, 0, i);\n+            newTypes[i] = fieldType;\n+            newValues[i] = value;\n+            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n+            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n+            \n+            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            iChronology.validate(newPartial, newValues);\n+            return newPartial;\n+        }\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified field removed.\n+     * <p>\n+     * If this partial did not previously support the field, no error occurs.\n+     *\n+     * @param fieldType  the field type to remove, may be null\n+     * @return a copy of this instance with the field removed\n+     */\n+    public Partial without(DateTimeFieldType fieldType) {\n+        int index = indexOf(fieldType);\n+        if (index != -1) {\n+            DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n+            int[] newValues = new int[size() - 1];\n+            System.arraycopy(iTypes, 0, newTypes, 0, index);\n+            System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n+            System.arraycopy(iValues, 0, newValues, 0, index);\n+            System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n+            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            iChronology.validate(newPartial, newValues);\n+            return newPartial;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this Partial with the specified field set to a new value.\n+     * <p>\n+     * If this partial does not support the field, an exception is thrown.\n+     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed in the returned instance if supported.\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public Partial withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the value of the specified field increased.\n+     * If this partial does not support the field, an exception is thrown.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * The addition will overflow into larger fields (eg. minute to hour).\n+     * However, it will not wrap around if the top maximum is reached.\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the value of the specified field increased.\n+     * If this partial does not support the field, an exception is thrown.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * The addition will overflow into larger fields (eg. minute to hour).\n+     * If the maximum is reached, the addition will wra.\n+     *\n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this Partial with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using the method\n+     * {@link #withFieldAdded(DurationFieldType, int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new Partial(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     *\n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public Partial plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     *\n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public Partial minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods for getting and manipulating the partial.\n+     * <p>\n+     * See also {@link ReadablePartial#get(DateTimeFieldType)}.\n+     *\n+     * @param type  the field type to get the property for, not null\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this partial match the specified instant.\n+     * <p>\n+     * A match occurs when all the fields of this partial are the same as the\n+     * corresponding fields on the specified instant.\n+     *\n+     * @param instant  an instant to check against, null means now in default zone\n+     * @return true if this partial matches the specified instant\n+     */\n+    public boolean isMatch(ReadableInstant instant) {\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        for (int i = 0; i < iTypes.length; i++) {\n+            int value = iTypes[i].getField(chrono).get(millis);\n+            if (value != iValues[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Does this partial match the specified partial.\n+     * <p>\n+     * A match occurs when all the fields of this partial are the same as the\n+     * corresponding fields on the specified partial.\n+     *\n+     * @param partial  a partial to check against, must not be null\n+     * @return true if this partial matches the specified partial\n+     * @throws IllegalArgumentException if the partial is null\n+     * @throws IllegalArgumentException if the fields of the two partials do not match\n+     * @since 1.5\n+     */\n+    public boolean isMatch(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        for (int i = 0; i < iTypes.length; i++) {\n+            int value = partial.get(iTypes[i]);\n+            if (value != iValues[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a formatter suitable for the fields in this partial.\n+     * <p>\n+     * If there is no appropriate ISO format, null is returned.\n+     * This method may return a formatter that does not display all the\n+     * fields of the partial. This might occur when you have overlapping\n+     * fields, such as dayOfWeek and dayOfMonth.\n+     *\n+     * @return a formatter suitable for the fields in this partial, null\n+     *  if none is suitable\n+     */\n+    public DateTimeFormatter getFormatter() {\n+        DateTimeFormatter[] f = iFormatter;\n+        if (f == null) {\n+            if (size() == 0) {\n+                return null;\n+            }\n+            f = new DateTimeFormatter[2];\n+            try {\n+                List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n+                f[0] = ISODateTimeFormat.forFields(list, true, false);\n+                if (list.size() == 0) {\n+                    f[1] = f[0];\n+                }\n+            } catch (IllegalArgumentException ex) {\n+                // ignore\n+            }\n+            iFormatter = f;\n+        }\n+        return f[0];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date in an appropriate ISO8601 format.\n+     * <p>\n+     * This method will output the partial in one of two ways.\n+     * If {@link #getFormatter()}\n+     * <p>\n+     * If there is no appropriate ISO format a dump of the fields is output\n+     * via {@link #toStringList()}.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        DateTimeFormatter[] f = iFormatter;\n+        if (f == null) {\n+            getFormatter();\n+            f = iFormatter;\n+            if (f == null) {\n+                return toStringList();\n+            }\n+        }\n+        DateTimeFormatter f1 = f[1];\n+        if (f1 == null) {\n+            return toStringList();\n+        }\n+        return f1.print(this);\n+    }\n+\n+    /**\n+     * Gets a string version of the partial that lists all the fields.\n+     * <p>\n+     * This method exists to provide a better debugging toString than\n+     * the standard toString. This method lists all the fields and their\n+     * values in a style similar to the collections framework.\n+     *\n+     * @return a toString format that lists all the fields\n+     */\n+    public String toStringList() {\n+        int size = size();\n+        StringBuffer buf = new StringBuffer(20 * size);\n+        buf.append('[');\n+        for (int i = 0; i < size; i++) {\n+            if (i > 0) {\n+                buf.append(',').append(' ');\n+            }\n+            buf.append(iTypes[i].getName());\n+            buf.append('=');\n+            buf.append(iValues[i]);\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     * Unsupported fields will appear as special unicode characters.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     * Unsupported fields will appear as special unicode characters.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>Partial</code>.\n+     * <p>\n+     * This class binds a <code>Partial</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.1\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 53278362873888L;\n+\n+        /** The partial */\n+        private final Partial iPartial;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(Partial partial, int fieldIndex) {\n+            super();\n+            iPartial = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iPartial.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iPartial;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public Partial getPartial() {\n+            return iPartial;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iPartial.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this Partial.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial addToCopy(int valueToAdd) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this Partial wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the Partial.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public Partial setCopy(int value) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().set(iPartial, iFieldIndex, newValues, value);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the Partial to a parsed text value.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public Partial setCopy(String text, Locale locale) {\n+            int[] newValues = iPartial.getValues();\n+            newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n+            return new Partial(iPartial, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the Partial to a parsed text value.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the Partial with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public Partial setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new Partial with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the Partial with this field set to its maximum\n+         * @since 1.2\n+         */\n+        public Partial withMaximumValue() {\n+            return setCopy(getMaximumValue());\n+        }\n+\n+        /**\n+         * Returns a new Partial with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The Partial attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the Partial with this field set to its minimum\n+         * @since 1.2\n+         */\n+        public Partial withMinimumValue() {\n+            return setCopy(getMinimumValue());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Period.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.base.BasePeriod;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+\n+/**\n+ * An immutable time period specifying a set of duration field values.\n+ * <p>\n+ * A time period is divided into a number of fields, such as hours and seconds.\n+ * Which fields are supported is defined by the PeriodType class.\n+ * The default is the standard period type, which supports years, months, weeks, days,\n+ * hours, minutes, seconds and millis.\n+ * <p>\n+ * When this time period is added to an instant, the effect is of adding each field in turn.\n+ * As a result, this takes into account daylight savings time.\n+ * Adding a time period of 1 day to the day before daylight savings starts will only add\n+ * 23 hours rather than 24 to ensure that the time remains the same.\n+ * If this is not the behaviour you want, then see {@link Duration}.\n+ * <p>\n+ * The definition of a period also affects the equals method. A period of 1\n+ * day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes.\n+ * This is because periods represent an abstracted definition of a time period\n+ * (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight\n+ * savings boundary). To compare the actual duration of two periods, convert\n+ * both to durations using toDuration, an operation that emphasises that the\n+ * result may differ according to the date you choose.\n+ * <p>\n+ * Period is thread-safe and immutable, provided that the PeriodType is as well.\n+ * All standard PeriodType classes supplied are thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see MutablePeriod\n+ */\n+public final class Period\n+        extends BasePeriod\n+        implements ReadablePeriod, Serializable {\n+\n+    /**\n+     * A period of zero length and standard period type.\n+     * @since 1.4\n+     */\n+    public static final Period ZERO = new Period();\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 741052353876488155L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create a period with a specified number of years.\n+     * <p>\n+     * The standard period type is used, thus you can add other fields such\n+     * as months or days using the <code>withXxx()</code> methods.\n+     * For example, <code>Period.years(2).withMonths(6);</code>\n+     * <p>\n+     * If you want a year-based period that cannot have other fields added,\n+     * then you should consider using {@link Years}.\n+     *\n+     * @param years  the amount of years in this period\n+     * @return the period\n+     */\n+    public static Period years(int years) {\n+        return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period with a specified number of months.\n+     * <p>\n+     * The standard period type is used, thus you can add other fields such\n+     * as years or days using the <code>withXxx()</code> methods.\n+     * For example, <code>Period.months(2).withDays(6);</code>\n+     * <p>\n+     * If you want a month-based period that cannot have other fields added,\n+     * then you should consider using {@link Months}.\n+     *\n+     * @param months  the amount of months in this period\n+     * @return the period\n+     */\n+    public static Period months(int months) {\n+        return new Period(new int[] {0, months, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period with a specified number of weeks.\n+     * <p>\n+     * The standard period type is used, thus you can add other fields such\n+     * as months or days using the <code>withXxx()</code> methods.\n+     * For example, <code>Period.weeks(2).withDays(6);</code>\n+     * <p>\n+     * If you want a week-based period that cannot have other fields added,\n+     * then you should consider using {@link Weeks}.\n+     *\n+     * @param weeks  the amount of weeks in this period\n+     * @return the period\n+     */\n+    public static Period weeks(int weeks) {\n+        return new Period(new int[] {0, 0, weeks, 0, 0, 0, 0, 0}, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period with a specified number of days.\n+     * <p>\n+     * The standard period type is used, thus you can add other fields such\n+     * as months or weeks using the <code>withXxx()</code> methods.\n+     * For example, <code>Period.days(2).withHours(6);</code>\n+     * <p>\n+     * If you want a day-based period that cannot have other fields added,\n+     * then you should consider using {@link Days}.\n+     *\n+     * @param days  the amount of days in this period\n+     * @return the period\n+     */\n+    public static Period days(int days) {\n+        return new Period(new int[] {0, 0, 0, days, 0, 0, 0, 0}, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period with a specified number of hours.\n+     * <p>\n+     * The standard period type is used, thus you can add other fields such\n+     * as months or days using the <code>withXxx()</code> methods.\n+     * For example, <code>Period.hours(2).withMinutes(30);</code>\n+     * <p>\n+     * If you want a hour-based period that cannot have other fields added,\n+     * then you should consider using {@link Hours}.\n+     *\n+     * @param hours  the amount of hours in this period\n+     * @return the period\n+     */\n+    public static Period hours(int hours) {\n+        return new Period(new int[] {0, 0, 0, 0, hours, 0, 0, 0}, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period with a specified number of minutes.\n+     * <p>\n+     * The standard period type is used, thus you can add other fields such\n+     * as days or hours using the <code>withXxx()</code> methods.\n+     * For example, <code>Period.minutes(2).withSeconds(30);</code>\n+     * <p>\n+     * If you want a minute-based period that cannot have other fields added,\n+     * then you should consider using {@link Minutes}.\n+     *\n+     * @param minutes  the amount of minutes in this period\n+     * @return the period\n+     */\n+    public static Period minutes(int minutes) {\n+        return new Period(new int[] {0, 0, 0, 0, 0, minutes, 0, 0}, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period with a specified number of seconds.\n+     * <p>\n+     * The standard period type is used, thus you can add other fields such\n+     * as days or hours using the <code>withXxx()</code> methods.\n+     * For example, <code>Period.seconds(2).withMillis(30);</code>\n+     * <p>\n+     * If you want a second-based period that cannot have other fields added,\n+     * then you should consider using {@link Seconds}.\n+     *\n+     * @param seconds  the amount of seconds in this period\n+     * @return the period\n+     */\n+    public static Period seconds(int seconds) {\n+        return new Period(new int[] {0, 0, 0, 0, 0, 0, seconds, 0}, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period with a specified number of millis.\n+     * <p>\n+     * The standard period type is used, thus you can add other fields such\n+     * as days or hours using the <code>withXxx()</code> methods.\n+     * For example, <code>Period.millis(20).withSeconds(30);</code>\n+     *\n+     * @param millis  the amount of millis in this period\n+     * @return the period\n+     */\n+    public static Period millis(int millis) {\n+        return new Period(new int[] {0, 0, 0, 0, 0, 0, 0, millis}, PeriodType.standard());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a period from two partially specified times, calculating\n+     * by field difference.\n+     * <p>\n+     * The two partials must contain the same fields, thus you can specify\n+     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n+     * but not one of each. Also, the partial may not contain overlapping\n+     * fields, such as dayOfWeek and dayOfMonth.\n+     * <p>\n+     * Calculation by field difference works by extracting the difference\n+     * one field at a time and not wrapping into other fields.\n+     * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.\n+     * <p>\n+     * For example, you have an event that always runs from the 27th of\n+     * each month to the 2nd of the next month. If you calculate this\n+     * period using a standard constructor, then you will get between\n+     * P3D and P6D depending on the month. If you use this method, then\n+     * you will get P1M-25D. This field-difference based period can\n+     * be successfully applied to each month of the year to obtain the\n+     * correct end date for a given start date.\n+     *\n+     * @param start  the start of the period, must not be null\n+     * @param end  the end of the period, must not be null\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     * @since 1.1\n+     */\n+    public static Period fieldDifference(ReadablePartial start, ReadablePartial end) {\n+        if (start == null || end == null) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n+        }\n+        if (start.size() != end.size()) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+        }\n+        DurationFieldType[] types = new DurationFieldType[start.size()];\n+        int[] values = new int[start.size()];\n+        for (int i = 0, isize = start.size(); i < isize; i++) {\n+            if (start.getFieldType(i) != end.getFieldType(i)) {\n+                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+            }\n+            types[i] = start.getFieldType(i).getDurationType();\n+            if (i > 0 && types[i - 1] == types[i]) {\n+                throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\n+            }\n+            values[i] = end.getValue(i) - start.getValue(i);\n+        }\n+        return new Period(values, PeriodType.forFields(types));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new empty period with the standard set of fields.\n+     * <p>\n+     * One way to initialise a period is as follows:\n+     * <pre>\n+     * Period = new Period().withYears(6).withMonths(3).withSeconds(23);\n+     * </pre>\n+     * Bear in mind that this creates four period instances in total, three of\n+     * which are immediately discarded.\n+     * The alterative is more efficient, but less readable:\n+     * <pre>\n+     * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);\n+     * </pre>\n+     * The following is also slightly less wasteful:\n+     * <pre>\n+     * Period = Period.years(6).withMonths(3).withSeconds(23);\n+     * </pre>\n+     */\n+    public Period() {\n+        super(0L, null, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using the standard set of fields.\n+     * Note that the parameters specify the time fields hours, minutes,\n+     * seconds and millis, not the date fields.\n+     *\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public Period(int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using the standard set of fields.\n+     *\n+     * @param years  amount of years in this period\n+     * @param months  amount of months in this period\n+     * @param weeks  amount of weeks in this period\n+     * @param days  amount of days in this period\n+     * @param hours  amount of hours in this period\n+     * @param minutes  amount of minutes in this period\n+     * @param seconds  amount of seconds in this period\n+     * @param millis  amount of milliseconds in this period\n+     */\n+    public Period(int years, int months, int weeks, int days,\n+                  int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n+    }\n+\n+    /**\n+     * Create a period from a set of field values.\n+     * <p>\n+     * There is usually little need to use this constructor.\n+     * The period type is used primarily to define how to split an interval into a period.\n+     * As this constructor already is split, the period type does no real work.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports, null means AllType\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public Period(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration using the standard\n+     * set of fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * For the standard period type this is the time fields only.\n+     * Thus the year, month, week and day fields will not be populated.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available precise field, hours in this case.\n+     * <p>\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you have two options:\n+     * <ul>\n+     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n+     * <li>specify a period type that contains precise definitions of the day and larger\n+     * fields, such as UTC\n+     * </ul>\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public Period(long duration) {\n+        super(duration, null, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public Period(long duration, PeriodType type) {\n+        super(duration, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration using the standard\n+     * set of fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param chronology  the chronology to use to split the duration, null means ISO default\n+     */\n+    public Period(long duration, Chronology chronology) {\n+        super(duration, null, chronology);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chronology  the chronology to use to split the duration, null means ISO default\n+     */\n+    public Period(long duration, PeriodType type, Chronology chronology) {\n+        super(duration, type, chronology);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public Period(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public Period(long startInstant, long endInstant, PeriodType type) {\n+        super(startInstant, endInstant, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     */\n+    public Period(long startInstant, long endInstant, Chronology chrono) {\n+        super(startInstant, endInstant, null, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     */\n+    public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n+        super(startInstant, endInstant, type, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public Period(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period from two partially specified times.\n+     * <p>\n+     * The two partials must contain the same fields, thus you can specify\n+     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n+     * but not one of each.\n+     * As these are Partial objects, time zones have no effect on the result.\n+     * <p>\n+     * The two partials must also both be contiguous - see\n+     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.\n+     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n+     * <p>\n+     * An alternative way of constructing a Period from two Partials\n+     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.\n+     * That method handles all kinds of partials.\n+     *\n+     * @param start  the start of the period, must not be null\n+     * @param end  the end of the period, must not be null\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     * @since 1.1\n+     */\n+    public Period(ReadablePartial start, ReadablePartial end) {\n+        super(start, end, null);\n+    }\n+\n+    /**\n+     * Creates a period from two partially specified times.\n+     * <p>\n+     * The two partials must contain the same fields, thus you can specify\n+     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n+     * but not one of each.\n+     * As these are Partial objects, time zones have no effect on the result.\n+     * <p>\n+     * The two partials must also both be contiguous - see\n+     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.\n+     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n+     * <p>\n+     * An alternative way of constructing a Period from two Partials\n+     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.\n+     * That method handles all kinds of partials.\n+     *\n+     * @param start  the start of the period, must not be null\n+     * @param end  the end of the period, must not be null\n+     * @param type  which set of fields this period supports, null means standard\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     * @since 1.1\n+     */\n+    public Period(ReadablePartial start, ReadablePartial end, PeriodType type) {\n+        super(start, end, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given start point and the duration.\n+     *\n+     * @param startInstant  the interval start, null means now\n+     * @param duration  the duration of the interval, null means zero-length\n+     */\n+    public Period(ReadableInstant startInstant, ReadableDuration duration) {\n+        super(startInstant, duration, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given start point and the duration.\n+     *\n+     * @param startInstant  the interval start, null means now\n+     * @param duration  the duration of the interval, null means zero-length\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public Period(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n+        super(startInstant, duration, type);\n+    }\n+\n+    /**\n+     * Creates a period from the given duration and end point.\n+     *\n+     * @param duration  the duration of the interval, null means zero-length\n+     * @param endInstant  the interval end, null means now\n+     */\n+    public Period(ReadableDuration duration, ReadableInstant endInstant) {\n+        super(duration, endInstant, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given duration and end point.\n+     *\n+     * @param duration  the duration of the interval, null means zero-length\n+     * @param endInstant  the interval end, null means now\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n+        super(duration, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a period by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePeriod, ReadableInterval and String.\n+     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n+     *\n+     * @param period  period to convert\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Period(Object period) {\n+        super(period, null, null);\n+    }\n+\n+    /**\n+     * Creates a period by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePeriod, ReadableInterval and String.\n+     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Period(Object period, PeriodType type) {\n+        super(period, type, null);\n+    }\n+\n+    /**\n+     * Creates a period by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePeriod, ReadableInterval and String.\n+     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n+     *\n+     * @param period  period to convert\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Period(Object period, Chronology chrono) {\n+        super(period, null, chrono);\n+    }\n+\n+    /**\n+     * Creates a period by converting or copying from another object.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadablePeriod, ReadableInterval and String.\n+     * The String formats are described by {@link ISOPeriodFormat#standard()}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Period(Object period, PeriodType type, Chronology chrono) {\n+        super(period, type, chrono);\n+    }\n+\n+    /**\n+     * Constructor used when we trust ourselves.\n+     *\n+     * @param values  the values to use, not null, not cloned\n+     * @param type  which set of fields this period supports, not null\n+     */\n+    private Period(int[] values, PeriodType type) {\n+        super(values, type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this period as an immutable <code>Period</code> object\n+     * by returning <code>this</code>.\n+     * \n+     * @return <code>this</code>\n+     */\n+    public Period toPeriod() {\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    public int getYears() {\n+        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n+    }\n+\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    public int getMonths() {\n+        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n+    }\n+\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    public int getWeeks() {\n+        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n+    }\n+\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    public int getDays() {\n+        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    public int getHours() {\n+        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n+    }\n+\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    public int getMinutes() {\n+        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n+    }\n+\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    public int getSeconds() {\n+        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n+    }\n+\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    public int getMillis() {\n+        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new Period instance with the same field values but\n+     * different PeriodType.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     * \n+     * @param type  the period type to use, null means standard\n+     * @return the new period instance\n+     * @throws IllegalArgumentException if the new period won't accept all of the current fields\n+     */\n+    public Period withPeriodType(PeriodType type) {\n+        type = DateTimeUtils.getPeriodType(type);\n+        if (type.equals(getPeriodType())) {\n+            return this;\n+        }\n+        return new Period(this, type);\n+    }\n+\n+    /**\n+     * Creates a new Period instance with the fields from the specified period\n+     * copied on top of those from this period.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     * \n+     * @param period  the period to copy from, null ignored\n+     * @return the new period instance\n+     * @throws IllegalArgumentException if a field type is unsupported\n+     */\n+    public Period withFields(ReadablePeriod period) {\n+        if (period == null) {\n+            return this;\n+        }\n+        int[] newValues = getValues();  // cloned\n+        newValues = super.mergePeriodInto(newValues, period);\n+        return new Period(newValues, getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new Period instance with the specified field set to a new value.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     * \n+     * @param field  the field to set, not null\n+     * @param value  the value to set to\n+     * @return the new period instance\n+     * @throws IllegalArgumentException if the field type is null or unsupported\n+     */\n+    public Period withField(DurationFieldType field, int value) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        int[] newValues = getValues();  // cloned\n+        super.setFieldInto(newValues, field, value);\n+        return new Period(newValues, getPeriodType());\n+    }\n+\n+    /**\n+     * Creates a new Period instance with the valueToAdd added to the specified field.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     * \n+     * @param field  the field to set, not null\n+     * @param value  the value to add\n+     * @return the new period instance\n+     * @throws IllegalArgumentException if the field type is null or unsupported\n+     */\n+    public Period withFieldAdded(DurationFieldType field, int value) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Field must not be null\");\n+        }\n+        if (value == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();  // cloned\n+        super.addFieldInto(newValues, field, value);\n+        return new Period(newValues, getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new period with the specified number of years.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new period with the increased years\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period withYears(int years) {\n+        int[] values = getValues();  // cloned\n+        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period with the specified number of months.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new period with the increased months\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period withMonths(int months) {\n+        int[] values = getValues();  // cloned\n+        getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period with the specified number of weeks.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new period with the increased weeks\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period withWeeks(int weeks) {\n+        int[] values = getValues();  // cloned\n+        getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period with the specified number of days.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new period with the increased days\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period withDays(int days) {\n+        int[] values = getValues();  // cloned\n+        getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period with the specified number of hours.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new period with the increased hours\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period withHours(int hours) {\n+        int[] values = getValues();  // cloned\n+        getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period with the specified number of minutes.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new period with the increased minutes\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period withMinutes(int minutes) {\n+        int[] values = getValues();  // cloned\n+        getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period with the specified number of seconds.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new period with the increased seconds\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period withSeconds(int seconds) {\n+        int[] values = getValues();  // cloned\n+        getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period with the specified number of millis.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new period with the increased millis\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period withMillis(int millis) {\n+        int[] values = getValues();  // cloned\n+        getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new period with the specified period added.\n+     * <p>\n+     * Each field of the period is added separately. Thus a period of\n+     * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result\n+     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.\n+     * <p>\n+     * If the period being added contains a non-zero amount for a field that\n+     * is not supported in this period then an exception is thrown.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param period  the period to add, null adds zero and returns this\n+     * @return the new updated period\n+     * @throws UnsupportedOperationException if any field is not supported\n+     * @since 1.5\n+     */\n+    public Period plus(ReadablePeriod period) {\n+        if (period == null) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new period with the specified number of years added.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new period with the increased years\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period plusYears(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period plus the specified number of months added.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new period plus the increased months\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period plusMonths(int months) {\n+        if (months == 0) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period plus the specified number of weeks added.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new period plus the increased weeks\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period plusWeeks(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period plus the specified number of days added.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new period plus the increased days\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period plusDays(int days) {\n+        if (days == 0) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period plus the specified number of hours added.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new period plus the increased hours\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period plusHours(int hours) {\n+        if (hours == 0) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period plus the specified number of minutes added.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new period plus the increased minutes\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period plusMinutes(int minutes) {\n+        if (minutes == 0) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period plus the specified number of seconds added.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new period plus the increased seconds\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period plusSeconds(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    /**\n+     * Returns a new period plus the specified number of millis added.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new period plus the increased millis\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period plusMillis(int millis) {\n+        if (millis == 0) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new period with the specified period subtracted.\n+     * <p>\n+     * Each field of the period is subtracted separately. Thus a period of\n+     * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result\n+     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.\n+     * <p>\n+     * If the period being added contains a non-zero amount for a field that\n+     * is not supported in this period then an exception is thrown.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param period  the period to add, null adds zero and returns this\n+     * @return the new updated period\n+     * @throws UnsupportedOperationException if any field is not supported\n+     * @since 1.5\n+     */\n+    public Period minus(ReadablePeriod period) {\n+        if (period == null) {\n+            return this;\n+        }\n+        int[] values = getValues();  // cloned\n+        getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));\n+        getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));\n+        return new Period(values, getPeriodType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new period with the specified number of years taken away.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to take away, may be negative\n+     * @return the new period with the increased years\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period minusYears(int years) {\n+        return plusYears(-years);\n+    }\n+\n+    /**\n+     * Returns a new period minus the specified number of months taken away.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param months  the amount of months to take away, may be negative\n+     * @return the new period minus the increased months\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period minusMonths(int months) {\n+        return plusMonths(-months);\n+    }\n+\n+    /**\n+     * Returns a new period minus the specified number of weeks taken away.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to take away, may be negative\n+     * @return the new period minus the increased weeks\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period minusWeeks(int weeks) {\n+        return plusWeeks(-weeks);\n+    }\n+\n+    /**\n+     * Returns a new period minus the specified number of days taken away.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param days  the amount of days to take away, may be negative\n+     * @return the new period minus the increased days\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period minusDays(int days) {\n+        return plusDays(-days);\n+    }\n+\n+    /**\n+     * Returns a new period minus the specified number of hours taken away.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param hours  the amount of hours to take away, may be negative\n+     * @return the new period minus the increased hours\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period minusHours(int hours) {\n+        return plusHours(-hours);\n+    }\n+\n+    /**\n+     * Returns a new period minus the specified number of minutes taken away.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param minutes  the amount of minutes to take away, may be negative\n+     * @return the new period minus the increased minutes\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period minusMinutes(int minutes) {\n+        return plusMinutes(-minutes);\n+    }\n+\n+    /**\n+     * Returns a new period minus the specified number of seconds taken away.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to take away, may be negative\n+     * @return the new period minus the increased seconds\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period minusSeconds(int seconds) {\n+        return plusSeconds(-seconds);\n+    }\n+\n+    /**\n+     * Returns a new period minus the specified number of millis taken away.\n+     * <p>\n+     * This period instance is immutable and unaffected by this method call.\n+     *\n+     * @param millis  the amount of millis to take away, may be negative\n+     * @return the new period minus the increased millis\n+     * @throws UnsupportedOperationException if the field is not supported\n+     */\n+    public Period minusMillis(int millis) {\n+        return plusMillis(-millis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period to a period in weeks assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard weeks in this period\n+     * @throws UnsupportedOperationException if the period contains years or months\n+     * @throws ArithmeticException if the number of weeks is too large to be represented\n+     * @since 1.5\n+     */\n+    public Weeks toStandardWeeks() {\n+        checkYearsAndMonths(\"Weeks\");\n+        long millis = getMillis();  // assign to a long\n+        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n+        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n+        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n+        millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n+        long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;\n+        return Weeks.weeks(FieldUtils.safeToInt(weeks));\n+    }\n+\n+    /**\n+     * Converts this period to a period in days assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard days in this period\n+     * @throws UnsupportedOperationException if the period contains years or months\n+     * @throws ArithmeticException if the number of days is too large to be represented\n+     * @since 1.5\n+     */\n+    public Days toStandardDays() {\n+        checkYearsAndMonths(\"Days\");\n+        long millis = getMillis();  // assign to a long\n+        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n+        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n+        millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n+        long days = millis / DateTimeConstants.MILLIS_PER_DAY;\n+        days = FieldUtils.safeAdd(days, getDays());\n+        days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));\n+        return Days.days(FieldUtils.safeToInt(days));\n+    }\n+\n+    /**\n+     * Converts this period to a period in hours assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard hours in this period\n+     * @throws UnsupportedOperationException if the period contains years or months\n+     * @throws ArithmeticException if the number of hours is too large to be represented\n+     * @since 1.5\n+     */\n+    public Hours toStandardHours() {\n+        checkYearsAndMonths(\"Hours\");\n+        long millis = getMillis();  // assign to a long\n+        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n+        millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n+        long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;\n+        hours = FieldUtils.safeAdd(hours, getHours());\n+        hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));\n+        hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));\n+        return Hours.hours(FieldUtils.safeToInt(hours));\n+    }\n+\n+    /**\n+     * Converts this period to a period in minutes assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard minutes in this period\n+     * @throws UnsupportedOperationException if the period contains years or months\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     * @since 1.5\n+     */\n+    public Minutes toStandardMinutes() {\n+        checkYearsAndMonths(\"Minutes\");\n+        long millis = getMillis();  // assign to a long\n+        millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n+        long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;\n+        minutes = FieldUtils.safeAdd(minutes, getMinutes());\n+        minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));\n+        minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));\n+        minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));\n+        return Minutes.minutes(FieldUtils.safeToInt(minutes));\n+    }\n+\n+    /**\n+     * Converts this period to a period in seconds assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a period representing the number of standard seconds in this period\n+     * @throws UnsupportedOperationException if the period contains years or months\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     * @since 1.5\n+     */\n+    public Seconds toStandardSeconds() {\n+        checkYearsAndMonths(\"Seconds\");\n+        long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n+        seconds = FieldUtils.safeAdd(seconds, getSeconds());\n+        seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));\n+        seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));\n+        seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));\n+        seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));\n+        return Seconds.seconds(FieldUtils.safeToInt(seconds));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period to a duration assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all\n+     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n+     * all minutes are 60 seconds. This is not true when daylight savings time\n+     * is considered, and may also not be true for some unusual chronologies.\n+     * However, it is included as it is a useful operation for many\n+     * applications and business rules.\n+     * <p>\n+     * If the period contains years or months, an exception will be thrown.\n+     * \n+     * @return a duration equivalent to this period\n+     * @throws UnsupportedOperationException if the period contains years or months\n+     * @since 1.5\n+     */\n+    public Duration toStandardDuration() {\n+        checkYearsAndMonths(\"Duration\");\n+        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n+        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n+        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n+        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n+        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n+        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n+        return new Duration(millis);\n+    }\n+\n+    /**\n+     * Check that there are no years or months in the period.\n+     * \n+     * @param destintionType  the destination type, not null\n+     * @throws UnsupportedOperationException if the period contains years or months\n+     */\n+    private void checkYearsAndMonths(String destintionType) {\n+        if (getMonths() != 0) {\n+            throw new UnsupportedOperationException(\"Cannot convert to \" + destintionType + \" as this period contains months and months vary in length\");\n+        }\n+        if (getYears() != 0) {\n+            throw new UnsupportedOperationException(\"Cannot convert to \" + destintionType + \" as this period contains years and years vary in length\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Normalizes this period using standard rules, assuming a 12 month year,\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to normalize a period.\n+     * However to achieve this it makes the assumption that all years are\n+     * 12 months, all weeks are 7 days, all days are 24 hours,\n+     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n+     * true when daylight savings time is considered, and may also not be true\n+     * for some chronologies. However, it is included as it is a useful operation\n+     * for many applications and business rules.\n+     * <p>\n+     * If the period contains years or months, then the months will be\n+     * normalized to be between 0 and 11. The days field and below will be\n+     * normalized as necessary, however this will not overflow into the months\n+     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n+     * But a period of 1 month 40 days will remain as 1 month 40 days.\n+     * <p>\n+     * The result will always have a <code>PeriodType</code> of standard, thus\n+     * days will be grouped into weeks.\n+     * \n+     * @return a normalized period equivalent to this period\n+     * @throws ArithmeticException if any field is too large to be represented\n+     * @since 1.5\n+     */\n+    public Period normalizedStandard() {\n+        return normalizedStandard(PeriodType.standard());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Normalizes this period using standard rules, assuming a 12 month year,\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n+     * providing control over how the result is split into fields.\n+     * <p>\n+     * This method allows you to normalize a period.\n+     * However to achieve this it makes the assumption that all years are\n+     * 12 months, all weeks are 7 days, all days are 24 hours,\n+     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n+     * true when daylight savings time is considered, and may also not be true\n+     * for some chronologies. However, it is included as it is a useful operation\n+     * for many applications and business rules.\n+     * <p>\n+     * If the period contains years or months, then the months will be\n+     * normalized to be between 0 and 11. The days field and below will be\n+     * normalized as necessary, however this will not overflow into the months\n+     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n+     * But a period of 1 month 40 days will remain as 1 month 40 days.\n+     * <p>\n+     * The PeriodType parameter controls how the result is created. It allows\n+     * you to omit certain fields from the result if desired. For example,\n+     * you may not want the result to include weeks, in which case you pass\n+     * in <code>PeriodType.yearMonthDayTime()</code>.\n+     * \n+     * @param type  the period type of the new period, null means standard type\n+     * @return a normalized period equivalent to this period\n+     * @throws ArithmeticException if any field is too large to be represented\n+     * @throws UnsupportedOperationException if this period contains non-zero\n+     *  years or months but the specified period type does not support them\n+     * @since 1.5\n+     */\n+    public Period normalizedStandard(PeriodType type) {\n+        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n+        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n+        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n+        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n+        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n+        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n+        Period result = new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());\n+        int years = getYears();\n+        int months = getMonths();\n+        if (years != 0 || months != 0) {\n+            years = FieldUtils.safeAdd(years, months / 12);\n+            months = months % 12;\n+            if (years != 0) {\n+                result = result.withYears(years);\n+            }\n+            if (months != 0) {\n+                result = result.withMonths(months);\n+            }\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/PeriodType.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Controls a period implementation by specifying which duration fields are to be used.\n+ * <p>\n+ * The following implementations are provided:\n+ * <ul>\n+ * <li>Standard - years, months, weeks, days, hours, minutes, seconds, millis\n+ * <li>YearMonthDayTime - years, months, days, hours, minutes, seconds, millis\n+ * <li>YearMonthDay - years, months, days\n+ * <li>YearWeekDayTime - years, weeks, days, hours, minutes, seconds, millis\n+ * <li>YearWeekDay - years, weeks, days\n+ * <li>YearDayTime - years, days, hours, minutes, seconds, millis\n+ * <li>YearDay - years, days, hours\n+ * <li>DayTime - days, hours, minutes, seconds, millis\n+ * <li>Time - hours, minutes, seconds, millis\n+ * <li>plus one for each single type\n+ * </ul>\n+ *\n+ * <p>\n+ * PeriodType is thread-safe and immutable, and all subclasses must be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class PeriodType implements Serializable {\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2274324892792009998L;\n+\n+    /** Cache of all the known types. */\n+    private static final Map<PeriodType, Object> cTypes = new HashMap<PeriodType, Object>(32);\n+\n+    static int YEAR_INDEX = 0;\n+    static int MONTH_INDEX = 1;\n+    static int WEEK_INDEX = 2;\n+    static int DAY_INDEX = 3;\n+    static int HOUR_INDEX = 4;\n+    static int MINUTE_INDEX = 5;\n+    static int SECOND_INDEX = 6;\n+    static int MILLI_INDEX = 7;\n+    \n+    private static PeriodType cStandard;\n+    private static PeriodType cYMDTime;\n+    private static PeriodType cYMD;\n+    private static PeriodType cYWDTime;\n+    private static PeriodType cYWD;\n+    private static PeriodType cYDTime;\n+    private static PeriodType cYD;\n+    private static PeriodType cDTime;\n+    private static PeriodType cTime;\n+    \n+    private static PeriodType cYears;\n+    private static PeriodType cMonths;\n+    private static PeriodType cWeeks;\n+    private static PeriodType cDays;\n+    private static PeriodType cHours;\n+    private static PeriodType cMinutes;\n+    private static PeriodType cSeconds;\n+    private static PeriodType cMillis;\n+\n+    /**\n+     * Gets a type that defines all standard fields.\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType standard() {\n+        PeriodType type = cStandard;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Standard\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(), DurationFieldType.months(),\n+                    DurationFieldType.weeks(), DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n+            );\n+            cStandard = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard fields except weeks.\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType yearMonthDayTime() {\n+        PeriodType type = cYMDTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearMonthDayTime\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(), DurationFieldType.months(),\n+                    DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { 0, 1, -1, 2, 3, 4, 5, 6, }\n+            );\n+            cYMDTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines the year, month and day fields.\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days\n+     * </ul>\n+     *\n+     * @return the period type\n+     * @since 1.1\n+     */\n+    public static PeriodType yearMonthDay() {\n+        PeriodType type = cYMD;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearMonthDay\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(), DurationFieldType.months(),\n+                    DurationFieldType.days(),\n+                },\n+                new int[] { 0, 1, -1, 2, -1, -1, -1, -1, }\n+            );\n+            cYMD = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard fields except months.\n+     * <ul>\n+     * <li>years\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType yearWeekDayTime() {\n+        PeriodType type = cYWDTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearWeekDayTime\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(),\n+                    DurationFieldType.weeks(), DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { 0, -1, 1, 2, 3, 4, 5, 6, }\n+            );\n+            cYWDTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines year, week and day fields.\n+     * <ul>\n+     * <li>years\n+     * <li>weeks\n+     * <li>days\n+     * </ul>\n+     *\n+     * @return the period type\n+     * @since 1.1\n+     */\n+    public static PeriodType yearWeekDay() {\n+        PeriodType type = cYWD;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearWeekDay\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(),\n+                    DurationFieldType.weeks(), DurationFieldType.days(),\n+                },\n+                new int[] { 0, -1, 1, 2, -1, -1, -1, -1, }\n+            );\n+            cYWD = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard fields except months and weeks.\n+     * <ul>\n+     * <li>years\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType yearDayTime() {\n+        PeriodType type = cYDTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearDayTime\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(), DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { 0, -1, -1, 1, 2, 3, 4, 5, }\n+            );\n+            cYDTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines the year and day fields.\n+     * <ul>\n+     * <li>years\n+     * <li>days\n+     * </ul>\n+     *\n+     * @return the period type\n+     * @since 1.1\n+     */\n+    public static PeriodType yearDay() {\n+        PeriodType type = cYD;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearDay\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(), DurationFieldType.days(),\n+                },\n+                new int[] { 0, -1, -1, 1, -1, -1, -1, -1, }\n+            );\n+            cYD = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard fields from days downwards.\n+     * <ul>\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType dayTime() {\n+        PeriodType type = cDTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"DayTime\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { -1, -1, -1, 0, 1, 2, 3, 4, }\n+            );\n+            cDTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard time fields.\n+     * <ul>\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType time() {\n+        PeriodType type = cTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Time\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { -1, -1, -1, -1, 0, 1, 2, 3, }\n+            );\n+            cTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the years field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType years() {\n+        PeriodType type = cYears;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Years\",\n+                new DurationFieldType[] { DurationFieldType.years() },\n+                new int[] { 0, -1, -1, -1, -1, -1, -1, -1, }\n+            );\n+            cYears = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the months field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType months() {\n+        PeriodType type = cMonths;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Months\",\n+                new DurationFieldType[] { DurationFieldType.months() },\n+                new int[] { -1, 0, -1, -1, -1, -1, -1, -1, }\n+            );\n+            cMonths = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the weeks field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType weeks() {\n+        PeriodType type = cWeeks;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Weeks\",\n+                new DurationFieldType[] { DurationFieldType.weeks() },\n+                new int[] { -1, -1, 0, -1, -1, -1, -1, -1, }\n+            );\n+            cWeeks = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the days field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType days() {\n+        PeriodType type = cDays;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Days\",\n+                new DurationFieldType[] { DurationFieldType.days() },\n+                new int[] { -1, -1, -1, 0, -1, -1, -1, -1, }\n+            );\n+            cDays = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the hours field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType hours() {\n+        PeriodType type = cHours;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Hours\",\n+                new DurationFieldType[] { DurationFieldType.hours() },\n+                new int[] { -1, -1, -1, -1, 0, -1, -1, -1, }\n+            );\n+            cHours = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the minutes field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType minutes() {\n+        PeriodType type = cMinutes;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Minutes\",\n+                new DurationFieldType[] { DurationFieldType.minutes() },\n+                new int[] { -1, -1, -1, -1, -1, 0, -1, -1, }\n+            );\n+            cMinutes = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the seconds field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType seconds() {\n+        PeriodType type = cSeconds;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Seconds\",\n+                new DurationFieldType[] { DurationFieldType.seconds() },\n+                new int[] { -1, -1, -1, -1, -1, -1, 0, -1, }\n+            );\n+            cSeconds = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the millis field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType millis() {\n+        PeriodType type = cMillis;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Millis\",\n+                new DurationFieldType[] { DurationFieldType.millis() },\n+                new int[] { -1, -1, -1, -1, -1, -1, -1, 0, }\n+            );\n+            cMillis = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a period type that contains the duration types of the array.\n+     * <p>\n+     * Only the 8 standard duration field types are supported.\n+     *\n+     * @param types  the types to include in the array.\n+     * @return the period type\n+     * @since 1.1\n+     */\n+    public static synchronized PeriodType forFields(DurationFieldType[] types) {\n+        if (types == null || types.length == 0) {\n+            throw new IllegalArgumentException(\"Types array must not be null or empty\");\n+        }\n+        for (int i = 0; i < types.length; i++) {\n+            if (types[i] == null) {\n+                throw new IllegalArgumentException(\"Types array must not contain null\");\n+            }\n+        }\n+        Map<PeriodType, Object> cache = cTypes;\n+        if (cache.isEmpty()) {\n+            cache.put(standard(), standard());\n+            cache.put(yearMonthDayTime(), yearMonthDayTime());\n+            cache.put(yearMonthDay(), yearMonthDay());\n+            cache.put(yearWeekDayTime(), yearWeekDayTime());\n+            cache.put(yearWeekDay(), yearWeekDay());\n+            cache.put(yearDayTime(), yearDayTime());\n+            cache.put(yearDay(), yearDay());\n+            cache.put(dayTime(), dayTime());\n+            cache.put(time(), time());\n+            cache.put(years(), years());\n+            cache.put(months(), months());\n+            cache.put(weeks(), weeks());\n+            cache.put(days(), days());\n+            cache.put(hours(), hours());\n+            cache.put(minutes(), minutes());\n+            cache.put(seconds(), seconds());\n+            cache.put(millis(), millis());\n+        }\n+        PeriodType inPartType = new PeriodType(null, types, null);\n+        Object cached = cache.get(inPartType);\n+        if (cached instanceof PeriodType) {\n+            return (PeriodType) cached;\n+        }\n+        if (cached != null) {\n+            throw new IllegalArgumentException(\"PeriodType does not support fields: \" + cached);\n+        }\n+        PeriodType type = standard();\n+        List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));\n+        if (list.remove(DurationFieldType.years()) == false) {\n+            type = type.withYearsRemoved();\n+        }\n+        if (list.remove(DurationFieldType.months()) == false) {\n+            type = type.withMonthsRemoved();\n+        }\n+        if (list.remove(DurationFieldType.weeks()) == false) {\n+            type = type.withWeeksRemoved();\n+        }\n+        if (list.remove(DurationFieldType.days()) == false) {\n+            type = type.withDaysRemoved();\n+        }\n+        if (list.remove(DurationFieldType.hours()) == false) {\n+            type = type.withHoursRemoved();\n+        }\n+        if (list.remove(DurationFieldType.minutes()) == false) {\n+            type = type.withMinutesRemoved();\n+        }\n+        if (list.remove(DurationFieldType.seconds()) == false) {\n+            type = type.withSecondsRemoved();\n+        }\n+        if (list.remove(DurationFieldType.millis()) == false) {\n+            type = type.withMillisRemoved();\n+        }\n+        if (list.size() > 0) {\n+            cache.put(inPartType, list);\n+            throw new IllegalArgumentException(\"PeriodType does not support fields: \" + list);\n+        }\n+        // recheck cache in case initial array order was wrong\n+        PeriodType checkPartType = new PeriodType(null, type.iTypes, null);\n+        PeriodType checkedType = (PeriodType) cache.get(checkPartType);\n+        if (checkedType != null) {\n+            cache.put(inPartType, checkedType);\n+            return checkedType;\n+        }\n+        cache.put(inPartType, type);\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /** The name of the type */\n+    private final String iName;\n+    /** The array of types */\n+    private final DurationFieldType[] iTypes;\n+    /** The array of indices */\n+    private final int[] iIndices;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param name  the name\n+     * @param types  the types\n+     * @param indices  the indices\n+     */\n+    protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\n+        super();\n+        iName = name;\n+        iTypes = types;\n+        iIndices = indices;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the name of the period type.\n+     * \n+     * @return the name\n+     */\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * Gets the number of fields in the period type.\n+     * \n+     * @return the number of fields\n+     */\n+    public int size() {\n+        return iTypes.length;\n+    }\n+\n+    /**\n+     * Gets the field type by index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the field type\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DurationFieldType getFieldType(int index) {\n+        return iTypes[index];\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this period.\n+     *\n+     * @param type  the type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        return (indexOf(type) >= 0);\n+    }\n+\n+    /**\n+     * Gets the index of the field in this period.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of -1 if not supported\n+     */\n+    public int indexOf(DurationFieldType type) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (iTypes[i] == type) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Gets a debugging to string.\n+     * \n+     * @return a string\n+     */\n+    public String toString() {\n+        return \"PeriodType[\" + getName() + \"]\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the indexed field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @param index  the index to use\n+     * @return the value of the field, zero if unsupported\n+     */\n+    int getIndexedField(ReadablePeriod period, int index) {\n+        int realIndex = iIndices[index];\n+        return (realIndex == -1 ? 0 : period.getValue(realIndex));\n+    }\n+\n+    /**\n+     * Sets the indexed field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @param index  the index to use\n+     * @param values  the array to populate\n+     * @param newValue  the value to set\n+     * @throws UnsupportedOperationException if not supported\n+     */\n+    boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\n+        int realIndex = iIndices[index];\n+        if (realIndex == -1) {\n+            throw new UnsupportedOperationException(\"Field is not supported\");\n+        }\n+        values[realIndex] = newValue;\n+        return true;\n+    }\n+\n+    /**\n+     * Adds to the indexed field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @param index  the index to use\n+     * @param values  the array to populate\n+     * @param valueToAdd  the value to add\n+     * @return true if the array is updated\n+     * @throws UnsupportedOperationException if not supported\n+     */\n+    boolean addIndexedField(ReadablePeriod period, int index, int[] values, int valueToAdd) {\n+        if (valueToAdd == 0) {\n+            return false;\n+        }\n+        int realIndex = iIndices[index];\n+        if (realIndex == -1) {\n+            throw new UnsupportedOperationException(\"Field is not supported\");\n+        }\n+        values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd);\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a version of this PeriodType instance that does not support years.\n+     * \n+     * @return a new period type that supports the original set of fields except years\n+     */\n+    public PeriodType withYearsRemoved() {\n+        return withFieldRemoved(0, \"NoYears\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support months.\n+     * \n+     * @return a new period type that supports the original set of fields except months\n+     */\n+    public PeriodType withMonthsRemoved() {\n+        return withFieldRemoved(1, \"NoMonths\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support weeks.\n+     * \n+     * @return a new period type that supports the original set of fields except weeks\n+     */\n+    public PeriodType withWeeksRemoved() {\n+        return withFieldRemoved(2, \"NoWeeks\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support days.\n+     * \n+     * @return a new period type that supports the original set of fields except days\n+     */\n+    public PeriodType withDaysRemoved() {\n+        return withFieldRemoved(3, \"NoDays\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support hours.\n+     * \n+     * @return a new period type that supports the original set of fields except hours\n+     */\n+    public PeriodType withHoursRemoved() {\n+        return withFieldRemoved(4, \"NoHours\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support minutes.\n+     * \n+     * @return a new period type that supports the original set of fields except minutes\n+     */\n+    public PeriodType withMinutesRemoved() {\n+        return withFieldRemoved(5, \"NoMinutes\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support seconds.\n+     * \n+     * @return a new period type that supports the original set of fields except seconds\n+     */\n+    public PeriodType withSecondsRemoved() {\n+        return withFieldRemoved(6, \"NoSeconds\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support milliseconds.\n+     * \n+     * @return a new period type that supports the original set of fields except milliseconds\n+     */\n+    public PeriodType withMillisRemoved() {\n+        return withFieldRemoved(7, \"NoMillis\");\n+    }\n+\n+    /**\n+     * Removes the field specified by indices index.\n+     * \n+     * @param indicesIndex  the index to remove\n+     * @param name  the name addition\n+     * @return the new type\n+     */\n+    private PeriodType withFieldRemoved(int indicesIndex, String name) {\n+        int fieldIndex = iIndices[indicesIndex];\n+        if (fieldIndex == -1) {\n+            return this;\n+        }\n+        \n+        DurationFieldType[] types = new DurationFieldType[size() - 1];\n+        for (int i = 0; i < iTypes.length; i++) {\n+            if (i < fieldIndex) {\n+                types[i] = iTypes[i];\n+            } else if (i > fieldIndex) {\n+                types[i - 1] = iTypes[i];\n+            }\n+        }\n+        \n+        int[] indices = new int[8];\n+        for (int i = 0; i < indices.length; i++) {\n+            if (i < indicesIndex) {\n+                indices[i] = iIndices[i];\n+            } else if (i > indicesIndex) {\n+                indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1);\n+            } else {\n+                indices[i] = -1;\n+            }\n+        }\n+        return new PeriodType(getName() + name, types, indices);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this type to another object.\n+     * To be equal, the object must be a PeriodType with the same set of fields.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof PeriodType == false) {\n+            return false;\n+        }\n+        PeriodType other = (PeriodType) obj;\n+        return (Arrays.equals(iTypes, other.iTypes));\n+    }\n+\n+    /**\n+     * Returns a hashcode based on the field types.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        int hash = 0;\n+        for (int i = 0; i < iTypes.length; i++) {\n+            hash += iTypes[i].hashCode();\n+        }\n+        return hash;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadWritableDateTime.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines an instant in time that can be queried and modified using datetime fields.\n+ * <p>\n+ * The implementation of this interface will be mutable.\n+ * It may provide more advanced methods than those in the interface.\n+ * <p>\n+ * Methods in your application should be defined using <code>ReadWritableDateTime</code>\n+ * as a parameter if the method wants to manipulate and change a date in simple ways.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface ReadWritableDateTime extends ReadableDateTime, ReadWritableInstant {\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the year to the specified value.\n+     *\n+     * @param year  the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setYear(int year);\n+\n+    /**\n+     * Add a number of years to the date.\n+     *\n+     * @param years  the years to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addYears(int years);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the weekyear to the specified value.\n+     *\n+     * @param weekyear  the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setWeekyear(int weekyear);\n+\n+    /**\n+     * Add a number of weekyears to the date.\n+     *\n+     * @param weekyears  the weekyears to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addWeekyears(int weekyears);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the month of the year to the specified value.\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMonthOfYear(int monthOfYear);\n+\n+    /**\n+     * Add a number of months to the date.\n+     *\n+     * @param months  the months to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addMonths(int months);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the week of weekyear to the specified value.\n+     *\n+     * @param weekOfWeekyear the week of the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setWeekOfWeekyear(int weekOfWeekyear);\n+\n+    /**\n+     * Add a number of weeks to the date.\n+     *\n+     * @param weeks  the weeks to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addWeeks(int weeks);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the day of year to the specified value.\n+     *\n+     * @param dayOfYear the day of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDayOfYear(int dayOfYear);\n+\n+    /**\n+     * Set the day of the month to the specified value.\n+     *\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDayOfMonth(int dayOfMonth);\n+\n+    /**\n+     * Set the day of week to the specified value.\n+     *\n+     * @param dayOfWeek  the day of the week\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setDayOfWeek(int dayOfWeek);\n+\n+    /**\n+     * Add a number of days to the date.\n+     *\n+     * @param days  the days to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addDays(int days);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the hour of the day to the specified value.\n+     *\n+     * @param hourOfDay  the hour of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setHourOfDay(int hourOfDay);\n+\n+    /**\n+     * Add a number of hours to the date.\n+     *\n+     * @param hours  the hours to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addHours(int hours);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the minute of the day to the specified value.\n+     *\n+     * @param minuteOfDay  the minute of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMinuteOfDay(int minuteOfDay);\n+\n+    /**\n+     * Set the minute of the hour to the specified value.\n+     *\n+     * @param minuteOfHour  the minute of hour\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMinuteOfHour(int minuteOfHour);\n+\n+    /**\n+     * Add a number of minutes to the date.\n+     *\n+     * @param minutes  the minutes to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addMinutes(int minutes);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the second of the day to the specified value.\n+     *\n+     * @param secondOfDay  the second of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setSecondOfDay(int secondOfDay);\n+\n+    /**\n+     * Set the second of the minute to the specified value.\n+     *\n+     * @param secondOfMinute  the second of minute\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setSecondOfMinute(int secondOfMinute);\n+\n+    /**\n+     * Add a number of seconds to the date.\n+     *\n+     * @param seconds  the seconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addSeconds(int seconds);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the millis of the day to the specified value.\n+     *\n+     * @param millisOfDay  the millis of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMillisOfDay(int millisOfDay);\n+\n+    /**\n+     * Set the millis of the second to the specified value.\n+     *\n+     * @param millisOfSecond  the millis of second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMillisOfSecond(int millisOfSecond);\n+\n+    /**\n+     * Add a number of milliseconds to the date. The implementation of this\n+     * method differs from the {@link #add(long)} method in that a\n+     * DateTimeField performs the addition.\n+     *\n+     * @param millis  the milliseconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void addMillis(int millis);\n+\n+    /**\n+     * Set the date from fields.\n+     * The time part of this object will be unaffected.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    void setDate(int year, int monthOfYear, int dayOfMonth);\n+\n+    /**\n+     * Set the time from fields.\n+     * The date part of this object will be unaffected.\n+     *\n+     * @param hour  the hour\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    void setTime(int hour, int minuteOfHour, int secondOfMinute, int millisOfSecond);\n+\n+    /**\n+     * Set the date and time from fields.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @throws IllegalArgumentException if any value is invalid\n+     */\n+    void setDateTime(\n+        int year, int monthOfYear, int dayOfMonth,\n+        int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadWritableInstant.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines an instant in the datetime continuum that can be queried and modified.\n+ * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.\n+ * <p>\n+ * The implementation of this interface will be mutable.\n+ * It may provide more advanced methods than those in the interface.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadWritableInstant extends ReadableInstant {\n+\n+    /**\n+     * Sets the value as the number of milliseconds since\n+     * the epoch, 1970-01-01T00:00:00Z.\n+     * \n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * instant to\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setMillis(long instant);\n+\n+    /**\n+     * Sets the millisecond instant of this instant from another.\n+     * <p>\n+     * This method does not change the chronology of this instant, just the\n+     * millisecond instant.\n+     * \n+     * @param instant  the instant to use, null means now\n+     */\n+    void setMillis(ReadableInstant instant);\n+\n+    /**\n+     * Sets the chronology of the datetime, which has no effect if not applicable.\n+     * \n+     * @param chronology  the chronology to use, null means ISOChronology in default zone\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void setChronology(Chronology chronology);\n+\n+    /**\n+     * Sets the time zone of the datetime, changing the chronology and field values.\n+     * <p>\n+     * Changing the zone using this method retains the millisecond instant.\n+     * The millisecond instant is adjusted in the new zone to compensate.\n+     * \n+     * chronology. Setting the time zone does not affect the millisecond value\n+     * of this instant.\n+     * <p>\n+     * If the chronology already has this time zone, no change occurs.\n+     *\n+     * @param zone  the time zone to use, null means default zone\n+     * @see #setZoneRetainFields\n+     */\n+    void setZone(DateTimeZone zone);\n+\n+    /**\n+     * Sets the time zone of the datetime, changing the chronology and millisecond.\n+     * <p>\n+     * Changing the zone using this method retains the field values.\n+     * The millisecond instant is adjusted in the new zone to compensate.\n+     * <p>\n+     * If the chronology already has this time zone, no change occurs.\n+     *\n+     * @param zone  the time zone to use, null means default zone\n+     * @see #setZone\n+     */\n+    void setZoneRetainFields(DateTimeZone zone);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a millisecond duration to this instant.\n+     * <p>\n+     * This will typically change the value of ost fields.\n+     *\n+     * @param duration  the millis to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void add(long duration);\n+\n+    /**\n+     * Adds a duration to this instant.\n+     * <p>\n+     * This will typically change the value of most fields.\n+     *\n+     * @param duration  the duration to add, null means add zero\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    void add(ReadableDuration duration);\n+\n+    /**\n+     * Adds a duration to this instant specifying how many times to add.\n+     * <p>\n+     * This will typically change the value of most fields.\n+     *\n+     * @param duration  the duration to add, null means add zero\n+     * @param scalar  direction and amount to add, which may be negative\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    void add(ReadableDuration duration, int scalar);\n+\n+    /**\n+     * Adds a period to this instant.\n+     * <p>\n+     * This will typically change the value of most fields.\n+     *\n+     * @param period  the period to add, null means add zero\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    void add(ReadablePeriod period);\n+\n+    /**\n+     * Adds a period to this instant specifying how many times to add.\n+     * <p>\n+     * This will typically change the value of most fields.\n+     *\n+     * @param period  the period to add, null means add zero\n+     * @param scalar  direction and amount to add, which may be negative\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    void add(ReadablePeriod period, int scalar);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of one of the fields of the instant, such as hourOfDay.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType, null ignored\n+     * @param value  the value to set the field to\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    void set(DateTimeFieldType type, int value);\n+\n+    /**\n+     * Adds to the instant specifying the duration and multiple to add.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType, null ignored\n+     * @param amount  the amount to add of this duration\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    void add(DurationFieldType type, int amount);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadWritableInterval.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Writable interface for an interval.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface ReadWritableInterval extends ReadableInterval {\n+\n+    /**\n+     * Sets this interval from two millisecond instants.\n+     *\n+     * @param startInstant  the start of the time interval\n+     * @param endInstant  the start of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    void setInterval(long startInstant, long endInstant);\n+\n+    /**\n+     * Sets this interval to be the same as another.\n+     *\n+     * @param interval  the interval to copy\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    void setInterval(ReadableInterval interval);\n+\n+    /**\n+     * Sets this interval from two instants.\n+     *\n+     * @param startInstant  the start of the time interval\n+     * @param endInstant  the start of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    void setInterval(ReadableInstant startInstant, ReadableInstant endInstant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the chronology of this time interval.\n+     *\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    void setChronology(Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the start of this time interval.\n+     *\n+     * @param millisInstant  the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    void setStartMillis(long millisInstant);\n+\n+    /**\n+     * Sets the start of this time interval as an Instant.\n+     *\n+     * @param instant  the start of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    void setStart(ReadableInstant instant);\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Sets the end of this time interval.\n+     *\n+     * @param millisInstant  the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    void setEndMillis(long millisInstant);\n+\n+    /** \n+     * Sets the end of this time interval as an Instant.\n+     *\n+     * @param instant  the end of the time interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    void setEnd(ReadableInstant instant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the duration of this time interval, preserving the start instant.\n+     *\n+     * @param duration  new duration for interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    void setDurationAfterStart(ReadableDuration duration);\n+\n+    /**\n+     * Sets the duration of this time interval, preserving the end instant.\n+     *\n+     * @param duration  new duration for interval\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    void setDurationBeforeEnd(ReadableDuration duration);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the period of this time interval, preserving the start instant.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    void setPeriodAfterStart(ReadablePeriod period);\n+\n+    /**\n+     * Sets the period of this time interval, preserving the end instant.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    void setPeriodBeforeEnd(ReadablePeriod period);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadWritablePeriod.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a duration of time that can be queried and modified using datetime fields.\n+ * <p>\n+ * The implementation of this interface will be mutable.\n+ * It may provide more advanced methods than those in the interface.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadWritablePeriod extends ReadablePeriod {\n+\n+    /**\n+     * Clears the period, setting all values back to zero.\n+     */\n+    void clear();\n+\n+    /**\n+     * Sets the value of one of the fields by index.\n+     *\n+     * @param index  the field index\n+     * @param value  the new value for the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    void setValue(int index, int value);\n+\n+    /**\n+     * Sets the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the period.\n+     *\n+     * @param field  a DurationFieldType instance that is supported by this period\n+     * @param value  the new value for the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    void set(DurationFieldType field, int value);\n+\n+    /**\n+     * Sets all the fields in one go from another ReadablePeriod.\n+     * \n+     * @param period  the period to set, null means zero length period\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    void setPeriod(ReadablePeriod period);\n+\n+    /**\n+     * Sets all the fields in one go.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    void setPeriod(int years, int months, int weeks, int days,\n+                       int hours, int minutes, int seconds, int millis);\n+\n+    /**\n+     * Sets all the fields in one go from an interval dividing the\n+     * fields using the period type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    void setPeriod(ReadableInterval interval);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds to the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the period.\n+     *\n+     * @param field  a DurationFieldType instance that is supported by this period\n+     * @param value  the value to add to the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    void add(DurationFieldType field, int value);\n+\n+    /**\n+     * Adds a period to this one by adding each field in turn.\n+     * \n+     * @param period  the period to add, null means add nothing\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(ReadablePeriod period);\n+\n+    /**\n+     * Adds to each field of this period.\n+     * \n+     * @param years  amount of years to add to this period, which must be zero if unsupported\n+     * @param months  amount of months to add to this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks to add to this period, which must be zero if unsupported\n+     * @param days  amount of days to add to this period, which must be zero if unsupported\n+     * @param hours  amount of hours to add to this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes to add to this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds to add to this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds to add to this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if the period being added contains a field\n+     * not supported by this period\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis);\n+\n+    /**\n+     * Adds an interval to this one by dividing the interval into\n+     * fields and then adding each field in turn.\n+     * \n+     * @param interval  the interval to add, null means add nothing\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void add(ReadableInterval interval);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of years of the period.\n+     * \n+     * @param years  the number of years\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    void setYears(int years);\n+\n+    /**\n+     * Adds the specified years to the number of years in the period.\n+     * \n+     * @param years  the number of years\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addYears(int years);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of months of the period.\n+     * \n+     * @param months  the number of months\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    void setMonths(int months);\n+\n+    /**\n+     * Adds the specified months to the number of months in the period.\n+     * \n+     * @param months  the number of months\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMonths(int months);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of weeks of the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    void setWeeks(int weeks);\n+\n+    /**\n+     * Adds the specified weeks to the number of weeks in the period.\n+     * \n+     * @param weeks  the number of weeks\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addWeeks(int weeks);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of days of the period.\n+     * \n+     * @param days  the number of days\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    void setDays(int days);\n+\n+    /**\n+     * Adds the specified days to the number of days in the period.\n+     * \n+     * @param days  the number of days\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addDays(int days);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of hours of the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    void setHours(int hours);\n+\n+    /**\n+     * Adds the specified hours to the number of hours in the period.\n+     * \n+     * @param hours  the number of hours\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addHours(int hours);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of minutes of the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    void setMinutes(int minutes);\n+\n+    /**\n+     * Adds the specified minutes to the number of minutes in the period.\n+     * \n+     * @param minutes  the number of minutes\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMinutes(int minutes);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of seconds of the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    void setSeconds(int seconds);\n+\n+    /**\n+     * Adds the specified seconds to the number of seconds in the period.\n+     * \n+     * @param seconds  the number of seconds\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addSeconds(int seconds);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the number of millis of the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     */\n+    void setMillis(int millis);\n+\n+    /**\n+     * Adds the specified millis to the number of millis in the period.\n+     * \n+     * @param millis  the number of millis\n+     * @throws IllegalArgumentException if field is not supported and the value is non-zero\n+     * @throws ArithmeticException if the addition exceeds the capacity of the period\n+     */\n+    void addMillis(int millis);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadableDateTime.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Defines an instant in time that can be queried using datetime fields.\n+ * <p>\n+ * The implementation of this interface may be mutable or immutable.\n+ * This interface only gives access to retrieve data, never to change it.\n+ * <p>\n+ * Methods in your application should be defined using <code>ReadableDateTime</code>\n+ * as a parameter if the method only wants to read the datetime, and not perform\n+ * any advanced manipulations.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface ReadableDateTime extends ReadableInstant {\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week\n+     */\n+    int getDayOfWeek();\n+\n+    /**\n+     * Get the day of month field value.\n+     * \n+     * @return the day of month\n+     */\n+    int getDayOfMonth();\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    int getDayOfYear();\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    int getWeekOfWeekyear();\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    int getWeekyear();\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    int getMonthOfYear();\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    int getYear();\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    int getYearOfEra();\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    int getYearOfCentury();\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    int getCenturyOfEra();\n+\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    int getEra();\n+\n+    // Time field access methods\n+    //-----------------------------------------------------------\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    int getMillisOfSecond();\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    int getMillisOfDay();\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    int getSecondOfMinute();\n+\n+    /**\n+     * Get the second of day field value.\n+     *\n+     * @return the second of day\n+     */\n+    int getSecondOfDay();\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    int getMinuteOfHour();\n+\n+    /**\n+     * Get the minute of day field value.\n+     *\n+     * @return the minute of day\n+     */\n+    int getMinuteOfDay();\n+\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    int getHourOfDay();\n+\n+    /**\n+     * Get this object as a DateTime.\n+     * <p>\n+     * If the implementation of the interface is a DateTime, it is returned directly.\n+     * \n+     * @return a DateTime using the same millis\n+     */\n+    DateTime toDateTime();\n+\n+    /**\n+     * Get this object as a MutableDateTime, always returning a new instance.\n+     * \n+     * @return a MutableDateTime using the same millis\n+     */\n+    MutableDateTime toMutableDateTime();\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException  if pattern is invalid\n+     * @see  org.joda.time.format.DateTimeFormat\n+     */\n+    String toString(String pattern) throws IllegalArgumentException;\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  pattern specification\n+     * @param locale  Locale to use, or null for default\n+     * @throws IllegalArgumentException  if pattern is invalid\n+     * @see  org.joda.time.format.DateTimeFormat\n+     */\n+    String toString(String pattern, Locale locale) throws IllegalArgumentException;\n+    \n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadableDuration.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines an exact duration of time in milliseconds.\n+ * <p>\n+ * The implementation of this interface may be mutable or immutable. This\n+ * interface only gives access to retrieve data, never to change it.\n+ * <p>\n+ * Methods that are passed a duration as a parameter will treat <code>null</code>\n+ * as a zero length duration.\n+ *\n+ * @see ReadableInterval\n+ * @see ReadablePeriod\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadableDuration extends Comparable<ReadableDuration> {\n+\n+    /**\n+     * Gets the total length of this duration in milliseconds.\n+     *\n+     * @return the total length of the time duration in milliseconds.\n+     */\n+    long getMillis();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this duration as an immutable <code>Duration</code> object.\n+     * <p>\n+     * This will either typecast this instance, or create a new <code>Duration</code>.\n+     * \n+     * @return a Duration created using the millisecond duration from this instance\n+     */\n+    Duration toDuration();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this duration to a Period instance using the standard period type\n+     * and the ISO chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used. Thus, only the hour,\n+     * minute, second and millisecond fields on the period will be used.\n+     * The year, month, week and day fields will not be populated.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available field, hours in this case.\n+     * <p>\n+     * For example, a duration effectively equal to (365 + 60 + 5) days will be\n+     * converted to ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}.\n+     * \n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    Period toPeriod();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this duration with the specified duration based on length.\n+     *\n+     * @param obj  a duration to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the given object is not supported\n+     */\n+    int compareTo(ReadableDuration obj);\n+\n+    /**\n+     * Is the length of this duration equal to the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    boolean isEqual(ReadableDuration duration);\n+\n+    /**\n+     * Is the length of this duration longer than the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    boolean isLongerThan(ReadableDuration duration);\n+\n+    /**\n+     * Is the length of this duration shorter than the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    boolean isShorterThan(ReadableDuration duration);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond length. All ReadableDuration instances are accepted.\n+     *\n+     * @param readableDuration  a readable duration to check against\n+     * @return true if the length of the duration is equal\n+     */\n+    boolean equals(Object readableDuration);\n+\n+    /**\n+     * Gets a hash code for the duration that is compatable with the \n+     * equals method.\n+     * The following formula must be used:\n+     * <pre>\n+     *  long len = getMillis();\n+     *  return (int) (len ^ (len >>> 32));\n+     * </pre>\n+     *\n+     * @return a hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format using hours,\n+     * minutes and seconds (including fractional milliseconds).\n+     * <p>\n+     * For example, \"PT6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadableInstant.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines an instant in the datetime continuum.\n+ * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.\n+ * <p>\n+ * The implementation of this interface may be mutable or immutable.\n+ * This interface only gives access to retrieve data, never to change it.\n+ * <p>\n+ * Methods in your application should be defined using <code>ReadableInstant</code>\n+ * as a parameter if the method only wants to read the instant without needing to know\n+ * the specific datetime fields.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadableInstant extends Comparable<ReadableInstant> {\n+\n+    /**\n+     * Get the value as the number of milliseconds since\n+     * the epoch, 1970-01-01T00:00:00Z.\n+     *\n+     * @return the value as milliseconds\n+     */\n+    long getMillis();\n+\n+    /**\n+     * Gets the chronology of the instant.\n+     * <p>\n+     * The {@link Chronology} provides conversion from the millisecond\n+     * value to meaningful fields in a particular calendar system.\n+     * \n+     * @return the Chronology, never null\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Gets the time zone of the instant from the chronology.\n+     * \n+     * @return the DateTimeZone that the instant is using, never null\n+     */\n+    DateTimeZone getZone();\n+\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This method uses the chronology of the instant to obtain the value.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null\n+     */\n+    int get(DateTimeFieldType type);\n+\n+    /**\n+     * Checks whether the field type specified is supported by this implementation.\n+     *\n+     * @param field  the field type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    boolean isSupported(DateTimeFieldType field);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a simple immutable <code>Instant</code> object.\n+     * <p>\n+     * This can be useful if you don't trust the implementation\n+     * of the interface to be well-behaved, or to get a guaranteed\n+     * immutable object.\n+     *\n+     * @return the value as an <code>Instant</code> object\n+     */\n+    Instant toInstant();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for ascending\n+     * millisecond instant order. This ordering is inconsistent with\n+     * equals, as it ignores the Chronology.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object type is not supported\n+     */\n+    int compareTo(ReadableInstant readableInstant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this instant equal to the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n+     * @return true if the instant is equal to the instant passed in\n+     */\n+    boolean isEqual(ReadableInstant instant);\n+\n+    /**\n+     * Is this instant after the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n+     * @return true if the instant is after the instant passed in\n+     */\n+    boolean isAfter(ReadableInstant instant);\n+\n+    /**\n+     * Is this instant before the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n+     * @return true if the instant is before the instant passed in\n+     */\n+    boolean isBefore(ReadableInstant instant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond instant and the Chronology. All ReadableInstant\n+     * instances are accepted.\n+     * <p>\n+     * To compare two instants for absolute time (ie. UTC milliseconds \n+     * ignoring the chronology), use {@link #isEqual(ReadableInstant)} or\n+     * {@link #compareTo(Object)}.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return true if millisecond and chronology are equal, false if\n+     *  not or the instant is null or of an incorrect type\n+     */\n+    boolean equals(Object readableInstant);\n+\n+    /**\n+     * Gets a hash code for the instant that is compatible with the \n+     * equals method.\n+     * <p>\n+     * The formula used must be as follows:\n+     * <pre>\n+     * ((int) (getMillis() ^ (getMillis() >>> 32))) +\n+     * (getChronology().hashCode())\n+     * </pre>\n+     *\n+     * @return a hash code as defined above\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadableInterval.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/** \n+ * Readable interface for an interval of time between two instants.\n+ * <p>\n+ * A time interval represents a period of time between two instants.\n+ * Intervals are inclusive of the start instant and exclusive of the end.\n+ * The end instant is always greater than or equal to the start instant.\n+ * <p>\n+ * Intervals have a fixed millisecond duration.\n+ * This is the difference between the start and end instants.\n+ * The duration is represented separately by {@link ReadableDuration}.\n+ * As a result, intervals are not comparable.\n+ * To compare the length of two intervals, you should compare their durations.\n+ * <p>\n+ * An interval can also be converted to a {@link ReadablePeriod}.\n+ * This represents the difference between the start and end points in terms of fields\n+ * such as years and days.\n+ * <p>\n+ * Methods that are passed an interval as a parameter will treat <code>null</code>\n+ * as a zero length interval at the current instant in time.\n+ *\n+ * @author Sean Geoghegan\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadableInterval {\n+\n+    /**\n+     * Gets the chronology of the interval, which is the chronology of the first datetime.\n+     *\n+     * @return the chronology of the interval\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Gets the start of this time interval which is inclusive.\n+     *\n+     * @return the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    long getStartMillis();\n+\n+    /**\n+     * Gets the start of this time interval, which is inclusive, as a DateTime.\n+     *\n+     * @return the start of the time interval\n+     */\n+    DateTime getStart();\n+\n+    /** \n+     * Gets the end of this time interval which is exclusive.\n+     *\n+     * @return the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    long getEndMillis();\n+\n+    /** \n+     * Gets the end of this time interval, which is exclusive, as a DateTime.\n+     *\n+     * @return the end of the time interval\n+     */\n+    DateTime getEnd();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this time interval contain the specified instant.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. A zero duration interval cannot contain anything.\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * [09:00 to 10:00) contains 08:59  = false (before start)\n+     * [09:00 to 10:00) contains 09:00  = true\n+     * [09:00 to 10:00) contains 09:59  = true\n+     * [09:00 to 10:00) contains 10:00  = false (equals end)\n+     * [09:00 to 10:00) contains 10:01  = false (after end)\n+     * \n+     * [14:00 to 14:00) contains 14:00  = false (zero duration contains nothing)\n+     * </pre>\n+     *\n+     * @param instant  the instant, null means now\n+     * @return true if this time interval contains the instant\n+     */\n+    boolean contains(ReadableInstant instant);\n+    \n+    /**\n+     * Does this time interval contain the specified time interval.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. The other interval is contained if this interval\n+     * wholly contains, starts, finishes or equals it.\n+     * A zero duration interval cannot contain anything.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The <code>contains</code> method is not related to these states.\n+     * In particular, a zero duration interval is contained at the start of\n+     * a larger interval, but does not overlap (it abuts instead).\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * [09:00 to 10:00) contains [09:00 to 10:00)  = true\n+     * [09:00 to 10:00) contains [09:00 to 09:30)  = true\n+     * [09:00 to 10:00) contains [09:30 to 10:00)  = true\n+     * [09:00 to 10:00) contains [09:15 to 09:45)  = true\n+     * [09:00 to 10:00) contains [09:00 to 09:00)  = true\n+     * \n+     * [09:00 to 10:00) contains [08:59 to 10:00)  = false (otherStart before thisStart)\n+     * [09:00 to 10:00) contains [09:00 to 10:01)  = false (otherEnd after thisEnd)\n+     * [09:00 to 10:00) contains [10:00 to 10:00)  = false (otherStart equals thisEnd)\n+     * \n+     * [14:00 to 14:00) contains [14:00 to 14:00)  = false (zero duration contains nothing)\n+     * </pre>\n+     *\n+     * @param interval  the time interval to compare to, null means a zero duration interval now\n+     * @return true if this time interval contains the time interval\n+     */\n+    boolean contains(ReadableInterval interval);\n+    \n+    /**\n+     * Does this time interval overlap the specified time interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval overlaps another if it shares some common part of the\n+     * datetime continuum. \n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * [09:00 to 10:00) overlaps [08:00 to 08:30)  = false (completely before)\n+     * [09:00 to 10:00) overlaps [08:00 to 09:00)  = false (abuts before)\n+     * [09:00 to 10:00) overlaps [08:00 to 09:30)  = true\n+     * [09:00 to 10:00) overlaps [08:00 to 10:00)  = true\n+     * [09:00 to 10:00) overlaps [08:00 to 11:00)  = true\n+     * \n+     * [09:00 to 10:00) overlaps [09:00 to 09:00)  = false (abuts before)\n+     * [09:00 to 10:00) overlaps [09:00 to 09:30)  = true\n+     * [09:00 to 10:00) overlaps [09:00 to 10:00)  = true\n+     * [09:00 to 10:00) overlaps [09:00 to 11:00)  = true\n+     * \n+     * [09:00 to 10:00) overlaps [09:30 to 09:30)  = true\n+     * [09:00 to 10:00) overlaps [09:30 to 10:00)  = true\n+     * [09:00 to 10:00) overlaps [09:30 to 11:00)  = true\n+     * \n+     * [09:00 to 10:00) overlaps [10:00 to 10:00)  = false (abuts after)\n+     * [09:00 to 10:00) overlaps [10:00 to 11:00)  = false (abuts after)\n+     * \n+     * [09:00 to 10:00) overlaps [10:30 to 11:00)  = false (completely after)\n+     * \n+     * [14:00 to 14:00) overlaps [14:00 to 14:00)  = false (abuts before and after)\n+     * [14:00 to 14:00) overlaps [13:00 to 15:00)  = true\n+     * </pre>\n+     *\n+     * @param interval  the time interval to compare to, null means a zero length interval now\n+     * @return true if the time intervals overlap\n+     */\n+    boolean overlaps(ReadableInterval interval);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this time interval after the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is after the instant\n+     */\n+    boolean isAfter(ReadableInstant instant);\n+    \n+    /**\n+     * Is this time interval entirely after the specified interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the interval to compare to, null means now\n+     * @return true if this time interval is after the interval specified\n+     */\n+    boolean isAfter(ReadableInterval interval);\n+    \n+    /**\n+     * Is this time interval before the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is before the instant\n+     */\n+    boolean isBefore(ReadableInstant instant);\n+    \n+    /**\n+     * Is this time interval entirely before the specified interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the interval to compare to, null means now\n+     * @return true if this time interval is before the interval specified\n+     */\n+    boolean isBefore(ReadableInterval interval);\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this interval as an immutable <code>Interval</code> object.\n+     * <p>\n+     * This will either typecast this instance, or create a new <code>Interval</code>.\n+     *\n+     * @return the interval as an Interval object\n+     */\n+    Interval toInterval();\n+\n+    /**\n+     * Get this time interval as a <code>MutableInterval</code>.\n+     * <p>\n+     * This will always return a new <code>MutableInterval</code> with the same interval.\n+     *\n+     * @return the time interval as a MutableInterval object\n+     */\n+    MutableInterval toMutableInterval();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millisecond duration of this time interval.\n+     *\n+     * @return the millisecond duration of the time interval\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    Duration toDuration();\n+\n+    /**\n+     * Gets the millisecond duration of this time interval.\n+     *\n+     * @return the millisecond duration of the time interval\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    long toDurationMillis();\n+\n+    /**\n+     * Converts the duration of the interval to a period using the\n+     * standard period type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     *\n+     * @return a time period derived from the interval\n+     */\n+    Period toPeriod();\n+\n+    /**\n+     * Converts the duration of the interval to a period using the\n+     * specified period type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     *\n+     * @param type  the requested type of the duration, null means standard\n+     * @return a time period derived from the interval\n+     */\n+    Period toPeriod(PeriodType type);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on start and end millis plus the chronology.\n+     * All ReadableInterval instances are accepted.\n+     * <p>\n+     * To compare the duration of two time intervals, use {@link #toDuration()}\n+     * to get the durations and compare those.\n+     *\n+     * @param readableInterval  a readable interval to check against\n+     * @return true if the start and end millis are equal\n+     */\n+    boolean equals(Object readableInterval);\n+\n+    /**\n+     * Gets a hash code for the time interval that is compatable with the \n+     * equals method.\n+     * <p>\n+     * The formula used must be as follows:\n+     * <pre>int result = 97;\n+     * result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32)));\n+     * result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32)));\n+     * result = 31 * result + getChronology().hashCode();\n+     * return result;</pre>\n+     *\n+     * @return a hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in the ISO8601 interval format.\n+     * <p>\n+     * For example, \"2004-06-09T12:30:00.000/2004-07-10T13:30:00.000\".\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadablePartial.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a partial time that does not support every datetime field, and is\n+ * thus a local time.\n+ * <p>\n+ * A <code>ReadablePartial</code> supports a subset of those fields on the chronology.\n+ * It cannot be compared to a <code>ReadableInstant</code>, as it does not fully\n+ * specify an instant in time. The time it does specify is a local time, and does\n+ * not include a time zone.\n+ * <p>\n+ * A <code>ReadablePartial</code> can be converted to a <code>ReadableInstant</code>\n+ * using the <code>toDateTime</code> method. This works by providing a full base\n+ * instant that can be used to 'fill in the gaps' and specify a time zone.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadablePartial {\n+\n+    /**\n+     * Gets the number of fields that this partial supports.\n+     *\n+     * @return the number of fields supported\n+     */\n+    int size();\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    DateTimeFieldType getFieldType(int index);\n+\n+    /**\n+     * Gets the field at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    DateTimeField getField(int index);\n+\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    int getValue(int index);\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology, never null\n+     */\n+    Chronology getChronology();\n+\n+    /**\n+     * Gets the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the partial.\n+     *\n+     * @param field  a DateTimeFieldType instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    int get(DateTimeFieldType field);\n+\n+    /**\n+     * Checks whether the field type specified is supported by this partial.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    boolean isSupported(DateTimeFieldType field);\n+\n+    /**\n+     * Converts this partial to a full datetime by resolving it against another\n+     * datetime.\n+     * <p>\n+     * This method takes the specified datetime and sets the fields from this\n+     * instant on top. The chronology from the base instant is used.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n+     * @param baseInstant  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    DateTime toDateTime(ReadableInstant baseInstant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this partial with the specified object for equality based\n+     * on the supported fields, chronology and values.\n+     * <p>\n+     * Two instances of ReadablePartial are equal if they have the same\n+     * chronology, same field types (in same order) and same values.\n+     *\n+     * @param partial  the object to compare to\n+     * @return true if equal\n+     */\n+    boolean equals(Object partial);\n+\n+    /**\n+     * Gets a hash code for the partial that is compatible with the \n+     * equals method.\n+     * <p>\n+     * The formula used must be:\n+     * <pre>\n+     *  int total = 157;\n+     *  for (int i = 0; i < fields.length; i++) {\n+     *      total = 23 * total + values[i];\n+     *      total = 23 * total + fieldTypes[i].hashCode();\n+     *  }\n+     *  total += chronology.hashCode();\n+     *  return total;\n+     * </pre>\n+     *\n+     * @return a suitable hash code\n+     */\n+    int hashCode();\n+\n+// NOTE: This method should have existed in Joda-Time v1.0.\n+// We STRONGLY recommend that all implementations of ReadablePartial\n+// implement this method, as per AbstractPartial.\n+// The simplest way to do this is to extend AbstractPartial.\n+// v2.0 of Joda-Time will include this method in this interface.\n+//    //-----------------------------------------------------------------------\n+//    /**\n+//     * Compares this partial with another returning an integer\n+//     * indicating the order.\n+//     * <p>\n+//     * The fields are compared in order, from largest to smallest.\n+//     * The first field that is non-equal is used to determine the result.\n+//     * Thus a YearHour partial will first be compared on the year, and then\n+//     * on the hour.\n+//     * <p>\n+//     * The specified object must be a partial instance whose field types\n+//     * match those of this partial. If the parial instance has different\n+//     * fields then a ClassCastException is thrown.\n+//     *\n+//     * @param partial  an object to check against\n+//     * @return negative if this is less, zero if equal, positive if greater\n+//     * @throws ClassCastException if the partial is the wrong class\n+//     *  or if it has field types that don't match\n+//     * @throws NullPointerException if the partial is null\n+//     * @since 2.0\n+//     */\n+//    int compareTo(Object partial);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value as a String in a recognisable ISO8601 format, only\n+     * displaying supported fields.\n+     * <p>\n+     * The string output is in ISO8601 format to enable the String\n+     * constructor to correctly parse it.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/ReadablePeriod.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+/**\n+ * Defines a time period specified in terms of individual duration fields\n+ * such as years and days.\n+ * <p>\n+ * The implementation of this interface may be mutable or immutable. This\n+ * interface only gives access to retrieve data, never to change it.\n+ * <p>\n+ * Periods are split up into multiple fields, for example days and seconds.\n+ * Implementations are not required to evenly distribute the values across the fields.\n+ * The value for each field may be positive or negative.\n+ * <p>\n+ * When a time period is added to an instant, the effect is to add each field in turn.\n+ * For example, a time period could be defined as 3 months, 2 days and -1 hours.\n+ * In most circumstances this would be the same as 3 months, 1 day, and 23 hours.\n+ * However, when adding across a daylight savings boundary, a day may be 23 or 25 hours long.\n+ * Thus, the time period is always added field by field to the datetime.\n+ * <p>\n+ * Periods are independent of chronology, and can only be treated as durations\n+ * when paired with a time via an interval.\n+ *\n+ * @see ReadableDuration\n+ * @see ReadableInterval\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface ReadablePeriod {\n+\n+    /**\n+     * Gets the period type that defines which fields are included in the period.\n+     *\n+     * @return the period type\n+     */\n+    PeriodType getPeriodType();\n+\n+    /**\n+     * Gets the number of fields that this period supports.\n+     *\n+     * @return the number of fields supported\n+     */\n+    int size();\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    DurationFieldType getFieldType(int index);\n+\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    int getValue(int index);\n+\n+    /**\n+     * Gets the value of one of the fields.\n+     * <p>\n+     * If the field type specified is not supported by the period then zero\n+     * is returned.\n+     *\n+     * @param field  the field type to query, null returns zero\n+     * @return the value of that field, zero if field not supported\n+     */\n+    int get(DurationFieldType field);\n+\n+    /**\n+     * Checks whether the field type specified is supported by this period.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    boolean isSupported(DurationFieldType field);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this period as an immutable <code>Period</code> object.\n+     * <p>\n+     * This will either typecast this instance, or create a new <code>Period</code>.\n+     * \n+     * @return a Duration using the same field set and values\n+     */\n+    Period toPeriod();\n+\n+    /**\n+     * Get this object as a <code>MutablePeriod</code>.\n+     * <p>\n+     * This will always return a new <code>MutablePeriod</code> with the same fields.\n+     * \n+     * @return a MutablePeriod using the same field set and values\n+     */\n+    MutablePeriod toMutablePeriod();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value and type of each supported field.\n+     * All ReadablePeriod instances are accepted.\n+     * <p>\n+     * Note that a period of 1 day is not equal to a period of 24 hours,\n+     * nor is 1 hour equal to 60 minutes. Only periods with the same amount\n+     * in each field are equal.\n+     * <p>\n+     * This is because periods represent an abstracted definition of a time\n+     * period (eg. a day may not actually be 24 hours, it might be 23 or 25\n+     * at daylight savings boundary).\n+     * <p>\n+     * To compare the actual duration of two periods, convert both to\n+     * {@link Duration}s, an operation that emphasises that the result may\n+     * differ according to the date you choose.\n+     *\n+     * @param readablePeriod  a readable period to check against\n+     * @return true if all the field values and types are equal, false if\n+     *  not or the period is null or of an incorrect type\n+     */\n+    boolean equals(Object readablePeriod);\n+\n+    /**\n+     * Gets a hash code for the period that is compatible with the equals method.\n+     * The hashcode is calculated as follows:\n+     * <pre>\n+     *  int total = 17;\n+     *  for (int i = 0; i < fields.length; i++) {\n+     *      total = 27 * total + getValue(i);\n+     *      total = 27 * total + getFieldType(i).hashCode();\n+     *  }\n+     *  return total;\n+     * </pre>\n+     *\n+     * @return a hash code\n+     */\n+    int hashCode();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the style of the ISO8601 duration format.\n+     * Technically, the output can breach the ISO specification as weeks may be included.\n+     * <p>\n+     * For example, \"PT6H3M5S\" represents 6 hours, 3 minutes, 5 seconds.\n+     *\n+     * @return the value as an ISO8601 style string\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Seconds.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of seconds.\n+ * <p>\n+ * <code>Seconds</code> is an immutable period that can only store seconds.\n+ * It does not store years, months or hours for example. As such it is a\n+ * type-safe way of representing a number of seconds in an application.\n+ * <p>\n+ * The number of seconds is set in the constructor, and may be queried using\n+ * <code>getSeconds()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Seconds</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Seconds extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero seconds. */\n+    public static final Seconds ZERO = new Seconds(0);\n+    /** Constant representing one second. */\n+    public static final Seconds ONE = new Seconds(1);\n+    /** Constant representing two seconds. */\n+    public static final Seconds TWO = new Seconds(2);\n+    /** Constant representing three seconds. */\n+    public static final Seconds THREE = new Seconds(3);\n+    /** Constant representing the maximum number of seconds that can be stored in this object. */\n+    public static final Seconds MAX_VALUE = new Seconds(Integer.MAX_VALUE);\n+    /** Constant representing the minimum number of seconds that can be stored in this object. */\n+    public static final Seconds MIN_VALUE = new Seconds(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.seconds());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380862L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Seconds</code> that may be cached.\n+     * <code>Seconds</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param seconds  the number of seconds to obtain an instance for\n+     * @return the instance of Seconds\n+     */\n+    public static Seconds seconds(int seconds) {\n+        switch (seconds) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Seconds(seconds);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Seconds</code> representing the number of whole seconds\n+     * between the two specified datetimes.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Seconds secondsBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.seconds());\n+        return Seconds.seconds(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Seconds</code> representing the number of whole seconds\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalTime</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Seconds secondsBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalTime && end instanceof LocalTime)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int seconds = chrono.seconds().getDifference(\n+                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n+            return Seconds.seconds(seconds);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Seconds.seconds(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Seconds</code> representing the number of whole seconds\n+     * in the specified interval.\n+     *\n+     * @param interval  the interval to extract seconds from, null returns zero\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Seconds secondsIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Seconds.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds());\n+        return Seconds.seconds(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Seconds</code> representing the number of complete\n+     * standard length seconds in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 seconds.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, null returns zero\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Seconds standardSecondsIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_SECOND);\n+        return Seconds.seconds(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Seconds</code> by parsing a string in the ISO8601 format 'PTnS'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * seconds component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in seconds\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Seconds parseSeconds(String periodStr) {\n+        if (periodStr == null) {\n+            return Seconds.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Seconds.seconds(p.getSeconds());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of seconds.\n+     * You should consider using the factory method {@link #seconds(int)}\n+     * instead of the constructor.\n+     *\n+     * @param seconds  the number of seconds to represent\n+     */\n+    private Seconds(int seconds) {\n+        super(seconds);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Seconds.seconds(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>seconds</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.seconds();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>seconds</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.seconds();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in seconds to a period in weeks assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are 7 days\n+     * long, all days are 24 hours long, all hours are 60 minutes long and\n+     * all minutes are 60 seconds long.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of whole weeks for this number of seconds\n+     */\n+    public Weeks toStandardWeeks() {\n+        return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Converts this period in seconds to a period in days assuming a\n+     * 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all days are 24 hours\n+     * long, all hours are 60 minutes long and all minutes are 60 seconds long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of days for this number of seconds\n+     */\n+    public Days toStandardDays() {\n+        return Days.days(getValue() / DateTimeConstants.SECONDS_PER_DAY);\n+    }\n+\n+    /**\n+     * Converts this period in seconds to a period in hours assuming a\n+     * 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all hours are\n+     * 60 minutes long and all minutes are 60 seconds long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of seconds\n+     */\n+    public Hours toStandardHours() {\n+        return Hours.hours(getValue() / DateTimeConstants.SECONDS_PER_HOUR);\n+    }\n+\n+    /**\n+     * Converts this period in seconds to a period in minutes assuming a\n+     * 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all minutes are\n+     * 60 seconds long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of minutes for this number of seconds\n+     */\n+    public Minutes toStandardMinutes() {\n+        return Minutes.minutes(getValue() / DateTimeConstants.SECONDS_PER_MINUTE);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in seconds to a duration in milliseconds assuming a\n+     * 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all seconds are 24 hours\n+     * long, all hours are 60 minutes and all minutes are 60 seconds.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a duration equivalent to this number of seconds\n+     */\n+    public Duration toStandardDuration() {\n+        long seconds = getValue();  // assign to a long\n+        return new Duration(seconds * DateTimeConstants.MILLIS_PER_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of seconds that this period represents.\n+     *\n+     * @return the number of seconds in the period\n+     */\n+    public int getSeconds() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of seconds added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new period plus the specified number of seconds\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds plus(int seconds) {\n+        if (seconds == 0) {\n+            return this;\n+        }\n+        return Seconds.seconds(FieldUtils.safeAdd(getValue(), seconds));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of seconds added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative, null means zero\n+     * @return the new period plus the specified number of seconds\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds plus(Seconds seconds) {\n+        if (seconds == null) {\n+            return this;\n+        }\n+        return plus(seconds.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of seconds taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to take away, may be negative\n+     * @return the new period minus the specified number of seconds\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds minus(int seconds) {\n+        return plus(FieldUtils.safeNegate(seconds));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of seconds taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param seconds  the amount of seconds to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of seconds\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds minus(Seconds seconds) {\n+        if (seconds == null) {\n+            return this;\n+        }\n+        return minus(seconds.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the seconds multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds multipliedBy(int scalar) {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the seconds divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Seconds dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Seconds.seconds(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the seconds value negated.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Seconds negated() {\n+        return Seconds.seconds(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this seconds instance greater than the specified number of seconds.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this seconds instance is greater than the specified one\n+     */\n+    public boolean isGreaterThan(Seconds other) {\n+        if (other == null) {\n+            return getValue() > 0;\n+        }\n+        return getValue() > other.getValue();\n+    }\n+\n+    /**\n+     * Is this seconds instance less than the specified number of seconds.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this seconds instance is less than the specified one\n+     */\n+    public boolean isLessThan(Seconds other) {\n+        if (other == null) {\n+            return getValue() < 0;\n+        }\n+        return getValue() < other.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"PT4S\" represents 4 seconds.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"PT\" + String.valueOf(getValue()) + \"S\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/TimeOfDay.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BasePartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * TimeOfDay is an immutable partial supporting the hour, minute, second\n+ * and millisecond fields.\n+ * <p>\n+ * NOTE: This class only supports the four fields listed above. Thus, you\n+ * cannot query the millisOfDay or secondOfDay fields for example.\n+ * The new <code>LocalTime</code> class removes this restriction.\n+ * <p>\n+ * Calculations on TimeOfDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>hourOfDay().get()</code>\n+ * <li>text value - <code>hourOfDay().getAsText()</code>\n+ * <li>short text value - <code>hourOfDay().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>hourOfDay().getMaximumValue()</code>\n+ * <li>add/subtract - <code>hourOfDay().addToCopy()</code>\n+ * <li>set - <code>hourOfDay().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @deprecated Use LocalTime which has a much better internal implementation and\n+ *  has been available since 1.3\n+ */\n+public final class TimeOfDay\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n+    // NOTE: No toDateTime(YearMonthDay) as semantics are confusing when\n+    // different chronologies\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3633353405803318660L;\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.hourOfDay(),\n+        DateTimeFieldType.minuteOfHour(),\n+        DateTimeFieldType.secondOfMinute(),\n+        DateTimeFieldType.millisOfSecond(),\n+    };\n+\n+    /** Constant for midnight. */\n+    public static final TimeOfDay MIDNIGHT = new TimeOfDay(0, 0, 0, 0);\n+\n+    /** The index of the hourOfDay field in the field array */\n+    public static final int HOUR_OF_DAY = 0;\n+    /** The index of the minuteOfHour field in the field array */\n+    public static final int MINUTE_OF_HOUR = 1;\n+    /** The index of the secondOfMinute field in the field array */\n+    public static final int SECOND_OF_MINUTE = 2;\n+    /** The index of the millisOfSecond field in the field array */\n+    public static final int MILLIS_OF_SECOND = 3;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TimeOfDay from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the TimeOfDay.\n+     * This is useful to ensure that the field values are the same in the\n+     * created TimeOfDay no matter what the time zone is. For example, if\n+     * the Calendar states that the time is 04:29, then the created TimeOfDay\n+     * will always have the time 04:29 irrespective of time zone issues.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a TimeOfDay with ISO chronology.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created TimeOfDay\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the time is invalid for the ISO chronology\n+     * @since 1.2\n+     */\n+    public static TimeOfDay fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new TimeOfDay(\n+            calendar.get(Calendar.HOUR_OF_DAY),\n+            calendar.get(Calendar.MINUTE),\n+            calendar.get(Calendar.SECOND),\n+            calendar.get(Calendar.MILLISECOND)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the TimeOfDay.\n+     * This is useful to ensure that the field values are the same in the\n+     * created TimeOfDay no matter what the time zone is. For example, if\n+     * the Calendar states that the time is 04:29, then the created TimeOfDay\n+     * will always have the time 04:29 irrespective of time zone issues.\n+     * <p>\n+     * This factory method always creates a TimeOfDay with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created TimeOfDay\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     * @since 1.2\n+     */\n+    public static TimeOfDay fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new TimeOfDay(\n+            date.getHours(),\n+            date.getMinutes(),\n+            date.getSeconds(),\n+            (((int) (date.getTime() % 1000)) + 1000) % 1000\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TimeOfDay from the specified millis of day using the\n+     * ISO chronology.\n+     * <p>\n+     * The millisOfDay value may exceed the number of millis in one day,\n+     * but additional days will be ignored.\n+     * This method uses the UTC time zone internally.\n+     *\n+     * @param millisOfDay  the number of milliseconds into a day to convert\n+     */\n+    public static TimeOfDay fromMillisOfDay(long millisOfDay) {\n+        return fromMillisOfDay(millisOfDay, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from the specified millis of day using the\n+     * specified chronology.\n+     * <p>\n+     * The millisOfDay value may exceed the number of millis in one day,\n+     * but additional days will be ignored.\n+     * This method uses the UTC time zone internally.\n+     *\n+     * @param millisOfDay  the number of milliseconds into a day to convert\n+     * @param chrono  the chronology, null means ISO chronology\n+     */\n+    public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        chrono = chrono.withUTC();\n+        return new TimeOfDay(millisOfDay, chrono);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TimeOfDay with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    public TimeOfDay() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with the current time, using ISOChronology in\n+     * the specified zone to extract the fields.\n+     * <p>\n+     * The constructor uses the specified time zone to obtain the current time.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     * \n+     * @param zone  the zone to use, null means default zone\n+     * @since 1.1\n+     */\n+    public TimeOfDay(DateTimeZone zone) {\n+        super(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public TimeOfDay(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.\n+     * <p>\n+     * The chronology used will be derived from the object, defaulting to ISO.\n+     * <p>\n+     * NOTE: Prior to v1.3 the string format was described by\n+     * {@link ISODateTimeFormat#dateTimeParser()}. Dates are now rejected.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public TimeOfDay(Object instant) {\n+        super(instant, null, ISODateTimeFormat.timeParser());\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     * The specified chronology overrides that of the object.\n+     * <p>\n+     * NOTE: Prior to v1.3 the string format was described by\n+     * {@link ISODateTimeFormat#dateTimeParser()}. Dates are now rejected.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISO default\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public TimeOfDay(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser());\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds\n+     * using <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour) {\n+        this(hourOfDay, minuteOfHour, 0, 0, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {\n+        this(hourOfDay, minuteOfHour, 0, 0, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and zero milliseconds\n+     * using <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and zero milliseconds.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values using\n+     * <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {\n+        this(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, null);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with specified time field values and chronology.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public TimeOfDay(int hourOfDay, int minuteOfHour,\n+            int secondOfMinute, int millisOfSecond, Chronology chronology) {\n+        super(new int[] {hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with chronology from this instance and new values.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    TimeOfDay(TimeOfDay partial, int[] values) {\n+        super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a TimeOfDay with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    TimeOfDay(TimeOfDay partial, Chronology chrono) {\n+        super(partial, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int size() {\n+        return 4;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case HOUR_OF_DAY:\n+                return chrono.hourOfDay();\n+            case MINUTE_OF_HOUR:\n+                return chrono.minuteOfHour();\n+            case SECOND_OF_MINUTE:\n+                return chrono.secondOfMinute();\n+            case MILLIS_OF_SECOND:\n+                return chrono.millisOfSecond();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, Hour, Minute, Second, Millis.\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as TimeOfDay\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public TimeOfDay withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology);\n+            newChronology.validate(newTimeOfDay, getValues());\n+            return newTimeOfDay;\n+        }\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>minuteOfHour</code> then the day\n+     * would be changed in the returned instance.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6);\n+     * TimeOfDay updated = tod.minuteOfHour().setCopy(6);\n+     * TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public TimeOfDay withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the value of the specified field increased,\n+     * wrapping to what would be a new day if required.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * TimeOfDay added = tod.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * TimeOfDay added = tod.plusMinutes(6);\n+     * TimeOfDay added = tod.minuteOfHour().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the specified period added,\n+     * wrapping to what would be a new day if required.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusHours(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).addWrapPartial(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the specified period added,\n+     * wrapping to what would be a new day if required.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusHours(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public TimeOfDay plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time plus the specified number of hours.\n+     * <p>\n+     * This time instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay added = dt.plusHours(6);\n+     * TimeOfDay added = dt.plus(Period.hours(6));\n+     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to add, may be negative\n+     * @return the new time plus the increased hours\n+     * @since 1.1\n+     */\n+    public TimeOfDay plusHours(int hours) {\n+        return withFieldAdded(DurationFieldType.hours(), hours);\n+    }\n+\n+    /**\n+     * Returns a copy of this time plus the specified number of minutes.\n+     * <p>\n+     * This time instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay added = dt.plusMinutes(6);\n+     * TimeOfDay added = dt.plus(Period.minutes(6));\n+     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to add, may be negative\n+     * @return the new time plus the increased minutes\n+     * @since 1.1\n+     */\n+    public TimeOfDay plusMinutes(int minutes) {\n+        return withFieldAdded(DurationFieldType.minutes(), minutes);\n+    }\n+\n+    /**\n+     * Returns a copy of this time plus the specified number of seconds.\n+     * <p>\n+     * This time instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay added = dt.plusSeconds(6);\n+     * TimeOfDay added = dt.plus(Period.seconds(6));\n+     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to add, may be negative\n+     * @return the new time plus the increased seconds\n+     * @since 1.1\n+     */\n+    public TimeOfDay plusSeconds(int seconds) {\n+        return withFieldAdded(DurationFieldType.seconds(), seconds);\n+    }\n+\n+    /**\n+     * Returns a copy of this time plus the specified number of millis.\n+     * <p>\n+     * This time instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay added = dt.plusMillis(6);\n+     * TimeOfDay added = dt.plus(Period.millis(6));\n+     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to add, may be negative\n+     * @return the new time plus the increased millis\n+     * @since 1.1\n+     */\n+    public TimeOfDay plusMillis(int millis) {\n+        return withFieldAdded(DurationFieldType.millis(), millis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the specified period taken away,\n+     * wrapping to what would be a new day if required.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusHours(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new time exceeds capacity\n+     */\n+    public TimeOfDay minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time minus the specified number of hours.\n+     * <p>\n+     * This time instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay subtracted = dt.minusHours(6);\n+     * TimeOfDay subtracted = dt.minus(Period.hours(6));\n+     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n+     * </pre>\n+     *\n+     * @param hours  the amount of hours to subtract, may be negative\n+     * @return the new time minus the increased hours\n+     * @since 1.1\n+     */\n+    public TimeOfDay minusHours(int hours) {\n+        return withFieldAdded(DurationFieldType.hours(), FieldUtils.safeNegate(hours));\n+    }\n+\n+    /**\n+     * Returns a copy of this time minus the specified number of minutes.\n+     * <p>\n+     * This time instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay subtracted = dt.minusMinutes(6);\n+     * TimeOfDay subtracted = dt.minus(Period.minutes(6));\n+     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n+     * </pre>\n+     *\n+     * @param minutes  the amount of minutes to subtract, may be negative\n+     * @return the new time minus the increased minutes\n+     * @since 1.1\n+     */\n+    public TimeOfDay minusMinutes(int minutes) {\n+        return withFieldAdded(DurationFieldType.minutes(), FieldUtils.safeNegate(minutes));\n+    }\n+\n+    /**\n+     * Returns a copy of this time minus the specified number of seconds.\n+     * <p>\n+     * This time instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay subtracted = dt.minusSeconds(6);\n+     * TimeOfDay subtracted = dt.minus(Period.seconds(6));\n+     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n+     * </pre>\n+     *\n+     * @param seconds  the amount of seconds to subtract, may be negative\n+     * @return the new time minus the increased seconds\n+     * @since 1.1\n+     */\n+    public TimeOfDay minusSeconds(int seconds) {\n+        return withFieldAdded(DurationFieldType.seconds(), FieldUtils.safeNegate(seconds));\n+    }\n+\n+    /**\n+     * Returns a copy of this time minus the specified number of millis.\n+     * <p>\n+     * This time instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay subtracted = dt.minusMillis(6);\n+     * TimeOfDay subtracted = dt.minus(Period.millis(6));\n+     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n+     * </pre>\n+     *\n+     * @param millis  the amount of millis to subtract, may be negative\n+     * @return the new time minus the increased millis\n+     * @since 1.1\n+     */\n+    public TimeOfDay minusMillis(int millis) {\n+        return withFieldAdded(DurationFieldType.millis(), FieldUtils.safeNegate(millis));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalTime with the same time and chronology.\n+     *\n+     * @return a LocalTime with the same time and chronology\n+     * @since 1.3\n+     */\n+    public LocalTime toLocalTime() {\n+        return new LocalTime(getHourOfDay(), getMinuteOfHour(),\n+                getSecondOfMinute(), getMillisOfSecond(), getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this partial to a full datetime using the default time zone\n+     * setting the time fields from this instance and the date fields from\n+     * the current time.\n+     *\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeToday() {\n+        return toDateTimeToday(null);\n+    }\n+\n+    /**\n+     * Converts this partial to a full datetime using the specified time zone\n+     * setting the time fields from this instance and the date fields from\n+     * the current time.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeToday(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instantMillis = DateTimeUtils.currentTimeMillis();\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getValue(HOUR_OF_DAY);\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getValue(MINUTE_OF_HOUR);\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getValue(SECOND_OF_MINUTE);\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getValue(MILLIS_OF_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this time with the hour of day field updated.\n+     * <p>\n+     * TimeOfDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * hour of day changed.\n+     *\n+     * @param hour  the hour of day to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public TimeOfDay withHourOfDay(int hour) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the minute of hour field updated.\n+     * <p>\n+     * TimeOfDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * minute of hour changed.\n+     *\n+     * @param minute  the minute of hour to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public TimeOfDay withMinuteOfHour(int minute) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the second of minute field updated.\n+     * <p>\n+     * TimeOfDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * second of minute changed.\n+     *\n+     * @param second  the second of minute to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public TimeOfDay withSecondOfMinute(int second) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this time with the millis of second field updated.\n+     * <p>\n+     * TimeOfDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * millis of second changed.\n+     *\n+     * @param millis  the millis of second to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public TimeOfDay withMillisOfSecond(int millis) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field property which provides access to advanced functionality.\n+     * \n+     * @return the hour of day property\n+     */\n+    public Property hourOfDay() {\n+        return new Property(this, HOUR_OF_DAY);\n+    }\n+\n+    /**\n+     * Get the minute of hour field property which provides access to advanced functionality.\n+     * \n+     * @return the minute of hour property\n+     */\n+    public Property minuteOfHour() {\n+        return new Property(this, MINUTE_OF_HOUR);\n+    }\n+\n+    /**\n+     * Get the second of minute field property which provides access to advanced functionality.\n+     * \n+     * @return the second of minute property\n+     */\n+    public Property secondOfMinute() {\n+        return new Property(this, SECOND_OF_MINUTE);\n+    }\n+\n+    /**\n+     * Get the millis of second property which provides access to advanced functionality.\n+     * \n+     * @return the millis of second property\n+     */\n+    public Property millisOfSecond() {\n+        return new Property(this, MILLIS_OF_SECOND);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the time in the ISO8601 format THH:mm:ss.SSS.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.tTime().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>TimeOfDay</code>.\n+     * <p>\n+     * This class binds a <code>TimeOfDay</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.0\n+     * @deprecated Use LocalTime which has a much better internal implementation\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 5598459141741063833L;\n+\n+        /** The partial */\n+        private final TimeOfDay iTimeOfDay;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(TimeOfDay partial, int fieldIndex) {\n+            super();\n+            iTimeOfDay = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iTimeOfDay.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iTimeOfDay;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public TimeOfDay getTimeOfDay() {\n+            return iTimeOfDay;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iTimeOfDay.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay,\n+         * wrapping to what would be the next day if necessary.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond 23:59:59:999, then the\n+         * calculation wraps to 00:00:00.000. For the alternate strict behaviour\n+         * with no wrapping see {@link #addNoWrapToCopy(int)}.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public TimeOfDay addToCopy(int valueToAdd) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay,\n+         * throwing an Exception if the bounds are exceeded.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large (beyond 23:59:59:999) or too\n+         * small (less than 00:00:00.000) then an Execption is thrown.\n+         * For the alternate behaviour which wraps to the next 'day',\n+         * see {@link #addToCopy(int)}.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public TimeOfDay addNoWrapToCopy(int valueToAdd) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public TimeOfDay addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the TimeOfDay.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public TimeOfDay setCopy(int value) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public TimeOfDay setCopy(String text, Locale locale) {\n+            int[] newValues = iTimeOfDay.getValues();\n+            newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);\n+            return new TimeOfDay(iTimeOfDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the TimeOfDay to a parsed text value.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public TimeOfDay setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new TimeOfDay with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the TimeOfDay with this field set to its maximum\n+         * @since 1.2\n+         */\n+        public TimeOfDay withMaximumValue() {\n+            return setCopy(getMaximumValue());\n+        }\n+\n+        /**\n+         * Returns a new TimeOfDay with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the TimeOfDay with this field set to its minimum\n+         * @since 1.2\n+         */\n+        public TimeOfDay withMinimumValue() {\n+            return setCopy(getMinimumValue());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Weeks.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of weeks.\n+ * <p>\n+ * <code>Weeks</code> is an immutable period that can only store weeks.\n+ * It does not store years, months or hours for example. As such it is a\n+ * type-safe way of representing a number of weeks in an application.\n+ * <p>\n+ * The number of weeks is set in the constructor, and may be queried using\n+ * <code>getWeeks()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Weeks</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Weeks extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero weeks. */\n+    public static final Weeks ZERO = new Weeks(0);\n+    /** Constant representing one week. */\n+    public static final Weeks ONE = new Weeks(1);\n+    /** Constant representing two weeks. */\n+    public static final Weeks TWO = new Weeks(2);\n+    /** Constant representing three weeks. */\n+    public static final Weeks THREE = new Weeks(3);\n+    /** Constant representing the maximum number of weeks that can be stored in this object. */\n+    public static final Weeks MAX_VALUE = new Weeks(Integer.MAX_VALUE);\n+    /** Constant representing the minimum number of weeks that can be stored in this object. */\n+    public static final Weeks MIN_VALUE = new Weeks(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.weeks());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380866L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Weeks</code> that may be cached.\n+     * <code>Weeks</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param weeks  the number of weeks to obtain an instance for\n+     * @return the instance of Weeks\n+     */\n+    public static Weeks weeks(int weeks) {\n+        switch (weeks) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Weeks(weeks);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Weeks</code> representing the number of whole weeks\n+     * between the two specified datetimes.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Weeks weeksBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.weeks());\n+        return Weeks.weeks(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Weeks</code> representing the number of whole weeks\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Weeks weeksBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalDate && end instanceof LocalDate)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int weeks = chrono.weeks().getDifference(\n+                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n+            return Weeks.weeks(weeks);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Weeks.weeks(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Weeks</code> representing the number of whole weeks\n+     * in the specified interval.\n+     *\n+     * @param interval  the interval to extract weeks from, null returns zero\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Weeks weeksIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Weeks.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks());\n+        return Weeks.weeks(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Weeks</code> representing the number of complete\n+     * standard length weeks in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 weeks.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, null returns zero\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    public static Weeks standardWeeksIn(ReadablePeriod period) {\n+        int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_WEEK);\n+        return Weeks.weeks(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Weeks</code> by parsing a string in the ISO8601 format 'PnW'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * weeks component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in weeks\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Weeks parseWeeks(String periodStr) {\n+        if (periodStr == null) {\n+            return Weeks.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Weeks.weeks(p.getWeeks());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of weeks.\n+     * You should consider using the factory method {@link #weeks(int)}\n+     * instead of the constructor.\n+     *\n+     * @param weeks  the number of weeks to represent\n+     */\n+    private Weeks(int weeks) {\n+        super(weeks);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Weeks.weeks(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>weeks</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.weeks();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>weeks</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.weeks();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in weeks to a period in days assuming a\n+     * 7 day week.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long.\n+     * This may not be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of days for this number of weeks\n+     * @throws ArithmeticException if the number of days is too large to be represented\n+     */\n+    public Days toStandardDays() {\n+        return Days.days(FieldUtils.safeMultiply(getValue(), DateTimeConstants.DAYS_PER_WEEK));\n+    }\n+\n+    /**\n+     * Converts this period in weeks to a period in hours assuming a\n+     * 7 day week and 24 hour day.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long and all days are 24 hours long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of hours for this number of weeks\n+     * @throws ArithmeticException if the number of hours is too large to be represented\n+     */\n+    public Hours toStandardHours() {\n+        return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_WEEK));\n+    }\n+\n+    /**\n+     * Converts this period in weeks to a period in minutes assuming a\n+     * 7 day week, 24 hour day and 60 minute hour.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of minutes for this number of weeks\n+     * @throws ArithmeticException if the number of minutes is too large to be represented\n+     */\n+    public Minutes toStandardMinutes() {\n+        return Minutes.minutes(FieldUtils.safeMultiply(getValue(), DateTimeConstants.MINUTES_PER_WEEK));\n+    }\n+\n+    /**\n+     * Converts this period in weeks to a period in seconds assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert between different types of period.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long, all days are 24 hours long, all hours are 60 minutes long\n+     * and all minutes are 60 seconds long.\n+     * This is not true when daylight savings is considered and may also not\n+     * be true for some unusual chronologies. However, it is included\n+     * as it is a useful operation for many applications and business rules.\n+     * \n+     * @return a period representing the number of seconds for this number of weeks\n+     * @throws ArithmeticException if the number of seconds is too large to be represented\n+     */\n+    public Seconds toStandardSeconds() {\n+        return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_WEEK));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this period in weeks to a duration in milliweeks assuming a\n+     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n+     * <p>\n+     * This method allows you to convert from a period to a duration.\n+     * However to achieve this it makes the assumption that all weeks are\n+     * 7 days long, all days are 24 hours long, all hours are 60 minutes long\n+     * and all minutes are 60 seconds long.\n+     * This is not true when daylight savings time is considered, and may also\n+     * not be true for some unusual chronologies. However, it is included as it\n+     * is a useful operation for many applications and business rules.\n+     * \n+     * @return a duration equivalent to this number of weeks\n+     */\n+    public Duration toStandardDuration() {\n+        long weeks = getValue();  // assign to a long\n+        return new Duration(weeks * DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of weeks that this period represents.\n+     *\n+     * @return the number of weeks in the period\n+     */\n+    public int getWeeks() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of weeks added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative\n+     * @return the new period plus the specified number of weeks\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks plus(int weeks) {\n+        if (weeks == 0) {\n+            return this;\n+        }\n+        return Weeks.weeks(FieldUtils.safeAdd(getValue(), weeks));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of weeks added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to add, may be negative, null means zero\n+     * @return the new period plus the specified number of weeks\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks plus(Weeks weeks) {\n+        if (weeks == null) {\n+            return this;\n+        }\n+        return plus(weeks.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of weeks taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to take away, may be negative\n+     * @return the new period minus the specified number of weeks\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks minus(int weeks) {\n+        return plus(FieldUtils.safeNegate(weeks));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of weeks taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param weeks  the amount of weeks to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of weeks\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks minus(Weeks weeks) {\n+        if (weeks == null) {\n+            return this;\n+        }\n+        return minus(weeks.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the weeks multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks multipliedBy(int scalar) {\n+        return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the weeks divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Weeks dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Weeks.weeks(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the weeks value negated.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Weeks negated() {\n+        return Weeks.weeks(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this weeks instance greater than the specified number of weeks.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this weeks instance is greater than the specified one\n+     */\n+    public boolean isGreaterThan(Weeks other) {\n+        if (other == null) {\n+            return getValue() > 0;\n+        }\n+        return getValue() > other.getValue();\n+    }\n+\n+    /**\n+     * Is this weeks instance less than the specified number of weeks.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this weeks instance is less than the specified one\n+     */\n+    public boolean isLessThan(Weeks other) {\n+        if (other == null) {\n+            return getValue() < 0;\n+        }\n+        return getValue() < other.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P4W\" represents 4 weeks.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"P\" + String.valueOf(getValue()) + \"W\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/YearMonth.java\n+/*\n+ *  Copyright 2001-2010 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BasePartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * YearMonth is an immutable partial supporting the year and monthOfYear fields.\n+ * <p>\n+ * NOTE: This class only supports the two fields listed above.\n+ * It is impossible to query any other fields, such as dayOfWeek or centuryOfEra.\n+ * <p>\n+ * Calculations on YearMonth are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * One use case for this class is to store a credit card expiry date, as that only\n+ * references the year and month.\n+ * This class can be used as the gYearMonth type in XML Schema.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getMonthOfYear()</code>\n+ * <li><code>monthOfYear().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * YearMonth is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ */\n+public final class YearMonth\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 797544782896179L;\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.year(),\n+        DateTimeFieldType.monthOfYear(),\n+    };\n+\n+    /** The index of the year field in the field array */\n+    public static final int YEAR = 0;\n+    /** The index of the monthOfYear field in the field array */\n+    public static final int MONTH_OF_YEAR = 1;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonth from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the YearMonth.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a YearMonth with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created YearMonth, never null\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology\n+     */\n+    public static YearMonth fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the YearMonth.\n+     * <p>\n+     * This factory method always creates a YearMonth with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created YearMonth, never null\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public static YearMonth fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new YearMonth(date.getYear() + 1900, date.getMonth() + 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonth with the current year-month, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     */\n+    public YearMonth() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with the current year-month, using ISOChronology in\n+     * the specified zone to extract the fields.\n+     * <p>\n+     * The constructor uses the specified time zone to obtain the current year-month.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     * \n+     * @param zone  the zone to use, null means default zone\n+     */\n+    public YearMonth(DateTimeZone zone) {\n+        super(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with the current year-month, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonth(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public YearMonth(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonth(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth from an Object that represents some form of time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The chronology used will be derived from the object, defaulting to ISO.\n+     *\n+     * @param instant  the date-time object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonth(Object instant) {\n+        super(instant, null, ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a YearMonth from an Object that represents some form of time,\n+     * using the specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     * The specified chronology overrides that of the object.\n+     *\n+     * @param instant  the date-time object, null means now\n+     * @param chronology  the chronology, null means ISO default\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonth(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with specified year and month\n+     * using <code>ISOChronology</code>.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     */\n+    public YearMonth(int year, int monthOfYear) {\n+        this(year, monthOfYear, null);\n+    }\n+\n+    /**\n+     * Constructs an instance set to the specified year and month\n+     * using the specified chronology, whose zone is ignored.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code> is used.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a time-zone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonth(int year, int monthOfYear, Chronology chronology) {\n+        super(new int[] {year, monthOfYear}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with chronology from this instance and new values.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    YearMonth(YearMonth partial, int[] values) {\n+        super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a YearMonth with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    YearMonth(YearMonth partial, Chronology chrono) {\n+        super(partial, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial, which is two.\n+     * The supported fields are Year and MonthOfYear.\n+     * Note that only these fields may be queried.\n+     *\n+     * @return the field count, two\n+     */\n+    public int size() {\n+        return 2;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field, never null\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case MONTH_OF_YEAR:\n+                return chrono.monthOfYear();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index, never null\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, Year, Month.\n+     *\n+     * @return the array of field types (cloned), largest to smallest, never null\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as YearMonth\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this year-month with a different chronology, never null\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public YearMonth withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            YearMonth newYearMonth = new YearMonth(this, newChronology);\n+            newChronology.validate(newYearMonth, getValues());\n+            return newYearMonth;\n+        }\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>monthOfYear</code> then the month\n+     * would be changed in the returned instance.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * YearMonth updated = ym.withField(DateTimeFieldType.monthOfYear(), 6);\n+     * YearMonth updated = ym.monthOfYear().setCopy(6);\n+     * YearMonth updated = ym.property(DateTimeFieldType.monthOfYear()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set, never null\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public YearMonth withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);\n+     * YearMonth added = ym.plusMonths(6);\n+     * YearMonth added = ym.monthOfYear().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated, never null\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new date-time exceeds the capacity\n+     */\n+    public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added, never null\n+     * @throws ArithmeticException if the new date-time exceeds the capacity\n+     */\n+    public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added, never null\n+     * @throws ArithmeticException if the new year-month exceeds the capacity\n+     */\n+    public YearMonth plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month plus the specified number of years.\n+     * <p>\n+     * This year-month instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonth added = ym.plusYears(6);\n+     * YearMonth added = ym.plus(Period.years(6));\n+     * YearMonth added = ym.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new year-month plus the increased years, never null\n+     */\n+    public YearMonth plusYears(int years) {\n+        return withFieldAdded(DurationFieldType.years(), years);\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month plus the specified number of months.\n+     * <p>\n+     * This year-month instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonth added = ym.plusMonths(6);\n+     * YearMonth added = ym.plus(Period.months(6));\n+     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new year-month plus the increased months, never null\n+     */\n+    public YearMonth plusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), months);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away, never null\n+     * @throws ArithmeticException if the new year-month exceeds the capacity\n+     */\n+    public YearMonth minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month minus the specified number of years.\n+     * <p>\n+     * This year-month instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonth subtracted = ym.minusYears(6);\n+     * YearMonth subtracted = ym.minus(Period.years(6));\n+     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new year-month minus the increased years, never null\n+     */\n+    public YearMonth minusYears(int years) {\n+        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month minus the specified number of months.\n+     * <p>\n+     * This year-month instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonth subtracted = ym.minusMonths(6);\n+     * YearMonth subtracted = ym.minus(Period.months(6));\n+     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new year-month minus the increased months, never null\n+     */\n+    public YearMonth minusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalDate with the same year-month and chronology.\n+     *\n+     * @param dayOfMonth the day of month to use, valid for chronology, such as 1-31 for ISO\n+     * @return a LocalDate with the same year-month and chronology, never null\n+     */\n+    public LocalDate toLocalDate(int dayOfMonth) {\n+        return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to an Interval representing the whole month.\n+     * <p>\n+     * The interval will use the chronology of the year-month in the default zone.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @return an interval over the month, never null\n+     */\n+    public Interval toInterval() {\n+        return toInterval(null);\n+    }\n+\n+    /**\n+     * Converts this object to an Interval representing the whole month.\n+     * <p>\n+     * The interval will use the chronology of the year-month in the specified zone.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param zone  the zone to get the Interval in, null means default\n+     * @return an interval over the month, never null\n+     */\n+    public Interval toInterval(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        DateTime start = toLocalDate(1).toDateTimeAtStartOfDay(zone);\n+        DateTime end = plusMonths(1).toLocalDate(1).toDateTimeAtStartOfDay(zone);\n+        return new Interval(start, end);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field value.\n+     *\n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getValue(YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getValue(MONTH_OF_YEAR);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this year-month with the year field updated.\n+     * <p>\n+     * YearMonth is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year changed.\n+     *\n+     * @param year  the year to set\n+     * @return a copy of this object with the field set, never null\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public YearMonth withYear(int year) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().year().set(this, YEAR, newValues, year);\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this year-month with the month of year field updated.\n+     * <p>\n+     * YearMonth is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set, never null\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public YearMonth withMonthOfYear(int monthOfYear) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n+        return new YearMonth(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field property which provides access to advanced functionality.\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field property which provides access to advanced functionality.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, MONTH_OF_YEAR);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the year-month in ISO8601 format (yyyy-MM).\n+     *\n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.yearMonth().print(this);\n+    }\n+\n+    /**\n+     * Output the year-month using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the year-month using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>YearMonth</code>.\n+     * <p>\n+     * This class binds a <code>YearMonth</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 2.0\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 5727734012190224363L;\n+\n+        /** The partial */\n+        private final YearMonth iBase;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(YearMonth partial, int fieldIndex) {\n+            super();\n+            iBase = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iBase.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iBase;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public YearMonth getYearMonth() {\n+            return iBase;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iBase.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonth.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonth addToCopy(int valueToAdd) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonth(iBase, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonth wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>2004-12</code> addWrapField one month returns <code>2004-01</code>.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonth addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonth(iBase, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the YearMonth.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonth setCopy(int value) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().set(iBase, iFieldIndex, newValues, value);\n+            return new YearMonth(iBase, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonth to a parsed text value.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public YearMonth setCopy(String text, Locale locale) {\n+            int[] newValues = iBase.getValues();\n+            newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);\n+            return new YearMonth(iBase, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonth to a parsed text value.\n+         * <p>\n+         * The YearMonth attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the YearMonth with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public YearMonth setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/YearMonthDay.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.joda.time.base.BasePartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * YearMonthDay is an immutable partial supporting the year, monthOfYear\n+ * and dayOfMonth fields.\n+ * <p>\n+ * NOTE: This class only supports the three fields listed above. Thus, you\n+ * cannot query the dayOfWeek or centuryOfEra fields for example.\n+ * The new <code>LocalDate</code> class removes this restriction.\n+ * <p>\n+ * Calculations on YearMonthDay are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * Each individual field can be queried in two ways:\n+ * <ul>\n+ * <li><code>getMonthOfYear()</code>\n+ * <li><code>monthOfYear().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>numeric value - <code>monthOfYear().get()</code>\n+ * <li>text value - <code>monthOfYear().getAsText()</code>\n+ * <li>short text value - <code>monthOfYear().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code>\n+ * <li>add/subtract - <code>monthOfYear().addToCopy()</code>\n+ * <li>set - <code>monthOfYear().setCopy()</code>\n+ * </ul>\n+ * <p>\n+ * YearMonthDay is thread-safe and immutable, provided that the Chronology is as well.\n+ * All standard Chronology classes supplied are thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @deprecated Use LocalDate which has a much better internal implementation and\n+ *  has been available since 1.3\n+ */\n+public final class YearMonthDay\n+        extends BasePartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 797544782896179L;\n+    /** The singleton set of field types */\n+    private static final DateTimeFieldType[] FIELD_TYPES = new DateTimeFieldType[] {\n+        DateTimeFieldType.year(),\n+        DateTimeFieldType.monthOfYear(),\n+        DateTimeFieldType.dayOfMonth(),\n+    };\n+\n+    /** The index of the year field in the field array */\n+    public static final int YEAR = 0;\n+    /** The index of the monthOfYear field in the field array */\n+    public static final int MONTH_OF_YEAR = 1;\n+    /** The index of the dayOfMonth field in the field array */\n+    public static final int DAY_OF_MONTH = 2;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonthDay from a <code>java.util.Calendar</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Calendar and assigned to the YearMonthDay.\n+     * This is useful if you have been using the Calendar as a local date,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method ignores the type of the calendar and always\n+     * creates a YearMonthDay with ISO chronology. It is expected that you\n+     * will only pass in instances of <code>GregorianCalendar</code> however\n+     * this is not validated.\n+     *\n+     * @param calendar  the Calendar to extract fields from\n+     * @return the created YearMonthDay\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     * @since 1.2\n+     */\n+    public static YearMonthDay fromCalendarFields(Calendar calendar) {\n+        if (calendar == null) {\n+            throw new IllegalArgumentException(\"The calendar must not be null\");\n+        }\n+        return new YearMonthDay(\n+            calendar.get(Calendar.YEAR),\n+            calendar.get(Calendar.MONTH) + 1,\n+            calendar.get(Calendar.DAY_OF_MONTH)\n+        );\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay from a <code>java.util.Date</code>\n+     * using exactly the same field values avoiding any time zone effects.\n+     * <p>\n+     * Each field is queried from the Date and assigned to the YearMonthDay.\n+     * This is useful if you have been using the Date as a local date,\n+     * ignoing the zone.\n+     * <p>\n+     * This factory method always creates a YearMonthDay with ISO chronology.\n+     *\n+     * @param date  the Date to extract fields from\n+     * @return the created YearMonthDay\n+     * @throws IllegalArgumentException if the calendar is null\n+     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n+     * @since 1.2\n+     */\n+    public static YearMonthDay fromDateFields(Date date) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return new YearMonthDay(\n+            date.getYear() + 1900,\n+            date.getMonth() + 1,\n+            date.getDate()\n+        );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a YearMonthDay with the current date, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    public YearMonthDay() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with the current date, using ISOChronology in\n+     * the specified zone to extract the fields.\n+     * <p>\n+     * The constructor uses the specified time zone to obtain the current date.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     * \n+     * @param zone  the zone to use, null means default zone\n+     * @since 1.1\n+     */\n+    public YearMonthDay(DateTimeZone zone) {\n+        super(ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with the current date, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public YearMonthDay(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The chronology used will be derived from the object, defaulting to ISO.\n+     * <p>\n+     * NOTE: Prior to v1.3 the string format was described by\n+     * {@link ISODateTimeFormat#dateTimeParser()}. Time ony strings are now rejected.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonthDay(Object instant) {\n+        super(instant, null, ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     * The specified chronology overrides that of the object.\n+     * <p>\n+     * NOTE: Prior to v1.3 the string format was described by\n+     * {@link ISODateTimeFormat#dateTimeParser()}. Time only strings are now rejected.\n+     *\n+     * @param instant  the datetime object, null means now\n+     * @param chronology  the chronology, null means ISO default\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public YearMonthDay(Object instant, Chronology chronology) {\n+        super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.dateOptionalTimeParser());\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with specified time field values\n+     * using <code>ISOChronology</code> in the default zone.\n+     * <p>\n+     * The constructor uses the no time zone initialising the fields as provided.\n+     * Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public YearMonthDay(int year, int monthOfYear, int dayOfMonth) {\n+        this(year, monthOfYear, dayOfMonth, null);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with specified time field values.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\n+        super(new int[] {year, monthOfYear, dayOfMonth}, chronology);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with chronology from this instance and new values.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param values  the new set of values\n+     */\n+    YearMonthDay(YearMonthDay partial, int[] values) {\n+        super(partial, values);\n+    }\n+\n+    /**\n+     * Constructs a YearMonthDay with values from this instance and a new chronology.\n+     *\n+     * @param partial  the partial to base this new instance on\n+     * @param chrono  the new chronology\n+     */\n+    YearMonthDay(YearMonthDay partial, Chronology chrono) {\n+        super(partial, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int size() {\n+        return 3;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case MONTH_OF_YEAR:\n+                return chrono.monthOfYear();\n+            case DAY_OF_MONTH:\n+                return chrono.dayOfMonth();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return FIELD_TYPES[index];\n+    }\n+\n+    /**\n+     * Gets an array of the field type of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, Year, Month, Day\n+     *\n+     * @return the array of field types (cloned), largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        return (DateTimeFieldType[]) FIELD_TYPES.clone();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified chronology.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * This method retains the values of the fields, thus the result will\n+     * typically refer to a different instant.\n+     * <p>\n+     * The time zone of the specified chronology is ignored, as YearMonthDay\n+     * operates without a time zone.\n+     *\n+     * @param newChronology  the new chronology, null means ISO\n+     * @return a copy of this datetime with a different chronology\n+     * @throws IllegalArgumentException if the values are invalid for the new chronology\n+     */\n+    public YearMonthDay withChronologyRetainFields(Chronology newChronology) {\n+        newChronology = DateTimeUtils.getChronology(newChronology);\n+        newChronology = newChronology.withUTC();\n+        if (newChronology == getChronology()) {\n+            return this;\n+        } else {\n+            YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology);\n+            newChronology.validate(newYearMonthDay, getValues());\n+            return newYearMonthDay;\n+        }\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed in the returned instance.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * YearMonthDay updated = ymd.dayOfMonth().setCopy(6);\n+     * YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public YearMonthDay withField(DateTimeFieldType fieldType, int value) {\n+        int index = indexOfSupported(fieldType);\n+        if (value == getValue(index)) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * YearMonthDay added = ymd.withFieldAdded(DurationFieldType.days(), 6);\n+     * YearMonthDay added = ymd.plusDays(6);\n+     * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n+        int index = indexOfSupported(fieldType);\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * This method is typically used to add multiple copies of complex\n+     * period instances. Adding one field is best achieved using methods\n+     * like {@link #withFieldAdded(DurationFieldType, int)}\n+     * or {@link #plusYears(int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiply(period.getValue(i), scalar));\n+            }\n+        }\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to add complex period instances.\n+     * Adding one field is best achieved using methods\n+     * like {@link #plusYears(int)}.\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public YearMonthDay plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date plus the specified number of years.\n+     * <p>\n+     * This date instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonthDay added = dt.plusYears(6);\n+     * YearMonthDay added = dt.plus(Period.years(6));\n+     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.years(), 6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new date plus the increased years\n+     * @since 1.1\n+     */\n+    public YearMonthDay plusYears(int years) {\n+        return withFieldAdded(DurationFieldType.years(), years);\n+    }\n+\n+    /**\n+     * Returns a copy of this date plus the specified number of months.\n+     * <p>\n+     * This date instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonthDay added = dt.plusMonths(6);\n+     * YearMonthDay added = dt.plus(Period.months(6));\n+     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.months(), 6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to add, may be negative\n+     * @return the new date plus the increased months\n+     * @since 1.1\n+     */\n+    public YearMonthDay plusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), months);\n+    }\n+\n+    /**\n+     * Returns a copy of this date plus the specified number of days.\n+     * <p>\n+     * This date instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonthDay added = dt.plusDays(6);\n+     * YearMonthDay added = dt.plus(Period.days(6));\n+     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.days(), 6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to add, may be negative\n+     * @return the new date plus the increased days\n+     * @since 1.1\n+     */\n+    public YearMonthDay plusDays(int days) {\n+        return withFieldAdded(DurationFieldType.days(), days);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the specified period taken away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * This method is typically used to subtract complex period instances.\n+     * Subtracting one field is best achieved using methods\n+     * like {@link #minusYears(int)}.\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public YearMonthDay minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date minus the specified number of years.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonthDay subtracted = dt.minusYears(6);\n+     * YearMonthDay subtracted = dt.minus(Period.years(6));\n+     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n+     * </pre>\n+     *\n+     * @param years  the amount of years to subtract, may be negative\n+     * @return the new datetime minus the increased years\n+     * @since 1.1\n+     */\n+    public YearMonthDay minusYears(int years) {\n+        return withFieldAdded(DurationFieldType.years(), FieldUtils.safeNegate(years));\n+    }\n+\n+    /**\n+     * Returns a copy of this date minus the specified number of months.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonthDay subtracted = dt.minusMonths(6);\n+     * YearMonthDay subtracted = dt.minus(Period.months(6));\n+     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n+     * </pre>\n+     *\n+     * @param months  the amount of months to subtract, may be negative\n+     * @return the new datetime minus the increased months\n+     * @since 1.1\n+     */\n+    public YearMonthDay minusMonths(int months) {\n+        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n+    }\n+\n+    /**\n+     * Returns a copy of this date minus the specified number of days.\n+     * <p>\n+     * This datetime instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The following three lines are identical in effect:\n+     * <pre>\n+     * YearMonthDay subtracted = dt.minusDays(6);\n+     * YearMonthDay subtracted = dt.minus(Period.days(6));\n+     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n+     * </pre>\n+     *\n+     * @param days  the amount of days to subtract, may be negative\n+     * @return the new datetime minus the increased days\n+     * @since 1.1\n+     */\n+    public YearMonthDay minusDays(int days) {\n+        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the property object for the specified type, which contains\n+     * many useful methods.\n+     *\n+     * @param type  the field type to get the property for\n+     * @return the property object\n+     * @throws IllegalArgumentException if the field is null or unsupported\n+     */\n+    public Property property(DateTimeFieldType type) {\n+        return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a LocalDate with the same date and chronology.\n+     *\n+     * @return a LocalDate with the same date and chronology\n+     * @since 1.3\n+     */\n+    public LocalDate toLocalDate() {\n+        return new LocalDate(getYear(), getMonthOfYear(), getDayOfMonth(), getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this YearMonthDay to a full datetime at midnight using the\n+     * default time zone.\n+     *\n+     * @return this date as a datetime at midnight\n+     */\n+    public DateTime toDateTimeAtMidnight() {\n+        return toDateTimeAtMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this YearMonthDay to a full datetime at midnight using the\n+     * specified time zone.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime at midnight\n+     */\n+    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this partial to a full datetime using the default time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     *\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime() {\n+        return toDateTimeAtCurrentTime(null);\n+    }\n+\n+    /**\n+     * Converts this partial to a full datetime using the specified time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instantMillis = DateTimeUtils.currentTimeMillis();\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateMidnight in the default time zone.\n+     *\n+     * @return the DateMidnight instance in the default zone\n+     */\n+    public DateMidnight toDateMidnight() {\n+        return toDateMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateMidnight.\n+     *\n+     * @param zone  the zone to get the DateMidnight in, null means default\n+     * @return the DateMidnight instance\n+     */\n+    public DateMidnight toDateMidnight(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to a DateTime using a TimeOfDay to fill in the\n+     * missing fields and using the default time zone.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * YearMonthDay plus the time zone.\n+     * The chronology of the time is ignored - only the field values are used.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @return the DateTime instance\n+     */\n+    public DateTime toDateTime(TimeOfDay time) {\n+        return toDateTime(time, null);\n+    }\n+\n+    /**\n+     * Converts this object to a DateTime using a TimeOfDay to fill in the\n+     * missing fields.\n+     * This instance is immutable and unaffected by this method call.\n+     * <p>\n+     * The resulting chronology is determined by the chronology of this\n+     * YearMonthDay plus the time zone.\n+     * The chronology of the time is ignored - only the field values are used.\n+     *\n+     * @param time  the time of day to use, null means current time\n+     * @param zone  the zone to get the DateTime in, null means default\n+     * @return the DateTime instance\n+     */\n+    public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instant = DateTimeUtils.currentTimeMillis();\n+        instant = chrono.set(this, instant);\n+        if (time != null) {\n+            instant = chrono.set(time, instant);\n+        }\n+        return new DateTime(instant, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this object to an Interval representing the whole day\n+     * in the default time zone.\n+     *\n+     * @return a interval over the day\n+     */\n+    public Interval toInterval() {\n+        return toInterval(null);\n+    }\n+\n+    /**\n+     * Converts this object to an Interval representing the whole day.\n+     *\n+     * @param zone  the zone to get the Interval in, null means default\n+     * @return a interval over the day\n+     */\n+    public Interval toInterval(DateTimeZone zone) {\n+        zone = DateTimeUtils.getZone(zone);\n+        return toDateMidnight(zone).toInterval();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field value.\n+     *\n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getValue(YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     *\n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getValue(MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     *\n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getValue(DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a copy of this date with the year field updated.\n+     * <p>\n+     * YearMonthDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * year changed.\n+     *\n+     * @param year  the year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public YearMonthDay withYear(int year) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().year().set(this, YEAR, newValues, year);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the month of year field updated.\n+     * <p>\n+     * YearMonthDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * month of year changed.\n+     *\n+     * @param monthOfYear  the month of year to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public YearMonthDay withMonthOfYear(int monthOfYear) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Returns a copy of this date with the day of month field updated.\n+     * <p>\n+     * YearMonthDay is immutable, so there are no set methods.\n+     * Instead, this method returns a new instance with the value of\n+     * day of month changed.\n+     *\n+     * @param dayOfMonth  the day of month to set\n+     * @return a copy of this object with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     * @since 1.3\n+     */\n+    public YearMonthDay withDayOfMonth(int dayOfMonth) {\n+        int[] newValues = getValues();\n+        newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the year field property which provides access to advanced functionality.\n+     * \n+     * @return the year property\n+     */\n+    public Property year() {\n+        return new Property(this, YEAR);\n+    }\n+\n+    /**\n+     * Get the month of year field property which provides access to advanced functionality.\n+     * \n+     * @return the month of year property\n+     */\n+    public Property monthOfYear() {\n+        return new Property(this, MONTH_OF_YEAR);\n+    }\n+\n+    /**\n+     * Get the day of month field property which provides access to advanced functionality.\n+     * \n+     * @return the day of month property\n+     */\n+    public Property dayOfMonth() {\n+        return new Property(this, DAY_OF_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date in the ISO8601 format YYYY-MM-DD.\n+     * \n+     * @return ISO8601 formatted string\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.yearMonthDay().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The property class for <code>YearMonthDay</code>.\n+     * <p>\n+     * This class binds a <code>YearMonthDay</code> to a <code>DateTimeField</code>.\n+     * \n+     * @author Stephen Colebourne\n+     * @since 1.0\n+     * @deprecated Use LocalDate which has a much better internal implementation\n+     */\n+    public static class Property extends AbstractPartialFieldProperty implements Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 5727734012190224363L;\n+\n+        /** The partial */\n+        private final YearMonthDay iYearMonthDay;\n+        /** The field index */\n+        private final int iFieldIndex;\n+\n+        /**\n+         * Constructs a property.\n+         * \n+         * @param partial  the partial instance\n+         * @param fieldIndex  the index in the partial\n+         */\n+        Property(YearMonthDay partial, int fieldIndex) {\n+            super();\n+            iYearMonthDay = partial;\n+            iFieldIndex = fieldIndex;\n+        }\n+\n+        /**\n+         * Gets the field that this property uses.\n+         * \n+         * @return the field\n+         */\n+        public DateTimeField getField() {\n+            return iYearMonthDay.getField(iFieldIndex);\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        protected ReadablePartial getReadablePartial() {\n+            return iYearMonthDay;\n+        }\n+\n+        /**\n+         * Gets the partial that this property belongs to.\n+         * \n+         * @return the partial\n+         */\n+        public YearMonthDay getYearMonthDay() {\n+            return iYearMonthDay;\n+        }\n+\n+        /**\n+         * Gets the value of this field.\n+         * \n+         * @return the field value\n+         */\n+        public int get() {\n+            return iYearMonthDay.getValue(iFieldIndex);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonthDay.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it will affect larger fields.\n+         * Smaller fields are unaffected.\n+         * <p>\n+         * If the result would be too large, beyond the maximum year, then an\n+         * IllegalArgumentException is thrown.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonthDay addToCopy(int valueToAdd) {\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Adds to the value of this field in a copy of this YearMonthDay wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps within this field.\n+         * Other fields are unaffected.\n+         * <p>\n+         * For example,\n+         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonthDay addWrapFieldToCopy(int valueToAdd) {\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Sets this field in a copy of the YearMonthDay.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param value  the value to set the field in the copy to\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public YearMonthDay setCopy(int value) {\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @param locale  optional locale to use for selecting a text symbol\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public YearMonthDay setCopy(String text, Locale locale) {\n+            int[] newValues = iYearMonthDay.getValues();\n+            newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale);\n+            return new YearMonthDay(iYearMonthDay, newValues);\n+        }\n+\n+        /**\n+         * Sets this field in a copy of the YearMonthDay to a parsed text value.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param text  the text value to set\n+         * @return a copy of the YearMonthDay with the field value changed\n+         * @throws IllegalArgumentException if the text value isn't valid\n+         */\n+        public YearMonthDay setCopy(String text) {\n+            return setCopy(text, null);\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Returns a new YearMonthDay with this field set to the maximum value\n+         * for this field.\n+         * <p>\n+         * This operation is useful for obtaining a DateTime on the last day\n+         * of the month, as month lengths vary.\n+         * <pre>\n+         * YearMonthDay lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n+         * </pre>\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the YearMonthDay with this field set to its maximum\n+         * @since 1.2\n+         */\n+        public YearMonthDay withMaximumValue() {\n+            return setCopy(getMaximumValue());\n+        }\n+\n+        /**\n+         * Returns a new YearMonthDay with this field set to the minimum value\n+         * for this field.\n+         * <p>\n+         * The YearMonthDay attached to this property is unchanged by this call.\n+         *\n+         * @return a copy of the YearMonthDay with this field set to its minimum\n+         * @since 1.2\n+         */\n+        public YearMonthDay withMinimumValue() {\n+            return setCopy(getMinimumValue());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/Years.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time;\n+\n+import org.joda.time.base.BaseSingleFieldPeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * An immutable time period representing a number of years.\n+ * <p>\n+ * <code>Years</code> is an immutable period that can only store years.\n+ * It does not store years, days or hours for example. As such it is a\n+ * type-safe way of representing a number of years in an application.\n+ * <p>\n+ * The number of years is set in the constructor, and may be queried using\n+ * <code>getYears()</code>. Basic mathematical operations are provided -\n+ * <code>plus()</code>, <code>minus()</code>, <code>multipliedBy()</code> and\n+ * <code>dividedBy()</code>.\n+ * <p>\n+ * <code>Years</code> is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public final class Years extends BaseSingleFieldPeriod {\n+\n+    /** Constant representing zero years. */\n+    public static final Years ZERO = new Years(0);\n+    /** Constant representing one year. */\n+    public static final Years ONE = new Years(1);\n+    /** Constant representing two years. */\n+    public static final Years TWO = new Years(2);\n+    /** Constant representing three years. */\n+    public static final Years THREE = new Years(3);\n+    /** Constant representing the maximum number of years that can be stored in this object. */\n+    public static final Years MAX_VALUE = new Years(Integer.MAX_VALUE);\n+    /** Constant representing the minimum number of years that can be stored in this object. */\n+    public static final Years MIN_VALUE = new Years(Integer.MIN_VALUE);\n+\n+    /** The paser to use for this class. */\n+    private static final PeriodFormatter PARSER = ISOPeriodFormat.standard().withParseType(PeriodType.years());\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 87525275727380868L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an instance of <code>Years</code> that may be cached.\n+     * <code>Years</code> is immutable, so instances can be cached and shared.\n+     * This factory method provides access to shared instances.\n+     *\n+     * @param years  the number of years to obtain an instance for\n+     * @return the instance of Years\n+     */\n+    public static Years years(int years) {\n+        switch (years) {\n+            case 0:\n+                return ZERO;\n+            case 1:\n+                return ONE;\n+            case 2:\n+                return TWO;\n+            case 3:\n+                return THREE;\n+            case Integer.MAX_VALUE:\n+                return MAX_VALUE;\n+            case Integer.MIN_VALUE:\n+                return MIN_VALUE;\n+            default:\n+                return new Years(years);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>Years</code> representing the number of whole years\n+     * between the two specified datetimes. This method corectly handles\n+     * any daylight savings time changes that may occur during the interval.\n+     *\n+     * @param start  the start instant, must not be null\n+     * @param end  the end instant, must not be null\n+     * @return the period in years\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    public static Years yearsBetween(ReadableInstant start, ReadableInstant end) {\n+        int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.years());\n+        return Years.years(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Years</code> representing the number of whole years\n+     * between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, must not be null\n+     * @param end  the end partial date, must not be null\n+     * @return the period in years\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Years yearsBetween(ReadablePartial start, ReadablePartial end) {\n+        if (start instanceof LocalDate && end instanceof LocalDate)   {\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n+            int years = chrono.years().getDifference(\n+                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n+            return Years.years(years);\n+        }\n+        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n+        return Years.years(amount);\n+    }\n+\n+    /**\n+     * Creates a <code>Years</code> representing the number of whole years\n+     * in the specified interval. This method corectly handles any daylight\n+     * savings time changes that may occur during the interval.\n+     *\n+     * @param interval  the interval to extract years from, null returns zero\n+     * @return the period in years\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    public static Years yearsIn(ReadableInterval interval) {\n+        if (interval == null)   {\n+            return Years.ZERO;\n+        }\n+        int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years());\n+        return Years.years(amount);\n+    }\n+\n+    /**\n+     * Creates a new <code>Years</code> by parsing a string in the ISO8601 format 'PnY'.\n+     * <p>\n+     * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n+     * years component may be non-zero. If any other component is non-zero, an exception\n+     * will be thrown.\n+     *\n+     * @param periodStr  the period string, null returns zero\n+     * @return the period in years\n+     * @throws IllegalArgumentException if the string format is invalid\n+     */\n+    public static Years parseYears(String periodStr) {\n+        if (periodStr == null) {\n+            return Years.ZERO;\n+        }\n+        Period p = PARSER.parsePeriod(periodStr);\n+        return Years.years(p.getYears());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing a number of years.\n+     * You should consider using the factory method {@link #years(int)}\n+     * instead of the constructor.\n+     *\n+     * @param years  the number of years to represent\n+     */\n+    private Years(int years) {\n+        super(years);\n+    }\n+\n+    /**\n+     * Resolves singletons.\n+     * \n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        return Years.years(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration field type, which is <code>years</code>.\n+     *\n+     * @return the period type\n+     */\n+    public DurationFieldType getFieldType() {\n+        return DurationFieldType.years();\n+    }\n+\n+    /**\n+     * Gets the period type, which is <code>years</code>.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return PeriodType.years();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of years that this period represents.\n+     *\n+     * @return the number of years in the period\n+     */\n+    public int getYears() {\n+        return getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of years added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to add, may be negative\n+     * @return the new period plus the specified number of years\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years plus(int years) {\n+        if (years == 0) {\n+            return this;\n+        }\n+        return Years.years(FieldUtils.safeAdd(getValue(), years));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of years added.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to add, may be negative, null means zero\n+     * @return the new period plus the specified number of years\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years plus(Years years) {\n+        if (years == null) {\n+            return this;\n+        }\n+        return plus(years.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the specified number of years taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to take away, may be negative\n+     * @return the new period minus the specified number of years\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years minus(int years) {\n+        return plus(FieldUtils.safeNegate(years));\n+    }\n+\n+    /**\n+     * Returns a new instance with the specified number of years taken away.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param years  the amount of years to take away, may be negative, null means zero\n+     * @return the new period minus the specified number of years\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years minus(Years years) {\n+        if (years == null) {\n+            return this;\n+        }\n+        return minus(years.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the years multiplied by the specified scalar.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param scalar  the amount to multiply by, may be negative\n+     * @return the new period multiplied by the specified scalar\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years multipliedBy(int scalar) {\n+        return Years.years(FieldUtils.safeMultiply(getValue(), scalar));\n+    }\n+\n+    /**\n+     * Returns a new instance with the years divided by the specified divisor.\n+     * The calculation uses integer division, thus 3 divided by 2 is 1.\n+     * <p>\n+     * This instance is immutable and unaffected by this method call.\n+     *\n+     * @param divisor  the amount to divide by, may be negative\n+     * @return the new period divided by the specified divisor\n+     * @throws ArithmeticException if the divisor is zero\n+     */\n+    public Years dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return Years.years(getValue() / divisor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new instance with the years value negated.\n+     *\n+     * @return the new period with a negated value\n+     * @throws ArithmeticException if the result overflows an int\n+     */\n+    public Years negated() {\n+        return Years.years(FieldUtils.safeNegate(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this years instance greater than the specified number of years.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this years instance is greater than the specified one\n+     */\n+    public boolean isGreaterThan(Years other) {\n+        if (other == null) {\n+            return getValue() > 0;\n+        }\n+        return getValue() > other.getValue();\n+    }\n+\n+    /**\n+     * Is this years instance less than the specified number of years.\n+     *\n+     * @param other  the other period, null means zero\n+     * @return true if this years instance is less than the specified one\n+     */\n+    public boolean isLessThan(Years other) {\n+        if (other == null) {\n+            return getValue() < 0;\n+        }\n+        return getValue() < other.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this instance as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P4Y\" represents 4 years.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return \"P\" + String.valueOf(getValue()) + \"Y\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/AbstractDateTime.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableDateTime;\n+import org.joda.time.format.DateTimeFormat;\n+\n+/**\n+ * AbstractDateTime provides the common behaviour for datetime classes.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableDateTime} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * Whenever you want to implement <code>ReadableDateTime</code> you should\n+ * extend this class.\n+ * <p>\n+ * AbstractDateTime subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractDateTime\n+        extends AbstractInstant\n+        implements ReadableDateTime {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractDateTime() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This method uses the chronology of the datetime to obtain the value.\n+     * It is essentially a generic way of calling one of the get methods.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null\n+     */\n+    public int get(DateTimeFieldType type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        return type.getField(getChronology()).get(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    public int getEra() {\n+        return getChronology().era().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    public int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    public int getYear() {\n+        return getChronology().year().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    public int getWeekyear() {\n+        return getChronology().weekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    public int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    public int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    public int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.\n+     * \n+     * @return the day of month\n+     */\n+    public int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.\n+     * \n+     * @return the day of week\n+     */\n+    public int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of day field value.\n+     *\n+     * @return the minute of day\n+     */\n+    public int getMinuteOfDay() {\n+        return getChronology().minuteOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of day field value.\n+     *\n+     * @return the second of day\n+     */\n+    public int getSecondOfDay() {\n+        return getChronology().secondOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    public int getMillisOfDay() {\n+        return getChronology().millisOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the date time as a <code>java.util.Calendar</code>, assigning\n+     * exactly the same millisecond instant.\n+     * The locale is passed in, enabling Calendar to select the correct\n+     * localized subclass.\n+     * <p>\n+     * The JDK and Joda-Time both have time zone implementations and these\n+     * differ in accuracy. Joda-Time's implementation is generally more up to\n+     * date and thus more accurate - for example JDK1.3 has no historical data.\n+     * The effect of this is that the field values of the <code>Calendar</code>\n+     * may differ from those of this object, even though the milliseond value\n+     * is the same. Most of the time this just means that the JDK field values\n+     * are wrong, as our time zone information is more up to date.\n+     *\n+     * @param locale  the locale to get the Calendar for, or default if null\n+     * @return a localized Calendar initialised with this datetime\n+     */\n+    public Calendar toCalendar(Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        DateTimeZone zone = getZone();\n+        Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);\n+        cal.setTime(toDate());\n+        return cal;\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.GregorianCalendar</code>,\n+     * assigning exactly the same millisecond instant.\n+     * <p>\n+     * The JDK and Joda-Time both have time zone implementations and these\n+     * differ in accuracy. Joda-Time's implementation is generally more up to\n+     * date and thus more accurate - for example JDK1.3 has no historical data.\n+     * The effect of this is that the field values of the <code>Calendar</code>\n+     * may differ from those of this object, even though the milliseond value\n+     * is the same. Most of the time this just means that the JDK field values\n+     * are wrong, as our time zone information is more up to date.\n+     *\n+     * @return a GregorianCalendar initialised with this datetime\n+     */\n+    public GregorianCalendar toGregorianCalendar() {\n+        DateTimeZone zone = getZone();\n+        GregorianCalendar cal = new GregorianCalendar(zone.toTimeZone());\n+        cal.setTime(toDate());\n+        return cal;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see  org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the instant using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see  org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/AbstractDuration.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import org.joda.time.Duration;\n+import org.joda.time.Period;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.format.FormatUtils;\n+\n+/**\n+ * AbstractDuration provides the common behaviour for duration classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableDuration} interface should be used when different \n+ * kinds of durations are to be referenced.\n+ * <p>\n+ * AbstractDuration subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractDuration implements ReadableDuration {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractDuration() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this duration as an immutable <code>Duration</code> object.\n+     * \n+     * @return a Duration created using the millisecond duration from this instance\n+     */\n+    public Duration toDuration() {\n+        return new Duration(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this duration to a Period instance using the standard period type\n+     * and the ISO chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used. Thus, only the hour,\n+     * minute, second and millisecond fields on the period will be used.\n+     * The year, month, week and day fields will not be populated.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available field, hours in this case.\n+     * <p>\n+     * For example, a duration effectively equal to (365 + 60 + 5) days will be\n+     * converted to ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}.\n+     * \n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriod() {\n+        return new Period(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this duration with the specified duration based on length.\n+     *\n+     * @param other  a duration to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the given object is not supported\n+     */\n+    public int compareTo(ReadableDuration other) {\n+        long thisMillis = this.getMillis();\n+        long otherMillis = other.getMillis();\n+        \n+        // cannot do (thisMillis - otherMillis) as it can overflow\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        }\n+        if (thisMillis > otherMillis) {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration equal to the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    public boolean isEqual(ReadableDuration duration) {\n+        if (duration == null) {\n+            duration = Duration.ZERO;\n+        }\n+        return compareTo(duration) == 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration longer than the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    public boolean isLongerThan(ReadableDuration duration) {\n+        if (duration == null) {\n+            duration = Duration.ZERO;\n+        }\n+        return compareTo(duration) > 0;\n+    }\n+\n+    /**\n+     * Is the length of this duration shorter than the duration passed in.\n+     *\n+     * @param duration  another duration to compare to, null means zero milliseconds\n+     * @return true if this duration is equal to than the duration passed in\n+     */\n+    public boolean isShorterThan(ReadableDuration duration) {\n+        if (duration == null) {\n+            duration = Duration.ZERO;\n+        }\n+        return compareTo(duration) < 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond length. All ReadableDuration instances are accepted.\n+     *\n+     * @param duration  a readable duration to check against\n+     * @return true if the length of the duration is equal\n+     */\n+    public boolean equals(Object duration) {\n+        if (this == duration) {\n+            return true;\n+        }\n+        if (duration instanceof ReadableDuration == false) {\n+            return false;\n+        }\n+        ReadableDuration other = (ReadableDuration) duration;\n+        return (getMillis() == other.getMillis());\n+    }\n+\n+    /**\n+     * Gets a hash code for the duration that is compatible with the \n+     * equals method.\n+     *\n+     * @return a hash code\n+     */\n+    public int hashCode() {\n+        long len = getMillis();\n+        return (int) (len ^ (len >>> 32));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format including\n+     * only seconds and milliseconds.\n+     * <p>\n+     * For example, \"PT72.345S\" represents 1 minute, 12 seconds and 345 milliseconds.\n+     * <p>\n+     * For more control over the output, see\n+     * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        long millis = getMillis();\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"PT\");\n+        FormatUtils.appendUnpaddedInteger(buf, millis / 1000);\n+        long part = Math.abs(millis % 1000);\n+        if (part > 0) {\n+            buf.append('.');\n+            FormatUtils.appendPaddedInteger(buf, part, 3);\n+        }\n+        buf.append('S');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/AbstractInstant.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.util.Date;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * AbstractInstant provides the common behaviour for instant classes.\n+ * <p>\n+ * This class has no concept of a chronology, all methods work on the\n+ * millisecond instant.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableInstant} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * Whenever you want to implement <code>ReadableInstant</code> you should\n+ * extend this class.\n+ * <p>\n+ * AbstractInstant itself is thread-safe and immutable, but subclasses may be\n+ * mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractInstant implements ReadableInstant {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractInstant() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the time zone of the instant from the chronology.\n+     * \n+     * @return the DateTimeZone that the instant is using, never null\n+     */\n+    public DateTimeZone getZone() {\n+        return getChronology().getZone();\n+    }\n+\n+    /**\n+     * Get the value of one of the fields of a datetime using the chronology of the instant.\n+     * <p>\n+     * This method uses the chronology of the instant to obtain the value.\n+     * For example:\n+     * <pre>\n+     * DateTime dt = new DateTime();\n+     * int year = dt.get(DateTimeFieldType.year());\n+     * </pre>\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType, not null\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field type is null\n+     */\n+    public int get(DateTimeFieldType type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n+        }\n+        return type.getField(getChronology()).get(getMillis());\n+    }\n+\n+    /**\n+     * Checks if the field type specified is supported by this instant and chronology.\n+     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n+     *\n+     * @param type  a field type, usually obtained from DateTimeFieldType\n+     * @return true if the field type is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        if (type == null) {\n+            return false;\n+        }\n+        return type.getField(getChronology()).isSupported();\n+    }\n+\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * This could be used to get a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * Instant dt = new Instant();\n+     * int gjYear = dt.get(Chronology.getCoptic().year());\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use, not null\n+     * @return the value\n+     * @throws IllegalArgumentException if the field is null\n+     */\n+    public int get(DateTimeField field) {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The DateTimeField must not be null\");\n+        }\n+        return field.get(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this object as an Instant.\n+     * \n+     * @return an Instant using the same millis\n+     */\n+    public Instant toInstant() {\n+        return new Instant(getMillis());\n+    }\n+\n+    /**\n+     * Get this object as a DateTime in the same zone.\n+     *\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime() {\n+        return new DateTime(getMillis(), getZone());\n+    }\n+\n+    /**\n+     * Get this object as a DateTime using ISOChronology in the same zone.\n+     *\n+     * @return a DateTime using the same millis with ISOChronology\n+     */\n+    public DateTime toDateTimeISO() {\n+        return new DateTime(getMillis(), ISOChronology.getInstance(getZone()));\n+    }\n+\n+    /**\n+     * Get this object as a DateTime using the same chronology but a different zone.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime(DateTimeZone zone) {\n+        Chronology chrono = DateTimeUtils.getChronology(getChronology());\n+        chrono = chrono.withZone(zone);\n+        return new DateTime(getMillis(), chrono);\n+    }\n+\n+    /**\n+     * Get this object as a DateTime using the given chronology and its zone.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a DateTime using the same millis\n+     */\n+    public DateTime toDateTime(Chronology chronology) {\n+        return new DateTime(getMillis(), chronology);\n+    }\n+\n+    // NOTE: Although the toMutableDateTime methods could check to see if this\n+    // is already a MutableDateTime and return this casted, it makes it too\n+    // easy to mistakenly modify ReadableDateTime input parameters. Always\n+    // returning a copy prevents this.\n+\n+    /**\n+     * Get this object as a MutableDateTime in the same zone.\n+     *\n+     * @return a MutableDateTime using the same millis\n+     */\n+    public MutableDateTime toMutableDateTime() {\n+        return new MutableDateTime(getMillis(), getZone());\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime using ISOChronology in the same zone.\n+     *\n+     * @return a MutableDateTime using the same millis with ISOChronology\n+     */\n+    public MutableDateTime toMutableDateTimeISO() {\n+        return new MutableDateTime(getMillis(), ISOChronology.getInstance(getZone()));\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime using the same chronology but a different zone.\n+     * \n+     * @param zone time zone to apply, or default if null\n+     * @return a MutableDateTime using the same millis\n+     */\n+    public MutableDateTime toMutableDateTime(DateTimeZone zone) {\n+        Chronology chrono = DateTimeUtils.getChronology(getChronology());\n+        chrono = chrono.withZone(zone);\n+        return new MutableDateTime(getMillis(), chrono);\n+    }\n+\n+    /**\n+     * Get this object as a MutableDateTime using the given chronology and its zone.\n+     * \n+     * @param chronology chronology to apply, or ISOChronology if null\n+     * @return a MutableDateTime using the same millis\n+     */\n+    public MutableDateTime toMutableDateTime(Chronology chronology) {\n+        return new MutableDateTime(getMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the date time as a <code>java.util.Date</code>.\n+     * <p>\n+     * The <code>Date</code> object created has exactly the same millisecond\n+     * instant as this object.\n+     *\n+     * @return a Date initialised with this datetime\n+     */\n+    public Date toDate() {\n+        return new Date(getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the millisecond instant, chronology and time zone.\n+     * <p>\n+     * Two objects which represent the same instant in time, but are in\n+     * different time zones (based on time zone id), will be considered to\n+     * be different. Only two objects with the same {@link DateTimeZone},\n+     * {@link Chronology} and instant are equal.\n+     * <p>\n+     * See {@link #isEqual(ReadableInstant)} for an equals method that\n+     * ignores the Chronology and time zone.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return true if millisecond and chronology are equal, false if\n+     *  not or the instant is null or of an incorrect type\n+     */\n+    public boolean equals(Object readableInstant) {\n+        // must be to fulfil ReadableInstant contract\n+        if (this == readableInstant) {\n+            return true;\n+        }\n+        if (readableInstant instanceof ReadableInstant == false) {\n+            return false;\n+        }\n+        ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n+        return\n+            getMillis() == otherInstant.getMillis() &&\n+            FieldUtils.equals(getChronology(), otherInstant.getChronology());\n+    }\n+\n+    /**\n+     * Gets a hash code for the instant as defined in <code>ReadableInstant</code>.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        // must be to fulfil ReadableInstant contract\n+        return\n+            ((int) (getMillis() ^ (getMillis() >>> 32))) +\n+            (getChronology().hashCode());\n+    }\n+\n+    /**\n+     * Compares this object with the specified object for ascending\n+     * millisecond instant order. This ordering is inconsistent with\n+     * equals, as it ignores the Chronology.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     *\n+     * @param other  a readable instant to check against\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object type is not supported\n+     */\n+    public int compareTo(ReadableInstant other) {\n+        if (this == other) {\n+            return 0;\n+        }\n+        \n+        long otherMillis = other.getMillis();\n+        long thisMillis = getMillis();\n+        \n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this instant after the millisecond instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  a millisecond instant to check against\n+     * @return true if this instant is after the instant passed in\n+     */\n+    public boolean isAfter(long instant) {\n+        return (getMillis() > instant);\n+    }\n+\n+    /**\n+     * Is this instant after the current instant\n+     * comparing solely by millisecond.\n+     * \n+     * @return true if this instant is after the current instant\n+     */\n+    public boolean isAfterNow() {\n+        return isAfter(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this instant after the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n+     * @return true if the instant is after the instant passed in\n+     */\n+    public boolean isAfter(ReadableInstant instant) {\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        return isAfter(instantMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this instant before the millisecond instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  a millisecond instant to check against\n+     * @return true if this instant is before the instant passed in\n+     */\n+    public boolean isBefore(long instant) {\n+        return (getMillis() < instant);\n+    }\n+\n+    /**\n+     * Is this instant before the current instant\n+     * comparing solely by millisecond.\n+     * \n+     * @return true if this instant is before the current instant\n+     */\n+    public boolean isBeforeNow() {\n+        return isBefore(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this instant before the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n+     * @return true if the instant is before the instant passed in\n+     */\n+    public boolean isBefore(ReadableInstant instant) {\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        return isBefore(instantMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this instant equal to the millisecond instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  a millisecond instant to check against\n+     * @return true if this instant is before the instant passed in\n+     */\n+    public boolean isEqual(long instant) {\n+        return (getMillis() == instant);\n+    }\n+\n+    /**\n+     * Is this instant equal to the current instant\n+     * comparing solely by millisecond.\n+     * \n+     * @return true if this instant is before the current instant\n+     */\n+    public boolean isEqualNow() {\n+        return isEqual(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this instant equal to the instant passed in\n+     * comparing solely by millisecond.\n+     *\n+     * @param instant  an instant to check against, null means now\n+     * @return true if the instant is equal to the instant passed in\n+     */\n+    public boolean isEqual(ReadableInstant instant) {\n+        long instantMillis = DateTimeUtils.getInstantMillis(instant);\n+        return isEqual(instantMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).\n+     * \n+     * @return ISO8601 time formatted string.\n+     */\n+    public String toString() {\n+        return ISODateTimeFormat.dateTime().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Uses the specified formatter to convert this partial to a String.\n+     *\n+     * @param formatter  the formatter to use, null means use <code>toString()</code>.\n+     * @return the formatted string\n+     * @since 1.1\n+     */\n+    public String toString(DateTimeFormatter formatter) {\n+        if (formatter == null) {\n+            return toString();\n+        }\n+        return formatter.print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/AbstractInterval.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.Interval;\n+import org.joda.time.MutableInterval;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadableInterval;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * AbstractInterval provides the common behaviour for time intervals.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadableInterval} interface should be used when different \n+ * kinds of intervals are to be referenced.\n+ * <p>\n+ * AbstractInterval subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractInterval implements ReadableInterval {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractInterval() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates an interval.\n+     * \n+     * @param start  the start instant in milliseconds\n+     * @param end  the end instant in milliseconds\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    protected void checkInterval(long start, long end) {\n+        if (end < start) {\n+            throw new IllegalArgumentException(\"The end instant must be greater or equal to the start\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the start of this time interval, which is inclusive, as a DateTime.\n+     *\n+     * @return the start of the time interval\n+     */\n+    public DateTime getStart() {\n+        return new DateTime(getStartMillis(), getChronology());\n+    }\n+\n+    /** \n+     * Gets the end of this time interval, which is exclusive, as a DateTime.\n+     *\n+     * @return the end of the time interval\n+     */\n+    public DateTime getEnd() {\n+        return new DateTime(getEndMillis(), getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Does this time interval contain the specified millisecond instant.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. A zero duration interval cannot contain anything.\n+     *\n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval contains the millisecond\n+     */\n+    public boolean contains(long millisInstant) {\n+        long thisStart = getStartMillis();\n+        long thisEnd = getEndMillis();\n+        return (millisInstant >= thisStart && millisInstant < thisEnd);\n+    }\n+\n+    /**\n+     * Does this time interval contain the current instant.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. A zero duration interval cannot contain anything.\n+     *\n+     * @return true if this time interval contains the current instant\n+     */\n+    public boolean containsNow() {\n+        return contains(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Does this time interval contain the specified instant.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. A zero duration interval cannot contain anything.\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * [09:00 to 10:00) contains 08:59  = false (before start)\n+     * [09:00 to 10:00) contains 09:00  = true\n+     * [09:00 to 10:00) contains 09:59  = true\n+     * [09:00 to 10:00) contains 10:00  = false (equals end)\n+     * [09:00 to 10:00) contains 10:01  = false (after end)\n+     * \n+     * [14:00 to 14:00) contains 14:00  = false (zero duration contains nothing)\n+     * </pre>\n+     * Passing in a <code>null</code> parameter will have the same effect as\n+     * calling {@link #containsNow()}.\n+     *\n+     * @param instant  the instant, null means now\n+     * @return true if this time interval contains the instant\n+     */\n+    public boolean contains(ReadableInstant instant) {\n+        if (instant == null) {\n+            return containsNow();\n+        }\n+        return contains(instant.getMillis());\n+    }\n+\n+    /**\n+     * Does this time interval contain the specified time interval.\n+     * <p>\n+     * Non-zero duration intervals are inclusive of the start instant and\n+     * exclusive of the end. The other interval is contained if this interval\n+     * wholly contains, starts, finishes or equals it.\n+     * A zero duration interval cannot contain anything.\n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The <code>contains</code> method is not related to these states.\n+     * In particular, a zero duration interval is contained at the start of\n+     * a larger interval, but does not overlap (it abuts instead).\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * [09:00 to 10:00) contains [09:00 to 10:00)  = true\n+     * [09:00 to 10:00) contains [09:00 to 09:30)  = true\n+     * [09:00 to 10:00) contains [09:30 to 10:00)  = true\n+     * [09:00 to 10:00) contains [09:15 to 09:45)  = true\n+     * [09:00 to 10:00) contains [09:00 to 09:00)  = true\n+     * \n+     * [09:00 to 10:00) contains [08:59 to 10:00)  = false (otherStart before thisStart)\n+     * [09:00 to 10:00) contains [09:00 to 10:01)  = false (otherEnd after thisEnd)\n+     * [09:00 to 10:00) contains [10:00 to 10:00)  = false (otherStart equals thisEnd)\n+     * \n+     * [14:00 to 14:00) contains [14:00 to 14:00)  = false (zero duration contains nothing)\n+     * </pre>\n+     * Passing in a <code>null</code> parameter will have the same effect as\n+     * calling {@link #containsNow()}.\n+     *\n+     * @param interval  the time interval to compare to, null means a zero duration interval now\n+     * @return true if this time interval contains the time interval\n+     */\n+    public boolean contains(ReadableInterval interval) {\n+        if (interval == null) {\n+            return containsNow();\n+        }\n+        long otherStart = interval.getStartMillis();\n+        long otherEnd = interval.getEndMillis();\n+        long thisStart = getStartMillis();\n+        long thisEnd = getEndMillis();\n+        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd);\n+    }\n+\n+    /**\n+     * Does this time interval overlap the specified time interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * An interval overlaps another if it shares some common part of the\n+     * datetime continuum. \n+     * <p>\n+     * When two intervals are compared the result is one of three states:\n+     * (a) they abut, (b) there is a gap between them, (c) they overlap.\n+     * The abuts state takes precedence over the other two, thus a zero duration\n+     * interval at the start of a larger interval abuts and does not overlap.\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * [09:00 to 10:00) overlaps [08:00 to 08:30)  = false (completely before)\n+     * [09:00 to 10:00) overlaps [08:00 to 09:00)  = false (abuts before)\n+     * [09:00 to 10:00) overlaps [08:00 to 09:30)  = true\n+     * [09:00 to 10:00) overlaps [08:00 to 10:00)  = true\n+     * [09:00 to 10:00) overlaps [08:00 to 11:00)  = true\n+     * \n+     * [09:00 to 10:00) overlaps [09:00 to 09:00)  = false (abuts before)\n+     * [09:00 to 10:00) overlaps [09:00 to 09:30)  = true\n+     * [09:00 to 10:00) overlaps [09:00 to 10:00)  = true\n+     * [09:00 to 10:00) overlaps [09:00 to 11:00)  = true\n+     * \n+     * [09:00 to 10:00) overlaps [09:30 to 09:30)  = true\n+     * [09:00 to 10:00) overlaps [09:30 to 10:00)  = true\n+     * [09:00 to 10:00) overlaps [09:30 to 11:00)  = true\n+     * \n+     * [09:00 to 10:00) overlaps [10:00 to 10:00)  = false (abuts after)\n+     * [09:00 to 10:00) overlaps [10:00 to 11:00)  = false (abuts after)\n+     * \n+     * [09:00 to 10:00) overlaps [10:30 to 11:00)  = false (completely after)\n+     * \n+     * [14:00 to 14:00) overlaps [14:00 to 14:00)  = false (abuts before and after)\n+     * [14:00 to 14:00) overlaps [13:00 to 15:00)  = true\n+     * </pre>\n+     *\n+     * @param interval  the time interval to compare to, null means a zero length interval now\n+     * @return true if the time intervals overlap\n+     */\n+    public boolean overlaps(ReadableInterval interval) {\n+        long thisStart = getStartMillis();\n+        long thisEnd = getEndMillis();\n+        if (interval == null) {\n+            long now = DateTimeUtils.currentTimeMillis();\n+            return (thisStart < now && now < thisEnd);\n+        }  else {\n+            long otherStart = interval.getStartMillis();\n+            long otherEnd = interval.getEndMillis();\n+            return (thisStart < otherEnd && otherStart < thisEnd);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this time interval before the specified millisecond instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval is before the instant\n+     */\n+    public boolean isBefore(long millisInstant) {\n+        return (getEndMillis() <= millisInstant);\n+    }\n+\n+    /**\n+     * Is this time interval before the current instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @return true if this time interval is before the current instant\n+     */\n+    public boolean isBeforeNow() {\n+        return isBefore(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this time interval before the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is before the instant\n+     */\n+    public boolean isBefore(ReadableInstant instant) {\n+        if (instant == null) {\n+            return isBeforeNow();\n+        }\n+        return isBefore(instant.getMillis());\n+    }\n+\n+    /**\n+     * Is this time interval entirely before the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param interval  the interval to compare to, null means now\n+     * @return true if this time interval is before the interval specified\n+     */\n+    public boolean isBefore(ReadableInterval interval) {\n+        if (interval == null) {\n+            return isBeforeNow();\n+        }\n+        return isBefore(interval.getStartMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this time interval after the specified millisecond instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param millisInstant  the instant to compare to,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     * @return true if this time interval is after the instant\n+     */\n+    public boolean isAfter(long millisInstant) {\n+        return (getStartMillis() > millisInstant);\n+    }\n+\n+    /**\n+     * Is this time interval after the current instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @return true if this time interval is after the current instant\n+     */\n+    public boolean isAfterNow() {\n+        return isAfter(DateTimeUtils.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Is this time interval after the specified instant.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * \n+     * @param instant  the instant to compare to, null means now\n+     * @return true if this time interval is after the instant\n+     */\n+    public boolean isAfter(ReadableInstant instant) {\n+        if (instant == null) {\n+            return isAfterNow();\n+        }\n+        return isAfter(instant.getMillis());\n+    }\n+\n+    /**\n+     * Is this time interval entirely after the specified interval.\n+     * <p>\n+     * Intervals are inclusive of the start instant and exclusive of the end.\n+     * Only the end time of the specified interval is used in the comparison.\n+     * \n+     * @param interval  the interval to compare to, null means now\n+     * @return true if this time interval is after the interval specified\n+     */\n+    public boolean isAfter(ReadableInterval interval) {\n+        long endMillis;\n+        if (interval == null) {\n+            endMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            endMillis = interval.getEndMillis();\n+        }\n+        return (getStartMillis() >= endMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this interval as an immutable <code>Interval</code> object.\n+     *\n+     * @return the interval as an Interval object\n+     */\n+    public Interval toInterval() {\n+        return new Interval(getStartMillis(), getEndMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Get this time interval as a <code>MutableInterval</code>.\n+     * <p>\n+     * This will always return a new <code>MutableInterval</code> with the same interval.\n+     *\n+     * @return the time interval as a MutableInterval object\n+     */\n+    public MutableInterval toMutableInterval() {\n+        return new MutableInterval(getStartMillis(), getEndMillis(), getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration of this time interval in milliseconds.\n+     * <p>\n+     * The duration is equal to the end millis minus the start millis.\n+     *\n+     * @return the duration of the time interval in milliseconds\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    public long toDurationMillis() {\n+        return FieldUtils.safeAdd(getEndMillis(), -getStartMillis());\n+    }\n+\n+    /**\n+     * Gets the duration of this time interval.\n+     * <p>\n+     * The duration is equal to the end millis minus the start millis.\n+     *\n+     * @return the duration of the time interval\n+     * @throws ArithmeticException if the duration exceeds the capacity of a long\n+     */\n+    public Duration toDuration() {\n+        long durMillis = toDurationMillis();\n+        if (durMillis == 0) {\n+            return Duration.ZERO;\n+        } else {\n+            return new Duration(durMillis);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts the duration of the interval to a <code>Period</code> using the\n+     * All period type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     *\n+     * @return a time period derived from the interval\n+     */\n+    public Period toPeriod() {\n+        return new Period(getStartMillis(), getEndMillis(), getChronology());\n+    }\n+\n+    /**\n+     * Converts the duration of the interval to a <code>Period</code> using the\n+     * specified period type.\n+     * <p>\n+     * This method should be used to exract the field values describing the\n+     * difference between the start and end instants.\n+     *\n+     * @param type  the requested type of the duration, null means AllType\n+     * @return a time period derived from the interval\n+     */\n+    public Period toPeriod(PeriodType type) {\n+        return new Period(getStartMillis(), getEndMillis(), type, getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on start and end millis plus the chronology.\n+     * All ReadableInterval instances are accepted.\n+     * <p>\n+     * To compare the duration of two time intervals, use {@link #toDuration()}\n+     * to get the durations and compare those.\n+     *\n+     * @param readableInterval  a readable interval to check against\n+     * @return true if the start and end millis are equal\n+     */\n+    public boolean equals(Object readableInterval) {\n+        if (this == readableInterval) {\n+            return true;\n+        }\n+        if (readableInterval instanceof ReadableInterval == false) {\n+            return false;\n+        }\n+        ReadableInterval other = (ReadableInterval) readableInterval;\n+        return \n+            getStartMillis() == other.getStartMillis() &&\n+            getEndMillis() == other.getEndMillis() &&\n+            FieldUtils.equals(getChronology(), other.getChronology());\n+    }\n+\n+    /**\n+     * Hashcode compatible with equals method.\n+     *\n+     * @return suitable hashcode\n+     */\n+    public int hashCode() {\n+        long start = getStartMillis();\n+        long end = getEndMillis();\n+        int result = 97;\n+        result = 31 * result + ((int) (start ^ (start >>> 32)));\n+        result = 31 * result + ((int) (end ^ (end >>> 32)));\n+        result = 31 * result + getChronology().hashCode();\n+        return result;\n+    }\n+\n+    /**\n+     * Output a string in ISO8601 interval format.\n+     *\n+     * @return re-parsable string\n+     */\n+    public String toString() {\n+        DateTimeFormatter printer = ISODateTimeFormat.dateHourMinuteSecondFraction();\n+        printer = printer.withChronology(getChronology());\n+        StringBuffer buf = new StringBuffer(48);\n+        printer.printTo(buf, getStartMillis());\n+        buf.append('/');\n+        printer.printTo(buf, getEndMillis());\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/AbstractPartial.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+/**\n+ * AbstractPartial provides a standard base implementation of most methods\n+ * in the ReadablePartial interface.\n+ * <p>\n+ * Calculations on are performed using a {@link Chronology}.\n+ * This chronology is set to be in the UTC time zone for all calculations.\n+ * <p>\n+ * The methods on this class use {@link ReadablePartial#size()},\n+ * {@link AbstractPartial#getField(int, Chronology)} and\n+ * {@link ReadablePartial#getValue(int)} to calculate their results.\n+ * Subclasses may have a better implementation.\n+ * <p>\n+ * AbstractPartial allows subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractPartial\n+        implements ReadablePartial, Comparable<ReadablePartial> {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractPartial() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected abstract DateTimeField getField(int index, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field type at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field type\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeFieldType getFieldType(int index) {\n+        return getField(index, getChronology()).getType();\n+    }\n+\n+    /**\n+     * Gets an array of the field types that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported in an array that may be altered, largest to smallest\n+     */\n+    public DateTimeFieldType[] getFieldTypes() {\n+        DateTimeFieldType[] result = new DateTimeFieldType[size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getFieldType(i);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Gets the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeField getField(int index) {\n+        return getField(index, getChronology());\n+    }\n+\n+    /**\n+     * Gets an array of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported in an array that may be altered, largest to smallest\n+     */\n+    public DateTimeField[] getFields() {\n+        DateTimeField[] result = new DateTimeField[size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getField(i);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field in an array that may be altered, largest to smallest\n+     */\n+    public int[] getValues() {\n+        int[] result = new int[size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getValue(i);\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the value of one of the fields of a datetime.\n+     * <p>\n+     * The field specified must be one of those that is supported by the partial.\n+     *\n+     * @param type  a DateTimeFieldType instance that is supported by this partial\n+     * @return the value of that field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public int get(DateTimeFieldType type) {\n+        return getValue(indexOfSupported(type));\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this partial.\n+     *\n+     * @param type  the type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DateTimeFieldType type) {\n+        return (indexOf(type) != -1);\n+    }\n+\n+    /**\n+     * Gets the index of the specified field, or -1 if the field is unsupported.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of the field, -1 if unsupported\n+     */\n+    public int indexOf(DateTimeFieldType type) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) == type) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Gets the index of the specified field, throwing an exception if the\n+     * field is unsupported.\n+     *\n+     * @param type  the type to check, not null\n+     * @return the index of the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    protected int indexOfSupported(DateTimeFieldType type) {\n+        int index = indexOf(type);\n+        if (index == -1) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Gets the index of the first fields to have the specified duration,\n+     * or -1 if the field is unsupported.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of the field, -1 if unsupported\n+     */\n+    protected int indexOf(DurationFieldType type) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i).getDurationType() == type) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Gets the index of the first fields to have the specified duration,\n+     * throwing an exception if the field is unsupported.\n+     *\n+     * @param type  the type to check, not null\n+     * @return the index of the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    protected int indexOfSupported(DurationFieldType type) {\n+        int index = indexOf(type);\n+        if (index == -1) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return index;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Resolves this partial against another complete instant to create a new\n+     * full instant. The combination is performed using the chronology of the\n+     * specified instant.\n+     * <p>\n+     * For example, if this partial represents a time, then the result of this\n+     * method will be the datetime from the specified base instant plus the\n+     * time from this partial.\n+     *\n+     * @param baseInstant  the instant that provides the missing fields, null means now\n+     * @return the combined datetime\n+     */\n+    public DateTime toDateTime(ReadableInstant baseInstant) {\n+        Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n+        long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this ReadablePartial with another returning true if the chronology,\n+     * field types and values are equal.\n+     *\n+     * @param partial  an object to check against\n+     * @return true if fields and values are equal\n+     */\n+    public boolean equals(Object partial) {\n+        if (this == partial) {\n+            return true;\n+        }\n+        if (partial instanceof ReadablePartial == false) {\n+            return false;\n+        }\n+        ReadablePartial other = (ReadablePartial) partial;\n+        if (size() != other.size()) {\n+            return false;\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n+                return false;\n+            }\n+        }\n+        return FieldUtils.equals(getChronology(), other.getChronology());\n+    }\n+\n+    /**\n+     * Gets a hash code for the ReadablePartial that is compatible with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    public int hashCode() {\n+        int total = 157;\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            total = 23 * total + getValue(i);\n+            total = 23 * total + getFieldType(i).hashCode();\n+        }\n+        total += getChronology().hashCode();\n+        return total;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this partial with another returning an integer\n+     * indicating the order.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * The specified object must be a partial instance whose field types\n+     * match those of this partial.\n+     * <p>\n+     * NOTE: This implementation violates the Comparable contract.\n+     * This method will accept any instance of ReadablePartial as input.\n+     * However, it is possible that some implementations of ReadablePartial\n+     * exist that do not extend AbstractPartial, and thus will throw a\n+     * ClassCastException if compared in the opposite direction.\n+     * The cause of this problem is that ReadablePartial doesn't define\n+     * the compareTo() method, however we can't change that until v2.0.\n+     *\n+     * @param other  an object to check against\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the partial is the wrong class\n+     *  or if it has field types that don't match\n+     * @throws NullPointerException if the partial is null\n+     * @since 1.1\n+     */\n+    public int compareTo(ReadablePartial other) {\n+        if (this == other) {\n+            return 0;\n+        }\n+        if (size() != other.size()) {\n+            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) != other.getFieldType(i)) {\n+                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n+            }\n+        }\n+        // fields are ordered largest first\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) > other.getValue(i)) {\n+                return 1;\n+            }\n+            if (getValue(i) < other.getValue(i)) {\n+                return -1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Is this partial later than the specified partial.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param partial  a partial to check against, must not be null\n+     * @return true if this date is after the date passed in\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     * @since 1.1\n+     */\n+    public boolean isAfter(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(partial) > 0;\n+    }\n+\n+    /**\n+     * Is this partial earlier than the specified partial.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * The first field that is non-equal is used to determine the result.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param partial  a partial to check against, must not be null\n+     * @return true if this date is before the date passed in\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     * @since 1.1\n+     */\n+    public boolean isBefore(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(partial) < 0;\n+    }\n+\n+    /**\n+     * Is this partial the same as the specified partial.\n+     * <p>\n+     * The fields are compared in order, from largest to smallest.\n+     * If all fields are equal, the result is true.\n+     * <p>\n+     * You may not pass null into this method. This is because you need\n+     * a time zone to accurately determine the current date.\n+     *\n+     * @param partial  a partial to check against, must not be null\n+     * @return true if this date is the same as the date passed in\n+     * @throws IllegalArgumentException if the specified partial is null\n+     * @throws ClassCastException if the partial has field types that don't match\n+     * @since 1.1\n+     */\n+    public boolean isEqual(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"Partial cannot be null\");\n+        }\n+        return compareTo(partial) == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Uses the specified formatter to convert this partial to a String.\n+     *\n+     * @param formatter  the formatter to use, null means use <code>toString()</code>.\n+     * @return the formatted string\n+     * @since 1.1\n+     */\n+    public String toString(DateTimeFormatter formatter) {\n+        if (formatter == null) {\n+            return toString();\n+        }\n+        return formatter.print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/AbstractPeriod.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.Period;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * AbstractPeriod provides the common behaviour for period classes.\n+ * <p>\n+ * This class should generally not be used directly by API users. The \n+ * {@link ReadablePeriod} interface should be used when different \n+ * kinds of periods are to be referenced.\n+ * <p>\n+ * AbstractPeriod subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractPeriod implements ReadablePeriod {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractPeriod() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an array of the field types that this period supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n+     *\n+     * @return the fields supported in an array that may be altered, largest to smallest\n+     */\n+    public DurationFieldType[] getFieldTypes() {\n+        DurationFieldType[] result = new DurationFieldType[size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getFieldType(i);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this period supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field in an array that may be altered, largest to smallest\n+     */\n+    public int[] getValues() {\n+        int[] result = new int[size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getValue(i);\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of one of the fields.\n+     * <p>\n+     * If the field type specified is not supported by the period then zero\n+     * is returned.\n+     *\n+     * @param type  the field type to query, null returns zero\n+     * @return the value of that field, zero if field not supported\n+     */\n+    public int get(DurationFieldType type) {\n+        int index = indexOf(type);\n+        if (index == -1) {\n+            return 0;\n+        }\n+        return getValue(index);\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this period.\n+     *\n+     * @param type  the type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        return getPeriodType().isSupported(type);\n+    }\n+\n+    /**\n+     * Gets the index of the field in this period.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of -1 if not supported\n+     */\n+    public int indexOf(DurationFieldType type) {\n+        return getPeriodType().indexOf(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this period as an immutable <code>Period</code> object.\n+     * \n+     * @return a Period using the same field set and values\n+     */\n+    public Period toPeriod() {\n+        return new Period(this);\n+    }\n+\n+    /**\n+     * Get this object as a <code>MutablePeriod</code>.\n+     * <p>\n+     * This will always return a new <code>MutablePeriod</code> with the same fields.\n+     * \n+     * @return a MutablePeriod using the same field set and values\n+     */\n+    public MutablePeriod toMutablePeriod() {\n+        return new MutablePeriod(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the value of each field. All ReadablePeriod instances are accepted.\n+     * <p>\n+     * Note that a period of 1 day is not equal to a period of 24 hours,\n+     * nor is 1 hour equal to 60 minutes. Only periods with the same amount\n+     * in each field are equal.\n+     * <p>\n+     * This is because periods represent an abstracted definition of a time\n+     * period (eg. a day may not actually be 24 hours, it might be 23 or 25\n+     * at daylight savings boundary).\n+     * <p>\n+     * To compare the actual duration of two periods, convert both to\n+     * {@link org.joda.time.Duration Duration}s, an operation that emphasises\n+     * that the result may differ according to the date you choose.\n+     *\n+     * @param period  a readable period to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the period is null or of an incorrect type\n+     */\n+    public boolean equals(Object period) {\n+        if (this == period) {\n+            return true;\n+        }\n+        if (period instanceof ReadablePeriod == false) {\n+            return false;\n+        }\n+        ReadablePeriod other = (ReadablePeriod) period;\n+        if (size() != other.size()) {\n+            return false;\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets a hash code for the period as defined by ReadablePeriod.\n+     *\n+     * @return a hash code\n+     */\n+    public int hashCode() {\n+        int total = 17;\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            total = 27 * total + getValue(i);\n+            total = 27 * total + getFieldType(i).hashCode();\n+        }\n+        return total;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a String in the ISO8601 duration format.\n+     * <p>\n+     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n+     * <p>\n+     * For more control over the output, see\n+     * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.\n+     *\n+     * @return the value as an ISO8601 string\n+     */\n+    public String toString() {\n+        return ISOPeriodFormat.standard().print(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Uses the specified formatter to convert this period to a String.\n+     *\n+     * @param formatter  the formatter to use, null means use <code>toString()</code>.\n+     * @return the formatted string\n+     * @since 1.5\n+     */\n+    public String toString(PeriodFormatter formatter) {\n+        if (formatter == null) {\n+            return toString();\n+        }\n+        return formatter.print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/BaseDateTime.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableDateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.InstantConverter;\n+\n+/**\n+ * BaseDateTime is an abstract implementation of ReadableDateTime that stores\n+ * data in <code>long</code> and <code>Chronology</code> fields.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableDateTime} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * BaseDateTime subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Kandarp Shah\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class BaseDateTime\n+        extends AbstractDateTime\n+        implements ReadableDateTime, Serializable {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -6728882245981L;\n+\n+    /** The millis from 1970-01-01T00:00:00Z */\n+    private long iMillis;\n+    /** The chronology to use */\n+    private Chronology iChronology;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the default time zone.\n+     */\n+    public BaseDateTime() {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public BaseDateTime(DateTimeZone zone) {\n+        this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the current system millisecond time\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public BaseDateTime(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public BaseDateTime(long instant) {\n+        this(instant, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public BaseDateTime(long instant, DateTimeZone zone) {\n+        this(instant, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public BaseDateTime(long instant, Chronology chronology) {\n+        super();\n+        iChronology = checkChronology(chronology);\n+        iMillis = checkInstant(instant, iChronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * forcing the time zone to that specified.\n+     * <p>\n+     * If the object contains no chronology, <code>ISOChronology</code> is used.\n+     * If the specified time zone is null, the default zone is used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @param zone  the time zone\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public BaseDateTime(Object instant, DateTimeZone zone) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        Chronology chrono = checkChronology(converter.getChronology(instant, zone));\n+        iChronology = chrono;\n+        iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a datetime,\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, ISO in the default time zone is used.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public BaseDateTime(Object instant, Chronology chronology) {\n+        super();\n+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);\n+        iChronology = checkChronology(converter.getChronology(instant, chronology));\n+        iMillis = checkInstant(converter.getInstantMillis(instant, chronology), iChronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the default time zone.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public BaseDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance());\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using <code>ISOChronology</code> in the specified time zone.\n+     * <p>\n+     * If the specified time zone is null, the default zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param zone  the time zone, null means default time zone\n+     */\n+    public BaseDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            DateTimeZone zone) {\n+        this(year, monthOfYear, dayOfMonth, hourOfDay,\n+            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));\n+    }\n+\n+    /**\n+     * Constructs an instance from datetime field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * in the default time zone is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public BaseDateTime(\n+            int year,\n+            int monthOfYear,\n+            int dayOfMonth,\n+            int hourOfDay,\n+            int minuteOfHour,\n+            int secondOfMinute,\n+            int millisOfSecond,\n+            Chronology chronology) {\n+        super();\n+        iChronology = checkChronology(chronology);\n+        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        iMillis = checkInstant(instant, iChronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the specified chronology before storing it, potentially altering it.\n+     * This method must not access any instance variables.\n+     * <p>\n+     * This implementation converts nulls to ISOChronology in the default zone.\n+     *\n+     * @param chronology  the chronology to use, may be null\n+     * @return the chronology to store in this datetime, not null\n+     */\n+    protected Chronology checkChronology(Chronology chronology) {\n+        return DateTimeUtils.getChronology(chronology);\n+    }\n+\n+    /**\n+     * Checks the specified instant before storing it, potentially altering it.\n+     * This method must not access any instance variables.\n+     * <p>\n+     * This implementation simply returns the instant.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @param chronology  the chronology to use, not null\n+     * @return the instant to store in this datetime\n+     */\n+    protected long checkInstant(long instant, Chronology chronology) {\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds of the datetime instant from the Java epoch\n+     * of 1970-01-01T00:00:00Z.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n+     */\n+    public long getMillis() {\n+        return iMillis;\n+    }\n+\n+    /**\n+     * Gets the chronology of the datetime.\n+     * \n+     * @return the Chronology that the datetime is using\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the milliseconds of the datetime.\n+     * <p>\n+     * All changes to the millisecond field occurs via this method.\n+     * Override and block this method to make a subclass immutable.\n+     *\n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the datetime to\n+     */\n+    protected void setMillis(long instant) {\n+        iMillis = checkInstant(instant, iChronology);\n+    }\n+\n+    /**\n+     * Sets the chronology of the datetime.\n+     * <p>\n+     * All changes to the chronology field occurs via this method.\n+     * Override and block this method to make a subclass immutable.\n+     *\n+     * @param chronology  the chronology to set\n+     */\n+    protected void setChronology(Chronology chronology) {\n+        iChronology = checkChronology(chronology);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/BaseDuration.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.Interval;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.DurationConverter;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * BaseDuration is an abstract implementation of ReadableDuration that stores\n+ * data in a <code>long</code> duration milliseconds field.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableDuration} interface should be used when different \n+ * kinds of duration objects are to be referenced.\n+ * <p>\n+ * BaseDuration subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class BaseDuration\n+        extends AbstractDuration\n+        implements ReadableDuration, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2581698638990L;\n+\n+    /** The duration length */\n+    private long iMillis;\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    protected BaseDuration(long duration) {\n+        super();\n+        iMillis = duration;\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n+     */\n+    protected BaseDuration(long startInstant, long endInstant) {\n+        super();\n+        iMillis = FieldUtils.safeAdd(endInstant, -startInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param start  interval start, null means now\n+     * @param end  interval end, null means now\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n+     */\n+    protected BaseDuration(ReadableInstant start, ReadableInstant end) {\n+        super();\n+        if (start == end) {\n+            iMillis = 0L;\n+        } else {\n+            long startMillis = DateTimeUtils.getInstantMillis(start);\n+            long endMillis = DateTimeUtils.getInstantMillis(end);\n+            iMillis = FieldUtils.safeAdd(endMillis, -startMillis);\n+        }\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     */\n+    protected BaseDuration(Object duration) {\n+        super();\n+        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n+        iMillis = converter.getDurationMillis(duration);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of this duration in milliseconds.\n+     *\n+     * @return the length of the duration in milliseconds.\n+     */\n+    public long getMillis() {\n+        return iMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the length of this duration in milliseconds.\n+     * \n+     * @param duration  the new length of the duration\n+     */\n+    protected void setMillis(long duration) {\n+        iMillis = duration;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this duration to a Period instance using the specified period type\n+     * and the ISO chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * At most these are hours, minutes, seconds and millis - the period\n+     * type may restrict the selection further.\n+     * <p>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link #toPeriodFrom(ReadableInstant, PeriodType)}.\n+     * \n+     * @param type  the period type to use, null means standard\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriod(PeriodType type) {\n+        return new Period(getMillis(), type);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance using the standard period type\n+     * and the specified chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Exactly which fields are precise depends on the chronology.\n+     * Only the time fields are precise for ISO chronology with a time zone.\n+     * However, ISO UTC also has precise days and weeks.\n+     * <p>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link #toPeriodFrom(ReadableInstant)} and\n+     * {@link #toPeriodTo(ReadableInstant)}\n+     * \n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriod(Chronology chrono) {\n+        return new Period(getMillis(), chrono);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance using the specified period type\n+     * and chronology.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Exactly which fields are precise depends on the chronology.\n+     * Only the time fields are precise for ISO chronology with a time zone.\n+     * However, ISO UTC also has precise days and weeks.\n+     * <p>\n+     * For more control over the conversion process, you must pair the duration with\n+     * an instant, see {@link #toPeriodFrom(ReadableInstant, PeriodType)} and\n+     * {@link #toPeriodTo(ReadableInstant, PeriodType)}\n+     * \n+     * @param type  the period type to use, null means standard\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriod(PeriodType type, Chronology chrono) {\n+        return new Period(getMillis(), type, chrono);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance by adding the duration to a start\n+     * instant to obtain an interval using the standard period type.\n+     * <p>\n+     * This conversion will determine the fields of a period accurately.\n+     * The results are based on the instant millis, the chronology of the instant,\n+     * the standard period type and the length of this duration.\n+     * \n+     * @param startInstant  the instant to calculate the period from, null means now\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriodFrom(ReadableInstant startInstant) {\n+        return new Period(startInstant, this);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance by adding the duration to a start\n+     * instant to obtain an interval.\n+     * <p>\n+     * This conversion will determine the fields of a period accurately.\n+     * The results are based on the instant millis, the chronology of the instant,\n+     * the period type and the length of this duration.\n+     * \n+     * @param startInstant  the instant to calculate the period from, null means now\n+     * @param type  the period type determining how to split the duration into fields, null means All type\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriodFrom(ReadableInstant startInstant, PeriodType type) {\n+        return new Period(startInstant, this, type);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance by subtracting the duration\n+     * from an end instant to obtain an interval using the standard period\n+     * type.\n+     * <p>\n+     * This conversion will determine the fields of a period accurately.\n+     * The results are based on the instant millis, the chronology of the instant,\n+     * the standard period type and the length of this duration.\n+     * \n+     * @param endInstant  the instant to calculate the period to, null means now\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriodTo(ReadableInstant endInstant) {\n+        return new Period(this, endInstant);\n+    }\n+\n+    /**\n+     * Converts this duration to a Period instance by subtracting the duration\n+     * from an end instant to obtain an interval using the standard period\n+     * type.\n+     * <p>\n+     * This conversion will determine the fields of a period accurately.\n+     * The results are based on the instant millis, the chronology of the instant,\n+     * the period type and the length of this duration.\n+     * \n+     * @param endInstant  the instant to calculate the period to, null means now\n+     * @param type  the period type determining how to split the duration into fields, null means All type\n+     * @return a Period created using the millisecond duration from this instance\n+     */\n+    public Period toPeriodTo(ReadableInstant endInstant, PeriodType type) {\n+        return new Period(this, endInstant, type);\n+    }\n+\n+    /**\n+     * Converts this duration to an Interval starting at the specified instant.\n+     * \n+     * @param startInstant  the instant to start the interval at, null means now\n+     * @return an Interval starting at the specified instant\n+     */\n+    public Interval toIntervalFrom(ReadableInstant startInstant) {\n+        return new Interval(startInstant, this);\n+    }\n+\n+    /**\n+     * Converts this duration to an Interval ending at the specified instant.\n+     * \n+     * @param endInstant  the instant to end the interval at, null means now\n+     * @return an Interval ending at the specified instant\n+     */\n+    public Interval toIntervalTo(ReadableInstant endInstant) {\n+        return new Interval(this, endInstant);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/BaseInterval.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.MutableInterval;\n+import org.joda.time.ReadWritableInterval;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadableInterval;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.IntervalConverter;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * BaseInterval is an abstract implementation of ReadableInterval that stores\n+ * data in two <code>long</code> millisecond fields.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableInterval} interface should be used when different \n+ * kinds of interval objects are to be referenced.\n+ * <p>\n+ * BaseInterval subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Sean Geoghegan\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class BaseInterval\n+        extends AbstractInterval\n+        implements ReadableInterval, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 576586928732749278L;\n+\n+    /** The chronology of the interval */\n+    private Chronology iChronology;\n+    /** The start of the interval */\n+    private long iStartMillis;\n+    /** The end of the interval */\n+    private long iEndMillis;\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.\n+     * @param chrono  the chronology to use, null is ISO default\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    protected BaseInterval(long startInstant, long endInstant, Chronology chrono) {\n+        super();\n+        iChronology = DateTimeUtils.getChronology(chrono);\n+        checkInterval(startInstant, endInstant);\n+        iStartMillis = startInstant;\n+        iEndMillis = endInstant;\n+    }\n+\n+    /**\n+     * Constructs an interval from a start and end instant.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    protected BaseInterval(ReadableInstant start, ReadableInstant end) {\n+        super();\n+        if (start == null && end == null) {\n+            iStartMillis = iEndMillis = DateTimeUtils.currentTimeMillis();\n+            iChronology = ISOChronology.getInstance();\n+        } else {\n+            iChronology = DateTimeUtils.getInstantChronology(start);\n+            iStartMillis = DateTimeUtils.getInstantMillis(start);\n+            iEndMillis = DateTimeUtils.getInstantMillis(end);\n+            checkInterval(iStartMillis, iEndMillis);\n+        }\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a duration.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param duration  the duration of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    protected BaseInterval(ReadableInstant start, ReadableDuration duration) {\n+        super();\n+        iChronology = DateTimeUtils.getInstantChronology(start);\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        iEndMillis = FieldUtils.safeAdd(iStartMillis, durationMillis);\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs an interval from a millisecond duration and an end instant.\n+     * \n+     * @param duration  the duration of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    protected BaseInterval(ReadableDuration duration, ReadableInstant end) {\n+        super();\n+        iChronology = DateTimeUtils.getInstantChronology(end);\n+        iEndMillis = DateTimeUtils.getInstantMillis(end);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis);\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs an interval from a start instant and a time period.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param period  the period of this interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    protected BaseInterval(ReadableInstant start, ReadablePeriod period) {\n+        super();\n+        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n+        iChronology = chrono;\n+        iStartMillis = DateTimeUtils.getInstantMillis(start);\n+        if (period == null) {\n+            iEndMillis = iStartMillis;\n+        } else {\n+            iEndMillis = chrono.add(period, iStartMillis, 1);\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs an interval from a time period and an end instant.\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the period is used.\n+     * \n+     * @param period  the period of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    protected BaseInterval(ReadablePeriod period, ReadableInstant end) {\n+        super();\n+        Chronology chrono = DateTimeUtils.getInstantChronology(end);\n+        iChronology = chrono;\n+        iEndMillis = DateTimeUtils.getInstantMillis(end);\n+        if (period == null) {\n+            iStartMillis = iEndMillis;\n+        } else {\n+            iStartMillis = chrono.add(period, iEndMillis, -1);\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    /**\n+     * Constructs a time interval converting or copying from another object\n+     * that describes an interval.\n+     * \n+     * @param interval  the time interval to copy\n+     * @param chrono  the chronology to use, null means let converter decide\n+     * @throws IllegalArgumentException if the interval is invalid\n+     */\n+    protected BaseInterval(Object interval, Chronology chrono) {\n+        super();\n+        IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);\n+        if (converter.isReadableInterval(interval, chrono)) {\n+            ReadableInterval input = (ReadableInterval) interval;\n+            iChronology = (chrono != null ? chrono : input.getChronology());\n+            iStartMillis = input.getStartMillis();\n+            iEndMillis = input.getEndMillis();\n+        } else if (this instanceof ReadWritableInterval) {\n+            converter.setInto((ReadWritableInterval) this, interval, chrono);\n+        } else {\n+            MutableInterval mi = new MutableInterval();\n+            converter.setInto(mi, interval, chrono);\n+            iChronology = mi.getChronology();\n+            iStartMillis = mi.getStartMillis();\n+            iEndMillis = mi.getEndMillis();\n+        }\n+        checkInterval(iStartMillis, iEndMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology of this interval.\n+     *\n+     * @return the chronology\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    /**\n+     * Gets the start of this time interval which is inclusive.\n+     *\n+     * @return the start of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getStartMillis() {\n+        return iStartMillis;\n+    }\n+\n+    /**\n+     * Gets the end of this time interval which is exclusive.\n+     *\n+     * @return the end of the time interval,\n+     *  millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getEndMillis() {\n+        return iEndMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets this interval from two millisecond instants and a chronology.\n+     *\n+     * @param startInstant  the start of the time interval\n+     * @param endInstant  the start of the time interval\n+     * @param chrono  the chronology, not null\n+     * @throws IllegalArgumentException if the end is before the start\n+     */\n+    protected void setInterval(long startInstant, long endInstant, Chronology chrono) {\n+        checkInterval(startInstant, endInstant);\n+        iStartMillis = startInstant;\n+        iEndMillis = endInstant;\n+        iChronology = DateTimeUtils.getChronology(chrono);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/BaseLocal.java\n+/*\n+ *  Copyright 2001-2007 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+/**\n+ * BaseLocal is an abstract implementation of ReadablePartial that\n+ * use a local milliseconds internal representation.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link org.joda.time.ReadablePartial} interface should be used when different \n+ * kinds of partial objects are to be referenced.\n+ * <p>\n+ * BasePartial subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.5\n+ */\n+public abstract class BaseLocal\n+        extends AbstractPartial {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 276453175381783L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a partial with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    protected BaseLocal() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the local milliseconds from the Java epoch\n+     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).\n+     * <p>\n+     * This method is useful in certain circustances for high performance\n+     * access to the datetime fields.\n+     * \n+     * @return the number of milliseconds since 1970-01-01T00:00:00\n+     */\n+    protected abstract long getLocalMillis();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/BasePartial.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.PartialConverter;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+/**\n+ * BasePartial is an abstract implementation of ReadablePartial that stores\n+ * data in array and <code>Chronology</code> fields.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link org.joda.time.ReadablePartial} interface should be used when different \n+ * kinds of partial objects are to be referenced.\n+ * <p>\n+ * BasePartial subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class BasePartial\n+        extends AbstractPartial\n+        implements ReadablePartial, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2353678632973660L;\n+\n+    /** The chronology in use */\n+    private Chronology iChronology;\n+    /** The values of each field in this partial */\n+    private int[] iValues;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a partial with the current time, using ISOChronology in\n+     * the default zone to extract the fields.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     */\n+    protected BasePartial() {\n+        this(DateTimeUtils.currentTimeMillis(), null);\n+    }\n+\n+    /**\n+     * Constructs a partial with the current time, using the specified chronology\n+     * and zone to extract the fields.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    protected BasePartial(Chronology chronology) {\n+        this(DateTimeUtils.currentTimeMillis(), chronology);\n+    }\n+\n+    /**\n+     * Constructs a partial extracting the partial fields from the specified\n+     * milliseconds using the ISOChronology in the default zone.\n+     * <p>\n+     * The constructor uses the default time zone, resulting in the local time\n+     * being initialised. Once the constructor is complete, all further calculations\n+     * are performed without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    protected BasePartial(long instant) {\n+        this(instant, null);\n+    }\n+\n+    /**\n+     * Constructs a partial extracting the partial fields from the specified\n+     * milliseconds using the chronology provided.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     */\n+    protected BasePartial(long instant, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        iValues = chronology.get(this, instant);\n+    }\n+\n+    /**\n+     * Constructs a partial from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology, null means use converter\n+     * @throws IllegalArgumentException if the date is invalid\n+     */\n+    protected BasePartial(Object instant, Chronology chronology) {\n+        super();\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        iValues = converter.getPartialValues(this, instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs a partial from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     *\n+     * @param instant  the datetime object\n+     * @param chronology  the chronology, null means use converter\n+     * @param parser  if converting from a String, the given parser is preferred\n+     * @throws IllegalArgumentException if the date is invalid\n+     * @since 1.3\n+     */\n+    protected BasePartial(Object instant, Chronology chronology, DateTimeFormatter parser) {\n+        super();\n+        PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant);\n+        chronology = converter.getChronology(instant, chronology);\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        iValues = converter.getPartialValues(this, instant, chronology, parser);\n+    }\n+\n+    /**\n+     * Constructs a partial with specified time field values and chronology.\n+     * <p>\n+     * The constructor uses the time zone of the chronology specified.\n+     * Once the constructor is complete, all further calculations are performed\n+     * without reference to a timezone (by switching to UTC).\n+     * <p>\n+     * The array of values is assigned (not cloned) to the new instance.\n+     *\n+     * @param values  the new set of values\n+     * @param chronology  the chronology, null means ISOChronology in the default zone\n+     * @throws IllegalArgumentException if the values are invalid\n+     */\n+    protected BasePartial(int[] values, Chronology chronology) {\n+        super();\n+        chronology = DateTimeUtils.getChronology(chronology);\n+        iChronology = chronology.withUTC();\n+        chronology.validate(this, values);\n+        iValues = values;\n+    }\n+\n+    /**\n+     * Private constructor to be used by subclasses only which performs no validation.\n+     * <p>\n+     * Data is assigned (not cloned) to the new instance.\n+     *\n+     * @param base  the base partial\n+     * @param values  the new set of values, not cloned, null means use base\n+     */\n+    protected BasePartial(BasePartial base, int[] values) {\n+        super();\n+        iChronology = base.iChronology;\n+        iValues = values;\n+    }\n+\n+    /**\n+     * Private constructor to be used by subclasses only which performs no validation.\n+     * <p>\n+     * Data is assigned (not cloned) to the new instance.\n+     * This should not be used by mutable subclasses.\n+     *\n+     * @param base  the base partial\n+     * @param chrono  the chronology to use, null means use base\n+     */\n+    protected BasePartial(BasePartial base, Chronology chrono) {\n+        super();\n+        iChronology = chrono.withUTC();\n+        iValues = base.iValues;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the value\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        return iValues[index];\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field (cloned), largest to smallest\n+     */\n+    public int[] getValues() {\n+        return (int[]) iValues.clone();\n+    }\n+\n+    /**\n+     * Gets the chronology of the partial which is never null.\n+     * <p>\n+     * The {@link Chronology} is the calculation engine behind the partial and\n+     * provides conversion and validation of the fields in a particular calendar system.\n+     * \n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology() {\n+        return iChronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @param value  the value to set\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void setValue(int index, int value) {\n+        DateTimeField field = getField(index);\n+        iValues = field.set(this, index, iValues, value);\n+    }\n+\n+    /**\n+     * Sets the values of all fields.\n+     * \n+     * @param values  the array of values\n+     */\n+    protected void setValues(int[] values) {\n+        getChronology().validate(this, values);\n+        iValues = values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/BasePeriod.java\n+/*\n+ *  Copyright 2001-2007 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.Duration;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.PeriodConverter;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * BasePeriod is an abstract implementation of ReadablePeriod that stores\n+ * data in a <code>PeriodType</code> and an <code>int[]</code>.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadablePeriod} interface should be used when different \n+ * kinds of period objects are to be referenced.\n+ * <p>\n+ * BasePeriod subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class BasePeriod\n+        extends AbstractPeriod\n+        implements ReadablePeriod, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2110953284060001145L;\n+\n+    /** The type of period */\n+    private PeriodType iType;\n+    /** The values */\n+    private int[] iValues;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a period from a set of field values.\n+     *\n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @param type  which set of fields this period supports\n+     * @throws IllegalArgumentException if period type is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected BasePeriod(int years, int months, int weeks, int days,\n+                         int hours, int minutes, int seconds, int millis,\n+                         PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        iType = type;\n+        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n+        super();\n+        type = checkPeriodType(type);\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        iType = type;\n+        iValues = chrono.get(this, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this period supports, null means standard\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        if (startInstant == null && endInstant == null) {\n+            iType = type;\n+            iValues = new int[size()];\n+        } else {\n+            long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n+            long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n+            Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);\n+            iType = type;\n+            iValues = chrono.get(this, startMillis, endMillis);\n+        }\n+    }\n+\n+    /**\n+     * Creates a period from the given duration and end point.\n+     * <p>\n+     * The two partials must contain the same fields, thus you can\n+     * specify two <code>LocalDate</code> objects, or two <code>LocalTime</code>\n+     * objects, but not one of each.\n+     * As these are Partial objects, time zones have no effect on the result.\n+     * <p>\n+     * The two partials must also both be contiguous - see\n+     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a\n+     * definition. Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n+     *\n+     * @param start  the start of the period, must not be null\n+     * @param end  the end of the period, must not be null\n+     * @param type  which set of fields this period supports, null means standard\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     * @since 1.1\n+     */\n+    protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) {\n+        super();\n+        if (start == null || end == null) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n+        }\n+        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n+            // for performance\n+            type = checkPeriodType(type);\n+            long startMillis = ((BaseLocal) start).getLocalMillis();\n+            long endMillis = ((BaseLocal) end).getLocalMillis();\n+            Chronology chrono = start.getChronology();\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            iType = type;\n+            iValues = chrono.get(this, startMillis, endMillis);\n+        } else {\n+            if (start.size() != end.size()) {\n+                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+            }\n+            for (int i = 0, isize = start.size(); i < isize; i++) {\n+                if (start.getFieldType(i) != end.getFieldType(i)) {\n+                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+                }\n+            }\n+            if (DateTimeUtils.isContiguous(start) == false) {\n+                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n+            }\n+            iType = checkPeriodType(type);\n+            Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n+            iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));\n+        }\n+    }\n+\n+    /**\n+     * Creates a period from the given start point and duration.\n+     *\n+     * @param startInstant  the interval start, null means now\n+     * @param duration  the duration of the interval, null means zero-length\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        long endMillis = FieldUtils.safeAdd(startMillis, durationMillis);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n+        iType = type;\n+        iValues = chrono.get(this, startMillis, endMillis);\n+    }\n+\n+    /**\n+     * Creates a period from the given duration and end point.\n+     *\n+     * @param duration  the duration of the interval, null means zero-length\n+     * @param endInstant  the interval end, null means now\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n+        super();\n+        type = checkPeriodType(type);\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n+        long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n+        iType = type;\n+        iValues = chrono.get(this, startMillis, endMillis);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration, which is only really\n+     * suitable for durations less than one day.\n+     * <p>\n+     * Only fields that are precise will be used.\n+     * Thus the largest precise field may have a large value.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @throws IllegalArgumentException if period type is invalid\n+     */\n+    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n+        super();\n+        type = checkPeriodType(type);\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        iType = type;\n+        iValues = chrono.get(this, duration);\n+    }\n+\n+    /**\n+     * Creates a new period based on another using the {@link ConverterManager}.\n+     *\n+     * @param period  the period to convert\n+     * @param type  which set of fields this period supports, null means use type from object\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\n+        super();\n+        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n+        type = (type == null ? converter.getPeriodType(period) : type);\n+        type = checkPeriodType(type);\n+        iType = type;\n+        if (this instanceof ReadWritablePeriod) {\n+            iValues = new int[size()];\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            converter.setInto((ReadWritablePeriod) this, period, chrono);\n+        } else {\n+            iValues = new MutablePeriod(period, type, chrono).getValues();\n+        }\n+    }\n+\n+    /**\n+     * Constructor used when we trust ourselves.\n+     * Do not expose publically.\n+     *\n+     * @param values  the values to use, not null, not cloned\n+     * @param type  which set of fields this period supports, not null\n+     */\n+    protected BasePeriod(int[] values, PeriodType type) {\n+        super();\n+        iType = type;\n+        iValues = values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a period type, converting nulls to a default value and\n+     * checking the type is suitable for this instance.\n+     * \n+     * @param type  the type to check, may be null\n+     * @return the validated type to use, not null\n+     * @throws IllegalArgumentException if the period type is invalid\n+     */\n+    protected PeriodType checkPeriodType(PeriodType type) {\n+        return DateTimeUtils.getPeriodType(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the period type.\n+     *\n+     * @return the period type\n+     */\n+    public PeriodType getPeriodType() {\n+        return iType;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields that this period supports.\n+     *\n+     * @return the number of fields supported\n+     */\n+    public int size() {\n+        return iType.size();\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DurationFieldType getFieldType(int index) {\n+        return iType.getFieldType(index);\n+    }\n+\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        return iValues[index];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the total millisecond duration of this period relative to a start instant.\n+     * <p>\n+     * This method adds the period to the specified instant in order to\n+     * calculate the duration.\n+     * <p>\n+     * An instant must be supplied as the duration of a period varies.\n+     * For example, a period of 1 month could vary between the equivalent of\n+     * 28 and 31 days in milliseconds due to different length months.\n+     * Similarly, a day can vary at Daylight Savings cutover, typically between\n+     * 23 and 25 hours.\n+     *\n+     * @param startInstant  the instant to add the period to, thus obtaining the duration\n+     * @return the total length of the period as a duration relative to the start instant\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public Duration toDurationFrom(ReadableInstant startInstant) {\n+        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n+        long endMillis = chrono.add(this, startMillis, 1);\n+        return new Duration(startMillis, endMillis);\n+    }\n+\n+    /**\n+     * Gets the total millisecond duration of this period relative to an\n+     * end instant.\n+     * <p>\n+     * This method subtracts the period from the specified instant in order\n+     * to calculate the duration.\n+     * <p>\n+     * An instant must be supplied as the duration of a period varies.\n+     * For example, a period of 1 month could vary between the equivalent of\n+     * 28 and 31 days in milliseconds due to different length months.\n+     * Similarly, a day can vary at Daylight Savings cutover, typically between\n+     * 23 and 25 hours.\n+     *\n+     * @param endInstant  the instant to subtract the period from, thus obtaining the duration\n+     * @return the total length of the period as a duration relative to the end instant\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public Duration toDurationTo(ReadableInstant endInstant) {\n+        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n+        long startMillis = chrono.add(this, endMillis, -1);\n+        return new Duration(startMillis, endMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether a field type is supported, and if so adds the new value\n+     * to the relevent index in the specified array.\n+     * \n+     * @param type  the field type\n+     * @param values  the array to update\n+     * @param newValue  the new value to store if successful\n+     */\n+    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n+        int index = indexOf(type);\n+        if (index == -1) {\n+            if (newValue != 0) {\n+                throw new IllegalArgumentException(\n+                    \"Period does not support field '\" + type.getName() + \"'\");\n+            }\n+        } else {\n+            values[index] = newValue;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets all the fields of this period from another.\n+     * \n+     * @param period  the period to copy from, not null\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setPeriod(ReadablePeriod period) {\n+        if (period == null) {\n+            setValues(new int[size()]);\n+        } else {\n+            setPeriodInternal(period);\n+        }\n+    }\n+\n+    /**\n+     * Private method called from constructor.\n+     */\n+    private void setPeriodInternal(ReadablePeriod period) {\n+        int[] newValues = new int[size()];\n+        for (int i = 0, isize = period.size(); i < isize; i++) {\n+            DurationFieldType type = period.getFieldType(i);\n+            int value = period.getValue(i);\n+            checkAndUpdate(type, newValues, value);\n+        }\n+        iValues = newValues;\n+    }\n+\n+    /**\n+     * Sets the eight standard the fields in one go.\n+     * \n+     * @param years  amount of years in this period, which must be zero if unsupported\n+     * @param months  amount of months in this period, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n+     * @param days  amount of days in this period, which must be zero if unsupported\n+     * @param hours  amount of hours in this period, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setPeriod(int years, int months, int weeks, int days,\n+                             int hours, int minutes, int seconds, int millis) {\n+        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Private method called from constructor.\n+     */\n+    private void setPeriodInternal(int years, int months, int weeks, int days,\n+                                   int hours, int minutes, int seconds, int millis) {\n+        int[] newValues = new int[size()];\n+        checkAndUpdate(DurationFieldType.years(), newValues, years);\n+        checkAndUpdate(DurationFieldType.months(), newValues, months);\n+        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n+        checkAndUpdate(DurationFieldType.days(), newValues, days);\n+        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n+        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n+        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n+        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n+        iValues = newValues;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of a field in this period.\n+     * \n+     * @param field  the field to set\n+     * @param value  the value to set\n+     * @throws IllegalArgumentException if field is is null or not supported.\n+     */\n+    protected void setField(DurationFieldType field, int value) {\n+        setFieldInto(iValues, field, value);\n+    }\n+\n+    /**\n+     * Sets the value of a field in this period.\n+     * \n+     * @param values  the array of values to update\n+     * @param field  the field to set\n+     * @param value  the value to set\n+     * @throws IllegalArgumentException if field is null or not supported.\n+     */\n+    protected void setFieldInto(int[] values, DurationFieldType field, int value) {\n+        int index = indexOf(field);\n+        if (index == -1) {\n+            if (value != 0 || field == null) {\n+                throw new IllegalArgumentException(\n+                    \"Period does not support field '\" + field + \"'\");\n+            }\n+        } else {\n+            values[index] = value;\n+        }\n+    }\n+\n+    /**\n+     * Adds the value of a field in this period.\n+     * \n+     * @param field  the field to set\n+     * @param value  the value to set\n+     * @throws IllegalArgumentException if field is is null or not supported.\n+     */\n+    protected void addField(DurationFieldType field, int value) {\n+        addFieldInto(iValues, field, value);\n+    }\n+\n+    /**\n+     * Adds the value of a field in this period.\n+     * \n+     * @param values  the array of values to update\n+     * @param field  the field to set\n+     * @param value  the value to set\n+     * @throws IllegalArgumentException if field is is null or not supported.\n+     */\n+    protected void addFieldInto(int[] values, DurationFieldType field, int value) {\n+        int index = indexOf(field);\n+        if (index == -1) {\n+            if (value != 0 || field == null) {\n+                throw new IllegalArgumentException(\n+                    \"Period does not support field '\" + field + \"'\");\n+            }\n+        } else {\n+            values[index] = FieldUtils.safeAdd(values[index], value);\n+        }\n+    }\n+\n+    /**\n+     * Merges the fields from another period.\n+     * \n+     * @param period  the period to add from, not null\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void mergePeriod(ReadablePeriod period) {\n+        if (period != null) {\n+            iValues = mergePeriodInto(getValues(), period);\n+        }\n+    }\n+\n+    /**\n+     * Merges the fields from another period.\n+     * \n+     * @param values  the array of values to update\n+     * @param period  the period to add from, not null\n+     * @return the updated values\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected int[] mergePeriodInto(int[] values, ReadablePeriod period) {\n+         for (int i = 0, isize = period.size(); i < isize; i++) {\n+             DurationFieldType type = period.getFieldType(i);\n+             int value = period.getValue(i);\n+             checkAndUpdate(type, values, value);\n+         }\n+         return values;\n+    }\n+\n+    /**\n+     * Adds the fields from another period.\n+     * \n+     * @param period  the period to add from, not null\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void addPeriod(ReadablePeriod period) {\n+        if (period != null) {\n+            iValues = addPeriodInto(getValues(), period);\n+        }\n+    }\n+\n+    /**\n+     * Adds the fields from another period.\n+     * \n+     * @param values  the array of values to update\n+     * @param period  the period to add from, not null\n+     * @return the updated values\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected int[] addPeriodInto(int[] values, ReadablePeriod period) {\n+         for (int i = 0, isize = period.size(); i < isize; i++) {\n+             DurationFieldType type = period.getFieldType(i);\n+             int value = period.getValue(i);\n+             if (value != 0) {\n+                 int index = indexOf(type);\n+                 if (index == -1) {\n+                     throw new IllegalArgumentException(\n+                         \"Period does not support field '\" + type.getName() + \"'\");\n+                 } else {\n+                     values[index] = FieldUtils.safeAdd(getValue(index), value);\n+                 }\n+             }\n+         }\n+         return values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @param value  the value to set\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void setValue(int index, int value) {\n+        iValues[index] = value;\n+    }\n+\n+    /**\n+     * Sets the values of all fields.\n+     * \n+     * @param values  the array of values\n+     */\n+    protected void setValues(int[] values) {\n+        iValues = values;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * BaseSingleFieldPeriod is an abstract implementation of ReadablePeriod that\n+ * manages a single duration field, such as days or minutes.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadablePeriod} interface should be used when different \n+ * kinds of period objects are to be referenced.\n+ * <p>\n+ * BaseSingleFieldPeriod subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.4\n+ */\n+public abstract class BaseSingleFieldPeriod\n+        implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 9386874258972L;\n+\n+    /** The period in the units of this period. */\n+    private int iPeriod;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calculates the number of whole units between the two specified datetimes.\n+     *\n+     * @param start  the start instant, validated to not be null\n+     * @param end  the end instant, validated to not be null\n+     * @param field  the field type to use, must not be null\n+     * @return the period\n+     * @throws IllegalArgumentException if the instants are null or invalid\n+     */\n+    protected static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) {\n+        if (start == null || end == null) {\n+            throw new IllegalArgumentException(\"ReadableInstant objects must not be null\");\n+        }\n+        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n+        int amount = field.getField(chrono).getDifference(end.getMillis(), start.getMillis());\n+        return amount;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calculates the number of whole units between the two specified partial datetimes.\n+     * <p>\n+     * The two partials must contain the same fields, for example you can specify\n+     * two <code>LocalDate</code> objects.\n+     *\n+     * @param start  the start partial date, validated to not be null\n+     * @param end  the end partial date, validated to not be null\n+     * @param zeroInstance  the zero instance constant, must not be null\n+     * @return the period\n+     * @throws IllegalArgumentException if the partials are null or invalid\n+     */\n+    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n+        if (start == null || end == null) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n+        }\n+        if (start.size() != end.size()) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+        }\n+        for (int i = 0, isize = start.size(); i < isize; i++) {\n+            if (start.getFieldType(i) != end.getFieldType(i)) {\n+                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n+            }\n+        }\n+        if (DateTimeUtils.isContiguous(start) == false) {\n+            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n+        }\n+        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n+        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n+        return values[0];\n+    }\n+\n+    /**\n+     * Creates a new instance representing the number of complete standard length units\n+     * in the specified period.\n+     * <p>\n+     * This factory method converts all fields from the period to hours using standardised\n+     * durations for each field. Only those fields which have a precise duration in\n+     * the ISO UTC chronology can be converted.\n+     * <ul>\n+     * <li>One week consists of 7 days.\n+     * <li>One day consists of 24 hours.\n+     * <li>One hour consists of 60 minutes.\n+     * <li>One minute consists of 60 seconds.\n+     * <li>One second consists of 1000 milliseconds.\n+     * </ul>\n+     * Months and Years are imprecise and periods containing these values cannot be converted.\n+     *\n+     * @param period  the period to get the number of hours from, must not be null\n+     * @param millisPerUnit  the number of milliseconds in one standard unit of this period\n+     * @throws IllegalArgumentException if the period contains imprecise duration values\n+     */\n+    protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) {\n+        if (period == null) {\n+            return 0;\n+        }\n+        Chronology iso = ISOChronology.getInstanceUTC();\n+        long duration = 0L;\n+        for (int i = 0; i < period.size(); i++) {\n+            int value = period.getValue(i);\n+            if (value != 0) {\n+                DurationField field = period.getFieldType(i).getField(iso);\n+                if (field.isPrecise() == false) {\n+                    throw new IllegalArgumentException(\n+                            \"Cannot convert period to duration as \" + field.getName() +\n+                            \" is not precise in the period \" + period);\n+                }\n+                duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));\n+            }\n+        }\n+        return FieldUtils.safeToInt(duration / millisPerUnit);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance representing the specified period.\n+     *\n+     * @param period  the period to represent\n+     */\n+    protected BaseSingleFieldPeriod(int period) {\n+        super();\n+        iPeriod = period;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the amount of this period.\n+     *\n+     * @return the period value\n+     */\n+    protected int getValue() {\n+        return iPeriod;\n+    }\n+\n+    /**\n+     * Sets the amount of this period.\n+     * To make a subclass immutable you must declare it final, or block this method.\n+     *\n+     * @param value  the period value\n+     */\n+    protected void setValue(int value) {\n+        iPeriod = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the single duration field type.\n+     *\n+     * @return the duration field type, not null\n+     */\n+    public abstract DurationFieldType getFieldType();\n+\n+    /**\n+     * Gets the period type which matches the duration field type.\n+     *\n+     * @return the period type, not null\n+     */\n+    public abstract PeriodType getPeriodType();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields that this period supports, which is one.\n+     *\n+     * @return the number of fields supported, which is one\n+     */\n+    public int size() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     * <p>\n+     * The only index supported by this period is zero which returns the\n+     * field type of this class.\n+     *\n+     * @param index  the index to retrieve, which must be zero\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DurationFieldType getFieldType(int index) {\n+        if (index != 0) {\n+            throw new IndexOutOfBoundsException(String.valueOf(index));\n+        }\n+        return getFieldType();\n+    }\n+\n+    /**\n+     * Gets the value at the specified index.\n+     * <p>\n+     * The only index supported by this period is zero.\n+     *\n+     * @param index  the index to retrieve, which must be zero\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        if (index != 0) {\n+            throw new IndexOutOfBoundsException(String.valueOf(index));\n+        }\n+        return getValue();\n+    }\n+\n+    /**\n+     * Gets the value of a duration field represented by this period.\n+     * <p>\n+     * If the field type specified does not match the type used by this class\n+     * then zero is returned.\n+     *\n+     * @param type  the field type to query, null returns zero\n+     * @return the value of that field, zero if field not supported\n+     */\n+    public int get(DurationFieldType type) {\n+        if (type == getFieldType()) {\n+            return getValue();\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Checks whether the duration field specified is supported by this period.\n+     *\n+     * @param type  the type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        return (type == getFieldType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get this period as an immutable <code>Period</code> object.\n+     * The period will use <code>PeriodType.standard()</code>.\n+     *\n+     * @return a <code>Period</code> representing the same number of days\n+     */\n+    public Period toPeriod() {\n+        return Period.ZERO.withFields(this);\n+    }\n+\n+    /**\n+     * Get this object as a <code>MutablePeriod</code>.\n+     * <p>\n+     * This will always return a new <code>MutablePeriod</code> with the same fields.\n+     * The period will use <code>PeriodType.standard()</code>.\n+     * \n+     * @return a MutablePeriod using the same field set and values\n+     */\n+    public MutablePeriod toMutablePeriod() {\n+        MutablePeriod period = new MutablePeriod();\n+        period.add(this);\n+        return period;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based on the\n+     * value of each field. All ReadablePeriod instances are accepted, but only\n+     * those with a matching <code>PeriodType</code> can return true.\n+     *\n+     * @param period  a readable period to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or the period is null or of an incorrect type\n+     */\n+    public boolean equals(Object period) {\n+        if (this == period) {\n+            return true;\n+        }\n+        if (period instanceof ReadablePeriod == false) {\n+            return false;\n+        }\n+        ReadablePeriod other = (ReadablePeriod) period;\n+        return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());\n+    }\n+\n+    /**\n+     * Gets a hash code for the period as defined by ReadablePeriod.\n+     *\n+     * @return a hash code\n+     */\n+    public int hashCode() {\n+        int total = 17;\n+        total = 27 * total + getValue();\n+        total = 27 * total + getFieldType().hashCode();\n+        return total;\n+    }\n+\n+    /**\n+     * Compares this period to another object of the same class.\n+     *\n+     * @param other  the other period, must not be null\n+     * @return zero if equal, positive if greater, negative if less\n+     * @throws NullPointerException if the other period is null\n+     * @throws ClassCastException if the other period is of a different type\n+     */\n+    public int compareTo(BaseSingleFieldPeriod other) {\n+        if (other.getClass() != getClass()) {\n+            throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n+        }\n+        int otherValue = other.getValue();\n+        int thisValue = getValue();\n+        if (thisValue > otherValue) {\n+            return 1;\n+        }\n+        if (thisValue < otherValue) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/AssembledChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Abstract Chronology that enables chronologies to be assembled from\n+ * a container of fields.\n+ * <p>\n+ * AssembledChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AssembledChronology extends BaseChronology {\n+\n+    private static final long serialVersionUID = -6728465968995518215L;\n+\n+    private final Chronology iBase;\n+    private final Object iParam;\n+\n+    private transient DurationField iMillis;\n+    private transient DurationField iSeconds;\n+    private transient DurationField iMinutes;\n+    private transient DurationField iHours;\n+    private transient DurationField iHalfdays;\n+\n+    private transient DurationField iDays;\n+    private transient DurationField iWeeks;\n+    private transient DurationField iWeekyears;\n+    private transient DurationField iMonths;\n+    private transient DurationField iYears;\n+    private transient DurationField iCenturies;\n+    private transient DurationField iEras;\n+\n+    private transient DateTimeField iMillisOfSecond;\n+    private transient DateTimeField iMillisOfDay;\n+    private transient DateTimeField iSecondOfMinute;\n+    private transient DateTimeField iSecondOfDay;\n+    private transient DateTimeField iMinuteOfHour;\n+    private transient DateTimeField iMinuteOfDay;\n+    private transient DateTimeField iHourOfDay;\n+    private transient DateTimeField iClockhourOfDay;\n+    private transient DateTimeField iHourOfHalfday;\n+    private transient DateTimeField iClockhourOfHalfday;\n+    private transient DateTimeField iHalfdayOfDay;\n+\n+    private transient DateTimeField iDayOfWeek;\n+    private transient DateTimeField iDayOfMonth;\n+    private transient DateTimeField iDayOfYear;\n+    private transient DateTimeField iWeekOfWeekyear;\n+    private transient DateTimeField iWeekyear;\n+    private transient DateTimeField iWeekyearOfCentury;\n+    private transient DateTimeField iMonthOfYear;\n+    private transient DateTimeField iYear;\n+    private transient DateTimeField iYearOfEra;\n+    private transient DateTimeField iYearOfCentury;\n+    private transient DateTimeField iCenturyOfEra;\n+    private transient DateTimeField iEra;\n+\n+    // Bit set determines which base fields are used\n+    // bit 1 set: hourOfDay, minuteOfHour, secondOfMinute, and millisOfSecond fields\n+    // bit 2 set: millisOfDayField\n+    // bit 3 set: year, monthOfYear, and dayOfMonth fields\n+    private transient int iBaseFlags;\n+\n+    /**\n+     * Constructor calls the assemble method, enabling subclasses to define its\n+     * supported fields. If a base chronology is supplied, the field set\n+     * initially contains references to each base chronology field.\n+     * <p>\n+     * Other methods in this class will delegate to the base chronology, if it\n+     * can be determined that the base chronology will produce the same results\n+     * as AbstractChronology.\n+     *\n+     * @param base optional base chronology to copy initial fields from\n+     * @param param optional param object avalable for assemble method\n+     */\n+    protected AssembledChronology(Chronology base, Object param) {\n+        iBase = base;\n+        iParam = param;\n+        setFields();\n+    }\n+\n+    public DateTimeZone getZone() {\n+        Chronology base;\n+        if ((base = iBase) != null) {\n+            return base.getZone();\n+        }\n+        return null;\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 6) == 6) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        }\n+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {\n+            // Only call specialized implementation if applicable fields are the same.\n+            return base.getDateTimeMillis\n+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+        return super.getDateTimeMillis\n+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+    }\n+\n+    public final DurationField millis() {\n+        return iMillis;\n+    }\n+\n+    public final DateTimeField millisOfSecond() {\n+        return iMillisOfSecond;\n+    }\n+\n+    public final DateTimeField millisOfDay() {\n+        return iMillisOfDay;\n+    }\n+\n+    public final DurationField seconds() {\n+        return iSeconds;\n+    }\n+\n+    public final DateTimeField secondOfMinute() {\n+        return iSecondOfMinute;\n+    }\n+\n+    public final DateTimeField secondOfDay() {\n+        return iSecondOfDay;\n+    }\n+\n+    public final DurationField minutes() {\n+        return iMinutes;\n+    }\n+\n+    public final DateTimeField minuteOfHour() {\n+        return iMinuteOfHour;\n+    }\n+\n+    public final DateTimeField minuteOfDay() {\n+        return iMinuteOfDay;\n+    }\n+\n+    public final DurationField hours() {\n+        return iHours;\n+    }\n+\n+    public final DateTimeField hourOfDay() {\n+        return iHourOfDay;\n+    }\n+\n+    public final DateTimeField clockhourOfDay() {\n+        return iClockhourOfDay;\n+    }\n+\n+    public final DurationField halfdays() {\n+        return iHalfdays;\n+    }\n+\n+    public final DateTimeField hourOfHalfday() {\n+        return iHourOfHalfday;\n+    }\n+\n+    public final DateTimeField clockhourOfHalfday() {\n+        return iClockhourOfHalfday;\n+    }\n+\n+    public final DateTimeField halfdayOfDay() {\n+        return iHalfdayOfDay;\n+    }\n+\n+    public final DurationField days() {\n+        return iDays;\n+    }\n+\n+    public final DateTimeField dayOfWeek() {\n+        return iDayOfWeek;\n+    }\n+\n+    public final DateTimeField dayOfMonth() {\n+        return iDayOfMonth;\n+    }\n+\n+    public final DateTimeField dayOfYear() {\n+        return iDayOfYear;\n+    }\n+\n+    public final DurationField weeks() {\n+        return iWeeks;\n+    }\n+\n+    public final DateTimeField weekOfWeekyear() {\n+        return iWeekOfWeekyear;\n+    }\n+\n+    public final DurationField weekyears() {\n+        return iWeekyears;\n+    }\n+\n+    public final DateTimeField weekyear() {\n+        return iWeekyear;\n+    }\n+\n+    public final DateTimeField weekyearOfCentury() {\n+        return iWeekyearOfCentury;\n+    }\n+\n+    public final DurationField months() {\n+        return iMonths;\n+    }\n+\n+    public final DateTimeField monthOfYear() {\n+        return iMonthOfYear;\n+    }\n+\n+    public final DurationField years() {\n+        return iYears;\n+    }\n+\n+    public final DateTimeField year() {\n+        return iYear;\n+    }\n+\n+    public final DateTimeField yearOfEra() {\n+        return iYearOfEra;\n+    }\n+\n+    public final DateTimeField yearOfCentury() {\n+        return iYearOfCentury;\n+    }\n+\n+    public final DurationField centuries() {\n+        return iCenturies;\n+    }\n+\n+    public final DateTimeField centuryOfEra() {\n+        return iCenturyOfEra;\n+    }\n+\n+    public final DurationField eras() {\n+        return iEras;\n+    }\n+\n+    public final DateTimeField era() {\n+        return iEra;\n+    }\n+\n+    /**\n+     * Invoked by the constructor and after deserialization to allow subclasses\n+     * to define all of its supported fields. All unset fields default to\n+     * unsupported instances.\n+     *\n+     * @param fields container of fields\n+     */\n+    protected abstract void assemble(Fields fields);\n+\n+    /**\n+     * Returns the same base chronology as passed into the constructor.\n+     */\n+    protected final Chronology getBase() {\n+        return iBase;\n+    }\n+\n+    /**\n+     * Returns the same param object as passed into the constructor.\n+     */\n+    protected final Object getParam() {\n+        return iParam;\n+    }\n+\n+    private void setFields() {\n+        Fields fields = new Fields();\n+        if (iBase != null) {\n+            fields.copyFieldsFrom(iBase);\n+        }\n+        assemble(fields);\n+\n+        {\n+            DurationField f;\n+            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n+            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n+            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n+            iHours     = (f = fields.hours)     != null ? f : super.hours();\n+            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n+            iDays      = (f = fields.days)      != null ? f : super.days();\n+            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n+            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n+            iMonths    = (f = fields.months)    != null ? f : super.months();\n+            iYears     = (f = fields.years)     != null ? f : super.years();\n+            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n+            iEras      = (f = fields.eras)      != null ? f : super.eras();\n+        }\n+\n+        {\n+            DateTimeField f;\n+            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n+            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n+            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n+            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n+            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n+            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n+            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n+            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n+            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n+            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n+            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n+            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n+            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n+            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n+            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n+            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n+            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n+            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n+            iYear               = (f = fields.year)               != null ? f : super.year();\n+            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n+            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n+            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n+            iEra                = (f = fields.era)                != null ? f : super.era();\n+        }\n+\n+        int flags;\n+        if (iBase == null) {\n+            flags = 0;\n+        } else {\n+            flags = \n+                ((iHourOfDay      == iBase.hourOfDay()      &&\n+                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n+                  iSecondOfMinute == iBase.secondOfMinute() &&\n+                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n+\n+                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n+\n+                ((iYear        == iBase.year()        &&\n+                  iMonthOfYear == iBase.monthOfYear() &&\n+                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n+        }\n+\n+        iBaseFlags = flags;\n+    }\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        setFields();\n+    }\n+\n+    /**\n+     * A container of fields used for assembling a chronology.\n+     */\n+    public static final class Fields {\n+        public DurationField millis;\n+        public DurationField seconds;\n+        public DurationField minutes;\n+        public DurationField hours;\n+        public DurationField halfdays;\n+    \n+        public DurationField days;\n+        public DurationField weeks;\n+        public DurationField weekyears;\n+        public DurationField months;\n+        public DurationField years;\n+        public DurationField centuries;\n+        public DurationField eras;\n+    \n+        public DateTimeField millisOfSecond;\n+        public DateTimeField millisOfDay;\n+        public DateTimeField secondOfMinute;\n+        public DateTimeField secondOfDay;\n+        public DateTimeField minuteOfHour;\n+        public DateTimeField minuteOfDay;\n+        public DateTimeField hourOfDay;\n+        public DateTimeField clockhourOfDay;\n+        public DateTimeField hourOfHalfday;\n+        public DateTimeField clockhourOfHalfday;\n+        public DateTimeField halfdayOfDay;\n+    \n+        public DateTimeField dayOfWeek;\n+        public DateTimeField dayOfMonth;\n+        public DateTimeField dayOfYear;\n+        public DateTimeField weekOfWeekyear;\n+        public DateTimeField weekyear;\n+        public DateTimeField weekyearOfCentury;\n+        public DateTimeField monthOfYear;\n+        public DateTimeField year;\n+        public DateTimeField yearOfEra;\n+        public DateTimeField yearOfCentury;\n+        public DateTimeField centuryOfEra;\n+        public DateTimeField era;\n+\n+        Fields() {\n+        }\n+\n+        /**\n+         * Copy the supported fields from a chronology into this container.\n+         */\n+        public void copyFieldsFrom(Chronology chrono) {\n+            {\n+                DurationField f;\n+                if (isSupported(f = chrono.millis())) {\n+                    millis = f;\n+                }\n+                if (isSupported(f = chrono.seconds())) {\n+                    seconds = f;\n+                }\n+                if (isSupported(f = chrono.minutes())) {\n+                    minutes = f;\n+                }\n+                if (isSupported(f = chrono.hours())) {\n+                    hours = f;\n+                }\n+                if (isSupported(f = chrono.halfdays())) {\n+                    halfdays = f;\n+                }\n+                if (isSupported(f = chrono.days())) {\n+                    days = f;\n+                }\n+                if (isSupported(f = chrono.weeks())) {\n+                    weeks = f;\n+                }\n+                if (isSupported(f = chrono.weekyears())) {\n+                    weekyears = f;\n+                }\n+                if (isSupported(f = chrono.months())) {\n+                    months = f;\n+                }\n+                if (isSupported(f = chrono.years())) {\n+                    years = f;\n+                }\n+                if (isSupported(f = chrono.centuries())) {\n+                    centuries = f;\n+                }\n+                if (isSupported(f = chrono.eras())) {\n+                    eras = f;\n+                }\n+            }\n+\n+            {\n+                DateTimeField f;\n+                if (isSupported(f = chrono.millisOfSecond())) {\n+                    millisOfSecond = f;\n+                }\n+                if (isSupported(f = chrono.millisOfDay())) {\n+                    millisOfDay = f;\n+                }\n+                if (isSupported(f = chrono.secondOfMinute())) {\n+                    secondOfMinute = f;\n+                }\n+                if (isSupported(f = chrono.secondOfDay())) {\n+                    secondOfDay = f;\n+                }\n+                if (isSupported(f = chrono.minuteOfHour())) {\n+                    minuteOfHour = f;\n+                }\n+                if (isSupported(f = chrono.minuteOfDay())) {\n+                    minuteOfDay = f;\n+                }\n+                if (isSupported(f = chrono.hourOfDay())) {\n+                    hourOfDay = f;\n+                }\n+                if (isSupported(f = chrono.clockhourOfDay())) {\n+                    clockhourOfDay = f;\n+                }\n+                if (isSupported(f = chrono.hourOfHalfday())) {\n+                    hourOfHalfday = f;\n+                }\n+                if (isSupported(f = chrono.clockhourOfHalfday())) {\n+                    clockhourOfHalfday = f;\n+                }\n+                if (isSupported(f = chrono.halfdayOfDay())) {\n+                    halfdayOfDay = f;\n+                }\n+                if (isSupported(f = chrono.dayOfWeek())) {\n+                    dayOfWeek = f;\n+                }\n+                if (isSupported(f = chrono.dayOfMonth())) {\n+                    dayOfMonth = f;\n+                }\n+                if (isSupported(f = chrono.dayOfYear())) {\n+                    dayOfYear = f;\n+                }\n+                if (isSupported(f = chrono.weekOfWeekyear())) {\n+                    weekOfWeekyear = f;\n+                }\n+                if (isSupported(f = chrono.weekyear())) {\n+                    weekyear = f;\n+                }\n+                if (isSupported(f = chrono.weekyearOfCentury())) {\n+                    weekyearOfCentury = f;\n+                }\n+                if (isSupported(f = chrono.monthOfYear())) {\n+                    monthOfYear = f;\n+                }\n+                if (isSupported(f = chrono.year())) {\n+                    year = f;\n+                }\n+                if (isSupported(f = chrono.yearOfEra())) {\n+                    yearOfEra = f;\n+                }\n+                if (isSupported(f = chrono.yearOfCentury())) {\n+                    yearOfCentury = f;\n+                }\n+                if (isSupported(f = chrono.centuryOfEra())) {\n+                    centuryOfEra = f;\n+                }\n+                if (isSupported(f = chrono.era())) {\n+                    era = f;\n+                }\n+            }\n+        }\n+\n+        private static boolean isSupported(DurationField field) {\n+            return field == null ? false : field.isSupported();\n+        }\n+\n+        private static boolean isSupported(DateTimeField field) {\n+            return field == null ? false : field.isSupported();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BaseChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.ReadablePeriod;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.UnsupportedDateTimeField;\n+import org.joda.time.field.UnsupportedDurationField;\n+\n+/**\n+ * BaseChronology provides a skeleton implementation for chronology\n+ * classes. Many utility methods are defined, but all fields are unsupported.\n+ * <p>\n+ * BaseChronology is thread-safe and immutable, and all subclasses must be\n+ * as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class BaseChronology\n+        extends Chronology\n+        implements Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -7310865996721419676L;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected BaseChronology() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the DateTimeZone that this Chronology operates in, or null if\n+     * unspecified.\n+     *\n+     * @return DateTimeZone null if unspecified\n+     */\n+    public abstract DateTimeZone getZone();\n+\n+    /**\n+     * Returns an instance of this Chronology that operates in the UTC time\n+     * zone. Chronologies that do not operate in a time zone or are already\n+     * UTC must return themself.\n+     *\n+     * @return a version of this chronology that ignores time zones\n+     */\n+    public abstract Chronology withUTC();\n+    \n+    /**\n+     * Returns an instance of this Chronology that operates in any time zone.\n+     *\n+     * @return a version of this chronology with a specific time zone\n+     * @param zone to use, or default if null\n+     * @see org.joda.time.chrono.ZonedChronology\n+     */\n+    public abstract Chronology withZone(DateTimeZone zone);\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, and millisecond values. The set of given values must refer\n+     * to a valid datetime, or else an IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param millisOfDay millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        return millisOfDay().set(instant, millisOfDay);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, formed from the given year,\n+     * month, day, hour, minute, second, and millisecond values. The set of\n+     * given values must refer to a valid datetime, or else an\n+     * IllegalArgumentException is thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param year year to use\n+     * @param monthOfYear month to use\n+     * @param dayOfMonth day of month to use\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = year().set(0, year);\n+        instant = monthOfYear().set(instant, monthOfYear);\n+        instant = dayOfMonth().set(instant, dayOfMonth);\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    /**\n+     * Returns a datetime millisecond instant, from from the given instant,\n+     * hour, minute, second, and millisecond values. The set of given values\n+     * must refer to a valid datetime, or else an IllegalArgumentException is\n+     * thrown.\n+     * <p>\n+     * The default implementation calls upon separate DateTimeFields to\n+     * determine the result. Subclasses are encouraged to provide a more\n+     * efficient implementation.\n+     *\n+     * @param instant instant to start from\n+     * @param hourOfDay hour to use\n+     * @param minuteOfHour minute to use\n+     * @param secondOfMinute second to use\n+     * @param millisOfSecond millisecond to use\n+     * @return millisecond instant from 1970-01-01T00:00:00Z\n+     */\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        instant = hourOfDay().set(instant, hourOfDay);\n+        instant = minuteOfHour().set(instant, minuteOfHour);\n+        instant = secondOfMinute().set(instant, secondOfMinute);\n+        return millisOfSecond().set(instant, millisOfSecond);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates whether the fields stored in a partial instant are valid.\n+     * <p>\n+     * This implementation uses {@link DateTimeField#getMinimumValue(ReadablePartial, int[])}\n+     * and {@link DateTimeField#getMaximumValue(ReadablePartial, int[])}.\n+     *\n+     * @param partial  the partial instant to validate\n+     * @param values  the values to validate, not null\n+     * @throws IllegalArgumentException if the instant is invalid\n+     */\n+    public void validate(ReadablePartial partial, int[] values) {\n+        // check values in standard range, catching really stupid cases like -1\n+        // this means that the second check will not hit trouble\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            int value = values[i];\n+            DateTimeField field = partial.getField(i);\n+            if (value < field.getMinimumValue()) {\n+                throw new IllegalFieldValueException\n+                    (field.getType(), new Integer(value),\n+                     new Integer(field.getMinimumValue()), null);\n+            }\n+            if (value > field.getMaximumValue()) {\n+                throw new IllegalFieldValueException\n+                    (field.getType(), new Integer(value),\n+                     null, new Integer(field.getMaximumValue()));\n+            }\n+        }\n+        // check values in specific range, catching really odd cases like 30th Feb\n+        for (int i = 0; i < size; i++) {\n+            int value = values[i];\n+            DateTimeField field = partial.getField(i);\n+            if (value < field.getMinimumValue(partial, values)) {\n+                throw new IllegalFieldValueException\n+                    (field.getType(), new Integer(value),\n+                     new Integer(field.getMinimumValue(partial, values)), null);\n+            }\n+            if (value > field.getMaximumValue(partial, values)) {\n+                throw new IllegalFieldValueException\n+                    (field.getType(), new Integer(value),\n+                     null, new Integer(field.getMaximumValue(partial, values)));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the values of a partial from an instant.\n+     *\n+     * @param partial  the partial instant to use\n+     * @param instant  the instant to query\n+     * @return the values of the partial extracted from the instant\n+     */\n+    public int[] get(ReadablePartial partial, long instant) {\n+        int size = partial.size();\n+        int[] values = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            values[i] = partial.getFieldType(i).getField(this).get(instant);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Sets the partial into the instant.\n+     *\n+     * @param partial  the partial instant to use\n+     * @param instant  the instant to update\n+     * @return the updated instant\n+     */\n+    public long set(ReadablePartial partial, long instant) {\n+        for (int i = 0, isize = partial.size(); i < isize; i++) {\n+            instant = partial.getFieldType(i).getField(this).set(instant, partial.getValue(i));\n+        }\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the values of a period from an interval.\n+     *\n+     * @param period  the period instant to use\n+     * @param startInstant  the start instant of an interval to query\n+     * @param endInstant  the start instant of an interval to query\n+     * @return the values of the period extracted from the interval\n+     */\n+    public int[] get(ReadablePeriod period, long startInstant, long endInstant) {\n+        int size = period.size();\n+        int[] values = new int[size];\n+        if (startInstant != endInstant) {\n+            for (int i = 0; i < size; i++) {\n+                DurationField field = period.getFieldType(i).getField(this);\n+                int value = field.getDifference(endInstant, startInstant);\n+                startInstant = field.add(startInstant, value);\n+                values[i] = value;\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Gets the values of a period from an interval.\n+     *\n+     * @param period  the period instant to use\n+     * @param duration  the duration to query\n+     * @return the values of the period extracted from the duration\n+     */\n+    public int[] get(ReadablePeriod period, long duration) {\n+        int size = period.size();\n+        int[] values = new int[size];\n+        if (duration != 0) {\n+            long current = 0;\n+            for (int i = 0; i < size; i++) {\n+                DurationField field = period.getFieldType(i).getField(this);\n+                if (field.isPrecise()) {\n+                    int value = field.getDifference(duration, current);\n+                    current = field.add(current, value);\n+                    values[i] = value;\n+                }\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Adds the period to the instant, specifying the number of times to add.\n+     *\n+     * @param period  the period to add, null means add nothing\n+     * @param instant  the instant to add to\n+     * @param scalar  the number of times to add\n+     * @return the updated instant\n+     */\n+    public long add(ReadablePeriod period, long instant, int scalar) {\n+        if (scalar != 0 && period != null) {\n+            for (int i = 0, isize = period.size(); i < isize; i++) {\n+                long value = period.getValue(i); // use long to allow for multiplication (fits OK)\n+                if (value != 0) {\n+                    instant = period.getFieldType(i).getField(this).add(instant, value * scalar);\n+                }\n+            }\n+        }\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds the duration to the instant, specifying the number of times to add.\n+     *\n+     * @param instant  the instant to add to\n+     * @param duration  the duration to add\n+     * @param scalar  the number of times to add\n+     * @return the updated instant\n+     */\n+    public long add(long instant, long duration, int scalar) {\n+        if (duration == 0 || scalar == 0) {\n+            return instant;\n+        }\n+        long add = FieldUtils.safeMultiply(duration, scalar);\n+        return FieldUtils.safeAdd(instant, add);\n+    }\n+\n+    // Millis\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the millis duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField millis() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.millis());\n+    }\n+\n+    /**\n+     * Get the millis of second field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField millisOfSecond() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.millisOfSecond(), millis());\n+    }\n+\n+    /**\n+     * Get the millis of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField millisOfDay() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.millisOfDay(), millis());\n+    }\n+\n+    // Second\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the seconds duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField seconds() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.seconds());\n+    }\n+\n+    /**\n+     * Get the second of minute field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField secondOfMinute() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfMinute(), seconds());\n+    }\n+\n+    /**\n+     * Get the second of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField secondOfDay() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfDay(), seconds());\n+    }\n+\n+    // Minute\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the minutes duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField minutes() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.minutes());\n+    }\n+\n+    /**\n+     * Get the minute of hour field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField minuteOfHour() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes());\n+    }\n+\n+    /**\n+     * Get the minute of day field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField minuteOfDay() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfDay(), minutes());\n+    }\n+\n+    // Hour\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hours duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField hours() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.hours());\n+    }\n+\n+    /**\n+     * Get the hour of day (0-23) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField hourOfDay() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.hourOfDay(), hours());\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField clockhourOfDay() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.clockhourOfDay(), hours());\n+    }\n+\n+    // Halfday\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the halfdays duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField halfdays() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.halfdays());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField hourOfHalfday() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.hourOfHalfday(), hours());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField clockhourOfHalfday() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.clockhourOfHalfday(), hours());\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField halfdayOfDay() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.halfdayOfDay(), halfdays());\n+    }\n+\n+    // Day\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the days duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField days() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.days());\n+    }\n+\n+    /**\n+     * Get the day of week field for this chronology.\n+     *\n+     * <p>DayOfWeek values are defined in\n+     * {@link org.joda.time.DateTimeConstants DateTimeConstants}.\n+     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfWeek() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfWeek(), days());\n+    }\n+\n+    /**\n+     * Get the day of month field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfMonth() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfMonth(), days());\n+    }\n+\n+    /**\n+     * Get the day of year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField dayOfYear() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfYear(), days());\n+    }\n+\n+    // Week\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the weeks duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weeks() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.weeks());\n+    }\n+\n+    /**\n+     * Get the week of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField weekOfWeekyear() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekOfWeekyear(), weeks());\n+    }\n+\n+    // Weekyear\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the weekyears duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField weekyears() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.weekyears());\n+    }\n+\n+    /**\n+     * Get the year of a week based year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField weekyear() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekyear(), weekyears());\n+    }\n+\n+    /**\n+     * Get the year of a week based year in a century field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField weekyearOfCentury() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekyearOfCentury(), weekyears());\n+    }\n+\n+    // Month\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the months duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField months() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.months());\n+    }\n+\n+    /**\n+     * Get the month of year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField monthOfYear() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.monthOfYear(), months());\n+    }\n+\n+    // Year\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the years duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField years() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.years());\n+    }\n+\n+    /**\n+     * Get the year field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField year() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.year(), years());\n+    }\n+\n+    /**\n+     * Get the year of era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField yearOfEra() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfEra(), years());\n+    }\n+\n+    /**\n+     * Get the year of century field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField yearOfCentury() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfCentury(), years());\n+    }\n+\n+    // Century\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the centuries duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField centuries() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.centuries());\n+    }\n+\n+    /**\n+     * Get the century of era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField centuryOfEra() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.centuryOfEra(), centuries());\n+    }\n+\n+    // Era\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the eras duration field for this chronology.\n+     * \n+     * @return DurationField or UnsupportedDurationField if unsupported\n+     */\n+    public DurationField eras() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n+    }\n+\n+    /**\n+     * Get the era field for this chronology.\n+     * \n+     * @return DateTimeField or UnsupportedDateTimeField if unsupported\n+     */\n+    public DateTimeField era() {\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.era(), eras());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public abstract String toString();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.MillisDurationField;\n+import org.joda.time.field.OffsetDateTimeField;\n+import org.joda.time.field.PreciseDateTimeField;\n+import org.joda.time.field.PreciseDurationField;\n+import org.joda.time.field.RemainderDateTimeField;\n+import org.joda.time.field.ZeroIsMaxDateTimeField;\n+\n+/**\n+ * Abstract implementation for calendar systems that use a typical\n+ * day/month/year/leapYear model.\n+ * Most of the utility methods required by subclasses are package-private,\n+ * reflecting the intention that they be defined in the same package.\n+ * <p>\n+ * BasicChronology is thread-safe and immutable, and all subclasses must\n+ * be as well.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @author Guy Allard\n+ * @since 1.2, renamed from BaseGJChronology\n+ */\n+abstract class BasicChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 8283225332206808863L;\n+\n+    private static final DurationField cMillisField;\n+    private static final DurationField cSecondsField;\n+    private static final DurationField cMinutesField;\n+    private static final DurationField cHoursField;\n+    private static final DurationField cHalfdaysField;\n+    private static final DurationField cDaysField;\n+    private static final DurationField cWeeksField;\n+\n+    private static final DateTimeField cMillisOfSecondField;\n+    private static final DateTimeField cMillisOfDayField;\n+    private static final DateTimeField cSecondOfMinuteField;\n+    private static final DateTimeField cSecondOfDayField;\n+    private static final DateTimeField cMinuteOfHourField;\n+    private static final DateTimeField cMinuteOfDayField;\n+    private static final DateTimeField cHourOfDayField;\n+    private static final DateTimeField cHourOfHalfdayField;\n+    private static final DateTimeField cClockhourOfDayField;\n+    private static final DateTimeField cClockhourOfHalfdayField;\n+    private static final DateTimeField cHalfdayOfDayField;\n+\n+    static {\n+        cMillisField = MillisDurationField.INSTANCE;\n+        cSecondsField = new PreciseDurationField\n+            (DurationFieldType.seconds(), DateTimeConstants.MILLIS_PER_SECOND);\n+        cMinutesField = new PreciseDurationField\n+            (DurationFieldType.minutes(), DateTimeConstants.MILLIS_PER_MINUTE);\n+        cHoursField = new PreciseDurationField\n+            (DurationFieldType.hours(), DateTimeConstants.MILLIS_PER_HOUR);\n+        cHalfdaysField = new PreciseDurationField\n+            (DurationFieldType.halfdays(), DateTimeConstants.MILLIS_PER_DAY / 2);\n+        cDaysField = new PreciseDurationField\n+            (DurationFieldType.days(), DateTimeConstants.MILLIS_PER_DAY);\n+        cWeeksField = new PreciseDurationField\n+            (DurationFieldType.weeks(), DateTimeConstants.MILLIS_PER_WEEK);\n+\n+        cMillisOfSecondField = new PreciseDateTimeField\n+            (DateTimeFieldType.millisOfSecond(), cMillisField, cSecondsField);\n+\n+        cMillisOfDayField = new PreciseDateTimeField\n+            (DateTimeFieldType.millisOfDay(), cMillisField, cDaysField);\n+             \n+        cSecondOfMinuteField = new PreciseDateTimeField\n+            (DateTimeFieldType.secondOfMinute(), cSecondsField, cMinutesField);\n+\n+        cSecondOfDayField = new PreciseDateTimeField\n+            (DateTimeFieldType.secondOfDay(), cSecondsField, cDaysField);\n+\n+        cMinuteOfHourField = new PreciseDateTimeField\n+            (DateTimeFieldType.minuteOfHour(), cMinutesField, cHoursField);\n+\n+        cMinuteOfDayField = new PreciseDateTimeField\n+            (DateTimeFieldType.minuteOfDay(), cMinutesField, cDaysField);\n+\n+        cHourOfDayField = new PreciseDateTimeField\n+            (DateTimeFieldType.hourOfDay(), cHoursField, cDaysField);\n+\n+        cHourOfHalfdayField = new PreciseDateTimeField\n+            (DateTimeFieldType.hourOfHalfday(), cHoursField, cHalfdaysField);\n+\n+        cClockhourOfDayField = new ZeroIsMaxDateTimeField\n+            (cHourOfDayField, DateTimeFieldType.clockhourOfDay());\n+\n+        cClockhourOfHalfdayField = new ZeroIsMaxDateTimeField\n+            (cHourOfHalfdayField, DateTimeFieldType.clockhourOfHalfday());\n+\n+        cHalfdayOfDayField = new HalfdayField();\n+    }\n+\n+    private static final int CACHE_SIZE = 1 << 10;\n+    private static final int CACHE_MASK = CACHE_SIZE - 1;\n+\n+    private transient final YearInfo[] iYearInfoCache = new YearInfo[CACHE_SIZE];\n+\n+    private final int iMinDaysInFirstWeek;\n+\n+    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param);\n+\n+        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n+            throw new IllegalArgumentException\n+                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+        }\n+\n+        iMinDaysInFirstWeek = minDaysInFirstWeek;\n+    }\n+\n+    public DateTimeZone getZone() {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getZone();\n+        }\n+        return DateTimeZone.UTC;\n+    }\n+\n+    public long getDateTimeMillis(\n+            int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n+            throws IllegalArgumentException {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        }\n+\n+        FieldUtils.verifyValueBounds\n+            (DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);\n+        return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n+    }\n+\n+    public long getDateTimeMillis(\n+            int year, int monthOfYear, int dayOfMonth,\n+            int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)\n+            throws IllegalArgumentException {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);\n+\n+        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n+            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n+            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n+            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n+            + millisOfSecond;\n+    }\n+\n+    public int getMinimumDaysInFirstWeek() {\n+        return iMinDaysInFirstWeek;\n+    }\n+\n+    /**\n+     * Checks if this chronology instance equals another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.6\n+     */\n+    public boolean equals(Object obj) {\n+        return super.equals(obj);\n+    }\n+\n+    /**\n+     * A suitable hash code for the chronology.\n+     * \n+     * @return the hash code\n+     * @since 1.6\n+     */\n+    public int hashCode() {\n+        return getClass().getName().hashCode() * 11 + getZone().hashCode() + getMinimumDaysInFirstWeek();\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer(60);\n+        String name = getClass().getName();\n+        int index = name.lastIndexOf('.');\n+        if (index >= 0) {\n+            name = name.substring(index + 1);\n+        }\n+        sb.append(name);\n+        sb.append('[');\n+        DateTimeZone zone = getZone();\n+        if (zone != null) {\n+            sb.append(zone.getID());\n+        }\n+        if (getMinimumDaysInFirstWeek() != 4) {\n+            sb.append(\",mdfw=\");\n+            sb.append(getMinimumDaysInFirstWeek());\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        // First copy fields that are the same for all Gregorian and Julian\n+        // chronologies.\n+\n+        fields.millis = cMillisField;\n+        fields.seconds = cSecondsField;\n+        fields.minutes = cMinutesField;\n+        fields.hours = cHoursField;\n+        fields.halfdays = cHalfdaysField;\n+        fields.days = cDaysField;\n+        fields.weeks = cWeeksField;\n+\n+        fields.millisOfSecond = cMillisOfSecondField;\n+        fields.millisOfDay = cMillisOfDayField;\n+        fields.secondOfMinute = cSecondOfMinuteField;\n+        fields.secondOfDay = cSecondOfDayField;\n+        fields.minuteOfHour = cMinuteOfHourField;\n+        fields.minuteOfDay = cMinuteOfDayField;\n+        fields.hourOfDay = cHourOfDayField;\n+        fields.hourOfHalfday = cHourOfHalfdayField;\n+        fields.clockhourOfDay = cClockhourOfDayField;\n+        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n+        fields.halfdayOfDay = cHalfdayOfDayField;\n+\n+        // Now create fields that have unique behavior for Gregorian and Julian\n+        // chronologies.\n+\n+        fields.year = new BasicYearDateTimeField(this);\n+        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n+\n+        // Define one-based centuryOfEra and yearOfCentury.\n+        DateTimeField field = new OffsetDateTimeField(\n+            fields.yearOfEra, 99);\n+        fields.centuryOfEra = new DividedDateTimeField(\n+            field, DateTimeFieldType.centuryOfEra(), 100);\n+        \n+        field = new RemainderDateTimeField(\n+            (DividedDateTimeField) fields.centuryOfEra);\n+        fields.yearOfCentury = new OffsetDateTimeField(\n+            field, DateTimeFieldType.yearOfCentury(), 1);\n+\n+        fields.era = new GJEraDateTimeField(this);\n+        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n+        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n+        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n+        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n+        fields.weekyear = new BasicWeekyearDateTimeField(this);\n+        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n+        \n+        field = new RemainderDateTimeField(\n+            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n+        fields.weekyearOfCentury = new OffsetDateTimeField(\n+            field, DateTimeFieldType.weekyearOfCentury(), 1);\n+        \n+        // The remaining (imprecise) durations are available from the newly\n+        // created datetime fields.\n+\n+        fields.years = fields.year.getDurationField();\n+        fields.centuries = fields.centuryOfEra.getDurationField();\n+        fields.months = fields.monthOfYear.getDurationField();\n+        fields.weekyears = fields.weekyear.getDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the number of days in the year.\n+     *\n+     * @return 366\n+     */\n+    int getDaysInYearMax() {\n+        return 366;\n+    }\n+\n+    /**\n+     * Get the number of days in the year.\n+     *\n+     * @param year  the year to use\n+     * @return 366 if a leap year, otherwise 365\n+     */\n+    int getDaysInYear(int year) {\n+        return isLeapYear(year) ? 366 : 365;\n+    }\n+\n+    /**\n+     * Get the number of weeks in the year.\n+     *\n+     * @param year  the year to use\n+     * @return number of weeks in the year\n+     */\n+    int getWeeksInYear(int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n+    }\n+\n+    /**\n+     * Get the millis for the first week of a year.\n+     *\n+     * @param year  the year to use\n+     * @return millis\n+     */\n+    long getFirstWeekOfYearMillis(int year) {\n+        long jan1millis = getYearMillis(year);\n+        int jan1dayOfWeek = getDayOfWeek(jan1millis);\n+        \n+        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n+            // First week is end of previous year because it doesn't have enough days.\n+            return jan1millis + (8 - jan1dayOfWeek)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            // First week is start of this year because it has enough days.\n+            return jan1millis - (jan1dayOfWeek - 1)\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        }\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a year.\n+     *\n+     * @param year The year to use.\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    long getYearMillis(int year) {\n+        return getYearInfo(year).iFirstDayMillis;\n+    }\n+\n+    /**\n+     * Get the milliseconds for the start of a month.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    long getYearMonthMillis(int year, int month) {\n+        long millis = getYearMillis(year);\n+        millis += getTotalMillisByYearMonth(year, month);\n+        return millis;\n+    }\n+\n+    /**\n+     * Get the milliseconds for a particular date.\n+     *\n+     * @param year The year to use.\n+     * @param month The month to use\n+     * @param dayOfMonth The day of the month to use\n+     * @return millis from 1970-01-01T00:00:00Z\n+     */\n+    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n+        long millis = getYearMillis(year);\n+        millis += getTotalMillisByYearMonth(year, month);\n+        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+    \n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getYear(long instant) {\n+        // Get an initial estimate of the year, and the millis value that\n+        // represents the start of that year. Then verify estimate and fix if\n+        // necessary.\n+\n+        // Initial estimate uses values divided by two to avoid overflow.\n+        long unitMillis = getAverageMillisPerYearDividedByTwo();\n+        long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\n+        if (i2 < 0) {\n+            i2 = i2 - unitMillis + 1;\n+        }\n+        int year = (int) (i2 / unitMillis);\n+\n+        long yearStart = getYearMillis(year);\n+        long diff = instant - yearStart;\n+\n+        if (diff < 0) {\n+            year--;\n+        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n+            // One year may need to be added to fix estimate.\n+            long oneYear;\n+            if (isLeapYear(year)) {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n+            } else {\n+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n+            }\n+\n+            yearStart += oneYear;\n+\n+            if (yearStart <= instant) {\n+                // Didn't go too far, so actually add one year.\n+                year++;\n+            }\n+        }\n+\n+        return year;\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    int getMonthOfYear(long millis) {\n+        return getMonthOfYear(millis, getYear(millis));\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    abstract int getMonthOfYear(long millis, int year);\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     */\n+    int getDayOfMonth(long millis) {\n+        int year = getYear(millis);\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    int getDayOfMonth(long millis, int year) {\n+        int month = getMonthOfYear(millis, year);\n+        return getDayOfMonth(millis, year, month);\n+    }\n+\n+    /**\n+     * @param millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     * @param month precalculated month of millis\n+     */\n+    int getDayOfMonth(long millis, int year, int month) {\n+        long dateMillis = getYearMillis(year);\n+        dateMillis += getTotalMillisByYearMonth(year, month);\n+        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getDayOfYear(long instant) {\n+        return getDayOfYear(instant, getYear(instant));\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    int getDayOfYear(long instant, int year) {\n+        long yearStart = getYearMillis(year);\n+        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getWeekyear(long instant) {\n+        int year = getYear(instant);\n+        int week = getWeekOfWeekyear(instant, year);\n+        if (week == 1) {\n+            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n+        } else if (week > 51) {\n+            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n+        } else {\n+            return year;\n+        }\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getWeekOfWeekyear(long instant) {\n+        return getWeekOfWeekyear(instant, getYear(instant));\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     * @param year precalculated year of millis\n+     */\n+    int getWeekOfWeekyear(long instant, int year) {\n+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n+        if (instant < firstWeekMillis1) {\n+            return getWeeksInYear(year - 1);\n+        }\n+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n+        if (instant >= firstWeekMillis2) {\n+            return 1;\n+        }\n+        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getDayOfWeek(long instant) {\n+        // 1970-01-01 is day of week 4, Thursday.\n+\n+        long daysSince19700101;\n+        if (instant >= 0) {\n+            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n+        } else {\n+            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n+                / DateTimeConstants.MILLIS_PER_DAY;\n+            if (daysSince19700101 < -3) {\n+                return 7 + (int) ((daysSince19700101 + 4) % 7);\n+            }\n+        }\n+\n+        return 1 + (int) ((daysSince19700101 + 3) % 7);\n+    }\n+\n+    /**\n+     * @param instant millis from 1970-01-01T00:00:00Z\n+     */\n+    int getMillisOfDay(long instant) {\n+        if (instant >= 0) {\n+            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n+        } else {\n+            return (DateTimeConstants.MILLIS_PER_DAY - 1)\n+                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n+        }\n+    }\n+\n+    /**\n+     * Gets the maximum number of days in any month.\n+     * \n+     * @return 31\n+     */\n+    int getDaysInMonthMax() {\n+        return 31;\n+    }\n+\n+    /**\n+     * Gets the maximum number of days in the month specified by the instant.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @return the maximum number of days in the month\n+     */\n+    int getDaysInMonthMax(long instant) {\n+        int thisYear = getYear(instant);\n+        int thisMonth = getMonthOfYear(instant, thisYear);\n+        return getDaysInYearMonth(thisYear, thisMonth);\n+    }\n+\n+    /**\n+     * Gets the maximum number of days in the month specified by the instant.\n+     * The value represents what the user is trying to set, and can be\n+     * used to optimise this method.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @param value  the value being set\n+     * @return the maximum number of days in the month\n+     */\n+    int getDaysInMonthMaxForSet(long instant, int value) {\n+        return getDaysInMonthMax(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds for a date at midnight.\n+     * \n+     * @param year  the year\n+     * @param monthOfYear  the month\n+     * @param dayOfMonth  the day\n+     * @return the milliseconds\n+     */\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    /**\n+     * Gets the difference between the two instants in years.\n+     * \n+     * @param minuendInstant  the first instant\n+     * @param subtrahendInstant  the second instant\n+     * @return the difference\n+     */\n+    abstract long getYearDifference(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Is the specified year a leap year?\n+     * \n+     * @param year  the year to test\n+     * @return true if leap\n+     */\n+    abstract boolean isLeapYear(int year);\n+\n+    /**\n+     * Gets the number of days in the specified month and year.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the number of days\n+     */\n+    abstract int getDaysInYearMonth(int year, int month);\n+\n+    /**\n+     * Gets the maximum days in the specified month.\n+     * \n+     * @param month  the month\n+     * @return the max days\n+     */\n+    abstract int getDaysInMonthMax(int month);\n+\n+    /**\n+     * Gets the total number of millis elapsed in this year at the start\n+     * of the specified month, such as zero for month 1.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the elapsed millis at the start of the month\n+     */\n+    abstract long getTotalMillisByYearMonth(int year, int month);\n+\n+    /**\n+     * Gets the millisecond value of the first day of the year.\n+     * \n+     * @return the milliseconds for the first of the year\n+     */\n+    abstract long calculateFirstDayOfYearMillis(int year);\n+\n+    /**\n+     * Gets the minimum supported year.\n+     * \n+     * @return the year\n+     */\n+    abstract int getMinYear();\n+\n+    /**\n+     * Gets the maximum supported year.\n+     * \n+     * @return the year\n+     */\n+    abstract int getMaxYear();\n+\n+    /**\n+     * Gets the maximum month for the specified year.\n+     * This implementation calls getMaxMonth().\n+     * \n+     * @param year  the year\n+     * @return the maximum month value\n+     */\n+    int getMaxMonth(int year) {\n+        return getMaxMonth();\n+    }\n+\n+    /**\n+     * Gets the maximum number of months.\n+     * \n+     * @return 12\n+     */\n+    int getMaxMonth() {\n+        return 12;\n+    }\n+\n+    /**\n+     * Gets an average value for the milliseconds per year.\n+     * \n+     * @return the millis per year\n+     */\n+    abstract long getAverageMillisPerYear();\n+\n+    /**\n+     * Gets an average value for the milliseconds per year, divided by two.\n+     * \n+     * @return the millis per year divided by two\n+     */\n+    abstract long getAverageMillisPerYearDividedByTwo();\n+\n+    /**\n+     * Gets an average value for the milliseconds per month.\n+     * \n+     * @return the millis per month\n+     */\n+    abstract long getAverageMillisPerMonth();\n+\n+    /**\n+     * Returns a constant representing the approximate number of milliseconds\n+     * elapsed from year 0 of this chronology, divided by two. This constant\n+     * <em>must</em> be defined as:\n+     * <pre>\n+     *    (yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch) / 2\n+     * </pre>\n+     * where epoch is 1970-01-01 (Gregorian).\n+     */\n+    abstract long getApproxMillisAtEpochDividedByTwo();\n+\n+    /**\n+     * Sets the year from an instant and year.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @param year  the year to set\n+     * @return the updated millis\n+     */\n+    abstract long setYear(long instant, int year);\n+\n+    //-----------------------------------------------------------------------\n+    // Although accessed by multiple threads, this method doesn't need to be synchronized.\n+    private YearInfo getYearInfo(int year) {\n+        YearInfo info = iYearInfoCache[year & CACHE_MASK];\n+        if (info == null || info.iYear != year) {\n+            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n+            iYearInfoCache[year & CACHE_MASK] = info;\n+        }\n+        return info;\n+    }\n+\n+    private static class HalfdayField extends PreciseDateTimeField {\n+        private static final long serialVersionUID = 581601443656929254L;\n+\n+        HalfdayField() {\n+            super(DateTimeFieldType.halfdayOfDay(), cHalfdaysField, cDaysField);\n+        }\n+\n+        public String getAsText(int fieldValue, Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).halfdayValueToText(fieldValue);\n+        }\n+\n+        public long set(long millis, String text, Locale locale) {\n+            return set(millis, GJLocaleSymbols.forLocale(locale).halfdayTextToValue(text));\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return GJLocaleSymbols.forLocale(locale).getHalfdayMaxTextLength();\n+        }\n+    }\n+\n+    private static class YearInfo {\n+        public final int iYear;\n+        public final long iFirstDayMillis;\n+\n+        YearInfo(int year, long firstDayMillis) {\n+            iYear = year;\n+            iFirstDayMillis = firstDayMillis;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the month component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.1, refactored from GJDayOfMonthDateTimeField\n+ */\n+final class BasicDayOfMonthDateTimeField extends PreciseDurationDateTimeField {\n+\n+    private static final long serialVersionUID = -4677223814028011723L;\n+\n+    private final BasicChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n+        super(DateTimeFieldType.dayOfMonth(), days);\n+        iChronology = chronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int get(long instant) {\n+        return iChronology.getDayOfMonth(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.months();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getDaysInMonthMax();\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        return iChronology.getDaysInMonthMax(instant);\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.monthOfYear())) {\n+            int month = partial.get(DateTimeFieldType.monthOfYear());\n+            if (partial.isSupported(DateTimeFieldType.year())) {\n+                int year = partial.get(DateTimeFieldType.year());\n+                return iChronology.getDaysInYearMonth(year, month);\n+            }\n+            return iChronology.getDaysInMonthMax(month);\n+        }\n+        return getMaximumValue();\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {\n+                int month = values[i];\n+                for (int j = 0; j < size; j++) {\n+                    if (partial.getFieldType(j) == DateTimeFieldType.year()) {\n+                        int year = values[j];\n+                        return iChronology.getDaysInYearMonth(year, month);\n+                    }\n+                }\n+                return iChronology.getDaysInMonthMax(month);\n+            }\n+        }\n+        return getMaximumValue();\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return iChronology.getDaysInMonthMaxForSet(instant, value);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfMonth();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.1, refactored from GJDayOfYearDateTimeField\n+ */\n+final class BasicDayOfYearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    private static final long serialVersionUID = -6821236822336841037L;\n+\n+    private final BasicChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n+        super(DateTimeFieldType.dayOfYear(), days);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the day of the year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the day of the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getDayOfYear(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getDaysInYearMax();\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        int year = iChronology.getYear(instant);\n+        return iChronology.getDaysInYear(year);\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.year())) {\n+            int year = partial.get(DateTimeFieldType.year());\n+            return iChronology.getDaysInYear(year);\n+        }\n+        return iChronology.getDaysInYearMax();\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.year()) {\n+                int year = values[i];\n+                return iChronology.getDaysInYear(year);\n+            }\n+        }\n+        return iChronology.getDaysInYearMax();\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        int maxLessOne = iChronology.getDaysInYearMax() - 1;\n+        return (value > maxLessOne || value < 1) ? getMaximumValue(instant) : maxLessOne;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfYear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicFixedMonthChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+\n+/**\n+ * Abstract implementation of a calendar system based around fixed length months.\n+ * <p>\n+ * As the month length is fixed various calculations can be optimised.\n+ * This implementation assumes any additional days after twelve\n+ * months fall into a thirteenth month.\n+ * <p>\n+ * BasicFixedMonthChronology is thread-safe and immutable, and all\n+ * subclasses must be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.2, refactored from CopticChronology\n+ */\n+abstract class BasicFixedMonthChronology extends BasicChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 261387371998L;\n+\n+    /** The length of the month. */\n+    static final int MONTH_LENGTH = 30;\n+\n+    /** The typical millis per year. */\n+    static final long MILLIS_PER_YEAR =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** The length of the month in millis. */\n+    static final long MILLIS_PER_MONTH = ((long) MONTH_LENGTH) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     *\n+     * @param base  the base chronology\n+     * @param param  the init parameter\n+     * @param minDaysInFirstWeek  the minimum days in the first week\n+     */\n+    BasicFixedMonthChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long setYear(long instant, int year) {\n+        // optimsed implementation of set, due to fixed months\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > 365) {\n+            // Current year is leap, and day is leap.\n+            if (!isLeapYear(year)) {\n+                // Moving to a non-leap year, leap day doesn't exist.\n+                dayOfYear--;\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        // optimsed implementation of getDifference, due to fixed months\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        return ((month - 1) * MILLIS_PER_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDayOfMonth(long millis) {\n+        // optimised for fixed months\n+        return (getDayOfYear(millis) - 1) % MONTH_LENGTH + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    boolean isLeapYear(int year) {\n+        return (year & 3) == 3;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYearMonth(int year, int month) {\n+        return (month != 13) ? MONTH_LENGTH : (isLeapYear(year) ? 6 : 5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax() {\n+        return MONTH_LENGTH;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        return (month != 13 ? MONTH_LENGTH : 6);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis) {\n+        return (getDayOfYear(millis) - 1) / MONTH_LENGTH + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        long monthZeroBased = (millis - getYearMillis(year)) / MILLIS_PER_MONTH;\n+        return ((int) monthZeroBased) + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMaxMonth() {\n+        return 13;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerYearDividedByTwo() {\n+        return MILLIS_PER_YEAR / 2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicGJChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+\n+/**\n+ * Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.\n+ * Most of the utility methods required by subclasses are package-private,\n+ * reflecting the intention that they be defined in the same package.\n+ * <p>\n+ * BasicGJChronology is thread-safe and immutable, and all subclasses must\n+ * be as well.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @author Guy Allard\n+ * @since 1.2, refactored from CommonGJChronology\n+ */\n+abstract class BasicGJChronology extends BasicChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 538276888268L;\n+\n+    // These arrays are NOT public. We trust ourselves not to alter the array.\n+    // They use zero-based array indexes so the that valid range of months is\n+    // automatically checked.\n+    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {\n+        31,28,31,30,31,30,31,31,30,31,30,31\n+    };\n+    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {\n+        31,29,31,30,31,30,31,31,30,31,30,31\n+    };\n+    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    static {\n+        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+\n+        long minSum = 0;\n+        long maxSum = 0;\n+        for (int i = 0; i < 11; i++) {\n+            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            minSum += millis;\n+            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i + 1] = minSum;\n+\n+            millis = MAX_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            maxSum += millis;\n+            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i + 1] = maxSum;\n+        }\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        // Perform a binary search to get the month. To make it go even faster,\n+        // compare using ints instead of longs. The number of milliseconds per\n+        // year exceeds the limit of a 32-bit int's capacity, so divide by\n+        // 1024. No precision is lost (except time of day) since the number of\n+        // milliseconds per day contains 1024 as a factor. After the division,\n+        // the instant isn't measured in milliseconds, but in units of\n+        // (128/125)seconds.\n+\n+        int i = (int)((millis - getYearMillis(year)) >> 10);\n+\n+        // There are 86400000 milliseconds per day, but divided by 1024 is\n+        // 84375. There are 84375 (128/125)seconds per day.\n+\n+        return\n+            (isLeapYear(year))\n+            ? ((i < 182 * 84375)\n+               ? ((i < 91 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n+                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n+               : ((i < 274 * 84375)\n+                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n+                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n+            : ((i < 181 * 84375)\n+               ? ((i < 90 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n+                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n+               : ((i < 273 * 84375)\n+                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n+                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of days in the specified month and year.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the number of days\n+     */\n+    int getDaysInYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMaxForSet(long instant, int value) {\n+        return (value > 28 ? getDaysInMonthMax(instant) : 28);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+    \n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+    \n+        // Balance leap year differences on remainders.\n+        if (subtrahendRem >= FEB_29) {\n+            if (isLeapYear(subtrahendYear)) {\n+                if (!isLeapYear(minuendYear)) {\n+                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+                }\n+            } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) {\n+                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+            }\n+        }\n+    \n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long setYear(long instant, int year) {\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > (31 + 28)) { // after Feb 28\n+            if (isLeapYear(thisYear)) {\n+                // Current date is Feb 29 or later.\n+                if (!isLeapYear(year)) {\n+                    // Moving to a non-leap year, Feb 29 does not exist.\n+                    dayOfYear--;\n+                }\n+            } else {\n+                // Current date is Mar 01 or later.\n+                if (isLeapYear(year)) {\n+                    // Moving to a leap year, account for Feb 29.\n+                    dayOfYear++;\n+                }\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+\n+        return instant;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * Provides time calculations for the month of the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.2, refactored from GJMonthOfYearDateTimeField\n+ */\n+class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8258715387168736L;\n+\n+    private static final int MIN = DateTimeConstants.JANUARY;\n+\n+    private final BasicChronology iChronology;\n+    private final int iMax;\n+    private final int iLeapMonth;\n+\n+    /**\n+     * Restricted constructor.\n+     * \n+     * @param leapMonth the month of year that leaps\n+     */\n+    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n+        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n+        iChronology = chronology;\n+        iMax = iChronology.getMaxMonth();\n+        iLeapMonth = leapMonth;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the Month component of the specified time instant.\n+     *\n+     * @see org.joda.time.DateTimeField#get(long)\n+     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n+     * @param instant  the time instant in millis to query.\n+     * @return the month extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getMonthOfYear(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add the specified month to the specified time instant.\n+     * The amount added may be negative.<p>\n+     * If the new month has less total days than the specified\n+     * day of the month, this value is coerced to the nearest\n+     * sane value. e.g.<p>\n+     * 07-31 - (1 month) = 06-30<p>\n+     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n+     * @param instant  the time instant in millis to update.\n+     * @param months  the months to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int months) {\n+        if (months == 0) {\n+            return instant; // the easy case\n+        }\n+        //\n+        // Save time part first.\n+        //\n+        long timePart = iChronology.getMillisOfDay(instant);\n+        //\n+        //\n+        // Get this year and month.\n+        //\n+        int thisYear = iChronology.getYear(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+        // ----------------------------------------------------------\n+        //\n+        // Do not refactor without careful consideration.\n+        // Order of calculation is important.\n+        //\n+        int yearToUse;\n+        // Initially, monthToUse is zero-based\n+        int monthToUse = thisMonth - 1 + months;\n+        if (monthToUse >= 0) {\n+            yearToUse = thisYear + (monthToUse / iMax);\n+            monthToUse = (monthToUse % iMax) + 1;\n+        } else {\n+            yearToUse = thisYear + (monthToUse / iMax) - 1;\n+            monthToUse = Math.abs(monthToUse);\n+            int remMonthToUse = monthToUse % iMax;\n+            // Take care of the boundary condition\n+            if (remMonthToUse == 0) {\n+                remMonthToUse = iMax;\n+            }\n+            monthToUse = iMax - remMonthToUse + 1;\n+            // Take care of the boundary condition\n+            if (monthToUse == 1) {\n+                yearToUse += 1;\n+            }\n+        }\n+        // End of do not refactor.\n+        // ----------------------------------------------------------\n+\n+        //\n+        // Quietly force DOM to nearest sane value.\n+        //\n+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n+        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n+        if (dayToUse > maxDay) {\n+            dayToUse = maxDay;\n+        }\n+        //\n+        // get proper date part, and return result\n+        //\n+        long datePart =\n+            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n+        return datePart + timePart;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public long add(long instant, long months) {\n+        int i_months = (int)months;\n+        if (i_months == months) {\n+            return add(instant, i_months);\n+        }\n+\n+        // Copied from add(long, int) and modified slightly:\n+\n+        long timePart = iChronology.getMillisOfDay(instant);\n+\n+        int thisYear = iChronology.getYear(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+\n+        long yearToUse;\n+        long monthToUse = thisMonth - 1 + months;\n+        if (monthToUse >= 0) {\n+            yearToUse = thisYear + (monthToUse / iMax);\n+            monthToUse = (monthToUse % iMax) + 1;\n+        } else {\n+            yearToUse = thisYear + (monthToUse / iMax) - 1;\n+            monthToUse = Math.abs(monthToUse);\n+            int remMonthToUse = (int)(monthToUse % iMax);\n+            if (remMonthToUse == 0) {\n+                remMonthToUse = iMax;\n+            }\n+            monthToUse = iMax - remMonthToUse + 1;\n+            if (monthToUse == 1) {\n+                yearToUse += 1;\n+            }\n+        }\n+\n+        if (yearToUse < iChronology.getMinYear() ||\n+            yearToUse > iChronology.getMaxYear()) {\n+\n+            throw new IllegalArgumentException\n+                (\"Magnitude of add amount is too large: \" + months);\n+        }\n+\n+        int i_yearToUse = (int)yearToUse;\n+        int i_monthToUse = (int)monthToUse;\n+\n+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n+        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n+        if (dayToUse > maxDay) {\n+            dayToUse = maxDay;\n+        }\n+\n+        long datePart =\n+            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);\n+        return datePart + timePart;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n+        // overridden as superclass algorithm can't handle\n+        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n+        if (valueToAdd == 0) {\n+            return values;\n+        }\n+        if (DateTimeUtils.isContiguous(partial)) {\n+            long instant = 0L;\n+            for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n+            }\n+            instant = add(instant, valueToAdd);\n+            return iChronology.get(partial, instant);\n+        } else {\n+            return super.add(partial, fieldIndex, values, valueToAdd);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add to the Month component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapField\n+     * @param instant  the time instant in millis to update.\n+     * @param months  the months to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int months) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendYear = iChronology.getYear(minuendInstant);\n+        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n+        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n+        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n+\n+        long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;\n+\n+        // Before adjusting for remainder, account for special case of add\n+        // where the day-of-month is forced to the nearest sane value.\n+        int minuendDom = iChronology.getDayOfMonth\n+            (minuendInstant, minuendYear, minuendMonth);\n+        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n+            // Last day of the minuend month...\n+            int subtrahendDom = iChronology.getDayOfMonth\n+                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n+            if (subtrahendDom > minuendDom) {\n+                // ...and day of subtrahend month is larger.\n+                // Note: This works fine, but it ideally shouldn't invoke other\n+                // fields from within a field.\n+                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n+            }\n+        }\n+\n+        // Inlined remainder method to avoid duplicate calls.\n+        long minuendRem = minuendInstant\n+            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n+        long subtrahendRem = subtrahendInstant\n+            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n+\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the Month component of the specified time instant.<p>\n+     * If the new month has less total days than the specified\n+     * day of the month, this value is coerced to the nearest\n+     * sane value. e.g.<p>\n+     * 07-31 to month 6 = 06-30<p>\n+     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param month  the month (1,12) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if month is invalid\n+     */\n+    public long set(long instant, int month) {\n+        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n+        //\n+        int thisYear = iChronology.getYear(instant);\n+        //\n+        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n+        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n+        if (thisDom > maxDom) {\n+            // Quietly force DOM to nearest sane value.\n+            thisDom = maxDom;\n+        }\n+        // Return newly calculated millis value\n+        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n+            iChronology.getMillisOfDay(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean isLeap(long instant) {\n+        int thisYear = iChronology.getYear(instant);\n+        if (iChronology.isLeapYear(thisYear)) {\n+            return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getLeapAmount(long instant) {\n+        return isLeap(instant) ? 1 : 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getMinimumValue() {\n+        return MIN;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getMaximumValue() {\n+        return iMax;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public long roundFloor(long instant) {\n+        int year = iChronology.getYear(instant);\n+        int month = iChronology.getMonthOfYear(instant, year);\n+        return iChronology.getYearMonthMillis(year, month);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.monthOfYear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicSingleEraDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.field.BaseDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.UnsupportedDurationField;\n+\n+/**\n+ * Provides time calculations for the coptic era component of time.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.2, refactored from CopticEraDateTimeField\n+ */\n+final class BasicSingleEraDateTimeField extends BaseDateTimeField {\n+\n+    /**\n+     * Value of the era, which will be the same as DateTimeConstants.CE.\n+     */\n+    private static final int ERA_VALUE = DateTimeConstants.CE;\n+    /**\n+     * Text value of the era.\n+     */\n+    private final String iEraText;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    BasicSingleEraDateTimeField(String text) {\n+        super(DateTimeFieldType.era());\n+        iEraText = text;\n+    }\n+\n+    /** @inheritDoc */\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /** @inheritDoc */\n+    public int get(long instant) {\n+        return ERA_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long set(long instant, int era) {\n+        FieldUtils.verifyValueBounds(this, era, ERA_VALUE, ERA_VALUE);\n+        return instant;\n+    }\n+\n+    /** @inheritDoc */\n+    public long set(long instant, String text, Locale locale) {\n+        if (iEraText.equals(text) == false && \"1\".equals(text) == false) {\n+            throw new IllegalFieldValueException(DateTimeFieldType.era(), text);\n+        }\n+        return instant;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundCeiling(long instant) {\n+        return Long.MAX_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundHalfFloor(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundHalfCeiling(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public long roundHalfEven(long instant) {\n+        return Long.MIN_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public DurationField getDurationField() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n+    }\n+\n+    /** @inheritDoc */\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    /** @inheritDoc */\n+    public int getMinimumValue() {\n+        return ERA_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public int getMaximumValue() {\n+        return ERA_VALUE;\n+    }\n+\n+    /** @inheritDoc */\n+    public String getAsText(int fieldValue, Locale locale) {\n+        return iEraText;\n+    }\n+\n+    /** @inheritDoc */\n+    public int getMaximumTextLength(Locale locale) {\n+        return iEraText.length();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the week of a week based year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.1, refactored from GJWeekOfWeekyearDateTimeField\n+ */\n+final class BasicWeekOfWeekyearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    private static final long serialVersionUID = -1587436826395135328L;\n+\n+    private final BasicChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n+        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the week of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#get(long)\n+     * @param instant  the time instant in millis to query.\n+     * @return the week of the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getWeekOfWeekyear(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weekyears();\n+    }\n+\n+    // 1970-01-01 is day of week 4, Thursday. The rounding methods need to\n+    // apply a corrective alignment since weeks begin on day of week 1, Monday.\n+\n+    public long roundFloor(long instant) {\n+        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n+            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n+            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    public long remainder(long instant) {\n+        return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 53;\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        int weekyear = iChronology.getWeekyear(instant);\n+        return iChronology.getWeeksInYear(weekyear);\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.weekyear())) {\n+            int weekyear = partial.get(DateTimeFieldType.weekyear());\n+            return iChronology.getWeeksInYear(weekyear);\n+        }\n+        return 53;\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.weekyear()) {\n+                int weekyear = values[i];\n+                return iChronology.getWeeksInYear(weekyear);\n+            }\n+        }\n+        return 53;\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return value > 52 ? getMaximumValue(instant) : 52;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.weekOfWeekyear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * Provides time calculations for the week of the weekyear component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.1, refactored from GJWeekyearDateTimeField\n+ */\n+final class BasicWeekyearDateTimeField extends ImpreciseDateTimeField {\n+    \n+    private static final long serialVersionUID = 6215066916806820644L;\n+\n+    private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;\n+\n+    private final BasicChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    BasicWeekyearDateTimeField(BasicChronology chronology) {\n+        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Year of a week based year component of the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#get\n+     * @param instant  the time instant in millis to query.\n+     * @return the year extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getWeekyear(instant);\n+    }\n+\n+    /**\n+     * Add the specified years to the specified time instant.\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        return set(instant, get(instant) + years);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return add(instant, FieldUtils.safeToInt(value));\n+    }\n+\n+    /**\n+     * Add to the year component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapField\n+     * @param instant  the time instant in millis to update.\n+     * @param years  the years to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int years) {\n+        return add(instant, years);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendWeekyear = get(minuendInstant);\n+        int subtrahendWeekyear = get(subtrahendInstant);\n+\n+        long minuendRem = remainder(minuendInstant);\n+        long subtrahendRem = remainder(subtrahendInstant);\n+\n+        // Balance leap weekyear differences on remainders.\n+        if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {\n+            subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK;\n+        }\n+\n+        int difference = minuendWeekyear - subtrahendWeekyear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    /**\n+     * Set the Year of a week based year component of the specified time instant.\n+     *\n+     * @see org.joda.time.DateTimeField#set\n+     * @param instant  the time instant in millis to update.\n+     * @param year  the year (-9999,9999) to set the date to.\n+     * @return the updated DateTime.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds(this, Math.abs(year),\n+                                     iChronology.getMinYear(), iChronology.getMaxYear());\n+        //\n+        // Do nothing if no real change is requested.\n+        //\n+        int thisWeekyear = get( instant );\n+        if ( thisWeekyear == year ) {\n+            return instant;\n+        }\n+        //\n+        // Calculate the DayOfWeek (to be preserved).\n+        //\n+        int thisDow = iChronology.getDayOfWeek(instant);\n+        //\n+        // Calculate the maximum weeks in the target year.\n+        //\n+        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n+        int weeksInToYear = iChronology.getWeeksInYear( year );\n+        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n+            weeksInToYear : weeksInFromYear;\n+        //\n+        // Get the current week of the year. This will be preserved in\n+        // the output unless it is greater than the maximum possible\n+        // for the target weekyear.  In that case it is adjusted\n+        // to the maximum possible.\n+        //\n+        int setToWeek = iChronology.getWeekOfWeekyear(instant);\n+        if ( setToWeek > maxOutWeeks ) {\n+            setToWeek = maxOutWeeks;\n+        }\n+        //\n+        // Get a wroking copy of the current date-time.\n+        // This can be a convenience for debugging.\n+        //\n+        long workInstant = instant; // Get a copy\n+        //\n+        // Attempt to get close to the proper weekyear.\n+        // Note - we cannot currently call ourself, so we just call\n+        // set for the year.  This at least gets us close.\n+        //\n+        workInstant = iChronology.setYear( workInstant, year );\n+        //\n+        // Calculate the weekyear number for the get close to value\n+        // (which might not be equal to the year just set).\n+        //\n+        int workWoyYear = get( workInstant );\n+\n+        //\n+        // At most we are off by one year, which can be \"fixed\" by\n+        // adding/subtracting a week.\n+        //\n+        if ( workWoyYear < year ) {\n+            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n+        } else if ( workWoyYear > year ) {\n+            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n+        }\n+        //\n+        // Set the proper week in the current weekyear.\n+        //\n+\n+        // BEGIN: possible set WeekOfWeekyear logic.\n+        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\n+        // No range check required (we already know it is OK).\n+        workInstant = workInstant + (setToWeek - currentWoyWeek)\n+            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n+        // END: possible set WeekOfWeekyear logic.\n+\n+        //\n+        // Reset DayOfWeek to previous value.\n+        //\n+        // Note: This works fine, but it ideally shouldn't invoke other\n+        // fields from within a field.\n+        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n+        //\n+        // Return result.\n+        //\n+        return workInstant;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) > 52;\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) - 52;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.weeks();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        // Note: This works fine, but it ideally shouldn't invoke other\n+        // fields from within a field.\n+        instant = iChronology.weekOfWeekyear().roundFloor(instant);\n+        int wow = iChronology.getWeekOfWeekyear(instant);\n+        if (wow > 1) {\n+            instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.weekyear();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * A year field suitable for many calendars.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.1, refactored from GJYearDateTimeField\n+ */\n+class BasicYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -98628754872287L;\n+\n+    /** The underlying basic chronology. */\n+    protected final BasicChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     * \n+     * @param chronology  the chronology this field belogs to\n+     */\n+    BasicYearDateTimeField(BasicChronology chronology) {\n+        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    public int get(long instant) {\n+        return iChronology.getYear(instant);\n+    }\n+\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        int thisYear = get(instant);\n+        int newYear = FieldUtils.safeAdd(thisYear, years);\n+        return set(instant, newYear);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return add(instant, FieldUtils.safeToInt(years));\n+    }\n+\n+    public long addWrapField(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        // Return newly calculated millis value\n+        int thisYear = iChronology.getYear(instant);\n+        int wrappedYear = FieldUtils.getWrappedValue\n+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return set(instant, wrappedYear);\n+    }\n+\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds\n+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return iChronology.setYear(instant, year);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -iChronology.getYearDifference(subtrahendInstant, minuendInstant);\n+        }\n+        return iChronology.getYearDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.isLeapYear(get(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        if (iChronology.isLeapYear(get(instant))) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iChronology.getYearMillis(get(instant));\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        int year = get(instant);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+        if (instant != yearStartMillis) {\n+            // Bump up to start of next year.\n+            instant = iChronology.getYearMillis(year + 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.year();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/BuddhistChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.DelegatedDateTimeField;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.OffsetDateTimeField;\n+import org.joda.time.field.RemainderDateTimeField;\n+import org.joda.time.field.SkipUndoDateTimeField;\n+\n+/**\n+ * A chronology that matches the BuddhistCalendar class supplied by Sun.\n+ * <p>\n+ * The chronology is identical to the Gregorian/Julian, except that the\n+ * year is offset by +543 and the era is named 'BE' for Buddhist Era.\n+ * <p>\n+ * This class was intended by Sun to model the calendar used in Thailand.\n+ * However, the actual rules for Thailand are much more involved than\n+ * this class covers. (This class is accurate after 1941-01-01 ISO).\n+ * <p>\n+ * This chronlogy is being retained for those who want a same effect\n+ * replacement for the Sun class. It is hoped that community support will\n+ * enable a more accurate chronology for Thailand, to be developed.\n+ * <p>\n+ * BuddhistChronology is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class BuddhistChronology extends AssembledChronology {\n+    \n+    /** Serialization lock */\n+    private static final long serialVersionUID = -3474595157769370126L;\n+\n+    /**\n+     * Constant value for 'Buddhist Era', equivalent to the value returned\n+     * for AD/CE. Note that this differs from the constant in BuddhistCalendar.\n+     */\n+    public static final int BE = DateTimeConstants.CE;\n+\n+    /** A singleton era field. */\n+    private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"BE\");\n+\n+    /** Number of years difference in calendars. */\n+    private static final int BUDDHIST_OFFSET = 543;\n+\n+    /** Cache of zone to chronology */\n+    private static final Map<DateTimeZone, BuddhistChronology> cCache = new HashMap<DateTimeZone, BuddhistChronology>();\n+\n+    /** UTC instance of the chronology */\n+    private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     * <p>\n+     * The time zone of the returned instance is UTC.\n+     */\n+    public static BuddhistChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     */\n+    public static BuddhistChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault());\n+    }\n+\n+    /**\n+     * Standard instance of a Buddhist Chronology, that matches\n+     * Sun's BuddhistCalendar class. This means that it follows the\n+     * GregorianJulian calendar rules with a cutover date.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     */\n+    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        BuddhistChronology chrono = cCache.get(zone);\n+        if (chrono == null) {\n+            // First create without a lower limit.\n+            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);\n+            // Impose lower limit and make another BuddhistChronology.\n+            DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+            chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), \"\");\n+            cCache.put(zone, chrono);\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Restricted constructor.\n+     *\n+     * @param param if non-null, then don't change the field set\n+     */\n+    private BuddhistChronology(Chronology base, Object param) {\n+        super(base, param);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        Chronology base = getBase();\n+        return base == null ? getInstanceUTC() : getInstance(base.getZone());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    /**\n+     * Checks if this chronology instance equals another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.6\n+     */\n+    public boolean equals(Object obj) {\n+        return super.equals(obj);\n+    }\n+\n+    /**\n+     * A suitable hash code for the chronology.\n+     * \n+     * @return the hash code\n+     * @since 1.6\n+     */\n+    public int hashCode() {\n+        return \"Buddhist\".hashCode() * 11 + getZone().hashCode();\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        String str = \"BuddhistChronology\";\n+        DateTimeZone zone = getZone();\n+        if (zone != null) {\n+            str = str + '[' + zone.getID() + ']';\n+        }\n+        return str;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getParam() == null) {\n+            // julian chrono removed zero, but we need to put it back\n+            DateTimeField field = fields.year;\n+            fields.year = new OffsetDateTimeField(\n+                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n+            \n+            // one era, so yearOfEra is the same\n+            field = fields.yearOfEra;\n+            fields.yearOfEra = new DelegatedDateTimeField(\n+                fields.year, DateTimeFieldType.yearOfEra());\n+            \n+            // julian chrono removed zero, but we need to put it back\n+            field = fields.weekyear;\n+            fields.weekyear = new OffsetDateTimeField(\n+                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n+            \n+            field = new OffsetDateTimeField(fields.yearOfEra, 99);\n+            fields.centuryOfEra = new DividedDateTimeField(\n+                field, DateTimeFieldType.centuryOfEra(), 100);\n+            \n+            field = new RemainderDateTimeField(\n+                (DividedDateTimeField) fields.centuryOfEra);\n+            fields.yearOfCentury = new OffsetDateTimeField(\n+                field, DateTimeFieldType.yearOfCentury(), 1);\n+            \n+            field = new RemainderDateTimeField(\n+                fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n+            fields.weekyearOfCentury = new OffsetDateTimeField(\n+                field, DateTimeFieldType.weekyearOfCentury(), 1);\n+            \n+            fields.era = ERA_FIELD;\n+        }\n+    }\n+   \n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/CopticChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.SkipDateTimeField;\n+\n+/**\n+ * Implements the Coptic calendar system, which defines every fourth year as\n+ * leap, much like the Julian calendar. The year is broken down into 12 months,\n+ * each 30 days in length. An extra period at the end of the year is either 5\n+ * or 6 days in length. In this implementation, it is considered a 13th month.\n+ * <p>\n+ * Year 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus\n+ * Coptic years do not begin at the same time as Julian years. This chronology\n+ * is not proleptic, as it does not allow dates before the first Coptic year.\n+ * <p>\n+ * This implementation defines a day as midnight to midnight exactly as per\n+ * the ISO chronology. Some references indicate that a coptic day starts at\n+ * sunset on the previous ISO day, but this has not been confirmed and is not\n+ * implemented.\n+ * <p>\n+ * CopticChronology is thread-safe and immutable.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Coptic_calendar\">Wikipedia</a>\n+ * @see JulianChronology\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class CopticChronology extends BasicFixedMonthChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -5972804258688333942L;\n+\n+    /**\n+     * Constant value for 'Anno Martyrum' or 'Era of the Martyrs', equivalent\n+     * to the value returned for AD/CE.\n+     */\n+    public static final int AM = DateTimeConstants.CE;\n+\n+    /** A singleton era field. */\n+    private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"AM\");\n+\n+    /** The lowest year that can be fully supported. */\n+    private static final int MIN_YEAR = -292269337;\n+\n+    /** The highest year that can be fully supported. */\n+    private static final int MAX_YEAR = 292272708;\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map<DateTimeZone, CopticChronology[]> cCache = new HashMap<DateTimeZone, CopticChronology[]>();\n+\n+    /** Singleton instance of a UTC CopticChronology */\n+    private static final CopticChronology INSTANCE_UTC;\n+    static {\n+        // init after static fields\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an instance of the CopticChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static CopticChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static CopticChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static CopticChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the CopticChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     * @return a chronology in the specified time zone\n+     */\n+    public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        CopticChronology chrono;\n+        synchronized (cCache) {\n+            CopticChronology[] chronos = cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new CopticChronology[7];\n+                cCache.put(zone, chronos);\n+            }\n+            try {\n+                chrono = chronos[minDaysInFirstWeek - 1];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IllegalArgumentException\n+                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+            }\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    // First create without a lower limit.\n+                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);\n+                    // Impose lower limit and make another CopticChronology.\n+                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+                    chrono = new CopticChronology\n+                        (LimitChronology.getInstance(chrono, lowerLimit, null),\n+                         null, minDaysInFirstWeek);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n+                    chrono = new CopticChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n+                }\n+                chronos[minDaysInFirstWeek - 1] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     */\n+    CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Serialization singleton.\n+     */\n+    private Object readResolve() {\n+        Chronology base = getBase();\n+        int minDays = getMinimumDaysInFirstWeek();\n+        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology\n+        return base == null ?\n+                getInstance(DateTimeZone.UTC, minDays) :\n+                    getInstance(base.getZone(), minDays);\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long calculateFirstDayOfYearMillis(int year) {\n+        // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.\n+        // Calculate relative to the nearest leap year and account for the\n+        // difference later.\n+\n+        int relativeYear = year - 1687;\n+        int leapYears;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers.\n+            leapYears = (relativeYear + 3) >> 2;\n+        } else {\n+            leapYears = relativeYear >> 2;\n+            // For post 1687 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears)\n+            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+\n+        // Adjust to account for difference between 1687-01-01 and 1686-04-23.\n+\n+        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMinYear() {\n+        return MIN_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMaxYear() {\n+        return MAX_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        return (1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+\n+            // Coptic, like Julian, has no year zero.\n+            fields.year = new SkipDateTimeField(this, fields.year);\n+            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n+            \n+            fields.era = ERA_FIELD;\n+            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);\n+            fields.months = fields.monthOfYear.getDurationField();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/EthiopicChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.SkipDateTimeField;\n+\n+/**\n+ * Implements the Ethiopic calendar system, which defines every fourth year as\n+ * leap, much like the Julian calendar. The year is broken down into 12 months,\n+ * each 30 days in length. An extra period at the end of the year is either 5\n+ * or 6 days in length. In this implementation, it is considered a 13th month.\n+ * <p>\n+ * Year 1 in the Ethiopic calendar began on August 29, 8 CE (Julian), thus\n+ * Ethiopic years do not begin at the same time as Julian years. This chronology\n+ * is not proleptic, as it does not allow dates before the first Ethiopic year.\n+ * <p>\n+ * This implementation defines a day as midnight to midnight exactly as per\n+ * the ISO chronology. Some references indicate that a coptic day starts at\n+ * sunset on the previous ISO day, but this has not been confirmed and is not\n+ * implemented.\n+ * <p>\n+ * EthiopicChronology is thread-safe and immutable.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Ethiopian_calendar\">Wikipedia</a>\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.2\n+ */\n+public final class EthiopicChronology extends BasicFixedMonthChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -5972804258688333942L;\n+\n+    /**\n+     * Constant value for 'Ethiopean Era', equivalent\n+     * to the value returned for AD/CE.\n+     */\n+    public static final int EE = DateTimeConstants.CE;\n+\n+    /** A singleton era field. */\n+    private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"EE\");\n+\n+    /** The lowest year that can be fully supported. */\n+    private static final int MIN_YEAR = -292269337;\n+\n+    /** The highest year that can be fully supported. */\n+    private static final int MAX_YEAR = 292272984;\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map<DateTimeZone, EthiopicChronology[]> cCache = new HashMap<DateTimeZone, EthiopicChronology[]>();\n+\n+    /** Singleton instance of a UTC EthiopicChronology */\n+    private static final EthiopicChronology INSTANCE_UTC;\n+    static {\n+        // init after static fields\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an instance of the EthiopicChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static EthiopicChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the EthiopicChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static EthiopicChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the EthiopicChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static EthiopicChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the EthiopicChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     * @return a chronology in the specified time zone\n+     */\n+    public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        EthiopicChronology chrono;\n+        synchronized (cCache) {\n+            EthiopicChronology[] chronos = cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new EthiopicChronology[7];\n+                cCache.put(zone, chronos);\n+            }\n+            try {\n+                chrono = chronos[minDaysInFirstWeek - 1];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IllegalArgumentException\n+                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+            }\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    // First create without a lower limit.\n+                    chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);\n+                    // Impose lower limit and make another EthiopicChronology.\n+                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+                    chrono = new EthiopicChronology\n+                        (LimitChronology.getInstance(chrono, lowerLimit, null),\n+                         null, minDaysInFirstWeek);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n+                    chrono = new EthiopicChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n+                }\n+                chronos[minDaysInFirstWeek - 1] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     */\n+    EthiopicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Serialization singleton.\n+     */\n+    private Object readResolve() {\n+        Chronology base = getBase();\n+        return base == null ?\n+                getInstance(DateTimeZone.UTC, getMinimumDaysInFirstWeek()) :\n+                    getInstance(base.getZone(), getMinimumDaysInFirstWeek());\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long calculateFirstDayOfYearMillis(int year) {\n+        // Java epoch is 1970-01-01 Gregorian which is 1962-04-23 Ethiopic.\n+        // Calculate relative to the nearest leap year and account for the\n+        // difference later.\n+\n+        int relativeYear = year - 1963;\n+        int leapYears;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers.\n+            leapYears = (relativeYear + 3) >> 2;\n+        } else {\n+            leapYears = relativeYear >> 2;\n+            // For post 1963 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears)\n+            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+\n+        // Adjust to account for difference between 1963-01-01 and 1962-04-23.\n+\n+        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMinYear() {\n+        return MIN_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMaxYear() {\n+        return MAX_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        return (1962L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+\n+            // Ethiopic, like Julian, has no year zero.\n+            fields.year = new SkipDateTimeField(this, fields.year);\n+            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n+            \n+            fields.era = ERA_FIELD;\n+            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);\n+            fields.months = fields.monthOfYear.getDurationField();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/GJChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.Instant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.BaseDateTimeField;\n+import org.joda.time.field.DecoratedDurationField;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Implements the Gregorian/Julian calendar system which is the calendar system\n+ * used in most of the world. Wherever possible, it is recommended to use the\n+ * {@link ISOChronology} instead.\n+ * <p>\n+ * The Gregorian calendar replaced the Julian calendar, and the point in time\n+ * when this chronology switches can be controlled using the second parameter\n+ * of the getInstance method. By default this cutover is set to the date the\n+ * Gregorian calendar was first instituted, October 15, 1582.\n+ * <p>\n+ * Before this date, this chronology uses the proleptic Julian calendar\n+ * (proleptic means extending indefinitely). The Julian calendar has leap years\n+ * every four years, whereas the Gregorian has special rules for 100 and 400\n+ * years. A meaningful result will thus be obtained for all input values.\n+ * However before 8 CE, Julian leap years were irregular, and before 45 BCE\n+ * there was no Julian calendar.\n+ * <p>\n+ * This chronology differs from\n+ * {@link java.util.GregorianCalendar GregorianCalendar} in that years\n+ * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.\n+ * The yearOfEra field produces results compatible with GregorianCalendar.\n+ * <p>\n+ * The Julian calendar does not have a year zero, and so year -1 is followed by\n+ * year 1. If the Gregorian cutover date is specified at or before year -1\n+ * (Julian), year zero is defined. In other words, the proleptic Gregorian\n+ * chronology used by this class has a year zero.\n+ * <p>\n+ * To create a pure proleptic Julian chronology, use {@link JulianChronology},\n+ * and to create a pure proleptic Gregorian chronology, use\n+ * {@link GregorianChronology}.\n+ * <p>\n+ * GJChronology is thread-safe and immutable.\n+ * \n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class GJChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -2545574827706931671L;\n+\n+    /**\n+     * Convert a datetime from one chronology to another.\n+     */\n+    private static long convertByYear(long instant, Chronology from, Chronology to) {\n+        return to.getDateTimeMillis\n+            (from.year().get(instant),\n+             from.monthOfYear().get(instant),\n+             from.dayOfMonth().get(instant),\n+             from.millisOfDay().get(instant));\n+    }\n+\n+    /**\n+     * Convert a datetime from one chronology to another.\n+     */\n+    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n+        long newInstant;\n+        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n+        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n+        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n+        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n+        return newInstant;\n+    }\n+\n+    /**\n+     * The default GregorianJulian cutover point.\n+     */\n+    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\n+\n+    /** Cache of zone to chronology list */\n+    private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n+\n+    /**\n+     * Factory method returns instances of the default GJ cutover\n+     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n+     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n+     * October 15, 1582 (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n+     * and the minimum days in the first week of the year is 4.\n+     *\n+     * <p>The time zone of the returned instance is UTC.\n+     */\n+    public static GJChronology getInstanceUTC() {\n+        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n+    }\n+\n+    /**\n+     * Factory method returns instances of the default GJ cutover\n+     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)\n+     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by\n+     * October 15, 1582 (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n+     * and the minimum days in the first week of the year is 4.\n+     *\n+     * <p>The returned chronology is in the default time zone.\n+     */\n+    public static GJChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);\n+    }\n+\n+    /**\n+     * Factory method returns instances of the GJ cutover chronology. This uses\n+     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this\n+     * value, October 4, 1582 (Julian) is followed by October 15, 1582\n+     * (Gregorian).\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n+     * and the minimum days in the first week of the year is 4.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     */\n+    public static GJChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, DEFAULT_CUTOVER, 4);\n+    }\n+\n+    /**\n+     * Factory method returns instances of the GJ cutover chronology. Any\n+     * cutover date may be specified.\n+     *\n+     * <p>The first day of the week is designated to be\n+     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n+     * and the minimum days in the first week of the year is 4.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover to use, null means default\n+     */\n+    public static GJChronology getInstance(\n+            DateTimeZone zone,\n+            ReadableInstant gregorianCutover) {\n+        \n+        return getInstance(zone, gregorianCutover, 4);\n+    }\n+    \n+    /**\n+     * Factory method returns instances of the GJ cutover chronology. Any\n+     * cutover date may be specified.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover to use, null means default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     */\n+    public static synchronized GJChronology getInstance(\n+            DateTimeZone zone,\n+            ReadableInstant gregorianCutover,\n+            int minDaysInFirstWeek) {\n+        \n+        zone = DateTimeUtils.getZone(zone);\n+        Instant cutoverInstant;\n+        if (gregorianCutover == null) {\n+            cutoverInstant = DEFAULT_CUTOVER;\n+        } else {\n+            cutoverInstant = gregorianCutover.toInstant();\n+        }\n+\n+        GJChronology chrono;\n+\n+        ArrayList<GJChronology> chronos = cCache.get(zone);\n+        if (chronos == null) {\n+            chronos = new ArrayList<GJChronology>(2);\n+            cCache.put(zone, chronos);\n+        } else {\n+            for (int i=chronos.size(); --i>=0; ) {\n+                chrono = chronos.get(i);\n+                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n+                    cutoverInstant.equals(chrono.getGregorianCutover())) {\n+                    \n+                    return chrono;\n+                }\n+            }\n+        }\n+\n+        if (zone == DateTimeZone.UTC) {\n+            chrono = new GJChronology\n+                (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n+                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n+                 cutoverInstant);\n+        } else {\n+            chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n+            chrono = new GJChronology\n+                (ZonedChronology.getInstance(chrono, zone),\n+                 chrono.iJulianChronology,\n+                 chrono.iGregorianChronology,\n+                 chrono.iCutoverInstant);\n+        }\n+\n+        chronos.add(chrono);\n+\n+        return chrono;\n+    }\n+\n+    /**\n+     * Factory method returns instances of the GJ cutover chronology. Any\n+     * cutover date may be specified.\n+     *\n+     * @param zone  the time zone to use, null is default\n+     * @param gregorianCutover  the cutover to use\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     */\n+    public static GJChronology getInstance(\n+            DateTimeZone zone,\n+            long gregorianCutover,\n+            int minDaysInFirstWeek) {\n+        \n+        Instant cutoverInstant;\n+        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n+            cutoverInstant = null;\n+        } else {\n+            cutoverInstant = new Instant(gregorianCutover);\n+        }\n+        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private JulianChronology iJulianChronology;\n+    private GregorianChronology iGregorianChronology;\n+    private Instant iCutoverInstant;\n+\n+    private long iCutoverMillis;\n+    private long iGapDuration;\n+\n+    /**\n+     * @param julian chronology used before the cutover instant\n+     * @param gregorian chronology used at and after the cutover instant\n+     * @param cutoverInstant instant when the gregorian chronology began\n+     */\n+    private GJChronology(JulianChronology julian,\n+                         GregorianChronology gregorian,\n+                         Instant cutoverInstant) {\n+        super(null, new Object[] {julian, gregorian, cutoverInstant});\n+    }\n+\n+    /**\n+     * Called when applying a time zone.\n+     */\n+    private GJChronology(Chronology base,\n+                         JulianChronology julian,\n+                         GregorianChronology gregorian,\n+                         Instant cutoverInstant) {\n+        super(base, new Object[] {julian, gregorian, cutoverInstant});\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());\n+    }\n+\n+    public DateTimeZone getZone() {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getZone();\n+        }\n+        return DateTimeZone.UTC;\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return withZone(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        }\n+\n+        // Assume date is Gregorian.\n+        long instant = iGregorianChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth, millisOfDay);\n+        if (instant < iCutoverMillis) {\n+            // Maybe it's Julian.\n+            instant = iJulianChronology.getDateTimeMillis\n+                (year, monthOfYear, dayOfMonth, millisOfDay);\n+            if (instant >= iCutoverMillis) {\n+                // Okay, it's in the illegal cutover gap.\n+                throw new IllegalArgumentException(\"Specified date does not exist\");\n+            }\n+        }\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        Chronology base;\n+        if ((base = getBase()) != null) {\n+            return base.getDateTimeMillis\n+                (year, monthOfYear, dayOfMonth,\n+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        }\n+\n+        // Assume date is Gregorian.\n+        long instant = iGregorianChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        if (instant < iCutoverMillis) {\n+            // Maybe it's Julian.\n+            instant = iJulianChronology.getDateTimeMillis\n+                (year, monthOfYear, dayOfMonth,\n+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+            if (instant >= iCutoverMillis) {\n+                // Okay, it's in the illegal cutover gap.\n+                throw new IllegalArgumentException(\"Specified date does not exist\");\n+            }\n+        }\n+        return instant;\n+    }\n+\n+    /**\n+     * Gets the cutover instant between Gregorian and Julian chronologies.\n+     * @return the cutover instant\n+     */\n+    public Instant getGregorianCutover() {\n+        return iCutoverInstant;\n+    }\n+\n+    /**\n+     * Gets the minimum days needed for a week to be the first week in a year.\n+     * \n+     * @return the minimum days\n+     */\n+    public int getMinimumDaysInFirstWeek() {\n+        return iGregorianChronology.getMinimumDaysInFirstWeek();\n+    }\n+\n+    /**\n+     * Checks if this chronology instance equals another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.6\n+     */\n+    public boolean equals(Object obj) {\n+        return super.equals(obj);\n+    }\n+\n+    /**\n+     * A suitable hash code for the chronology.\n+     * \n+     * @return the hash code\n+     * @since 1.6\n+     */\n+    public int hashCode() {\n+        return \"GJ\".hashCode() * 11 + iJulianChronology.hashCode() +\n+            iGregorianChronology.hashCode() + iCutoverInstant.hashCode();\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer(60);\n+        sb.append(\"GJChronology\");\n+        sb.append('[');\n+        sb.append(getZone().getID());\n+        \n+        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n+            sb.append(\",cutover=\");\n+            DateTimeFormatter printer;\n+            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n+                printer = ISODateTimeFormat.date();\n+            } else {\n+                printer = ISODateTimeFormat.dateTime();\n+            }\n+            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n+        }\n+        \n+        if (getMinimumDaysInFirstWeek() != 4) {\n+            sb.append(\",mdfw=\");\n+            sb.append(getMinimumDaysInFirstWeek());\n+        }\n+        sb.append(']');\n+        \n+        return sb.toString();\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        Object[] params = (Object[])getParam();\n+\n+        JulianChronology julian = (JulianChronology)params[0];\n+        GregorianChronology gregorian = (GregorianChronology)params[1];\n+        Instant cutoverInstant = (Instant)params[2];\n+        iCutoverMillis = cutoverInstant.getMillis();\n+\n+        iJulianChronology = julian;\n+        iGregorianChronology = gregorian;\n+        iCutoverInstant = cutoverInstant;\n+\n+        if (getBase() != null) {\n+            return;\n+        }\n+\n+        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        // Compute difference between the chronologies at the cutover instant\n+        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n+\n+        // Begin field definitions.\n+\n+        // First just copy all the Gregorian fields and then override those\n+        // that need special attention.\n+        fields.copyFieldsFrom(gregorian);\n+        \n+        // Assuming cutover is at midnight, all time of day fields can be\n+        // gregorian since they are unaffected by cutover.\n+\n+        // Verify assumption.\n+        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n+            // Cutover is sometime in the day, so cutover fields are required\n+            // for time of day.\n+\n+            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n+            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n+            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n+            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n+            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n+            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n+            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n+            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n+            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n+            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n+                                                         fields.clockhourOfHalfday, iCutoverMillis);\n+            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n+        }\n+\n+        // These fields just require basic cutover support.\n+        {\n+            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n+        }\n+\n+        // DayOfYear and weekOfWeekyear require special handling since cutover\n+        // year has fewer days and weeks. Extend the cutover to the start of\n+        // the next year or weekyear. This keeps the sequence unbroken during\n+        // the cutover year.\n+\n+        {\n+            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n+            fields.dayOfYear = new CutoverField(\n+                julian.dayOfYear(), fields.dayOfYear, cutover);\n+        }\n+\n+        {\n+            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n+            fields.weekOfWeekyear = new CutoverField(\n+                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n+        }\n+\n+        // These fields are special because they have imprecise durations. The\n+        // family of addition methods need special attention. Override affected\n+        // duration fields as well.\n+        {\n+            fields.year = new ImpreciseCutoverField(\n+                julian.year(), fields.year, iCutoverMillis);\n+            fields.years = fields.year.getDurationField();\n+            fields.yearOfEra = new ImpreciseCutoverField(\n+                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n+            fields.yearOfCentury = new ImpreciseCutoverField(\n+                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n+            \n+            fields.centuryOfEra = new ImpreciseCutoverField(\n+                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n+            fields.centuries = fields.centuryOfEra.getDurationField();\n+            \n+            fields.monthOfYear = new ImpreciseCutoverField(\n+                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n+            fields.months = fields.monthOfYear.getDurationField();\n+            \n+            fields.weekyear = new ImpreciseCutoverField(\n+                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n+            fields.weekyearOfCentury = new ImpreciseCutoverField(\n+                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n+            fields.weekyears = fields.weekyear.getDurationField();\n+        }\n+\n+        // These fields require basic cutover support, except they must link to\n+        // imprecise durations.\n+        {\n+            CutoverField cf = new CutoverField\n+                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n+            cf.iRangeDurationField = fields.months;\n+            fields.dayOfMonth = cf;\n+        }\n+    }\n+\n+    long julianToGregorianByYear(long instant) {\n+        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n+    }\n+\n+    long gregorianToJulianByYear(long instant) {\n+        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n+    }\n+\n+    long julianToGregorianByWeekyear(long instant) {\n+        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n+    }\n+\n+    long gregorianToJulianByWeekyear(long instant) {\n+        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n+     * assumes that calls to add and addWrapField are unaffected by the cutover.\n+     */\n+    private class CutoverField extends BaseDateTimeField {\n+        private static final long serialVersionUID = 3528501219481026402L;\n+\n+        final DateTimeField iJulianField;\n+        final DateTimeField iGregorianField;\n+        final long iCutover;\n+        final boolean iConvertByWeekyear;\n+\n+        protected DurationField iDurationField;\n+        protected DurationField iRangeDurationField;\n+\n+        /**\n+         * @param julianField field from the chronology used before the cutover instant\n+         * @param gregorianField field from the chronology used at and after the cutover\n+         * @param cutoverMillis  the millis of the cutover\n+         */\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n+            this(julianField, gregorianField, cutoverMillis, false);\n+        }\n+\n+        /**\n+         * @param julianField field from the chronology used before the cutover instant\n+         * @param gregorianField field from the chronology used at and after the cutover\n+         * @param cutoverMillis  the millis of the cutover\n+         * @param convertByWeekyear\n+         */\n+        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n+                     long cutoverMillis, boolean convertByWeekyear) {\n+            super(gregorianField.getType());\n+            iJulianField = julianField;\n+            iGregorianField = gregorianField;\n+            iCutover = cutoverMillis;\n+            iConvertByWeekyear = convertByWeekyear;\n+            // Although average length of Julian and Gregorian years differ,\n+            // use the Gregorian duration field because it is more accurate.\n+            iDurationField = gregorianField.getDurationField();\n+\n+            DurationField rangeField = gregorianField.getRangeDurationField();\n+            if (rangeField == null) {\n+                rangeField = julianField.getRangeDurationField();\n+            }\n+            iRangeDurationField = rangeField;\n+        }\n+\n+        public boolean isLenient() {\n+            return false;\n+        }\n+\n+        public int get(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.get(instant);\n+            } else {\n+                return iJulianField.get(instant);\n+            }\n+        }\n+\n+        public String getAsText(long instant, Locale locale) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getAsText(instant, locale);\n+            } else {\n+                return iJulianField.getAsText(instant, locale);\n+            }\n+        }\n+\n+        public String getAsText(int fieldValue, Locale locale) {\n+            return iGregorianField.getAsText(fieldValue, locale);\n+        }\n+\n+        public String getAsShortText(long instant, Locale locale) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getAsShortText(instant, locale);\n+            } else {\n+                return iJulianField.getAsShortText(instant, locale);\n+            }\n+        }\n+\n+        public String getAsShortText(int fieldValue, Locale locale) {\n+            return iGregorianField.getAsShortText(fieldValue, locale);\n+        }\n+\n+        public long add(long instant, int value) {\n+            return iGregorianField.add(instant, value);\n+        }\n+\n+        public long add(long instant, long value) {\n+            return iGregorianField.add(instant, value);\n+        }\n+\n+        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n+            // overridden as superclass algorithm can't handle\n+            // 2004-02-29 + 48 months -> 2008-02-29 type dates\n+            if (valueToAdd == 0) {\n+                return values;\n+            }\n+            if (DateTimeUtils.isContiguous(partial)) {\n+                long instant = 0L;\n+                for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);\n+                }\n+                instant = add(instant, valueToAdd);\n+                return GJChronology.this.get(partial, instant);\n+            } else {\n+                return super.add(partial, fieldIndex, values, valueToAdd);\n+            }\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long set(long instant, int value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.set(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                    // Verify that new value stuck.\n+                    if (get(instant) != value) {\n+                        throw new IllegalFieldValueException\n+                            (iGregorianField.getType(), new Integer(value), null, null);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.set(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                    // Verify that new value stuck.\n+                    if (get(instant) != value) {\n+                       throw new IllegalFieldValueException\n+                            (iJulianField.getType(), new Integer(value), null, null);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public long set(long instant, String text, Locale locale) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.set(instant, text, locale);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                    // Cannot verify that new value stuck because set may be lenient.\n+                }\n+            } else {\n+                instant = iJulianField.set(instant, text, locale);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                    // Cannot verify that new value stuck because set may be lenient.\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public DurationField getDurationField() {\n+            return iDurationField;\n+        }\n+\n+        public DurationField getRangeDurationField() {\n+            return iRangeDurationField;\n+        }\n+\n+        public boolean isLeap(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.isLeap(instant);\n+            } else {\n+                return iJulianField.isLeap(instant);\n+            }\n+        }\n+\n+        public int getLeapAmount(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getLeapAmount(instant);\n+            } else {\n+                return iJulianField.getLeapAmount(instant);\n+            }\n+        }\n+\n+        public DurationField getLeapDurationField() {\n+            return iGregorianField.getLeapDurationField();\n+        }\n+\n+\n+        public int getMinimumValue() {\n+            // For all precise fields, the Julian and Gregorian limits are\n+            // identical. Choose Julian to tighten up the year limits.\n+            return iJulianField.getMinimumValue();\n+        }\n+\n+        public int getMinimumValue(ReadablePartial partial) {\n+            return iJulianField.getMinimumValue(partial);\n+        }\n+\n+        public int getMinimumValue(ReadablePartial partial, int[] values) {\n+            return iJulianField.getMinimumValue(partial, values);\n+        }\n+\n+        public int getMinimumValue(long instant) {\n+            if (instant < iCutover) {\n+                return iJulianField.getMinimumValue(instant);\n+            }\n+\n+            int min = iGregorianField.getMinimumValue(instant);\n+\n+            // Because the cutover may reduce the length of this field, verify\n+            // the minimum by setting it.\n+            instant = iGregorianField.set(instant, min);\n+            if (instant < iCutover) {\n+                min = iGregorianField.get(iCutover);\n+            }\n+\n+            return min;\n+        }\n+\n+        public int getMaximumValue() {\n+            // For all precise fields, the Julian and Gregorian limits are\n+            // identical.\n+            return iGregorianField.getMaximumValue();\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMaximumValue(instant);\n+            }\n+\n+            int max = iJulianField.getMaximumValue(instant);\n+\n+            // Because the cutover may reduce the length of this field, verify\n+            // the maximum by setting it.\n+            instant = iJulianField.set(instant, max);\n+            if (instant >= iCutover) {\n+                max = iJulianField.get(iJulianField.add(iCutover, -1));\n+            }\n+\n+            return max;\n+        }\n+\n+        public int getMaximumValue(ReadablePartial partial) {\n+            long instant = GJChronology.getInstanceUTC().set(partial, 0L);\n+            return getMaximumValue(instant);\n+        }\n+\n+        public int getMaximumValue(ReadablePartial partial, int[] values) {\n+            Chronology chrono = GJChronology.getInstanceUTC();\n+            long instant = 0L;\n+            for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                DateTimeField field = partial.getFieldType(i).getField(chrono);\n+                if (values[i] <= field.getMaximumValue(instant)) {\n+                    instant = field.set(instant, values[i]);\n+                }\n+            }\n+            return getMaximumValue(instant);\n+        }\n+\n+        public long roundFloor(long instant) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.roundFloor(instant);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.roundFloor(instant);\n+            }\n+            return instant;\n+        }\n+\n+        public long roundCeiling(long instant) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.roundCeiling(instant);\n+            } else {\n+                instant = iJulianField.roundCeiling(instant);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return Math.max(iJulianField.getMaximumTextLength(locale),\n+                            iGregorianField.getMaximumTextLength(locale));\n+        }\n+\n+        public int getMaximumShortTextLength(Locale locale) {\n+            return Math.max(iJulianField.getMaximumShortTextLength(locale),\n+                            iGregorianField.getMaximumShortTextLength(locale));\n+        }\n+\n+        protected long julianToGregorian(long instant) {\n+            if (iConvertByWeekyear) {\n+                return julianToGregorianByWeekyear(instant);\n+            } else {\n+                return julianToGregorianByYear(instant);\n+            }\n+        }\n+\n+        protected long gregorianToJulian(long instant) {\n+            if (iConvertByWeekyear) {\n+                return gregorianToJulianByWeekyear(instant);\n+            } else {\n+                return gregorianToJulianByYear(instant);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Cutover field for variable length fields. These fields internally call\n+     * set whenever add is called. As a result, the same correction applied to\n+     * set must be applied to add and addWrapField. Knowing when to use this\n+     * field requires specific knowledge of how the GJ fields are implemented.\n+     */\n+    private final class ImpreciseCutoverField extends CutoverField {\n+        private static final long serialVersionUID = 3410248757173576441L;\n+\n+        /**\n+         * Creates a duration field that links back to this.\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n+            this(julianField, gregorianField, null, cutoverMillis, false);\n+        }\n+\n+        /**\n+         * Uses a shared duration field rather than creating a new one.\n+         *\n+         * @param durationField shared duration field\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n+                              DurationField durationField, long cutoverMillis)\n+        {\n+            this(julianField, gregorianField, durationField, cutoverMillis, false);\n+        }\n+\n+        /**\n+         * Uses a shared duration field rather than creating a new one.\n+         *\n+         * @param durationField shared duration field\n+         */\n+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n+                              DurationField durationField,\n+                              long cutoverMillis, boolean convertByWeekyear)\n+        {\n+            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);\n+            if (durationField == null) {\n+                durationField = new LinkedDurationField(iDurationField, this);\n+            }\n+            iDurationField = durationField;\n+        }\n+\n+        public long add(long instant, int value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.add(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.add(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+        \n+        public long add(long instant, long value) {\n+            if (instant >= iCutover) {\n+                instant = iGregorianField.add(instant, value);\n+                if (instant < iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant + iGapDuration < iCutover) {\n+                        instant = gregorianToJulian(instant);\n+                    }\n+                }\n+            } else {\n+                instant = iJulianField.add(instant, value);\n+                if (instant >= iCutover) {\n+                    // Only adjust if gap fully crossed.\n+                    if (instant - iGapDuration >= iCutover) {\n+                        instant = julianToGregorian(instant);\n+                    }\n+                }\n+            }\n+            return instant;\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            if (minuendInstant >= iCutover) {\n+                if (subtrahendInstant >= iCutover) {\n+                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Julian, convert minuend to Julian to match.\n+                minuendInstant = gregorianToJulian(minuendInstant);\n+                return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n+            } else {\n+                if (subtrahendInstant < iCutover) {\n+                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Gregorian, convert minuend to Gregorian to match.\n+                minuendInstant = julianToGregorian(minuendInstant);\n+                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);\n+            }\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            if (minuendInstant >= iCutover) {\n+                if (subtrahendInstant >= iCutover) {\n+                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Julian, convert minuend to Julian to match.\n+                minuendInstant = gregorianToJulian(minuendInstant);\n+                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+            } else {\n+                if (subtrahendInstant < iCutover) {\n+                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+                }\n+                // Remember, the add is being reversed. Since subtrahend is\n+                // Gregorian, convert minuend to Gregorian to match.\n+                minuendInstant = julianToGregorian(minuendInstant);\n+                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+            }\n+        }\n+\n+        // Since the imprecise fields have durations longer than the gap\n+        // duration, keep these methods simple. The inherited implementations\n+        // produce incorrect results.\n+        //\n+        // Degenerate case: If this field is a month, and the cutover is set\n+        // far into the future, then the gap duration may be so large as to\n+        // reduce the number of months in a year. If the missing month(s) are\n+        // at the beginning or end of the year, then the minimum and maximum\n+        // values are not 1 and 12. I don't expect this case to ever occur.\n+\n+        public int getMinimumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMinimumValue(instant);\n+            } else {\n+                return iJulianField.getMinimumValue(instant);\n+            }\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            if (instant >= iCutover) {\n+                return iGregorianField.getMaximumValue(instant);\n+            } else {\n+                return iJulianField.getMaximumValue(instant);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Links the duration back to a ImpreciseCutoverField.\n+     */\n+    private static class LinkedDurationField extends DecoratedDurationField {\n+        private static final long serialVersionUID = 4097975388007713084L;\n+\n+        private final ImpreciseCutoverField iField;\n+\n+        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n+            super(durationField, durationField.getType());\n+            iField = dateTimeField;\n+        }\n+\n+        public long add(long instant, int value) {\n+            return iField.add(instant, value);\n+        }\n+\n+        public long add(long instant, long value) {\n+            return iField.add(instant, value);\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return iField.getDifference(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * GJDayOfWeekDateTimeField provides time calculations for the\n+ * day of the week component of time.\n+ *\n+ * @since 1.0\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ */\n+final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {\n+    \n+    /** Serialization version */\n+    private static final long serialVersionUID = -3857947176719041436L;\n+\n+    private final BasicChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n+        super(DateTimeFieldType.dayOfWeek(), days);\n+        iChronology = chronology;\n+    }\n+\n+    /**\n+     * Get the value of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query\n+     * @return the day of the week extracted from the input\n+     */\n+    public int get(long instant) {\n+        return iChronology.getDayOfWeek(instant);\n+    }\n+\n+    /**\n+     * Get the textual value of the specified time instant.\n+     * \n+     * @param fieldValue  the field value to query\n+     * @param locale  the locale to use\n+     * @return the day of the week, such as 'Monday'\n+     */\n+    public String getAsText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue);\n+    }\n+\n+    /**\n+     * Get the abbreviated textual value of the specified time instant.\n+     * \n+     * @param fieldValue  the field value to query\n+     * @param locale  the locale to use\n+     * @return the day of the week, such as 'Mon'\n+     */\n+    public String getAsShortText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue);\n+    }\n+\n+    /**\n+     * Convert the specified text and locale into a value.\n+     * \n+     * @param text  the text to convert\n+     * @param locale  the locale to convert using\n+     * @return the value extracted from the text\n+     * @throws IllegalArgumentException if the text is invalid\n+     */\n+    protected int convertText(String text, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.weeks();\n+    }\n+\n+    /**\n+     * Get the minimum value that this field can have.\n+     * \n+     * @return the field's minimum value\n+     */\n+    public int getMinimumValue() {\n+        return DateTimeConstants.MONDAY;\n+    }\n+\n+    /**\n+     * Get the maximum value that this field can have.\n+     * \n+     * @return the field's maximum value\n+     */\n+    public int getMaximumValue() {\n+        return DateTimeConstants.SUNDAY;\n+    }\n+\n+    /**\n+     * Get the maximum length of the text returned by this field.\n+     * \n+     * @param locale  the locale to use\n+     * @return the maximum textual length\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength();\n+    }\n+\n+    /**\n+     * Get the maximum length of the abbreviated text returned by this field.\n+     * \n+     * @param locale  the locale to use\n+     * @return the maximum abbreviated textual length\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfWeek();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/GJEraDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.field.BaseDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.UnsupportedDurationField;\n+\n+/**\n+ * Provides time calculations for the era component of time.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJEraDateTimeField extends BaseDateTimeField {\n+    \n+    /** Serialization version */\n+    private static final long serialVersionUID = 4240986525305515528L;\n+\n+    private final BasicChronology iChronology;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJEraDateTimeField(BasicChronology chronology) {\n+        super(DateTimeFieldType.era());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Get the Era component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     */\n+    public int get(long instant) {\n+        if (iChronology.getYear(instant) <= 0) {\n+            return DateTimeConstants.BCE;\n+        } else {\n+            return DateTimeConstants.CE;\n+        }\n+    }\n+\n+    public String getAsText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).eraValueToText(fieldValue);\n+    }\n+\n+    /**\n+     * Set the Era component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param era  the era to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if era is invalid.\n+     */\n+    public long set(long instant, int era) {\n+        FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);\n+            \n+        int oldEra = get(instant);\n+        if (oldEra != era) {\n+            int year = iChronology.getYear(instant);\n+            return iChronology.setYear(instant, -year);\n+        } else {\n+            return instant;\n+        }\n+    }\n+\n+    public long set(long instant, String text, Locale locale) {\n+        return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));\n+    }\n+\n+    public long roundFloor(long instant) {\n+        if (get(instant) == DateTimeConstants.CE) {\n+            return iChronology.setYear(0, 1);\n+        } else {\n+            return Long.MIN_VALUE;\n+        }\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        if (get(instant) == DateTimeConstants.BCE) {\n+            return iChronology.setYear(0, 1);\n+        } else {\n+            return Long.MAX_VALUE;\n+        }\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        // In reality, the era is infinite, so there is no halfway point.\n+        return roundFloor(instant);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public int getMinimumValue() {\n+        return DateTimeConstants.BCE;\n+    }\n+\n+    public int getMaximumValue() {\n+        return DateTimeConstants.CE;\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength();\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.era();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.lang.ref.WeakReference;\n+import java.text.DateFormatSymbols;\n+import java.util.Locale;\n+import java.util.TreeMap;\n+import java.util.WeakHashMap;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.IllegalFieldValueException;\n+\n+/**\n+ * Utility class used by a few of the GJDateTimeFields.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class GJLocaleSymbols {\n+    private static final int FAST_CACHE_SIZE = 64;\n+\n+    private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];\n+\n+    private static WeakHashMap<Locale, GJLocaleSymbols> cCache = new WeakHashMap<Locale, GJLocaleSymbols>();\n+\n+    public static GJLocaleSymbols forLocale(Locale locale) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);\n+        GJLocaleSymbols symbols = cFastCache[index];\n+        if (symbols != null && symbols.iLocale.get() == locale) {\n+            return symbols;\n+        }\n+        synchronized (cCache) {\n+            symbols = cCache.get(locale);\n+            if (symbols == null) {\n+                symbols = new GJLocaleSymbols(locale);\n+                cCache.put(locale, symbols);\n+            }\n+        }\n+        cFastCache[index] = symbols;\n+        return symbols;\n+    }\n+\n+    private static String[] realignMonths(String[] months) {\n+        String[] a = new String[13];\n+        for (int i=1; i<13; i++) {\n+            a[i] = months[i - 1];\n+        }\n+        return a;\n+    }\n+\n+    private static String[] realignDaysOfWeek(String[] daysOfWeek) {\n+        String[] a = new String[8];\n+        for (int i=1; i<8; i++) {\n+            a[i] = daysOfWeek[(i < 7) ? i + 1 : 1];\n+        }\n+        return a;\n+    }\n+\n+    private static void addSymbols(TreeMap<String, Integer> map, String[] symbols, Integer[] integers) {\n+        for (int i=symbols.length; --i>=0; ) {\n+            String symbol = symbols[i];\n+            if (symbol != null) {\n+                map.put(symbol, integers[i]);\n+            }\n+        }\n+    }\n+\n+    private static void addNumerals(TreeMap<String, Integer> map, int start, int end, Integer[] integers) {\n+        for (int i=start; i<=end; i++) {\n+            map.put(String.valueOf(i).intern(), integers[i]);\n+        }\n+    }\n+\n+    private static int maxLength(String[] a) {\n+        int max = 0;\n+        for (int i=a.length; --i>=0; ) {\n+            String s = a[i];\n+            if (s != null) {\n+                int len = s.length();\n+                if (len > max) {\n+                    max = len;\n+                }\n+            }\n+        }\n+        return max;\n+    }\n+\n+    private final WeakReference<Locale> iLocale;\n+\n+    private final String[] iEras;\n+    private final String[] iDaysOfWeek;\n+    private final String[] iShortDaysOfWeek;\n+    private final String[] iMonths;\n+    private final String[] iShortMonths;\n+    private final String[] iHalfday;\n+\n+    private final TreeMap<String, Integer> iParseEras;\n+    private final TreeMap<String, Integer> iParseDaysOfWeek;\n+    private final TreeMap<String, Integer> iParseMonths;\n+\n+    private final int iMaxEraLength;\n+    private final int iMaxDayOfWeekLength;\n+    private final int iMaxShortDayOfWeekLength;\n+    private final int iMaxMonthLength;\n+    private final int iMaxShortMonthLength;\n+    private final int iMaxHalfdayLength;\n+\n+    /**\n+     * @param locale must not be null\n+     */\n+    private GJLocaleSymbols(Locale locale) {\n+        iLocale = new WeakReference<Locale>(locale);\n+        \n+        DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale);\n+        \n+        iEras = dfs.getEras();\n+        iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays());\n+        iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays());\n+        iMonths = realignMonths(dfs.getMonths());\n+        iShortMonths = realignMonths(dfs.getShortMonths());\n+        iHalfday = dfs.getAmPmStrings();\n+\n+        Integer[] integers = new Integer[13];\n+        for (int i=0; i<13; i++) {\n+            integers[i] = new Integer(i);\n+        }\n+\n+        iParseEras = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n+        addSymbols(iParseEras, iEras, integers);\n+        if (\"en\".equals(locale.getLanguage())) {\n+            // Include support for parsing \"BCE\" and \"CE\" if the language is\n+            // English. At some point Joda-Time will need an independent set of\n+            // localized symbols and not depend on java.text.DateFormatSymbols.\n+            iParseEras.put(\"BCE\", integers[0]);\n+            iParseEras.put(\"CE\", integers[1]);\n+        }\n+\n+        iParseDaysOfWeek = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n+        addSymbols(iParseDaysOfWeek, iDaysOfWeek, integers);\n+        addSymbols(iParseDaysOfWeek, iShortDaysOfWeek, integers);\n+        addNumerals(iParseDaysOfWeek, 1, 7, integers);\n+\n+        iParseMonths = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER);\n+        addSymbols(iParseMonths, iMonths, integers);\n+        addSymbols(iParseMonths, iShortMonths, integers);\n+        addNumerals(iParseMonths, 1, 12, integers);\n+\n+        iMaxEraLength = maxLength(iEras);\n+        iMaxDayOfWeekLength = maxLength(iDaysOfWeek);\n+        iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek);\n+        iMaxMonthLength = maxLength(iMonths);\n+        iMaxShortMonthLength = maxLength(iShortMonths);\n+        iMaxHalfdayLength = maxLength(iHalfday);\n+    }\n+\n+    public String eraValueToText(int value) {\n+        return iEras[value];\n+    }\n+\n+    public int eraTextToValue(String text) {\n+        Integer era = iParseEras.get(text);\n+        if (era != null) {\n+            return era.intValue();\n+        }\n+        throw new IllegalFieldValueException(DateTimeFieldType.era(), text);\n+    }\n+\n+    public int getEraMaxTextLength() {\n+        return iMaxEraLength;\n+    }\n+\n+    public String monthOfYearValueToText(int value) {\n+        return iMonths[value];\n+    }\n+\n+    public String monthOfYearValueToShortText(int value) {\n+        return iShortMonths[value];\n+    }\n+\n+    public int monthOfYearTextToValue(String text) {\n+        Integer month = iParseMonths.get(text);\n+        if (month != null) {\n+            return month.intValue();\n+        }\n+        throw new IllegalFieldValueException(DateTimeFieldType.monthOfYear(), text);\n+    }\n+\n+    public int getMonthMaxTextLength() {\n+        return iMaxMonthLength;\n+    }\n+\n+    public int getMonthMaxShortTextLength() {\n+        return iMaxShortMonthLength;\n+    }\n+\n+    public String dayOfWeekValueToText(int value) {\n+        return iDaysOfWeek[value];\n+    }\n+\n+    public String dayOfWeekValueToShortText(int value) {\n+        return iShortDaysOfWeek[value];\n+    }\n+\n+    public int dayOfWeekTextToValue(String text) {\n+        Integer day = iParseDaysOfWeek.get(text);\n+        if (day != null) {\n+            return day.intValue();\n+        }\n+        throw new IllegalFieldValueException(DateTimeFieldType.dayOfWeek(), text);\n+    }\n+\n+    public int getDayOfWeekMaxTextLength() {\n+        return iMaxDayOfWeekLength;\n+    }\n+\n+    public int getDayOfWeekMaxShortTextLength() {\n+        return iMaxShortDayOfWeekLength;\n+    }\n+\n+    public String halfdayValueToText(int value) {\n+        return iHalfday[value];\n+    }\n+\n+    public int halfdayTextToValue(String text) {\n+        String[] halfday = iHalfday;\n+        for (int i = halfday.length; --i>=0; ) {\n+            if (halfday[i].equalsIgnoreCase(text)) {\n+                return i;\n+            }\n+        }\n+        throw new IllegalFieldValueException(DateTimeFieldType.halfdayOfDay(), text);\n+    }\n+\n+    public int getHalfdayMaxTextLength() {\n+        return iMaxHalfdayLength;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Provides time calculations for the month of the year component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJMonthOfYearDateTimeField extends BasicMonthOfYearDateTimeField {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -4748157875845286249L;\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n+        super(chronology, 2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public String getAsText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(fieldValue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public String getAsShortText(int fieldValue, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(fieldValue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected int convertText(String text, Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getMaximumTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.DecoratedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Provides time calculations for the year of era component of time.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class GJYearOfEraDateTimeField extends DecoratedDateTimeField {\n+\n+    private static final long serialVersionUID = -5961050944769862059L;\n+\n+    private final BasicChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n+        super(yearField, DateTimeFieldType.yearOfEra());\n+        iChronology = chronology;\n+    }\n+\n+    public int get(long instant) {\n+        int year = getWrappedField().get(instant);\n+        if (year <= 0) {\n+            year = 1 - year;\n+        }\n+        return year;\n+    }\n+\n+    public long add(long instant, int years) {\n+        return getWrappedField().add(instant, years);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return getWrappedField().add(instant, years);\n+    }\n+\n+    public long addWrapField(long instant, int years) {\n+        return getWrappedField().addWrapField(instant, years);\n+    }\n+\n+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int years) {\n+        return getWrappedField().addWrapField(instant, fieldIndex, values, years);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Set the year component of the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param year  the year (0,292278994) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if year is invalid.\n+     */\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue());\n+        if (iChronology.getYear(instant) <= 0) {\n+            year = 1 - year;\n+        }\n+        return super.set(instant, year);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return getWrappedField().getMaximumValue();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.yearOfEra();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/GregorianChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Implements a pure proleptic Gregorian calendar system, which defines every\n+ * fourth year as leap, unless the year is divisible by 100 and not by 400.\n+ * This improves upon the Julian calendar leap year rule.\n+ * <p>\n+ * Although the Gregorian calendar did not exist before 1582 CE, this\n+ * chronology assumes it did, thus it is proleptic. This implementation also\n+ * fixes the start of the year at January 1, and defines the year zero.\n+ * <p>\n+ * GregorianChronology is thread-safe and immutable.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Gregorian_calendar\">Wikipedia</a>\n+ * @see JulianChronology\n+ * @see GJChronology\n+ * \n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class GregorianChronology extends BasicGJChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -861407383323710522L;\n+\n+    private static final long MILLIS_PER_YEAR =\n+        (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    private static final long MILLIS_PER_MONTH =\n+        (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY / 12);\n+\n+    private static final int DAYS_0000_TO_1970 = 719527;\n+\n+    /** The lowest year that can be fully supported. */\n+    private static final int MIN_YEAR = -292275054;\n+\n+    /** The highest year that can be fully supported. */\n+    private static final int MAX_YEAR = 292278993;\n+\n+    /** Singleton instance of a UTC GregorianChronology */\n+    private static final GregorianChronology INSTANCE_UTC;\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map<DateTimeZone, GregorianChronology[]> cCache = new HashMap<DateTimeZone, GregorianChronology[]>();\n+\n+    static {\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * Gets an instance of the GregorianChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static GregorianChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the GregorianChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static GregorianChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the GregorianChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static GregorianChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the GregorianChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     * @return a chronology in the specified time zone\n+     */\n+    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        GregorianChronology chrono;\n+        synchronized (cCache) {\n+            GregorianChronology[] chronos = cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new GregorianChronology[7];\n+                cCache.put(zone, chronos);\n+            }\n+            try {\n+                chrono = chronos[minDaysInFirstWeek - 1];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IllegalArgumentException\n+                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+            }\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n+                    chrono = new GregorianChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n+                }\n+                chronos[minDaysInFirstWeek - 1] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        Chronology base = getBase();\n+        int minDays = getMinimumDaysInFirstWeek();\n+        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology\n+        return base == null ?\n+                getInstance(DateTimeZone.UTC, minDays) :\n+                    getInstance(base.getZone(), minDays);\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+        }\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n+    }\n+\n+    long calculateFirstDayOfYearMillis(int year) {\n+        // Initial value is just temporary.\n+        int leapYears = year / 100;\n+        if (year < 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers. When the expression is written as\n+            // (year / 4) - (year / 100) + (year / 400),\n+            // it works for both positive and negative values, except this optimization\n+            // eliminates two divisions.\n+            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;\n+        } else {\n+            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n+            if (isLeapYear(year)) {\n+                leapYears--;\n+            }\n+        }\n+\n+        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    int getMinYear() {\n+        return MIN_YEAR;\n+    }\n+\n+    int getMaxYear() {\n+        return MAX_YEAR;\n+    }\n+\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    long getAverageMillisPerYearDividedByTwo() {\n+        return MILLIS_PER_YEAR / 2;\n+    }\n+\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        return (1970L * MILLIS_PER_YEAR) / 2;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/ISOChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.DividedDateTimeField;\n+import org.joda.time.field.RemainderDateTimeField;\n+\n+/**\n+ * Implements a chronology that follows the rules of the ISO8601 standard,\n+ * which is compatible with Gregorian for all modern dates.\n+ * When ISO does not define a field, but it can be determined (such as AM/PM)\n+ * it is included.\n+ * <p>\n+ * With the exception of century related fields, ISOChronology is exactly the\n+ * same as {@link GregorianChronology}. In this chronology, centuries and year\n+ * of century are zero based. For all years, the century is determined by\n+ * dropping the last two digits of the year, ignoring sign. The year of century\n+ * is the value of the last two year digits.\n+ * <p>\n+ * ISOChronology is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class ISOChronology extends AssembledChronology {\n+    \n+    /** Serialization lock */\n+    private static final long serialVersionUID = -6212696554273812441L;\n+\n+    /** Singleton instance of a UTC ISOChronology */\n+    private static final ISOChronology INSTANCE_UTC;\n+        \n+    private static final int FAST_CACHE_SIZE = 64;\n+\n+    /** Fast cache of zone to chronology */\n+    private static final ISOChronology[] cFastCache;\n+\n+    /** Cache of zone to chronology */\n+    private static final Map<DateTimeZone, ISOChronology> cCache = new HashMap<DateTimeZone, ISOChronology>();\n+    static {\n+        cFastCache = new ISOChronology[FAST_CACHE_SIZE];\n+        INSTANCE_UTC = new ISOChronology(GregorianChronology.getInstanceUTC());\n+        cCache.put(DateTimeZone.UTC, INSTANCE_UTC);\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static ISOChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static ISOChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault());\n+    }\n+\n+    /**\n+     * Gets an instance of the ISOChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static ISOChronology getInstance(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n+        ISOChronology chrono = cFastCache[index];\n+        if (chrono != null && chrono.getZone() == zone) {\n+            return chrono;\n+        }\n+        synchronized (cCache) {\n+            chrono = cCache.get(zone);\n+            if (chrono == null) {\n+                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n+                cCache.put(zone, chrono);\n+            }\n+        }\n+        cFastCache[index] = chrono;\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    private ISOChronology(Chronology base) {\n+        super(base, null);\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging toString.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        String str = \"ISOChronology\";\n+        DateTimeZone zone = getZone();\n+        if (zone != null) {\n+            str = str + '[' + zone.getID() + ']';\n+        }\n+        return str;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getBase().getZone() == DateTimeZone.UTC) {\n+            // Use zero based century and year of century.\n+            fields.centuryOfEra = new DividedDateTimeField(\n+                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n+            fields.yearOfCentury = new RemainderDateTimeField(\n+                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n+            fields.weekyearOfCentury = new RemainderDateTimeField(\n+                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());\n+\n+            fields.centuries = fields.centuryOfEra.getDurationField();\n+        }\n+    }\n+\n+    /**\n+     * Checks if this chronology instance equals another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.6\n+     */\n+    public boolean equals(Object obj) {\n+        return super.equals(obj);\n+    }\n+\n+    /**\n+     * A suitable hash code for the chronology.\n+     * \n+     * @return the hash code\n+     * @since 1.6\n+     */\n+    public int hashCode() {\n+        return \"ISO\".hashCode() * 11 + getZone().hashCode();\n+    }\n+\n+    /**\n+     * Serialize ISOChronology instances using a small stub. This reduces the\n+     * serialized size, and deserialized instances come from the cache.\n+     */\n+    private Object writeReplace() {\n+        return new Stub(getZone());\n+    }\n+\n+    private static final class Stub implements Serializable {\n+        private static final long serialVersionUID = -6212696554273812441L;\n+\n+        private transient DateTimeZone iZone;\n+\n+        Stub(DateTimeZone zone) {\n+            iZone = zone;\n+        }\n+\n+        private Object readResolve() {\n+            return ISOChronology.getInstance(iZone);\n+        }\n+\n+        private void writeObject(ObjectOutputStream out) throws IOException {\n+            out.writeObject(iZone);\n+        }\n+\n+        private void readObject(ObjectInputStream in)\n+            throws IOException, ClassNotFoundException\n+        {\n+            iZone = (DateTimeZone)in.readObject();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.DecoratedDateTimeField;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * This field is not publicy exposed by ISOChronology, but rather it is used to\n+ * build the yearOfCentury and centuryOfEra fields. It merely drops the sign of\n+ * the year.\n+ *\n+ * @author Brian S O'Neill\n+ * @see GJYearOfEraDateTimeField\n+ * @since 1.0\n+ */\n+class ISOYearOfEraDateTimeField extends DecoratedDateTimeField {\n+\n+    private static final long serialVersionUID = 7037524068969447317L;\n+\n+    /**\n+     * Singleton instance\n+     */\n+    static final DateTimeField INSTANCE = new ISOYearOfEraDateTimeField();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ISOYearOfEraDateTimeField() {\n+        super(GregorianChronology.getInstanceUTC().year(), DateTimeFieldType.yearOfEra());\n+    }\n+\n+    public int get(long instant) {\n+        int year = getWrappedField().get(instant);\n+        return year < 0 ? -year : year;\n+    }\n+\n+    public long add(long instant, int years) {\n+        return getWrappedField().add(instant, years);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return getWrappedField().add(instant, years);\n+    }\n+\n+    public long addWrapField(long instant, int years) {\n+        return getWrappedField().addWrapField(instant, years);\n+    }\n+\n+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int years) {\n+        return getWrappedField().addWrapField(instant, fieldIndex, values, years);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds(this, year, 0, getMaximumValue());\n+        if (getWrappedField().get(instant) < 0) {\n+            year = -year;\n+        }\n+        return super.set(instant, year);\n+    }\n+\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+\n+    public int getMaximumValue() {\n+        return getWrappedField().getMaximumValue();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/IslamicChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Implements the Islamic, or Hijri, calendar system using arithmetic rules.\n+ * <p>\n+ * This calendar is a lunar calendar with a shorter year than ISO.\n+ * Year 1 in the Islamic calendar began on July 16, 622 CE (Julian), thus\n+ * Islamic years do not begin at the same time as Julian years. This chronology\n+ * is not proleptic, as it does not allow dates before the first Islamic year.\n+ * <p>\n+ * There are two basic forms of the Islamic calendar, the tabular and the\n+ * observed. The observed form cannot easily be used by computers as it\n+ * relies on human observation of the new moon.\n+ * The tabular calendar, implemented here, is an arithmetical approximation\n+ * of the observed form that follows relatively simple rules.\n+ * <p>\n+ * The tabular form of the calendar defines 12 months of alternately\n+ * 30 and 29 days. The last month is extended to 30 days in a leap year.\n+ * Leap years occur according to a 30 year cycle. There are four recognised\n+ * patterns of leap years in the 30 year cycle:\n+ * <pre>\n+ * Years 2, 5, 7, 10, 13, 15, 18, 21, 24, 26 & 29 - 15-based, used by Microsoft\n+ * Years 2, 5, 7, 10, 13, 16, 18, 21, 24, 26 & 29 - 16-based, most commonly used\n+ * Years 2, 5, 8, 10, 13, 16, 19, 21, 24, 27 & 29 - Indian\n+ * Years 2, 5, 8, 11, 13, 16, 19, 21, 24, 27 & 30 - Habash al-Hasib\n+ * </pre>\n+ * You can select which pattern to use via the factory methods, or use the\n+ * default (16-based).\n+ * <p>\n+ * This implementation defines a day as midnight to midnight exactly as per\n+ * the ISO chronology. This correct start of day is at sunset on the previous\n+ * day, however this cannot readily be modelled and has been ignored.\n+ * <p>\n+ * IslamicChronology is thread-safe and immutable.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Islamic_calendar\">Wikipedia</a>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.2\n+ */\n+public final class IslamicChronology extends BasicChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -3663823829888L;\n+\n+    /**\n+     * Constant value for 'Anno Hegirae', equivalent\n+     * to the value returned for AD/CE.\n+     */\n+    public static final int AH = DateTimeConstants.CE;\n+\n+    /** A singleton era field. */\n+    private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"AH\");\n+\n+    /** Leap year 15-based pattern. */\n+    public static final LeapYearPatternType LEAP_YEAR_15_BASED = new LeapYearPatternType(0, 623158436);\n+    /** Leap year 16-based pattern. */\n+    public static final LeapYearPatternType LEAP_YEAR_16_BASED = new LeapYearPatternType(1, 623191204);\n+    /** Leap year Indian pattern. */\n+    public static final LeapYearPatternType LEAP_YEAR_INDIAN = new LeapYearPatternType(2, 690562340);\n+    /** Leap year Habash al-Hasib pattern. */\n+    public static final LeapYearPatternType LEAP_YEAR_HABASH_AL_HASIB = new LeapYearPatternType(3, 153692453);\n+\n+    /** The lowest year that can be fully supported. */\n+    private static final int MIN_YEAR = -292269337;\n+\n+    /**\n+     * The highest year that can be fully supported.\n+     * Although calculateFirstDayOfYearMillis can go higher without\n+     * overflowing, the getYear method overflows when it adds the\n+     * approximate millis at the epoch.\n+     */\n+    private static final int MAX_YEAR = 292271022;\n+\n+    /** The days in a pair of months. */\n+    private static final int MONTH_PAIR_LENGTH = 59;\n+\n+    /** The length of the long month. */\n+    private static final int LONG_MONTH_LENGTH = 30;\n+\n+    /** The length of the short month. */\n+    private static final int SHORT_MONTH_LENGTH = 29;\n+\n+    /** The length of the long month in millis. */\n+    private static final long MILLIS_PER_MONTH_PAIR = 59L * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** The length of the long month in millis. */\n+    private static final long MILLIS_PER_MONTH = (long) (29.53056 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** The length of the long month in millis. */\n+    private static final long MILLIS_PER_LONG_MONTH = 30L * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** The typical millis per year. */\n+    private static final long MILLIS_PER_YEAR = (long) (354.36667 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** The typical millis per year. */\n+    private static final long MILLIS_PER_SHORT_YEAR = 354L * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** The typical millis per year. */\n+    private static final long MILLIS_PER_LONG_YEAR = 355L * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** The millis of 0001-01-01. */\n+    private static final long MILLIS_YEAR_1 = -42521587200000L;\n+                                    //        -42520809600000L;\n+//    long start = 0L - 278L * DateTimeConstants.MILLIS_PER_DAY;\n+//    long cy = 46L * MILLIS_PER_CYCLE;  // 1381-01-01\n+//    long rem = 5L * MILLIS_PER_SHORT_YEAR +\n+//            3L * MILLIS_PER_LONG_YEAR;  // 1389-01-01\n+\n+    /** The length of the cycle of leap years. */\n+    private static final int CYCLE = 30;\n+\n+    /** The millis of a 30 year cycle. */\n+    private static final long MILLIS_PER_CYCLE = ((19L * 354L + 11L * 355L) * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map<DateTimeZone, IslamicChronology[]> cCache = new HashMap<DateTimeZone, IslamicChronology[]>();\n+\n+    /** Singleton instance of a UTC IslamicChronology */\n+    private static final IslamicChronology INSTANCE_UTC;\n+    static {\n+        // init after static fields\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    /** The leap years to use. */\n+    private final LeapYearPatternType iLeapYears;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an instance of the IslamicChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static IslamicChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the IslamicChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static IslamicChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), LEAP_YEAR_16_BASED);\n+    }\n+\n+    /**\n+     * Gets an instance of the IslamicChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static IslamicChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, LEAP_YEAR_16_BASED);\n+    }\n+\n+    /**\n+     * Gets an instance of the IslamicChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param leapYears  the type defining the leap year pattern\n+     * @return a chronology in the specified time zone\n+     */\n+    public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        IslamicChronology chrono;\n+        synchronized (cCache) {\n+            IslamicChronology[] chronos = cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new IslamicChronology[4];\n+                cCache.put(zone, chronos);\n+            }\n+            chrono = chronos[leapYears.index];\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    // First create without a lower limit.\n+                    chrono = new IslamicChronology(null, null, leapYears);\n+                    // Impose lower limit and make another IslamicChronology.\n+                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+                    chrono = new IslamicChronology(\n+                        LimitChronology.getInstance(chrono, lowerLimit, null),\n+                         null, leapYears);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, leapYears);\n+                    chrono = new IslamicChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, leapYears);\n+                }\n+                chronos[leapYears.index] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     */\n+    IslamicChronology(Chronology base, Object param, LeapYearPatternType leapYears) {\n+        super(base, param, 4);\n+        this.iLeapYears = leapYears;\n+    }\n+\n+    /**\n+     * Serialization singleton.\n+     */\n+    private Object readResolve() {\n+        Chronology base = getBase();\n+        return base == null ? getInstanceUTC() : getInstance(base.getZone());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the leap year pattern type.\n+     *\n+     * @return the pattern type\n+     */\n+    public LeapYearPatternType getLeapYearPatternType() {\n+        return iLeapYears;\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    /**\n+     * A suitable hash code for the chronology.\n+     * \n+     * @return the hash code\n+     * @since 1.6\n+     */\n+    public int hashCode() {\n+        return super.hashCode() * 13 + getLeapYearPatternType().hashCode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getYear(long instant) {\n+        long millisIslamic = instant - MILLIS_YEAR_1;\n+        long cycles = millisIslamic / MILLIS_PER_CYCLE;\n+        long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE;\n+        \n+        int year = (int) ((cycles * CYCLE) + 1L);\n+        long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n+        while (cycleRemainder >= yearMillis) {\n+            cycleRemainder -= yearMillis;\n+            yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n+        }\n+        return year;\n+    }\n+\n+    long setYear(long instant, int year) {\n+        // optimsed implementation of set, due to fixed months\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > 354) {\n+            // Current year is leap, and day is leap.\n+            if (!isLeapYear(year)) {\n+                // Moving to a non-leap year, leap day doesn't exist.\n+                dayOfYear--;\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        // optimsed implementation of getDifference, due to fixed months\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        if (--month % 2 == 1) {\n+            month /= 2;\n+            return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH;\n+        } else {\n+            month /= 2;\n+            return month * MILLIS_PER_MONTH_PAIR;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDayOfMonth(long millis) {\n+        // optimised for simple months\n+        int doy = getDayOfYear(millis) - 1;\n+        if (doy == 354) {\n+            return 30;\n+        }\n+        return (doy % MONTH_PAIR_LENGTH) % LONG_MONTH_LENGTH + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    boolean isLeapYear(int year) {\n+        return iLeapYears.isLeapYear(year);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYearMax() {\n+        return 355;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYear(int year) {\n+        return isLeapYear(year) ? 355 : 354;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYearMonth(int year, int month) {\n+        if (month == 12 && isLeapYear(year)) {\n+            return LONG_MONTH_LENGTH;\n+        }\n+        return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax() {\n+        return LONG_MONTH_LENGTH;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        if (month == 12) {\n+            return LONG_MONTH_LENGTH;\n+        }\n+        return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        int doyZeroBased = (int) ((millis - getYearMillis(year)) / DateTimeConstants.MILLIS_PER_DAY);\n+        if (doyZeroBased == 354) {\n+            return 12;\n+        }\n+        return ((doyZeroBased * 2) / MONTH_PAIR_LENGTH) + 1;\n+//        return (int) (doyZeroBased / 29.9f) + 1;\n+//        \n+//        int monthPairZeroBased = doyZeroBased / MONTH_PAIR_LENGTH;\n+//        int monthPairRemainder = doyZeroBased % MONTH_PAIR_LENGTH;\n+//        return (monthPairZeroBased * 2) + 1 + (monthPairRemainder >= LONG_MONTH_LENGTH ? 1 : 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerYearDividedByTwo() {\n+        return MILLIS_PER_YEAR / 2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long calculateFirstDayOfYearMillis(int year) {\n+        if (year > MAX_YEAR) {\n+            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n+        }\n+        if (year < MIN_YEAR) {\n+            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n+        }\n+\n+        // Java epoch is 1970-01-01 Gregorian which is 0622-07-16 Islamic.\n+        // 0001-01-01 Islamic is -42520809600000L\n+        // would prefer to calculate against year zero, but leap year\n+        // can be in that year so it doesn't work\n+        year--;\n+        long cycle = year / CYCLE;\n+        long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE;\n+        int cycleRemainder = (year % CYCLE) + 1;\n+        \n+        for (int i = 1; i < cycleRemainder; i++) {\n+            millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n+        }\n+        \n+        return millis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMinYear() {\n+        return 1; //MIN_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMaxYear() {\n+        return MAX_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        // Epoch 1970-01-01 ISO = 1389-10-22 Islamic\n+        return (-MILLIS_YEAR_1) / 2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+\n+            fields.era = ERA_FIELD;\n+            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 12);\n+            fields.months = fields.monthOfYear.getDurationField();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Opaque object describing a leap year pattern for the Islamic Chronology.\n+     *\n+     * @since 1.2\n+     */\n+    public static class LeapYearPatternType implements Serializable {\n+        /** Serialization lock */\n+        private static final long serialVersionUID = 26581275372698L;\n+//        /** Leap year raw data encoded into bits. */\n+//        private static final int[][] LEAP_YEARS = {\n+//            {2, 5, 7, 10, 13, 15, 18, 21, 24, 26, 29},  // 623158436\n+//            {2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29},  // 623191204\n+//            {2, 5, 8, 10, 13, 16, 19, 21, 24, 27, 29},  // 690562340\n+//            {0, 2, 5, 8, 11, 13, 16, 19, 21, 24, 27},   // 153692453\n+//        };\n+        \n+        /** The index. */\n+        final byte index;\n+        /** The leap year pattern, a bit-based 1=true pattern. */\n+        final int pattern;\n+        \n+        /**\n+         * Constructor.\n+         * This constructor takes a bit pattern where bits 0-29 correspond\n+         * to years 0-29 in the 30 year Islamic cycle of years. This allows\n+         * a highly efficient lookup by bit-matching.\n+         *\n+         * @param index  the index\n+         * @param pattern  the bit pattern\n+         */\n+        LeapYearPatternType(int index, int pattern) {\n+            super();\n+            this.index = (byte) index;\n+            this.pattern = pattern;\n+        }\n+        \n+        /**\n+         * Is the year a leap year.\n+         * @param year  the year to query\n+         * @return true if leap\n+         */\n+        boolean isLeapYear(int year) {\n+            int key = 1 << (year % 30);\n+            return ((pattern & key) > 0);\n+        }\n+        \n+        /**\n+         * Ensure a singleton is returned if possible.\n+         * @return the singleton instance\n+         */\n+        private Object readResolve() {\n+            switch (index) {\n+                case 0:\n+                    return LEAP_YEAR_15_BASED;\n+                case 1:\n+                    return LEAP_YEAR_16_BASED;\n+                case 2:\n+                    return LEAP_YEAR_INDIAN;\n+                case 3:\n+                    return LEAP_YEAR_HABASH_AL_HASIB;\n+                default:\n+                    return this;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/JulianChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.field.SkipDateTimeField;\n+\n+/**\n+ * Implements a pure proleptic Julian calendar system, which defines every\n+ * fourth year as leap. This implementation follows the leap year rule\n+ * strictly, even for dates before 8 CE, where leap years were actually\n+ * irregular. In the Julian calendar, year zero does not exist: 1 BCE is\n+ * followed by 1 CE.\n+ * <p>\n+ * Although the Julian calendar did not exist before 45 BCE, this chronology\n+ * assumes it did, thus it is proleptic. This implementation also fixes the\n+ * start of the year at January 1.\n+ * <p>\n+ * JulianChronology is thread-safe and immutable.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Julian_calendar\">Wikipedia</a>\n+ * @see GregorianChronology\n+ * @see GJChronology\n+ *\n+ * @author Guy Allard\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class JulianChronology extends BasicGJChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -8731039522547897247L;\n+\n+    private static final long MILLIS_PER_YEAR =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    private static final long MILLIS_PER_MONTH =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n+\n+    /** The lowest year that can be fully supported. */\n+    private static final int MIN_YEAR = -292269054;\n+\n+    /** The highest year that can be fully supported. */\n+    private static final int MAX_YEAR = 292272992;\n+\n+    /** Singleton instance of a UTC JulianChronology */\n+    private static final JulianChronology INSTANCE_UTC;\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map<DateTimeZone, JulianChronology[]> cCache = new HashMap<DateTimeZone, JulianChronology[]>();\n+\n+    static {\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    static int adjustYearForSet(int year) {\n+        if (year <= 0) {\n+            if (year == 0) {\n+                throw new IllegalFieldValueException\n+                    (DateTimeFieldType.year(), new Integer(year), null, null);\n+            }\n+            year++;\n+        }\n+        return year;\n+    }\n+\n+    /**\n+     * Gets an instance of the JulianChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static JulianChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the JulianChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static JulianChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the JulianChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static JulianChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the JulianChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     * @return a chronology in the specified time zone\n+     */\n+    public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        JulianChronology chrono;\n+        synchronized (cCache) {\n+            JulianChronology[] chronos = cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new JulianChronology[7];\n+                cCache.put(zone, chronos);\n+            }\n+            try {\n+                chrono = chronos[minDaysInFirstWeek - 1];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IllegalArgumentException\n+                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+            }\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n+                    chrono = new JulianChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n+                }\n+                chronos[minDaysInFirstWeek - 1] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Restricted constructor\n+     */\n+    JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        Chronology base = getBase();\n+        int minDays = getMinimumDaysInFirstWeek();\n+        minDays = (minDays == 0 ? 4 : minDays);  // handle rename of BaseGJChronology\n+        return base == null ?\n+                getInstance(DateTimeZone.UTC, minDays) :\n+                    getInstance(base.getZone(), minDays);\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n+        throws IllegalArgumentException\n+    {\n+        return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);\n+    }\n+\n+    boolean isLeapYear(int year) {\n+        return (year & 3) == 0;\n+    }\n+\n+    long calculateFirstDayOfYearMillis(int year) {\n+        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.\n+        // Calculate relative to the nearest leap year and account for the\n+        // difference later.\n+\n+        int relativeYear = year - 1968;\n+        int leapYears;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers.\n+            leapYears = (relativeYear + 3) >> 2;\n+        } else {\n+            leapYears = relativeYear >> 2;\n+            // For post 1968 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears) * (long)DateTimeConstants.MILLIS_PER_DAY;\n+\n+        // Adjust to account for difference between 1968-01-01 and 1969-12-19.\n+\n+        return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    int getMinYear() {\n+        return MIN_YEAR;\n+    }\n+\n+    int getMaxYear() {\n+        return MAX_YEAR;\n+    }\n+\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    long getAverageMillisPerYearDividedByTwo() {\n+        return MILLIS_PER_YEAR / 2;\n+    }\n+\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+    long getApproxMillisAtEpochDividedByTwo() {\n+        return (1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY) / 2;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+            // Julian chronology has no year zero.\n+            fields.year = new SkipDateTimeField(this, fields.year);\n+            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/LenientChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.LenientDateTimeField;\n+\n+/**\n+ * Wraps another Chronology, ensuring all the fields are lenient.\n+ * <p>\n+ * LenientChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see LenientDateTimeField\n+ * @see StrictChronology\n+ */\n+public final class LenientChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -3148237568046877177L;\n+\n+    /**\n+     * Create a LenientChronology for any chronology.\n+     *\n+     * @param base the chronology to wrap\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    public static LenientChronology getInstance(Chronology base) {\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+        return new LenientChronology(base);\n+    }\n+\n+    private transient Chronology iWithUTC;\n+\n+    /**\n+     * Create a LenientChronology for any chronology.\n+     *\n+     * @param base the chronology to wrap\n+     */\n+    private LenientChronology(Chronology base) {\n+        super(base, null);\n+    }\n+\n+    public Chronology withUTC() {\n+        if (iWithUTC == null) {\n+            if (getZone() == DateTimeZone.UTC) {\n+                iWithUTC = this;\n+            } else {\n+                iWithUTC = LenientChronology.getInstance(getBase().withUTC());\n+            }\n+        }\n+        return iWithUTC;\n+    }\n+\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == DateTimeZone.UTC) {\n+            return withUTC();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return LenientChronology.getInstance(getBase().withZone(zone));\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        fields.year = convertField(fields.year);\n+        fields.yearOfEra = convertField(fields.yearOfEra);\n+        fields.yearOfCentury = convertField(fields.yearOfCentury);\n+        fields.centuryOfEra = convertField(fields.centuryOfEra);\n+        fields.era = convertField(fields.era);\n+        fields.dayOfWeek = convertField(fields.dayOfWeek);\n+        fields.dayOfMonth = convertField(fields.dayOfMonth);\n+        fields.dayOfYear = convertField(fields.dayOfYear);\n+        fields.monthOfYear = convertField(fields.monthOfYear);\n+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);\n+        fields.weekyear = convertField(fields.weekyear);\n+        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury);\n+\n+        fields.millisOfSecond = convertField(fields.millisOfSecond);\n+        fields.millisOfDay = convertField(fields.millisOfDay);\n+        fields.secondOfMinute = convertField(fields.secondOfMinute);\n+        fields.secondOfDay = convertField(fields.secondOfDay);\n+        fields.minuteOfHour = convertField(fields.minuteOfHour);\n+        fields.minuteOfDay = convertField(fields.minuteOfDay);\n+        fields.hourOfDay = convertField(fields.hourOfDay);\n+        fields.hourOfHalfday = convertField(fields.hourOfHalfday);\n+        fields.clockhourOfDay = convertField(fields.clockhourOfDay);\n+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);\n+        fields.halfdayOfDay = convertField(fields.halfdayOfDay);\n+    }\n+\n+    private final DateTimeField convertField(DateTimeField field) {\n+        return LenientDateTimeField.getInstance(field, getBase());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A lenient chronology is only equal to a lenient chronology with the\n+     * same base chronology.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof LenientChronology == false) {\n+            return false;\n+        }\n+        LenientChronology chrono = (LenientChronology) obj;\n+        return getBase().equals(chrono.getBase());\n+    }\n+\n+    /**\n+     * A suitable hashcode for the chronology.\n+     * \n+     * @return the hashcode\n+     * @since 1.4\n+     */\n+    public int hashCode() {\n+        return 236548278 + getBase().hashCode() * 7;\n+    }\n+\n+    /**\n+     * A debugging string for the chronology.\n+     * \n+     * @return the debugging string\n+     */\n+    public String toString() {\n+        return \"LenientChronology[\" + getBase().toString() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/LimitChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadableDateTime;\n+import org.joda.time.field.DecoratedDateTimeField;\n+import org.joda.time.field.DecoratedDurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Wraps another Chronology to impose limits on the range of instants that\n+ * the fields within a Chronology may support. The limits are applied to both\n+ * DateTimeFields and DurationFields.\n+ * <p>\n+ * Methods in DateTimeField and DurationField throw an IllegalArgumentException\n+ * whenever given an input instant that is outside the limits or when an\n+ * attempt is made to move an instant outside the limits.\n+ * <p>\n+ * LimitChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class LimitChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 7670866536893052522L;\n+\n+    /**\n+     * Wraps another chronology, with datetime limits. When withUTC or\n+     * withZone is called, the returned LimitChronology instance has\n+     * the same limits, except they are time zone adjusted.\n+     *\n+     * @param base  base chronology to wrap\n+     * @param lowerLimit  inclusive lower limit, or null if none\n+     * @param upperLimit  exclusive upper limit, or null if none\n+     * @throws IllegalArgumentException if chronology is null or limits are invalid\n+     */\n+    public static LimitChronology getInstance(Chronology base,\n+                                              ReadableDateTime lowerLimit,\n+                                              ReadableDateTime upperLimit) {\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+\n+        lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\n+        upperLimit = upperLimit == null ? null : upperLimit.toDateTime();\n+\n+        if (lowerLimit != null && upperLimit != null) {\n+            if (!lowerLimit.isBefore(upperLimit)) {\n+                throw new IllegalArgumentException\n+                    (\"The lower limit must be come before than the upper limit\");\n+            }\n+        }\n+\n+        return new LimitChronology(base, (DateTime)lowerLimit, (DateTime)upperLimit);\n+    }\n+\n+    final DateTime iLowerLimit;\n+    final DateTime iUpperLimit;\n+\n+    private transient LimitChronology iWithUTC;\n+\n+    /**\n+     * Wraps another chronology, with datetime limits. When withUTC or\n+     * withZone is called, the returned LimitChronology instance has\n+     * the same limits, except they are time zone adjusted.\n+     *\n+     * @param lowerLimit  inclusive lower limit, or null if none\n+     * @param upperLimit  exclusive upper limit, or null if none\n+     */\n+    private LimitChronology(Chronology base,\n+                            DateTime lowerLimit, DateTime upperLimit) {\n+        super(base, null);\n+        // These can be set after assembly.\n+        iLowerLimit = lowerLimit;\n+        iUpperLimit = upperLimit;\n+    }\n+\n+    /**\n+     * Returns the inclusive lower limit instant.\n+     * \n+     * @return lower limit\n+     */\n+    public DateTime getLowerLimit() {\n+        return iLowerLimit;\n+    }\n+\n+    /**\n+     * Returns the inclusive upper limit instant.\n+     * \n+     * @return upper limit\n+     */\n+    public DateTime getUpperLimit() {\n+        return iUpperLimit;\n+    }\n+\n+    /**\n+     * If this LimitChronology is already UTC, then this is\n+     * returned. Otherwise, a new instance is returned, with the limits\n+     * adjusted to the new time zone.\n+     */\n+    public Chronology withUTC() {\n+        return withZone(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * If this LimitChronology has the same time zone as the one given, then\n+     * this is returned. Otherwise, a new instance is returned, with the limits\n+     * adjusted to the new time zone.\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+\n+        if (zone == DateTimeZone.UTC && iWithUTC != null) {\n+            return iWithUTC;\n+        }\n+\n+        DateTime lowerLimit = iLowerLimit;\n+        if (lowerLimit != null) {\n+            MutableDateTime mdt = lowerLimit.toMutableDateTime();\n+            mdt.setZoneRetainFields(zone);\n+            lowerLimit = mdt.toDateTime();\n+        }\n+\n+        DateTime upperLimit = iUpperLimit;\n+        if (upperLimit != null) {\n+            MutableDateTime mdt = upperLimit.toMutableDateTime();\n+            mdt.setZoneRetainFields(zone);\n+            upperLimit = mdt.toDateTime();\n+        }\n+        \n+        LimitChronology chrono = getInstance\n+            (getBase().withZone(zone), lowerLimit, upperLimit);\n+\n+        if (zone == DateTimeZone.UTC) {\n+            iWithUTC = chrono;\n+        }\n+\n+        return chrono;\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        long instant = getBase().getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        checkLimits(instant, null);\n+        instant = getBase().getDateTimeMillis\n+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        checkLimits(instant, \"resulting\");\n+        return instant;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        // Keep a local cache of converted fields so as not to create redundant\n+        // objects.\n+        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n+\n+        // Convert duration fields...\n+\n+        fields.eras = convertField(fields.eras, converted);\n+        fields.centuries = convertField(fields.centuries, converted);\n+        fields.years = convertField(fields.years, converted);\n+        fields.months = convertField(fields.months, converted);\n+        fields.weekyears = convertField(fields.weekyears, converted);\n+        fields.weeks = convertField(fields.weeks, converted);\n+        fields.days = convertField(fields.days, converted);\n+\n+        fields.halfdays = convertField(fields.halfdays, converted);\n+        fields.hours = convertField(fields.hours, converted);\n+        fields.minutes = convertField(fields.minutes, converted);\n+        fields.seconds = convertField(fields.seconds, converted);\n+        fields.millis = convertField(fields.millis, converted);\n+\n+        // Convert datetime fields...\n+\n+        fields.year = convertField(fields.year, converted);\n+        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n+        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n+        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n+        fields.era = convertField(fields.era, converted);\n+        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n+        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n+        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n+        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n+        fields.weekyear = convertField(fields.weekyear, converted);\n+        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n+\n+        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n+        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n+        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n+        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n+        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n+        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n+        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n+        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n+        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n+        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n+    }\n+\n+    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DurationField)converted.get(field);\n+        }\n+        LimitDurationField limitField = new LimitDurationField(field);\n+        converted.put(field, limitField);\n+        return limitField;\n+    }\n+\n+    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DateTimeField)converted.get(field);\n+        }\n+        LimitDateTimeField limitField =\n+            new LimitDateTimeField(field,\n+                                   convertField(field.getDurationField(), converted),\n+                                   convertField(field.getRangeDurationField(), converted),\n+                                   convertField(field.getLeapDurationField(), converted));\n+        converted.put(field, limitField);\n+        return limitField;\n+    }\n+\n+    void checkLimits(long instant, String desc) {\n+        DateTime limit;\n+        if ((limit = iLowerLimit) != null && instant < limit.getMillis()) {\n+            throw new LimitException(desc, true);\n+        }\n+        if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) {\n+            throw new LimitException(desc, false);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A limit chronology is only equal to a limit chronology with the\n+     * same base chronology and limits.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof LimitChronology == false) {\n+            return false;\n+        }\n+        LimitChronology chrono = (LimitChronology) obj;\n+        return\n+            getBase().equals(chrono.getBase()) &&\n+            FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) &&\n+            FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit());\n+    }\n+\n+    /**\n+     * A suitable hashcode for the chronology.\n+     * \n+     * @return the hashcode\n+     * @since 1.4\n+     */\n+    public int hashCode() {\n+        int hash = 317351877;\n+        hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0);\n+        hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0);\n+        hash += getBase().hashCode() * 7;\n+        return hash;\n+    }\n+\n+    /**\n+     * A debugging string for the chronology.\n+     * \n+     * @return the debugging string\n+     */\n+    public String toString() {\n+        return \"LimitChronology[\" + getBase().toString() + \", \" +\n+            (getLowerLimit() == null ? \"NoLimit\" : getLowerLimit().toString()) + \", \" +\n+            (getUpperLimit() == null ? \"NoLimit\" : getUpperLimit().toString()) + ']';\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extends IllegalArgumentException such that the exception message is not\n+     * generated unless it is actually requested.\n+     */\n+    private class LimitException extends IllegalArgumentException {\n+        private static final long serialVersionUID = -5924689995607498581L;\n+\n+        private final boolean iIsLow;\n+\n+        LimitException(String desc, boolean isLow) {\n+            super(desc);\n+            iIsLow = isLow;\n+        }\n+\n+        public String getMessage() {\n+            StringBuffer buf = new StringBuffer(85);\n+            buf.append(\"The\");\n+            String desc = super.getMessage();\n+            if (desc != null) {\n+                buf.append(' ');\n+                buf.append(desc);\n+            }\n+            buf.append(\" instant is \");\n+\n+            DateTimeFormatter p = ISODateTimeFormat.dateTime();\n+            p = p.withChronology(getBase());\n+            if (iIsLow) {\n+                buf.append(\"below the supported minimum of \");\n+                p.printTo(buf, getLowerLimit().getMillis());\n+            } else {\n+                buf.append(\"above the supported maximum of \");\n+                p.printTo(buf, getUpperLimit().getMillis());\n+            }\n+            \n+            buf.append(\" (\");\n+            buf.append(getBase());\n+            buf.append(')');\n+\n+            return buf.toString();\n+        }\n+\n+        public String toString() {\n+            return \"IllegalArgumentException: \" + getMessage();\n+        }\n+    }\n+\n+    private class LimitDurationField extends DecoratedDurationField {\n+        private static final long serialVersionUID = 8049297699408782284L;\n+\n+        LimitDurationField(DurationField field) {\n+            super(field, field.getType());\n+        }\n+\n+        public int getValue(long duration, long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getValue(duration, instant);\n+        }\n+\n+        public long getValueAsLong(long duration, long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getValueAsLong(duration, instant);\n+        }\n+\n+        public long getMillis(int value, long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getMillis(value, instant);\n+        }\n+\n+        public long getMillis(long value, long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getMillis(value, instant);\n+        }\n+\n+        public long add(long instant, int amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().add(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public long add(long instant, long amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().add(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            checkLimits(minuendInstant, \"minuend\");\n+            checkLimits(subtrahendInstant, \"subtrahend\");\n+            return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            checkLimits(minuendInstant, \"minuend\");\n+            checkLimits(subtrahendInstant, \"subtrahend\");\n+            return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+\n+    }\n+\n+    private class LimitDateTimeField extends DecoratedDateTimeField {\n+        private static final long serialVersionUID = -2435306746995699312L;\n+\n+        private final DurationField iDurationField;\n+        private final DurationField iRangeDurationField;\n+        private final DurationField iLeapDurationField;\n+\n+        LimitDateTimeField(DateTimeField field,\n+                           DurationField durationField,\n+                           DurationField rangeDurationField,\n+                           DurationField leapDurationField) {\n+            super(field, field.getType());\n+            iDurationField = durationField;\n+            iRangeDurationField = rangeDurationField;\n+            iLeapDurationField = leapDurationField;\n+        }\n+\n+        public int get(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().get(instant);\n+        }\n+        \n+        public String getAsText(long instant, Locale locale) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getAsText(instant, locale);\n+        }\n+        \n+        public String getAsShortText(long instant, Locale locale) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getAsShortText(instant, locale);\n+        }\n+        \n+        public long add(long instant, int amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().add(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public long add(long instant, long amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().add(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public long addWrapField(long instant, int amount) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().addWrapField(instant, amount);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            checkLimits(minuendInstant, \"minuend\");\n+            checkLimits(subtrahendInstant, \"subtrahend\");\n+            return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+        }\n+        \n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            checkLimits(minuendInstant, \"minuend\");\n+            checkLimits(subtrahendInstant, \"subtrahend\");\n+            return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+        \n+        public long set(long instant, int value) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().set(instant, value);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long set(long instant, String text, Locale locale) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().set(instant, text, locale);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public final DurationField getDurationField() {\n+            return iDurationField;\n+        }\n+\n+        public final DurationField getRangeDurationField() {\n+            return iRangeDurationField;\n+        }\n+\n+        public boolean isLeap(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().isLeap(instant);\n+        }\n+        \n+        public int getLeapAmount(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getLeapAmount(instant);\n+        }\n+        \n+        public final DurationField getLeapDurationField() {\n+            return iLeapDurationField;\n+        }\n+        \n+        public long roundFloor(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundFloor(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long roundCeiling(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundCeiling(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long roundHalfFloor(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundHalfFloor(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long roundHalfCeiling(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundHalfCeiling(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long roundHalfEven(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().roundHalfEven(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+        \n+        public long remainder(long instant) {\n+            checkLimits(instant, null);\n+            long result = getWrappedField().remainder(instant);\n+            checkLimits(result, \"resulting\");\n+            return result;\n+        }\n+\n+        public int getMinimumValue(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getMinimumValue(instant);\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            checkLimits(instant, null);\n+            return getWrappedField().getMaximumValue(instant);\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return getWrappedField().getMaximumTextLength(locale);\n+        }\n+\n+        public int getMaximumShortTextLength(Locale locale) {\n+            return getWrappedField().getMaximumShortTextLength(locale);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/StrictChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.StrictDateTimeField;\n+\n+/**\n+ * Wraps another Chronology, ensuring all the fields are strict.\n+ * <p>\n+ * StrictChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see StrictDateTimeField\n+ * @see LenientChronology\n+ */\n+public final class StrictChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 6633006628097111960L;\n+\n+    /**\n+     * Create a StrictChronology for any chronology.\n+     *\n+     * @param base the chronology to wrap\n+     * @throws IllegalArgumentException if chronology is null\n+     */\n+    public static StrictChronology getInstance(Chronology base) {\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+        return new StrictChronology(base);\n+    }\n+\n+    private transient Chronology iWithUTC;\n+\n+    /**\n+     * Create a StrictChronology for any chronology.\n+     *\n+     * @param base the chronology to wrap\n+     */\n+    private StrictChronology(Chronology base) {\n+        super(base, null);\n+    }\n+\n+    public Chronology withUTC() {\n+        if (iWithUTC == null) {\n+            if (getZone() == DateTimeZone.UTC) {\n+                iWithUTC = this;\n+            } else {\n+                iWithUTC = StrictChronology.getInstance(getBase().withUTC());\n+            }\n+        }\n+        return iWithUTC;\n+    }\n+\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == DateTimeZone.UTC) {\n+            return withUTC();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return StrictChronology.getInstance(getBase().withZone(zone));\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        fields.year = convertField(fields.year);\n+        fields.yearOfEra = convertField(fields.yearOfEra);\n+        fields.yearOfCentury = convertField(fields.yearOfCentury);\n+        fields.centuryOfEra = convertField(fields.centuryOfEra);\n+        fields.era = convertField(fields.era);\n+        fields.dayOfWeek = convertField(fields.dayOfWeek);\n+        fields.dayOfMonth = convertField(fields.dayOfMonth);\n+        fields.dayOfYear = convertField(fields.dayOfYear);\n+        fields.monthOfYear = convertField(fields.monthOfYear);\n+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);\n+        fields.weekyear = convertField(fields.weekyear);\n+        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury);\n+\n+        fields.millisOfSecond = convertField(fields.millisOfSecond);\n+        fields.millisOfDay = convertField(fields.millisOfDay);\n+        fields.secondOfMinute = convertField(fields.secondOfMinute);\n+        fields.secondOfDay = convertField(fields.secondOfDay);\n+        fields.minuteOfHour = convertField(fields.minuteOfHour);\n+        fields.minuteOfDay = convertField(fields.minuteOfDay);\n+        fields.hourOfDay = convertField(fields.hourOfDay);\n+        fields.hourOfHalfday = convertField(fields.hourOfHalfday);\n+        fields.clockhourOfDay = convertField(fields.clockhourOfDay);\n+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);\n+        fields.halfdayOfDay = convertField(fields.halfdayOfDay);\n+    }\n+\n+    private static final DateTimeField convertField(DateTimeField field) {\n+        return StrictDateTimeField.getInstance(field);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A strict chronology is only equal to a strict chronology with the\n+     * same base chronology.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof StrictChronology == false) {\n+            return false;\n+        }\n+        StrictChronology chrono = (StrictChronology) obj;\n+        return getBase().equals(chrono.getBase());\n+    }\n+\n+    /**\n+     * A suitable hashcode for the chronology.\n+     * \n+     * @return the hashcode\n+     * @since 1.4\n+     */\n+    public int hashCode() {\n+        return 352831696 + getBase().hashCode() * 7;\n+    }\n+\n+    /**\n+     * A debugging string for the chronology.\n+     * \n+     * @return the debugging string\n+     */\n+    public String toString() {\n+        return \"StrictChronology[\" + getBase().toString() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.Instant;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.BaseDateTimeField;\n+import org.joda.time.field.BaseDurationField;\n+import org.joda.time.format.DateTimeFormat;\n+\n+/**\n+ * Wraps another Chronology to add support for time zones.\n+ * <p>\n+ * ZonedChronology is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class ZonedChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -1079258847191166848L;\n+\n+    /**\n+     * Create a ZonedChronology for any chronology, overriding any time zone it\n+     * may already have.\n+     *\n+     * @param base base chronology to wrap\n+     * @param zone the time zone\n+     * @throws IllegalArgumentException if chronology or time zone is null\n+     */\n+    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"Must supply a chronology\");\n+        }\n+        base = base.withUTC();\n+        if (base == null) {\n+            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n+        }\n+        if (zone == null) {\n+            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n+        }\n+        return new ZonedChronology(base, zone);\n+    }\n+\n+    static boolean useTimeArithmetic(DurationField field) {\n+        // Use time of day arithmetic rules for unit durations less than\n+        // typical time zone offsets.\n+        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n+    }\n+\n+    /**\n+     * Restricted constructor\n+     *\n+     * @param base base chronology to wrap\n+     * @param zone the time zone\n+     */\n+    private ZonedChronology(Chronology base, DateTimeZone zone) {\n+        super(base, zone);\n+    }\n+\n+    public DateTimeZone getZone() {\n+        return (DateTimeZone)getParam();\n+    }\n+\n+    public Chronology withUTC() {\n+        return getBase();\n+    }\n+\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getParam()) {\n+            return this;\n+        }\n+        if (zone == DateTimeZone.UTC) {\n+            return getBase();\n+        }\n+        return new ZonedChronology(getBase(), zone);\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int millisOfDay)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getDateTimeMillis\n+                          (year, monthOfYear, dayOfMonth, millisOfDay));\n+    }\n+\n+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getDateTimeMillis\n+                          (year, monthOfYear, dayOfMonth, \n+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    public long getDateTimeMillis(long instant,\n+                                  int hourOfDay, int minuteOfHour,\n+                                  int secondOfMinute, int millisOfSecond)\n+        throws IllegalArgumentException\n+    {\n+        return localToUTC(getBase().getDateTimeMillis\n+                          (instant + getZone().getOffset(instant),\n+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    /**\n+     * @param instant instant from 1970-01-01T00:00:00 local time\n+     * @return instant from 1970-01-01T00:00:00Z\n+     */\n+    private long localToUTC(long instant) {\n+        DateTimeZone zone = getZone();\n+        int offset = zone.getOffsetFromLocal(instant);\n+        instant -= offset;\n+        if (offset != zone.getOffset(instant)) {\n+            throw new IllegalArgumentException\n+                (\"Illegal instant due to time zone offset transition: \" +\n+                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n+        }\n+        return instant;\n+    }\n+\n+    protected void assemble(Fields fields) {\n+        // Keep a local cache of converted fields so as not to create redundant\n+        // objects.\n+        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n+\n+        // Convert duration fields...\n+\n+        fields.eras = convertField(fields.eras, converted);\n+        fields.centuries = convertField(fields.centuries, converted);\n+        fields.years = convertField(fields.years, converted);\n+        fields.months = convertField(fields.months, converted);\n+        fields.weekyears = convertField(fields.weekyears, converted);\n+        fields.weeks = convertField(fields.weeks, converted);\n+        fields.days = convertField(fields.days, converted);\n+\n+        fields.halfdays = convertField(fields.halfdays, converted);\n+        fields.hours = convertField(fields.hours, converted);\n+        fields.minutes = convertField(fields.minutes, converted);\n+        fields.seconds = convertField(fields.seconds, converted);\n+        fields.millis = convertField(fields.millis, converted);\n+\n+        // Convert datetime fields...\n+\n+        fields.year = convertField(fields.year, converted);\n+        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n+        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n+        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n+        fields.era = convertField(fields.era, converted);\n+        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n+        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n+        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n+        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n+        fields.weekyear = convertField(fields.weekyear, converted);\n+        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n+\n+        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n+        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n+        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n+        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n+        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n+        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n+        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n+        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n+        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n+        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n+    }\n+\n+    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DurationField)converted.get(field);\n+        }\n+        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n+        converted.put(field, zonedField);\n+        return zonedField;\n+    }\n+\n+    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n+        if (field == null || !field.isSupported()) {\n+            return field;\n+        }\n+        if (converted.containsKey(field)) {\n+            return (DateTimeField)converted.get(field);\n+        }\n+        ZonedDateTimeField zonedField =\n+            new ZonedDateTimeField(field, getZone(),\n+                                   convertField(field.getDurationField(), converted),\n+                                   convertField(field.getRangeDurationField(), converted),\n+                                   convertField(field.getLeapDurationField(), converted));\n+        converted.put(field, zonedField);\n+        return zonedField;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A zoned chronology is only equal to a zoned chronology with the\n+     * same base chronology and zone.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof ZonedChronology == false) {\n+            return false;\n+        }\n+        ZonedChronology chrono = (ZonedChronology) obj;\n+        return\n+            getBase().equals(chrono.getBase()) &&\n+            getZone().equals(chrono.getZone());\n+    }\n+\n+    /**\n+     * A suitable hashcode for the chronology.\n+     * \n+     * @return the hashcode\n+     * @since 1.4\n+     */\n+    public int hashCode() {\n+        return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7;\n+    }\n+\n+    /**\n+     * A debugging string for the chronology.\n+     * \n+     * @return the debugging string\n+     */\n+    public String toString() {\n+        return \"ZonedChronology[\" + getBase() + \", \" + getZone().getID() + ']';\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /*\n+     * Because time durations are typically smaller than time zone offsets, the\n+     * arithmetic methods subtract the original offset. This produces a more\n+     * expected behavior when crossing time zone offset transitions. For dates,\n+     * the new offset is subtracted off. This behavior, if applied to time\n+     * fields, can nullify or reverse an add when crossing a transition.\n+     */\n+    static class ZonedDurationField extends BaseDurationField {\n+        private static final long serialVersionUID = -485345310999208286L;\n+\n+        final DurationField iField;\n+        final boolean iTimeField;\n+        final DateTimeZone iZone;\n+\n+        ZonedDurationField(DurationField field, DateTimeZone zone) {\n+            super(field.getType());\n+            if (!field.isSupported()) {\n+                throw new IllegalArgumentException();\n+            }\n+            iField = field;\n+            iTimeField = useTimeArithmetic(field);\n+            iZone = zone;\n+        }\n+\n+        public boolean isPrecise() {\n+            return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();\n+        }\n+\n+        public long getUnitMillis() {\n+            return iField.getUnitMillis();\n+        }\n+\n+        public int getValue(long duration, long instant) {\n+            return iField.getValue(duration, addOffset(instant));\n+        }\n+\n+        public long getValueAsLong(long duration, long instant) {\n+            return iField.getValueAsLong(duration, addOffset(instant));\n+        }\n+\n+        public long getMillis(int value, long instant) {\n+            return iField.getMillis(value, addOffset(instant));\n+        }\n+\n+        public long getMillis(long value, long instant) {\n+            return iField.getMillis(value, addOffset(instant));\n+        }\n+\n+        public long add(long instant, int value) {\n+            int offset = getOffsetToAdd(instant);\n+            instant = iField.add(instant + offset, value);\n+            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n+        }\n+\n+        public long add(long instant, long value) {\n+            int offset = getOffsetToAdd(instant);\n+            instant = iField.add(instant + offset, value);\n+            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            int offset = getOffsetToAdd(subtrahendInstant);\n+            return iField.getDifference\n+                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n+                 subtrahendInstant + offset);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            int offset = getOffsetToAdd(subtrahendInstant);\n+            return iField.getDifferenceAsLong\n+                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n+                 subtrahendInstant + offset);\n+        }\n+\n+        private int getOffsetToAdd(long instant) {\n+            int offset = this.iZone.getOffset(instant);\n+            long sum = instant + offset;\n+            // If there is a sign change, but the two values have the same sign...\n+            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n+                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n+            }\n+            return offset;\n+        }\n+\n+        private int getOffsetFromLocalToSubtract(long instant) {\n+            int offset = this.iZone.getOffsetFromLocal(instant);\n+            long diff = instant - offset;\n+            // If there is a sign change, but the two values have different signs...\n+            if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\n+                throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n+            }\n+            return offset;\n+        }\n+\n+        private long addOffset(long instant) {\n+            return iZone.convertUTCToLocal(instant);\n+        }\n+    }\n+\n+    /**\n+     * A DateTimeField that decorates another to add timezone behaviour.\n+     * <p>\n+     * This class converts passed in instants to local wall time, and vice\n+     * versa on output.\n+     */\n+    static final class ZonedDateTimeField extends BaseDateTimeField {\n+        private static final long serialVersionUID = -3968986277775529794L;\n+\n+        final DateTimeField iField;\n+        final DateTimeZone iZone;\n+        final DurationField iDurationField;\n+        final boolean iTimeField;\n+        final DurationField iRangeDurationField;\n+        final DurationField iLeapDurationField;\n+\n+        ZonedDateTimeField(DateTimeField field,\n+                           DateTimeZone zone,\n+                           DurationField durationField,\n+                           DurationField rangeDurationField,\n+                           DurationField leapDurationField) {\n+            super(field.getType());\n+            if (!field.isSupported()) {\n+                throw new IllegalArgumentException();\n+            }\n+            iField = field;\n+            iZone = zone;\n+            iDurationField = durationField;\n+            iTimeField = useTimeArithmetic(durationField);\n+            iRangeDurationField = rangeDurationField;\n+            iLeapDurationField = leapDurationField;\n+        }\n+\n+        public boolean isLenient() {\n+            return iField.isLenient();\n+        }\n+\n+        public int get(long instant) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.get(localInstant);\n+        }\n+\n+        public String getAsText(long instant, Locale locale) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getAsText(localInstant, locale);\n+        }\n+\n+        public String getAsShortText(long instant, Locale locale) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getAsShortText(localInstant, locale);\n+        }\n+\n+        public String getAsText(int fieldValue, Locale locale) {\n+            return iField.getAsText(fieldValue, locale);\n+        }\n+\n+        public String getAsShortText(int fieldValue, Locale locale) {\n+            return iField.getAsShortText(fieldValue, locale);\n+        }\n+\n+        public long add(long instant, int value) {\n+            if (iTimeField) {\n+                int offset = getOffsetToAdd(instant);\n+                long localInstant = iField.add(instant + offset, value);\n+                return localInstant - offset;\n+            } else {\n+               long localInstant = iZone.convertUTCToLocal(instant);\n+               localInstant = iField.add(localInstant, value);\n+               return iZone.convertLocalToUTC(localInstant, false);\n+            }\n+        }\n+\n+        public long add(long instant, long value) {\n+            if (iTimeField) {\n+                int offset = getOffsetToAdd(instant);\n+                long localInstant = iField.add(instant + offset, value);\n+                return localInstant - offset;\n+            } else {\n+               long localInstant = iZone.convertUTCToLocal(instant);\n+               localInstant = iField.add(localInstant, value);\n+               return iZone.convertLocalToUTC(localInstant, false);\n+            }\n+        }\n+\n+        public long addWrapField(long instant, int value) {\n+            if (iTimeField) {\n+                int offset = getOffsetToAdd(instant);\n+                long localInstant = iField.addWrapField(instant + offset, value);\n+                return localInstant - offset;\n+            } else {\n+                long localInstant = iZone.convertUTCToLocal(instant);\n+                localInstant = iField.addWrapField(localInstant, value);\n+                return iZone.convertLocalToUTC(localInstant, false);\n+            }\n+        }\n+\n+        public long set(long instant, int value) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            localInstant = iField.set(localInstant, value);\n+            long result = iZone.convertLocalToUTC(localInstant, false);\n+            if (get(result) != value) {\n+                throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n+                    \"Illegal instant due to time zone offset transition: \" +\n+                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n+                    \" (\" + iZone.getID() + \")\");\n+            }\n+            return result;\n+        }\n+\n+        public long set(long instant, String text, Locale locale) {\n+            // cannot verify that new value stuck because set may be lenient\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            localInstant = iField.set(localInstant, text, locale);\n+            return iZone.convertLocalToUTC(localInstant, false);\n+        }\n+\n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            int offset = getOffsetToAdd(subtrahendInstant);\n+            return iField.getDifference\n+                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n+                 subtrahendInstant + offset);\n+        }\n+\n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            int offset = getOffsetToAdd(subtrahendInstant);\n+            return iField.getDifferenceAsLong\n+                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n+                 subtrahendInstant + offset);\n+        }\n+\n+        public final DurationField getDurationField() {\n+            return iDurationField;\n+        }\n+\n+        public final DurationField getRangeDurationField() {\n+            return iRangeDurationField;\n+        }\n+\n+        public boolean isLeap(long instant) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.isLeap(localInstant);\n+        }\n+\n+        public int getLeapAmount(long instant) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getLeapAmount(localInstant);\n+        }\n+\n+        public final DurationField getLeapDurationField() {\n+            return iLeapDurationField;\n+        }\n+\n+        public long roundFloor(long instant) {\n+            if (iTimeField) {\n+                int offset = getOffsetToAdd(instant);\n+                instant = iField.roundFloor(instant + offset);\n+                return instant - offset;\n+            } else {\n+                long localInstant = iZone.convertUTCToLocal(instant);\n+                localInstant = iField.roundFloor(localInstant);\n+                return iZone.convertLocalToUTC(localInstant, false);\n+            }\n+        }\n+\n+        public long roundCeiling(long instant) {\n+            if (iTimeField) {\n+                int offset = getOffsetToAdd(instant);\n+                instant = iField.roundCeiling(instant + offset);\n+                return instant - offset;\n+            } else {\n+                long localInstant = iZone.convertUTCToLocal(instant);\n+                localInstant = iField.roundCeiling(localInstant);\n+                return iZone.convertLocalToUTC(localInstant, false);\n+            }\n+        }\n+\n+        public long remainder(long instant) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.remainder(localInstant);\n+        }\n+\n+        public int getMinimumValue() {\n+            return iField.getMinimumValue();\n+        }\n+\n+        public int getMinimumValue(long instant) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getMinimumValue(localInstant);\n+        }\n+\n+        public int getMinimumValue(ReadablePartial instant) {\n+            return iField.getMinimumValue(instant);\n+        }\n+\n+        public int getMinimumValue(ReadablePartial instant, int[] values) {\n+            return iField.getMinimumValue(instant, values);\n+        }\n+\n+        public int getMaximumValue() {\n+            return iField.getMaximumValue();\n+        }\n+\n+        public int getMaximumValue(long instant) {\n+            long localInstant = iZone.convertUTCToLocal(instant);\n+            return iField.getMaximumValue(localInstant);\n+        }\n+\n+        public int getMaximumValue(ReadablePartial instant) {\n+            return iField.getMaximumValue(instant);\n+        }\n+\n+        public int getMaximumValue(ReadablePartial instant, int[] values) {\n+            return iField.getMaximumValue(instant, values);\n+        }\n+\n+        public int getMaximumTextLength(Locale locale) {\n+            return iField.getMaximumTextLength(locale);\n+        }\n+\n+        public int getMaximumShortTextLength(Locale locale) {\n+            return iField.getMaximumShortTextLength(locale);\n+        }\n+\n+        private int getOffsetToAdd(long instant) {\n+            int offset = this.iZone.getOffset(instant);\n+            long sum = instant + offset;\n+            // If there is a sign change, but the two values have the same sign...\n+            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n+                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n+            }\n+            return offset;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/AbstractConverter.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+/**\n+ * AbstractConverter simplifies the process of implementing a converter.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public abstract class AbstractConverter implements Converter {\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected AbstractConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * <p>\n+     * This implementation returns the current time.\n+     * \n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is always non-null\n+     * @return the millisecond value\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        return DateTimeUtils.currentTimeMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the chronology from an object of this convertor's type\n+     * where the time zone is specified.\n+     * <p>\n+     * This implementation returns the ISO chronology.\n+     * \n+     * @param object  the object to convert\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, DateTimeZone zone) {\n+        return ISOChronology.getInstance(zone);\n+    }\n+\n+    /**\n+     * Extracts the chronology from an object of this convertor's type\n+     * where the chronology is specified.\n+     * <p>\n+     * This implementation returns the chronology specified, or the\n+     * ISO chronology in the default zone if null passed in.\n+     * \n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, null means ISO default\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, Chronology chrono) {\n+        return DateTimeUtils.getChronology(chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * The chrono parameter is a hint to the converter, should it require a\n+     * chronology to aid in conversion.\n+     * <p>\n+     * This implementation calls {@link #getInstantMillis(Object, Chronology)}.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) {\n+        long instant = getInstantMillis(object, chrono);\n+        return chrono.get(fieldSource, instant);\n+    }\n+\n+    /**\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * The chrono parameter is a hint to the converter, should it require a\n+     * chronology to aid in conversion.\n+     * <p>\n+     * This implementation calls {@link #getPartialValues(ReadablePartial, Object, Chronology)}.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @param parser  if converting from a String, the given parser is preferred\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     * @since 1.3\n+     */\n+    public int[] getPartialValues(ReadablePartial fieldSource,\n+            Object object, Chronology chrono, DateTimeFormatter parser) {\n+        return getPartialValues(fieldSource, object, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Selects a suitable period type for the given object.\n+     *\n+     * @param object  the object to examine\n+     * @return the period type, never null\n+     */\n+    public PeriodType getPeriodType(Object object) {\n+        return PeriodType.standard();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the input is a ReadableInterval.\n+     * <p>\n+     * If it is, then the calling code should cast and copy the fields directly.\n+     *\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, may be null\n+     * @return true if the input is a ReadableInterval\n+     */\n+    public boolean isReadableInterval(Object object, Chronology chrono) {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging string version of this converter.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        return \"Converter[\" + (getSupportedType() == null ? \"null\" : getSupportedType().getName()) + \"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/CalendarConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.GJChronology;\n+import org.joda.time.chrono.GregorianChronology;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.JulianChronology;\n+\n+/**\n+ * CalendarConverter converts a java util Calendar to an instant or partial.\n+ * The Calendar is converted to milliseconds and the chronology that best\n+ * matches the calendar.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+final class CalendarConverter extends AbstractConverter\n+        implements InstantConverter, PartialConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final CalendarConverter INSTANCE = new CalendarConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected CalendarConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology.\n+     * <p>\n+     * If a chronology is specified then it is used.\n+     * Otherwise, it is the GJChronology if a GregorianCalendar is used,\n+     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.\n+     * The time zone is extracted from the calendar if possible, default used if not.\n+     * \n+     * @param object  the Calendar to convert, must not be null\n+     * @param chrono  the chronology to use, null means use Calendar\n+     * @return the chronology, never null\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public Chronology getChronology(Object object, Chronology chrono) {\n+        if (chrono != null) {\n+            return chrono;\n+        }\n+        Calendar cal = (Calendar) object;\n+        DateTimeZone zone = null;\n+        try {\n+            zone = DateTimeZone.forTimeZone(cal.getTimeZone());\n+            \n+        } catch (IllegalArgumentException ex) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        return getChronology(cal, zone);\n+    }\n+\n+    /**\n+     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,\n+     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.\n+     * The time zone specified is used in preference to that on the calendar.\n+     * \n+     * @param object  the Calendar to convert, must not be null\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public Chronology getChronology(Object object, DateTimeZone zone) {\n+        if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n+            return BuddhistChronology.getInstance(zone);\n+        } else if (object instanceof GregorianCalendar) {\n+            GregorianCalendar gc = (GregorianCalendar) object;\n+            long cutover = gc.getGregorianChange().getTime();\n+            if (cutover == Long.MIN_VALUE) {\n+                return GregorianChronology.getInstance(zone);\n+            } else if (cutover == Long.MAX_VALUE) {\n+                return JulianChronology.getInstance(zone);\n+            } else {\n+                return GJChronology.getInstance(zone, cutover, 4);\n+            }\n+        } else {\n+            return ISOChronology.getInstance(zone);\n+        }\n+    }\n+\n+    /**\n+     * Gets the millis, which is the Calendar millis value.\n+     * \n+     * @param object  the Calendar to convert, must not be null\n+     * @param chrono  the chronology result from getChronology, non-null\n+     * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        Calendar calendar = (Calendar) object;\n+        return calendar.getTime().getTime();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns Calendar.class.\n+     * \n+     * @return Calendar.class\n+     */\n+    public Class<?> getSupportedType() {\n+        return Calendar.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/Converter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+/**\n+ * Basic converter interface for specifying what object type can be converted.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface Converter {\n+\n+    /**\n+     * Returns the object type that this converter supports, which may\n+     * specified by a class, superclass, abstract class, interface, or null.\n+     * \n+     * @return the object type that this converter supports\n+     */\n+    Class<?> getSupportedType();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/ConverterManager.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.JodaTimePermission;\n+\n+/**\n+ * ConverterManager controls the date and time converters.\n+ * <p>\n+ * This class enables additional conversion classes to be added via\n+ * {@link #addInstantConverter(InstantConverter)}, which may replace an\n+ * existing converter. Similar methods exist for duration, time period and\n+ * interval converters.\n+ * <p>\n+ * This class is threadsafe, so adding/removing converters can be done at any\n+ * time. Updating the set of convertors is relatively expensive, and so should\n+ * not be performed often.\n+ * <p>\n+ * The default instant converters are:\n+ * <ul>\n+ * <li>ReadableInstant\n+ * <li>String\n+ * <li>Calendar\n+ * <li>Date (includes sql package subclasses)\n+ * <li>Long (milliseconds)\n+ * <li>null (now)\n+ * </ul>\n+ * \n+ * The default partial converters are:\n+ * <ul>\n+ * <li>ReadablePartial\n+ * <li>ReadableInstant\n+ * <li>String\n+ * <li>Calendar\n+ * <li>Date (includes sql package subclasses)\n+ * <li>Long (milliseconds)\n+ * <li>null (now)\n+ * </ul>\n+ * \n+ * The default duration converters are:\n+ * <ul>\n+ * <li>ReadableDuration\n+ * <li>ReadableInterval\n+ * <li>String\n+ * <li>Long (milliseconds)\n+ * <li>null (zero ms)\n+ * </ul>\n+ *\n+ * The default time period converters are:\n+ * <ul>\n+ * <li>ReadablePeriod\n+ * <li>ReadableInterval\n+ * <li>String\n+ * <li>null (zero)\n+ * </ul>\n+ * \n+ * The default interval converters are:\n+ * <ul>\n+ * <li>ReadableInterval\n+ * <li>String\n+ * <li>null (zero-length from now to now)\n+ * </ul>\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class ConverterManager {\n+\n+    /**\n+     * Singleton instance, lazily loaded to avoid class loading.\n+     */\n+    private static ConverterManager INSTANCE;\n+\n+    public static ConverterManager getInstance() {\n+        if (INSTANCE == null) {\n+            INSTANCE = new ConverterManager();\n+        }\n+        return INSTANCE;\n+    }\n+    \n+    private ConverterSet iInstantConverters;\n+    private ConverterSet iPartialConverters;\n+    private ConverterSet iDurationConverters;\n+    private ConverterSet iPeriodConverters;\n+    private ConverterSet iIntervalConverters;\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ConverterManager() {\n+        super();\n+\n+        iInstantConverters = new ConverterSet(new Converter[] {\n+            ReadableInstantConverter.INSTANCE,\n+            StringConverter.INSTANCE,\n+            CalendarConverter.INSTANCE,\n+            DateConverter.INSTANCE,\n+            LongConverter.INSTANCE,\n+            NullConverter.INSTANCE,\n+        });\n+\n+        iPartialConverters = new ConverterSet(new Converter[] {\n+            ReadablePartialConverter.INSTANCE,\n+            ReadableInstantConverter.INSTANCE,\n+            StringConverter.INSTANCE,\n+            CalendarConverter.INSTANCE,\n+            DateConverter.INSTANCE,\n+            LongConverter.INSTANCE,\n+            NullConverter.INSTANCE,\n+        });\n+\n+        iDurationConverters = new ConverterSet(new Converter[] {\n+            ReadableDurationConverter.INSTANCE,\n+            ReadableIntervalConverter.INSTANCE,\n+            StringConverter.INSTANCE,\n+            LongConverter.INSTANCE,\n+            NullConverter.INSTANCE,\n+        });\n+\n+        iPeriodConverters = new ConverterSet(new Converter[] {\n+            ReadableDurationConverter.INSTANCE,\n+            ReadablePeriodConverter.INSTANCE,\n+            ReadableIntervalConverter.INSTANCE,\n+            StringConverter.INSTANCE,\n+            NullConverter.INSTANCE,\n+        });\n+\n+        iIntervalConverters = new ConverterSet(new Converter[] {\n+            ReadableIntervalConverter.INSTANCE,\n+            StringConverter.INSTANCE,\n+            NullConverter.INSTANCE,\n+        });\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public InstantConverter getInstantConverter(Object object) {\n+        InstantConverter converter =\n+            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No instant converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the set of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public InstantConverter[] getInstantConverters() {\n+        ConverterSet set = iInstantConverters;\n+        InstantConverter[] converters = new InstantConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public InstantConverter addInstantConverter(InstantConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterInstantConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        InstantConverter[] removed = new InstantConverter[1];\n+        iInstantConverters = iInstantConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public InstantConverter removeInstantConverter(InstantConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterInstantConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        InstantConverter[] removed = new InstantConverter[1];\n+        iInstantConverters = iInstantConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.\n+     * \n+     * @throws SecurityException if the user does not have the permission\n+     */\n+    private void checkAlterInstantConverters() throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public PartialConverter getPartialConverter(Object object) {\n+        PartialConverter converter =\n+            (PartialConverter)iPartialConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No partial converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the set of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public PartialConverter[] getPartialConverters() {\n+        ConverterSet set = iPartialConverters;\n+        PartialConverter[] converters = new PartialConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public PartialConverter addPartialConverter(PartialConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterPartialConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        PartialConverter[] removed = new PartialConverter[1];\n+        iPartialConverters = iPartialConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public PartialConverter removePartialConverter(PartialConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterPartialConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        PartialConverter[] removed = new PartialConverter[1];\n+        iPartialConverters = iPartialConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.\n+     * \n+     * @throws SecurityException if the user does not have the permission\n+     */\n+    private void checkAlterPartialConverters() throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public DurationConverter getDurationConverter(Object object) {\n+        DurationConverter converter =\n+            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No duration converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the list of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public DurationConverter[] getDurationConverters() {\n+        ConverterSet set = iDurationConverters;\n+        DurationConverter[] converters = new DurationConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public DurationConverter addDurationConverter(DurationConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterDurationConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        DurationConverter[] removed = new DurationConverter[1];\n+        iDurationConverters = iDurationConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public DurationConverter removeDurationConverter(DurationConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterDurationConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        DurationConverter[] removed = new DurationConverter[1];\n+        iDurationConverters = iDurationConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.\n+     * \n+     * @throws SecurityException if the user does not have the permission\n+     */\n+    private void checkAlterDurationConverters() throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public PeriodConverter getPeriodConverter(Object object) {\n+        PeriodConverter converter =\n+            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No period converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the list of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public PeriodConverter[] getPeriodConverters() {\n+        ConverterSet set = iPeriodConverters;\n+        PeriodConverter[] converters = new PeriodConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public PeriodConverter addPeriodConverter(PeriodConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterPeriodConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        PeriodConverter[] removed = new PeriodConverter[1];\n+        iPeriodConverters = iPeriodConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public PeriodConverter removePeriodConverter(PeriodConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterPeriodConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        PeriodConverter[] removed = new PeriodConverter[1];\n+        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Checks whether the user has permission 'ConverterManager.alterPeriodConverters'.\n+     * \n+     * @throws SecurityException if the user does not have the permission\n+     */\n+    private void checkAlterPeriodConverters() throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the best converter for the object specified.\n+     * \n+     * @param object  the object to convert\n+     * @return the converter to use\n+     * @throws IllegalArgumentException if no suitable converter\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    public IntervalConverter getIntervalConverter(Object object) {\n+        IntervalConverter converter =\n+            (IntervalConverter)iIntervalConverters.select(object == null ? null : object.getClass());\n+        if (converter != null) {\n+            return converter;\n+        }\n+        throw new IllegalArgumentException(\"No interval converter found for type: \" +\n+            (object == null ? \"null\" : object.getClass().getName()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of the list of converters.\n+     * \n+     * @return the converters, a copy of the real data, never null\n+     */\n+    public IntervalConverter[] getIntervalConverters() {\n+        ConverterSet set = iIntervalConverters;\n+        IntervalConverter[] converters = new IntervalConverter[set.size()];\n+        set.copyInto(converters);\n+        return converters;\n+    }\n+    \n+    /**\n+     * Adds a converter to the set of converters. If a matching converter is\n+     * already in the set, the given converter replaces it. If the converter is\n+     * exactly the same as one already in the set, no changes are made.\n+     * <p>\n+     * The order in which converters are added is not relevent. The best\n+     * converter is selected by examining the object hierarchy.\n+     * \n+     * @param converter  the converter to add, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public IntervalConverter addIntervalConverter(IntervalConverter converter) \n+            throws SecurityException {\n+        \n+        checkAlterIntervalConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        IntervalConverter[] removed = new IntervalConverter[1];\n+        iIntervalConverters = iIntervalConverters.add(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Removes a converter from the set of converters. If the converter was\n+     * not in the set, no changes are made.\n+     * \n+     * @param converter  the converter to remove, null ignored\n+     * @return replaced converter, or null\n+     */\n+    public IntervalConverter removeIntervalConverter(IntervalConverter converter)\n+            throws SecurityException {\n+        \n+        checkAlterIntervalConverters();\n+        if (converter == null) {\n+            return null;\n+        }\n+        IntervalConverter[] removed = new IntervalConverter[1];\n+        iIntervalConverters = iIntervalConverters.remove(converter, removed);\n+        return removed[0];\n+    }\n+    \n+    /**\n+     * Checks whether the user has permission 'ConverterManager.alterIntervalConverters'.\n+     * \n+     * @throws SecurityException if the user does not have the permission\n+     */\n+    private void checkAlterIntervalConverters() throws SecurityException {\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterIntervalConverters\"));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debug representation of the object.\n+     */\n+    public String toString() {\n+        return \"ConverterManager[\" +\n+            iInstantConverters.size() + \" instant,\" +\n+            iPartialConverters.size() + \" partial,\" +\n+            iDurationConverters.size() + \" duration,\" +\n+            iPeriodConverters.size() + \" period,\" +\n+            iIntervalConverters.size() + \" interval]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/ConverterSet.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+/**\n+ * A set of converters, which allows exact converters to be quickly\n+ * selected. This class is threadsafe because it is (essentially) immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class ConverterSet {\n+    private final Converter[] iConverters;\n+\n+    // A simple immutable hashtable: closed hashing, linear probing, sized\n+    // power of 2, at least one null slot.\n+    private Entry[] iSelectEntries;\n+\n+    ConverterSet(Converter[] converters) {\n+        // Since this is a package private constructor, we trust ourselves not\n+        // to alter the array outside this class.\n+        iConverters = converters;\n+        iSelectEntries = new Entry[1 << 4]; // 16\n+    }\n+\n+    /**\n+     * Returns the closest matching converter for the given type, or null if\n+     * none found.\n+     *\n+     * @param type type to select, which may be null\n+     * @throws IllegalStateException if multiple converters match the type\n+     * equally well\n+     */\n+    Converter select(Class<?> type) throws IllegalStateException {\n+        // Check the hashtable first.\n+        Entry[] entries = iSelectEntries;\n+        int length = entries.length;\n+        int index = type == null ? 0 : type.hashCode() & (length - 1);\n+\n+        Entry e;\n+        // This loop depends on there being at least one null slot.\n+        while ((e = entries[index]) != null) {\n+            if (e.iType == type) {\n+                return e.iConverter;\n+            }\n+            if (++index >= length) {\n+                index = 0;\n+            }\n+        }\n+\n+        // Not found in the hashtable, so do actual work.\n+\n+        Converter converter = selectSlow(this, type);\n+        e = new Entry(type, converter);\n+\n+        // Save the entry for future selects. This class must be threadsafe,\n+        // but there is no synchronization. Since the hashtable is being used\n+        // as a cache, it is okay to destroy existing entries. This isn't\n+        // likely to occur unless there is a high amount of concurrency. As\n+        // time goes on, cache updates will occur less often, and the cache\n+        // will fill with all the necessary entries.\n+\n+        // Do all updates on a copy: slots in iSelectEntries must not be\n+        // updated by multiple threads as this can allow all null slots to be\n+        // consumed.\n+        entries = (Entry[])entries.clone();\n+\n+        // Add new entry.\n+        entries[index] = e;\n+\n+        // Verify that at least one null slot exists!\n+        for (int i=0; i<length; i++) {\n+            if (entries[i] == null) {\n+                // Found a null slot, swap in new hashtable.\n+                iSelectEntries = entries;\n+                return converter;\n+            }\n+        }\n+\n+        // Double capacity and re-hash.\n+\n+        int newLength = length << 1;\n+        Entry[] newEntries = new Entry[newLength];\n+        for (int i=0; i<length; i++) {\n+            e = entries[i];\n+            type = e.iType;\n+            index = type == null ? 0 : type.hashCode() & (newLength - 1);\n+            while (newEntries[index] != null) {\n+                if (++index >= newLength) {\n+                    index = 0;\n+                }\n+            }\n+            newEntries[index] = e;\n+        }\n+\n+        // Swap in new hashtable.\n+        iSelectEntries = newEntries;\n+        return converter;\n+    }\n+\n+    /**\n+     * Returns the amount of converters in the set.\n+     */\n+    int size() {\n+        return iConverters.length;\n+    }\n+\n+    /**\n+     * Copies all the converters in the set to the given array.\n+     */\n+    void copyInto(Converter[] converters) {\n+        System.arraycopy(iConverters, 0, converters, 0, iConverters.length);\n+    }\n+\n+    /**\n+     * Returns a copy of this set, with the given converter added. If a\n+     * matching converter is already in the set, the given converter replaces\n+     * it. If the converter is exactly the same as one already in the set, the\n+     * original set is returned.\n+     *\n+     * @param converter  converter to add, must not be null\n+     * @param removed  if not null, element 0 is set to the removed converter\n+     * @throws NullPointerException if converter is null\n+     */\n+    ConverterSet add(Converter converter, Converter[] removed) {\n+        Converter[] converters = iConverters;\n+        int length = converters.length;\n+\n+        for (int i=0; i<length; i++) {\n+            Converter existing = converters[i];\n+            if (converter.equals(existing)) {\n+                // Already in the set.\n+                if (removed != null) {\n+                    removed[0] = null;\n+                }\n+                return this;\n+            }\n+            \n+            if (converter.getSupportedType() == existing.getSupportedType()) {\n+                // Replace the converter.\n+                Converter[] copy = new Converter[length];\n+                    \n+                for (int j=0; j<length; j++) {\n+                    if (j != i) {\n+                        copy[j] = converters[j];\n+                    } else {\n+                        copy[j] = converter;\n+                    }\n+                }\n+\n+                if (removed != null) {\n+                    removed[0] = existing;\n+                }\n+                return new ConverterSet(copy);\n+            }\n+        }\n+\n+        // Not found, so add it.\n+        Converter[] copy = new Converter[length + 1];\n+        System.arraycopy(converters, 0, copy, 0, length);\n+        copy[length] = converter;\n+        \n+        if (removed != null) {\n+            removed[0] = null;\n+        }\n+        return new ConverterSet(copy);\n+    }\n+\n+    /**\n+     * Returns a copy of this set, with the given converter removed. If the\n+     * converter was not in the set, the original set is returned.\n+     *\n+     * @param converter  converter to remove, must not be null\n+     * @param removed  if not null, element 0 is set to the removed converter\n+     * @throws NullPointerException if converter is null\n+     */\n+    ConverterSet remove(Converter converter, Converter[] removed) {\n+        Converter[] converters = iConverters;\n+        int length = converters.length;\n+\n+        for (int i=0; i<length; i++) {\n+            if (converter.equals(converters[i])) {\n+                return remove(i, removed);\n+            }\n+        }\n+\n+        // Not found.\n+        if (removed != null) {\n+            removed[0] = null;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns a copy of this set, with the converter at the given index\n+     * removed.\n+     *\n+     * @param index index of converter to remove\n+     * @param removed if not null, element 0 is set to the removed converter\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    ConverterSet remove(final int index, Converter[] removed) {\n+        Converter[] converters = iConverters;\n+        int length = converters.length;\n+        if (index >= length) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+\n+        if (removed != null) {\n+            removed[0] = converters[index];\n+        }\n+\n+        Converter[] copy = new Converter[length - 1];\n+                \n+        int j = 0;\n+        for (int i=0; i<length; i++) {\n+            if (i != index) {\n+                copy[j++] = converters[i];\n+            }\n+        }\n+        \n+        return new ConverterSet(copy);\n+    }\n+\n+    /**\n+     * Returns the closest matching converter for the given type, but not very\n+     * efficiently.\n+     */\n+    private static Converter selectSlow(ConverterSet set, Class<?> type) {\n+        Converter[] converters = set.iConverters;\n+        int length = converters.length;\n+        Converter converter;\n+\n+        for (int i=length; --i>=0; ) {\n+            converter = converters[i];\n+            Class<?> supportedType = converter.getSupportedType();\n+\n+            if (supportedType == type) {\n+                // Exact match.\n+                return converter;\n+            }\n+\n+            if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {\n+                // Eliminate the impossible.\n+                set = set.remove(i, null);\n+                converters = set.iConverters;\n+                length = converters.length;\n+            }\n+        }\n+\n+        // Haven't found exact match, so check what remains in the set.\n+\n+        if (type == null || length == 0) {\n+            return null;\n+        }\n+        if (length == 1) {\n+            // Found the one best match.\n+            return converters[0];\n+        }\n+\n+        // At this point, there exist multiple potential converters.\n+\n+        // Eliminate supertypes.\n+        for (int i=length; --i>=0; ) {\n+            converter = converters[i];\n+            Class<?> supportedType = converter.getSupportedType();\n+            for (int j=length; --j>=0; ) {\n+                if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\n+                    // Eliminate supertype.\n+                    set = set.remove(j, null);\n+                    converters = set.iConverters;\n+                    length = converters.length;\n+                    i = length - 1;\n+                }\n+            }\n+        }        \n+        \n+        // Check what remains in the set.\n+\n+        if (length == 1) {\n+            // Found the one best match.\n+            return converters[0];\n+        }\n+\n+        // Class c implements a, b {}\n+        // Converters exist only for a and b. Which is better? Neither.\n+\n+        StringBuffer msg = new StringBuffer();\n+        msg.append(\"Unable to find best converter for type \\\"\");\n+        msg.append(type.getName());\n+        msg.append(\"\\\" from remaining set: \");\n+        for (int i=0; i<length; i++) {\n+            converter = converters[i];\n+            Class<?> supportedType = converter.getSupportedType();\n+\n+            msg.append(converter.getClass().getName());\n+            msg.append('[');\n+            msg.append(supportedType == null ? null : supportedType.getName());\n+            msg.append(\"], \");\n+        }\n+\n+        throw new IllegalStateException(msg.toString());\n+    }\n+\n+    static class Entry {\n+        final Class<?> iType;\n+        final Converter iConverter;\n+\n+        Entry(Class<?> type, Converter converter) {\n+            iType = type;\n+            iConverter = converter;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/DateConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import java.util.Date;\n+\n+import org.joda.time.Chronology;\n+\n+/**\n+ * DateConverter converts a java util Date to an instant or partial.\n+ * The Date is converted to milliseconds in the ISO chronology.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+final class DateConverter extends AbstractConverter\n+        implements InstantConverter, PartialConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final DateConverter INSTANCE = new DateConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected DateConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis, which is the Date millis value.\n+     * \n+     * @param object  the Date to convert, must not be null\n+     * @param chrono  the non-null result of getChronology\n+     * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        Date date = (Date) object;\n+        return date.getTime();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns Date.class.\n+     * \n+     * @return Date.class\n+     */\n+    public Class<?> getSupportedType() {\n+        return Date.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/DurationConverter.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+/**\n+ * DurationConverter defines how an object is converted to a millisecond duration.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface DurationConverter extends Converter {\n+\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond duration\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    long getDurationMillis(Object object);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/InstantConverter.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * InstantConverter defines how an object is converted to milliseconds/chronology.\n+ * <p>\n+ * The two methods in this interface must be called in order, as the\n+ * <code>getInstantMillis</code> method relies on the result of the\n+ * <code>getChronology</code> method being passed in.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface InstantConverter extends Converter {\n+\n+    /**\n+     * Extracts the chronology from an object of this converter's type\n+     * where the time zone is specified.\n+     * \n+     * @param object  the object to convert\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    Chronology getChronology(Object object, DateTimeZone zone);\n+\n+    /**\n+     * Extracts the chronology from an object of this converter's type\n+     * where the chronology may be specified.\n+     * <p>\n+     * If the chronology is non-null it should be used. If it is null, then the\n+     * object should be queried, and if it has no chronology then ISO default is used.\n+     * \n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, null means use object\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    Chronology getChronology(Object object, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the millis from an object of this converter's type.\n+     * <p>\n+     * The chronology passed in is the result of the call to <code>getChronology</code>.\n+     * \n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @return the millisecond instant\n+     * @throws ClassCastException if the object is invalid\n+     * @throws IllegalArgumentException if object conversion fails\n+     */\n+    long getInstantMillis(Object object, Chronology chrono);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/IntervalConverter.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.ReadWritableInterval;\n+\n+/**\n+ * IntervalConverter defines how an object is converted to an interval.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface IntervalConverter extends Converter {\n+\n+    /**\n+     * Checks if the input is a ReadableInterval.\n+     * <p>\n+     * If it is, then the calling code should cast and copy the fields directly.\n+     *\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n+     * @return true if the input is a ReadableInterval\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    boolean isReadableInterval(Object object, Chronology chrono);\n+\n+    /**\n+     * Extracts interval endpoint values from an object of this converter's\n+     * type, and sets them into the given ReadWritableInterval.\n+     *\n+     * @param writableInterval  interval to get modified, not null\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/LongConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+\n+/**\n+ * LongConverter converts a Long to an instant, partial or duration.\n+ * The Long value represents milliseconds in the ISO chronology.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class LongConverter extends AbstractConverter\n+        implements InstantConverter, PartialConverter, DurationConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final LongConverter INSTANCE = new LongConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected LongConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millisecond instant, which is the Long value.\n+     * \n+     * @param object  the Long to convert, must not be null\n+     * @param chrono  the chronology to use, which is always non-null\n+     * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        return ((Long) object).longValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millisecond duration, which is the Long value.\n+     * \n+     * @param object  the Long to convert, must not be null\n+     * @return the millisecond duration\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public long getDurationMillis(Object object) {\n+        return ((Long) object).longValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns Long.class.\n+     * \n+     * @return Long.class\n+     */\n+    public Class<?> getSupportedType() {\n+        return Long.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/NullConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.Period;\n+import org.joda.time.ReadWritableInterval;\n+import org.joda.time.ReadWritablePeriod;\n+\n+/**\n+ * NullConverter converts null to an instant, partial, duration, period\n+ * or interval. Null means now for instant/partial, zero for duration/period\n+ * and from now to now for interval.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class NullConverter extends AbstractConverter\n+        implements InstantConverter, PartialConverter, DurationConverter, PeriodConverter, IntervalConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final NullConverter INSTANCE = new NullConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected NullConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millisecond duration, which is zero.\n+     * \n+     * @param object  the object to convert, which is null\n+     * @return the millisecond duration\n+     */\n+    public long getDurationMillis(Object object) {\n+        return 0L;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the given ReadWritableDuration to zero milliseconds.\n+     *\n+     * @param duration duration to get modified\n+     * @param object  the object to convert, which is null\n+     * @param chrono  the chronology to use\n+     * @throws NullPointerException if the duration is null\n+     */\n+    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\n+        duration.setPeriod((Period) null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts interval endpoint values from an object of this converter's\n+     * type, and sets them into the given ReadWritableInterval.\n+     *\n+     * @param writableInterval interval to get modified, not null\n+     * @param object  the object to convert, which is null\n+     * @param chrono  the chronology to use, may be null\n+     * @throws NullPointerException if the interval is null\n+     */\n+    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n+        writableInterval.setChronology(chrono);\n+        long now = DateTimeUtils.currentTimeMillis();\n+        writableInterval.setInterval(now, now);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns null.\n+     * \n+     * @return null\n+     */\n+    public Class<?> getSupportedType() {\n+        return null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/PartialConverter.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+/**\n+ * PartialConverter defines how an object is converted to a ReadablePartial.\n+ * <p>\n+ * The two methods in this interface must be called in order, as the\n+ * <code>getPartialValues</code> method relies on the result of the\n+ * <code>getChronology</code> method being passed in.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public interface PartialConverter extends Converter {\n+\n+    /**\n+     * Extracts the chronology from an object of this converter's type\n+     * where the time zone is specified.\n+     * \n+     * @param object  the object to convert\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     * @throws ClassCastException if the object is invalid\n+     * @since 1.3\n+     */\n+    Chronology getChronology(Object object, DateTimeZone zone);\n+\n+    /**\n+     * Extracts the chronology from an object of this converter's type\n+     * where the chronology is specified.\n+     * \n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, null usually means ISO\n+     * @return the chronology, not converted to UTC/local time zone, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    Chronology getChronology(Object object, Chronology chrono);\n+\n+    /**\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * The chrono parameter is a hint to the converter, should it require a\n+     * chronology to aid in conversion.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono);\n+\n+    /**\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * The chrono parameter is a hint to the converter, should it require a\n+     * chronology to aid in conversion.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @param parser  if converting from a String, the given parser is preferred\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     * @since 1.3\n+     */\n+    int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono,\n+                           DateTimeFormatter parser);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/PeriodConverter.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+\n+/**\n+ * PeriodConverter defines how an object is converted to a time period.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface PeriodConverter extends Converter {\n+\n+    /**\n+     * Extracts duration values from an object of this converter's type, and\n+     * sets them into the given ReadWritableDuration.\n+     *\n+     * @param period  the period to modify\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, must not be null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    void setInto(ReadWritablePeriod period, Object object, Chronology chrono);\n+\n+    /**\n+     * Selects a suitable period type for the given object.\n+     *\n+     * @param object  the object to examine, must not be null\n+     * @return the period type, never null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    PeriodType getPeriodType(Object object);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/ReadableDurationConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadableDuration;\n+\n+/**\n+ * ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class ReadableDurationConverter extends AbstractConverter\n+        implements DurationConverter, PeriodConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadableDurationConverter INSTANCE = new ReadableDurationConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadableDurationConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the object to convert, must not be null\n+     * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    public long getDurationMillis(Object object) {\n+        return ((ReadableDuration) object).getMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts duration values from an object of this converter's type, and\n+     * sets them into the given ReadWritableDuration.\n+     *\n+     * @param writablePeriod  period to get modified\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, must not be null\n+     * @throws NullPointerException if the duration or object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {\n+        ReadableDuration dur = (ReadableDuration) object;\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        long duration = dur.getMillis();\n+        int[] values = chrono.get(writablePeriod, duration);\n+        for (int i = 0; i < values.length; i++) {\n+            writablePeriod.setValue(i, values[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadableDuration.class.\n+     * \n+     * @return ReadableDuration.class\n+     */\n+    public Class<?> getSupportedType() {\n+        return ReadableDuration.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/ReadableInstantConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * ReadableInstantConverter extracts milliseconds and chronology from a ReadableInstant.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+class ReadableInstantConverter extends AbstractConverter\n+        implements InstantConverter, PartialConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadableInstantConverter INSTANCE = new ReadableInstantConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadableInstantConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology, which is taken from the ReadableInstant.\n+     * If the chronology on the instant is null, the ISOChronology in the\n+     * specified time zone is used.\n+     * If the chronology on the instant is not in the specified zone, it is\n+     * adapted.\n+     * \n+     * @param object  the ReadableInstant to convert, must not be null\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, DateTimeZone zone) {\n+        Chronology chrono = ((ReadableInstant) object).getChronology();\n+        if (chrono == null) {\n+            return ISOChronology.getInstance(zone);\n+        }\n+        DateTimeZone chronoZone = chrono.getZone();\n+        if (chronoZone != zone) {\n+            chrono = chrono.withZone(zone);\n+            if (chrono == null) {\n+                return ISOChronology.getInstance(zone);\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    /**\n+     * Gets the chronology, which is taken from the ReadableInstant.\n+     * <p>\n+     * If the passed in chronology is non-null, it is used.\n+     * Otherwise the chronology from the instant is used.\n+     * \n+     * @param object  the ReadableInstant to convert, must not be null\n+     * @param chrono  the chronology to use, null means use that from object\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ((ReadableInstant) object).getChronology();\n+            chrono = DateTimeUtils.getChronology(chrono);\n+        }\n+        return chrono;\n+    }\n+\n+    /**\n+     * Extracts the millis from an object of this convertor's type.\n+     * \n+     * @param object  the ReadableInstant to convert, must not be null\n+     * @param chrono  the non-null result of getChronology\n+     * @return the millisecond value\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        return ((ReadableInstant) object).getMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadableInstant.class.\n+     * \n+     * @return ReadableInstant.class\n+     */\n+    public Class<?> getSupportedType() {\n+        return ReadableInstant.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/ReadableIntervalConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.ReadWritableInterval;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadableInterval;\n+\n+/**\n+ * Converts intervals into durations of any requested period type.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class ReadableIntervalConverter extends AbstractConverter\n+        implements IntervalConverter, DurationConverter, PeriodConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadableIntervalConverter INSTANCE = new ReadableIntervalConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadableIntervalConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millisecond length of the interval.\n+     * \n+     * @param object  the interval\n+     */\n+    public long getDurationMillis(Object object) {\n+        return (((ReadableInterval) object)).toDurationMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the values of the mutable duration from the specified interval.\n+     * \n+     * @param writablePeriod  the period to modify\n+     * @param object  the interval to set from\n+     * @param chrono  the chronology to use\n+     */\n+    public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {\n+        ReadableInterval interval = (ReadableInterval) object;\n+        chrono = (chrono != null ? chrono : DateTimeUtils.getIntervalChronology(interval));\n+        long start = interval.getStartMillis();\n+        long end = interval.getEndMillis();\n+        int[] values = chrono.get(writablePeriod, start, end);\n+        for (int i = 0; i < values.length; i++) {\n+            writablePeriod.setValue(i, values[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the input is a ReadableInterval.\n+     * <p>\n+     * If it is, then the calling code should cast and copy the fields directly.\n+     *\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n+     * @return true if the input is a ReadableInterval\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public boolean isReadableInterval(Object object, Chronology chrono) {\n+        return true;\n+    }\n+\n+    /**\n+     * Extracts interval endpoint values from an object of this converter's\n+     * type, and sets them into the given ReadWritableInterval.\n+     *\n+     * @param writableInterval interval to get modified, not null\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n+        ReadableInterval input = (ReadableInterval) object;\n+        writableInterval.setInterval(input);\n+        if (chrono != null) {\n+            writableInterval.setChronology(chrono);\n+        } else {\n+            writableInterval.setChronology(input.getChronology());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadableInterval.class.\n+     */\n+    public Class<?> getSupportedType() {\n+        return ReadableInterval.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/ReadablePartialConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * ReadablePartialConverter extracts partial fields and chronology from a ReadablePartial.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+class ReadablePartialConverter extends AbstractConverter\n+        implements PartialConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadablePartialConverter INSTANCE = new ReadablePartialConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadablePartialConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology, which is taken from the ReadablePartial.\n+     * \n+     * @param object  the ReadablePartial to convert, must not be null\n+     * @param zone  the specified zone to use, null means default zone\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, DateTimeZone zone) {\n+        return getChronology(object, (Chronology) null).withZone(zone);\n+    }\n+\n+    /**\n+     * Gets the chronology, which is taken from the ReadableInstant.\n+     * <p>\n+     * If the passed in chronology is non-null, it is used.\n+     * Otherwise the chronology from the instant is used.\n+     * \n+     * @param object  the ReadablePartial to convert, must not be null\n+     * @param chrono  the chronology to use, null means use that from object\n+     * @return the chronology, never null\n+     */\n+    public Chronology getChronology(Object object, Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ((ReadablePartial) object).getChronology();\n+            chrono = DateTimeUtils.getChronology(chrono);\n+        }\n+        return chrono;\n+    }\n+\n+    /**\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * The chrono parameter is a hint to the converter, should it require a\n+     * chronology to aid in conversion.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono) {\n+        ReadablePartial input = (ReadablePartial) object;\n+        int size = fieldSource.size();\n+        int[] values = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            values[i] = input.get(fieldSource.getFieldType(i));\n+        }\n+        chrono.validate(fieldSource, values);\n+        return values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadableInstant.class.\n+     * \n+     * @return ReadableInstant.class\n+     */\n+    public Class<?> getSupportedType() {\n+        return ReadablePartial.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/ReadablePeriodConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadablePeriod;\n+\n+/**\n+ * ReadablePeriodConverter extracts milliseconds and chronology from a ReadablePeriod.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class ReadablePeriodConverter extends AbstractConverter\n+        implements PeriodConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final ReadablePeriodConverter INSTANCE = new ReadablePeriodConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected ReadablePeriodConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts duration values from an object of this converter's type, and\n+     * sets them into the given ReadWritablePeriod.\n+     *\n+     * @param duration duration to get modified\n+     * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use\n+     * @throws NullPointerException if the duration or object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     * @throws IllegalArgumentException if the object is invalid\n+     */\n+    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\n+        duration.setPeriod((ReadablePeriod) object);\n+    }\n+\n+    /**\n+     * Selects a suitable period type for the given object.\n+     *\n+     * @param object  the object to examine, must not be null\n+     * @return the period type from the readable duration\n+     * @throws NullPointerException if the object is null\n+     * @throws ClassCastException if the object is an invalid type\n+     */\n+    public PeriodType getPeriodType(Object object) {\n+        ReadablePeriod period = (ReadablePeriod) object;\n+        return period.getPeriodType();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns ReadablePeriod class.\n+     * \n+     * @return ReadablePeriod.class\n+     */\n+    public Class<?> getSupportedType() {\n+        return ReadablePeriod.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/convert/StringConverter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.convert;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.Period;\n+import org.joda.time.ReadWritableInterval;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+/**\n+ * StringConverter converts from a String to an instant, partial,\n+ * duration, period or interval..\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class StringConverter extends AbstractConverter\n+        implements InstantConverter, PartialConverter, DurationConverter, PeriodConverter, IntervalConverter {\n+\n+    /**\n+     * Singleton instance.\n+     */\n+    static final StringConverter INSTANCE = new StringConverter();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    protected StringConverter() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the millis, which is the ISO parsed string value.\n+     * \n+     * @param object  the String to convert, must not be null\n+     * @param chrono  the chronology to use, non-null result of getChronology\n+     * @return the millisecond value\n+     * @throws IllegalArgumentException if the value if invalid\n+     */\n+    public long getInstantMillis(Object object, Chronology chrono) {\n+        String str = (String) object;\n+        DateTimeFormatter p = ISODateTimeFormat.dateTimeParser();\n+        return p.withChronology(chrono).parseMillis(str);\n+    }\n+\n+    /**\n+     * Extracts the values of the partial from an object of this converter's type.\n+     * This method checks if the parser has a zone, and uses it if present.\n+     * This is most useful for parsing local times with UTC.\n+     * \n+     * @param fieldSource  a partial that provides access to the fields.\n+     *  This partial may be incomplete and only getFieldType(int) should be used\n+     * @param object  the object to convert\n+     * @param chrono  the chronology to use, which is the non-null result of getChronology()\n+     * @param parser the parser to use, may be null\n+     * @return the array of field values that match the fieldSource, must be non-null valid\n+     * @throws ClassCastException if the object is invalid\n+     * @throws IllegalArgumentException if the value if invalid\n+     * @since 1.3\n+     */\n+    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) {\n+        if (parser.getZone() != null) {\n+            chrono = chrono.withZone(parser.getZone());\n+        }\n+        long millis = parser.withChronology(chrono).parseMillis((String) object);\n+        return chrono.get(fieldSource, millis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the duration of the string using the standard type.\n+     * This matches the toString() method of ReadableDuration.\n+     * \n+     * @param object  the String to convert, must not be null\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public long getDurationMillis(Object object) {\n+        // parse here because duration could be bigger than the int supported\n+        // by the period parser\n+        String original = (String) object;\n+        String str = original;\n+        int len = str.length();\n+        if (len >= 4 &&\n+            (str.charAt(0) == 'P' || str.charAt(0) == 'p') &&\n+            (str.charAt(1) == 'T' || str.charAt(1) == 't') &&\n+            (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) {\n+            // ok\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid format: \\\"\" + original + '\"');\n+        }\n+        str = str.substring(2, len - 1);\n+        int dot = -1;\n+        for (int i = 0; i < str.length(); i++) {\n+            if ((str.charAt(i) >= '0' && str.charAt(i) <= '9') ||\n+                (i == 0 && str.charAt(0) == '-')) {\n+                // ok\n+            } else if (i > 0 && str.charAt(i) == '.' && dot == -1) {\n+                // ok\n+                dot = i;\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid format: \\\"\" + original + '\"');\n+            }\n+        }\n+        long millis = 0, seconds = 0;\n+        if (dot > 0) {\n+            seconds = Long.parseLong(str.substring(0, dot));\n+            str = str.substring(dot + 1);\n+            if (str.length() != 3) {\n+                str = (str + \"000\").substring(0, 3);\n+            }\n+            millis = Integer.parseInt(str);\n+        } else {\n+            seconds = Long.parseLong(str);\n+        }\n+        if (seconds < 0) {\n+            return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), -millis);\n+        } else {\n+            return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts duration values from an object of this converter's type, and\n+     * sets them into the given ReadWritableDuration.\n+     *\n+     * @param period  period to get modified\n+     * @param object  the String to convert, must not be null\n+     * @param chrono  the chronology to use\n+     * @return the millisecond duration\n+     * @throws ClassCastException if the object is invalid\n+     */\n+    public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) {\n+        String str = (String) object;\n+        PeriodFormatter parser = ISOPeriodFormat.standard();\n+        period.clear();\n+        int pos = parser.parseInto(period, str, 0);\n+        if (pos < str.length()) {\n+            if (pos < 0) {\n+                // Parse again to get a better exception thrown.\n+                parser.withParseType(period.getPeriodType()).parseMutablePeriod(str);\n+            }\n+            throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of the mutable interval from the string.\n+     * \n+     * @param writableInterval  the interval to set\n+     * @param object  the String to convert, must not be null\n+     * @param chrono  the chronology to use, may be null\n+     */\n+    public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) {\n+        String str = (String) object;\n+\n+        int separator = str.indexOf('/');\n+        if (separator < 0) {\n+            throw new IllegalArgumentException(\"Format requires a '/' separator: \" + str);\n+        }\n+\n+        String leftStr = str.substring(0, separator);\n+        if (leftStr.length() <= 0) {\n+            throw new IllegalArgumentException(\"Format invalid: \" + str);\n+        }\n+        String rightStr = str.substring(separator + 1);\n+        if (rightStr.length() <= 0) {\n+            throw new IllegalArgumentException(\"Format invalid: \" + str);\n+        }\n+\n+        DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser();\n+        dateTimeParser = dateTimeParser.withChronology(chrono);\n+        PeriodFormatter periodParser = ISOPeriodFormat.standard();\n+        long startInstant = 0, endInstant = 0;\n+        Period period = null;\n+        Chronology parsedChrono = null;\n+        \n+        // before slash\n+        char c = leftStr.charAt(0);\n+        if (c == 'P' || c == 'p') {\n+            period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr);\n+        } else {\n+            DateTime start = dateTimeParser.parseDateTime(leftStr);\n+            startInstant = start.getMillis();\n+            parsedChrono = start.getChronology();\n+        }\n+        \n+        // after slash\n+        c = rightStr.charAt(0);\n+        if (c == 'P' || c == 'p') {\n+            if (period != null) {\n+                throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n+            }\n+            period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr);\n+            chrono = (chrono != null ? chrono : parsedChrono);\n+            endInstant = chrono.add(period, startInstant, 1);\n+        } else {\n+            DateTime end = dateTimeParser.parseDateTime(rightStr);\n+            endInstant = end.getMillis();\n+            parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());\n+            chrono = (chrono != null ? chrono : parsedChrono);\n+            if (period != null) {\n+                startInstant = chrono.add(period, endInstant, -1);\n+            }\n+        }\n+        \n+        writableInterval.setInterval(startInstant, endInstant);\n+        writableInterval.setChronology(chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns String.class.\n+     * \n+     * @return String.class\n+     */\n+    public Class<?> getSupportedType() {\n+        return String.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/AbstractPartialFieldProperty.java\n+/*\n+ *  Copyright 2001-2006 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * AbstractPartialFieldProperty is a base class for binding a\n+ * ReadablePartial to a DateTimeField.\n+ * <p>\n+ * It allows the date and time manipulation code to be field based yet\n+ * still easy to use.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class AbstractPartialFieldProperty {\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractPartialFieldProperty() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public abstract DateTimeField getField();\n+\n+    /**\n+     * Gets the field type being used.\n+     * \n+     * @return the field type\n+     */\n+    public DateTimeFieldType getFieldType() {\n+        return getField().getType();\n+    }\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return getField().getName();\n+    }\n+\n+    /**\n+     * Gets the partial instant being used.\n+     * \n+     * @return the partial instant\n+     */\n+    protected abstract ReadablePartial getReadablePartial();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of this property from the instant.\n+     * <p>\n+     * For example, the following two lines of code are equivalent:\n+     * <pre>\n+     * partial.getDayOfMonth();\n+     * partial.dayOfMonth().get();\n+     * </pre>\n+     * \n+     * @return the current value\n+     */\n+    public abstract int get();\n+\n+    /**\n+     * Gets the value of this property from the instant as a string.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * using <code>Integer.toString</code>. This method does NOT return\n+     * textual descriptions such as 'Monday' or 'January'.\n+     * See {@link #getAsText()} and {@link #getAsShortText()} for those.\n+     * \n+     * @return the current value\n+     * @see DateTimeField#get\n+     * @since 1.1\n+     */\n+    public String getAsString() {\n+        return Integer.toString(get());\n+    }\n+\n+    /**\n+     * Gets the textual value of this property from the instant as a\n+     * string in the default locale.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * returning the appropriate textual description wherever possible.\n+     * Thus, a day of week of 1 would return 'Monday' in English.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText() {\n+        return getAsText(null);\n+    }\n+\n+    /**\n+     * Gets the textual value of this property from the instant as a\n+     * string in the specified locale.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * returning the appropriate textual description wherever possible.\n+     * Thus, a day of week of 1 would return 'Monday' in English.\n+     * \n+     * @param locale  locale to use for selecting a text symbol, null means default\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return getField().getAsText(getReadablePartial(), get(), locale);\n+    }\n+\n+    /**\n+     * Gets the short textual value of this property from the instant as a\n+     * string in the default locale.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * returning the appropriate textual description wherever possible.\n+     * Thus, a day of week of 1 would return 'Mon' in English.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    /**\n+     * Gets the short textual value of this property from the instant as a\n+     * string in the specified locale.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * returning the appropriate textual description wherever possible.\n+     * Thus, a day of week of 1 would return 'Mon' in English.\n+     * \n+     * @param locale  locale to use for selecting a text symbol, null means default\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return getField().getAsShortText(getReadablePartial(), get(), locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField\n+     */\n+    public DurationField getDurationField() {\n+        return getField().getDurationField();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return getField().getRangeDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minimum value for the field ignoring the current time.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValueOverall() {\n+        return getField().getMinimumValue();\n+    }\n+\n+    /**\n+     * Gets the minimum value for this field given the current field values.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValue() {\n+        return getField().getMinimumValue(getReadablePartial());\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field ignoring the current time.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValueOverall() {\n+        return getField().getMaximumValue();\n+    }\n+\n+    /**\n+     * Gets the maximum value for this field given the current field values.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValue() {\n+        return getField().getMaximumValue(getReadablePartial());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return getField().getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getField().getMaximumShortTextLength(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The comparison is based on the value of the same field type, irrespective\n+     * of any difference in chronology. Thus, if this property represents the\n+     * hourOfDay field, then the hourOfDay field of the other instant will be queried\n+     * whether in the same chronology or not.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null or the instant\n+     *  doesn't support the field of this property\n+     */\n+    public int compareTo(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getFieldType());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Compare this field to the same field on another partial instant.\n+     * <p>\n+     * The comparison is based on the value of the same field type, irrespective\n+     * of any difference in chronology. Thus, if this property represents the\n+     * hourOfDay field, then the hourOfDay field of the other partial will be queried\n+     * whether in the same chronology or not.\n+     * \n+     * @param partial  the partial to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws IllegalArgumentException if the field of this property cannot be queried\n+     *  on the specified instant\n+     */\n+    public int compareTo(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = partial.get(getFieldType());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this property to another.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (object instanceof AbstractPartialFieldProperty == false) {\n+            return false;\n+        }\n+        AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object;\n+        return\n+            get() == other.get() &&\n+            getFieldType() == other.getFieldType() &&\n+            FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a suitable hashcode for the object.\n+     * \n+     * @return the hashcode\n+     * @since 1.3\n+     */\n+    public int hashCode() {\n+        int hash = 19;\n+        hash = 13 * hash + get();\n+        hash = 13 * hash + getFieldType().hashCode();\n+        hash = 13 * hash + getReadablePartial().getChronology().hashCode();\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"Property[\" + getName() + \"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/AbstractReadableInstantFieldProperty.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DurationField;\n+import org.joda.time.Interval;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * AbstractReadableInstantFieldProperty is a base class for binding a\n+ * ReadableInstant to a DateTimeField.\n+ * <p>\n+ * It allows the date and time manipulation code to be field based yet\n+ * still easy to use.\n+ * <p>\n+ * AbstractReadableInstantFieldProperty itself is thread-safe and immutable,\n+ * but the ReadableInstant being operated on may be mutable and not\n+ * thread-safe.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @author Mike Schrag\n+ * @since 1.0\n+ */\n+public abstract class AbstractReadableInstantFieldProperty implements Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 1971226328211649661L;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public AbstractReadableInstantFieldProperty() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field being used.\n+     * \n+     * @return the field\n+     */\n+    public abstract DateTimeField getField();\n+\n+    /**\n+     * Gets the field type being used.\n+     * \n+     * @return the field type\n+     */\n+    public DateTimeFieldType getFieldType() {\n+        return getField().getType();\n+    }\n+\n+    /**\n+     * Gets the name of the field.\n+     * \n+     * @return the field name\n+     */\n+    public String getName() {\n+        return getField().getName();\n+    }\n+\n+    /**\n+     * Gets the milliseconds of the datetime that this property is linked to.\n+     * \n+     * @return the milliseconds\n+     */\n+    protected abstract long getMillis();\n+\n+    /**\n+     * Gets the chronology of the datetime that this property is linked to.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException, and must be\n+     * implemented by subclasses to enable the equals() and hashCode() methods.\n+     * \n+     * @return the chronology\n+     * @since 1.4\n+     */\n+    protected Chronology getChronology() {\n+        throw new UnsupportedOperationException(\n+                \"The method getChronology() was added in v1.4 and needs \" +\n+                \"to be implemented by subclasses of AbstractReadableInstantFieldProperty\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of this property from the instant.\n+     * <p>\n+     * For example, the following two lines of code are equivalent:\n+     * <pre>\n+     * datetime.getDayOfMonth();\n+     * datetime.dayOfMonth().get();\n+     * </pre>\n+     * \n+     * @return the current value\n+     * @see DateTimeField#get\n+     */\n+    public int get() {\n+        return getField().get(getMillis());\n+    }\n+\n+    /**\n+     * Gets the value of this property from the instant as a string.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * using <code>Integer.toString</code>. This method does NOT return\n+     * textual descriptions such as 'Monday' or 'January'.\n+     * See {@link #getAsText()} and {@link #getAsShortText()} for those.\n+     * \n+     * @return the current value\n+     * @see DateTimeField#get\n+     * @since 1.1\n+     */\n+    public String getAsString() {\n+        return Integer.toString(get());\n+    }\n+\n+    /**\n+     * Gets the textual value of this property from the instant as a\n+     * string in the default locale.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * returning the appropriate textual description wherever possible.\n+     * Thus, a day of week of 1 would return 'Monday' in English.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText() {\n+        return getAsText(null);\n+    }\n+\n+    /**\n+     * Gets the textual value of this property from the instant as a\n+     * string in the specified locale.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * returning the appropriate textual description wherever possible.\n+     * Thus, a day of week of 1 would return 'Monday' in English.\n+     * \n+     * @param locale  locale to use for selecting a text symbol, null means default\n+     * @return the current text value\n+     * @see DateTimeField#getAsText\n+     */\n+    public String getAsText(Locale locale) {\n+        return getField().getAsText(getMillis(), locale);\n+    }\n+\n+    /**\n+     * Gets the short textual value of this property from the instant as a\n+     * string in the default locale.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * returning the appropriate textual description wherever possible.\n+     * Thus, a day of week of 1 would return 'Mon' in English.\n+     * \n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText() {\n+        return getAsShortText(null);\n+    }\n+\n+    /**\n+     * Gets the short textual value of this property from the instant as a\n+     * string in the specified locale.\n+     * <p>\n+     * This method returns the value converted to a <code>String</code>\n+     * returning the appropriate textual description wherever possible.\n+     * Thus, a day of week of 1 would return 'Mon' in English.\n+     * \n+     * @param locale  locale to use for selecting a text symbol, null means default\n+     * @return the current text value\n+     * @see DateTimeField#getAsShortText\n+     */\n+    public String getAsShortText(Locale locale) {\n+        return getField().getAsShortText(getMillis(), locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant  the subtrahend, null means now\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public int getDifference(ReadableInstant instant) {\n+        if (instant == null) {\n+            return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis());\n+        }\n+        return getField().getDifference(getMillis(), instant.getMillis());\n+    }\n+\n+    /**\n+     * Returns the difference between this field property instant and the one\n+     * passed in, in the units of this field. The sign of the difference\n+     * matches that of compareTo. In other words, this field property's instant\n+     * is the minuend.\n+     *\n+     * @param instant  the subtrahend, null means now\n+     * @return the difference in the units of this field\n+     * @see DateTimeField#getDifference\n+     */\n+    public long getDifferenceAsLong(ReadableInstant instant) {\n+        if (instant == null) {\n+            return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis());\n+        }\n+        return getField().getDifferenceAsLong(getMillis(), instant.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField\n+     */\n+    public DurationField getDurationField() {\n+        return getField().getDurationField();\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return getField().getRangeDurationField();\n+    }\n+\n+    /**\n+     * Gets whether this field is leap.\n+     * \n+     * @return true if a leap field\n+     * @see DateTimeField#isLeap\n+     */\n+    public boolean isLeap() {\n+        return getField().isLeap(getMillis());\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is leap.\n+     * \n+     * @return the amount by which the field is leap\n+     * @see DateTimeField#getLeapAmount\n+     */\n+    public int getLeapAmount() {\n+        return getField().getLeapAmount(getMillis());\n+    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return getField().getLeapDurationField();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the minimum value for the field ignoring the current time.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValueOverall() {\n+        return getField().getMinimumValue();\n+    }\n+\n+    /**\n+     * Gets the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     * @see DateTimeField#getMinimumValue\n+     */\n+    public int getMinimumValue() {\n+        return getField().getMinimumValue(getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field ignoring the current time.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValueOverall() {\n+        return getField().getMaximumValue();\n+    }\n+\n+    /**\n+     * Gets the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     * @see DateTimeField#getMaximumValue\n+     */\n+    public int getMaximumValue() {\n+        return getField().getMaximumValue(getMillis());\n+    }\n+\n+    /**\n+     * Gets the maximum text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumTextLength\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        return getField().getMaximumTextLength(locale);\n+    }\n+\n+    /**\n+     * Gets the maximum short text length for the field.\n+     * \n+     * @param locale  optional locale to use for selecting a text symbol\n+     * @return the maximum length\n+     * @see DateTimeField#getMaximumShortTextLength\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getField().getMaximumShortTextLength(locale);\n+    }\n+\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field.\n+     *\n+     * @see DateTimeField#remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder() {\n+        return getField().remainder(getMillis());\n+    }\n+\n+    /**\n+     * Returns the interval that represents the range of the minimum\n+     * and maximum values of this field.\n+     * <p>\n+     * For example, <code>datetime.monthOfYear().toInterval()</code>\n+     * will return an interval over the whole month.\n+     *\n+     * @return the interval of this field\n+     * @since 1.2\n+     */\n+    public Interval toInterval() {\n+        DateTimeField field = getField();\n+        long start = field.roundFloor(getMillis());\n+        long end = field.add(start, 1);\n+        Interval interval = new Interval(start, end);\n+        return interval;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another instant.\n+     * <p>\n+     * The comparison is based on the value of the same field type, irrespective\n+     * of any difference in chronology. Thus, if this property represents the\n+     * hourOfDay field, then the hourOfDay field of the other instant will be queried\n+     * whether in the same chronology or not.\n+     * \n+     * @param instant  the instant to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the instant is null\n+     */\n+    public int compareTo(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = instant.get(getFieldType());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare this field to the same field on another partial instant.\n+     * <p>\n+     * The comparison is based on the value of the same field type, irrespective\n+     * of any difference in chronology. Thus, if this property represents the\n+     * hourOfDay field, then the hourOfDay field of the other partial will be queried\n+     * whether in the same chronology or not.\n+     * \n+     * @param partial  the partial to compare to\n+     * @return negative value if this is less, 0 if equal, or positive value if greater\n+     * @throws IllegalArgumentException if the partial is null\n+     * @throws IllegalArgumentException if the partial doesn't support this field\n+     */\n+    public int compareTo(ReadablePartial partial) {\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        int thisValue = get();\n+        int otherValue = partial.get(getFieldType());\n+        if (thisValue < otherValue) {\n+            return -1;\n+        } else if (thisValue > otherValue) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this property to another.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (object instanceof AbstractReadableInstantFieldProperty == false) {\n+            return false;\n+        }\n+        AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;\n+        return \n+            get() == other.get() &&\n+            getFieldType().equals(other.getFieldType()) &&\n+            FieldUtils.equals(getChronology(), other.getChronology());\n+    }\n+\n+    /**\n+     * Returns a hashcode compatible with the equals method.\n+     * \n+     * @return the hashcode\n+     */\n+    public int hashCode() {\n+        return get() * 17 + getFieldType().hashCode() + getChronology().hashCode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output a debugging string.\n+     * \n+     * @return debugging string\n+     */\n+    public String toString() {\n+        return \"Property[\" + getName() + \"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/BaseDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * BaseDateTimeField provides the common behaviour for DateTimeField\n+ * implementations. \n+ * <p>\n+ * This class should generally not be used directly by API users. The\n+ * DateTimeField class should be used when different kinds of DateTimeField\n+ * objects are to be referenced.\n+ * <p>\n+ * BaseDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DecoratedDateTimeField\n+ */\n+public abstract class BaseDateTimeField extends DateTimeField {\n+\n+    /** The field type. */\n+    private final DateTimeFieldType iType;\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected BaseDateTimeField(DateTimeFieldType type) {\n+        super();\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type must not be null\");\n+        }\n+        iType = type;\n+    }\n+    \n+    public final DateTimeFieldType getType() {\n+        return iType;\n+    }\n+\n+    public final String getName() {\n+        return iType.getName();\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public final boolean isSupported() {\n+        return true;\n+    }\n+\n+    // Main access API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the value of the field, in the units of the field\n+     */\n+    public abstract int get(long instant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsText(get(instant), locale).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null means default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        return getAsText(get(instant), locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * <p>\n+     * The default implementation calls {@link #getAsText(long, Locale)}.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the text value of the field\n+     */\n+    public final String getAsText(long instant) {\n+        return getAsText(instant, null);\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsText(fieldValue, locale).\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {\n+        return getAsText(fieldValue, locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation calls {@link ReadablePartial#get(DateTimeFieldType)}\n+     * and {@link #getAsText(ReadablePartial, int, Locale)}.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public final String getAsText(ReadablePartial partial, Locale locale) {\n+        return getAsText(partial, partial.get(getType()), locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from the field value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns Integer.toString(get(instant)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumTextLength.\n+     *\n+     * @param fieldValue  the numeric value to convert to text\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(int fieldValue, Locale locale) {\n+        return Integer.toString(fieldValue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the human-readable, short text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsShortText(get(instant), locale).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null means default\n+     * @return the text value of the field\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        return getAsShortText(get(instant), locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the milliseconds.\n+     * <p>\n+     * The default implementation calls {@link #getAsShortText(long, Locale)}.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the text value of the field\n+     */\n+    public final String getAsShortText(long instant) {\n+        return getAsShortText(instant, null);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsShortText(fieldValue, locale).\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {\n+        return getAsShortText(fieldValue, locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation calls {@link ReadablePartial#get(DateTimeFieldType)}\n+     * and {@link #getAsText(ReadablePartial, int, Locale)}.\n+     *\n+     * @param partial  the partial instant to query\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public final String getAsShortText(ReadablePartial partial, Locale locale) {\n+        return getAsShortText(partial, partial.get(getType()), locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the field value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsText(fieldValue, locale).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumShortTextLength.\n+     *\n+     * @param fieldValue  the numeric value to convert to text\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsShortText(int fieldValue, Locale locale) {\n+        return getAsText(fieldValue, locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * overflowing into larger fields if necessary.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field, larger fields will increase as required.\n+     * Smaller fields should be unaffected, except where the result would be\n+     * an invalid value for a smaller field. In this case the smaller field is\n+     * adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 add six months is 2001-02-20<br>\n+     * 2000-08-20 add twenty months is 2002-04-20<br>\n+     * 2000-08-20 add minus nine months is 1999-11-20<br>\n+     * 2001-01-31 add one month  is 2001-02-28<br>\n+     * 2001-01-31 add two months is 2001-03-31<br>\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long add(long instant, int value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * overflowing into larger fields if necessary.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the long value to add, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if value is too large\n+     * @see #add(long,int)\n+     */\n+    public long add(long instant, long value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * throwing an exception if the maximum size of the instant is reached.\n+     * <p>\n+     * The value will be added to this field, overflowing into larger fields\n+     * if necessary. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * Partial instants only contain some fields. This may result in a maximum\n+     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this\n+     * limit is breached by the add an exception is thrown.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 add six months is 2000-02-20<br>\n+     * 2000-08-20 add twenty months is 2000-04-20<br>\n+     * 2000-08-20 add minus nine months is 2000-11-20<br>\n+     * 2001-01-31 add one month  is 2001-02-28<br>\n+     * 2001-01-31 add two months is 2001-03-31<br>\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the partial\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n+     */\n+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        if (valueToAdd == 0) {\n+            return values;\n+        }\n+        // there are more efficient algorithms than this (especially for time only fields)\n+        // trouble is when dealing with days and months, so we use this technique of\n+        // adding/removing one from the larger field at a time\n+        DateTimeField nextField = null;\n+        \n+        while (valueToAdd > 0) {\n+            int max = getMaximumValue(instant, values);\n+            long proposed = values[fieldIndex] + valueToAdd;\n+            if (proposed <= max) {\n+                values[fieldIndex] = (int) proposed;\n+                break;\n+            }\n+            if (nextField == null) {\n+                if (fieldIndex == 0) {\n+                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n+                }\n+                nextField = instant.getField(fieldIndex - 1);\n+                // test only works if this field is UTC (ie. local)\n+                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n+                    throw new IllegalArgumentException(\"Fields invalid for add\");\n+                }\n+            }\n+            valueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add\n+            values = nextField.add(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field\n+            values[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero\n+        }\n+        while (valueToAdd < 0) {\n+            int min = getMinimumValue(instant, values);\n+            long proposed = values[fieldIndex] + valueToAdd;\n+            if (proposed >= min) {\n+                values[fieldIndex] = (int) proposed;\n+                break;\n+            }\n+            if (nextField == null) {\n+                if (fieldIndex == 0) {\n+                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n+                }\n+                nextField = instant.getField(fieldIndex - 1);\n+                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n+                    throw new IllegalArgumentException(\"Fields invalid for add\");\n+                }\n+            }\n+            valueToAdd -= (min - 1) - values[fieldIndex];  // reduce the amount to add\n+            values = nextField.add(instant, fieldIndex - 1, values, -1);  // subtract 1 from next bigger field\n+            values[fieldIndex] = getMaximumValue(instant, values);  // reset this field to max value\n+        }\n+        \n+        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * wrapping the whole partial if the maximum size of the partial is reached.\n+     * <p>\n+     * The value will be added to this field, overflowing into larger fields\n+     * if necessary. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * Partial instants only contain some fields. This may result in a maximum\n+     * possible value, such as TimeOfDay normally being limited to 23:59:59:999.\n+     * If ths limit is reached by the addition, this method will wrap back to\n+     * 00:00:00.000. In fact, you would generally only use this method for\n+     * classes that have a limitation such as this.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 10:20:30 add 20 minutes is 10:40:30<br>\n+     * 10:20:30 add 45 minutes is 11:05:30<br>\n+     * 10:20:30 add 16 hours is 02:20:30<br>\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the partial\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n+     */\n+    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        if (valueToAdd == 0) {\n+            return values;\n+        }\n+        // there are more efficient algorithms than this (especially for time only fields)\n+        // trouble is when dealing with days and months, so we use this technique of\n+        // adding/removing one from the larger field at a time\n+        DateTimeField nextField = null;\n+        \n+        while (valueToAdd > 0) {\n+            int max = getMaximumValue(instant, values);\n+            long proposed = values[fieldIndex] + valueToAdd;\n+            if (proposed <= max) {\n+                values[fieldIndex] = (int) proposed;\n+                break;\n+            }\n+            if (nextField == null) {\n+                if (fieldIndex == 0) {\n+                    valueToAdd -= (max + 1) - values[fieldIndex];\n+                    values[fieldIndex] = getMinimumValue(instant, values);\n+                    continue;\n+                }\n+                nextField = instant.getField(fieldIndex - 1);\n+                // test only works if this field is UTC (ie. local)\n+                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n+                    throw new IllegalArgumentException(\"Fields invalid for add\");\n+                }\n+            }\n+            valueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add\n+            values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field\n+            values[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero\n+        }\n+        while (valueToAdd < 0) {\n+            int min = getMinimumValue(instant, values);\n+            long proposed = values[fieldIndex] + valueToAdd;\n+            if (proposed >= min) {\n+                values[fieldIndex] = (int) proposed;\n+                break;\n+            }\n+            if (nextField == null) {\n+                if (fieldIndex == 0) {\n+                    valueToAdd -= (min - 1) - values[fieldIndex];\n+                    values[fieldIndex] = getMaximumValue(instant, values);\n+                    continue;\n+                }\n+                nextField = instant.getField(fieldIndex - 1);\n+                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n+                    throw new IllegalArgumentException(\"Fields invalid for add\");\n+                }\n+            }\n+            valueToAdd -= (min - 1) - values[fieldIndex];  // reduce the amount to add\n+            values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1);  // subtract 1 from next bigger field\n+            values[fieldIndex] = getMaximumValue(instant, values);  // reset this field to max value\n+        }\n+        \n+        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addWrapField six months is 2000-02-20<br>\n+     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>\n+     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addWrapField one month  is 2001-02-28<br>\n+     * 2001-01-31 addWrapField two months is 2001-03-31<br>\n+     * <p>\n+     * The default implementation internally calls set. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long addWrapField(long instant, int value) {\n+        int current = get(instant);\n+        int wrapped = FieldUtils.getWrappedValue\n+            (current, value, getMinimumValue(instant), getMaximumValue(instant));\n+        return set(instant, wrapped);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addWrapField six months is 2000-02-20<br>\n+     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>\n+     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addWrapField one month  is 2001-02-28<br>\n+     * 2001-01-31 addWrapField two months is 2001-03-31<br>\n+     * <p>\n+     * The default implementation internally calls set. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        int current = values[fieldIndex];\n+        int wrapped = FieldUtils.getWrappedValue\n+            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n+        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied.\n+     * <p>\n+     * The value of this field will be set.\n+     * If the value is invalid, an exception if thrown.\n+     * <p>\n+     * If setting this field would make other fields invalid, then those fields\n+     * may be changed. For example if the current date is the 31st January, and\n+     * the month is set to February, the day would be invalid. Instead, the day\n+     * would be changed to the closest value - the 28th/29th February as appropriate.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  the value to set, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract long set(long instant, int value);\n+\n+    /**\n+     * Sets a value using the specified partial instant.\n+     * <p>\n+     * The value of this field (specified by the index) will be set.\n+     * If the value is invalid, an exception if thrown.\n+     * <p>\n+     * If setting this field would make other fields invalid, then those fields\n+     * may be changed. For example if the current date is the 31st January, and\n+     * the month is set to February, the day would be invalid. Instead, the day\n+     * would be changed to the closest value - the 28th/29th February as appropriate.\n+     * \n+     * @param partial  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values to update\n+     * @param newValue  the value to set, in the units of the field\n+     * @return the updated values\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) {\n+        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values));\n+        values[fieldIndex] = newValue;\n+        \n+        // may need to adjust smaller fields\n+        for (int i = fieldIndex + 1; i < partial.size(); i++) {\n+            DateTimeField field = partial.getField(i);\n+            if (values[i] > field.getMaximumValue(partial, values)) {\n+                values[i] = field.getMaximumValue(partial, values);\n+            }\n+            if (values[i] < field.getMinimumValue(partial, values)) {\n+                values[i] = field.getMinimumValue(partial, values);\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * This implementation uses <code>convertText(String, Locale)</code> and\n+     * {@link #set(long, int)}.\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getAsText.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        int value = convertText(text, locale);\n+        return set(instant, value);\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text value.\n+     * <p>\n+     * This implementation uses {@link #set(long, String, Locale)}.\n+     * <p>\n+     * Note: subclasses that override this method should also override getAsText.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public final long set(long instant, String text) {\n+        return set(instant, text, null);\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * This implementation uses <code>convertText(String, Locale)</code> and\n+     * {@link #set(ReadablePartial, int, int[], int)}.\n+     *\n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values of the partial instant which should be updated\n+     * @param text  the text value to set\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n+        int value = convertText(text, locale);\n+        return set(instant, fieldIndex, values, value);\n+    }\n+\n+    /**\n+     * Convert the specified text and locale into a value.\n+     * \n+     * @param text  the text to convert\n+     * @param locale  the locale to convert using\n+     * @return the value extracted from the text\n+     * @throws IllegalArgumentException if the text is invalid\n+     */\n+    protected int convertText(String text, Locale locale) {\n+        try {\n+            return Integer.parseInt(text);\n+        } catch (NumberFormatException ex) {\n+            throw new IllegalFieldValueException(getType(), text);\n+        }\n+    }\n+\n+    // Extra information API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the unit duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public abstract DurationField getDurationField();\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public abstract DurationField getRangeDurationField();\n+\n+    /**\n+     * Returns whether this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return true, a non leap year would return\n+     * false.\n+     * <p>\n+     * This implementation returns false.\n+     * \n+     * @return true if the field is 'leap'\n+     */\n+    public boolean isLeap(long instant) {\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return one, a non leap year would return\n+     * zero.\n+     * <p>\n+     * This implementation returns zero.\n+     */\n+    public int getLeapAmount(long instant) {\n+        return 0;\n+    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     * <p>\n+     * This implementation returns null.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Get the minimum allowable value for this field.\n+     * \n+     * @return the minimum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMinimumValue();\n+\n+    /**\n+     * Get the minimum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMinimumValue()}.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public int getMinimumValue(long instant) {\n+        return getMinimumValue();\n+    }\n+\n+    /**\n+     * Get the minimum value for this field evaluated at the specified instant.\n+     * <p>\n+     * This implementation returns the same as {@link #getMinimumValue()}.\n+     * \n+     * @param instant  the partial instant to query\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public int getMinimumValue(ReadablePartial instant) {\n+        return getMinimumValue();\n+    }\n+\n+    /**\n+     * Get the minimum value for this field using the partial instant and\n+     * the specified values.\n+     * <p>\n+     * This implementation returns the same as {@link #getMinimumValue(ReadablePartial)}.\n+     * \n+     * @param instant  the partial instant to query\n+     * @param values  the values to use\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public int getMinimumValue(ReadablePartial instant, int[] values) {\n+        return getMinimumValue(instant);\n+    }\n+\n+    /**\n+     * Get the maximum allowable value for this field.\n+     * \n+     * @return the maximum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMaximumValue();\n+\n+    /**\n+     * Get the maximum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMaximumValue()}.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public int getMaximumValue(long instant) {\n+        return getMaximumValue();\n+    }\n+\n+    /**\n+     * Get the maximum value for this field evaluated at the specified instant.\n+     * <p>\n+     * This implementation returns the same as {@link #getMaximumValue()}.\n+     * \n+     * @param instant  the partial instant to query\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public int getMaximumValue(ReadablePartial instant) {\n+        return getMaximumValue();\n+    }\n+\n+    /**\n+     * Get the maximum value for this field using the partial instant and\n+     * the specified values.\n+     * <p>\n+     * This implementation returns the same as {@link #getMaximumValue(ReadablePartial)}.\n+     * \n+     * @param instant  the partial instant to query\n+     * @param values  the values to use\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n+        return getMaximumValue(instant);\n+    }\n+\n+    /**\n+     * Get the maximum text value for this field. The default implementation\n+     * returns the equivalent of Integer.toString(getMaximumValue()).length().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum text length\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        int max = getMaximumValue();\n+        if (max >= 0) {\n+            if (max < 10) {\n+                return 1;\n+            } else if (max < 100) {\n+                return 2;\n+            } else if (max < 1000) {\n+                return 3;\n+            }\n+        }\n+        return Integer.toString(max).length();\n+    }\n+\n+    /**\n+     * Get the maximum short text value for this field. The default\n+     * implementation returns getMaximumTextLength().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum short text length\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getMaximumTextLength(locale);\n+    }\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Round to the lowest whole unit of this field. After rounding, the value\n+     * of this field and all fields of a higher magnitude are retained. The\n+     * fractional millis that cannot be expressed in whole increments of this\n+     * field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * lowest whole hour is 2002-11-02T23:00:00.000.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundFloor(long instant);\n+\n+    /**\n+     * Round to the highest whole unit of this field. The value of this field\n+     * and all fields of a higher magnitude may be incremented in order to\n+     * achieve this result. The fractional millis that cannot be expressed in\n+     * whole increments of this field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * highest whole hour is 2002-11-03T00:00:00.000.\n+     * <p>\n+     * The default implementation calls roundFloor, and if the instant is\n+     * modified as a result, adds one field unit. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundCeiling(long instant) {\n+        long newInstant = roundFloor(instant);\n+        if (newInstant != instant) {\n+            instant = add(newInstant, 1);\n+        }\n+        return instant;\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor or is exactly halfway, this function\n+     * behaves like roundFloor. If the millisecond value is closer to the\n+     * ceiling, this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfFloor(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffFromFloor <= diffToCeiling) {\n+            // Closer to the floor, or halfway - round floor\n+            return floor;\n+        } else {\n+            return ceiling;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling or is exactly halfway,\n+     * this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfCeiling(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffToCeiling <= diffFromFloor) {\n+            // Closer to the ceiling, or halfway - round ceiling\n+            return ceiling;\n+        } else {\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling, this function behaves\n+     * like roundCeiling.\n+     * <p>\n+     * If the millisecond value is exactly halfway between the floor and\n+     * ceiling, the ceiling is chosen over the floor only if it makes this\n+     * field's value even.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfEven(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffFromFloor < diffToCeiling) {\n+            // Closer to the floor - round floor\n+            return floor;\n+        } else if (diffToCeiling < diffFromFloor) {\n+            // Closer to the ceiling - round ceiling\n+            return ceiling;\n+        } else {\n+            // Round to the instant that makes this field even. If both values\n+            // make this field even (unlikely), favor the ceiling.\n+            if ((get(ceiling) & 1) == 0) {\n+                return ceiling;\n+            }\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field. In other\n+     * words, calling remainder returns the duration that roundFloor would\n+     * subtract.\n+     * <p>\n+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by\n+     * hour is 34 minutes and 56.789 seconds.\n+     * <p>\n+     * The default implementation computes\n+     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the\n+     * remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DateTimeField[\" + getName() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/BaseDurationField.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+\n+/**\n+ * BaseDurationField provides the common behaviour for DurationField\n+ * implementations.\n+ * <p>\n+ * This class should generally not be used directly by API users. The\n+ * DurationField class should be used when different kinds of DurationField\n+ * objects are to be referenced.\n+ * <p>\n+ * BaseDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DecoratedDurationField\n+ * @since 1.0\n+ */\n+public abstract class BaseDurationField extends DurationField implements Serializable {\n+\n+    /** Serialization lock. */\n+    private static final long serialVersionUID = -2554245107589433218L;\n+\n+    /** A desriptive name for the field. */\n+    private final DurationFieldType iType;\n+\n+    protected BaseDurationField(DurationFieldType type) {\n+        super();\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type must not be null\");\n+        }\n+        iType = type;\n+    }\n+\n+    public final DurationFieldType getType() {\n+        return iType;\n+    }\n+\n+    public final String getName() {\n+        return iType.getName();\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public final boolean isSupported() {\n+        return true;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public int getValue(long duration) {\n+        return FieldUtils.safeToInt(getValueAsLong(duration));\n+    }\n+\n+    /**\n+     * Get the value of this field from the milliseconds, which is approximate\n+     * if this field is imprecise.\n+     *\n+     * @param duration  the milliseconds to query, which may be negative\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public long getValueAsLong(long duration) {\n+        return duration / getUnitMillis();\n+    }\n+\n+    /**\n+     * Get the value of this field from the milliseconds relative to an\n+     * instant.\n+     *\n+     * <p>If the milliseconds is positive, then the instant is treated as a\n+     * \"start instant\". If negative, the instant is treated as an \"end\n+     * instant\".\n+     *\n+     * <p>The default implementation returns\n+     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  the start instant to calculate relative to\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public int getValue(long duration, long instant) {\n+        return FieldUtils.safeToInt(getValueAsLong(duration, instant));\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(int value) {\n+        return value * getUnitMillis();  // safe\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value, which is\n+     * approximate if this field is imprecise.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(long value) {\n+        return FieldUtils.safeMultiply(value, getUnitMillis());\n+    }\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int compareTo(DurationField otherField) {\n+        long otherMillis = otherField.getUnitMillis();\n+        long thisMillis = getUnitMillis();\n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DurationField[\" + getName() + ']';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/DecoratedDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * <code>DecoratedDateTimeField</code> extends {@link BaseDateTimeField},\n+ * implementing only the minimum required set of methods. These implemented\n+ * methods delegate to a wrapped field.\n+ * <p>\n+ * This design allows new DateTimeField types to be defined that piggyback on\n+ * top of another, inheriting all the safe method implementations from\n+ * BaseDateTimeField. Should any method require pure delegation to the\n+ * wrapped field, simply override and use the provided getWrappedField method.\n+ * <p>\n+ * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DelegatedDateTimeField\n+ */\n+public abstract class DecoratedDateTimeField extends BaseDateTimeField {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 203115783733757597L;\n+\n+    /** The DateTimeField being wrapped */\n+    private final DateTimeField iField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field being decorated\n+     * @param type  allow type to be overridden\n+     */\n+    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n+        super(type);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException(\"The field must be supported\");\n+        }\n+        iField = field;\n+    }\n+\n+    /**\n+     * Gets the wrapped date time field.\n+     * \n+     * @return the wrapped DateTimeField\n+     */\n+    public final DateTimeField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public boolean isLenient() {\n+        return iField.isLenient();\n+    }\n+\n+    public int get(long instant) {\n+        return iField.get(instant);\n+    }\n+\n+    public long set(long instant, int value) {\n+        return iField.set(instant, value);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return iField.getDurationField();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iField.getRangeDurationField();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iField.roundFloor(instant);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/DecoratedDurationField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+\n+/**\n+ * <code>DecoratedDurationField</code> extends {@link BaseDurationField},\n+ * implementing only the minimum required set of methods. These implemented\n+ * methods delegate to a wrapped field.\n+ * <p>\n+ * This design allows new DurationField types to be defined that piggyback on\n+ * top of another, inheriting all the safe method implementations from\n+ * BaseDurationField. Should any method require pure delegation to the\n+ * wrapped field, simply override and use the provided getWrappedField method.\n+ * <p>\n+ * DecoratedDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DelegatedDurationField\n+ * @since 1.0\n+ */\n+public class DecoratedDurationField extends BaseDurationField {\n+\n+    private static final long serialVersionUID = 8019982251647420015L;\n+\n+    /** The DurationField being wrapped */\n+    private final DurationField iField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the base field\n+     * @param type  the type to actually use\n+     */\n+    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n+        super(type);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException(\"The field must be supported\");\n+        }\n+        iField = field;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the wrapped duration field.\n+     * \n+     * @return the wrapped DurationField\n+     */\n+    public final DurationField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public boolean isPrecise() {\n+        return iField.isPrecise();\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return iField.getValueAsLong(duration, instant);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/DelegatedDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * <code>DelegatedDateTimeField</code> delegates each method call to the\n+ * date time field it wraps.\n+ * <p>\n+ * DelegatedDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DecoratedDateTimeField\n+ */\n+public class DelegatedDateTimeField extends DateTimeField implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -4730164440214502503L;\n+\n+    /** The DateTimeField being wrapped */\n+    private final DateTimeField iField;\n+    /** The override field type */\n+    private final DateTimeFieldType iType;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field being decorated\n+     */\n+    public DelegatedDateTimeField(DateTimeField field) {\n+        this(field, null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field being decorated\n+     * @param type  the field type override\n+     */\n+    public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n+        super();\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        iField = field;\n+        iType = (type == null ? field.getType() : type);\n+    }\n+\n+    /**\n+     * Gets the wrapped date time field.\n+     * \n+     * @return the wrapped DateTimeField\n+     */\n+    public final DateTimeField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public DateTimeFieldType getType() {\n+        return iType;\n+    }\n+\n+    public String getName() {\n+        return iType.getName();\n+    }\n+\n+    public boolean isSupported() {\n+        return iField.isSupported();\n+    }\n+\n+    public boolean isLenient() {\n+        return iField.isLenient();\n+    }\n+\n+    public int get(long instant) {\n+        return iField.get(instant);\n+    }\n+\n+    public String getAsText(long instant, Locale locale) {\n+        return iField.getAsText(instant, locale);\n+    }\n+\n+    public String getAsText(long instant) {\n+        return iField.getAsText(instant);\n+    }\n+\n+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {\n+        return iField.getAsText(partial, fieldValue, locale);\n+    }\n+\n+    public String getAsText(ReadablePartial partial, Locale locale) {\n+        return iField.getAsText(partial, locale);\n+    }\n+\n+    public String getAsText(int fieldValue, Locale locale) {\n+        return iField.getAsText(fieldValue, locale);\n+    }\n+\n+    public String getAsShortText(long instant, Locale locale) {\n+        return iField.getAsShortText(instant, locale);\n+    }\n+\n+    public String getAsShortText(long instant) {\n+        return iField.getAsShortText(instant);\n+    }\n+\n+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {\n+        return iField.getAsShortText(partial, fieldValue, locale);\n+    }\n+\n+    public String getAsShortText(ReadablePartial partial, Locale locale) {\n+        return iField.getAsShortText(partial, locale);\n+    }\n+\n+    public String getAsShortText(int fieldValue, Locale locale) {\n+        return iField.getAsShortText(fieldValue, locale);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        return iField.add(instant, fieldIndex, values, valueToAdd);\n+    }\n+\n+    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        return iField.addWrapPartial(instant, fieldIndex, values, valueToAdd);\n+    }\n+\n+    public long addWrapField(long instant, int value) {\n+        return iField.addWrapField(instant, value);\n+    }\n+\n+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        return iField.addWrapField(instant, fieldIndex, values, valueToAdd);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long set(long instant, int value) {\n+        return iField.set(instant, value);\n+    }\n+\n+    public long set(long instant, String text, Locale locale) {\n+        return iField.set(instant, text, locale);\n+    }\n+\n+    public long set(long instant, String text) {\n+        return iField.set(instant, text);\n+    }\n+\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n+        return iField.set(instant, fieldIndex, values, newValue);\n+    }\n+\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n+        return iField.set(instant, fieldIndex, values, text, locale);\n+    }\n+\n+    public DurationField getDurationField() {\n+        return iField.getDurationField();\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iField.getRangeDurationField();\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iField.isLeap(instant);\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return iField.getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iField.getLeapDurationField();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iField.getMinimumValue();\n+    }\n+\n+    public int getMinimumValue(long instant) {\n+        return iField.getMinimumValue(instant);\n+    }\n+\n+    public int getMinimumValue(ReadablePartial instant) {\n+        return iField.getMinimumValue(instant);\n+    }\n+\n+    public int getMinimumValue(ReadablePartial instant, int[] values) {\n+        return iField.getMinimumValue(instant, values);\n+    }\n+\n+    public int getMaximumValue() {\n+        return iField.getMaximumValue();\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        return iField.getMaximumValue(instant);\n+    }\n+\n+    public int getMaximumValue(ReadablePartial instant) {\n+        return iField.getMaximumValue(instant);\n+    }\n+\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n+        return iField.getMaximumValue(instant, values);\n+    }\n+\n+    public int getMaximumTextLength(Locale locale) {\n+        return iField.getMaximumTextLength(locale);\n+    }\n+\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return iField.getMaximumShortTextLength(locale);\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iField.roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return iField.roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return iField.roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return iField.roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return iField.roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return iField.remainder(instant);\n+    }\n+\n+    public String toString() {\n+        return (\"DateTimeField[\" + getName() + ']');\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/DelegatedDurationField.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+\n+/**\n+ * <code>DelegatedDurationField</code> delegates each method call to the\n+ * duration field it wraps.\n+ * <p>\n+ * DelegatedDurationField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see DecoratedDurationField\n+ * @since 1.0\n+ */\n+public class DelegatedDurationField extends DurationField implements Serializable {\n+\n+    /** Serialization lock. */\n+    private static final long serialVersionUID = -5576443481242007829L;\n+\n+    /** The DurationField being wrapped */\n+    private final DurationField iField;\n+    /** The field type */\n+    private final DurationFieldType iType;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the base field\n+     */\n+    protected DelegatedDurationField(DurationField field) {\n+        this(field, null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the base field\n+     * @param type  the field type to use\n+     */\n+    protected DelegatedDurationField(DurationField field, DurationFieldType type) {\n+        super();\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        iField = field;\n+        iType = (type == null ? field.getType() : type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the wrapped duration field.\n+     * \n+     * @return the wrapped DurationField\n+     */\n+    public final DurationField getWrappedField() {\n+        return iField;\n+    }\n+\n+    public DurationFieldType getType() {\n+        return iType;\n+    }\n+\n+    public String getName() {\n+        return iType.getName();\n+    }\n+\n+    /**\n+     * Returns true if this field is supported.\n+     */\n+    public boolean isSupported() {\n+        return iField.isSupported();\n+    }\n+\n+    public boolean isPrecise() {\n+        return iField.isPrecise();\n+    }\n+    \n+    public int getValue(long duration) {\n+        return iField.getValue(duration);\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return iField.getValueAsLong(duration);\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return iField.getValue(duration, instant);\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return iField.getValueAsLong(duration, instant);\n+    }\n+\n+    public long getMillis(int value) {\n+        return iField.getMillis(value);\n+    }\n+\n+    public long getMillis(long value) {\n+        return iField.getMillis(value);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return iField.getMillis(value, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return iField.add(instant, value);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getUnitMillis() {\n+        return iField.getUnitMillis();\n+    }\n+\n+    public int compareTo(DurationField durationField) {\n+        return iField.compareTo(durationField);\n+    }\n+\n+    public String toString() {\n+        return (iType == null) ? iField.toString() :\n+            (\"DurationField[\" + iType + ']');\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/DividedDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Divides a DateTimeField such that the retrieved values are reduced by a\n+ * fixed divisor. The field's unit duration is scaled accordingly, but the\n+ * range duration is unchanged.\n+ * <p>\n+ * DividedDateTimeField is thread-safe and immutable.\n+ *\n+ * @see RemainderDateTimeField\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class DividedDateTimeField extends DecoratedDateTimeField {\n+\n+    private static final long serialVersionUID = 8318475124230605365L;\n+\n+    // Shared with RemainderDateTimeField.\n+    final int iDivisor;\n+    final DurationField iDurationField;\n+\n+    private final int iMin;\n+    private final int iMax;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param type  the field type this field will actually use\n+     * @param divisor  divisor, such as 100 years in a century\n+     * @throws IllegalArgumentException if divisor is less than two\n+     */\n+    public DividedDateTimeField(DateTimeField field,\n+                                DateTimeFieldType type, int divisor) {\n+        super(field, type);\n+                \n+        if (divisor < 2) {\n+            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n+        }\n+\n+        DurationField unitField = field.getDurationField();\n+        if (unitField == null) {\n+            iDurationField = null;\n+        } else {\n+            iDurationField = new ScaledDurationField(\n+                unitField, type.getDurationType(), divisor);\n+        }\n+\n+        iDivisor = divisor;\n+\n+        int i = field.getMinimumValue();\n+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n+\n+        int j = field.getMaximumValue();\n+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n+\n+        iMin = min;\n+        iMax = max;\n+    }\n+\n+    /**\n+     * Construct a DividedDateTimeField that compliments the given\n+     * RemainderDateTimeField.\n+     *\n+     * @param remainderField  complimentary remainder field, like \"yearOfCentury()\".\n+     * @param type  the field type this field will actually use\n+     */\n+    public DividedDateTimeField(RemainderDateTimeField remainderField, DateTimeFieldType type) {\n+        super(remainderField.getWrappedField(), type);\n+        int divisor = iDivisor = remainderField.iDivisor;\n+        iDurationField = remainderField.iRangeField;\n+\n+        DateTimeField field = getWrappedField();\n+        int i = field.getMinimumValue();\n+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n+\n+        int j = field.getMaximumValue();\n+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n+\n+        iMin = min;\n+        iMax = max;\n+    }\n+\n+    /**\n+     * Get the amount of scaled units from the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the amount of scaled units extracted from the input.\n+     */\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n+        if (value >= 0) {\n+            return value / iDivisor;\n+        } else {\n+            return ((value + 1) / iDivisor) - 1;\n+        }\n+    }\n+\n+    /**\n+     * Add the specified amount of scaled units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int amount) {\n+        return getWrappedField().add(instant, amount * iDivisor);\n+    }\n+\n+    /**\n+     * Add the specified amount of scaled units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, long amount) {\n+        return getWrappedField().add(instant, amount * iDivisor);\n+    }\n+\n+    /**\n+     * Add to the scaled component of the specified time instant,\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of scaled units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int amount) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iDivisor;\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iDivisor;\n+    }\n+\n+    /**\n+     * Set the specified amount of scaled units to the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param value  value of scaled units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n+        int remainder = getRemainder(getWrappedField().get(instant));\n+        return getWrappedField().set(instant, value * iDivisor + remainder);\n+    }\n+\n+    /**\n+     * Returns a scaled version of the wrapped field's unit duration field.\n+     */\n+    public DurationField getDurationField() {\n+        return iDurationField;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return iMin;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iMax;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        DateTimeField field = getWrappedField();\n+        return field.roundFloor(field.set(instant, get(instant) * iDivisor));\n+    }\n+\n+    public long remainder(long instant) {\n+        return set(instant, get(getWrappedField().remainder(instant)));\n+    }\n+\n+    /**\n+     * Returns the divisor applied, in the field's units.\n+     * \n+     * @return the divisor\n+     */\n+    public int getDivisor() {\n+        return iDivisor;\n+    }\n+\n+    private int getRemainder(int value) {\n+        if (value >= 0) {\n+            return value % iDivisor;\n+        } else {\n+            return (iDivisor - 1) + ((value + 1) % iDivisor);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/FieldUtils.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.IllegalFieldValueException;\n+\n+/**\n+ * General utilities that don't fit elsewhere.\n+ * <p>\n+ * FieldUtils is thread-safe and immutable.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class FieldUtils {\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private FieldUtils() {\n+        super();\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    /**\n+     * Negates the input throwing an exception if it can't negate it.\n+     * \n+     * @param value  the value to negate\n+     * @return the negated value\n+     * @throws ArithmeticException if the value is Integer.MIN_VALUE\n+     * @since 1.1\n+     */\n+    public static int safeNegate(int value) {\n+        if (value == Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\");\n+        }\n+        return -value;\n+    }\n+    \n+    /**\n+     * Add two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static int safeAdd(int val1, int val2) {\n+        int sum = val1 + val2;\n+        // If there is a sign change, but the two values have the same sign...\n+        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n+        }\n+        return sum;\n+    }\n+    \n+    /**\n+     * Add two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static long safeAdd(long val1, long val2) {\n+        long sum = val1 + val2;\n+        // If there is a sign change, but the two values have the same sign...\n+        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n+        }\n+        return sum;\n+    }\n+    \n+    /**\n+     * Subtracts two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value, to be taken away from\n+     * @param val2  the second value, the amount to take away\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static long safeSubtract(long val1, long val2) {\n+        long diff = val1 - val2;\n+        // If there is a sign change, but the two values have different signs...\n+        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n+        }\n+        return diff;\n+    }\n+    \n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     * @since 1.2\n+     */\n+    public static int safeMultiply(int val1, int val2) {\n+        long total = (long) val1 * (long) val2;\n+        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" * \" + val2);\n+        }\n+        return (int) total;\n+    }\n+\n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param scalar  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     * @since 1.2\n+     */\n+    public static long safeMultiply(long val1, int scalar) {\n+        switch (scalar) {\n+        case -1:\n+            return -val1;\n+        case 0:\n+            return 0L;\n+        case 1:\n+            return val1;\n+        }\n+        long total = val1 * scalar;\n+        if (total / scalar != val1) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" * \" + scalar);\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Multiply two values throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static long safeMultiply(long val1, long val2) {\n+        if (val2 == 1) {\n+            return val1;\n+        }\n+        if (val2 == 0) {\n+            return 0;\n+        }\n+        long total = val1 * val2;\n+        if (total / val2 != val1) {\n+            throw new ArithmeticException\n+                (\"The calculation caused an overflow: \" + val1 + \" * \" + val2);\n+        }\n+        return total;\n+    }\n+    \n+    /**\n+     * Casts to an int throwing an exception if overflow occurs.\n+     * \n+     * @param value  the value\n+     * @return the value as an int\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static int safeToInt(long value) {\n+        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n+            return (int) value;\n+        }\n+        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n+    }\n+    \n+    /**\n+     * Multiply two values to return an int throwing an exception if overflow occurs.\n+     * \n+     * @param val1  the first value\n+     * @param val2  the second value\n+     * @return the new total\n+     * @throws ArithmeticException if the value is too big or too small\n+     */\n+    public static int safeMultiplyToInt(long val1, long val2) {\n+        long val = FieldUtils.safeMultiply(val1, val2);\n+        return FieldUtils.safeToInt(val);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalFieldValueException if value is not in the specified bounds\n+     */\n+    public static void verifyValueBounds(DateTimeField field, \n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value < lowerBound) || (value > upperBound)) {\n+            throw new IllegalFieldValueException\n+                (field.getType(), new Integer(value),\n+                 new Integer(lowerBound), new Integer(upperBound));\n+        }\n+    }\n+\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalFieldValueException if value is not in the specified bounds\n+     * @since 1.1\n+     */\n+    public static void verifyValueBounds(DateTimeFieldType fieldType, \n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value < lowerBound) || (value > upperBound)) {\n+            throw new IllegalFieldValueException\n+                (fieldType, new Integer(value),\n+                 new Integer(lowerBound), new Integer(upperBound));\n+        }\n+    }\n+\n+    /**\n+     * Verify that input values are within specified bounds.\n+     * \n+     * @param value  the value to check\n+     * @param lowerBound  the lower bound allowed for value\n+     * @param upperBound  the upper bound allowed for value\n+     * @throws IllegalFieldValueException if value is not in the specified bounds\n+     */\n+    public static void verifyValueBounds(String fieldName,\n+                                         int value, int lowerBound, int upperBound) {\n+        if ((value < lowerBound) || (value > upperBound)) {\n+            throw new IllegalFieldValueException\n+                (fieldName, new Integer(value),\n+                 new Integer(lowerBound), new Integer(upperBound));\n+        }\n+    }\n+\n+    /**\n+     * Utility method used by addWrapField implementations to ensure the new\n+     * value lies within the field's legal value range.\n+     *\n+     * @param currentValue the current value of the data, which may lie outside\n+     * the wrapped value range\n+     * @param wrapValue  the value to add to current value before\n+     *  wrapping.  This may be negative.\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    public static int getWrappedValue(int currentValue, int wrapValue,\n+                                      int minValue, int maxValue) {\n+        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n+    }\n+\n+    /**\n+     * Utility method that ensures the given value lies within the field's\n+     * legal value range.\n+     * \n+     * @param value  the value to fit into the wrapped value range\n+     * @param minValue the wrap range minimum value.\n+     * @param maxValue the wrap range maximum value.  This must be\n+     *  greater than minValue (checked by the method).\n+     * @return the wrapped value\n+     * @throws IllegalArgumentException if minValue is greater\n+     *  than or equal to maxValue\n+     */\n+    public static int getWrappedValue(int value, int minValue, int maxValue) {\n+        if (minValue >= maxValue) {\n+            throw new IllegalArgumentException(\"MIN > MAX\");\n+        }\n+\n+        int wrapRange = maxValue - minValue + 1;\n+        value -= minValue;\n+\n+        if (value >= 0) {\n+            return (value % wrapRange) + minValue;\n+        }\n+\n+        int remByRange = (-value) % wrapRange;\n+\n+        if (remByRange == 0) {\n+            return 0 + minValue;\n+        }\n+        return (wrapRange - remByRange) + minValue;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two objects as equals handling null.\n+     * \n+     * @param object1  the first object\n+     * @param object2  the second object\n+     * @return true if equal\n+     * @since 1.4\n+     */\n+    public static boolean equals(Object object1, Object object2) {\n+        if (object1 == object2) {\n+            return true;\n+        }\n+        if (object1 == null || object2 == null) {\n+            return false;\n+        }\n+        return object1.equals(object2);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/ImpreciseDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+\n+/**\n+ * Abstract datetime field class that defines its own DurationField, which\n+ * delegates back into this ImpreciseDateTimeField.\n+ * <p>\n+ * This DateTimeField is useful for defining DateTimeFields that are composed\n+ * of imprecise durations. If both duration fields are precise, then a\n+ * {@link PreciseDateTimeField} should be used instead.\n+ * <p>\n+ * When defining imprecise DateTimeFields where a matching DurationField is\n+ * already available, just extend BaseDateTimeField directly so as not to\n+ * create redundant DurationField instances.\n+ * <p>\n+ * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @see PreciseDateTimeField\n+ * @since 1.0\n+ */\n+public abstract class ImpreciseDateTimeField extends BaseDateTimeField {\n+\n+    private static final long serialVersionUID = 7190739608550251860L;\n+\n+    final long iUnitMillis;\n+    private final DurationField iDurationField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param type  the field type\n+     * @param unitMillis  the average duration unit milliseconds\n+     */\n+    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n+        super(type);\n+        iUnitMillis = unitMillis;\n+        iDurationField = new LinkedDurationField(type.getDurationType());\n+    }\n+\n+    public abstract int get(long instant);\n+\n+    public abstract long set(long instant, int value);\n+\n+    public abstract long add(long instant, int value);\n+\n+    public abstract long add(long instant, long value);\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     * <p>\n+     * The default implementation call getDifferenceAsLong and converts the\n+     * return value to an int.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     * <p>\n+     * The default implementation performs a guess-and-check algorithm using\n+     * getDurationField().getUnitMillis() and the add() method. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifferenceAsLong(subtrahendInstant, minuendInstant);\n+        }\n+        \n+        long difference = (minuendInstant - subtrahendInstant) / iUnitMillis;\n+        if (add(subtrahendInstant, difference) < minuendInstant) {\n+            do {\n+                difference++;\n+            } while (add(subtrahendInstant, difference) <= minuendInstant);\n+            difference--;\n+        } else if (add(subtrahendInstant, difference) > minuendInstant) {\n+            do {\n+                difference--;\n+            } while (add(subtrahendInstant, difference) > minuendInstant);\n+        }\n+        return difference;\n+    }\n+\n+    public final DurationField getDurationField() {\n+        return iDurationField;\n+    }\n+\n+    public abstract DurationField getRangeDurationField();\n+\n+    public abstract long roundFloor(long instant);\n+\n+    protected final long getDurationUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    private final class LinkedDurationField extends BaseDurationField {\n+        private static final long serialVersionUID = -203813474600094134L;\n+\n+        LinkedDurationField(DurationFieldType type) {\n+            super(type);\n+        }\n+    \n+        public boolean isPrecise() {\n+            return false;\n+        }\n+    \n+        public long getUnitMillis() {\n+            return iUnitMillis;\n+        }\n+\n+        public int getValue(long duration, long instant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifference(instant + duration, instant);\n+        }\n+\n+        public long getValueAsLong(long duration, long instant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifferenceAsLong(instant + duration, instant);\n+        }\n+        \n+        public long getMillis(int value, long instant) {\n+            return ImpreciseDateTimeField.this.add(instant, value) - instant;\n+        }\n+\n+        public long getMillis(long value, long instant) {\n+            return ImpreciseDateTimeField.this.add(instant, value) - instant;\n+        }\n+\n+        public long add(long instant, int value) {\n+            return ImpreciseDateTimeField.this.add(instant, value);\n+        }\n+        \n+        public long add(long instant, long value) {\n+            return ImpreciseDateTimeField.this.add(instant, value);\n+        }\n+        \n+        public int getDifference(long minuendInstant, long subtrahendInstant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifference(minuendInstant, subtrahendInstant);\n+        }\n+        \n+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+            return ImpreciseDateTimeField.this\n+                .getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/LenientDateTimeField.java\n+/*\n+ *  Copyright 2001-2007 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Converts a strict DateTimeField into a lenient one. By being lenient, the\n+ * set method accepts out of bounds values, performing an addition instead.\n+ * <p>\n+ * LenientDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @see org.joda.time.chrono.LenientChronology\n+ * @see StrictDateTimeField\n+ * @since 1.0\n+ */\n+public class LenientDateTimeField extends DelegatedDateTimeField {\n+\n+    private static final long serialVersionUID = 8714085824173290599L;\n+\n+    private final Chronology iBase;\n+\n+    /**\n+     * Returns a lenient version of the given field. If it is already lenient,\n+     * then it is returned as-is. Otherwise, a new LenientDateTimeField is\n+     * returned.\n+     */\n+    public static DateTimeField getInstance(DateTimeField field, Chronology base) {\n+        if (field == null) {\n+            return null;\n+        }\n+        if (field instanceof StrictDateTimeField) {\n+            field = ((StrictDateTimeField)field).getWrappedField();\n+        }\n+        if (field.isLenient()) {\n+            return field;\n+        }\n+        return new LenientDateTimeField(field, base);\n+    }\n+\n+    protected LenientDateTimeField(DateTimeField field, Chronology base) {\n+        super(field);\n+        iBase = base;\n+    }\n+\n+    public final boolean isLenient() {\n+        return true;\n+    }\n+\n+    /**\n+     * Set values which may be out of bounds by adding the difference between\n+     * the new value and the current value.\n+     */\n+    public long set(long instant, int value) {\n+        // lenient needs to handle time zone chronologies\n+        // so we do the calculation using local milliseconds\n+        long localInstant = iBase.getZone().convertUTCToLocal(instant);\n+        long difference = FieldUtils.safeSubtract(value, get(instant));\n+        localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n+        return iBase.getZone().convertLocalToUTC(localInstant, false);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/MillisDurationField.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+\n+/**\n+ * Duration field class representing a field with a fixed unit length of one\n+ * millisecond.\n+ * <p>\n+ * MillisDurationField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class MillisDurationField extends DurationField implements Serializable {\n+\n+    /** Serialization lock. */\n+    private static final long serialVersionUID = 2656707858124633367L;\n+\n+    /** Singleton instance. */\n+    public static final DurationField INSTANCE = new MillisDurationField();\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private MillisDurationField() {\n+        super();\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    public DurationFieldType getType() {\n+        return DurationFieldType.millis();\n+    }\n+\n+    public String getName() {\n+        return \"millis\";\n+    }\n+\n+    /**\n+     * Returns true as this field is supported.\n+     * \n+     * @return true always\n+     */\n+    public boolean isSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true as this field is precise.\n+     * \n+     * @return true always\n+     */\n+    public final boolean isPrecise() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the amount of milliseconds per unit value of this field.\n+     *\n+     * @return one always\n+     */\n+    public final long getUnitMillis() {\n+        return 1;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int getValue(long duration) {\n+        return FieldUtils.safeToInt(duration);\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return duration;\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return FieldUtils.safeToInt(duration);\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return duration;\n+    }\n+\n+    public long getMillis(int value) {\n+        return value;\n+    }\n+\n+    public long getMillis(long value) {\n+        return value;\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        return value;\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        return value;\n+    }\n+\n+    public long add(long instant, int value) {\n+        return FieldUtils.safeAdd(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return FieldUtils.safeAdd(instant, value);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant));\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);\n+    }\n+\n+    //------------------------------------------------------------------------\n+    public int compareTo(DurationField otherField) {\n+        long otherMillis = otherField.getUnitMillis();\n+        long thisMillis = getUnitMillis();\n+        // cannot do (thisMillis - otherMillis) as can overflow\n+        if (thisMillis == otherMillis) {\n+            return 0;\n+        }\n+        if (thisMillis < otherMillis) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DurationField[millis]\";\n+    }\n+\n+    /**\n+     * Deserialize to the singleton.\n+     */\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/OffsetDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Generic offset adjusting datetime field.\n+ * <p>\n+ * OffsetDateTimeField is thread-safe and immutable.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class OffsetDateTimeField extends DecoratedDateTimeField {\n+    private static final long serialVersionUID = 3145790132623583142L;\n+\n+    private final int iOffset;\n+\n+    private final int iMin;\n+    private final int iMax;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param offset  offset to add to field values\n+     * @throws IllegalArgumentException if offset is zero\n+     */\n+    public OffsetDateTimeField(DateTimeField field, int offset) {\n+        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param type  the field type this field actually uses\n+     * @param offset  offset to add to field values\n+     * @throws IllegalArgumentException if offset is zero\n+     */\n+    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n+        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param type  the field type this field actually uses\n+     * @param offset  offset to add to field values\n+     * @param minValue  minimum allowed value\n+     * @param maxValue  maximum allowed value\n+     * @throws IllegalArgumentException if offset is zero\n+     */\n+    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n+                               int minValue, int maxValue) {\n+        super(field, type);\n+                \n+        if (offset == 0) {\n+            throw new IllegalArgumentException(\"The offset cannot be zero\");\n+        }\n+\n+        iOffset = offset;\n+\n+        if (minValue < (field.getMinimumValue() + offset)) {\n+            iMin = field.getMinimumValue() + offset;\n+        } else {\n+            iMin = minValue;\n+        }\n+        if (maxValue > (field.getMaximumValue() + offset)) {\n+            iMax = field.getMaximumValue() + offset;\n+        } else {\n+            iMax = maxValue;\n+        }\n+    }\n+\n+    /**\n+     * Get the amount of offset units from the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the amount of units extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return super.get(instant) + iOffset;\n+    }\n+\n+    /**\n+     * Add the specified amount of offset units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int amount) {\n+        instant = super.add(instant, amount);\n+        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);\n+        return instant;\n+    }\n+\n+    /**\n+     * Add the specified amount of offset units to the specified time\n+     * instant. The amount added may be negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, long amount) {\n+        instant = super.add(instant, amount);\n+        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);\n+        return instant;\n+    }\n+\n+    /**\n+     * Add to the offset component of the specified time instant,\n+     * wrapping around within that component if necessary.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int amount) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));\n+    }\n+\n+    /**\n+     * Set the specified amount of offset units to the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param value  value of units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n+        return super.set(instant, value - iOffset);\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return getWrappedField().isLeap(instant);\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return getWrappedField().getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return getWrappedField().getLeapDurationField();\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return iMin;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iMax;\n+    }\n+    \n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Returns the offset added to the field values.\n+     * \n+     * @return the offset\n+     */\n+    public int getOffset() {\n+        return iOffset;\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/PreciseDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Precise datetime field, composed of two precise duration fields.\n+ * <p>\n+ * This DateTimeField is useful for defining DateTimeFields that are composed\n+ * of precise durations, like time of day fields. If either duration field is\n+ * imprecise, then an {@link ImpreciseDateTimeField} may be used instead.\n+ * <p>\n+ * PreciseDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see ImpreciseDateTimeField\n+ */\n+public class PreciseDateTimeField extends PreciseDurationDateTimeField {\n+\n+    private static final long serialVersionUID = -5586801265774496376L;\n+\n+    /** The maximum range in the correct units */\n+    private final int iRange;\n+\n+    private final DurationField iRangeField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param type  the field type this field uses\n+     * @param unit  precise unit duration, like \"seconds()\".\n+     * @param range precise range duration, preferably a multiple of the unit,\n+     * like \"minutes()\".\n+     * @throws IllegalArgumentException if either duration field is imprecise\n+     * @throws IllegalArgumentException if unit milliseconds is less than one\n+     * or effective value range is less than two.\n+     */\n+    public PreciseDateTimeField(DateTimeFieldType type,\n+                                DurationField unit, DurationField range) {\n+        super(type, unit);\n+\n+        if (!range.isPrecise()) {\n+            throw new IllegalArgumentException(\"Range duration field must be precise\");\n+        }\n+\n+        long rangeMillis = range.getUnitMillis();\n+        iRange = (int)(rangeMillis / getUnitMillis());\n+        if (iRange < 2) {\n+            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n+        }\n+\n+        iRangeField = range;\n+    }\n+\n+    /**\n+     * Get the amount of fractional units from the specified time instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the amount of fractional units extracted from the input.\n+     */\n+    public int get(long instant) {\n+        if (instant >= 0) {\n+            return (int) ((instant / getUnitMillis()) % iRange);\n+        } else {\n+            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n+        }\n+    }\n+\n+    /**\n+     * Add to the component of the specified time instant, wrapping around\n+     * within that component if necessary.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param amount  the amount of units to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int amount) {\n+        int thisValue = get(instant);\n+        int wrappedValue = FieldUtils.getWrappedValue\n+            (thisValue, amount, getMinimumValue(), getMaximumValue());\n+        // copy code from set() to avoid repeat call to get()\n+        return instant + (wrappedValue - thisValue) * getUnitMillis();\n+    }\n+\n+    /**\n+     * Set the specified amount of units to the specified time instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  value of units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\n+        return instant + (value - get(instant)) * iUnitMillis;\n+    }\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"minute of hour\", then the range duration field is an hours.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public DurationField getRangeDurationField() {\n+        return iRangeField;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iRange - 1;\n+    }\n+    \n+    /**\n+     * Returns the range of the field in the field's units.\n+     * <p>\n+     * For example, 60 for seconds per minute. The field is allowed values\n+     * from 0 to range - 1.\n+     * \n+     * @return unit range\n+     */\n+    public int getRange() {\n+        return iRange;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Precise datetime field, which has a precise unit duration field.\n+ * <p>\n+ * PreciseDurationDateTimeField is thread-safe and immutable, and its\n+ * subclasses must be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public abstract class PreciseDurationDateTimeField extends BaseDateTimeField {\n+\n+    private static final long serialVersionUID = 5004523158306266035L;\n+\n+    /** The fractional unit in millis */\n+    final long iUnitMillis;\n+\n+    private final DurationField iUnitField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param type  the field type\n+     * @param unit  precise unit duration, like \"days()\".\n+     * @throws IllegalArgumentException if duration field is imprecise\n+     * @throws IllegalArgumentException if unit milliseconds is less than one\n+     */\n+    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n+        super(type);\n+\n+        if (!unit.isPrecise()) {\n+            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n+        }\n+\n+        iUnitMillis = unit.getUnitMillis();\n+        if (iUnitMillis < 1) {\n+            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n+        }\n+\n+        iUnitField = unit;\n+    }\n+\n+    /**\n+     * Returns false by default.\n+     */\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Set the specified amount of units to the specified time instant.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  value of units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),\n+                                     getMaximumValueForSet(instant, value));\n+        return instant + (value - get(instant)) * iUnitMillis;\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n+     * </pre>\n+     */\n+    public long roundFloor(long instant) {\n+        if (instant >= 0) {\n+            return instant - instant % iUnitMillis;\n+        } else {\n+            instant += 1;\n+            return instant - instant % iUnitMillis - iUnitMillis;\n+        }\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n+     * </pre>\n+     */\n+    public long roundCeiling(long instant) {\n+        if (instant > 0) {\n+            instant -= 1;\n+            return instant - instant % iUnitMillis + iUnitMillis;\n+        } else {\n+            return instant - instant % iUnitMillis;\n+        }\n+    }\n+\n+    /**\n+     * This method assumes that this field is properly rounded on\n+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n+     * method as follows:\n+     * <pre>\n+     * return super.remainder(instant + ALIGNMENT_MILLIS);\n+     * </pre>\n+     */\n+    public long remainder(long instant) {\n+        if (instant >= 0) {\n+            return instant % iUnitMillis;\n+        } else {\n+            return (instant + 1) % iUnitMillis + iUnitMillis - 1;\n+        }\n+    }\n+\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"minute of hour\", then the duration field is minutes.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public DurationField getDurationField() {\n+        return iUnitField;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field.\n+     * \n+     * @return the minimum value\n+     */\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+\n+    public final long getUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    /**\n+     * Called by the set method to get the maximum allowed value. By default,\n+     * returns getMaximumValue(instant). Override to provide a faster\n+     * implementation.\n+     */\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return getMaximumValue(instant);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/PreciseDurationField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DurationFieldType;\n+\n+/**\n+ * Duration field class representing a field with a fixed unit length.\n+ * <p>\n+ * PreciseDurationField is thread-safe and immutable.\n+ * \n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class PreciseDurationField extends BaseDurationField {\n+    \n+    private static final long serialVersionUID = -8346152187724495365L;\n+\n+    /** The size of the unit */\n+    private final long iUnitMillis;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param type  the field type\n+     * @param unitMillis  the unit milliseconds\n+     */    \n+    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n+        super(type);\n+        iUnitMillis = unitMillis;\n+    }\n+    \n+    //------------------------------------------------------------------------\n+    /**\n+     * This field is precise.\n+     * \n+     * @return true always\n+     */\n+    public final boolean isPrecise() {\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns the amount of milliseconds per unit value of this field.\n+     *\n+     * @return the unit size of this field, in milliseconds\n+     */\n+    public final long getUnitMillis() {\n+        return iUnitMillis;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param duration  the milliseconds to query, which may be negative\n+     * @param instant  ignored\n+     * @return the value of the field, in the units of the field, which may be\n+     * negative\n+     */\n+    public long getValueAsLong(long duration, long instant) {\n+        return duration / iUnitMillis;  // safe\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @param instant  ignored\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(int value, long instant) {\n+        return value * iUnitMillis;  // safe\n+    }\n+\n+    /**\n+     * Get the millisecond duration of this field from its value.\n+     * \n+     * @param value  the value of the field, which may be negative\n+     * @param instant  ignored\n+     * @return the milliseconds that the field represents, which may be\n+     * negative\n+     */\n+    public long getMillis(long value, long instant) {\n+        return FieldUtils.safeMultiply(value, iUnitMillis);\n+    }\n+\n+    public long add(long instant, int value) {\n+        long addition = value * iUnitMillis;  // safe\n+        return FieldUtils.safeAdd(instant, addition);\n+    }\n+\n+    public long add(long instant, long value) {\n+        long addition = FieldUtils.safeMultiply(value, iUnitMillis);\n+        return FieldUtils.safeAdd(instant, addition);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        long difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);\n+        return difference / iUnitMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this duration field to another.\n+     * Two fields are equal if of the same type and duration.\n+     * \n+     * @param obj  the object to compare to\n+     * @return if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        } else if (obj instanceof PreciseDurationField) {\n+            PreciseDurationField other = (PreciseDurationField) obj;\n+            return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for this instance.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        long millis = iUnitMillis;\n+        int hash = (int) (millis ^ (millis >>> 32));\n+        hash += getType().hashCode();\n+        return hash;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/RemainderDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+\n+/**\n+ * Counterpart remainder datetime field to {@link DividedDateTimeField}. The\n+ * field's unit duration is unchanged, but the range duration is scaled\n+ * accordingly.\n+ * <p>\n+ * RemainderDateTimeField is thread-safe and immutable.\n+ *\n+ * @see DividedDateTimeField\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class RemainderDateTimeField extends DecoratedDateTimeField {\n+\n+    private static final long serialVersionUID = 5708241235177666790L;\n+\n+    // Shared with DividedDateTimeField.\n+    final int iDivisor;\n+    final DurationField iRangeField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param type  the field type this field actually uses\n+     * @param divisor  divisor, such as 100 years in a century\n+     * @throws IllegalArgumentException if divisor is less than two\n+     */\n+    public RemainderDateTimeField(DateTimeField field,\n+                                  DateTimeFieldType type, int divisor) {\n+        super(field, type);\n+\n+        if (divisor < 2) {\n+            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n+        }\n+\n+        DurationField rangeField = field.getDurationField();\n+        if (rangeField == null) {\n+            iRangeField = null;\n+        } else {\n+            iRangeField = new ScaledDurationField(\n+                rangeField, type.getRangeDurationType(), divisor);\n+        }\n+\n+        iDivisor = divisor;\n+    }\n+\n+    /**\n+     * Construct a RemainderDateTimeField that compliments the given\n+     * DividedDateTimeField.\n+     *\n+     * @param dividedField  complimentary divided field, like \"century()\".\n+     */\n+    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n+        this(dividedField, dividedField.getType());\n+    }\n+\n+    /**\n+     * Construct a RemainderDateTimeField that compliments the given\n+     * DividedDateTimeField.\n+     *\n+     * @param dividedField  complimentary divided field, like \"century()\".\n+     * @param type  the field type this field actually uses\n+     */\n+    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n+        super(dividedField.getWrappedField(), type);\n+        iDivisor = dividedField.iDivisor;\n+        iRangeField = dividedField.iDurationField;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the remainder from the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to query.\n+     * @return the remainder extracted from the input.\n+     */\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n+        if (value >= 0) {\n+            return value % iDivisor;\n+        } else {\n+            return (iDivisor - 1) + ((value + 1) % iDivisor);\n+        }\n+    }\n+\n+    /**\n+     * Add the specified amount to the specified time instant, wrapping around\n+     * within the remainder range if necessary. The amount added may be\n+     * negative.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param amount  the amount to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int amount) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));\n+    }\n+\n+    /**\n+     * Set the specified amount of remainder units to the specified time instant.\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param value  value of remainder units to set.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException if value is too large or too small.\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1);\n+        int divided = getDivided(getWrappedField().get(instant));\n+        return getWrappedField().set(instant, divided * iDivisor + value);\n+    }\n+\n+    /**\n+     * Returns a scaled version of the wrapped field's unit duration field.\n+     */\n+    public DurationField getRangeDurationField() {\n+        return iRangeField;\n+    }\n+\n+    /**\n+     * Get the minimum value for the field, which is always zero.\n+     * \n+     * @return the minimum value of zero.\n+     */\n+    public int getMinimumValue() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is always one less than the\n+     * divisor.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return iDivisor - 1;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+    /**\n+     * Returns the divisor applied, in the field's units.\n+     * \n+     * @return the divisor\n+     */\n+    public int getDivisor() {\n+        return iDivisor;\n+    }\n+\n+    private int getDivided(int value) {\n+        if (value >= 0) {\n+            return value / iDivisor;\n+        } else {\n+            return ((value + 1) / iDivisor) - 1;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/ScaledDurationField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+\n+/**\n+ * Scales a DurationField such that it's unit millis becomes larger in\n+ * magnitude.\n+ * <p>\n+ * ScaledDurationField is thread-safe and immutable.\n+ *\n+ * @see PreciseDurationField\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class ScaledDurationField extends DecoratedDurationField {\n+\n+    private static final long serialVersionUID = -3205227092378684157L;\n+\n+    private final int iScalar;\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param type  the type this field will actually use\n+     * @param scalar  scalar, such as 100 years in a century\n+     * @throws IllegalArgumentException if scalar is zero or one.\n+     */\n+    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n+        super(field, type);\n+        if (scalar == 0 || scalar == 1) {\n+            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n+        }\n+        iScalar = scalar;\n+    }\n+\n+    public int getValue(long duration) {\n+        return getWrappedField().getValue(duration) / iScalar;\n+    }\n+\n+    public long getValueAsLong(long duration) {\n+        return getWrappedField().getValueAsLong(duration) / iScalar;\n+    }\n+\n+    public int getValue(long duration, long instant) {\n+        return getWrappedField().getValue(duration, instant) / iScalar;\n+    }\n+\n+    public long getValueAsLong(long duration, long instant) {\n+        return getWrappedField().getValueAsLong(duration, instant) / iScalar;\n+    }\n+\n+    public long getMillis(int value) {\n+        long scaled = ((long) value) * ((long) iScalar);\n+        return getWrappedField().getMillis(scaled);\n+    }\n+\n+    public long getMillis(long value) {\n+        long scaled = FieldUtils.safeMultiply(value, iScalar);\n+        return getWrappedField().getMillis(scaled);\n+    }\n+\n+    public long getMillis(int value, long instant) {\n+        long scaled = ((long) value) * ((long) iScalar);\n+        return getWrappedField().getMillis(scaled, instant);\n+    }\n+\n+    public long getMillis(long value, long instant) {\n+        long scaled = FieldUtils.safeMultiply(value, iScalar);\n+        return getWrappedField().getMillis(scaled, instant);\n+    }\n+\n+    public long add(long instant, int value) {\n+        long scaled = ((long) value) * ((long) iScalar);\n+        return getWrappedField().add(instant, scaled);\n+    }\n+\n+    public long add(long instant, long value) {\n+        long scaled = FieldUtils.safeMultiply(value, iScalar);\n+        return getWrappedField().add(instant, scaled);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar;\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar;\n+    }\n+\n+    public long getUnitMillis() {\n+        return getWrappedField().getUnitMillis() * iScalar;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the scalar applied, in the field's units.\n+     * \n+     * @return the scalar\n+     */\n+    public int getScalar() {\n+        return iScalar;\n+    }\n+\n+    /**\n+     * Compares this duration field to another.\n+     * Two fields are equal if of the same type and duration.\n+     * \n+     * @param obj  the object to compare to\n+     * @return if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        } else if (obj instanceof ScaledDurationField) {\n+            ScaledDurationField other = (ScaledDurationField) obj;\n+            return (getWrappedField().equals(other.getWrappedField())) &&\n+                   (getType() == other.getType()) &&\n+                   (iScalar == other.iScalar);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for this instance.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        long scalar = iScalar;\n+        int hash = (int) (scalar ^ (scalar >>> 32));\n+        hash += getType().hashCode();\n+        hash += getWrappedField().hashCode();\n+        return hash;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/SkipDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.IllegalFieldValueException;\n+\n+/**\n+ * Wraps another field such that a certain value is skipped.\n+ * <p>\n+ * This is most useful for years where you want to skip zero, so the\n+ * sequence runs ...,2,1,-1,-2,...\n+ * <p>\n+ * SkipDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class SkipDateTimeField extends DelegatedDateTimeField {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -8869148464118507846L;\n+\n+    /** The chronology to wrap. */\n+    private final Chronology iChronology;\n+    /** The value to skip. */\n+    private final int iSkip;\n+    /** The calculated minimum value. */\n+    private transient int iMinValue;\n+\n+    /**\n+     * Constructor that skips zero.\n+     * \n+     * @param chronology  the chronoogy to use\n+     * @param field  the field to skip zero on\n+     */\n+    public SkipDateTimeField(Chronology chronology, DateTimeField field) {\n+        this(chronology, field, 0);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param chronology  the chronoogy to use\n+     * @param field  the field to skip zero on\n+     * @param skip  the value to skip\n+     */\n+    public SkipDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n+        super(field);\n+        iChronology = chronology;\n+        int min = super.getMinimumValue();\n+        if (min < skip) {\n+            iMinValue = min - 1;\n+        } else if (min == skip) {\n+            iMinValue = skip + 1;\n+        } else {\n+            iMinValue = min;\n+        }\n+        iSkip = skip;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int get(long millis) {\n+        int value = super.get(millis);\n+        if (value <= iSkip) {\n+            value--;\n+        }\n+        return value;\n+    }\n+\n+    public long set(long millis, int value) {\n+        FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());\n+        if (value <= iSkip) {\n+            if (value == iSkip) {\n+                throw new IllegalFieldValueException\n+                    (DateTimeFieldType.year(), new Integer(value), null, null);\n+            }\n+            value++;\n+        }\n+        return super.set(millis, value);\n+    }\n+\n+    public int getMinimumValue() {\n+        return iMinValue;\n+    }\n+\n+    private Object readResolve() {\n+        return getType().getField(iChronology);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/SkipUndoDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Wraps another field such that a certain value is added back into\n+ * the sequence of numbers.\n+ * <p>\n+ * This reverses the effect of SkipDateTimeField. This isn't very\n+ * elegant.\n+ * <p>\n+ * SkipUndoDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class SkipUndoDateTimeField extends DelegatedDateTimeField {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -5875876968979L;\n+\n+    /** The chronology to wrap. */\n+    private final Chronology iChronology;\n+    /** The value to skip. */\n+    private final int iSkip;\n+    /** The calculated minimum value. */\n+    private transient int iMinValue;\n+\n+    /**\n+     * Constructor that reinserts zero.\n+     * \n+     * @param chronology  the chronoogy to use\n+     * @param field  the field to skip zero on\n+     */\n+    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {\n+        this(chronology, field, 0);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param chronology  the chronoogy to use\n+     * @param field  the field to skip zero on\n+     * @param skip  the value to skip\n+     */\n+    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n+        super(field);\n+        iChronology = chronology;\n+        int min = super.getMinimumValue();\n+        if (min < skip) {\n+            iMinValue = min + 1;\n+        } else if (min == skip + 1) {\n+            iMinValue = skip;\n+        } else {\n+            iMinValue = min;\n+        }\n+        iSkip = skip;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int get(long millis) {\n+        int value = super.get(millis);\n+        if (value < iSkip) {\n+            value++;\n+        }\n+        return value;\n+    }\n+\n+    public long set(long millis, int value) {\n+        FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());\n+        if (value <= iSkip) {\n+            value--;\n+        }\n+        return super.set(millis, value);\n+    }\n+\n+    public int getMinimumValue() {\n+        return iMinValue;\n+    }\n+\n+    private Object readResolve() {\n+        return getType().getField(iChronology);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/StrictDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Converts a lenient DateTimeField into a strict one. By being strict, the set\n+ * throws an IllegalArgumentException if the value is out of bounds.\n+ * <p>\n+ * StrictDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @see org.joda.time.chrono.StrictChronology\n+ * @see LenientDateTimeField\n+ * @since 1.0\n+ */\n+public class StrictDateTimeField extends DelegatedDateTimeField {\n+\n+    private static final long serialVersionUID = 3154803964207950910L;\n+\n+    /**\n+     * Returns a strict version of the given field. If it is already strict,\n+     * then it is returned as-is. Otherwise, a new StrictDateTimeField is\n+     * returned.\n+     */\n+    public static DateTimeField getInstance(DateTimeField field) {\n+        if (field == null) {\n+            return null;\n+        }\n+        if (field instanceof LenientDateTimeField) {\n+            field = ((LenientDateTimeField)field).getWrappedField();\n+        }\n+        if (!field.isLenient()) {\n+            return field;\n+        }\n+        return new StrictDateTimeField(field);\n+    }\n+\n+    protected StrictDateTimeField(DateTimeField field) {\n+        super(field);\n+    }\n+\n+    public final boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Does a bounds check before setting the value.\n+     *\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public long set(long instant, int value) {\n+        FieldUtils.verifyValueBounds\n+            (this, value, getMinimumValue(instant), getMaximumValue(instant));\n+        return super.set(instant, value);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/UnsupportedDateTimeField.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * A placeholder implementation to use when a datetime field is not supported.\n+ * <p>\n+ * UnsupportedDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class UnsupportedDateTimeField extends DateTimeField implements Serializable {\n+\n+    /** Serialilzation version */\n+    private static final long serialVersionUID = -1934618396111902255L;\n+\n+    /** The cache of unsupported datetime field instances */\n+    private static HashMap<DateTimeFieldType, UnsupportedDateTimeField> cCache;\n+\n+    /**\n+     * Gets an instance of UnsupportedDateTimeField for a specific named field.\n+     * Names should be of standard format, such as 'monthOfYear' or 'hourOfDay'.\n+     * The returned instance is cached.\n+     * \n+     * @param type  the type to obtain\n+     * @return the instance\n+     * @throws IllegalArgumentException if durationField is null\n+     */\n+    public static synchronized UnsupportedDateTimeField getInstance(\n+            DateTimeFieldType type, DurationField durationField) {\n+\n+        UnsupportedDateTimeField field;\n+        if (cCache == null) {\n+            cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7);\n+            field = null;\n+        } else {\n+            field = cCache.get(type);\n+            if (field != null && field.getDurationField() != durationField) {\n+                field = null;\n+            }\n+        }\n+        if (field == null) {\n+            field = new UnsupportedDateTimeField(type, durationField);\n+            cCache.put(type, field);\n+        }\n+        return field;\n+    }\n+\n+    /** The field type */\n+    private final DateTimeFieldType iType;\n+    /** The duration of the datetime field */\n+    private final DurationField iDurationField;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param type  the field type\n+     * @param durationField  the duration to use\n+     */\n+    private UnsupportedDateTimeField(DateTimeFieldType type, DurationField durationField) {\n+        if (type == null || durationField == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        iType = type;\n+        iDurationField = durationField;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Design note: Simple accessors return a suitable value, but methods\n+    // intended to perform calculations throw an UnsupportedOperationException.\n+\n+    public DateTimeFieldType getType() {\n+        return iType;\n+    }\n+\n+    public String getName() {\n+        return iType.getName();\n+    }\n+\n+    /**\n+     * This field is not supported.\n+     *\n+     * @return false always\n+     */\n+    public boolean isSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * This field is not lenient.\n+     *\n+     * @return false always\n+     */\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int get(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(ReadablePartial partial, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsText(int fieldValue, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(ReadablePartial partial, int fieldValue, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(ReadablePartial partial, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public String getAsShortText(int fieldValue, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long add(long instant, int value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long add(long instant, long value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long addWrapField(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Delegates to the duration field.\n+     *\n+     * @throws UnsupportedOperationException if the duration is unsupported\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long set(long instant, String text) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Even though this DateTimeField is unsupported, the duration field might\n+     * be supported.\n+     *\n+     * @return a possibly supported DurationField\n+     */\n+    public DurationField getDurationField() {\n+        return iDurationField;\n+    }\n+\n+    /**\n+     * Always returns null.\n+     *\n+     * @return null always\n+     */\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public boolean isLeap(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getLeapAmount(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always returns null.\n+     *\n+     * @return null always\n+     */\n+    public DurationField getLeapDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue() {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue(ReadablePartial instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMinimumValue(ReadablePartial instant, int[] values) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue() {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue(ReadablePartial instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundFloor(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundCeiling(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfFloor(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfCeiling(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long roundHalfEven(long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long remainder(long instant) {\n+        throw unsupported();\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"UnsupportedDateTimeField\";\n+    }\n+\n+    /**\n+     * Ensure proper singleton serialization\n+     */\n+    private Object readResolve() {\n+        return getInstance(iType, iDurationField);\n+    }\n+\n+    private UnsupportedOperationException unsupported() {\n+        return new UnsupportedOperationException(iType + \" field is unsupported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+\n+/**\n+ * A placeholder implementation to use when a duration field is not supported.\n+ * <p>\n+ * UnsupportedDurationField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class UnsupportedDurationField extends DurationField implements Serializable {\n+\n+    /** Serialization lock. */\n+    private static final long serialVersionUID = -6390301302770925357L;\n+\n+    /** The cache of unsupported duration field instances */\n+    private static HashMap<DurationFieldType, UnsupportedDurationField> cCache;\n+\n+    /**\n+     * Gets an instance of UnsupportedDurationField for a specific named field.\n+     * The returned instance is cached.\n+     * \n+     * @param type  the type to obtain\n+     * @return the instance\n+     */\n+    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n+        UnsupportedDurationField field;\n+        if (cCache == null) {\n+            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n+            field = null;\n+        } else {\n+            field = cCache.get(type);\n+        }\n+        if (field == null) {\n+            field = new UnsupportedDurationField(type);\n+            cCache.put(type, field);\n+        }\n+        return field;\n+    }\n+\n+    /** The name of the field */\n+    private final DurationFieldType iType;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param type  the type to use\n+     */\n+    private UnsupportedDurationField(DurationFieldType type) {\n+        iType = type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Design note: Simple Accessors return a suitable value, but methods\n+    // intended to perform calculations throw an UnsupportedOperationException.\n+\n+    public final DurationFieldType getType() {\n+        return iType;\n+    }\n+\n+    public String getName() {\n+        return iType.getName();\n+    }\n+\n+    /**\n+     * This field is not supported.\n+     *\n+     * @return false always\n+     */\n+    public boolean isSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * This field is precise.\n+     * \n+     * @return true always\n+     */\n+    public boolean isPrecise() {\n+        return true;\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getValue(long duration) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getValueAsLong(long duration) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getValue(long duration, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getValueAsLong(long duration, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(long value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(int value, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getMillis(long value, long instant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long add(long instant, int value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long add(long instant, long value) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        throw unsupported();\n+    }\n+\n+    /**\n+     * Always returns zero.\n+     *\n+     * @return zero always\n+     */\n+    public long getUnitMillis() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Always returns zero, indicating that sort order is not relevent.\n+     *\n+     * @return zero always\n+     */\n+    public int compareTo(DurationField durationField) {\n+        return 0;\n+    }\n+\n+    //------------------------------------------------------------------------\n+    /**\n+     * Compares this duration field to another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        } else if (obj instanceof UnsupportedDurationField) {\n+            UnsupportedDurationField other = (UnsupportedDurationField) obj;\n+            if (other.getName() == null) {\n+                return (getName() == null);\n+            }\n+            return (other.getName().equals(getName()));\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a suitable hashcode.\n+     * \n+     * @return the hashcode\n+     */\n+    public int hashCode() {\n+        return getName().hashCode();\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"UnsupportedDurationField[\" + getName() + ']';\n+    }\n+\n+    /**\n+     * Ensure proper singleton serialization\n+     */\n+    private Object readResolve() {\n+        return getInstance(iType);\n+    }\n+\n+    private UnsupportedOperationException unsupported() {\n+        return new UnsupportedOperationException(iType + \" field is unsupported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/field/ZeroIsMaxDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * Wraps another field such that zero values are replaced with one more than\n+ * it's maximum. This is particularly useful for implementing an clockhourOfDay\n+ * field, where the midnight value of 0 is replaced with 24.\n+ * <p>\n+ * ZeroIsMaxDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class ZeroIsMaxDateTimeField extends DecoratedDateTimeField {\n+\n+    private static final long serialVersionUID = 961749798233026866L;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the base field\n+     * @param type  the field type this field will actually use\n+     * @throws IllegalArgumentException if wrapped field's minimum value is not zero\n+     */\n+    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n+        super(field, type);\n+        if (field.getMinimumValue() != 0) {\n+            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n+        }\n+    }\n+\n+    public int get(long instant) {\n+        int value = getWrappedField().get(instant);\n+        if (value == 0) {\n+            value = getMaximumValue();\n+        }\n+        return value;\n+    }\n+\n+    public long add(long instant, int value) {\n+        return getWrappedField().add(instant, value);\n+    }\n+\n+    public long add(long instant, long value) {\n+        return getWrappedField().add(instant, value);\n+    }\n+\n+    public long addWrapField(long instant, int value) {\n+        return getWrappedField().addWrapField(instant, value);\n+    }\n+\n+    public int[] addWrapField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n+        return getWrappedField().addWrapField(instant, fieldIndex, values, valueToAdd);\n+    }\n+\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public long set(long instant, int value) {\n+        int max = getMaximumValue();\n+        FieldUtils.verifyValueBounds(this, value, 1, max);\n+        if (value == max) {\n+            value = 0;\n+        }\n+        return getWrappedField().set(instant, value);\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return getWrappedField().isLeap(instant);\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return getWrappedField().getLeapAmount(instant);\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return getWrappedField().getLeapDurationField();\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue(long instant) {\n+        return 1;\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue(ReadablePartial instant) {\n+        return 1;\n+    }\n+\n+    /**\n+     * Always returns 1.\n+     * \n+     * @return the minimum value of 1\n+     */\n+    public int getMinimumValue(ReadablePartial instant, int[] values) {\n+        return 1;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is one more than the wrapped\n+     * field's maximum value.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue() {\n+        return getWrappedField().getMaximumValue() + 1;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is one more than the wrapped\n+     * field's maximum value.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue(long instant) {\n+        return getWrappedField().getMaximumValue(instant) + 1;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is one more than the wrapped\n+     * field's maximum value.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue(ReadablePartial instant) {\n+        return getWrappedField().getMaximumValue(instant) + 1;\n+    }\n+\n+    /**\n+     * Get the maximum value for the field, which is one more than the wrapped\n+     * field's maximum value.\n+     * \n+     * @return the maximum value\n+     */\n+    public int getMaximumValue(ReadablePartial instant, int[] values) {\n+        return getWrappedField().getMaximumValue(instant, values) + 1;\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return getWrappedField().roundFloor(instant);\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        return getWrappedField().roundCeiling(instant);\n+    }\n+\n+    public long roundHalfFloor(long instant) {\n+        return getWrappedField().roundHalfFloor(instant);\n+    }\n+\n+    public long roundHalfCeiling(long instant) {\n+        return getWrappedField().roundHalfCeiling(instant);\n+    }\n+\n+    public long roundHalfEven(long instant) {\n+        return getWrappedField().roundHalfEven(instant);\n+    }\n+\n+    public long remainder(long instant) {\n+        return getWrappedField().remainder(instant);\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeFormat.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * Factory that creates instances of DateTimeFormatter from patterns and styles.\n+ * <p>\n+ * Datetime formatting is performed by the {@link DateTimeFormatter} class.\n+ * Three classes provide factory methods to create formatters, and this is one.\n+ * The others are {@link ISODateTimeFormat} and {@link DateTimeFormatterBuilder}.\n+ * <p>\n+ * This class provides two types of factory:\n+ * <ul>\n+ * <li>{@link #forPattern(String) Pattern} provides a DateTimeFormatter based on\n+ * a pattern string that is mostly compatible with the JDK date patterns.\n+ * <li>{@link #forStyle(String) Style} provides a DateTimeFormatter based on a\n+ * two character style, representing short, medium, long and full.\n+ * </ul>\n+ * <p>\n+ * For example, to use a patterm:\n+ * <pre>\n+ * DateTime dt = new DateTime();\n+ * DateTimeFormatter fmt = DateTimeFormat.forPattern(\"MMMM, yyyy\");\n+ * String str = fmt.print(dt);\n+ * </pre>\n+ *\n+ * The pattern syntax is mostly compatible with java.text.SimpleDateFormat -\n+ * time zone names cannot be parsed and a few more symbols are supported.\n+ * All ASCII letters are reserved as pattern letters, which are defined as follows:\n+ * <blockquote>\n+ * <pre>\n+ * Symbol  Meaning                      Presentation  Examples\n+ * ------  -------                      ------------  -------\n+ * G       era                          text          AD\n+ * C       century of era (&gt;=0)         number        20\n+ * Y       year of era (&gt;=0)            year          1996\n+ *\n+ * x       weekyear                     year          1996\n+ * w       week of weekyear             number        27\n+ * e       day of week                  number        2\n+ * E       day of week                  text          Tuesday; Tue\n+ *\n+ * y       year                         year          1996\n+ * D       day of year                  number        189\n+ * M       month of year                month         July; Jul; 07\n+ * d       day of month                 number        10\n+ *\n+ * a       halfday of day               text          PM\n+ * K       hour of halfday (0~11)       number        0\n+ * h       clockhour of halfday (1~12)  number        12\n+ *\n+ * H       hour of day (0~23)           number        0\n+ * k       clockhour of day (1~24)      number        24\n+ * m       minute of hour               number        30\n+ * s       second of minute             number        55\n+ * S       fraction of second           number        978\n+ *\n+ * z       time zone                    text          Pacific Standard Time; PST\n+ * Z       time zone offset/id          zone          -0800; -08:00; America/Los_Angeles\n+ *\n+ * '       escape for text              delimiter\n+ * ''      single quote                 literal       '\n+ * </pre>\n+ * </blockquote>\n+ * The count of pattern letters determine the format.\n+ * <p>\n+ * <strong>Text</strong>: If the number of pattern letters is 4 or more,\n+ * the full form is used; otherwise a short or abbreviated form is used if\n+ * available.\n+ * <p>\n+ * <strong>Number</strong>: The minimum number of digits. Shorter numbers\n+ * are zero-padded to this amount.\n+ * <p>\n+ * <strong>Year</strong>: Numeric presentation for year and weekyear fields\n+ * are handled specially. For example, if the count of 'y' is 2, the year\n+ * will be displayed as the zero-based year of the century, which is two\n+ * digits.\n+ * <p>\n+ * <strong>Month</strong>: 3 or over, use text, otherwise use number.\n+ * <p>\n+ * <strong>Zone</strong>: 'Z' outputs offset without a colon, 'ZZ' outputs\n+ * the offset with a colon, 'ZZZ' or more outputs the zone id.\n+ * <p>\n+ * <strong>Zone names</strong>: Time zone names ('z') cannot be parsed.\n+ * <p>\n+ * Any characters in the pattern that are not in the ranges of ['a'..'z']\n+ * and ['A'..'Z'] will be treated as quoted text. For instance, characters\n+ * like ':', '.', ' ', '#' and '?' will appear in the resulting time text\n+ * even they are not embraced within single quotes.\n+ * <p>\n+ * DateTimeFormat is thread-safe and immutable, and the formatters it returns\n+ * are as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Maxim Zhao\n+ * @since 1.0\n+ * @see ISODateTimeFormat\n+ * @see DateTimeFormatterBuilder\n+ */\n+public class DateTimeFormat {\n+\n+    /** Style constant for FULL. */\n+    static final int FULL = 0;  // DateFormat.FULL\n+    /** Style constant for LONG. */\n+    static final int LONG = 1;  // DateFormat.LONG\n+    /** Style constant for MEDIUM. */\n+    static final int MEDIUM = 2;  // DateFormat.MEDIUM\n+    /** Style constant for SHORT. */\n+    static final int SHORT = 3;  // DateFormat.SHORT\n+    /** Style constant for NONE. */\n+    static final int NONE = 4;\n+\n+    /** Type constant for DATE only. */\n+    static final int DATE = 0;\n+    /** Type constant for TIME only. */\n+    static final int TIME = 1;\n+    /** Type constant for DATETIME. */\n+    static final int DATETIME = 2;\n+\n+    /** Maps patterns to formatters, patterns don't vary by locale. */\n+    private static final Map<String, DateTimeFormatter> cPatternedCache = new HashMap<String, DateTimeFormatter>(7);\n+    /** Maps patterns to formatters, patterns don't vary by locale. */\n+    private static final DateTimeFormatter[] cStyleCache = new DateTimeFormatter[25];\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory to create a formatter from a pattern string.\n+     * The pattern string is described above in the class level javadoc.\n+     * It is very similar to SimpleDateFormat patterns.\n+     * <p>\n+     * The format may contain locale specific output, and this will change as\n+     * you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * For example:\n+     * <pre>\n+     * DateTimeFormat.forPattern(pattern).withLocale(Locale.FRANCE).print(dt);\n+     * </pre>\n+     *\n+     * @param pattern  pattern specification\n+     * @return the formatter\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     */\n+    public static DateTimeFormatter forPattern(String pattern) {\n+        return createFormatterForPattern(pattern);\n+    }\n+\n+    /**\n+     * Factory to create a format from a two character style pattern.\n+     * <p>\n+     * The first character is the date style, and the second character is the\n+     * time style. Specify a character of 'S' for short style, 'M' for medium,\n+     * 'L' for long, and 'F' for full.\n+     * A date or time may be ommitted by specifying a style character '-'.\n+     * <p>\n+     * The returned formatter will dynamically adjust to the locale that\n+     * the print/parse takes place in. Thus you just call\n+     * {@link DateTimeFormatter#withLocale(Locale)} and the Short/Medium/Long/Full\n+     * style for that locale will be output. For example:\n+     * <pre>\n+     * DateTimeFormat.forStyle(style).withLocale(Locale.FRANCE).print(dt);\n+     * </pre>\n+     *\n+     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n+     * @return the formatter\n+     * @throws IllegalArgumentException if the style is invalid\n+     */\n+    public static DateTimeFormatter forStyle(String style) {\n+        return createFormatterForStyle(style);\n+    }\n+\n+    /**\n+     * Returns the pattern used by a particular style and locale.\n+     * <p>\n+     * The first character is the date style, and the second character is the\n+     * time style. Specify a character of 'S' for short style, 'M' for medium,\n+     * 'L' for long, and 'F' for full.\n+     * A date or time may be ommitted by specifying a style character '-'.\n+     *\n+     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n+     * @param locale  locale to use, null means default\n+     * @return the formatter\n+     * @throws IllegalArgumentException if the style is invalid\n+     * @since 1.3\n+     */\n+    public static String patternForStyle(String style, Locale locale) {\n+        DateTimeFormatter formatter = createFormatterForStyle(style);\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        // Not pretty, but it works.\n+        return ((StyleFormatter) formatter.getPrinter()).getPattern(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a format that outputs a short date format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter shortDate() {\n+        return createFormatterForStyleIndex(SHORT, NONE);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a short time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter shortTime() {\n+        return createFormatterForStyleIndex(NONE, SHORT);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a short datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter shortDateTime() {\n+        return createFormatterForStyleIndex(SHORT, SHORT);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a format that outputs a medium date format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter mediumDate() {\n+        return createFormatterForStyleIndex(MEDIUM, NONE);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a medium time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter mediumTime() {\n+        return createFormatterForStyleIndex(NONE, MEDIUM);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a medium datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter mediumDateTime() {\n+        return createFormatterForStyleIndex(MEDIUM, MEDIUM);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a format that outputs a long date format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter longDate() {\n+        return createFormatterForStyleIndex(LONG, NONE);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a long time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter longTime() {\n+        return createFormatterForStyleIndex(NONE, LONG);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a long datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter longDateTime() {\n+        return createFormatterForStyleIndex(LONG, LONG);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a format that outputs a full date format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter fullDate() {\n+        return createFormatterForStyleIndex(FULL, NONE);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a full time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter fullTime() {\n+        return createFormatterForStyleIndex(NONE, FULL);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a full datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter fullDateTime() {\n+        return createFormatterForStyleIndex(FULL, FULL);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parses the given pattern and appends the rules to the given\n+     * DateTimeFormatterBuilder.\n+     *\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     */\n+    static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n+        parsePatternTo(builder, pattern);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @since 1.1 (previously private)\n+     */\n+    protected DateTimeFormat() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parses the given pattern and appends the rules to the given\n+     * DateTimeFormatterBuilder.\n+     *\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     * @see #forPattern\n+     */\n+    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n+        int length = pattern.length();\n+        int[] indexRef = new int[1];\n+\n+        for (int i=0; i<length; i++) {\n+            indexRef[0] = i;\n+            String token = parseToken(pattern, indexRef);\n+            i = indexRef[0];\n+\n+            int tokenLen = token.length();\n+            if (tokenLen == 0) {\n+                break;\n+            }\n+            char c = token.charAt(0);\n+\n+            switch (c) {\n+            case 'G': // era designator (text)\n+                builder.appendEraText();\n+                break;\n+            case 'C': // century of era (number)\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n+                break;\n+            case 'x': // weekyear (number)\n+            case 'y': // year (number)\n+            case 'Y': // year of era (number)\n+                if (tokenLen == 2) {\n+                    boolean lenientParse = true;\n+\n+                    // Peek ahead to next token.\n+                    if (i + 1 < length) {\n+                        indexRef[0]++;\n+                        if (isNumericToken(parseToken(pattern, indexRef))) {\n+                            // If next token is a number, cannot support\n+                            // lenient parse, because it will consume digits\n+                            // that it should not.\n+                            lenientParse = false;\n+                        }\n+                        indexRef[0]--;\n+                    }\n+\n+                    // Use pivots which are compatible with SimpleDateFormat.\n+                    switch (c) {\n+                    case 'x':\n+                        builder.appendTwoDigitWeekyear\n+                            (new DateTime().getWeekyear() - 30, lenientParse);\n+                        break;\n+                    case 'y':\n+                    case 'Y':\n+                    default:\n+                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n+                        break;\n+                    }\n+                } else {\n+                    // Try to support long year values.\n+                    int maxDigits = 9;\n+\n+                    // Peek ahead to next token.\n+                    if (i + 1 < length) {\n+                        indexRef[0]++;\n+                        if (isNumericToken(parseToken(pattern, indexRef))) {\n+                            // If next token is a number, cannot support long years.\n+                            maxDigits = tokenLen;\n+                        }\n+                        indexRef[0]--;\n+                    }\n+\n+                    switch (c) {\n+                    case 'x':\n+                        builder.appendWeekyear(tokenLen, maxDigits);\n+                        break;\n+                    case 'y':\n+                        builder.appendYear(tokenLen, maxDigits);\n+                        break;\n+                    case 'Y':\n+                        builder.appendYearOfEra(tokenLen, maxDigits);\n+                        break;\n+                    }\n+                }\n+                break;\n+            case 'M': // month of year (text and number)\n+                if (tokenLen >= 3) {\n+                    if (tokenLen >= 4) {\n+                        builder.appendMonthOfYearText();\n+                    } else {\n+                        builder.appendMonthOfYearShortText();\n+                    }\n+                } else {\n+                    builder.appendMonthOfYear(tokenLen);\n+                }\n+                break;\n+            case 'd': // day of month (number)\n+                builder.appendDayOfMonth(tokenLen);\n+                break;\n+            case 'a': // am/pm marker (text)\n+                builder.appendHalfdayOfDayText();\n+                break;\n+            case 'h': // clockhour of halfday (number, 1..12)\n+                builder.appendClockhourOfHalfday(tokenLen);\n+                break;\n+            case 'H': // hour of day (number, 0..23)\n+                builder.appendHourOfDay(tokenLen);\n+                break;\n+            case 'k': // clockhour of day (1..24)\n+                builder.appendClockhourOfDay(tokenLen);\n+                break;\n+            case 'K': // hour of halfday (0..11)\n+                builder.appendHourOfHalfday(tokenLen);\n+                break;\n+            case 'm': // minute of hour (number)\n+                builder.appendMinuteOfHour(tokenLen);\n+                break;\n+            case 's': // second of minute (number)\n+                builder.appendSecondOfMinute(tokenLen);\n+                break;\n+            case 'S': // fraction of second (number)\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n+                break;\n+            case 'e': // day of week (number)\n+                builder.appendDayOfWeek(tokenLen);\n+                break;\n+            case 'E': // dayOfWeek (text)\n+                if (tokenLen >= 4) {\n+                    builder.appendDayOfWeekText();\n+                } else {\n+                    builder.appendDayOfWeekShortText();\n+                }\n+                break;\n+            case 'D': // day of year (number)\n+                builder.appendDayOfYear(tokenLen);\n+                break;\n+            case 'w': // week of weekyear (number)\n+                builder.appendWeekOfWeekyear(tokenLen);\n+                break;\n+            case 'z': // time zone (text)\n+                if (tokenLen >= 4) {\n+                    builder.appendTimeZoneName();\n+                } else {\n+                    builder.appendTimeZoneShortName();\n+                }\n+                break;\n+            case 'Z': // time zone offset\n+                if (tokenLen == 1) {\n+                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n+                } else if (tokenLen == 2) {\n+                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n+                } else {\n+                    builder.appendTimeZoneId();\n+                }\n+                break;\n+            case '\\'': // literal text\n+                String sub = token.substring(1);\n+                if (sub.length() == 1) {\n+                    builder.appendLiteral(sub.charAt(0));\n+                } else {\n+                    // Create copy of sub since otherwise the temporary quoted\n+                    // string would still be referenced internally.\n+                    builder.appendLiteral(new String(sub));\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException\n+                    (\"Illegal pattern component: \" + token);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parses an individual token.\n+     * \n+     * @param pattern  the pattern string\n+     * @param indexRef  a single element array, where the input is the start\n+     *  location and the output is the location after parsing the token\n+     * @return the parsed token\n+     */\n+    private static String parseToken(String pattern, int[] indexRef) {\n+        StringBuffer buf = new StringBuffer();\n+\n+        int i = indexRef[0];\n+        int length = pattern.length();\n+\n+        char c = pattern.charAt(i);\n+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+            // Scan a run of the same character, which indicates a time\n+            // pattern.\n+            buf.append(c);\n+\n+            while (i + 1 < length) {\n+                char peek = pattern.charAt(i + 1);\n+                if (peek == c) {\n+                    buf.append(c);\n+                    i++;\n+                } else {\n+                    break;\n+                }\n+            }\n+        } else {\n+            // This will identify token as text.\n+            buf.append('\\'');\n+\n+            boolean inLiteral = false;\n+\n+            for (; i < length; i++) {\n+                c = pattern.charAt(i);\n+                \n+                if (c == '\\'') {\n+                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n+                        // '' is treated as escaped '\n+                        i++;\n+                        buf.append(c);\n+                    } else {\n+                        inLiteral = !inLiteral;\n+                    }\n+                } else if (!inLiteral &&\n+                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n+                    i--;\n+                    break;\n+                } else {\n+                    buf.append(c);\n+                }\n+            }\n+        }\n+\n+        indexRef[0] = i;\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Returns true if token should be parsed as a numeric field.\n+     * \n+     * @param token  the token to parse\n+     * @return true if numeric field\n+     */\n+    private static boolean isNumericToken(String token) {\n+        int tokenLen = token.length();\n+        if (tokenLen > 0) {\n+            char c = token.charAt(0);\n+            switch (c) {\n+            case 'c': // century (number)\n+            case 'C': // century of era (number)\n+            case 'x': // weekyear (number)\n+            case 'y': // year (number)\n+            case 'Y': // year of era (number)\n+            case 'd': // day of month (number)\n+            case 'h': // hour of day (number, 1..12)\n+            case 'H': // hour of day (number, 0..23)\n+            case 'm': // minute of hour (number)\n+            case 's': // second of minute (number)\n+            case 'S': // fraction of second (number)\n+            case 'e': // day of week (number)\n+            case 'D': // day of year (number)\n+            case 'F': // day of week in month (number)\n+            case 'w': // week of year (number)\n+            case 'W': // week of month (number)\n+            case 'k': // hour of day (1..24)\n+            case 'K': // hour of day (0..11)\n+                return true;\n+            case 'M': // month of year (text and number)\n+                if (tokenLen <= 2) {\n+                    return true;\n+                }\n+            }\n+        }\n+            \n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Select a format from a custom pattern.\n+     *\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     * @see #appendPatternTo\n+     */\n+    private static DateTimeFormatter createFormatterForPattern(String pattern) {\n+        if (pattern == null || pattern.length() == 0) {\n+            throw new IllegalArgumentException(\"Invalid pattern specification\");\n+        }\n+        DateTimeFormatter formatter = null;\n+        synchronized (cPatternedCache) {\n+            formatter = cPatternedCache.get(pattern);\n+            if (formatter == null) {\n+                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n+                parsePatternTo(builder, pattern);\n+                formatter = builder.toFormatter();\n+\n+                cPatternedCache.put(pattern, formatter);\n+            }\n+        }\n+        return formatter;\n+    }\n+\n+    /**\n+     * Select a format from a two character style pattern. The first character\n+     * is the date style, and the second character is the time style. Specify a\n+     * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'\n+     * for full. A date or time may be ommitted by specifying a style character '-'.\n+     *\n+     * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n+     * @throws IllegalArgumentException if the style is invalid\n+     */\n+    private static DateTimeFormatter createFormatterForStyle(String style) {\n+        if (style == null || style.length() != 2) {\n+            throw new IllegalArgumentException(\"Invalid style specification: \" + style);\n+        }\n+        int dateStyle = selectStyle(style.charAt(0));\n+        int timeStyle = selectStyle(style.charAt(1));\n+        if (dateStyle == NONE && timeStyle == NONE) {\n+            throw new IllegalArgumentException(\"Style '--' is invalid\");\n+        }\n+        return createFormatterForStyleIndex(dateStyle, timeStyle);\n+    }\n+\n+    /**\n+     * Gets the formatter for the specified style.\n+     * \n+     * @param dateStyle  the date style\n+     * @param timeStyle  the time style\n+     * @return the formatter\n+     */\n+    private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {\n+        int index = ((dateStyle << 2) + dateStyle) + timeStyle;\n+        DateTimeFormatter f = null;\n+        synchronized (cStyleCache) {\n+            f = cStyleCache[index];\n+            if (f == null) {\n+                int type = DATETIME;\n+                if (dateStyle == NONE) {\n+                    type = TIME;\n+                } else if (timeStyle == NONE) {\n+                    type = DATE;\n+                }\n+                StyleFormatter llf = new StyleFormatter(\n+                        dateStyle, timeStyle, type);\n+                f = new DateTimeFormatter(llf, llf);\n+                cStyleCache[index] = f;\n+            }\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Gets the JDK style code from the Joda code.\n+     * \n+     * @param ch  the Joda style code\n+     * @return the JDK style code\n+     */\n+    private static int selectStyle(char ch) {\n+        switch (ch) {\n+        case 'S':\n+            return SHORT;\n+        case 'M':\n+            return MEDIUM;\n+        case 'L':\n+            return LONG;\n+        case 'F':\n+            return FULL;\n+        case '-':\n+            return NONE;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid style character: \" + ch);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class StyleFormatter\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        private static final Map<String, DateTimeFormatter> cCache = new HashMap<String, DateTimeFormatter>();  // manual sync\n+        \n+        private final int iDateStyle;\n+        private final int iTimeStyle;\n+        private final int iType;\n+\n+        StyleFormatter(int dateStyle, int timeStyle, int type) {\n+            super();\n+            iDateStyle = dateStyle;\n+            iTimeStyle = timeStyle;\n+            iType = type;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return 40;  // guess\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            DateTimePrinter p = getFormatter(locale).getPrinter();\n+            p.printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            DateTimePrinter p = getFormatter(locale).getPrinter();\n+            p.printTo(out, instant, chrono, displayOffset, displayZone, locale);\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            DateTimePrinter p = getFormatter(locale).getPrinter();\n+            p.printTo(buf, partial, locale);\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            DateTimePrinter p = getFormatter(locale).getPrinter();\n+            p.printTo(out, partial, locale);\n+        }\n+\n+        public int estimateParsedLength() {\n+            return 40;  // guess\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeParser p = getFormatter(bucket.getLocale()).getParser();\n+            return p.parseInto(bucket, text, position);\n+        }\n+\n+        private DateTimeFormatter getFormatter(Locale locale) {\n+            locale = (locale == null ? Locale.getDefault() : locale);\n+            String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString();\n+            DateTimeFormatter f = null;\n+            synchronized (cCache) {\n+                f = cCache.get(key);\n+                if (f == null) {\n+                    String pattern = getPattern(locale);\n+                    f = DateTimeFormat.forPattern(pattern);\n+                    cCache.put(key, f);\n+                }\n+            }\n+            return f;\n+        }\n+\n+        String getPattern(Locale locale) {\n+            DateFormat f = null;\n+            switch (iType) {\n+                case DATE:\n+                    f = DateFormat.getDateInstance(iDateStyle, locale);\n+                    break;\n+                case TIME:\n+                    f = DateFormat.getTimeInstance(iTimeStyle, locale);\n+                    break;\n+                case DATETIME:\n+                    f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale);\n+                    break;\n+            }\n+            if (f instanceof SimpleDateFormat == false) {\n+                throw new IllegalArgumentException(\"No datetime pattern for locale: \" + locale);\n+            }\n+            return ((SimpleDateFormat) f).toPattern();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.LocalDate;\n+import org.joda.time.LocalDateTime;\n+import org.joda.time.LocalTime;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadWritableInstant;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * Controls the printing and parsing of a datetime to and from a string.\n+ * <p>\n+ * This class is the main API for printing and parsing used by most applications.\n+ * Instances of this class are created via one of three factory classes:\n+ * <ul>\n+ * <li>{@link DateTimeFormat} - formats by pattern and style</li>\n+ * <li>{@link ISODateTimeFormat} - ISO8601 formats</li>\n+ * <li>{@link DateTimeFormatterBuilder} - complex formats created via method calls</li>\n+ * </ul>\n+ * <p>\n+ * An instance of this class holds a reference internally to one printer and\n+ * one parser. It is possible that one of these may be null, in which case the\n+ * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n+ * and {@link #isParser()} methods.\n+ * <p>\n+ * The underlying printer/parser can be altered to behave exactly as required\n+ * by using one of the decorator modifiers:\n+ * <ul>\n+ * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n+ * <li>{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone</li>\n+ * <li>{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology</li>\n+ * <li>{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset</li>\n+ * </ul>\n+ * Each of these returns a new formatter (instances of this class are immutable).\n+ * <p>\n+ * The main methods of the class are the <code>printXxx</code> and\n+ * <code>parseXxx</code> methods. These are used as follows:\n+ * <pre>\n+ * // print using the defaults (default locale, chronology/zone of the datetime)\n+ * String dateStr = formatter.print(dt);\n+ * // print using the French locale\n+ * String dateStr = formatter.withLocale(Locale.FRENCH).print(dt);\n+ * // print using the UTC zone\n+ * String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt);\n+ * \n+ * // parse using the Paris zone\n+ * DateTime date = formatter.withZone(DateTimeZone.forID(\"Europe/Paris\")).parseDateTime(str);\n+ * </pre>\n+ * \n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @author Fredrik Borgh\n+ * @since 1.0\n+ */\n+public class DateTimeFormatter {\n+\n+    /** The internal printer used to output the datetime. */\n+    private final DateTimePrinter iPrinter;\n+    /** The internal parser used to output the datetime. */\n+    private final DateTimeParser iParser;\n+    /** The locale to use for printing and parsing. */\n+    private final Locale iLocale;\n+    /** Whether the offset is parsed. */\n+    private final boolean iOffsetParsed;\n+    /** The chronology to use as an override. */\n+    private final Chronology iChrono;\n+    /** The zone to use as an override. */\n+    private final DateTimeZone iZone;\n+    /* The pivot year to use for two-digit year parsing. */\n+    private final Integer iPivotYear;\n+\n+    /**\n+     * Creates a new formatter, however you will normally use the factory\n+     * or the builder.\n+     * \n+     * @param printer  the internal printer, null if cannot print\n+     * @param parser  the internal parser, null if cannot parse\n+     */\n+    public DateTimeFormatter(\n+            DateTimePrinter printer, DateTimeParser parser) {\n+        super();\n+        iPrinter = printer;\n+        iParser = parser;\n+        iLocale = null;\n+        iOffsetParsed = false;\n+        iChrono = null;\n+        iZone = null;\n+        iPivotYear = null;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    private DateTimeFormatter(\n+            DateTimePrinter printer, DateTimeParser parser,\n+            Locale locale, boolean offsetParsed,\n+            Chronology chrono, DateTimeZone zone,\n+            Integer pivotYear) {\n+        super();\n+        iPrinter = printer;\n+        iParser = parser;\n+        iLocale = locale;\n+        iOffsetParsed = offsetParsed;\n+        iChrono = chrono;\n+        iZone = zone;\n+        iPivotYear = pivotYear;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this formatter capable of printing.\n+     * \n+     * @return true if this is a printer\n+     */\n+    public boolean isPrinter() {\n+        return (iPrinter != null);\n+    }\n+\n+    /**\n+     * Gets the internal printer object that performs the real printing work.\n+     * \n+     * @return the internal printer; is null if printing not supported\n+     */\n+    public DateTimePrinter getPrinter() {\n+        return iPrinter;\n+    }\n+\n+    /**\n+     * Is this formatter capable of parsing.\n+     * \n+     * @return true if this is a parser\n+     */\n+    public boolean isParser() {\n+        return (iParser != null);\n+    }\n+\n+    /**\n+     * Gets the internal parser object that performs the real parsing work.\n+     * \n+     * @return the internal parser; is null if parsing not supported\n+     */\n+    public DateTimeParser getParser() {\n+        return iParser;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter with a different locale that will be used\n+     * for printing and parsing.\n+     * <p>\n+     * A DateTimeFormatter is immutable, so a new instance is returned,\n+     * and the original is unaltered and still usable.\n+     * \n+     * @param locale the locale to use; if null, formatter uses default locale\n+     * at invocation time\n+     * @return the new formatter\n+     */\n+    public DateTimeFormatter withLocale(Locale locale) {\n+        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, locale,\n+                iOffsetParsed, iChrono, iZone, iPivotYear);\n+    }\n+\n+    /**\n+     * Gets the locale that will be used for printing and parsing.\n+     * \n+     * @return the locale to use; if null, formatter uses default locale at\n+     * invocation time\n+     */\n+    public Locale getLocale() {\n+        return iLocale;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will create a datetime with a time zone\n+     * equal to that of the offset of the parsed string.\n+     * <p>\n+     * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n+     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n+     * savings rules). If the parsed string represents a local time (no zone\n+     * offset) the parsed datetime will be in the default zone.\n+     * <p>\n+     * Calling this method sets the override zone to null.\n+     * Calling the override zone method sets this flag off.\n+     * \n+     * @return the new formatter\n+     */\n+    public DateTimeFormatter withOffsetParsed() {\n+        if (iOffsetParsed == true) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                true, iChrono, null, iPivotYear);\n+    }\n+\n+    /**\n+     * Checks whether the offset from the string is used as the zone of\n+     * the parsed datetime.\n+     * \n+     * @return true if the offset from the string is used as the zone\n+     */\n+    public boolean isOffsetParsed() {\n+        return iOffsetParsed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will use the specified chronology in\n+     * preference to that of the printed object, or ISO on a parse.\n+     * <p>\n+     * When printing, this chronolgy will be used in preference to the chronology\n+     * from the datetime that would otherwise be used.\n+     * <p>\n+     * When parsing, this chronology will be set on the parsed datetime.\n+     * <p>\n+     * A null chronology means no-override.\n+     * If both an override chronology and an override zone are set, the\n+     * override zone will take precedence over the zone in the chronology.\n+     * \n+     * @param chrono  the chronology to use as an override\n+     * @return the new formatter\n+     */\n+    public DateTimeFormatter withChronology(Chronology chrono) {\n+        if (iChrono == chrono) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                iOffsetParsed, chrono, iZone, iPivotYear);\n+    }\n+\n+    /**\n+     * Gets the chronology to use as an override.\n+     * \n+     * @return the chronology to use as an override\n+     */\n+    public Chronology getChronology() {\n+        return iChrono;\n+    }\n+\n+    /**\n+     * Gets the chronology to use as an override.\n+     * \n+     * @return the chronology to use as an override\n+     * @deprecated Use the method with the correct spelling\n+     */\n+    public Chronology getChronolgy() {\n+        return iChrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will use the UTC zone in preference\n+     * to the zone of the printed object, or default zone on a parse.\n+     * <p>\n+     * When printing, UTC will be used in preference to the zone\n+     * from the datetime that would otherwise be used.\n+     * <p>\n+     * When parsing, UTC will be set on the parsed datetime.\n+     * <p>\n+     * If both an override chronology and an override zone are set, the\n+     * override zone will take precedence over the zone in the chronology.\n+     * \n+     * @return the new formatter, never null\n+     * @since 2.0\n+     */\n+    public DateTimeFormatter withZoneUTC() {\n+        return withZone(DateTimeZone.UTC);\n+    }\n+\n+    /**\n+     * Returns a new formatter that will use the specified zone in preference\n+     * to the zone of the printed object, or default zone on a parse.\n+     * <p>\n+     * When printing, this zone will be used in preference to the zone\n+     * from the datetime that would otherwise be used.\n+     * <p>\n+     * When parsing, this zone will be set on the parsed datetime.\n+     * <p>\n+     * A null zone means of no-override.\n+     * If both an override chronology and an override zone are set, the\n+     * override zone will take precedence over the zone in the chronology.\n+     * \n+     * @param zone  the zone to use as an override\n+     * @return the new formatter\n+     */\n+    public DateTimeFormatter withZone(DateTimeZone zone) {\n+        if (iZone == zone) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                false, iChrono, zone, iPivotYear);\n+    }\n+\n+    /**\n+     * Gets the zone to use as an override.\n+     * \n+     * @return the zone to use as an override\n+     */\n+    public DateTimeZone getZone() {\n+        return iZone;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will use the specified pivot year for two\n+     * digit year parsing in preference to that stored in the parser.\n+     * <p>\n+     * This setting is useful for changing the pivot year of formats built\n+     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n+     * <p>\n+     * When parsing, this pivot year is used. Null means no-override.\n+     * There is no effect when printing.\n+     * <p>\n+     * The pivot year enables a two digit year to be converted to a four\n+     * digit year. The pivot represents the year in the middle of the\n+     * supported range of years. Thus the full range of years that will\n+     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n+     *\n+     * <pre>\n+     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n+     * ---------------------------------------------------------------\n+     * 1950      1900..1999      1900    1920    1940    1960    1980\n+     * 1975      1925..2024      2000    2020    1940    1960    1980\n+     * 2000      1950..2049      2000    2020    2040    1960    1980\n+     * 2025      1975..2074      2000    2020    2040    2060    1980\n+     * 2050      2000..2099      2000    2020    2040    2060    2080\n+     * </pre>\n+     *\n+     * @param pivotYear  the pivot year to use as an override when parsing\n+     * @return the new formatter\n+     * @since 1.1\n+     */\n+    public DateTimeFormatter withPivotYear(Integer pivotYear) {\n+        if (iPivotYear == pivotYear || (iPivotYear != null && iPivotYear.equals(pivotYear))) {\n+            return this;\n+        }\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                iOffsetParsed, iChrono, iZone, pivotYear);\n+    }\n+\n+    /**\n+     * Returns a new formatter that will use the specified pivot year for two\n+     * digit year parsing in preference to that stored in the parser.\n+     * <p>\n+     * This setting is useful for changing the pivot year of formats built\n+     * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n+     * <p>\n+     * When parsing, this pivot year is used.\n+     * There is no effect when printing.\n+     * <p>\n+     * The pivot year enables a two digit year to be converted to a four\n+     * digit year. The pivot represents the year in the middle of the\n+     * supported range of years. Thus the full range of years that will\n+     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n+     *\n+     * <pre>\n+     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n+     * ---------------------------------------------------------------\n+     * 1950      1900..1999      1900    1920    1940    1960    1980\n+     * 1975      1925..2024      2000    2020    1940    1960    1980\n+     * 2000      1950..2049      2000    2020    2040    1960    1980\n+     * 2025      1975..2074      2000    2020    2040    2060    1980\n+     * 2050      2000..2099      2000    2020    2040    2060    2080\n+     * </pre>\n+     *\n+     * @param pivotYear  the pivot year to use as an override when parsing\n+     * @return the new formatter\n+     * @since 1.1\n+     */\n+    public DateTimeFormatter withPivotYear(int pivotYear) {\n+        return withPivotYear(new Integer(pivotYear));\n+    }\n+\n+    /**\n+     * Gets the pivot year to use as an override.\n+     *\n+     * @return the pivot year to use as an override\n+     * @since 1.1\n+     */\n+    public Integer getPivotYear() {\n+      return iPivotYear;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableInstant, using the chronology supplied by the instant.\n+     *\n+     * @param buf  the destination to format to, not null\n+     * @param instant  instant to format, null means now\n+     */\n+    public void printTo(StringBuffer buf, ReadableInstant instant) {\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        printTo(buf, millis, chrono);\n+    }\n+\n+    /**\n+     * Prints a ReadableInstant, using the chronology supplied by the instant.\n+     *\n+     * @param out  the destination to format to, not null\n+     * @param instant  instant to format, null means now\n+     */\n+    public void printTo(Writer out, ReadableInstant instant) throws IOException {\n+        long millis = DateTimeUtils.getInstantMillis(instant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n+        printTo(out, millis, chrono);\n+    }\n+\n+    /**\n+     * Prints a ReadableInstant, using the chronology supplied by the instant.\n+     *\n+     * @param appendable  the destination to format to, not null\n+     * @param instant  instant to format, null means now\n+     * @since 2.0\n+     */\n+    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {\n+        appendable.append(print(instant));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using ISO chronology in the default DateTimeZone.\n+     *\n+     * @param buf  the destination to format to, not null\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     */\n+    public void printTo(StringBuffer buf, long instant) {\n+        printTo(buf, instant, null);\n+    }\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using ISO chronology in the default DateTimeZone.\n+     *\n+     * @param out  the destination to format to, not null\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     */\n+    public void printTo(Writer out, long instant) throws IOException {\n+        printTo(out, instant, null);\n+    }\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using ISO chronology in the default DateTimeZone.\n+     *\n+     * @param appendable  the destination to format to, not null\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @since 2.0\n+     */\n+    public void printTo(Appendable appendable, long instant) throws IOException {\n+        appendable.append(print(instant));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadablePartial.\n+     * <p>\n+     * Neither the override chronology nor the override zone are used\n+     * by this method.\n+     *\n+     * @param buf  the destination to format to, not null\n+     * @param partial  partial to format\n+     */\n+    public void printTo(StringBuffer buf, ReadablePartial partial) {\n+        DateTimePrinter printer = requirePrinter();\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        printer.printTo(buf, partial, iLocale);\n+    }\n+\n+    /**\n+     * Prints a ReadablePartial.\n+     * <p>\n+     * Neither the override chronology nor the override zone are used\n+     * by this method.\n+     *\n+     * @param out  the destination to format to, not null\n+     * @param partial  partial to format\n+     */\n+    public void printTo(Writer out, ReadablePartial partial) throws IOException {\n+        DateTimePrinter printer = requirePrinter();\n+        if (partial == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        printer.printTo(out, partial, iLocale);\n+    }\n+\n+    /**\n+     * Prints a ReadablePartial.\n+     * <p>\n+     * Neither the override chronology nor the override zone are used\n+     * by this method.\n+     *\n+     * @param appendable  the destination to format to, not null\n+     * @param partial  partial to format\n+     * @since 2.0\n+     */\n+    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {\n+        appendable.append(print(partial));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadableInstant to a String.\n+     * <p>\n+     * This method will use the override zone and the override chronololgy if\n+     * they are set. Otherwise it will use the chronology and zone of the instant.\n+     *\n+     * @param instant  instant to format, null means now\n+     * @return the printed result\n+     */\n+    public String print(ReadableInstant instant) {\n+        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n+        printTo(buf, instant);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Prints a millisecond instant to a String.\n+     * <p>\n+     * This method will use the override zone and the override chronololgy if\n+     * they are set. Otherwise it will use the ISO chronology and default zone.\n+     *\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @return the printed result\n+     */\n+    public String print(long instant) {\n+        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n+        printTo(buf, instant);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Prints a ReadablePartial to a new String.\n+     * <p>\n+     * Neither the override chronology nor the override zone are used\n+     * by this method.\n+     *\n+     * @param partial  partial to format\n+     * @return the printed result\n+     */\n+    public String print(ReadablePartial partial) {\n+        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n+        printTo(buf, partial);\n+        return buf.toString();\n+    }\n+\n+    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n+        DateTimePrinter printer = requirePrinter();\n+        chrono = selectChronology(chrono);\n+        // Shift instant into local time (UTC) to avoid excessive offset\n+        // calculations when printing multiple fields in a composite printer.\n+        DateTimeZone zone = chrono.getZone();\n+        int offset = zone.getOffset(instant);\n+        long adjustedInstant = instant + offset;\n+        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n+            // Time zone offset overflow, so revert to UTC.\n+            zone = DateTimeZone.UTC;\n+            offset = 0;\n+            adjustedInstant = instant;\n+        }\n+        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n+    }\n+\n+    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n+        DateTimePrinter printer = requirePrinter();\n+        chrono = selectChronology(chrono);\n+        // Shift instant into local time (UTC) to avoid excessive offset\n+        // calculations when printing multiple fields in a composite printer.\n+        DateTimeZone zone = chrono.getZone();\n+        int offset = zone.getOffset(instant);\n+        long adjustedInstant = instant + offset;\n+        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n+            // Time zone offset overflow, so revert to UTC.\n+            zone = DateTimeZone.UTC;\n+            offset = 0;\n+            adjustedInstant = instant;\n+        }\n+        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n+    }\n+\n+    /**\n+     * Checks whether printing is supported.\n+     * \n+     * @throws UnsupportedOperationException if printing is not supported\n+     */\n+    private DateTimePrinter requirePrinter() {\n+        DateTimePrinter printer = iPrinter;\n+        if (printer == null) {\n+            throw new UnsupportedOperationException(\"Printing not supported\");\n+        }\n+        return printer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parses a datetime from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritableInstant. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text and in this case those fields\n+     * that were read will be set.\n+     * <p>\n+     * Only those fields present in the string will be changed in the specified\n+     * instant. All other fields will remain unaltered. Thus if the string only\n+     * contains a year and a month, then the day and time will be retained from\n+     * the input instant. If this is not the behaviour you want, then reset the\n+     * fields before calling this method, or use {@link #parseDateTime(String)}\n+     * or {@link #parseMutableDateTime(String)}.\n+     * <p>\n+     * If it fails, the return value is negative, but the instant may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     * <p>\n+     * The parse will use the chronology of the instant.\n+     *\n+     * @param instant  an instant that will be modified, not null\n+     * @param text  the text to parse\n+     * @param position  position to start parsing from\n+     * @return new position, negative value means parse failed -\n+     *  apply complement operator (~) to get position of failure\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the instant is null\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public int parseInto(ReadWritableInstant instant, String text, int position) {\n+        DateTimeParser parser = requireParser();\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"Instant must not be null\");\n+        }\n+        \n+        long instantMillis = instant.getMillis();\n+        Chronology chrono = instant.getChronology();\n+        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n+        chrono = selectChronology(chrono);\n+        \n+        DateTimeParserBucket bucket = new DateTimeParserBucket\n+            (instantLocal, chrono, iLocale, iPivotYear);\n+        int newPos = parser.parseInto(bucket, text, position);\n+        instant.setMillis(bucket.computeMillis(false, text));\n+        if (iOffsetParsed && bucket.getZone() == null) {\n+            int parsedOffset = bucket.getOffset();\n+            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n+            chrono = chrono.withZone(parsedZone);\n+        }\n+        instant.setChronology(chrono);\n+        return newPos;\n+    }\n+\n+    /**\n+     * Parses a datetime from the given text, returning the number of\n+     * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n+     * <p>\n+     * The parse will use the ISO chronology, and the default time zone.\n+     * If the text contains a time zone string then that will be taken into account.\n+     *\n+     * @param text  text to parse\n+     * @return parsed value expressed in milliseconds since the epoch\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public long parseMillis(String text) {\n+        DateTimeParser parser = requireParser();\n+        \n+        Chronology chrono = selectChronology(iChrono);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        int newPos = parser.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return bucket.computeMillis(true, text);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n+     * Parses only the local date from the given text, returning a new LocalDate.\n+     * <p>\n+     * This will parse the text fully according to the formatter, using the UTC zone.\n+     * Once parsed, only the local date will be used.\n+     * This means that any parsed time, time-zone or offset field is completely ignored.\n+     * It also means that the zone and offset-parsed settings are ignored.\n+     *\n+     * @param text  the text to parse, not null\n+     * @return the parsed date, never null\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     * @since 2.0\n+     */\n+    public LocalDate parseLocalDate(String text) {\n+        return parseLocalDateTime(text).toLocalDate();\n+    }\n+\n+    /**\n+     * Parses only the local time from the given text, returning a new LocalDate.\n+     * <p>\n+     * This will parse the text fully according to the formatter, using the UTC zone.\n+     * Once parsed, only the local time will be used.\n+     * This means that any parsed date, time-zone or offset field is completely ignored.\n+     * It also means that the zone and offset-parsed settings are ignored.\n+     *\n+     * @param text  the text to parse, not null\n+     * @return the parsed time, never null\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     * @since 2.0\n+     */\n+    public LocalTime parseLocalTime(String text) {\n+        return parseLocalDateTime(text).toLocalTime();\n+    }\n+\n+    /**\n+     * Parses only the local date-time from the given text, returning a new LocalDate.\n+     * <p>\n+     * This will parse the text fully according to the formatter, using the UTC zone.\n+     * Once parsed, only the local date-time will be used.\n+     * This means that any parsed time-zone or offset field is completely ignored.\n+     * It also means that the zone and offset-parsed settings are ignored.\n+     *\n+     * @param text  the text to parse, not null\n+     * @return the parsed date-time, never null\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     * @since 2.0\n+     */\n+    public LocalDateTime parseLocalDateTime(String text) {\n+        DateTimeParser parser = requireParser();\n+        \n+        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        int newPos = parser.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                long millis = bucket.computeMillis(true, text);\n+                if (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\n+                    int parsedOffset = bucket.getOffset();\n+                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n+                    chrono = chrono.withZone(parsedZone);\n+                }\n+                return new LocalDateTime(millis, chrono);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new DateTime.\n+     * <p>\n+     * The parse will use the zone and chronology specified on this formatter.\n+     * <p>\n+     * If the text contains a time zone string then that will be taken into\n+     * account in adjusting the time of day as follows.\n+     * If the {@link #withOffsetParsed()} has been called, then the resulting\n+     * DateTime will have a fixed offset based on the parsed time zone.\n+     * Otherwise the resulting DateTime will have the zone of this formatter,\n+     * but the parsed zone may have caused the time to be adjusted.\n+     *\n+     * @param text  the text to parse\n+     * @return parsed value in a DateTime object\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public DateTime parseDateTime(String text) {\n+        DateTimeParser parser = requireParser();\n+        \n+        Chronology chrono = selectChronology(null);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        int newPos = parser.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                long millis = bucket.computeMillis(true, text);\n+                if (iOffsetParsed && bucket.getZone() == null) {\n+                    int parsedOffset = bucket.getOffset();\n+                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n+                    chrono = chrono.withZone(parsedZone);\n+                }\n+                return new DateTime(millis, chrono);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n+     * Parses a datetime from the given text, returning a new MutableDateTime.\n+     * <p>\n+     * The parse will use the zone and chronology specified on this formatter.\n+     * <p>\n+     * If the text contains a time zone string then that will be taken into\n+     * account in adjusting the time of day as follows.\n+     * If the {@link #withOffsetParsed()} has been called, then the resulting\n+     * DateTime will have a fixed offset based on the parsed time zone.\n+     * Otherwise the resulting DateTime will have the zone of this formatter,\n+     * but the parsed zone may have caused the time to be adjusted.\n+     *\n+     * @param text  the text to parse\n+     * @return parsed value in a MutableDateTime object\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     * @throws IllegalArgumentException if the text to parse is invalid\n+     */\n+    public MutableDateTime parseMutableDateTime(String text) {\n+        DateTimeParser parser = requireParser();\n+        \n+        Chronology chrono = selectChronology(null);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        int newPos = parser.parseInto(bucket, text, 0);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                long millis = bucket.computeMillis(true, text);\n+                if (iOffsetParsed && bucket.getZone() == null) {\n+                    int parsedOffset = bucket.getOffset();\n+                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n+                    chrono = chrono.withZone(parsedZone);\n+                }\n+                return new MutableDateTime(millis, chrono);\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n+     * Checks whether parsing is supported.\n+     * \n+     * @throws UnsupportedOperationException if parsing is not supported\n+     */\n+    private DateTimeParser requireParser() {\n+        DateTimeParser parser = iParser;\n+        if (parser == null) {\n+            throw new UnsupportedOperationException(\"Parsing not supported\");\n+        }\n+        return parser;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Determines the correct chronology to use.\n+     *\n+     * @param chrono  the proposed chronology\n+     * @return the actual chronology\n+     */\n+    private Chronology selectChronology(Chronology chrono) {\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        if (iChrono != null) {\n+            chrono = iChrono;\n+        }\n+        if (iZone != null) {\n+            chrono = chrono.withZone(iZone);\n+        }\n+        return chrono;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.MutableDateTime.Property;\n+import org.joda.time.field.MillisDurationField;\n+import org.joda.time.field.PreciseDateTimeField;\n+\n+/**\n+ * Factory that creates complex instances of DateTimeFormatter via method calls.\n+ * <p>\n+ * Datetime formatting is performed by the {@link DateTimeFormatter} class.\n+ * Three classes provide factory methods to create formatters, and this is one.\n+ * The others are {@link DateTimeFormat} and {@link ISODateTimeFormat}.\n+ * <p>\n+ * DateTimeFormatterBuilder is used for constructing formatters which are then\n+ * used to print or parse. The formatters are built by appending specific fields\n+ * or other formatters to an instance of this builder.\n+ * <p>\n+ * For example, a formatter that prints month and year, like \"January 1970\",\n+ * can be constructed as follows:\n+ * <p>\n+ * <pre>\n+ * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()\n+ *     .appendMonthOfYearText()\n+ *     .appendLiteral(' ')\n+ *     .appendYear(4, 4)\n+ *     .toFormatter();\n+ * </pre>\n+ * <p>\n+ * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the\n+ * formatters that it builds are thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @author Fredrik Borgh\n+ * @since 1.0\n+ * @see DateTimeFormat\n+ * @see ISODateTimeFormat\n+ */\n+public class DateTimeFormatterBuilder {\n+\n+    /** Array of printers and parsers (alternating). */\n+    private ArrayList<Object> iElementPairs;\n+    /** Cache of the last returned formatter. */\n+    private Object iFormatter;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a DateTimeFormatterBuilder.\n+     */\n+    public DateTimeFormatterBuilder() {\n+        super();\n+        iElementPairs = new ArrayList<Object>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a DateTimeFormatter using all the appended elements.\n+     * <p>\n+     * This is the main method used by applications at the end of the build\n+     * process to create a usable formatter.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned formatter.\n+     * <p>\n+     * The returned formatter may not support both printing and parsing.\n+     * The methods {@link DateTimeFormatter#isPrinter()} and\n+     * {@link DateTimeFormatter#isParser()} will help you determine the state\n+     * of the formatter.\n+     *\n+     * @throws UnsupportedOperationException if neither printing nor parsing is supported\n+     */\n+    public DateTimeFormatter toFormatter() {\n+        Object f = getFormatter();\n+        DateTimePrinter printer = null;\n+        if (isPrinter(f)) {\n+            printer = (DateTimePrinter) f;\n+        }\n+        DateTimeParser parser = null;\n+        if (isParser(f)) {\n+            parser = (DateTimeParser) f;\n+        }\n+        if (printer != null || parser != null) {\n+            return new DateTimeFormatter(printer, parser);\n+        }\n+        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n+    }\n+\n+    /**\n+     * Internal method to create a DateTimePrinter instance using all the\n+     * appended elements.\n+     * <p>\n+     * Most applications will not use this method.\n+     * If you want a printer in an application, call {@link #toFormatter()}\n+     * and just use the printing API.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned printer.\n+     *\n+     * @throws UnsupportedOperationException if printing is not supported\n+     */\n+    public DateTimePrinter toPrinter() {\n+        Object f = getFormatter();\n+        if (isPrinter(f)) {\n+            return (DateTimePrinter) f;\n+        }\n+        throw new UnsupportedOperationException(\"Printing is not supported\");\n+    }\n+\n+    /**\n+     * Internal method to create a DateTimeParser instance using all the\n+     * appended elements.\n+     * <p>\n+     * Most applications will not use this method.\n+     * If you want a parser in an application, call {@link #toFormatter()}\n+     * and just use the parsing API.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned parser.\n+     *\n+     * @throws UnsupportedOperationException if parsing is not supported\n+     */\n+    public DateTimeParser toParser() {\n+        Object f = getFormatter();\n+        if (isParser(f)) {\n+            return (DateTimeParser) f;\n+        }\n+        throw new UnsupportedOperationException(\"Parsing is not supported\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if toFormatter can be called without throwing an\n+     * UnsupportedOperationException.\n+     * \n+     * @return true if a formatter can be built\n+     */\n+    public boolean canBuildFormatter() {\n+        return isFormatter(getFormatter());\n+    }\n+\n+    /**\n+     * Returns true if toPrinter can be called without throwing an\n+     * UnsupportedOperationException.\n+     * \n+     * @return true if a printer can be built\n+     */\n+    public boolean canBuildPrinter() {\n+        return isPrinter(getFormatter());\n+    }\n+\n+    /**\n+     * Returns true if toParser can be called without throwing an\n+     * UnsupportedOperationException.\n+     * \n+     * @return true if a parser can be built\n+     */\n+    public boolean canBuildParser() {\n+        return isParser(getFormatter());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clears out all the appended elements, allowing this builder to be\n+     * reused.\n+     */\n+    public void clear() {\n+        iFormatter = null;\n+        iElementPairs.clear();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends another formatter.\n+     *\n+     * @param formatter  the formatter to add\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if formatter is null or of an invalid type\n+     */\n+    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n+        if (formatter == null) {\n+            throw new IllegalArgumentException(\"No formatter supplied\");\n+        }\n+        return append0(formatter.getPrinter(), formatter.getParser());\n+    }\n+\n+    /**\n+     * Appends just a printer. With no matching parser, a parser cannot be\n+     * built from this DateTimeFormatterBuilder.\n+     *\n+     * @param printer  the printer to add\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if printer is null or of an invalid type\n+     */\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n+        checkPrinter(printer);\n+        return append0(printer, null);\n+    }\n+\n+    /**\n+     * Appends just a parser. With no matching printer, a printer cannot be\n+     * built from this builder.\n+     *\n+     * @param parser  the parser to add\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if parser is null or of an invalid type\n+     */\n+    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n+        checkParser(parser);\n+        return append0(null, parser);\n+    }\n+\n+    /**\n+     * Appends a printer/parser pair.\n+     *\n+     * @param printer  the printer to add\n+     * @param parser  the parser to add\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if printer or parser is null or of an invalid type\n+     */\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n+        checkPrinter(printer);\n+        checkParser(parser);\n+        return append0(printer, parser);\n+    }\n+\n+    /**\n+     * Appends a printer and a set of matching parsers. When parsing, the first\n+     * parser in the list is selected for parsing. If it fails, the next is\n+     * chosen, and so on. If none of these parsers succeeds, then the failed\n+     * position of the parser that made the greatest progress is returned.\n+     * <p>\n+     * Only the printer is optional. In addition, it is illegal for any but the\n+     * last of the parser array elements to be null. If the last element is\n+     * null, this represents the empty parser. The presence of an empty parser\n+     * indicates that the entire array of parse formats is optional.\n+     *\n+     * @param printer  the printer to add\n+     * @param parsers  the parsers to add\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if any printer or parser is of an invalid type\n+     * @throws IllegalArgumentException if any parser element but the last is null\n+     */\n+    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n+        if (printer != null) {\n+            checkPrinter(printer);\n+        }\n+        if (parsers == null) {\n+            throw new IllegalArgumentException(\"No parsers supplied\");\n+        }\n+        int length = parsers.length;\n+        if (length == 1) {\n+            if (parsers[0] == null) {\n+                throw new IllegalArgumentException(\"No parser supplied\");\n+            }\n+            return append0(printer, parsers[0]);\n+        }\n+\n+        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n+        int i;\n+        for (i = 0; i < length - 1; i++) {\n+            if ((copyOfParsers[i] = parsers[i]) == null) {\n+                throw new IllegalArgumentException(\"Incomplete parser array\");\n+            }\n+        }\n+        copyOfParsers[i] = parsers[i];\n+\n+        return append0(printer, new MatchingParser(copyOfParsers));\n+    }\n+\n+    /**\n+     * Appends just a parser element which is optional. With no matching\n+     * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if parser is null or of an invalid type\n+     */\n+    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n+        checkParser(parser);\n+        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n+        return append0(null, new MatchingParser(parsers));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the parser is non null and a provider.\n+     * \n+     * @param parser  the parser to check\n+     */\n+    private void checkParser(DateTimeParser parser) {\n+        if (parser == null) {\n+            throw new IllegalArgumentException(\"No parser supplied\");\n+        }\n+    }\n+\n+    /**\n+     * Checks if the printer is non null and a provider.\n+     * \n+     * @param printer  the printer to check\n+     */\n+    private void checkPrinter(DateTimePrinter printer) {\n+        if (printer == null) {\n+            throw new IllegalArgumentException(\"No printer supplied\");\n+        }\n+    }\n+\n+    private DateTimeFormatterBuilder append0(Object element) {\n+        iFormatter = null;\n+        // Add the element as both a printer and parser.\n+        iElementPairs.add(element);\n+        iElementPairs.add(element);\n+        return this;\n+    }\n+\n+    private DateTimeFormatterBuilder append0(\n+            DateTimePrinter printer, DateTimeParser parser) {\n+        iFormatter = null;\n+        iElementPairs.add(printer);\n+        iElementPairs.add(parser);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Instructs the printer to emit a specific character, and the parser to\n+     * expect it. The parser is case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendLiteral(char c) {\n+        return append0(new CharacterLiteral(c));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit specific text, and the parser to expect\n+     * it. The parser is case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if text is null\n+     */\n+    public DateTimeFormatterBuilder appendLiteral(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Literal must not be null\");\n+        }\n+        switch (text.length()) {\n+            case 0:\n+                return this;\n+            case 1:\n+                return append0(new CharacterLiteral(text.charAt(0)));\n+            default:\n+                return append0(new StringLiteral(text));\n+        }\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as a decimal number, and the\n+     * parser to expect an unsigned decimal number.\n+     *\n+     * @param fieldType  type of field to append\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if field type is null\n+     */\n+    public DateTimeFormatterBuilder appendDecimal(\n+            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        if (maxDigits < minDigits) {\n+            maxDigits = minDigits;\n+        }\n+        if (minDigits < 0 || maxDigits <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (minDigits <= 1) {\n+            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n+        } else {\n+            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n+        }\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as a fixed-width decimal\n+     * number (smaller numbers will be left-padded with zeros), and the parser\n+     * to expect an unsigned decimal number with the same fixed width.\n+     * \n+     * @param fieldType  type of field to append\n+     * @param numDigits  the exact number of digits to parse or print, except if\n+     * printed value requires more digits\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n+     * @since 1.5\n+     */\n+    public DateTimeFormatterBuilder appendFixedDecimal(\n+            DateTimeFieldType fieldType, int numDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        if (numDigits <= 0) {\n+            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n+        }\n+        return append0(new FixedNumber(fieldType, numDigits, false));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as a decimal number, and the\n+     * parser to expect a signed decimal number.\n+     *\n+     * @param fieldType  type of field to append\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if field type is null\n+     */\n+    public DateTimeFormatterBuilder appendSignedDecimal(\n+            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        if (maxDigits < minDigits) {\n+            maxDigits = minDigits;\n+        }\n+        if (minDigits < 0 || maxDigits <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (minDigits <= 1) {\n+            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n+        } else {\n+            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n+        }\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as a fixed-width decimal\n+     * number (smaller numbers will be left-padded with zeros), and the parser\n+     * to expect an signed decimal number with the same fixed width.\n+     * \n+     * @param fieldType  type of field to append\n+     * @param numDigits  the exact number of digits to parse or print, except if\n+     * printed value requires more digits\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n+     * @since 1.5\n+     */\n+    public DateTimeFormatterBuilder appendFixedSignedDecimal(\n+            DateTimeFieldType fieldType, int numDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        if (numDigits <= 0) {\n+            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n+        }\n+        return append0(new FixedNumber(fieldType, numDigits, true));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as text, and the\n+     * parser to expect text.\n+     *\n+     * @param fieldType  type of field to append\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if field type is null\n+     */\n+    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        return append0(new TextField(fieldType, false));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a field value as short text, and the\n+     * parser to expect text.\n+     *\n+     * @param fieldType  type of field to append\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if field type is null\n+     */\n+    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        return append0(new TextField(fieldType, true));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a remainder of time as a decimal fraction,\n+     * without decimal point. For example, if the field is specified as\n+     * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n+     * decimal point is implied, so the fraction is 0.75, or three-quarters of\n+     * a minute.\n+     *\n+     * @param fieldType  type of field to append\n+     * @param minDigits  minimum number of digits to print.\n+     * @param maxDigits  maximum number of digits to print or parse.\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @throws IllegalArgumentException if field type is null\n+     */\n+    public DateTimeFormatterBuilder appendFraction(\n+            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n+        if (fieldType == null) {\n+            throw new IllegalArgumentException(\"Field type must not be null\");\n+        }\n+        if (maxDigits < minDigits) {\n+            maxDigits = minDigits;\n+        }\n+        if (minDigits < 0 || maxDigits <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return append0(new Fraction(fieldType, minDigits, maxDigits));\n+    }\n+\n+    /**\n+     * Appends the print/parse of a fractional second.\n+     * <p>\n+     * This reliably handles the case where fractional digits are being handled\n+     * beyond a visible decimal point. The digits parsed will always be treated\n+     * as the most significant (numerically largest) digits.\n+     * Thus '23' will be parsed as 230 milliseconds.\n+     * Contrast this behaviour to {@link #appendMillisOfSecond}.\n+     * This method does not print or parse the decimal point itself.\n+     * \n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n+        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Appends the print/parse of a fractional minute.\n+     * <p>\n+     * This reliably handles the case where fractional digits are being handled\n+     * beyond a visible decimal point. The digits parsed will always be treated\n+     * as the most significant (numerically largest) digits.\n+     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).\n+     * This method does not print or parse the decimal point itself.\n+     * \n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n+        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Appends the print/parse of a fractional hour.\n+     * <p>\n+     * This reliably handles the case where fractional digits are being handled\n+     * beyond a visible decimal point. The digits parsed will always be treated\n+     * as the most significant (numerically largest) digits.\n+     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).\n+     * This method does not print or parse the decimal point itself.\n+     * \n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n+        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Appends the print/parse of a fractional day.\n+     * <p>\n+     * This reliably handles the case where fractional digits are being handled\n+     * beyond a visible decimal point. The digits parsed will always be treated\n+     * as the most significant (numerically largest) digits.\n+     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).\n+     * This method does not print or parse the decimal point itself.\n+     * \n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to print or parse\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n+        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric millisOfSecond field.\n+     * <p>\n+     * This method will append a field that prints a three digit value.\n+     * During parsing the value that is parsed is assumed to be three digits.\n+     * If less than three digits are present then they will be counted as the\n+     * smallest parts of the millisecond. This is probably not what you want\n+     * if you are using the field as a fraction. Instead, a fractional\n+     * millisecond should be produced using {@link #appendFractionOfSecond}.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric millisOfDay field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric secondOfMinute field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric secondOfDay field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric minuteOfHour field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric minuteOfDay field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric hourOfDay field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric clockhourOfDay field.\n+     *\n+     * @param minDigits minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric hourOfHalfday field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric clockhourOfHalfday field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric dayOfWeek field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric dayOfMonth field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric dayOfYear field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric weekOfWeekyear field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric weekyear field.\n+     *\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n+        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric monthOfYear field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n+        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric year field.\n+     *\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n+        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric year field which always prints\n+     * and parses two digits. A pivot year is used during parsing to determine\n+     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n+     *\n+     * <pre>\n+     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n+     * ---------------------------------------------------------------\n+     * 1950      1900..1999      1900    1920    1940    1960    1980\n+     * 1975      1925..2024      2000    2020    1940    1960    1980\n+     * 2000      1950..2049      2000    2020    2040    1960    1980\n+     * 2025      1975..2074      2000    2020    2040    2060    1980\n+     * 2050      2000..2099      2000    2020    2040    2060    2080\n+     * </pre>\n+     *\n+     * @param pivot  pivot year to use when parsing\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n+        return appendTwoDigitYear(pivot, false);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric year field which always prints\n+     * two digits. A pivot year is used during parsing to determine the range\n+     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n+     * parse is instructed to be lenient and the digit count is not two, it is\n+     * treated as an absolute year. With lenient parsing, specifying a positive\n+     * or negative sign before the year also makes it absolute.\n+     *\n+     * @param pivot  pivot year to use when parsing\n+     * @param lenientParse  when true, if digit count is not two, it is treated\n+     * as an absolute year\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @since 1.1\n+     */\n+    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n+        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric weekyear field which always prints\n+     * and parses two digits. A pivot year is used during parsing to determine\n+     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n+     *\n+     * <pre>\n+     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n+     * ---------------------------------------------------------------\n+     * 1950      1900..1999      1900    1920    1940    1960    1980\n+     * 1975      1925..2024      2000    2020    1940    1960    1980\n+     * 2000      1950..2049      2000    2020    2040    1960    1980\n+     * 2025      1975..2074      2000    2020    2040    2060    1980\n+     * 2050      2000..2099      2000    2020    2040    2060    2080\n+     * </pre>\n+     *\n+     * @param pivot  pivot weekyear to use when parsing\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n+        return appendTwoDigitWeekyear(pivot, false);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric weekyear field which always prints\n+     * two digits. A pivot year is used during parsing to determine the range\n+     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n+     * parse is instructed to be lenient and the digit count is not two, it is\n+     * treated as an absolute weekyear. With lenient parsing, specifying a positive\n+     * or negative sign before the weekyear also makes it absolute.\n+     *\n+     * @param pivot  pivot weekyear to use when parsing\n+     * @param lenientParse  when true, if digit count is not two, it is treated\n+     * as an absolute weekyear\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @since 1.1\n+     */\n+    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n+        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric yearOfEra field.\n+     *\n+     * @param minDigits  minimum number of digits to <i>print</i>\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n+        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric year of century field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n+        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric century of era field.\n+     *\n+     * @param minDigits  minimum number of digits to print\n+     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n+     * maximum number of digits to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n+        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific AM/PM text, and the\n+     * parser to expect it. The parser is case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n+        return appendText(DateTimeFieldType.halfdayOfDay());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific dayOfWeek text. The\n+     * parser will accept a long or short dayOfWeek text, case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendDayOfWeekText() {\n+        return appendText(DateTimeFieldType.dayOfWeek());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a short locale-specific dayOfWeek\n+     * text. The parser will accept a long or short dayOfWeek text,\n+     * case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n+        return appendShortText(DateTimeFieldType.dayOfWeek());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a short locale-specific monthOfYear\n+     * text. The parser will accept a long or short monthOfYear text,\n+     * case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendMonthOfYearText() { \n+        return appendText(DateTimeFieldType.monthOfYear());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific monthOfYear text. The\n+     * parser will accept a long or short monthOfYear text, case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n+        return appendShortText(DateTimeFieldType.monthOfYear());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific era text (BC/AD), and\n+     * the parser to expect it. The parser is case-insensitive.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendEraText() {\n+        return appendText(DateTimeFieldType.era());\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a locale-specific time zone name. A\n+     * parser cannot be created from this builder if a time zone name is\n+     * appended.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneName() {\n+        return append0(new TimeZoneName(TimeZoneName.LONG_NAME), null);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a short locale-specific time zone\n+     * name. A parser cannot be created from this builder if time zone\n+     * name is appended.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n+        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME), null);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit the identifier of the time zone.\n+     * This field cannot currently be parsed.\n+     *\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneId() {\n+        return append0(new TimeZoneName(TimeZoneName.ID), null);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit text and numbers to display time zone\n+     * offset from UTC. A parser will use the parsed time zone offset to adjust\n+     * the datetime.\n+     * <p>\n+     * If zero offset text is supplied, then it will be printed when the zone is zero.\n+     * During parsing, either the zero offset text, or the offset will be parsed.\n+     *\n+     * @param zeroOffsetText  the text to use if time zone offset is zero. If\n+     * null, offset is always shown.\n+     * @param showSeparators  if true, prints ':' separator before minute and\n+     * second field and prints '.' separator before fraction field.\n+     * @param minFields  minimum number of fields to print, stopping when no\n+     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n+     * @param maxFields  maximum number of fields to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneOffset(\n+            String zeroOffsetText, boolean showSeparators,\n+            int minFields, int maxFields) {\n+        return append0(new TimeZoneOffset\n+                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit text and numbers to display time zone\n+     * offset from UTC. A parser will use the parsed time zone offset to adjust\n+     * the datetime.\n+     * <p>\n+     * If zero offset print text is supplied, then it will be printed when the zone is zero.\n+     * If zero offset parse text is supplied, then either it or the offset will be parsed.\n+     *\n+     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If\n+     * null, offset is always shown.\n+     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time\n+     * zone offset is zero. If null, then always use the offset.\n+     * @param showSeparators  if true, prints ':' separator before minute and\n+     * second field and prints '.' separator before fraction field.\n+     * @param minFields  minimum number of fields to print, stopping when no\n+     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n+     * @param maxFields  maximum number of fields to print\n+     * @return this DateTimeFormatterBuilder, for chaining\n+     * @since 2.0\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneOffset(\n+            String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,\n+            int minFields, int maxFields) {\n+        return append0(new TimeZoneOffset\n+                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calls upon {@link DateTimeFormat} to parse the pattern and append the\n+     * results into this builder.\n+     *\n+     * @param pattern  pattern specification\n+     * @throws IllegalArgumentException if the pattern is invalid\n+     * @see DateTimeFormat\n+     */\n+    public DateTimeFormatterBuilder appendPattern(String pattern) {\n+        DateTimeFormat.appendPatternTo(this, pattern);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private Object getFormatter() {\n+        Object f = iFormatter;\n+\n+        if (f == null) {\n+            if (iElementPairs.size() == 2) {\n+                Object printer = iElementPairs.get(0);\n+                Object parser = iElementPairs.get(1);\n+\n+                if (printer != null) {\n+                    if (printer == parser || parser == null) {\n+                        f = printer;\n+                    }\n+                } else {\n+                    f = parser;\n+                }\n+            }\n+\n+            if (f == null) {\n+                f = new Composite(iElementPairs);\n+            }\n+\n+            iFormatter = f;\n+        }\n+\n+        return f;\n+    }\n+\n+    private boolean isPrinter(Object f) {\n+        if (f instanceof DateTimePrinter) {\n+            if (f instanceof Composite) {\n+                return ((Composite)f).isPrinter();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean isParser(Object f) {\n+        if (f instanceof DateTimeParser) {\n+            if (f instanceof Composite) {\n+                return ((Composite)f).isParser();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean isFormatter(Object f) {\n+        return (isPrinter(f) || isParser(f));\n+    }\n+\n+    static void appendUnknownString(StringBuffer buf, int len) {\n+        for (int i = len; --i >= 0;) {\n+            buf.append('\\ufffd');\n+        }\n+    }\n+\n+    static void printUnknownString(Writer out, int len) throws IOException {\n+        for (int i = len; --i >= 0;) {\n+            out.write('\\ufffd');\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class CharacterLiteral\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        private final char iValue;\n+\n+        CharacterLiteral(char value) {\n+            super();\n+            iValue = value;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return 1;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            buf.append(iValue);\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            out.write(iValue);\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            buf.append(iValue);\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            out.write(iValue);\n+        }\n+\n+        public int estimateParsedLength() {\n+            return 1;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            if (position >= text.length()) {\n+                return ~position;\n+            }\n+\n+            char a = text.charAt(position);\n+            char b = iValue;\n+\n+            if (a != b) {\n+                a = Character.toUpperCase(a);\n+                b = Character.toUpperCase(b);\n+                if (a != b) {\n+                    a = Character.toLowerCase(a);\n+                    b = Character.toLowerCase(b);\n+                    if (a != b) {\n+                        return ~position;\n+                    }\n+                }\n+            }\n+\n+            return position + 1;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class StringLiteral\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        private final String iValue;\n+\n+        StringLiteral(String value) {\n+            super();\n+            iValue = value;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iValue.length();\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            buf.append(iValue);\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            out.write(iValue);\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            buf.append(iValue);\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            out.write(iValue);\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iValue.length();\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n+                return position + iValue.length();\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static abstract class NumberFormatter\n+            implements DateTimePrinter, DateTimeParser {\n+        protected final DateTimeFieldType iFieldType;\n+        protected final int iMaxParsedDigits;\n+        protected final boolean iSigned;\n+\n+        NumberFormatter(DateTimeFieldType fieldType,\n+                int maxParsedDigits, boolean signed) {\n+            super();\n+            iFieldType = fieldType;\n+            iMaxParsedDigits = maxParsedDigits;\n+            iSigned = signed;\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iMaxParsedDigits;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n+\n+            boolean negative = false;\n+            int length = 0;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n+                    negative = c == '-';\n+\n+                    // Next character must be a digit.\n+                    if (length + 1 >= limit || \n+                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n+                    {\n+                        break;\n+                    }\n+\n+                    if (negative) {\n+                        length++;\n+                    } else {\n+                        // Skip the '+' for parseInt to succeed.\n+                        position++;\n+                    }\n+                    // Expand the limit to disregard the sign character.\n+                    limit = Math.min(limit + 1, text.length() - position);\n+                    continue;\n+                }\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                length++;\n+            }\n+\n+            if (length == 0) {\n+                return ~position;\n+            }\n+\n+            int value;\n+            if (length >= 9) {\n+                // Since value may exceed integer limits, use stock parser\n+                // which checks for this.\n+                value = Integer.parseInt(text.substring(position, position += length));\n+            } else {\n+                int i = position;\n+                if (negative) {\n+                    i++;\n+                }\n+                try {\n+                    value = text.charAt(i++) - '0';\n+                } catch (StringIndexOutOfBoundsException e) {\n+                    return ~position;\n+                }\n+                position += length;\n+                while (i < position) {\n+                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n+                }\n+                if (negative) {\n+                    value = -value;\n+                }\n+            }\n+\n+            bucket.saveField(iFieldType, value);\n+            return position;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class UnpaddedNumber extends NumberFormatter {\n+\n+        protected UnpaddedNumber(DateTimeFieldType fieldType,\n+                       int maxParsedDigits, boolean signed)\n+        {\n+            super(fieldType, maxParsedDigits, signed);\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iMaxParsedDigits;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            try {\n+                DateTimeField field = iFieldType.getField(chrono);\n+                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));\n+            } catch (RuntimeException e) {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            try {\n+                DateTimeField field = iFieldType.getField(chrono);\n+                FormatUtils.writeUnpaddedInteger(out, field.get(instant));\n+            } catch (RuntimeException e) {\n+                out.write('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            if (partial.isSupported(iFieldType)) {\n+                try {\n+                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));\n+                } catch (RuntimeException e) {\n+                    buf.append('\\ufffd');\n+                }\n+            } else {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            if (partial.isSupported(iFieldType)) {\n+                try {\n+                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));\n+                } catch (RuntimeException e) {\n+                    out.write('\\ufffd');\n+                }\n+            } else {\n+                out.write('\\ufffd');\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class PaddedNumber extends NumberFormatter {\n+\n+        protected final int iMinPrintedDigits;\n+\n+        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\n+                     boolean signed, int minPrintedDigits)\n+        {\n+            super(fieldType, maxParsedDigits, signed);\n+            iMinPrintedDigits = minPrintedDigits;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iMaxParsedDigits;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            try {\n+                DateTimeField field = iFieldType.getField(chrono);\n+                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n+            } catch (RuntimeException e) {\n+                appendUnknownString(buf, iMinPrintedDigits);\n+            }\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            try {\n+                DateTimeField field = iFieldType.getField(chrono);\n+                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);\n+            } catch (RuntimeException e) {\n+                printUnknownString(out, iMinPrintedDigits);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            if (partial.isSupported(iFieldType)) {\n+                try {\n+                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n+                } catch (RuntimeException e) {\n+                    appendUnknownString(buf, iMinPrintedDigits);\n+                }\n+            } else {\n+                appendUnknownString(buf, iMinPrintedDigits);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            if (partial.isSupported(iFieldType)) {\n+                try {\n+                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);\n+                } catch (RuntimeException e) {\n+                    printUnknownString(out, iMinPrintedDigits);\n+                }\n+            } else {\n+                printUnknownString(out, iMinPrintedDigits);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class FixedNumber extends PaddedNumber {\n+\n+        protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n+            super(fieldType, numDigits, signed, numDigits);\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int newPos = super.parseInto(bucket, text, position);\n+            if (newPos < 0) {\n+                return newPos;\n+            }\n+            int expectedPos = position + iMaxParsedDigits;\n+            if (newPos != expectedPos) {\n+                if (iSigned) {\n+                    char c = text.charAt(position);\n+                    if (c == '-' || c == '+') {\n+                        expectedPos++;\n+                    }\n+                }\n+                if (newPos > expectedPos) {\n+                    // The failure is at the position of the first extra digit.\n+                    return ~(expectedPos + 1);\n+                } else if (newPos < expectedPos) {\n+                    // The failure is at the position where the next digit should be.\n+                    return ~newPos;\n+                }\n+            }\n+            return newPos;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class TwoDigitYear\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        /** The field to print/parse. */\n+        private final DateTimeFieldType iType;\n+        /** The pivot year. */\n+        private final int iPivot;\n+        private final boolean iLenientParse;\n+\n+        TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n+            super();\n+            iType = type;\n+            iPivot = pivot;\n+            iLenientParse = lenientParse;\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iLenientParse ? 4 : 2;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int limit = text.length() - position;\n+\n+            if (!iLenientParse) {\n+                limit = Math.min(2, limit);\n+                if (limit < 2) {\n+                    return ~position;\n+                }\n+            } else {\n+                boolean hasSignChar = false;\n+                boolean negative = false;\n+                int length = 0;\n+                while (length < limit) {\n+                    char c = text.charAt(position + length);\n+                    if (length == 0 && (c == '-' || c == '+')) {\n+                        hasSignChar = true;\n+                        negative = c == '-';\n+                        if (negative) {\n+                            length++;\n+                        } else {\n+                            // Skip the '+' for parseInt to succeed.\n+                            position++;\n+                            limit--;\n+                        }\n+                        continue;\n+                    }\n+                    if (c < '0' || c > '9') {\n+                        break;\n+                    }\n+                    length++;\n+                }\n+                \n+                if (length == 0) {\n+                    return ~position;\n+                }\n+\n+                if (hasSignChar || length != 2) {\n+                    int value;\n+                    if (length >= 9) {\n+                        // Since value may exceed integer limits, use stock\n+                        // parser which checks for this.\n+                        value = Integer.parseInt(text.substring(position, position += length));\n+                    } else {\n+                        int i = position;\n+                        if (negative) {\n+                            i++;\n+                        }\n+                        try {\n+                            value = text.charAt(i++) - '0';\n+                        } catch (StringIndexOutOfBoundsException e) {\n+                            return ~position;\n+                        }\n+                        position += length;\n+                        while (i < position) {\n+                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n+                        }\n+                        if (negative) {\n+                            value = -value;\n+                        }\n+                    }\n+                    \n+                    bucket.saveField(iType, value);\n+                    return position;\n+                }\n+            }\n+\n+            int year;\n+            char c = text.charAt(position);\n+            if (c < '0' || c > '9') {\n+                return ~position;\n+            }\n+            year = c - '0';\n+            c = text.charAt(position + 1);\n+            if (c < '0' || c > '9') {\n+                return ~position;\n+            }\n+            year = ((year << 3) + (year << 1)) + c - '0';\n+\n+            int pivot = iPivot;\n+            // If the bucket pivot year is non-null, use that when parsing\n+            if (bucket.getPivotYear() != null) {\n+                pivot = bucket.getPivotYear().intValue();\n+            }\n+\n+            int low = pivot - 50;\n+\n+            int t;\n+            if (low >= 0) {\n+                t = low % 100;\n+            } else {\n+                t = 99 + ((low + 1) % 100);\n+            }\n+\n+            year += low + ((year < t) ? 100 : 0) - t;\n+\n+            bucket.saveField(iType, year);\n+            return position + 2;\n+        }\n+        \n+        public int estimatePrintedLength() {\n+            return 2;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            int year = getTwoDigitYear(instant, chrono);\n+            if (year < 0) {\n+                buf.append('\\ufffd');\n+                buf.append('\\ufffd');\n+            } else {\n+                FormatUtils.appendPaddedInteger(buf, year, 2);\n+            }\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            int year = getTwoDigitYear(instant, chrono);\n+            if (year < 0) {\n+                out.write('\\ufffd');\n+                out.write('\\ufffd');\n+            } else {\n+                FormatUtils.writePaddedInteger(out, year, 2);\n+            }\n+        }\n+\n+        private int getTwoDigitYear(long instant, Chronology chrono) {\n+            try {\n+                int year = iType.getField(chrono).get(instant);\n+                if (year < 0) {\n+                    year = -year;\n+                }\n+                return year % 100;\n+            } catch (RuntimeException e) {\n+                return -1;\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            int year = getTwoDigitYear(partial);\n+            if (year < 0) {\n+                buf.append('\\ufffd');\n+                buf.append('\\ufffd');\n+            } else {\n+                FormatUtils.appendPaddedInteger(buf, year, 2);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            int year = getTwoDigitYear(partial);\n+            if (year < 0) {\n+                out.write('\\ufffd');\n+                out.write('\\ufffd');\n+            } else {\n+                FormatUtils.writePaddedInteger(out, year, 2);\n+            }\n+        }\n+\n+        private int getTwoDigitYear(ReadablePartial partial) {\n+            if (partial.isSupported(iType)) {\n+                try {\n+                    int year = partial.get(iType);\n+                    if (year < 0) {\n+                        year = -year;\n+                    }\n+                    return year % 100;\n+                } catch (RuntimeException e) {}\n+            } \n+            return -1;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class TextField\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache =\n+                    new HashMap<Locale, Map<DateTimeFieldType, Object[]>>();\n+        private final DateTimeFieldType iFieldType;\n+        private final boolean iShort;\n+\n+        TextField(DateTimeFieldType fieldType, boolean isShort) {\n+            super();\n+            iFieldType = fieldType;\n+            iShort = isShort;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iShort ? 6 : 20;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            try {\n+                buf.append(print(instant, chrono, locale));\n+            } catch (RuntimeException e) {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            try {\n+                out.write(print(instant, chrono, locale));\n+            } catch (RuntimeException e) {\n+                out.write('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            try {\n+                buf.append(print(partial, locale));\n+            } catch (RuntimeException e) {\n+                buf.append('\\ufffd');\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            try {\n+                out.write(print(partial, locale));\n+            } catch (RuntimeException e) {\n+                out.write('\\ufffd');\n+            }\n+        }\n+\n+        private String print(long instant, Chronology chrono, Locale locale) {\n+            DateTimeField field = iFieldType.getField(chrono);\n+            if (iShort) {\n+                return field.getAsShortText(instant, locale);\n+            } else {\n+                return field.getAsText(instant, locale);\n+            }\n+        }\n+\n+        private String print(ReadablePartial partial, Locale locale) {\n+            if (partial.isSupported(iFieldType)) {\n+                DateTimeField field = iFieldType.getField(partial.getChronology());\n+                if (iShort) {\n+                    return field.getAsShortText(partial, locale);\n+                } else {\n+                    return field.getAsText(partial, locale);\n+                }\n+            } else {\n+                return \"\\ufffd\";\n+            }\n+        }\n+\n+        public int estimateParsedLength() {\n+            return estimatePrintedLength();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            Locale locale = bucket.getLocale();\n+            // handle languages which might have non ASCII A-Z or punctuation\n+            // bug 1788282\n+            Set<String> validValues = null;\n+            int maxLength = 0;\n+            synchronized (cParseCache) {\n+                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);\n+                if (innerMap == null) {\n+                    innerMap = new HashMap<DateTimeFieldType, Object[]>();\n+                    cParseCache.put(locale, innerMap);\n+                }\n+                Object[] array = innerMap.get(iFieldType);\n+                if (array == null) {\n+                    validValues = new HashSet<String>(32);\n+                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n+                    Property property = dt.property(iFieldType);\n+                    int min = property.getMinimumValueOverall();\n+                    int max = property.getMaximumValueOverall();\n+                    if (max - min > 32) {  // protect against invalid fields\n+                        return ~position;\n+                    }\n+                    maxLength = property.getMaximumTextLength(locale);\n+                    for (int i = min; i <= max; i++) {\n+                        property.set(i);\n+                        validValues.add(property.getAsShortText(locale));\n+                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));\n+                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));\n+                        validValues.add(property.getAsText(locale));\n+                        validValues.add(property.getAsText(locale).toLowerCase(locale));\n+                        validValues.add(property.getAsText(locale).toUpperCase(locale));\n+                    }\n+                    if (\"en\".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n+                        // hack to support for parsing \"BCE\" and \"CE\" if the language is English\n+                        validValues.add(\"BCE\");\n+                        validValues.add(\"bce\");\n+                        validValues.add(\"CE\");\n+                        validValues.add(\"ce\");\n+                        maxLength = 3;\n+                    }\n+                    array = new Object[] {validValues, new Integer(maxLength)};\n+                    innerMap.put(iFieldType, array);\n+                } else {\n+                    validValues = (Set<String>) array[0];\n+                    maxLength = ((Integer) array[1]).intValue();\n+                }\n+            }\n+            // match the longest string first using our knowledge of the max length\n+            int limit = Math.min(text.length(), position + maxLength);\n+            for (int i = limit; i > position; i--) {\n+                String match = text.substring(position, i);\n+                if (validValues.contains(match)) {\n+                    bucket.saveField(iFieldType, match, locale);\n+                    return i;\n+                }\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class Fraction\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        private final DateTimeFieldType iFieldType;\n+        protected int iMinDigits;\n+        protected int iMaxDigits;\n+\n+        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n+            super();\n+            iFieldType = fieldType;\n+            // Limit the precision requirements.\n+            if (maxDigits > 18) {\n+                maxDigits = 18;\n+            }\n+            iMinDigits = minDigits;\n+            iMaxDigits = maxDigits;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iMaxDigits;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            try {\n+                printTo(buf, null, instant, chrono);\n+            } catch (IOException e) {\n+                // Not gonna happen.\n+            }\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            printTo(null, out, instant, chrono);\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            // removed check whether field is supported, as input field is typically\n+            // secondOfDay which is unsupported by TimeOfDay\n+            long millis = partial.getChronology().set(partial, 0L);\n+            try {\n+                printTo(buf, null, millis, partial.getChronology());\n+            } catch (IOException e) {\n+                // Not gonna happen.\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            // removed check whether field is supported, as input field is typically\n+            // secondOfDay which is unsupported by TimeOfDay\n+            long millis = partial.getChronology().set(partial, 0L);\n+            printTo(null, out, millis, partial.getChronology());\n+        }\n+\n+        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)\n+            throws IOException\n+        {\n+            DateTimeField field = iFieldType.getField(chrono);\n+            int minDigits = iMinDigits;\n+\n+            long fraction;\n+            try {\n+                fraction = field.remainder(instant);\n+            } catch (RuntimeException e) {\n+                if (buf != null) {\n+                    appendUnknownString(buf, minDigits);\n+                } else {\n+                    printUnknownString(out, minDigits);\n+                }\n+                return;\n+            }\n+\n+            if (fraction == 0) {\n+                if (buf != null) {\n+                    while (--minDigits >= 0) {\n+                        buf.append('0');\n+                    }\n+                } else {\n+                    while (--minDigits >= 0) {\n+                        out.write('0');\n+                    }\n+                }\n+                return;\n+            }\n+\n+            String str;\n+            long[] fractionData = getFractionData(fraction, field);\n+            long scaled = fractionData[0];\n+            int maxDigits = (int) fractionData[1];\n+            \n+            if ((scaled & 0x7fffffff) == scaled) {\n+                str = Integer.toString((int) scaled);\n+            } else {\n+                str = Long.toString(scaled);\n+            }\n+\n+            int length = str.length();\n+            int digits = maxDigits;\n+            while (length < digits) {\n+                if (buf != null) {\n+                    buf.append('0');\n+                } else {\n+                    out.write('0');\n+                }\n+                minDigits--;\n+                digits--;\n+            }\n+\n+            if (minDigits < digits) {\n+                // Chop off as many trailing zero digits as necessary.\n+                while (minDigits < digits) {\n+                    if (length <= 1 || str.charAt(length - 1) != '0') {\n+                        break;\n+                    }\n+                    digits--;\n+                    length--;\n+                }\n+                if (length < str.length()) {\n+                    if (buf != null) {\n+                        for (int i=0; i<length; i++) {\n+                            buf.append(str.charAt(i));\n+                        }\n+                    } else {\n+                        for (int i=0; i<length; i++) {\n+                            out.write(str.charAt(i));\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+\n+            if (buf != null) {\n+                buf.append(str);\n+            } else {\n+                out.write(str);\n+            }\n+        }\n+        \n+        private long[] getFractionData(long fraction, DateTimeField field) {\n+            long rangeMillis = field.getDurationField().getUnitMillis();\n+            long scalar;\n+            int maxDigits = iMaxDigits;\n+            while (true) {\n+                switch (maxDigits) {\n+                default: scalar = 1L; break;\n+                case 1:  scalar = 10L; break;\n+                case 2:  scalar = 100L; break;\n+                case 3:  scalar = 1000L; break;\n+                case 4:  scalar = 10000L; break;\n+                case 5:  scalar = 100000L; break;\n+                case 6:  scalar = 1000000L; break;\n+                case 7:  scalar = 10000000L; break;\n+                case 8:  scalar = 100000000L; break;\n+                case 9:  scalar = 1000000000L; break;\n+                case 10: scalar = 10000000000L; break;\n+                case 11: scalar = 100000000000L; break;\n+                case 12: scalar = 1000000000000L; break;\n+                case 13: scalar = 10000000000000L; break;\n+                case 14: scalar = 100000000000000L; break;\n+                case 15: scalar = 1000000000000000L; break;\n+                case 16: scalar = 10000000000000000L; break;\n+                case 17: scalar = 100000000000000000L; break;\n+                case 18: scalar = 1000000000000000000L; break;\n+                }\n+                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n+                    break;\n+                }\n+                // Overflowed: scale down.\n+                maxDigits--;\n+            }\n+            \n+            return new long[] {fraction * scalar / rangeMillis, maxDigits};\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iMaxDigits;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeField field = iFieldType.getField(bucket.getChronology());\n+            \n+            int limit = Math.min(iMaxDigits, text.length() - position);\n+\n+            long value = 0;\n+            long n = field.getDurationField().getUnitMillis() * 10;\n+            int length = 0;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                length++;\n+                long nn = n / 10;\n+                value += (c - '0') * nn;\n+                n = nn;\n+            }\n+\n+            value /= 10;\n+\n+            if (length == 0) {\n+                return ~position;\n+            }\n+\n+            if (value > Integer.MAX_VALUE) {\n+                return ~position;\n+            }\n+\n+            DateTimeField parseField = new PreciseDateTimeField(\n+                DateTimeFieldType.millisOfSecond(),\n+                MillisDurationField.INSTANCE,\n+                field.getDurationField());\n+\n+            bucket.saveField(parseField, (int) value);\n+\n+            return position + length;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class TimeZoneOffset\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        private final String iZeroOffsetPrintText;\n+        private final String iZeroOffsetParseText;\n+        private final boolean iShowSeparators;\n+        private final int iMinFields;\n+        private final int iMaxFields;\n+\n+        TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\n+                                boolean showSeparators,\n+                                int minFields, int maxFields)\n+        {\n+            super();\n+            iZeroOffsetPrintText = zeroOffsetPrintText;\n+            iZeroOffsetParseText = zeroOffsetParseText;\n+            iShowSeparators = showSeparators;\n+            if (minFields <= 0 || maxFields < minFields) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (minFields > 4) {\n+                minFields = 4;\n+                maxFields = 4;\n+            }\n+            iMinFields = minFields;\n+            iMaxFields = maxFields;\n+        }\n+            \n+        public int estimatePrintedLength() {\n+            int est = 1 + iMinFields << 1;\n+            if (iShowSeparators) {\n+                est += iMinFields - 1;\n+            }\n+            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n+                est = iZeroOffsetPrintText.length();\n+            }\n+            return est;\n+        }\n+        \n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            if (displayZone == null) {\n+                return;  // no zone\n+            }\n+            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n+                buf.append(iZeroOffsetPrintText);\n+                return;\n+            }\n+            if (displayOffset >= 0) {\n+                buf.append('+');\n+            } else {\n+                buf.append('-');\n+                displayOffset = -displayOffset;\n+            }\n+\n+            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n+            FormatUtils.appendPaddedInteger(buf, hours, 2);\n+            if (iMaxFields == 1) {\n+                return;\n+            }\n+            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n+            if (displayOffset == 0 && iMinFields <= 1) {\n+                return;\n+            }\n+\n+            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (iShowSeparators) {\n+                buf.append(':');\n+            }\n+            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n+            if (iMaxFields == 2) {\n+                return;\n+            }\n+            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (displayOffset == 0 && iMinFields <= 2) {\n+                return;\n+            }\n+\n+            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n+            if (iShowSeparators) {\n+                buf.append(':');\n+            }\n+            FormatUtils.appendPaddedInteger(buf, seconds, 2);\n+            if (iMaxFields == 3) {\n+                return;\n+            }\n+            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+            if (displayOffset == 0 && iMinFields <= 3) {\n+                return;\n+            }\n+\n+            if (iShowSeparators) {\n+                buf.append('.');\n+            }\n+            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n+        }\n+        \n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            if (displayZone == null) {\n+                return;  // no zone\n+            }\n+            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n+                out.write(iZeroOffsetPrintText);\n+                return;\n+            }\n+            if (displayOffset >= 0) {\n+                out.write('+');\n+            } else {\n+                out.write('-');\n+                displayOffset = -displayOffset;\n+            }\n+\n+            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n+            FormatUtils.writePaddedInteger(out, hours, 2);\n+            if (iMaxFields == 1) {\n+                return;\n+            }\n+            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n+            if (displayOffset == 0 && iMinFields == 1) {\n+                return;\n+            }\n+\n+            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (iShowSeparators) {\n+                out.write(':');\n+            }\n+            FormatUtils.writePaddedInteger(out, minutes, 2);\n+            if (iMaxFields == 2) {\n+                return;\n+            }\n+            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+            if (displayOffset == 0 && iMinFields == 2) {\n+                return;\n+            }\n+\n+            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n+            if (iShowSeparators) {\n+                out.write(':');\n+            }\n+            FormatUtils.writePaddedInteger(out, seconds, 2);\n+            if (iMaxFields == 3) {\n+                return;\n+            }\n+            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+            if (displayOffset == 0 && iMinFields == 3) {\n+                return;\n+            }\n+\n+            if (iShowSeparators) {\n+                out.write('.');\n+            }\n+            FormatUtils.writePaddedInteger(out, displayOffset, 3);\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            // no zone info\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            // no zone info\n+        }\n+\n+        public int estimateParsedLength() {\n+            return estimatePrintedLength();\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int limit = text.length() - position;\n+\n+            zeroOffset:\n+            if (iZeroOffsetParseText != null) {\n+                if (iZeroOffsetParseText.length() == 0) {\n+                    // Peek ahead, looking for sign character.\n+                    if (limit > 0) {\n+                        char c = text.charAt(position);\n+                        if (c == '-' || c == '+') {\n+                            break zeroOffset;\n+                        }\n+                    }\n+                    bucket.setOffset(0);\n+                    return position;\n+                }\n+                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n+                    bucket.setOffset(0);\n+                    return position + iZeroOffsetParseText.length();\n+                }\n+            }\n+\n+            // Format to expect is sign character followed by at least one digit.\n+\n+            if (limit <= 1) {\n+                return ~position;\n+            }\n+\n+            boolean negative;\n+            char c = text.charAt(position);\n+            if (c == '-') {\n+                negative = true;\n+            } else if (c == '+') {\n+                negative = false;\n+            } else {\n+                return ~position;\n+            }\n+\n+            limit--;\n+            position++;\n+\n+            // Format following sign is one of:\n+            //\n+            // hh\n+            // hhmm\n+            // hhmmss\n+            // hhmmssSSS\n+            // hh:mm\n+            // hh:mm:ss\n+            // hh:mm:ss.SSS\n+\n+            // First parse hours.\n+\n+            if (digitCount(text, position, 2) < 2) {\n+                // Need two digits for hour.\n+                return ~position;\n+            }\n+\n+            int offset;\n+\n+            int hours = FormatUtils.parseTwoDigits(text, position);\n+            if (hours > 23) {\n+                return ~position;\n+            }\n+            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n+            limit -= 2;\n+            position += 2;\n+\n+            parse: {\n+                // Need to decide now if separators are expected or parsing\n+                // stops at hour field.\n+\n+                if (limit <= 0) {\n+                    break parse;\n+                }\n+\n+                boolean expectSeparators;\n+                c = text.charAt(position);\n+                if (c == ':') {\n+                    expectSeparators = true;\n+                    limit--;\n+                    position++;\n+                } else if (c >= '0' && c <= '9') {\n+                    expectSeparators = false;\n+                } else {\n+                    break parse;\n+                }\n+\n+                // Proceed to parse minutes.\n+\n+                int count = digitCount(text, position, 2);\n+                if (count == 0 && !expectSeparators) {\n+                    break parse;\n+                } else if (count < 2) {\n+                    // Need two digits for minute.\n+                    return ~position;\n+                }\n+\n+                int minutes = FormatUtils.parseTwoDigits(text, position);\n+                if (minutes > 59) {\n+                    return ~position;\n+                }\n+                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n+                limit -= 2;\n+                position += 2;\n+\n+                // Proceed to parse seconds.\n+\n+                if (limit <= 0) {\n+                    break parse;\n+                }\n+\n+                if (expectSeparators) {\n+                    if (text.charAt(position) != ':') {\n+                        break parse;\n+                    }\n+                    limit--;\n+                    position++;\n+                }\n+\n+                count = digitCount(text, position, 2);\n+                if (count == 0 && !expectSeparators) {\n+                    break parse;\n+                } else if (count < 2) {\n+                    // Need two digits for second.\n+                    return ~position;\n+                }\n+\n+                int seconds = FormatUtils.parseTwoDigits(text, position);\n+                if (seconds > 59) {\n+                    return ~position;\n+                }\n+                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n+                limit -= 2;\n+                position += 2;\n+\n+                // Proceed to parse fraction of second.\n+\n+                if (limit <= 0) {\n+                    break parse;\n+                }\n+\n+                if (expectSeparators) {\n+                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n+                        break parse;\n+                    }\n+                    limit--;\n+                    position++;\n+                }\n+                \n+                count = digitCount(text, position, 3);\n+                if (count == 0 && !expectSeparators) {\n+                    break parse;\n+                } else if (count < 1) {\n+                    // Need at least one digit for fraction of second.\n+                    return ~position;\n+                }\n+\n+                offset += (text.charAt(position++) - '0') * 100;\n+                if (count > 1) {\n+                    offset += (text.charAt(position++) - '0') * 10;\n+                    if (count > 2) {\n+                        offset += text.charAt(position++) - '0';\n+                    }\n+                }\n+            }\n+\n+            bucket.setOffset(negative ? -offset : offset);\n+            return position;\n+        }\n+\n+        /**\n+         * Returns actual amount of digits to parse, but no more than original\n+         * 'amount' parameter.\n+         */\n+        private int digitCount(String text, int position, int amount) {\n+            int limit = Math.min(text.length() - position, amount);\n+            amount = 0;\n+            for (; limit > 0; limit--) {\n+                char c = text.charAt(position + amount);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                amount++;\n+            }\n+            return amount;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class TimeZoneName\n+            implements DateTimePrinter {\n+\n+        static final int LONG_NAME = 0;\n+        static final int SHORT_NAME = 1;\n+        static final int ID = 2;\n+\n+        private final int iType;\n+\n+        TimeZoneName(int type) {\n+            super();\n+            iType = type;\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return (iType == SHORT_NAME ? 4 : 20);\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            buf.append(print(instant - displayOffset, displayZone, locale));\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            out.write(print(instant - displayOffset, displayZone, locale));\n+        }\n+\n+        private String print(long instant, DateTimeZone displayZone, Locale locale) {\n+            if (displayZone == null) {\n+                return \"\";  // no zone\n+            }\n+            switch (iType) {\n+                case LONG_NAME:\n+                    return displayZone.getName(instant, locale);\n+                case SHORT_NAME:\n+                    return displayZone.getShortName(instant, locale);\n+                case ID:\n+                    return displayZone.getID();\n+            }\n+            return \"\";\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            // no zone info\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            // no zone info\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class Composite\n+            implements DateTimePrinter, DateTimeParser {\n+\n+        private final DateTimePrinter[] iPrinters;\n+        private final DateTimeParser[] iParsers;\n+\n+        private final int iPrintedLengthEstimate;\n+        private final int iParsedLengthEstimate;\n+\n+        Composite(List<Object> elementPairs) {\n+            super();\n+\n+            List<Object> printerList = new ArrayList<Object>();\n+            List<Object> parserList = new ArrayList<Object>();\n+\n+            decompose(elementPairs, printerList, parserList);\n+\n+            if (printerList.size() <= 0) {\n+                iPrinters = null;\n+                iPrintedLengthEstimate = 0;\n+            } else {\n+                int size = printerList.size();\n+                iPrinters = new DateTimePrinter[size];\n+                int printEst = 0;\n+                for (int i=0; i<size; i++) {\n+                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n+                    printEst += printer.estimatePrintedLength();\n+                    iPrinters[i] = printer;\n+                }\n+                iPrintedLengthEstimate = printEst;\n+            }\n+\n+            if (parserList.size() <= 0) {\n+                iParsers = null;\n+                iParsedLengthEstimate = 0;\n+            } else {\n+                int size = parserList.size();\n+                iParsers = new DateTimeParser[size];\n+                int parseEst = 0;\n+                for (int i=0; i<size; i++) {\n+                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n+                    parseEst += parser.estimateParsedLength();\n+                    iParsers[i] = parser;\n+                }\n+                iParsedLengthEstimate = parseEst;\n+            }\n+        }\n+\n+        public int estimatePrintedLength() {\n+            return iPrintedLengthEstimate;\n+        }\n+\n+        public void printTo(\n+                StringBuffer buf, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) {\n+            DateTimePrinter[] elements = iPrinters;\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            if (locale == null) {\n+                // Guard against default locale changing concurrently.\n+                locale = Locale.getDefault();\n+            }\n+\n+            int len = elements.length;\n+            for (int i = 0; i < len; i++) {\n+                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n+            }\n+        }\n+\n+        public void printTo(\n+                Writer out, long instant, Chronology chrono,\n+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n+            DateTimePrinter[] elements = iPrinters;\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            if (locale == null) {\n+                // Guard against default locale changing concurrently.\n+                locale = Locale.getDefault();\n+            }\n+\n+            int len = elements.length;\n+            for (int i = 0; i < len; i++) {\n+                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);\n+            }\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n+            DateTimePrinter[] elements = iPrinters;\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            if (locale == null) {\n+                // Guard against default locale changing concurrently.\n+                locale = Locale.getDefault();\n+            }\n+\n+            int len = elements.length;\n+            for (int i=0; i<len; i++) {\n+                elements[i].printTo(buf, partial, locale);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n+            DateTimePrinter[] elements = iPrinters;\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            if (locale == null) {\n+                // Guard against default locale changing concurrently.\n+                locale = Locale.getDefault();\n+            }\n+\n+            int len = elements.length;\n+            for (int i=0; i<len; i++) {\n+                elements[i].printTo(out, partial, locale);\n+            }\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iParsedLengthEstimate;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeParser[] elements = iParsers;\n+            if (elements == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = elements.length;\n+            for (int i=0; i<len && position >= 0; i++) {\n+                position = elements[i].parseInto(bucket, text, position);\n+            }\n+            return position;\n+        }\n+\n+        boolean isPrinter() {\n+            return iPrinters != null;\n+        }\n+\n+        boolean isParser() {\n+            return iParsers != null;\n+        }\n+\n+        /**\n+         * Processes the element pairs, putting results into the given printer\n+         * and parser lists.\n+         */\n+        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n+            int size = elementPairs.size();\n+            for (int i=0; i<size; i+=2) {\n+                Object element = elementPairs.get(i);\n+                if (element instanceof DateTimePrinter) {\n+                    if (element instanceof Composite) {\n+                        addArrayToList(printerList, ((Composite)element).iPrinters);\n+                    } else {\n+                        printerList.add(element);\n+                    }\n+                }\n+\n+                element = elementPairs.get(i + 1);\n+                if (element instanceof DateTimeParser) {\n+                    if (element instanceof Composite) {\n+                        addArrayToList(parserList, ((Composite)element).iParsers);\n+                    } else {\n+                        parserList.add(element);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void addArrayToList(List<Object> list, Object[] array) {\n+            if (array != null) {\n+                for (int i=0; i<array.length; i++) {\n+                    list.add(array[i]);\n+                }\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class MatchingParser\n+            implements DateTimeParser {\n+\n+        private final DateTimeParser[] iParsers;\n+        private final int iParsedLengthEstimate;\n+\n+        MatchingParser(DateTimeParser[] parsers) {\n+            super();\n+            iParsers = parsers;\n+            int est = 0;\n+            for (int i=parsers.length; --i>=0 ;) {\n+                DateTimeParser parser = parsers[i];\n+                if (parser != null) {\n+                    int len = parser.estimateParsedLength();\n+                    if (len > est) {\n+                        est = len;\n+                    }\n+                }\n+            }\n+            iParsedLengthEstimate = est;\n+        }\n+\n+        public int estimateParsedLength() {\n+            return iParsedLengthEstimate;\n+        }\n+\n+        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            DateTimeParser[] parsers = iParsers;\n+            int length = parsers.length;\n+\n+            final Object originalState = bucket.saveState();\n+            boolean isOptional = false;\n+\n+            int bestValidPos = position;\n+            Object bestValidState = null;\n+\n+            int bestInvalidPos = position;\n+\n+            for (int i=0; i<length; i++) {\n+                DateTimeParser parser = parsers[i];\n+                if (parser == null) {\n+                    // The empty parser wins only if nothing is better.\n+                    if (bestValidPos <= position) {\n+                        return position;\n+                    }\n+                    isOptional = true;\n+                    break;\n+                }\n+                int parsePos = parser.parseInto(bucket, text, position);\n+                if (parsePos >= position) {\n+                    if (parsePos > bestValidPos) {\n+                        if (parsePos >= text.length() ||\n+                            (i + 1) >= length || parsers[i + 1] == null) {\n+\n+                            // Completely parsed text or no more parsers to\n+                            // check. Skip the rest.\n+                            return parsePos;\n+                        }\n+                        bestValidPos = parsePos;\n+                        bestValidState = bucket.saveState();\n+                    }\n+                } else {\n+                    if (parsePos < 0) {\n+                        parsePos = ~parsePos;\n+                        if (parsePos > bestInvalidPos) {\n+                            bestInvalidPos = parsePos;\n+                        }\n+                    }\n+                }\n+                bucket.restoreState(originalState);\n+            }\n+\n+            if (bestValidPos > position || (bestValidPos == position && isOptional)) {\n+                // Restore the state to the best valid parse.\n+                if (bestValidState != null) {\n+                    bucket.restoreState(bestValidState);\n+                }\n+                return bestValidPos;\n+            }\n+\n+            return ~bestInvalidPos;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeParser.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+/**\n+ * Internal interface for parsing textual representations of datetimes.\n+ * <p>\n+ * Application users will rarely use this class directly. Instead, you\n+ * will use one of the factory classes to create a {@link DateTimeFormatter}.\n+ * <p>\n+ * The factory classes are:<br />\n+ * - {@link DateTimeFormatterBuilder}<br />\n+ * - {@link DateTimeFormat}<br />\n+ * - {@link ISODateTimeFormat}<br />\n+ *\n+ * @author Brian S O'Neill\n+ * @see DateTimeFormatter\n+ * @see DateTimeFormatterBuilder\n+ * @see DateTimeFormat\n+ * @since 1.0\n+ */\n+public interface DateTimeParser {\n+\n+    /**\n+     * Returns the expected maximum number of characters consumed.\n+     * The actual amount should rarely exceed this estimate.\n+     * \n+     * @return the estimated length\n+     */\n+    int estimateParsedLength();\n+\n+    /**\n+     * Parse an element from the given text, saving any fields into the given\n+     * DateTimeParserBucket. If the parse succeeds, the return value is the new\n+     * text position. Note that the parse may succeed without fully reading the\n+     * text.\n+     * <p>\n+     * If it fails, the return value is negative. To determine the position\n+     * where the parse failed, apply the one's complement operator (~) on the\n+     * return value.\n+     *\n+     * @param bucket  field are saved into this, not null\n+     * @param text  the text to parse, not null\n+     * @param position  position to start parsing from\n+     * @return new position, negative value means parse failed -\n+     *  apply complement operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(DateTimeParserBucket bucket, String text, int position);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationField;\n+import org.joda.time.IllegalFieldValueException;\n+\n+/**\n+ * DateTimeParserBucket is an advanced class, intended mainly for parser\n+ * implementations. It can also be used during normal parsing operations to\n+ * capture more information about the parse.\n+ * <p>\n+ * This class allows fields to be saved in any order, but be physically set in\n+ * a consistent order. This is useful for parsing against formats that allow\n+ * field values to contradict each other.\n+ * <p>\n+ * Field values are applied in an order where the \"larger\" fields are set\n+ * first, making their value less likely to stick.  A field is larger than\n+ * another when it's range duration is longer. If both ranges are the same,\n+ * then the larger field has the longer duration. If it cannot be determined\n+ * which field is larger, then the fields are set in the order they were saved.\n+ * <p>\n+ * For example, these fields were saved in this order: dayOfWeek, monthOfYear,\n+ * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in\n+ * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.\n+ * <p>\n+ * DateTimeParserBucket is mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Fredrik Borgh\n+ * @since 1.0\n+ */\n+public class DateTimeParserBucket {\n+\n+    /** The chronology to use for parsing. */\n+    private final Chronology iChrono;\n+    private final long iMillis;\n+    \n+    // TimeZone to switch to in computeMillis. If null, use offset.\n+    private DateTimeZone iZone;\n+    private int iOffset;\n+    /** The locale to use for parsing. */\n+    private Locale iLocale;\n+    /** Used for parsing two-digit years. */\n+    private Integer iPivotYear;\n+\n+    private SavedField[] iSavedFields = new SavedField[8];\n+    private int iSavedFieldsCount;\n+    private boolean iSavedFieldsShared;\n+    \n+    private Object iSavedState;\n+\n+    /**\n+     * Constucts a bucket.\n+     * \n+     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n+     * @param chrono  the chronology to use\n+     * @param locale  the locale to use\n+     */\n+    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n+        this(instantLocal, chrono, locale, null);\n+    }\n+\n+    /**\n+     * Constucts a bucket, with the option of specifying the pivot year for\n+     * two-digit year parsing.\n+     *\n+     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n+     * @param chrono  the chronology to use\n+     * @param locale  the locale to use\n+     * @param pivotYear  the pivot year to use when parsing two-digit years\n+     * @since 1.1\n+     */\n+    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n+        super();\n+        chrono = DateTimeUtils.getChronology(chrono);\n+        iMillis = instantLocal;\n+        iChrono = chrono.withUTC();\n+        iLocale = (locale == null ? Locale.getDefault() : locale);\n+        setZone(chrono.getZone());\n+        iPivotYear = pivotYear;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n+     */\n+    public Chronology getChronology() {\n+        return iChrono;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the locale to be used during parsing.\n+     * \n+     * @return the locale to use\n+     */\n+    public Locale getLocale() {\n+        return iLocale;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the time zone used by computeMillis, or null if an offset is\n+     * used instead.\n+     */\n+    public DateTimeZone getZone() {\n+        return iZone;\n+    }\n+    \n+    /**\n+     * Set a time zone to be used when computeMillis is called, which\n+     * overrides any set time zone offset.\n+     *\n+     * @param zone the date time zone to operate in, or null if UTC\n+     */\n+    public void setZone(DateTimeZone zone) {\n+        iSavedState = null;\n+        iZone = zone == DateTimeZone.UTC ? null : zone;\n+        iOffset = 0;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the time zone offset in milliseconds used by computeMillis,\n+     * unless getZone doesn't return null.\n+     */\n+    public int getOffset() {\n+        return iOffset;\n+    }\n+    \n+    /**\n+     * Set a time zone offset to be used when computeMillis is called, which\n+     * overrides the time zone.\n+     */\n+    public void setOffset(int offset) {\n+        iSavedState = null;\n+        iOffset = offset;\n+        iZone = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the pivot year used for parsing two-digit years.\n+     * <p>\n+     * If null is returned, this indicates default behaviour\n+     *\n+     * @return Integer value of the pivot year, null if not set\n+     * @since 1.1\n+     */\n+    public Integer getPivotYear() {\n+        return iPivotYear;\n+    }\n+\n+    /**\n+     * Sets the pivot year to use when parsing two digit years.\n+     * <p>\n+     * If the value is set to null, this will indicate that default\n+     * behaviour should be used.\n+     *\n+     * @param pivotYear  the pivot year to use\n+     * @since 1.1\n+     */\n+    public void setPivotYear(Integer pivotYear) {\n+        iPivotYear = pivotYear;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Saves a datetime field value.\n+     * \n+     * @param field  the field, whose chronology must match that of this bucket\n+     * @param value  the value\n+     */\n+    public void saveField(DateTimeField field, int value) {\n+        saveField(new SavedField(field, value));\n+    }\n+    \n+    /**\n+     * Saves a datetime field value.\n+     * \n+     * @param fieldType  the field type\n+     * @param value  the value\n+     */\n+    public void saveField(DateTimeFieldType fieldType, int value) {\n+        saveField(new SavedField(fieldType.getField(iChrono), value));\n+    }\n+    \n+    /**\n+     * Saves a datetime field text value.\n+     * \n+     * @param fieldType  the field type\n+     * @param text  the text value\n+     * @param locale  the locale to use\n+     */\n+    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n+        saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n+    }\n+    \n+    private void saveField(SavedField field) {\n+        SavedField[] savedFields = iSavedFields;\n+        int savedFieldsCount = iSavedFieldsCount;\n+        \n+        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n+            // Expand capacity or merely copy if saved fields are shared.\n+            SavedField[] newArray = new SavedField\n+                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n+            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n+            iSavedFields = savedFields = newArray;\n+            iSavedFieldsShared = false;\n+        }\n+        \n+        iSavedState = null;\n+        savedFields[savedFieldsCount] = field;\n+        iSavedFieldsCount = savedFieldsCount + 1;\n+    }\n+    \n+    /**\n+     * Saves the state of this bucket, returning it in an opaque object. Call\n+     * restoreState to undo any changes that were made since the state was\n+     * saved. Calls to saveState may be nested.\n+     *\n+     * @return opaque saved state, which may be passed to restoreState\n+     */\n+    public Object saveState() {\n+        if (iSavedState == null) {\n+            iSavedState = new SavedState();\n+        }\n+        return iSavedState;\n+    }\n+    \n+    /**\n+     * Restores the state of this bucket from a previously saved state. The\n+     * state object passed into this method is not consumed, and it can be used\n+     * later to restore to that state again.\n+     *\n+     * @param savedState opaque saved state, returned from saveState\n+     * @return true state object is valid and state restored\n+     */\n+    public boolean restoreState(Object savedState) {\n+        if (savedState instanceof SavedState) {\n+            if (((SavedState) savedState).restoreState(this)) {\n+                iSavedState = savedState;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Computes the parsed datetime by setting the saved fields.\n+     * This method is idempotent, but it is not thread-safe.\n+     *\n+     * @return milliseconds since 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public long computeMillis() {\n+        return computeMillis(false, null);\n+    }\n+    \n+    /**\n+     * Computes the parsed datetime by setting the saved fields.\n+     * This method is idempotent, but it is not thread-safe.\n+     *\n+     * @param resetFields false by default, but when true, unsaved field values are cleared\n+     * @return milliseconds since 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public long computeMillis(boolean resetFields) {\n+        return computeMillis(resetFields, null);\n+    }\n+\n+    /**\n+     * Computes the parsed datetime by setting the saved fields.\n+     * This method is idempotent, but it is not thread-safe.\n+     *\n+     * @param resetFields false by default, but when true, unsaved field values are cleared\n+     * @param text optional text being parsed, to be included in any error message\n+     * @return milliseconds since 1970-01-01T00:00:00Z\n+     * @throws IllegalArgumentException if any field is out of range\n+     * @since 1.3\n+     */\n+    public long computeMillis(boolean resetFields, String text) {\n+        SavedField[] savedFields = iSavedFields;\n+        int count = iSavedFieldsCount;\n+        if (iSavedFieldsShared) {\n+            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n+            iSavedFieldsShared = false;\n+        }\n+        sort(savedFields, count);\n+\n+        long millis = iMillis;\n+        try {\n+            for (int i=0; i<count; i++) {\n+                millis = savedFields[i].set(millis, resetFields);\n+            }\n+        } catch (IllegalFieldValueException e) {\n+            if (text != null) {\n+                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+            }\n+            throw e;\n+        }\n+        \n+        if (iZone == null) {\n+            millis -= iOffset;\n+        } else {\n+            int offset = iZone.getOffsetFromLocal(millis);\n+            millis -= offset;\n+            if (offset != iZone.getOffset(millis)) {\n+                String message =\n+                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n+                if (text != null) {\n+                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n+                }\n+                throw new IllegalArgumentException(message);\n+            }\n+        }\n+        \n+        return millis;\n+    }\n+    \n+    /**\n+     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n+     * choice since it always creates an internal copy of the array, even if it\n+     * doesn't need to. If the array slice is small enough, an insertion sort\n+     * is chosen instead, but it doesn't need a copy!\n+     * <p>\n+     * This method has a modified version of that insertion sort, except it\n+     * doesn't create an unnecessary array copy. If high is over 10, then\n+     * java.util.Arrays is called, which will perform a merge sort, which is\n+     * faster than insertion sort on large lists.\n+     * <p>\n+     * The end result is much greater performance when computeMillis is called.\n+     * Since the amount of saved fields is small, the insertion sort is a\n+     * better choice. Additional performance is gained since there is no extra\n+     * array allocation and copying. Also, the insertion sort here does not\n+     * perform any casting operations. The version in java.util.Arrays performs\n+     * casts within the insertion sort loop.\n+     */\n+    private static void sort(SavedField[] array, int high) {\n+        if (high > 10) {\n+            Arrays.sort(array, 0, high);\n+        } else {\n+            for (int i=0; i<high; i++) {\n+                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n+                    SavedField t = array[j];\n+                    array[j] = array[j-1];\n+                    array[j-1] = t;\n+                }\n+            }\n+        }\n+    }\n+\n+    class SavedState {\n+        final DateTimeZone iZone;\n+        final int iOffset;\n+        final SavedField[] iSavedFields;\n+        final int iSavedFieldsCount;\n+        \n+        SavedState() {\n+            this.iZone = DateTimeParserBucket.this.iZone;\n+            this.iOffset = DateTimeParserBucket.this.iOffset;\n+            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n+            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n+        }\n+        \n+        boolean restoreState(DateTimeParserBucket enclosing) {\n+            if (enclosing != DateTimeParserBucket.this) {\n+                return false;\n+            }\n+            enclosing.iZone = this.iZone;\n+            enclosing.iOffset = this.iOffset;\n+            enclosing.iSavedFields = this.iSavedFields;\n+            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n+                // Since count is being restored to a lower count, the\n+                // potential exists for new saved fields to destroy data being\n+                // shared by another state. Set this flag such that the array\n+                // of saved fields is cloned prior to modification.\n+                enclosing.iSavedFieldsShared = true;\n+            }\n+            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n+            return true;\n+        }\n+    }\n+    \n+    static class SavedField implements Comparable<SavedField> {\n+        final DateTimeField iField;\n+        final int iValue;\n+        final String iText;\n+        final Locale iLocale;\n+        \n+        SavedField(DateTimeField field, int value) {\n+            iField = field;\n+            iValue = value;\n+            iText = null;\n+            iLocale = null;\n+        }\n+        \n+        SavedField(DateTimeField field, String text, Locale locale) {\n+            iField = field;\n+            iValue = 0;\n+            iText = text;\n+            iLocale = locale;\n+        }\n+        \n+        long set(long millis, boolean reset) {\n+            if (iText == null) {\n+                millis = iField.set(millis, iValue);\n+            } else {\n+                millis = iField.set(millis, iText, iLocale);\n+            }\n+            if (reset) {\n+                millis = iField.roundFloor(millis);\n+            }\n+            return millis;\n+        }\n+        \n+        /**\n+         * The field with the longer range duration is ordered first, where\n+         * null is considered infinite. If the ranges match, then the field\n+         * with the longer duration is ordered first.\n+         */\n+        public int compareTo(SavedField obj) {\n+            DateTimeField other = obj.iField;\n+            int result = compareReverse\n+                (iField.getRangeDurationField(), other.getRangeDurationField());\n+            if (result != 0) {\n+                return result;\n+            }\n+            return compareReverse\n+                (iField.getDurationField(), other.getDurationField());\n+        }\n+        \n+        private int compareReverse(DurationField a, DurationField b) {\n+            if (a == null || !a.isSupported()) {\n+                if (b == null || !b.isSupported()) {\n+                    return 0;\n+                }\n+                return -1;\n+            }\n+            if (b == null || !b.isSupported()) {\n+                return 1;\n+            }\n+            return -a.compareTo(b);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimePrinter.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Locale;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.ReadablePartial;\n+\n+/**\n+ * Internal interface for creating textual representations of datetimes.\n+ * <p>\n+ * Application users will rarely use this class directly. Instead, you\n+ * will use one of the factory classes to create a {@link DateTimeFormatter}.\n+ * <p>\n+ * The factory classes are:<br />\n+ * - {@link DateTimeFormatterBuilder}<br />\n+ * - {@link DateTimeFormat}<br />\n+ * - {@link ISODateTimeFormat}<br />\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @see DateTimeFormatterBuilder\n+ * @see DateTimeFormat\n+ * @see ISODateTimeFormat\n+ * @since 1.0\n+ */\n+public interface DateTimePrinter {\n+\n+    /**\n+     * Returns the expected maximum number of characters produced.\n+     * The actual amount should rarely exceed this estimate.\n+     * \n+     * @return the estimated length\n+     */\n+    int estimatePrintedLength();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the given Chronology.\n+     *\n+     * @param buf  formatted instant is appended to this buffer, not null\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param chrono  the chronology to use, not null\n+     * @param displayOffset  if a time zone offset is printed, force it to use\n+     * this millisecond value\n+     * @param displayZone  the time zone to use, null means local time\n+     * @param locale  the locale to use, null means default locale\n+     */\n+    void printTo(StringBuffer buf, long instant, Chronology chrono,\n+                 int displayOffset, DateTimeZone displayZone, Locale locale);\n+\n+    /**\n+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,\n+     * using the given Chronology.\n+     *\n+     * @param out  formatted instant is written out\n+     * @param instant  millis since 1970-01-01T00:00:00Z\n+     * @param chrono  the chronology to use, not null\n+     * @param displayOffset  if a time zone offset is printed, force it to use\n+     * this millisecond value\n+     * @param displayZone  the time zone to use, null means local time\n+     * @param locale  the locale to use, null means default locale\n+     */\n+    void printTo(Writer out, long instant, Chronology chrono,\n+                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadablePartial.\n+     *\n+     * @param buf  formatted partial is appended to this buffer, not null\n+     * @param partial  partial to format, not null\n+     * @param locale  the locale to use, null means default locale\n+     */\n+    void printTo(StringBuffer buf, ReadablePartial partial, Locale locale);\n+\n+    /**\n+     * Prints a ReadablePartial.\n+     *\n+     * @param out  formatted partial is written out, not null\n+     * @param partial  partial to format, not null\n+     * @param locale  the locale to use, null means default locale\n+     */\n+    void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException;\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/FormatUtils.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Utility methods used by formatters.\n+ * <p>\n+ * FormatUtils is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class FormatUtils {\n+\n+    private static final double LOG_10 = Math.log(10);\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private FormatUtils() {\n+    }\n+\n+    /**\n+     * Converts an integer to a string, prepended with a variable amount of '0'\n+     * pad characters, and appends it to the given buffer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param buf receives integer converted to a string\n+     * @param value value to convert to a string\n+     * @param size minumum amount of digits to append\n+     */\n+    public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\n+        if (value < 0) {\n+            buf.append('-');\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                for (; size > 10; size--) {\n+                    buf.append('0');\n+                }\n+                buf.append(\"\" + -(long)Integer.MIN_VALUE);\n+                return;\n+            }\n+        }\n+        if (value < 10) {\n+            for (; size > 1; size--) {\n+                buf.append('0');\n+            }\n+            buf.append((char)(value + '0'));\n+        } else if (value < 100) {\n+            for (; size > 2; size--) {\n+                buf.append('0');\n+            }\n+            // Calculate value div/mod by 10 without using two expensive\n+            // division operations. (2 ^ 27) / 10 = 13421772. Add one to\n+            // value to correct rounding error.\n+            int d = ((value + 1) * 13421772) >> 27;\n+            buf.append((char) (d + '0'));\n+            // Append remainder by calculating (value - d * 10).\n+            buf.append((char) (value - (d << 3) - (d << 1) + '0'));\n+        } else {\n+            int digits;\n+            if (value < 1000) {\n+                digits = 3;\n+            } else if (value < 10000) {\n+                digits = 4;\n+            } else {\n+                digits = (int)(Math.log(value) / LOG_10) + 1;\n+            }\n+            for (; size > digits; size--) {\n+                buf.append('0');\n+            }\n+            buf.append(Integer.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, prepended with a variable amount of '0'\n+     * pad characters, and appends it to the given buffer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param buf receives integer converted to a string\n+     * @param value value to convert to a string\n+     * @param size minumum amount of digits to append\n+     */\n+    public static void appendPaddedInteger(StringBuffer buf, long value, int size) {\n+        int intValue = (int)value;\n+        if (intValue == value) {\n+            appendPaddedInteger(buf, intValue, size);\n+        } else if (size <= 19) {\n+            buf.append(Long.toString(value));\n+        } else {\n+            if (value < 0) {\n+                buf.append('-');\n+                if (value != Long.MIN_VALUE) {\n+                    value = -value;\n+                } else {\n+                    for (; size > 19; size--) {\n+                        buf.append('0');\n+                    }\n+                    buf.append(\"9223372036854775808\");\n+                    return;\n+                }\n+            }\n+            int digits = (int)(Math.log(value) / LOG_10) + 1;\n+            for (; size > digits; size--) {\n+                buf.append('0');\n+            }\n+            buf.append(Long.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, prepended with a variable amount of '0'\n+     * pad characters, and writes it to the given writer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param out receives integer converted to a string\n+     * @param value value to convert to a string\n+     * @param size minumum amount of digits to append\n+     */\n+    public static void writePaddedInteger(Writer out, int value, int size)\n+        throws IOException\n+    {\n+        if (value < 0) {\n+            out.write('-');\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                for (; size > 10; size--) {\n+                    out.write('0');\n+                }\n+                out.write(\"\" + -(long)Integer.MIN_VALUE);\n+                return;\n+            }\n+        }\n+        if (value < 10) {\n+            for (; size > 1; size--) {\n+                out.write('0');\n+            }\n+            out.write(value + '0');\n+        } else if (value < 100) {\n+            for (; size > 2; size--) {\n+                out.write('0');\n+            }\n+            // Calculate value div/mod by 10 without using two expensive\n+            // division operations. (2 ^ 27) / 10 = 13421772. Add one to\n+            // value to correct rounding error.\n+            int d = ((value + 1) * 13421772) >> 27;\n+            out.write(d + '0');\n+            // Append remainder by calculating (value - d * 10).\n+            out.write(value - (d << 3) - (d << 1) + '0');\n+        } else {\n+            int digits;\n+            if (value < 1000) {\n+                digits = 3;\n+            } else if (value < 10000) {\n+                digits = 4;\n+            } else {\n+                digits = (int)(Math.log(value) / LOG_10) + 1;\n+            }\n+            for (; size > digits; size--) {\n+                out.write('0');\n+            }\n+            out.write(Integer.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, prepended with a variable amount of '0'\n+     * pad characters, and writes it to the given writer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param out receives integer converted to a string\n+     * @param value value to convert to a string\n+     * @param size minumum amount of digits to append\n+     */\n+    public static void writePaddedInteger(Writer out, long value, int size)\n+        throws IOException\n+    {\n+        int intValue = (int)value;\n+        if (intValue == value) {\n+            writePaddedInteger(out, intValue, size);\n+        } else if (size <= 19) {\n+            out.write(Long.toString(value));\n+        } else {\n+            if (value < 0) {\n+                out.write('-');\n+                if (value != Long.MIN_VALUE) {\n+                    value = -value;\n+                } else {\n+                    for (; size > 19; size--) {\n+                        out.write('0');\n+                    }\n+                    out.write(\"9223372036854775808\");\n+                    return;\n+                }\n+            }\n+            int digits = (int)(Math.log(value) / LOG_10) + 1;\n+            for (; size > digits; size--) {\n+                out.write('0');\n+            }\n+            out.write(Long.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, and appends it to the given buffer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param buf receives integer converted to a string\n+     * @param value value to convert to a string\n+     */\n+    public static void appendUnpaddedInteger(StringBuffer buf, int value) {\n+        if (value < 0) {\n+            buf.append('-');\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                buf.append(\"\" + -(long)Integer.MIN_VALUE);\n+                return;\n+            }\n+        }\n+        if (value < 10) {\n+            buf.append((char)(value + '0'));\n+        } else if (value < 100) {\n+            // Calculate value div/mod by 10 without using two expensive\n+            // division operations. (2 ^ 27) / 10 = 13421772. Add one to\n+            // value to correct rounding error.\n+            int d = ((value + 1) * 13421772) >> 27;\n+            buf.append((char) (d + '0'));\n+            // Append remainder by calculating (value - d * 10).\n+            buf.append((char) (value - (d << 3) - (d << 1) + '0'));\n+        } else {\n+            buf.append(Integer.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, and appends it to the given buffer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param buf receives integer converted to a string\n+     * @param value value to convert to a string\n+     */\n+    public static void appendUnpaddedInteger(StringBuffer buf, long value) {\n+        int intValue = (int)value;\n+        if (intValue == value) {\n+            appendUnpaddedInteger(buf, intValue);\n+        } else {\n+            buf.append(Long.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, and writes it to the given writer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param out receives integer converted to a string\n+     * @param value value to convert to a string\n+     */\n+    public static void writeUnpaddedInteger(Writer out, int value)\n+        throws IOException\n+    {\n+        if (value < 0) {\n+            out.write('-');\n+            if (value != Integer.MIN_VALUE) {\n+                value = -value;\n+            } else {\n+                out.write(\"\" + -(long)Integer.MIN_VALUE);\n+                return;\n+            }\n+        }\n+        if (value < 10) {\n+            out.write(value + '0');\n+        } else if (value < 100) {\n+            // Calculate value div/mod by 10 without using two expensive\n+            // division operations. (2 ^ 27) / 10 = 13421772. Add one to\n+            // value to correct rounding error.\n+            int d = ((value + 1) * 13421772) >> 27;\n+            out.write(d + '0');\n+            // Append remainder by calculating (value - d * 10).\n+            out.write(value - (d << 3) - (d << 1) + '0');\n+        } else {\n+            out.write(Integer.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Converts an integer to a string, and writes it to the given writer.\n+     *\n+     * <p>This method is optimized for converting small values to strings.\n+     *\n+     * @param out receives integer converted to a string\n+     * @param value value to convert to a string\n+     */\n+    public static void writeUnpaddedInteger(Writer out, long value)\n+        throws IOException\n+    {\n+        int intValue = (int)value;\n+        if (intValue == value) {\n+            writeUnpaddedInteger(out, intValue);\n+        } else {\n+            out.write(Long.toString(value));\n+        }\n+    }\n+\n+    /**\n+     * Calculates the number of decimal digits for the given value,\n+     * including the sign.\n+     */\n+    public static int calculateDigitCount(long value) {\n+        if (value < 0) {\n+            if (value != Long.MIN_VALUE) {\n+                return calculateDigitCount(-value) + 1;\n+            } else {\n+                return 20;\n+            }\n+        }\n+        return \n+            (value < 10 ? 1 :\n+             (value < 100 ? 2 :\n+              (value < 1000 ? 3 :\n+               (value < 10000 ? 4 :\n+                ((int)(Math.log(value) / LOG_10) + 1)))));\n+    }\n+\n+    static int parseTwoDigits(String text, int position) {\n+        int value = text.charAt(position) - '0';\n+        return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';\n+    }\n+\n+    static String createErrorMessage(final String text, final int errorPos) {\n+        int sampleLen = errorPos + 32;\n+        String sampleText;\n+        if (text.length() <= sampleLen + 3) {\n+            sampleText = text;\n+        } else {\n+            sampleText = text.substring(0, sampleLen).concat(\"...\");\n+        }\n+        \n+        if (errorPos <= 0) {\n+            return \"Invalid format: \\\"\" + sampleText + '\"';\n+        }\n+        \n+        if (errorPos >= text.length()) {\n+            return \"Invalid format: \\\"\" + sampleText + \"\\\" is too short\";\n+        }\n+        \n+        return \"Invalid format: \\\"\" + sampleText + \"\\\" is malformed at \\\"\" +\n+            sampleText.substring(errorPos) + '\"';\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/ISODateTimeFormat.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.joda.time.DateTimeFieldType;\n+\n+/**\n+ * Factory that creates instances of DateTimeFormatter for the ISO8601 standard.\n+ * <p>\n+ * Datetime formatting is performed by the {@link DateTimeFormatter} class.\n+ * Three classes provide factory methods to create formatters, and this is one.\n+ * The others are {@link DateTimeFormat} and {@link DateTimeFormatterBuilder}.\n+ * <p>\n+ * ISO8601 is the international standard for data interchange. It defines a\n+ * framework, rather than an absolute standard. As a result this provider has a\n+ * number of methods that represent common uses of the framework. The most common\n+ * formats are {@link #date() date}, {@link #time() time}, and {@link #dateTime() dateTime}.\n+ * <p>\n+ * For example, to format a date time in ISO format:\n+ * <pre>\n+ * DateTime dt = new DateTime();\n+ * DateTimeFormatter fmt = ISODateTimeFormat.dateTime();\n+ * String str = fmt.print(dt);\n+ * </pre>\n+ * <p>\n+ * It is important to understand that these formatters are not linked to\n+ * the <code>ISOChronology</code>. These formatters may be used with any\n+ * chronology, however there may be certain side effects with more unusual\n+ * chronologies. For example, the ISO formatters rely on dayOfWeek being\n+ * single digit, dayOfMonth being two digit and dayOfYear being three digit.\n+ * A chronology with a ten day week would thus cause issues. However, in\n+ * general, it is safe to use these formatters with other chronologies.\n+ * <p>\n+ * ISODateTimeFormat is thread-safe and immutable, and the formatters it\n+ * returns are as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DateTimeFormat\n+ * @see DateTimeFormatterBuilder\n+ */\n+public class ISODateTimeFormat {\n+\n+    //-----------------------------------------------------------------------\n+    private static DateTimeFormatter\n+        ye,  // year element (yyyy)\n+        mye, // monthOfYear element (-MM)\n+        dme, // dayOfMonth element (-dd)\n+        we,  // weekyear element (xxxx)\n+        wwe, // weekOfWeekyear element (-ww)\n+        dwe, // dayOfWeek element (-ee)\n+        dye, // dayOfYear element (-DDD)\n+        hde, // hourOfDay element (HH)\n+        mhe, // minuteOfHour element (:mm)\n+        sme, // secondOfMinute element (:ss)\n+        fse, // fractionOfSecond element (.SSSSSSSSS)\n+        ze,  // zone offset element\n+        lte, // literal 'T' element\n+        \n+        //y,   // year (same as year element)\n+        ym,  // year month\n+        ymd, // year month day\n+\n+        //w,   // weekyear (same as weekyear element)\n+        ww,  // weekyear week\n+        wwd, // weekyear week day\n+\n+        //h,    // hour (same as hour element)\n+        hm,   // hour minute\n+        hms,  // hour minute second\n+        hmsl, // hour minute second millis\n+        hmsf, // hour minute second fraction\n+\n+        dh,    // date hour\n+        dhm,   // date hour minute\n+        dhms,  // date hour minute second\n+        dhmsl, // date hour minute second millis\n+        dhmsf, // date hour minute second fraction\n+\n+        //d,  // date (same as ymd)\n+        t,  // time\n+        tx,  // time no millis\n+        tt,  // Ttime\n+        ttx,  // Ttime no millis\n+        dt, // date time\n+        dtx, // date time no millis\n+\n+        //wd,  // week date (same as wwd)\n+        wdt, // week date time\n+        wdtx, // week date time no millis\n+\n+        od,  // ordinal date (same as yd)\n+        odt, // ordinal date time\n+        odtx, // ordinal date time no millis\n+\n+        bd,  // basic date\n+        bt,  // basic time\n+        btx,  // basic time no millis\n+        btt, // basic Ttime\n+        bttx, // basic Ttime no millis\n+        bdt, // basic date time\n+        bdtx, // basic date time no millis\n+\n+        bod,  // basic ordinal date\n+        bodt, // basic ordinal date time\n+        bodtx, // basic ordinal date time no millis\n+\n+        bwd,  // basic week date\n+        bwdt, // basic week date time\n+        bwdtx, // basic week date time no millis\n+\n+        dpe, // date parser element\n+        tpe, // time parser element\n+        dp,  // date parser\n+        ldp, // local date parser\n+        tp,  // time parser\n+        ltp, // local time parser\n+        dtp, // date time parser\n+        dotp, // date optional time parser\n+        ldotp; // local date optional time parser\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @since 1.1 (previously private)\n+     */\n+    protected ISODateTimeFormat() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a formatter that outputs only those fields specified.\n+     * <p>\n+     * This method examines the fields provided and returns an ISO-style\n+     * formatter that best fits. This can be useful for outputting\n+     * less-common ISO styles, such as YearMonth (YYYY-MM) or MonthDay (--MM-DD).\n+     * <p>\n+     * The list provided may have overlapping fields, such as dayOfWeek and\n+     * dayOfMonth. In this case, the style is chosen based on the following\n+     * list, thus in the example, the calendar style is chosen as dayOfMonth\n+     * is higher in priority than dayOfWeek:\n+     * <ul>\n+     * <li>monthOfYear - calendar date style\n+     * <li>dayOfYear - ordinal date style\n+     * <li>weekOfWeekYear - week date style\n+     * <li>dayOfMonth - calendar date style\n+     * <li>dayOfWeek - week date style\n+     * <li>year\n+     * <li>weekyear\n+     * </ul>\n+     * The supported formats are:\n+     * <pre>\n+     * Extended      Basic       Fields\n+     * 2005-03-25    20050325    year/monthOfYear/dayOfMonth\n+     * 2005-03       2005-03     year/monthOfYear\n+     * 2005--25      2005--25    year/dayOfMonth *\n+     * 2005          2005        year\n+     * --03-25       --0325      monthOfYear/dayOfMonth\n+     * --03          --03        monthOfYear\n+     * ---03         ---03       dayOfMonth\n+     * 2005-084      2005084     year/dayOfYear\n+     * -084          -084        dayOfYear\n+     * 2005-W12-5    2005W125    weekyear/weekOfWeekyear/dayOfWeek\n+     * 2005-W-5      2005W-5     weekyear/dayOfWeek *\n+     * 2005-W12      2005W12     weekyear/weekOfWeekyear\n+     * -W12-5        -W125       weekOfWeekyear/dayOfWeek\n+     * -W12          -W12        weekOfWeekyear\n+     * -W-5          -W-5        dayOfWeek\n+     * 10:20:30.040  102030.040  hour/minute/second/milli\n+     * 10:20:30      102030      hour/minute/second\n+     * 10:20         1020        hour/minute\n+     * 10            10          hour\n+     * -20:30.040    -2030.040   minute/second/milli\n+     * -20:30        -2030       minute/second\n+     * -20           -20         minute\n+     * --30.040      --30.040    second/milli\n+     * --30          --30        second\n+     * ---.040       ---.040     milli *\n+     * 10-30.040     10-30.040   hour/second/milli *\n+     * 10:20-.040    1020-.040   hour/minute/milli *\n+     * 10-30         10-30       hour/second *\n+     * 10--.040      10--.040    hour/milli *\n+     * -20-.040      -20-.040    minute/milli *\n+     *   plus datetime formats like {date}T{time}\n+     * </pre>\n+     * * indiates that this is not an official ISO format and can be excluded\n+     * by passing in <code>strictISO</code> as <code>true</code>.\n+     * <p>\n+     * This method can side effect the input collection of fields.\n+     * If the input collection is modifiable, then each field that was added to\n+     * the formatter will be removed from the collection, including any duplicates.\n+     * If the input collection is unmodifiable then no side effect occurs.\n+     * <p>\n+     * This side effect processing is useful if you need to know whether all\n+     * the fields were converted into the formatter or not. To achieve this,\n+     * pass in a modifiable list, and check that it is empty on exit.\n+     *\n+     * @param fields  the fields to get a formatter for, not null,\n+     *  updated by the method call unless unmodifiable,\n+     *  removing those fields built in the formatter\n+     * @param extended  true to use the extended format (with separators)\n+     * @param strictISO  true to stick exactly to ISO8601, false to include additional formats\n+     * @return a suitable formatter\n+     * @throws IllegalArgumentException if there is no format for the fields\n+     * @since 1.1\n+     */\n+    public static DateTimeFormatter forFields(\n+        Collection<DateTimeFieldType> fields,\n+        boolean extended,\n+        boolean strictISO) {\n+        \n+        if (fields == null || fields.size() == 0) {\n+            throw new IllegalArgumentException(\"The fields must not be null or empty\");\n+        }\n+        Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields);\n+        int inputSize = workingFields.size();\n+        boolean reducedPrec = false;\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n+        // date\n+        if (workingFields.contains(DateTimeFieldType.monthOfYear())) {\n+            reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) {\n+            reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) {\n+            reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) {\n+            reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) {\n+            reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n+        } else if (workingFields.remove(DateTimeFieldType.year())) {\n+            bld.append(yearElement());\n+            reducedPrec = true;\n+        } else if (workingFields.remove(DateTimeFieldType.weekyear())) {\n+            bld.append(weekyearElement());\n+            reducedPrec = true;\n+        }\n+        boolean datePresent = (workingFields.size() < inputSize);\n+        \n+        // time\n+        time(bld, workingFields, extended, strictISO, reducedPrec, datePresent);\n+        \n+        // result\n+        if (bld.canBuildFormatter() == false) {\n+            throw new IllegalArgumentException(\"No valid format for fields: \" + fields);\n+        }\n+        \n+        // side effect the input collection to indicate the processed fields\n+        // handling unmodifiable collections with no side effect\n+        try {\n+            fields.retainAll(workingFields);\n+        } catch (UnsupportedOperationException ex) {\n+            // ignore, so we can handle unmodifiable collections\n+        }\n+        return bld.toFormatter();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a date using the calendar date format.\n+     * Specification reference: 5.2.1.\n+     *\n+     * @param bld  the builder\n+     * @param fields  the fields\n+     * @param extended  true to use extended format\n+     * @param strictISO  true to only allow ISO formats\n+     * @return true if reduced precision\n+     * @since 1.1\n+     */\n+    private static boolean dateByMonth(\n+        DateTimeFormatterBuilder bld,\n+        Collection<DateTimeFieldType> fields,\n+        boolean extended,\n+        boolean strictISO) {\n+        \n+        boolean reducedPrec = false;\n+        if (fields.remove(DateTimeFieldType.year())) {\n+            bld.append(yearElement());\n+            if (fields.remove(DateTimeFieldType.monthOfYear())) {\n+                if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n+                    // YYYY-MM-DD/YYYYMMDD\n+                    appendSeparator(bld, extended);\n+                    bld.appendMonthOfYear(2);\n+                    appendSeparator(bld, extended);\n+                    bld.appendDayOfMonth(2);\n+                } else {\n+                    // YYYY-MM/YYYY-MM\n+                    bld.appendLiteral('-');\n+                    bld.appendMonthOfYear(2);\n+                    reducedPrec = true;\n+                }\n+            } else {\n+                if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n+                    // YYYY--DD/YYYY--DD (non-iso)\n+                    checkNotStrictISO(fields, strictISO);\n+                    bld.appendLiteral('-');\n+                    bld.appendLiteral('-');\n+                    bld.appendDayOfMonth(2);\n+                } else {\n+                    // YYYY/YYYY\n+                    reducedPrec = true;\n+                }\n+            }\n+            \n+        } else if (fields.remove(DateTimeFieldType.monthOfYear())) {\n+            bld.appendLiteral('-');\n+            bld.appendLiteral('-');\n+            bld.appendMonthOfYear(2);\n+            if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n+                // --MM-DD/--MMDD\n+                appendSeparator(bld, extended);\n+                bld.appendDayOfMonth(2);\n+            } else {\n+                // --MM/--MM\n+                reducedPrec = true;\n+            }\n+        } else if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n+            // ---DD/---DD\n+            bld.appendLiteral('-');\n+            bld.appendLiteral('-');\n+            bld.appendLiteral('-');\n+            bld.appendDayOfMonth(2);\n+        }\n+        return reducedPrec;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a date using the ordinal date format.\n+     * Specification reference: 5.2.2.\n+     *\n+     * @param bld  the builder\n+     * @param fields  the fields\n+     * @param extended  true to use extended format\n+     * @param strictISO  true to only allow ISO formats\n+     * @since 1.1\n+     */\n+    private static boolean dateByOrdinal(\n+        DateTimeFormatterBuilder bld,\n+        Collection<DateTimeFieldType> fields,\n+        boolean extended,\n+        boolean strictISO) {\n+        \n+        boolean reducedPrec = false;\n+        if (fields.remove(DateTimeFieldType.year())) {\n+            bld.append(yearElement());\n+            if (fields.remove(DateTimeFieldType.dayOfYear())) {\n+                // YYYY-DDD/YYYYDDD\n+                appendSeparator(bld, extended);\n+                bld.appendDayOfYear(3);\n+            } else {\n+                // YYYY/YYYY\n+                reducedPrec = true;\n+            }\n+            \n+        } else if (fields.remove(DateTimeFieldType.dayOfYear())) {\n+            // -DDD/-DDD\n+            bld.appendLiteral('-');\n+            bld.appendDayOfYear(3);\n+        }\n+        return reducedPrec;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a date using the calendar date format.\n+     * Specification reference: 5.2.3.\n+     *\n+     * @param bld  the builder\n+     * @param fields  the fields\n+     * @param extended  true to use extended format\n+     * @param strictISO  true to only allow ISO formats\n+     * @since 1.1\n+     */\n+    private static boolean dateByWeek(\n+        DateTimeFormatterBuilder bld,\n+        Collection<DateTimeFieldType> fields,\n+        boolean extended,\n+        boolean strictISO) {\n+        \n+        boolean reducedPrec = false;\n+        if (fields.remove(DateTimeFieldType.weekyear())) {\n+            bld.append(weekyearElement());\n+            if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\n+                appendSeparator(bld, extended);\n+                bld.appendLiteral('W');\n+                bld.appendWeekOfWeekyear(2);\n+                if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n+                    // YYYY-WWW-D/YYYYWWWD\n+                    appendSeparator(bld, extended);\n+                    bld.appendDayOfWeek(1);\n+                } else {\n+                    // YYYY-WWW/YYYY-WWW\n+                    reducedPrec = true;\n+                }\n+            } else {\n+                if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n+                    // YYYY-W-D/YYYYW-D (non-iso)\n+                    checkNotStrictISO(fields, strictISO);\n+                    appendSeparator(bld, extended);\n+                    bld.appendLiteral('W');\n+                    bld.appendLiteral('-');\n+                    bld.appendDayOfWeek(1);\n+                } else {\n+                    // YYYY/YYYY\n+                    reducedPrec = true;\n+                }\n+            }\n+            \n+        } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\n+            bld.appendLiteral('-');\n+            bld.appendLiteral('W');\n+            bld.appendWeekOfWeekyear(2);\n+            if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n+                // -WWW-D/-WWWD\n+                appendSeparator(bld, extended);\n+                bld.appendDayOfWeek(1);\n+            } else {\n+                // -WWW/-WWW\n+                reducedPrec = true;\n+            }\n+        } else if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n+            // -W-D/-W-D\n+            bld.appendLiteral('-');\n+            bld.appendLiteral('W');\n+            bld.appendLiteral('-');\n+            bld.appendDayOfWeek(1);\n+        }\n+        return reducedPrec;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds the time fields to the builder.\n+     * Specification reference: 5.3.1.\n+     * \n+     * @param bld  the builder\n+     * @param fields  the fields\n+     * @param extended  whether to use the extended format\n+     * @param strictISO  whether to be strict\n+     * @param reducedPrec  whether the date was reduced precision\n+     * @param datePresent  whether there was a date\n+     * @since 1.1\n+     */\n+    private static void time(\n+        DateTimeFormatterBuilder bld,\n+        Collection<DateTimeFieldType> fields,\n+        boolean extended,\n+        boolean strictISO,\n+        boolean reducedPrec,\n+        boolean datePresent) {\n+        \n+        boolean hour = fields.remove(DateTimeFieldType.hourOfDay());\n+        boolean minute = fields.remove(DateTimeFieldType.minuteOfHour());\n+        boolean second = fields.remove(DateTimeFieldType.secondOfMinute());\n+        boolean milli = fields.remove(DateTimeFieldType.millisOfSecond());\n+        if (!hour && !minute && !second && !milli) {\n+            return;\n+        }\n+        if (hour || minute || second || milli) {\n+            if (strictISO && reducedPrec) {\n+                throw new IllegalArgumentException(\"No valid ISO8601 format for fields because Date was reduced precision: \" + fields);\n+            }\n+            if (datePresent) {\n+                bld.appendLiteral('T');\n+            }\n+        }\n+        if (hour && minute && second || (hour && !second && !milli)) {\n+            // OK - HMSm/HMS/HM/H - valid in combination with date\n+        } else {\n+            if (strictISO && datePresent) {\n+                throw new IllegalArgumentException(\"No valid ISO8601 format for fields because Time was truncated: \" + fields);\n+            }\n+            if (!hour && (minute && second || (minute && !milli) || second)) {\n+                // OK - MSm/MS/M/Sm/S - valid ISO formats\n+            } else {\n+                if (strictISO) {\n+                    throw new IllegalArgumentException(\"No valid ISO8601 format for fields: \" + fields);\n+                }\n+            }\n+        }\n+        if (hour) {\n+            bld.appendHourOfDay(2);\n+        } else if (minute || second || milli) {\n+            bld.appendLiteral('-');\n+        }\n+        if (extended && hour && minute) {\n+            bld.appendLiteral(':');\n+        }\n+        if (minute) {\n+            bld.appendMinuteOfHour(2);\n+        } else if (second || milli) {\n+            bld.appendLiteral('-');\n+        }\n+        if (extended && minute && second) {\n+            bld.appendLiteral(':');\n+        }\n+        if (second) {\n+            bld.appendSecondOfMinute(2);\n+        } else if (milli) {\n+            bld.appendLiteral('-');\n+        }\n+        if (milli) {\n+            bld.appendLiteral('.');\n+            bld.appendMillisOfSecond(3);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks that the iso only flag is not set, throwing an exception if it is.\n+     * \n+     * @param fields  the fields\n+     * @param strictISO  true if only ISO formats allowed\n+     * @since 1.1\n+     */\n+    private static void checkNotStrictISO(Collection<DateTimeFieldType> fields, boolean strictISO) {\n+        if (strictISO) {\n+            throw new IllegalArgumentException(\"No valid ISO8601 format for fields: \" + fields);\n+        }\n+    }\n+\n+    /**\n+     * Appends the separator if necessary.\n+     *\n+     * @param bld  the builder\n+     * @param extended  whether to append the separator\n+     * @param sep  the separator\n+     * @since 1.1\n+     */\n+    private static void appendSeparator(DateTimeFormatterBuilder bld, boolean extended) {\n+        if (extended) {\n+            bld.appendLiteral('-');\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a generic ISO date parser for parsing dates with a possible zone.\n+     * It accepts formats described by the following syntax:\n+     * <pre>\n+     * date              = date-element ['T' offset]\n+     * date-element      = std-date-element | ord-date-element | week-date-element\n+     * std-date-element  = yyyy ['-' MM ['-' dd]]\n+     * ord-date-element  = yyyy ['-' DDD]\n+     * week-date-element = xxxx '-W' ww ['-' e]\n+     * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])\n+     * </pre>\n+     */\n+    public static DateTimeFormatter dateParser() {\n+        if (dp == null) {\n+            DateTimeParser tOffset = new DateTimeFormatterBuilder()\n+                .appendLiteral('T')\n+                .append(offsetElement()).toParser();\n+            dp = new DateTimeFormatterBuilder()\n+                .append(dateElementParser())\n+                .appendOptional(tOffset)\n+                .toFormatter();\n+        }\n+        return dp;\n+    }\n+\n+    /**\n+     * Returns a generic ISO date parser for parsing local dates.\n+     * This parser is initialised with the local (UTC) time zone.\n+     * <p>\n+     * It accepts formats described by the following syntax:\n+     * <pre>\n+     * date-element      = std-date-element | ord-date-element | week-date-element\n+     * std-date-element  = yyyy ['-' MM ['-' dd]]\n+     * ord-date-element  = yyyy ['-' DDD]\n+     * week-date-element = xxxx '-W' ww ['-' e]\n+     * </pre>\n+     * @since 1.3\n+     */\n+    public static DateTimeFormatter localDateParser() {\n+        if (ldp == null) {\n+            ldp = dateElementParser().withZoneUTC();\n+        }\n+        return ldp;\n+    }\n+\n+    /**\n+     * Returns a generic ISO date parser for parsing dates.\n+     * It accepts formats described by the following syntax:\n+     * <pre>\n+     * date-element      = std-date-element | ord-date-element | week-date-element\n+     * std-date-element  = yyyy ['-' MM ['-' dd]]\n+     * ord-date-element  = yyyy ['-' DDD]\n+     * week-date-element = xxxx '-W' ww ['-' e]\n+     * </pre>\n+     */\n+    public static DateTimeFormatter dateElementParser() {\n+        if (dpe == null) {\n+            dpe = new DateTimeFormatterBuilder()\n+                .append(null, new DateTimeParser[] {\n+                    new DateTimeFormatterBuilder()\n+                    .append(yearElement())\n+                    .appendOptional\n+                    (new DateTimeFormatterBuilder()\n+                     .append(monthElement())\n+                     .appendOptional(dayOfMonthElement().getParser())\n+                     .toParser())\n+                    .toParser(),\n+                    new DateTimeFormatterBuilder()\n+                    .append(weekyearElement())\n+                    .append(weekElement())\n+                    .appendOptional(dayOfWeekElement().getParser())\n+                    .toParser(),\n+                    new DateTimeFormatterBuilder()\n+                    .append(yearElement())\n+                    .append(dayOfYearElement())\n+                    .toParser()\n+                })\n+                .toFormatter();\n+        }\n+        return dpe;\n+    }\n+\n+    /**\n+     * Returns a generic ISO time parser for parsing times with a possible zone.\n+     * It accepts formats described by the following syntax:\n+     * <pre>\n+     * time           = ['T'] time-element [offset]\n+     * time-element   = HH [minute-element] | [fraction]\n+     * minute-element = ':' mm [second-element] | [fraction]\n+     * second-element = ':' ss [fraction]\n+     * fraction       = ('.' | ',') digit+\n+     * offset         = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])\n+     * </pre>\n+     */\n+    public static DateTimeFormatter timeParser() {\n+        if (tp == null) {\n+            tp = new DateTimeFormatterBuilder()\n+                .appendOptional(literalTElement().getParser())\n+                .append(timeElementParser())\n+                .appendOptional(offsetElement().getParser())\n+                .toFormatter();\n+        }\n+        return tp;\n+    }\n+\n+    /**\n+     * Returns a generic ISO time parser for parsing local times.\n+     * This parser is initialised with the local (UTC) time zone.\n+     * <p>\n+     * It accepts formats described by the following syntax:\n+     * <pre>\n+     * time           = ['T'] time-element\n+     * time-element   = HH [minute-element] | [fraction]\n+     * minute-element = ':' mm [second-element] | [fraction]\n+     * second-element = ':' ss [fraction]\n+     * fraction       = ('.' | ',') digit+\n+     * </pre>\n+     * @since 1.3\n+     */\n+    public static DateTimeFormatter localTimeParser() {\n+        if (ltp == null) {\n+            ltp = new DateTimeFormatterBuilder()\n+                .appendOptional(literalTElement().getParser())\n+                .append(timeElementParser())\n+                .toFormatter().withZoneUTC();\n+        }\n+        return ltp;\n+    }\n+\n+    /**\n+     * Returns a generic ISO time parser. It accepts formats described by\n+     * the following syntax:\n+     * <pre>\n+     * time-element   = HH [minute-element] | [fraction]\n+     * minute-element = ':' mm [second-element] | [fraction]\n+     * second-element = ':' ss [fraction]\n+     * fraction       = ('.' | ',') digit+\n+     * </pre>\n+     */\n+    public static DateTimeFormatter timeElementParser() {\n+        if (tpe == null) {\n+            // Decimal point can be either '.' or ','\n+            DateTimeParser decimalPoint = new DateTimeFormatterBuilder()\n+                .append(null, new DateTimeParser[] {\n+                    new DateTimeFormatterBuilder()\n+                    .appendLiteral('.')\n+                    .toParser(),\n+                    new DateTimeFormatterBuilder()\n+                    .appendLiteral(',')\n+                    .toParser()\n+                })\n+                .toParser();\n+\n+            tpe = new DateTimeFormatterBuilder()\n+                // time-element\n+                .append(hourElement())\n+                .append\n+                (null, new DateTimeParser[] {\n+                    new DateTimeFormatterBuilder()\n+                    // minute-element\n+                    .append(minuteElement())\n+                    .append\n+                    (null, new DateTimeParser[] {\n+                        new DateTimeFormatterBuilder()\n+                        // second-element\n+                        .append(secondElement())\n+                        // second fraction\n+                        .appendOptional(new DateTimeFormatterBuilder()\n+                                        .append(decimalPoint)\n+                                        .appendFractionOfSecond(1, 9)\n+                                        .toParser())\n+                        .toParser(),\n+                        // minute fraction\n+                        new DateTimeFormatterBuilder()\n+                        .append(decimalPoint)\n+                        .appendFractionOfMinute(1, 9)\n+                        .toParser(),\n+                        null\n+                    })\n+                    .toParser(),\n+                    // hour fraction\n+                    new DateTimeFormatterBuilder()\n+                    .append(decimalPoint)\n+                    .appendFractionOfHour(1, 9)\n+                    .toParser(),\n+                    null\n+                })\n+                .toFormatter();\n+        }\n+        return tpe;\n+    }\n+\n+    /**\n+     * Returns a generic ISO datetime parser which parses either a date or\n+     * a time or both. It accepts formats described by the following syntax:\n+     * <pre>\n+     * datetime          = time | date-opt-time\n+     * time              = 'T' time-element [offset]\n+     * date-opt-time     = date-element ['T' [time-element] [offset]]\n+     * date-element      = std-date-element | ord-date-element | week-date-element\n+     * std-date-element  = yyyy ['-' MM ['-' dd]]\n+     * ord-date-element  = yyyy ['-' DDD]\n+     * week-date-element = xxxx '-W' ww ['-' e]\n+     * time-element      = HH [minute-element] | [fraction]\n+     * minute-element    = ':' mm [second-element] | [fraction]\n+     * second-element    = ':' ss [fraction]\n+     * fraction          = ('.' | ',') digit+\n+     * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])\n+     * </pre>\n+     */\n+    public static DateTimeFormatter dateTimeParser() {\n+        if (dtp == null) {\n+            // This is different from the general time parser in that the 'T'\n+            // is required.\n+            DateTimeParser time = new DateTimeFormatterBuilder()\n+                .appendLiteral('T')\n+                .append(timeElementParser())\n+                .appendOptional(offsetElement().getParser())\n+                .toParser();\n+            dtp = new DateTimeFormatterBuilder()\n+                .append(null, new DateTimeParser[] {time, dateOptionalTimeParser().getParser()})\n+                .toFormatter();\n+        }\n+        return dtp;\n+    }\n+\n+    /**\n+     * Returns a generic ISO datetime parser where the date is mandatory and\n+     * the time is optional. This parser can parse zoned datetimes.\n+     * It accepts formats described by the following syntax:\n+     * <pre>\n+     * date-opt-time     = date-element ['T' [time-element] [offset]]\n+     * date-element      = std-date-element | ord-date-element | week-date-element\n+     * std-date-element  = yyyy ['-' MM ['-' dd]]\n+     * ord-date-element  = yyyy ['-' DDD]\n+     * week-date-element = xxxx '-W' ww ['-' e]\n+     * time-element      = HH [minute-element] | [fraction]\n+     * minute-element    = ':' mm [second-element] | [fraction]\n+     * second-element    = ':' ss [fraction]\n+     * fraction          = ('.' | ',') digit+\n+     * </pre>\n+     * @since 1.3\n+     */\n+    public static DateTimeFormatter dateOptionalTimeParser() {\n+        if (dotp == null) {\n+            DateTimeParser timeOrOffset = new DateTimeFormatterBuilder()\n+                .appendLiteral('T')\n+                .appendOptional(timeElementParser().getParser())\n+                .appendOptional(offsetElement().getParser())\n+                .toParser();\n+            dotp = new DateTimeFormatterBuilder()\n+                .append(dateElementParser())\n+                .appendOptional(timeOrOffset)\n+                .toFormatter();\n+        }\n+        return dotp;\n+    }\n+\n+    /**\n+     * Returns a generic ISO datetime parser where the date is mandatory and\n+     * the time is optional. This parser only parses local datetimes.\n+     * This parser is initialised with the local (UTC) time zone.\n+     * <p>\n+     * It accepts formats described by the following syntax:\n+     * <pre>\n+     * datetime          = date-element ['T' time-element]\n+     * date-element      = std-date-element | ord-date-element | week-date-element\n+     * std-date-element  = yyyy ['-' MM ['-' dd]]\n+     * ord-date-element  = yyyy ['-' DDD]\n+     * week-date-element = xxxx '-W' ww ['-' e]\n+     * time-element      = HH [minute-element] | [fraction]\n+     * minute-element    = ':' mm [second-element] | [fraction]\n+     * second-element    = ':' ss [fraction]\n+     * fraction          = ('.' | ',') digit+\n+     * </pre>\n+     * @since 1.3\n+     */\n+    public static DateTimeFormatter localDateOptionalTimeParser() {\n+        if (ldotp == null) {\n+            DateTimeParser time = new DateTimeFormatterBuilder()\n+                .appendLiteral('T')\n+                .append(timeElementParser())\n+                .toParser();\n+            ldotp = new DateTimeFormatterBuilder()\n+                .append(dateElementParser())\n+                .appendOptional(time)\n+                .toFormatter().withZoneUTC();\n+        }\n+        return ldotp;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a formatter for a full date as four digit year, two digit month\n+     * of year, and two digit day of month (yyyy-MM-dd).\n+     * \n+     * @return a formatter for yyyy-MM-dd\n+     */\n+    public static DateTimeFormatter date() {\n+        return yearMonthDay();\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, three digit fraction of second, and\n+     * time zone offset (HH:mm:ss.SSSZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for HH:mm:ss.SSSZZ\n+     */\n+    public static DateTimeFormatter time() {\n+        if (t == null) {\n+            t = new DateTimeFormatterBuilder()\n+                .append(hourMinuteSecondFraction())\n+                .append(offsetElement())\n+                .toFormatter();\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, and time zone offset (HH:mm:ssZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for HH:mm:ssZZ\n+     */\n+    public static DateTimeFormatter timeNoMillis() {\n+        if (tx == null) {\n+            tx = new DateTimeFormatterBuilder()\n+                .append(hourMinuteSecond())\n+                .append(offsetElement())\n+                .toFormatter();\n+        }\n+        return tx;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, three digit fraction of second, and\n+     * time zone offset prefixed by 'T' ('T'HH:mm:ss.SSSZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for 'T'HH:mm:ss.SSSZZ\n+     */\n+    public static DateTimeFormatter tTime() {\n+        if (tt == null) {\n+            tt = new DateTimeFormatterBuilder()\n+                .append(literalTElement())\n+                .append(time())\n+                .toFormatter();\n+        }\n+        return tt;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, and time zone offset prefixed\n+     * by 'T' ('T'HH:mm:ssZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for 'T'HH:mm:ssZZ\n+     */\n+    public static DateTimeFormatter tTimeNoMillis() {\n+        if (ttx == null) {\n+            ttx = new DateTimeFormatterBuilder()\n+                .append(literalTElement())\n+                .append(timeNoMillis())\n+                .toFormatter();\n+        }\n+        return ttx;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date and time, separated by a 'T'\n+     * (yyyy-MM-dd'T'HH:mm:ss.SSSZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSSZZ\n+     */\n+    public static DateTimeFormatter dateTime() {\n+        if (dt == null) {\n+            dt = new DateTimeFormatterBuilder()\n+                .append(date())\n+                .append(tTime())\n+                .toFormatter();\n+        }\n+        return dt;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date and time without millis,\n+     * separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for yyyy-MM-dd'T'HH:mm:ssZZ\n+     */\n+    public static DateTimeFormatter dateTimeNoMillis() {\n+        if (dtx == null) {\n+            dtx = new DateTimeFormatterBuilder()\n+                .append(date())\n+                .append(tTimeNoMillis())\n+                .toFormatter();\n+        }\n+        return dtx;\n+    }\n+\n+    /**\n+     * Returns a formatter for a full ordinal date, using a four\n+     * digit year and three digit dayOfYear (yyyy-DDD).\n+     * \n+     * @return a formatter for yyyy-DDD\n+     * @since 1.1\n+     */\n+    public static DateTimeFormatter ordinalDate() {\n+        if (od == null) {\n+            od = new DateTimeFormatterBuilder()\n+                .append(yearElement())\n+                .append(dayOfYearElement())\n+                .toFormatter();\n+        }\n+        return od;\n+    }\n+\n+    /**\n+     * Returns a formatter for a full ordinal date and time, using a four\n+     * digit year and three digit dayOfYear (yyyy-DDD'T'HH:mm:ss.SSSZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for yyyy-DDD'T'HH:mm:ss.SSSZZ\n+     * @since 1.1\n+     */\n+    public static DateTimeFormatter ordinalDateTime() {\n+        if (odt == null) {\n+            odt = new DateTimeFormatterBuilder()\n+                .append(ordinalDate())\n+                .append(tTime())\n+                .toFormatter();\n+        }\n+        return odt;\n+    }\n+\n+    /**\n+     * Returns a formatter for a full ordinal date and time without millis,\n+     * using a four digit year and three digit dayOfYear (yyyy-DDD'T'HH:mm:ssZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for yyyy-DDD'T'HH:mm:ssZZ\n+     * @since 1.1\n+     */\n+    public static DateTimeFormatter ordinalDateTimeNoMillis() {\n+        if (odtx == null) {\n+            odtx = new DateTimeFormatterBuilder()\n+                .append(ordinalDate())\n+                .append(tTimeNoMillis())\n+                .toFormatter();\n+        }\n+        return odtx;\n+    }\n+\n+    /**\n+     * Returns a formatter for a full date as four digit weekyear, two digit\n+     * week of weekyear, and one digit day of week (xxxx-'W'ww-e).\n+     * \n+     * @return a formatter for xxxx-'W'ww-e\n+     */\n+    public static DateTimeFormatter weekDate() {\n+        return weekyearWeekDay();\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full weekyear date and time,\n+     * separated by a 'T' (xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ\n+     */\n+    public static DateTimeFormatter weekDateTime() {\n+        if (wdt == null) {\n+            wdt = new DateTimeFormatterBuilder()\n+                .append(weekDate())\n+                .append(tTime())\n+                .toFormatter();\n+        }\n+        return wdt;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full weekyear date and time without millis,\n+     * separated by a 'T' (xxxx-'W'ww-e'T'HH:mm:ssZZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n+     * \n+     * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ssZZ\n+     */\n+    public static DateTimeFormatter weekDateTimeNoMillis() {\n+        if (wdtx == null) {\n+            wdtx = new DateTimeFormatterBuilder()\n+                .append(weekDate())\n+                .append(tTimeNoMillis())\n+                .toFormatter();\n+        }\n+        return wdtx;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a basic formatter for a full date as four digit year, two digit\n+     * month of year, and two digit day of month (yyyyMMdd).\n+     * \n+     * @return a formatter for yyyyMMdd\n+     */\n+    public static DateTimeFormatter basicDate() {\n+        if (bd == null) {\n+            bd = new DateTimeFormatterBuilder()\n+                .appendYear(4, 4)\n+                .appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2)\n+                .appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2)\n+                .toFormatter();\n+        }\n+        return bd;\n+    }\n+\n+    /**\n+     * Returns a basic formatter for a two digit hour of day, two digit minute\n+     * of hour, two digit second of minute, three digit millis, and time zone\n+     * offset (HHmmss.SSSZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for HHmmss.SSSZ\n+     */\n+    public static DateTimeFormatter basicTime() {\n+        if (bt == null) {\n+            bt = new DateTimeFormatterBuilder()\n+                .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)\n+                .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)\n+                .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)\n+                .appendLiteral('.')\n+                .appendFractionOfSecond(3, 9)\n+                .appendTimeZoneOffset(\"Z\", false, 2, 2)\n+                .toFormatter();\n+        }\n+        return bt;\n+    }\n+\n+    /**\n+     * Returns a basic formatter for a two digit hour of day, two digit minute\n+     * of hour, two digit second of minute, and time zone offset (HHmmssZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for HHmmssZ\n+     */\n+    public static DateTimeFormatter basicTimeNoMillis() {\n+        if (btx == null) {\n+            btx = new DateTimeFormatterBuilder()\n+                .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)\n+                .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)\n+                .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)\n+                .appendTimeZoneOffset(\"Z\", false, 2, 2)\n+                .toFormatter();\n+        }\n+        return btx;\n+    }\n+\n+    /**\n+     * Returns a basic formatter for a two digit hour of day, two digit minute\n+     * of hour, two digit second of minute, three digit millis, and time zone\n+     * offset prefixed by 'T' ('T'HHmmss.SSSZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for 'T'HHmmss.SSSZ\n+     */\n+    public static DateTimeFormatter basicTTime() {\n+        if (btt == null) {\n+            btt = new DateTimeFormatterBuilder()\n+                .append(literalTElement())\n+                .append(basicTime())\n+                .toFormatter();\n+        }\n+        return btt;\n+    }\n+\n+    /**\n+     * Returns a basic formatter for a two digit hour of day, two digit minute\n+     * of hour, two digit second of minute, and time zone offset prefixed by 'T'\n+     * ('T'HHmmssZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for 'T'HHmmssZ\n+     */\n+    public static DateTimeFormatter basicTTimeNoMillis() {\n+        if (bttx == null) {\n+            bttx = new DateTimeFormatterBuilder()\n+                .append(literalTElement())\n+                .append(basicTimeNoMillis())\n+                .toFormatter();\n+        }\n+        return bttx;\n+    }\n+\n+    /**\n+     * Returns a basic formatter that combines a basic date and time, separated\n+     * by a 'T' (yyyyMMdd'T'HHmmss.SSSZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for yyyyMMdd'T'HHmmss.SSSZ\n+     */\n+    public static DateTimeFormatter basicDateTime() {\n+        if (bdt == null) {\n+            bdt = new DateTimeFormatterBuilder()\n+                .append(basicDate())\n+                .append(basicTTime())\n+                .toFormatter();\n+        }\n+        return bdt;\n+    }\n+\n+    /**\n+     * Returns a basic formatter that combines a basic date and time without millis,\n+     * separated by a 'T' (yyyyMMdd'T'HHmmssZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for yyyyMMdd'T'HHmmssZ\n+     */\n+    public static DateTimeFormatter basicDateTimeNoMillis() {\n+        if (bdtx == null) {\n+            bdtx = new DateTimeFormatterBuilder()\n+                .append(basicDate())\n+                .append(basicTTimeNoMillis())\n+                .toFormatter();\n+        }\n+        return bdtx;\n+    }\n+\n+    /**\n+     * Returns a formatter for a full ordinal date, using a four\n+     * digit year and three digit dayOfYear (yyyyDDD).\n+     * \n+     * @return a formatter for yyyyDDD\n+     * @since 1.1\n+     */\n+    public static DateTimeFormatter basicOrdinalDate() {\n+        if (bod == null) {\n+            bod = new DateTimeFormatterBuilder()\n+                .appendYear(4, 4)\n+                .appendFixedDecimal(DateTimeFieldType.dayOfYear(), 3)\n+                .toFormatter();\n+        }\n+        return bod;\n+    }\n+\n+    /**\n+     * Returns a formatter for a full ordinal date and time, using a four\n+     * digit year and three digit dayOfYear (yyyyDDD'T'HHmmss.SSSZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for yyyyDDD'T'HHmmss.SSSZ\n+     * @since 1.1\n+     */\n+    public static DateTimeFormatter basicOrdinalDateTime() {\n+        if (bodt == null) {\n+            bodt = new DateTimeFormatterBuilder()\n+                .append(basicOrdinalDate())\n+                .append(basicTTime())\n+                .toFormatter();\n+        }\n+        return bodt;\n+    }\n+\n+    /**\n+     * Returns a formatter for a full ordinal date and time without millis,\n+     * using a four digit year and three digit dayOfYear (yyyyDDD'T'HHmmssZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for yyyyDDD'T'HHmmssZ\n+     * @since 1.1\n+     */\n+    public static DateTimeFormatter basicOrdinalDateTimeNoMillis() {\n+        if (bodtx == null) {\n+            bodtx = new DateTimeFormatterBuilder()\n+                .append(basicOrdinalDate())\n+                .append(basicTTimeNoMillis())\n+                .toFormatter();\n+        }\n+        return bodtx;\n+    }\n+\n+    /**\n+     * Returns a basic formatter for a full date as four digit weekyear, two\n+     * digit week of weekyear, and one digit day of week (xxxx'W'wwe).\n+     * \n+     * @return a formatter for xxxx'W'wwe\n+     */\n+    public static DateTimeFormatter basicWeekDate() {\n+        if (bwd == null) {\n+            bwd = new DateTimeFormatterBuilder()\n+                .appendWeekyear(4, 4)\n+                .appendLiteral('W')\n+                .appendFixedDecimal(DateTimeFieldType.weekOfWeekyear(), 2)\n+                .appendFixedDecimal(DateTimeFieldType.dayOfWeek(), 1)\n+                .toFormatter();\n+        }\n+        return bwd;\n+    }\n+\n+    /**\n+     * Returns a basic formatter that combines a basic weekyear date and time,\n+     * separated by a 'T' (xxxx'W'wwe'T'HHmmss.SSSZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for xxxx'W'wwe'T'HHmmss.SSSZ\n+     */\n+    public static DateTimeFormatter basicWeekDateTime() {\n+        if (bwdt == null) {\n+            bwdt = new DateTimeFormatterBuilder()\n+                .append(basicWeekDate())\n+                .append(basicTTime())\n+                .toFormatter();\n+        }\n+        return bwdt;\n+    }\n+\n+    /**\n+     * Returns a basic formatter that combines a basic weekyear date and time\n+     * without millis, separated by a 'T' (xxxx'W'wwe'T'HHmmssZ).\n+     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HHmm' for non-zero.\n+     * \n+     * @return a formatter for xxxx'W'wwe'T'HHmmssZ\n+     */\n+    public static DateTimeFormatter basicWeekDateTimeNoMillis() {\n+        if (bwdtx == null) {\n+            bwdtx = new DateTimeFormatterBuilder()\n+                .append(basicWeekDate())\n+                .append(basicTTimeNoMillis())\n+                .toFormatter();\n+        }\n+        return bwdtx;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a formatter for a four digit year. (yyyy)\n+     * \n+     * @return a formatter for yyyy\n+     */\n+    public static DateTimeFormatter year() {\n+        return yearElement();\n+    }\n+\n+    /**\n+     * Returns a formatter for a four digit year and two digit month of\n+     * year. (yyyy-MM)\n+     * \n+     * @return a formatter for yyyy-MM\n+     */\n+    public static DateTimeFormatter yearMonth() {\n+        if (ym == null) {\n+            ym = new DateTimeFormatterBuilder()\n+                .append(yearElement())\n+                .append(monthElement())\n+                .toFormatter();\n+        }\n+        return ym;\n+    }\n+\n+    /**\n+     * Returns a formatter for a four digit year, two digit month of year, and\n+     * two digit day of month. (yyyy-MM-dd)\n+     * \n+     * @return a formatter for yyyy-MM-dd\n+     */\n+    public static DateTimeFormatter yearMonthDay() {\n+        if (ymd == null) {\n+            ymd = new DateTimeFormatterBuilder()\n+                .append(yearElement())\n+                .append(monthElement())\n+                .append(dayOfMonthElement())\n+                .toFormatter();\n+        }\n+        return ymd;\n+    }\n+\n+    /**\n+     * Returns a formatter for a four digit weekyear. (xxxx)\n+     * \n+     * @return a formatter for xxxx\n+     */\n+    public static DateTimeFormatter weekyear() {\n+        return weekyearElement();\n+    }\n+\n+    /**\n+     * Returns a formatter for a four digit weekyear and two digit week of\n+     * weekyear. (xxxx-'W'ww)\n+     * \n+     * @return a formatter for xxxx-'W'ww\n+     */\n+    public static DateTimeFormatter weekyearWeek() {\n+        if (ww == null) {\n+            ww = new DateTimeFormatterBuilder()\n+                .append(weekyearElement())\n+                .append(weekElement())\n+                .toFormatter();\n+        }\n+        return ww;\n+    }\n+\n+    /**\n+     * Returns a formatter for a four digit weekyear, two digit week of\n+     * weekyear, and one digit day of week. (xxxx-'W'ww-e)\n+     * \n+     * @return a formatter for xxxx-'W'ww-e\n+     */\n+    public static DateTimeFormatter weekyearWeekDay() {\n+        if (wwd == null) {\n+            wwd = new DateTimeFormatterBuilder()\n+                .append(weekyearElement())\n+                .append(weekElement())\n+                .append(dayOfWeekElement())\n+                .toFormatter();\n+        }\n+        return wwd;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day. (HH)\n+     * \n+     * @return a formatter for HH\n+     */\n+    public static DateTimeFormatter hour() {\n+        return hourElement();\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day and two digit minute of\n+     * hour. (HH:mm)\n+     * \n+     * @return a formatter for HH:mm\n+     */\n+    public static DateTimeFormatter hourMinute() {\n+        if (hm == null) {\n+            hm = new DateTimeFormatterBuilder()\n+                .append(hourElement())\n+                .append(minuteElement())\n+                .toFormatter();\n+        }\n+        return hm;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, and two digit second of minute. (HH:mm:ss)\n+     * \n+     * @return a formatter for HH:mm:ss\n+     */\n+    public static DateTimeFormatter hourMinuteSecond() {\n+        if (hms == null) {\n+            hms = new DateTimeFormatterBuilder()\n+                .append(hourElement())\n+                .append(minuteElement())\n+                .append(secondElement())\n+                .toFormatter();\n+        }\n+        return hms;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, and three digit fraction of\n+     * second (HH:mm:ss.SSS). Parsing will parse up to 3 fractional second\n+     * digits.\n+     * \n+     * @return a formatter for HH:mm:ss.SSS\n+     */\n+    public static DateTimeFormatter hourMinuteSecondMillis() {\n+        if (hmsl == null) {\n+            hmsl = new DateTimeFormatterBuilder()\n+                .append(hourElement())\n+                .append(minuteElement())\n+                .append(secondElement())\n+                .appendLiteral('.')\n+                .appendFractionOfSecond(3, 3)\n+                .toFormatter();\n+        }\n+        return hmsl;\n+    }\n+\n+    /**\n+     * Returns a formatter for a two digit hour of day, two digit minute of\n+     * hour, two digit second of minute, and three digit fraction of\n+     * second (HH:mm:ss.SSS). Parsing will parse up to 9 fractional second\n+     * digits, throwing away all except the first three.\n+     * \n+     * @return a formatter for HH:mm:ss.SSS\n+     */\n+    public static DateTimeFormatter hourMinuteSecondFraction() {\n+        if (hmsf == null) {\n+            hmsf = new DateTimeFormatterBuilder()\n+                .append(hourElement())\n+                .append(minuteElement())\n+                .append(secondElement())\n+                .append(fractionElement())\n+                .toFormatter();\n+        }\n+        return hmsf;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date and two digit hour of\n+     * day. (yyyy-MM-dd'T'HH)\n+     * \n+     * @return a formatter for yyyy-MM-dd'T'HH\n+     */\n+    public static DateTimeFormatter dateHour() {\n+        if (dh == null) {\n+            dh = new DateTimeFormatterBuilder()\n+                .append(date())\n+                .append(literalTElement())\n+                .append(hour())\n+                .toFormatter();\n+        }\n+        return dh;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date, two digit hour of day,\n+     * and two digit minute of hour. (yyyy-MM-dd'T'HH:mm)\n+     * \n+     * @return a formatter for yyyy-MM-dd'T'HH:mm\n+     */\n+    public static DateTimeFormatter dateHourMinute() {\n+        if (dhm == null) {\n+            dhm = new DateTimeFormatterBuilder()\n+                .append(date())\n+                .append(literalTElement())\n+                .append(hourMinute())\n+                .toFormatter();\n+        }\n+        return dhm;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date, two digit hour of day,\n+     * two digit minute of hour, and two digit second of\n+     * minute. (yyyy-MM-dd'T'HH:mm:ss)\n+     * \n+     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss\n+     */\n+    public static DateTimeFormatter dateHourMinuteSecond() {\n+        if (dhms == null) {\n+            dhms = new DateTimeFormatterBuilder()\n+                .append(date())\n+                .append(literalTElement())\n+                .append(hourMinuteSecond())\n+                .toFormatter();\n+        }\n+        return dhms;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date, two digit hour of day,\n+     * two digit minute of hour, two digit second of minute, and three digit\n+     * fraction of second (yyyy-MM-dd'T'HH:mm:ss.SSS). Parsing will parse up\n+     * to 3 fractional second digits.\n+     * \n+     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS\n+     */\n+    public static DateTimeFormatter dateHourMinuteSecondMillis() {\n+        if (dhmsl == null) {\n+            dhmsl = new DateTimeFormatterBuilder()\n+                .append(date())\n+                .append(literalTElement())\n+                .append(hourMinuteSecondMillis())\n+                .toFormatter();\n+        }\n+        return dhmsl;\n+    }\n+\n+    /**\n+     * Returns a formatter that combines a full date, two digit hour of day,\n+     * two digit minute of hour, two digit second of minute, and three digit\n+     * fraction of second (yyyy-MM-dd'T'HH:mm:ss.SSS). Parsing will parse up\n+     * to 9 fractional second digits, throwing away all except the first three.\n+     * \n+     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS\n+     */\n+    public static DateTimeFormatter dateHourMinuteSecondFraction() {\n+        if (dhmsf == null) {\n+            dhmsf = new DateTimeFormatterBuilder()\n+                .append(date())\n+                .append(literalTElement())\n+                .append(hourMinuteSecondFraction())\n+                .toFormatter();\n+        }\n+        return dhmsf;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private static DateTimeFormatter yearElement() {\n+        if (ye == null) {\n+            ye = new DateTimeFormatterBuilder()\n+                .appendYear(4, 9)\n+                .toFormatter();\n+        }\n+        return ye;\n+    }\n+\n+    private static DateTimeFormatter monthElement() {\n+        if (mye == null) {\n+            mye = new DateTimeFormatterBuilder()\n+                .appendLiteral('-')\n+                .appendMonthOfYear(2)\n+                .toFormatter();\n+        }\n+        return mye;\n+    }\n+\n+    private static DateTimeFormatter dayOfMonthElement() {\n+        if (dme == null) {\n+            dme = new DateTimeFormatterBuilder()\n+                .appendLiteral('-')\n+                .appendDayOfMonth(2)\n+                .toFormatter();\n+        }\n+        return dme;\n+    }\n+\n+    private static DateTimeFormatter weekyearElement() {\n+        if (we == null) {\n+            we = new DateTimeFormatterBuilder()\n+                .appendWeekyear(4, 9)\n+                .toFormatter();\n+        }\n+        return we;\n+    }\n+\n+    private static DateTimeFormatter weekElement() {\n+        if (wwe == null) {\n+            wwe = new DateTimeFormatterBuilder()\n+                .appendLiteral(\"-W\")\n+                .appendWeekOfWeekyear(2)\n+                .toFormatter();\n+        }\n+        return wwe;\n+    }\n+\n+    private static DateTimeFormatter dayOfWeekElement() {\n+        if (dwe == null) {\n+            dwe = new DateTimeFormatterBuilder()\n+                .appendLiteral('-')\n+                .appendDayOfWeek(1)\n+                .toFormatter();\n+        }\n+        return dwe;\n+    }\n+\n+    private static DateTimeFormatter dayOfYearElement() {\n+        if (dye == null) {\n+            dye = new DateTimeFormatterBuilder()\n+                .appendLiteral('-')\n+                .appendDayOfYear(3)\n+                .toFormatter();\n+        }\n+        return dye;\n+    }\n+    \n+    private static DateTimeFormatter literalTElement() {\n+        if (lte == null) {\n+            lte = new DateTimeFormatterBuilder()\n+                .appendLiteral('T')\n+                .toFormatter();\n+        }\n+        return lte;\n+    }\n+\n+    private static DateTimeFormatter hourElement() {\n+        if (hde == null) {\n+            hde = new DateTimeFormatterBuilder()\n+                .appendHourOfDay(2)\n+                .toFormatter();\n+        }\n+        return hde;\n+    }\n+\n+    private static DateTimeFormatter minuteElement() {\n+        if (mhe == null) {\n+            mhe = new DateTimeFormatterBuilder()\n+                .appendLiteral(':')\n+                .appendMinuteOfHour(2)\n+                .toFormatter();\n+        }\n+        return mhe;\n+    }\n+\n+    private static DateTimeFormatter secondElement() {\n+        if (sme == null) {\n+            sme = new DateTimeFormatterBuilder()\n+                .appendLiteral(':')\n+                .appendSecondOfMinute(2)\n+                .toFormatter();\n+        }\n+        return sme;\n+    }\n+\n+    private static DateTimeFormatter fractionElement() {\n+        if (fse == null) {\n+            fse = new DateTimeFormatterBuilder()\n+                .appendLiteral('.')\n+                // Support parsing up to nanosecond precision even though\n+                // those extra digits will be dropped.\n+                .appendFractionOfSecond(3, 9)\n+                .toFormatter();\n+        }\n+        return fse;\n+    }\n+\n+    private static DateTimeFormatter offsetElement() {\n+        if (ze == null) {\n+            ze = new DateTimeFormatterBuilder()\n+                .appendTimeZoneOffset(\"Z\", true, 2, 4)\n+                .toFormatter();\n+        }\n+        return ze;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/ISOPeriodFormat.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+/**\n+ * Factory that creates instances of PeriodFormatter for the ISO8601 standard.\n+ * <p>\n+ * Period formatting is performed by the {@link PeriodFormatter} class.\n+ * Three classes provide factory methods to create formatters, and this is one.\n+ * The others are {@link PeriodFormat} and {@link PeriodFormatterBuilder}.\n+ * <p>\n+ * ISOPeriodFormat is thread-safe and immutable, and the formatters it\n+ * returns are as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see PeriodFormat\n+ * @see PeriodFormatterBuilder\n+ */\n+public class ISOPeriodFormat {\n+\n+    /** Cache of standard format. */\n+    private static PeriodFormatter cStandard;\n+    /** Cache of alternate months format. */\n+    private static PeriodFormatter cAlternate;\n+    /** Cache of alternate extended months format. */\n+    private static PeriodFormatter cAlternateExtended;\n+    /** Cache of alternate weeks format. */\n+    private static PeriodFormatter cAlternateWithWeeks;\n+    /** Cache of alternate extended weeks format. */\n+    private static PeriodFormatter cAlternateExtendedWihWeeks;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @since 1.1 (previously private)\n+     */\n+    protected ISOPeriodFormat() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The standard ISO format - PyYmMwWdDThHmMsS.\n+     * Milliseconds are not output.\n+     * Note that the ISO8601 standard actually indicates weeks should not\n+     * be shown if any other field is present and vice versa.\n+     * \n+     * @return the formatter\n+     */\n+    public static PeriodFormatter standard() {\n+        if (cStandard == null) {\n+            cStandard = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .appendYears()\n+                .appendSuffix(\"Y\")\n+                .appendMonths()\n+                .appendSuffix(\"M\")\n+                .appendWeeks()\n+                .appendSuffix(\"W\")\n+                .appendDays()\n+                .appendSuffix(\"D\")\n+                .appendSeparatorIfFieldsAfter(\"T\")\n+                .appendHours()\n+                .appendSuffix(\"H\")\n+                .appendMinutes()\n+                .appendSuffix(\"M\")\n+                .appendSecondsWithOptionalMillis()\n+                .appendSuffix(\"S\")\n+                .toFormatter();\n+        }\n+        return cStandard;\n+    }\n+\n+    /**\n+     * The alternate ISO format, PyyyymmddThhmmss, which excludes weeks.\n+     * <p>\n+     * Even if weeks are present in the period, they are not output.\n+     * Fractional seconds (milliseconds) will appear if required.\n+     * \n+     * @return the formatter\n+     */\n+    public static PeriodFormatter alternate() {\n+        if (cAlternate == null) {\n+            cAlternate = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .minimumPrintedDigits(2)\n+                .appendMonths()\n+                .appendDays()\n+                .appendSeparatorIfFieldsAfter(\"T\")\n+                .appendHours()\n+                .appendMinutes()\n+                .appendSecondsWithOptionalMillis()\n+                .toFormatter();\n+        }\n+        return cAlternate;\n+    }\n+\n+    /**\n+     * The alternate ISO format, Pyyyy-mm-ddThh:mm:ss, which excludes weeks.\n+     * <p>\n+     * Even if weeks are present in the period, they are not output.\n+     * Fractional seconds (milliseconds) will appear if required.\n+     * \n+     * @return the formatter\n+     */\n+    public static PeriodFormatter alternateExtended() {\n+        if (cAlternateExtended == null) {\n+            cAlternateExtended = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .appendSeparator(\"-\")\n+                .minimumPrintedDigits(2)\n+                .appendMonths()\n+                .appendSeparator(\"-\")\n+                .appendDays()\n+                .appendSeparatorIfFieldsAfter(\"T\")\n+                .appendHours()\n+                .appendSeparator(\":\")\n+                .appendMinutes()\n+                .appendSeparator(\":\")\n+                .appendSecondsWithOptionalMillis()\n+                .toFormatter();\n+        }\n+        return cAlternateExtended;\n+    }\n+\n+    /**\n+     * The alternate ISO format, PyyyyWwwddThhmmss, which excludes months.\n+     * <p>\n+     * Even if months are present in the period, they are not output.\n+     * Fractional seconds (milliseconds) will appear if required.\n+     * \n+     * @return the formatter\n+     */\n+    public static PeriodFormatter alternateWithWeeks() {\n+        if (cAlternateWithWeeks == null) {\n+            cAlternateWithWeeks = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .minimumPrintedDigits(2)\n+                .appendPrefix(\"W\")\n+                .appendWeeks()\n+                .appendDays()\n+                .appendSeparatorIfFieldsAfter(\"T\")\n+                .appendHours()\n+                .appendMinutes()\n+                .appendSecondsWithOptionalMillis()\n+                .toFormatter();\n+        }\n+        return cAlternateWithWeeks;\n+    }\n+\n+    /**\n+     * The alternate ISO format, Pyyyy-Www-ddThh:mm:ss, which excludes months.\n+     * <p>\n+     * Even if months are present in the period, they are not output.\n+     * Fractional seconds (milliseconds) will appear if required.\n+     * \n+     * @return the formatter\n+     */\n+    public static PeriodFormatter alternateExtendedWithWeeks() {\n+        if (cAlternateExtendedWihWeeks == null) {\n+            cAlternateExtendedWihWeeks = new PeriodFormatterBuilder()\n+                .appendLiteral(\"P\")\n+                .printZeroAlways()\n+                .minimumPrintedDigits(4)\n+                .appendYears()\n+                .appendSeparator(\"-\")\n+                .minimumPrintedDigits(2)\n+                .appendPrefix(\"W\")\n+                .appendWeeks()\n+                .appendSeparator(\"-\")\n+                .appendDays()\n+                .appendSeparatorIfFieldsAfter(\"T\")\n+                .appendHours()\n+                .appendSeparator(\":\")\n+                .appendMinutes()\n+                .appendSeparator(\":\")\n+                .appendSecondsWithOptionalMillis()\n+                .toFormatter();\n+        }\n+        return cAlternateExtendedWihWeeks;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/PeriodFormat.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+/**\n+ * Factory that creates instances of PeriodFormatter.\n+ * <p>\n+ * Period formatting is performed by the {@link PeriodFormatter} class.\n+ * Three classes provide factory methods to create formatters, and this is one.\n+ * The others are {@link ISOPeriodFormat} and {@link PeriodFormatterBuilder}.\n+ * <p>\n+ * PeriodFormat is thread-safe and immutable, and the formatters it returns\n+ * are as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see ISOPeriodFormat\n+ * @see PeriodFormatterBuilder\n+ */\n+public class PeriodFormat {\n+\n+    /** An english words based formatter. */\n+    private static PeriodFormatter cEnglishWords;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @since 1.1 (previously private)\n+     */\n+    protected PeriodFormat() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the default PeriodFormatter.\n+     * <p>\n+     * This currently returns a word based formatter using English only.\n+     * Hopefully future release will support localized period formatting.\n+     * \n+     * @return the formatter\n+     */\n+    public static PeriodFormatter getDefault() {\n+        if (cEnglishWords == null) {\n+            String[] variants = {\" \", \",\", \",and \", \", and \"};\n+            cEnglishWords = new PeriodFormatterBuilder()\n+                .appendYears()\n+                .appendSuffix(\" year\", \" years\")\n+                .appendSeparator(\", \", \" and \", variants)\n+                .appendMonths()\n+                .appendSuffix(\" month\", \" months\")\n+                .appendSeparator(\", \", \" and \", variants)\n+                .appendWeeks()\n+                .appendSuffix(\" week\", \" weeks\")\n+                .appendSeparator(\", \", \" and \", variants)\n+                .appendDays()\n+                .appendSuffix(\" day\", \" days\")\n+                .appendSeparator(\", \", \" and \", variants)\n+                .appendHours()\n+                .appendSuffix(\" hour\", \" hours\")\n+                .appendSeparator(\", \", \" and \", variants)\n+                .appendMinutes()\n+                .appendSuffix(\" minute\", \" minutes\")\n+                .appendSeparator(\", \", \" and \", variants)\n+                .appendSeconds()\n+                .appendSuffix(\" second\", \" seconds\")\n+                .appendSeparator(\", \", \" and \", variants)\n+                .appendMillis()\n+                .appendSuffix(\" millisecond\", \" milliseconds\")\n+                .toFormatter();\n+        }\n+        return cEnglishWords;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/PeriodFormatter.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Locale;\n+\n+import org.joda.time.MutablePeriod;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadablePeriod;\n+\n+/**\n+ * Controls the printing and parsing of a time period to and from a string.\n+ * <p>\n+ * This class is the main API for printing and parsing used by most applications.\n+ * Instances of this class are created via one of three factory classes:\n+ * <ul>\n+ * <li>{@link PeriodFormat} - formats by pattern and style</li>\n+ * <li>{@link ISOPeriodFormat} - ISO8601 formats</li>\n+ * <li>{@link PeriodFormatterBuilder} - complex formats created via method calls</li>\n+ * </ul>\n+ * <p>\n+ * An instance of this class holds a reference internally to one printer and\n+ * one parser. It is possible that one of these may be null, in which case the\n+ * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}\n+ * and {@link #isParser()} methods.\n+ * <p>\n+ * The underlying printer/parser can be altered to behave exactly as required\n+ * by using a decorator modifier:\n+ * <ul>\n+ * <li>{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale</li>\n+ * </ul>\n+ * This returns a new formatter (instances of this class are immutable).\n+ * <p>\n+ * The main methods of the class are the <code>printXxx</code> and\n+ * <code>parseXxx</code> methods. These are used as follows:\n+ * <pre>\n+ * // print using the default locale\n+ * String periodStr = formatter.print(period);\n+ * // print using the French locale\n+ * String periodStr = formatter.withLocale(Locale.FRENCH).print(period);\n+ * \n+ * // parse using the French locale\n+ * Period date = formatter.withLocale(Locale.FRENCH).parsePeriod(str);\n+ * </pre>\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class PeriodFormatter {\n+\n+    /** The internal printer used to output the datetime. */\n+    private final PeriodPrinter iPrinter;\n+    /** The internal parser used to output the datetime. */\n+    private final PeriodParser iParser;\n+    /** The locale to use for printing and parsing. */\n+    private final Locale iLocale;\n+    /** The period type used in parsing. */\n+    private final PeriodType iParseType;\n+\n+    /**\n+     * Creates a new formatter, however you will normally use the factory\n+     * or the builder.\n+     * \n+     * @param printer  the internal printer, null if cannot print\n+     * @param parser  the internal parser, null if cannot parse\n+     */\n+    public PeriodFormatter(\n+            PeriodPrinter printer, PeriodParser parser) {\n+        super();\n+        iPrinter = printer;\n+        iParser = parser;\n+        iLocale = null;\n+        iParseType = null;\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param printer  the internal printer, null if cannot print\n+     * @param parser  the internal parser, null if cannot parse\n+     * @param locale  the locale to use\n+     * @param type  the parse period type\n+     */\n+    private PeriodFormatter(\n+            PeriodPrinter printer, PeriodParser parser,\n+            Locale locale, PeriodType type) {\n+        super();\n+        iPrinter = printer;\n+        iParser = parser;\n+        iLocale = locale;\n+        iParseType = type;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this formatter capable of printing.\n+     * \n+     * @return true if this is a printer\n+     */\n+    public boolean isPrinter() {\n+        return (iPrinter != null);\n+    }\n+\n+    /**\n+     * Gets the internal printer object that performs the real printing work.\n+     * \n+     * @return the internal printer\n+     */\n+    public PeriodPrinter getPrinter() {\n+        return iPrinter;\n+    }\n+\n+    /**\n+     * Is this formatter capable of parsing.\n+     * \n+     * @return true if this is a parser\n+     */\n+    public boolean isParser() {\n+        return (iParser != null);\n+    }\n+\n+    /**\n+     * Gets the internal parser object that performs the real parsing work.\n+     * \n+     * @return the internal parser\n+     */\n+    public PeriodParser getParser() {\n+        return iParser;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter with a different locale that will be used\n+     * for printing and parsing.\n+     * <p>\n+     * A PeriodFormatter is immutable, so a new instance is returned,\n+     * and the original is unaltered and still usable.\n+     * \n+     * @param locale  the locale to use\n+     * @return the new formatter\n+     */\n+    public PeriodFormatter withLocale(Locale locale) {\n+        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n+            return this;\n+        }\n+        return new PeriodFormatter(iPrinter, iParser, locale, iParseType);\n+    }\n+\n+    /**\n+     * Gets the locale that will be used for printing and parsing.\n+     * \n+     * @return the locale to use\n+     */\n+    public Locale getLocale() {\n+        return iLocale;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter with a different PeriodType for parsing.\n+     * <p>\n+     * A PeriodFormatter is immutable, so a new instance is returned,\n+     * and the original is unaltered and still usable.\n+     * \n+     * @param type  the type to use in parsing\n+     * @return the new formatter\n+     */\n+    public PeriodFormatter withParseType(PeriodType type) {\n+        if (type == iParseType) {\n+            return this;\n+        }\n+        return new PeriodFormatter(iPrinter, iParser, iLocale, type);\n+    }\n+\n+    /**\n+     * Gets the PeriodType that will be used for parsing.\n+     * \n+     * @return the parse type to use\n+     */\n+    public PeriodType getParseType() {\n+        return iParseType;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadablePeriod to a StringBuffer.\n+     *\n+     * @param buf  the formatted period is appended to this buffer\n+     * @param period  the period to format, not null\n+     */\n+    public void printTo(StringBuffer buf, ReadablePeriod period) {\n+        checkPrinter();\n+        checkPeriod(period);\n+        \n+        getPrinter().printTo(buf, period, iLocale);\n+    }\n+\n+    /**\n+     * Prints a ReadablePeriod to a Writer.\n+     *\n+     * @param out  the formatted period is written out\n+     * @param period  the period to format, not null\n+     */\n+    public void printTo(Writer out, ReadablePeriod period) throws IOException {\n+        checkPrinter();\n+        checkPeriod(period);\n+        \n+        getPrinter().printTo(out, period, iLocale);\n+    }\n+\n+    /**\n+     * Prints a ReadablePeriod to a new String.\n+     *\n+     * @param period  the period to format, not null\n+     * @return the printed result\n+     */\n+    public String print(ReadablePeriod period) {\n+        checkPrinter();\n+        checkPeriod(period);\n+        \n+        PeriodPrinter printer = getPrinter();\n+        StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale));\n+        printer.printTo(buf, period, iLocale);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Checks whether printing is supported.\n+     * \n+     * @throws UnsupportedOperationException if printing is not supported\n+     */\n+    private void checkPrinter() {\n+        if (iPrinter == null) {\n+            throw new UnsupportedOperationException(\"Printing not supported\");\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the period is non-null.\n+     * \n+     * @throws IllegalArgumentException if the period is null\n+     */\n+    private void checkPeriod(ReadablePeriod period) {\n+        if (period == null) {\n+            throw new IllegalArgumentException(\"Period must not be null\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parses a period from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritablePeriod. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text.\n+     * <p>\n+     * The parse type of the formatter is not used by this method.\n+     * <p>\n+     * If it fails, the return value is negative, but the period may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     *\n+     * @param period  a period that will be modified\n+     * @param text  text to parse\n+     * @param position position to start parsing from\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public int parseInto(ReadWritablePeriod period, String text, int position) {\n+        checkParser();\n+        checkPeriod(period);\n+        \n+        return getParser().parseInto(period, text, position, iLocale);\n+    }\n+\n+    /**\n+     * Parses a period from the given text, returning a new Period.\n+     *\n+     * @param text  text to parse\n+     * @return parsed value in a Period object\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public Period parsePeriod(String text) {\n+        checkParser();\n+        \n+        return parseMutablePeriod(text).toPeriod();\n+    }\n+\n+    /**\n+     * Parses a period from the given text, returning a new MutablePeriod.\n+     *\n+     * @param text  text to parse\n+     * @return parsed value in a MutablePeriod object\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    public MutablePeriod parseMutablePeriod(String text) {\n+        checkParser();\n+        \n+        MutablePeriod period = new MutablePeriod(0, iParseType);\n+        int newPos = getParser().parseInto(period, text, 0, iLocale);\n+        if (newPos >= 0) {\n+            if (newPos >= text.length()) {\n+                return period;\n+            }\n+        } else {\n+            newPos = ~newPos;\n+        }\n+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n+    }\n+\n+    /**\n+     * Checks whether parsing is supported.\n+     * \n+     * @throws UnsupportedOperationException if parsing is not supported\n+     */\n+    private void checkParser() {\n+        if (iParser == null) {\n+            throw new UnsupportedOperationException(\"Parsing not supported\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TreeSet;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.PeriodType;\n+import org.joda.time.ReadWritablePeriod;\n+import org.joda.time.ReadablePeriod;\n+\n+/**\n+ * Factory that creates complex instances of PeriodFormatter via method calls.\n+ * <p>\n+ * Period formatting is performed by the {@link PeriodFormatter} class.\n+ * Three classes provide factory methods to create formatters, and this is one.\n+ * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.\n+ * <p>\n+ * PeriodFormatterBuilder is used for constructing formatters which are then\n+ * used to print or parse. The formatters are built by appending specific fields\n+ * or other formatters to an instance of this builder.\n+ * <p>\n+ * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n+ * can be constructed as follows:\n+ * <p>\n+ * <pre>\n+ * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n+ *     .printZeroAlways()\n+ *     .appendYears()\n+ *     .appendSuffix(\" year\", \" years\")\n+ *     .appendSeparator(\" and \")\n+ *     .printZeroRarely()\n+ *     .appendMonths()\n+ *     .appendSuffix(\" month\", \" months\")\n+ *     .toFormatter();\n+ * </pre>\n+ * <p>\n+ * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n+ * formatters that it builds are thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see PeriodFormat\n+ */\n+public class PeriodFormatterBuilder {\n+    private static final int PRINT_ZERO_RARELY_FIRST = 1;\n+    private static final int PRINT_ZERO_RARELY_LAST = 2;\n+    private static final int PRINT_ZERO_IF_SUPPORTED = 3;\n+    private static final int PRINT_ZERO_ALWAYS = 4;\n+    private static final int PRINT_ZERO_NEVER = 5;\n+    \n+    private static final int YEARS = 0;\n+    private static final int MONTHS = 1;\n+    private static final int WEEKS = 2;\n+    private static final int DAYS = 3;\n+    private static final int HOURS = 4;\n+    private static final int MINUTES = 5;\n+    private static final int SECONDS = 6;\n+    private static final int MILLIS = 7;\n+    private static final int SECONDS_MILLIS = 8;\n+    private static final int SECONDS_OPTIONAL_MILLIS = 9;\n+    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;\n+\n+    private int iMinPrintedDigits;\n+    private int iPrintZeroSetting;\n+    private int iMaxParsedDigits;\n+    private boolean iRejectSignedValues;\n+\n+    private PeriodFieldAffix iPrefix;\n+\n+    // List of Printers and Parsers used to build a final formatter.\n+    private List<Object> iElementPairs;\n+    /** Set to true if the formatter is not a printer. */\n+    private boolean iNotPrinter;\n+    /** Set to true if the formatter is not a parser. */\n+    private boolean iNotParser;\n+\n+    // Last PeriodFormatter appended of each field type.\n+    private FieldFormatter[] iFieldFormatters;\n+\n+    public PeriodFormatterBuilder() {\n+        clear();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a PeriodFormatter using all the appended elements.\n+     * <p>\n+     * This is the main method used by applications at the end of the build\n+     * process to create a usable formatter.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned formatter.\n+     * <p>\n+     * The returned formatter may not support both printing and parsing.\n+     * The methods {@link PeriodFormatter#isPrinter()} and\n+     * {@link PeriodFormatter#isParser()} will help you determine the state\n+     * of the formatter.\n+     * \n+     * @return the newly created formatter\n+     * @throws IllegalStateException if the builder can produce neither a printer nor a parser\n+     */\n+    public PeriodFormatter toFormatter() {\n+        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n+        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n+        return formatter;\n+    }\n+\n+    /**\n+     * Internal method to create a PeriodPrinter instance using all the\n+     * appended elements.\n+     * <p>\n+     * Most applications will not use this method.\n+     * If you want a printer in an application, call {@link #toFormatter()}\n+     * and just use the printing API.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned printer.\n+     * \n+     * @return the newly created printer, null if builder cannot create a printer\n+     */\n+    public PeriodPrinter toPrinter() {\n+        if (iNotPrinter) {\n+            return null;\n+        }\n+        return toFormatter().getPrinter();\n+    }\n+\n+    /**\n+     * Internal method to create a PeriodParser instance using all the\n+     * appended elements.\n+     * <p>\n+     * Most applications will not use this method.\n+     * If you want a printer in an application, call {@link #toFormatter()}\n+     * and just use the printing API.\n+     * <p>\n+     * Subsequent changes to this builder do not affect the returned parser.\n+     * \n+     * @return the newly created parser, null if builder cannot create a parser\n+     */\n+    public PeriodParser toParser() {\n+        if (iNotParser) {\n+            return null;\n+        }\n+        return toFormatter().getParser();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clears out all the appended elements, allowing this builder to be reused.\n+     */\n+    public void clear() {\n+        iMinPrintedDigits = 1;\n+        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n+        iMaxParsedDigits = 10;\n+        iRejectSignedValues = false;\n+        iPrefix = null;\n+        if (iElementPairs == null) {\n+            iElementPairs = new ArrayList<Object>();\n+        } else {\n+            iElementPairs.clear();\n+        }\n+        iNotPrinter = false;\n+        iNotParser = false;\n+        iFieldFormatters = new FieldFormatter[10];\n+    }\n+\n+    /**\n+     * Appends another formatter.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n+        if (formatter == null) {\n+            throw new IllegalArgumentException(\"No formatter supplied\");\n+        }\n+        clearPrefix();\n+        append0(formatter.getPrinter(), formatter.getParser());\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a printer parser pair.\n+     * <p>\n+     * Either the printer or the parser may be null, in which case the builder will\n+     * be unable to produce a parser or printer repectively.\n+     *\n+     * @param printer  appends a printer to the builder, null if printing is not supported\n+     * @param parser  appends a parser to the builder, null if parsing is not supported\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalArgumentException if both the printer and parser are null\n+     */\n+    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n+        if (printer == null && parser == null) {\n+            throw new IllegalArgumentException(\"No printer or parser supplied\");\n+        }\n+        clearPrefix();\n+        append0(printer, parser);\n+        return this;\n+    }\n+\n+    /**\n+     * Instructs the printer to emit specific text, and the parser to expect it.\n+     * The parser is case-insensitive.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalArgumentException if text is null\n+     */\n+    public PeriodFormatterBuilder appendLiteral(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException(\"Literal must not be null\");\n+        }\n+        clearPrefix();\n+        Literal literal = new Literal(text);\n+        append0(literal, literal);\n+        return this;\n+    }\n+\n+    /**\n+     * Set the minimum digits printed for the next and following appended\n+     * fields. By default, the minimum digits printed is one. If the field value\n+     * is zero, it is not printed unless a printZero rule is applied.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n+        iMinPrintedDigits = minDigits;\n+        return this;\n+    }\n+\n+    /**\n+     * Set the maximum digits parsed for the next and following appended\n+     * fields. By default, the maximum digits parsed is ten.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n+        iMaxParsedDigits = maxDigits;\n+        return this;\n+    }\n+\n+    /**\n+     * Reject signed values when parsing the next and following appended fields.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n+        iRejectSignedValues = v;\n+        return this;\n+    }\n+\n+    /**\n+     * Never print zero values for the next and following appended fields,\n+     * unless no fields would be printed. If no fields are printed, the printer\n+     * forces the last \"printZeroRarely\" field to print a zero.\n+     * <p>\n+     * This field setting is the default.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder printZeroRarelyLast() {\n+        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n+        return this;\n+    }\n+\n+    /**\n+     * Never print zero values for the next and following appended fields,\n+     * unless no fields would be printed. If no fields are printed, the printer\n+     * forces the first \"printZeroRarely\" field to print a zero.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder printZeroRarelyFirst() {\n+        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n+        return this;\n+    }\n+\n+    /**\n+     * Print zero values for the next and following appened fields only if the\n+     * period supports it.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder printZeroIfSupported() {\n+        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n+        return this;\n+    }\n+\n+    /**\n+     * Always print zero values for the next and following appended fields,\n+     * even if the period doesn't support it. The parser requires values for\n+     * fields that always print zero.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder printZeroAlways() {\n+        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n+        return this;\n+    }\n+\n+    /**\n+     * Never print zero values for the next and following appended fields,\n+     * unless no fields would be printed. If no fields are printed, the printer\n+     * forces the last \"printZeroRarely\" field to print a zero.\n+     * <p>\n+     * This field setting is the default.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder printZeroNever() {\n+        iPrintZeroSetting = PRINT_ZERO_NEVER;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     *\n+     * @param text text to print before field only if field is printed\n+     * @return this PeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    public PeriodFormatterBuilder appendPrefix(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendPrefix(new SimpleAffix(text));\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     * <p>\n+     * During parsing, the singular and plural versions are accepted whether\n+     * or not the actual value matches plurality.\n+     *\n+     * @param singularText text to print if field value is one\n+     * @param pluralText text to print if field value is not one\n+     * @return this PeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    public PeriodFormatterBuilder appendPrefix(String singularText,\n+                                                 String pluralText) {\n+        if (singularText == null || pluralText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendPrefix(new PluralAffix(singularText, pluralText));\n+    }\n+\n+    /**\n+     * Append a field prefix which applies only to the next appended field. If\n+     * the field is not printed, neither is the prefix.\n+     *\n+     * @param prefix custom prefix\n+     * @return this PeriodFormatterBuilder\n+     * @see #appendSuffix\n+     */\n+    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n+        if (prefix == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (iPrefix != null) {\n+            prefix = new CompositeAffix(iPrefix, prefix);\n+        }\n+        iPrefix = prefix;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Instruct the printer to emit an integer years field, if supported.\n+     * <p>\n+     * The number of printed and parsed digits can be controlled using\n+     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendYears() {\n+        appendField(YEARS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer months field, if supported.\n+     * <p>\n+     * The number of printed and parsed digits can be controlled using\n+     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendMonths() {\n+        appendField(MONTHS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer weeks field, if supported.\n+     * <p>\n+     * The number of printed and parsed digits can be controlled using\n+     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendWeeks() {\n+        appendField(WEEKS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer days field, if supported.\n+     * <p>\n+     * The number of printed and parsed digits can be controlled using\n+     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendDays() {\n+        appendField(DAYS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer hours field, if supported.\n+     * <p>\n+     * The number of printed and parsed digits can be controlled using\n+     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendHours() {\n+        appendField(HOURS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer minutes field, if supported.\n+     * <p>\n+     * The number of printed and parsed digits can be controlled using\n+     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendMinutes() {\n+        appendField(MINUTES);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer seconds field, if supported.\n+     * <p>\n+     * The number of printed and parsed digits can be controlled using\n+     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendSeconds() {\n+        appendField(SECONDS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a combined seconds and millis field, if supported.\n+     * The millis will overflow into the seconds if necessary.\n+     * The millis are always output.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendSecondsWithMillis() {\n+        appendField(SECONDS_MILLIS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit a combined seconds and millis field, if supported.\n+     * The millis will overflow into the seconds if necessary.\n+     * The millis are only output if non-zero.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n+        appendField(SECONDS_OPTIONAL_MILLIS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer millis field, if supported.\n+     * <p>\n+     * The number of printed and parsed digits can be controlled using\n+     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendMillis() {\n+        appendField(MILLIS);\n+        return this;\n+    }\n+\n+    /**\n+     * Instruct the printer to emit an integer millis field, if supported.\n+     * <p>\n+     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n+     *\n+     * @return this PeriodFormatterBuilder\n+     */\n+    public PeriodFormatterBuilder appendMillis3Digit() {\n+        appendField(7, 3);\n+        return this;\n+    }\n+\n+    private void appendField(int type) {\n+        appendField(type, iMinPrintedDigits);\n+    }\n+\n+    private void appendField(int type, int minPrinted) {\n+        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n+            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n+        append0(field, field);\n+        iFieldFormatters[type] = field;\n+        iPrefix = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     *\n+     * @param text text to print after field only if field is printed\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public PeriodFormatterBuilder appendSuffix(String text) {\n+        if (text == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendSuffix(new SimpleAffix(text));\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     * <p>\n+     * During parsing, the singular and plural versions are accepted whether or\n+     * not the actual value matches plurality.\n+     *\n+     * @param singularText text to print if field value is one\n+     * @param pluralText text to print if field value is not one\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    public PeriodFormatterBuilder appendSuffix(String singularText,\n+                                               String pluralText) {\n+        if (singularText == null || pluralText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return appendSuffix(new PluralAffix(singularText, pluralText));\n+    }\n+\n+    /**\n+     * Append a field suffix which applies only to the last appended field. If\n+     * the field is not printed, neither is the suffix.\n+     *\n+     * @param suffix custom suffix\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if no field exists to append to\n+     * @see #appendPrefix\n+     */\n+    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n+        final Object originalPrinter;\n+        final Object originalParser;\n+        if (iElementPairs.size() > 0) {\n+            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n+            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n+        } else {\n+            originalPrinter = null;\n+            originalParser = null;\n+        }\n+\n+        if (originalPrinter == null || originalParser == null ||\n+                originalPrinter != originalParser ||\n+                !(originalPrinter instanceof FieldFormatter)) {\n+            throw new IllegalStateException(\"No field to apply suffix to\");\n+        }\n+\n+        clearPrefix();\n+        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n+        iElementPairs.set(iElementPairs.size() - 2, newField);\n+        iElementPairs.set(iElementPairs.size() - 1, newField);\n+        iFieldFormatters[newField.getFieldType()] = newField;\n+        \n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Append a separator, which is output if fields are printed both before\n+     * and after the separator.\n+     * <p>\n+     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n+     * will only output the comma if both the days and hours fields are output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param text  the text to use as a separator\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparator(String text) {\n+        return appendSeparator(text, text, null, true, true);\n+    }\n+\n+    /**\n+     * Append a separator, which is output only if fields are printed after the separator.\n+     * <p>\n+     * For example,\n+     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n+     * will only output the comma if the hours fields is output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param text  the text to use as a separator\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n+        return appendSeparator(text, text, null, false, true);\n+    }\n+\n+    /**\n+     * Append a separator, which is output only if fields are printed before the separator.\n+     * <p>\n+     * For example,\n+     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n+     * will only output the comma if the days fields is output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param text  the text to use as a separator\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n+        return appendSeparator(text, text, null, true, false);\n+    }\n+\n+    /**\n+     * Append a separator, which is output if fields are printed both before\n+     * and after the separator.\n+     * <p>\n+     * This method changes the separator depending on whether it is the last separator\n+     * to be output.\n+     * <p>\n+     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n+     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n+     * and '1' if just one field is output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param text  the text to use as a separator\n+     * @param finalText  the text used used if this is the final separator to be printed\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n+        return appendSeparator(text, finalText, null, true, true);\n+    }\n+\n+    /**\n+     * Append a separator, which is output if fields are printed both before\n+     * and after the separator.\n+     * <p>\n+     * This method changes the separator depending on whether it is the last separator\n+     * to be output.\n+     * <p>\n+     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n+     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n+     * and '1' if just one field is output.\n+     * <p>\n+     * The text will be parsed case-insensitively.\n+     * <p>\n+     * Note: appending a separator discontinues any further work on the latest\n+     * appended field.\n+     *\n+     * @param text  the text to use as a separator\n+     * @param finalText  the text used used if this is the final separator to be printed\n+     * @param variants  set of text values which are also acceptable when parsed\n+     * @return this PeriodFormatterBuilder\n+     * @throws IllegalStateException if this separator follows a previous one\n+     */\n+    public PeriodFormatterBuilder appendSeparator(String text, String finalText,\n+                                                  String[] variants) {\n+        return appendSeparator(text, finalText, variants, true, true);\n+    }\n+\n+    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n+                                                   String[] variants,\n+                                                   boolean useBefore, boolean useAfter) {\n+        if (text == null || finalText == null) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        clearPrefix();\n+        \n+        // optimise zero formatter case\n+        List<Object> pairs = iElementPairs;\n+        if (pairs.size() == 0) {\n+            if (useAfter && useBefore == false) {\n+                Separator separator = new Separator(\n+                        text, finalText, variants,\n+                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n+                append0(separator, separator);\n+            }\n+            return this;\n+        }\n+        \n+        // find the last separator added\n+        int i;\n+        Separator lastSeparator = null;\n+        for (i=pairs.size(); --i>=0; ) {\n+            if (pairs.get(i) instanceof Separator) {\n+                lastSeparator = (Separator) pairs.get(i);\n+                pairs = pairs.subList(i + 1, pairs.size());\n+                break;\n+            }\n+            i--;  // element pairs\n+        }\n+        \n+        // merge formatters\n+        if (lastSeparator != null && pairs.size() == 0) {\n+            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n+        } else {\n+            Object[] comp = createComposite(pairs);\n+            pairs.clear();\n+            Separator separator = new Separator(\n+                    text, finalText, variants,\n+                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n+                    useBefore, useAfter);\n+            pairs.add(separator);\n+            pairs.add(separator);\n+        }\n+        \n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void clearPrefix() throws IllegalStateException {\n+        if (iPrefix != null) {\n+            throw new IllegalStateException(\"Prefix not followed by field\");\n+        }\n+        iPrefix = null;\n+    }\n+\n+    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n+        iElementPairs.add(printer);\n+        iElementPairs.add(parser);\n+        iNotPrinter |= (printer == null);\n+        iNotParser |= (parser == null);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n+        if (notPrinter && notParser) {\n+            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n+        }\n+        int size = elementPairs.size();\n+        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n+            Separator sep = (Separator) elementPairs.get(0);\n+            PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n+            sep = sep.finish(f.getPrinter(), f.getParser());\n+            return new PeriodFormatter(sep, sep);\n+        }\n+        Object[] comp = createComposite(elementPairs);\n+        if (notPrinter) {\n+            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n+        } else if (notParser) {\n+            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n+        } else {\n+            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n+        }\n+    }\n+\n+    private static Object[] createComposite(List<Object> elementPairs) {\n+        switch (elementPairs.size()) {\n+            case 0:\n+                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n+            case 1:\n+                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n+            default:\n+                Composite comp = new Composite(elementPairs);\n+                return new Object[] {comp, comp};\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Defines a formatted field's prefix or suffix text.\n+     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n+     */\n+    static interface PeriodFieldAffix {\n+        int calculatePrintedLength(int value);\n+        \n+        void printTo(StringBuffer buf, int value);\n+        \n+        void printTo(Writer out, int value) throws IOException;\n+        \n+        /**\n+         * @return new position after parsing affix, or ~position of failure\n+         */\n+        int parse(String periodStr, int position);\n+\n+        /**\n+         * @return position where affix starts, or original ~position if not found\n+         */\n+        int scan(String periodStr, int position);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements an affix where the text does not vary by the amount.\n+     */\n+    static class SimpleAffix implements PeriodFieldAffix {\n+        private final String iText;\n+\n+        SimpleAffix(String text) {\n+            iText = text;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return iText.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            buf.append(iText);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            out.write(iText);\n+        }\n+\n+        public int parse(String periodStr, int position) {\n+            String text = iText;\n+            int textLength = text.length();\n+            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n+                return position + textLength;\n+            }\n+            return ~position;\n+        }\n+\n+        public int scan(String periodStr, final int position) {\n+            String text = iText;\n+            int textLength = text.length();\n+            int sourceLength = periodStr.length();\n+            search:\n+            for (int pos = position; pos < sourceLength; pos++) {\n+                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n+                    return pos;\n+                }\n+                // Only allow number characters to be skipped in search of suffix.\n+                switch (periodStr.charAt(pos)) {\n+                case '0': case '1': case '2': case '3': case '4':\n+                case '5': case '6': case '7': case '8': case '9':\n+                case '.': case ',': case '+': case '-':\n+                    break;\n+                default:\n+                    break search;\n+                }\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements an affix where the text varies by the amount of the field.\n+     * Only singular (1) and plural (not 1) are supported.\n+     */\n+    static class PluralAffix implements PeriodFieldAffix {\n+        private final String iSingularText;\n+        private final String iPluralText;\n+\n+        PluralAffix(String singularText, String pluralText) {\n+            iSingularText = singularText;\n+            iPluralText = pluralText;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return (value == 1 ? iSingularText : iPluralText).length();\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            buf.append(value == 1 ? iSingularText : iPluralText);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            out.write(value == 1 ? iSingularText : iPluralText);\n+        }\n+\n+        public int parse(String periodStr, int position) {\n+            String text1 = iPluralText;\n+            String text2 = iSingularText; \n+\n+            if (text1.length() < text2.length()) {\n+                // Swap in order to match longer one first.\n+                String temp = text1;\n+                text1 = text2;\n+                text2 = temp;\n+            }\n+\n+            if (periodStr.regionMatches\n+                (true, position, text1, 0, text1.length())) {\n+                return position + text1.length();\n+            }\n+            if (periodStr.regionMatches\n+                (true, position, text2, 0, text2.length())) {\n+                return position + text2.length();\n+            }\n+\n+            return ~position;\n+        }\n+\n+        public int scan(String periodStr, final int position) {\n+            String text1 = iPluralText;\n+            String text2 = iSingularText; \n+\n+            if (text1.length() < text2.length()) {\n+                // Swap in order to match longer one first.\n+                String temp = text1;\n+                text1 = text2;\n+                text2 = temp;\n+            }\n+\n+            int textLength1 = text1.length();\n+            int textLength2 = text2.length();\n+\n+            int sourceLength = periodStr.length();\n+            for (int pos = position; pos < sourceLength; pos++) {\n+                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {\n+                    return pos;\n+                }\n+                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {\n+                    return pos;\n+                }\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Builds a composite affix by merging two other affix implementations.\n+     */\n+    static class CompositeAffix implements PeriodFieldAffix {\n+        private final PeriodFieldAffix iLeft;\n+        private final PeriodFieldAffix iRight;\n+\n+        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {\n+            iLeft = left;\n+            iRight = right;\n+        }\n+\n+        public int calculatePrintedLength(int value) {\n+            return iLeft.calculatePrintedLength(value)\n+                + iRight.calculatePrintedLength(value);\n+        }\n+\n+        public void printTo(StringBuffer buf, int value) {\n+            iLeft.printTo(buf, value);\n+            iRight.printTo(buf, value);\n+        }\n+\n+        public void printTo(Writer out, int value) throws IOException {\n+            iLeft.printTo(out, value);\n+            iRight.printTo(out, value);\n+        }\n+\n+        public int parse(String periodStr, int position) {\n+            position = iLeft.parse(periodStr, position);\n+            if (position >= 0) {\n+                position = iRight.parse(periodStr, position);\n+            }\n+            return position;\n+        }\n+\n+        public int scan(String periodStr, final int position) {\n+            int pos = iLeft.scan(periodStr, position);\n+            if (pos >= 0) {\n+                return iRight.scan(periodStr, pos);\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Formats the numeric value of a field, potentially with prefix/suffix.\n+     */\n+    static class FieldFormatter\n+            implements PeriodPrinter, PeriodParser {\n+        private final int iMinPrintedDigits;\n+        private final int iPrintZeroSetting;\n+        private final int iMaxParsedDigits;\n+        private final boolean iRejectSignedValues;\n+        \n+        /** The index of the field type, 0=year, etc. */\n+        private final int iFieldType;\n+        /**\n+         * The array of the latest formatter added for each type.\n+         * This is shared between all the field formatters in a formatter.\n+         */\n+        private final FieldFormatter[] iFieldFormatters;\n+        \n+        private final PeriodFieldAffix iPrefix;\n+        private final PeriodFieldAffix iSuffix;\n+\n+        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n+                       int maxParsedDigits, boolean rejectSignedValues,\n+                       int fieldType, FieldFormatter[] fieldFormatters,\n+                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n+            iMinPrintedDigits = minPrintedDigits;\n+            iPrintZeroSetting = printZeroSetting;\n+            iMaxParsedDigits = maxParsedDigits;\n+            iRejectSignedValues = rejectSignedValues;\n+            iFieldType = fieldType;\n+            iFieldFormatters = fieldFormatters;\n+            iPrefix = prefix;\n+            iSuffix = suffix;\n+        }\n+\n+        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n+            iMinPrintedDigits = field.iMinPrintedDigits;\n+            iPrintZeroSetting = field.iPrintZeroSetting;\n+            iMaxParsedDigits = field.iMaxParsedDigits;\n+            iRejectSignedValues = field.iRejectSignedValues;\n+            iFieldType = field.iFieldType;\n+            iFieldFormatters = field.iFieldFormatters;\n+            iPrefix = field.iPrefix;\n+            if (field.iSuffix != null) {\n+                suffix = new CompositeAffix(field.iSuffix, suffix);\n+            }\n+            iSuffix = suffix;\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n+            if (stopAt <= 0) {\n+                return 0;\n+            }\n+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n+                return 1;\n+            }\n+            return 0;\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong == Long.MAX_VALUE) {\n+                return 0;\n+            }\n+\n+            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n+            if (iFieldType >= SECONDS_MILLIS) {\n+                // valueLong contains the seconds and millis fields\n+                // the minimum output is 0.000, which is 4 digits\n+                sum = Math.max(sum, 4);\n+                // plus one for the decimal point\n+                sum++;\n+                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n+                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n+                    sum -= 4; // remove three digits and decimal point\n+                }\n+                // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n+                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n+            }\n+            int value = (int) valueLong;\n+\n+            if (iPrefix != null) {\n+                sum += iPrefix.calculatePrintedLength(value);\n+            }\n+            if (iSuffix != null) {\n+                sum += iSuffix.calculatePrintedLength(value);\n+            }\n+\n+            return sum;\n+        }\n+        \n+        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong == Long.MAX_VALUE) {\n+                return;\n+            }\n+            int value = (int) valueLong;\n+            if (iFieldType >= SECONDS_MILLIS) {\n+                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n+            }\n+\n+            if (iPrefix != null) {\n+                iPrefix.printTo(buf, value);\n+            }\n+            int minDigits = iMinPrintedDigits;\n+            if (minDigits <= 1) {\n+                FormatUtils.appendUnpaddedInteger(buf, value);\n+            } else {\n+                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n+            }\n+            if (iFieldType >= SECONDS_MILLIS) {\n+                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n+                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n+                    buf.append('.');\n+                    FormatUtils.appendPaddedInteger(buf, dp, 3);\n+                }\n+            }\n+            if (iSuffix != null) {\n+                iSuffix.printTo(buf, value);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n+            long valueLong = getFieldValue(period);\n+            if (valueLong == Long.MAX_VALUE) {\n+                return;\n+            }\n+            int value = (int) valueLong;\n+            if (iFieldType >= SECONDS_MILLIS) {\n+                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n+            }\n+\n+            if (iPrefix != null) {\n+                iPrefix.printTo(out, value);\n+            }\n+            int minDigits = iMinPrintedDigits;\n+            if (minDigits <= 1) {\n+                FormatUtils.writeUnpaddedInteger(out, value);\n+            } else {\n+                FormatUtils.writePaddedInteger(out, value, minDigits);\n+            }\n+            if (iFieldType >= SECONDS_MILLIS) {\n+                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n+                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n+                    out.write('.');\n+                    FormatUtils.writePaddedInteger(out, dp, 3);\n+                }\n+            }\n+            if (iSuffix != null) {\n+                iSuffix.printTo(out, value);\n+            }\n+        }\n+\n+        public int parseInto(\n+                ReadWritablePeriod period, String text, \n+                int position, Locale locale) {\n+\n+            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n+\n+            // Shortcut test.\n+            if (position >= text.length()) {\n+                return mustParse ? ~position : position;\n+            }\n+\n+            if (iPrefix != null) {\n+                position = iPrefix.parse(text, position);\n+                if (position >= 0) {\n+                    // If prefix is found, then the parse must finish.\n+                    mustParse = true;\n+                } else {\n+                    // Prefix not found, so bail.\n+                    if (!mustParse) {\n+                        // It's okay because parsing of this field is not\n+                        // required. Don't return an error. Fields down the\n+                        // chain can continue on, trying to parse.\n+                        return ~position;\n+                    }\n+                    return position;\n+                }\n+            }\n+\n+            int suffixPos = -1;\n+            if (iSuffix != null && !mustParse) {\n+                // Pre-scan the suffix, to help determine if this field must be\n+                // parsed.\n+                suffixPos = iSuffix.scan(text, position);\n+                if (suffixPos >= 0) {\n+                    // If suffix is found, then parse must finish.\n+                    mustParse = true;\n+                } else {\n+                    // Suffix not found, so bail.\n+                    if (!mustParse) {\n+                        // It's okay because parsing of this field is not\n+                        // required. Don't return an error. Fields down the\n+                        // chain can continue on, trying to parse.\n+                        return ~suffixPos;\n+                    }\n+                    return suffixPos;\n+                }\n+            }\n+\n+            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n+                // If parsing is not required and the field is not supported,\n+                // exit gracefully so that another parser can continue on.\n+                return position;\n+            }\n+\n+            int limit;\n+            if (suffixPos > 0) {\n+                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n+            } else {\n+                limit = Math.min(iMaxParsedDigits, text.length() - position);\n+            }\n+\n+            // validate input number\n+            int length = 0;\n+            int fractPos = -1;\n+            boolean hasDigits = false;\n+            while (length < limit) {\n+                char c = text.charAt(position + length);\n+                // leading sign\n+                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n+                    boolean negative = c == '-';\n+\n+                    // Next character must be a digit.\n+                    if (length + 1 >= limit || \n+                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n+                    {\n+                        break;\n+                    }\n+\n+                    if (negative) {\n+                        length++;\n+                    } else {\n+                        // Skip the '+' for parseInt to succeed.\n+                        position++;\n+                    }\n+                    // Expand the limit to disregard the sign character.\n+                    limit = Math.min(limit + 1, text.length() - position);\n+                    continue;\n+                }\n+                // main number\n+                if (c >= '0' && c <= '9') {\n+                    hasDigits = true;\n+                } else {\n+                    if ((c == '.' || c == ',')\n+                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n+                        if (fractPos >= 0) {\n+                            // can't have two decimals\n+                            break;\n+                        }\n+                        fractPos = position + length + 1;\n+                        // Expand the limit to disregard the decimal point.\n+                        limit = Math.min(limit + 1, text.length() - position);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                length++;\n+            }\n+\n+            if (!hasDigits) {\n+                return ~position;\n+            }\n+\n+            if (suffixPos >= 0 && position + length != suffixPos) {\n+                // If there are additional non-digit characters before the\n+                // suffix is reached, then assume that the suffix found belongs\n+                // to a field not yet reached. Return original position so that\n+                // another parser can continue on.\n+                return position;\n+            }\n+\n+            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n+                // Handle common case.\n+                setFieldValue(period, iFieldType, parseInt(text, position, length));\n+            } else if (fractPos < 0) {\n+                setFieldValue(period, SECONDS, parseInt(text, position, length));\n+                setFieldValue(period, MILLIS, 0);\n+            } else {\n+                int wholeValue = parseInt(text, position, fractPos - position - 1);\n+                setFieldValue(period, SECONDS, wholeValue);\n+\n+                int fractLen = position + length - fractPos;\n+                int fractValue;\n+                if (fractLen <= 0) {\n+                    fractValue = 0;\n+                } else {\n+                    if (fractLen >= 3) {\n+                        fractValue = parseInt(text, fractPos, 3);\n+                    } else {\n+                        fractValue = parseInt(text, fractPos, fractLen);\n+                        if (fractLen == 1) {\n+                            fractValue *= 100;\n+                        } else {\n+                            fractValue *= 10;\n+                        }\n+                    }\n+                    if (wholeValue < 0) {\n+                        fractValue = -fractValue;\n+                    }\n+                }\n+\n+                setFieldValue(period, MILLIS, fractValue);\n+            }\n+                \n+            position += length;\n+\n+            if (position >= 0 && iSuffix != null) {\n+                position = iSuffix.parse(text, position);\n+            }\n+                \n+            return position;\n+        }\n+\n+        /**\n+         * @param text text to parse\n+         * @param position position in text\n+         * @param length exact count of characters to parse\n+         * @return parsed int value\n+         */\n+        private int parseInt(String text, int position, int length) {\n+            if (length >= 10) {\n+                // Since value may exceed max, use stock parser which checks for this.\n+                return Integer.parseInt(text.substring(position, position + length));\n+            }\n+            if (length <= 0) {\n+                return 0;\n+            }\n+            int value = text.charAt(position++);\n+            length--;\n+            boolean negative;\n+            if (value == '-') {\n+                if (--length < 0) {\n+                    return 0;\n+                }\n+                negative = true;\n+                value = text.charAt(position++);\n+            } else {\n+                negative = false;\n+            }\n+            value -= '0';\n+            while (length-- > 0) {\n+                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n+            }\n+            return negative ? -value : value;\n+        }\n+\n+        /**\n+         * @return Long.MAX_VALUE if nothing to print, otherwise value\n+         */\n+        long getFieldValue(ReadablePeriod period) {\n+            PeriodType type;\n+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n+                type = null; // Don't need to check if supported.\n+            } else {\n+                type = period.getPeriodType();\n+            }\n+            if (type != null && isSupported(type, iFieldType) == false) {\n+                return Long.MAX_VALUE;\n+            }\n+\n+            long value;\n+\n+            switch (iFieldType) {\n+            default:\n+                return Long.MAX_VALUE;\n+            case YEARS:\n+                value = period.get(DurationFieldType.years());\n+                break;\n+            case MONTHS:\n+                value = period.get(DurationFieldType.months());\n+                break;\n+            case WEEKS:\n+                value = period.get(DurationFieldType.weeks());\n+                break;\n+            case DAYS:\n+                value = period.get(DurationFieldType.days());\n+                break;\n+            case HOURS:\n+                value = period.get(DurationFieldType.hours());\n+                break;\n+            case MINUTES:\n+                value = period.get(DurationFieldType.minutes());\n+                break;\n+            case SECONDS:\n+                value = period.get(DurationFieldType.seconds());\n+                break;\n+            case MILLIS:\n+                value = period.get(DurationFieldType.millis());\n+                break;\n+            case SECONDS_MILLIS: // drop through\n+            case SECONDS_OPTIONAL_MILLIS:\n+                int seconds = period.get(DurationFieldType.seconds());\n+                int millis = period.get(DurationFieldType.millis());\n+                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n+                break;\n+            }\n+\n+            // determine if period is zero and this is the last field\n+            if (value == 0) {\n+                switch (iPrintZeroSetting) {\n+                case PRINT_ZERO_NEVER:\n+                    return Long.MAX_VALUE;\n+                case PRINT_ZERO_RARELY_LAST:\n+                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n+                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n+                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n+                                return Long.MAX_VALUE;\n+                            }\n+                        }\n+                    } else {\n+                        return Long.MAX_VALUE;\n+                    }\n+                    break;\n+                case PRINT_ZERO_RARELY_FIRST:\n+                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n+                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n+                        i--;                              // see bug 1660490\n+                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n+                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n+                                return Long.MAX_VALUE;\n+                            }\n+                        }\n+                    } else {\n+                        return Long.MAX_VALUE;\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            return value;\n+        }\n+\n+        boolean isZero(ReadablePeriod period) {\n+            for (int i = 0, isize = period.size(); i < isize; i++) {\n+                if (period.getValue(i) != 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        boolean isSupported(PeriodType type, int field) {\n+            switch (field) {\n+            default:\n+                return false;\n+            case YEARS:\n+                return type.isSupported(DurationFieldType.years());\n+            case MONTHS:\n+                return type.isSupported(DurationFieldType.months());\n+            case WEEKS:\n+                return type.isSupported(DurationFieldType.weeks());\n+            case DAYS:\n+                return type.isSupported(DurationFieldType.days());\n+            case HOURS:\n+                return type.isSupported(DurationFieldType.hours());\n+            case MINUTES:\n+                return type.isSupported(DurationFieldType.minutes());\n+            case SECONDS:\n+                return type.isSupported(DurationFieldType.seconds());\n+            case MILLIS:\n+                return type.isSupported(DurationFieldType.millis());\n+            case SECONDS_MILLIS: // drop through\n+            case SECONDS_OPTIONAL_MILLIS:\n+                return type.isSupported(DurationFieldType.seconds()) ||\n+                       type.isSupported(DurationFieldType.millis());\n+            }\n+        }\n+\n+        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n+            switch (field) {\n+            default:\n+                break;\n+            case YEARS:\n+                period.setYears(value);\n+                break;\n+            case MONTHS:\n+                period.setMonths(value);\n+                break;\n+            case WEEKS:\n+                period.setWeeks(value);\n+                break;\n+            case DAYS:\n+                period.setDays(value);\n+                break;\n+            case HOURS:\n+                period.setHours(value);\n+                break;\n+            case MINUTES:\n+                period.setMinutes(value);\n+                break;\n+            case SECONDS:\n+                period.setSeconds(value);\n+                break;\n+            case MILLIS:\n+                period.setMillis(value);\n+                break;\n+            }\n+        }\n+\n+        int getFieldType() {\n+            return iFieldType;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Handles a simple literal piece of text.\n+     */\n+    static class Literal\n+            implements PeriodPrinter, PeriodParser {\n+        static final Literal EMPTY = new Literal(\"\");\n+        private final String iText;\n+\n+        Literal(String text) {\n+            iText = text;\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n+            return 0;\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n+            return iText.length();\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n+            buf.append(iText);\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n+            out.write(iText);\n+        }\n+\n+        public int parseInto(\n+                ReadWritablePeriod period, String periodStr,\n+                int position, Locale locale) {\n+            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n+                return position + iText.length();\n+            }\n+            return ~position;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Handles a separator, that splits the fields into multiple parts.\n+     * For example, the 'T' in the ISO8601 standard.\n+     */\n+    static class Separator\n+            implements PeriodPrinter, PeriodParser {\n+        private final String iText;\n+        private final String iFinalText;\n+        private final String[] iParsedForms;\n+\n+        private final boolean iUseBefore;\n+        private final boolean iUseAfter;\n+\n+        private final PeriodPrinter iBeforePrinter;\n+        private volatile PeriodPrinter iAfterPrinter;\n+        private final PeriodParser iBeforeParser;\n+        private volatile PeriodParser iAfterParser;\n+\n+        Separator(String text, String finalText, String[] variants,\n+                PeriodPrinter beforePrinter, PeriodParser beforeParser,\n+                boolean useBefore, boolean useAfter) {\n+            iText = text;\n+            iFinalText = finalText;\n+\n+            if ((finalText == null || text.equals(finalText)) &&\n+                (variants == null || variants.length == 0)) {\n+\n+                iParsedForms = new String[] {text};\n+            } else {\n+                // Filter and reverse sort the parsed forms.\n+                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n+                parsedSet.add(text);\n+                parsedSet.add(finalText);\n+                if (variants != null) {\n+                    for (int i=variants.length; --i>=0; ) {\n+                        parsedSet.add(variants[i]);\n+                    }\n+                }\n+                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);\n+                Collections.reverse(parsedList);\n+                iParsedForms = parsedList.toArray(new String[parsedList.size()]);\n+            }\n+\n+            iBeforePrinter = beforePrinter;\n+            iBeforeParser = beforeParser;\n+            iUseBefore = useBefore;\n+            iUseAfter = useAfter;\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n+            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);\n+            if (sum < stopAt) {\n+                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);\n+            }\n+            return sum;\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n+            PeriodPrinter before = iBeforePrinter;\n+            PeriodPrinter after = iAfterPrinter;\n+            \n+            int sum = before.calculatePrintedLength(period, locale)\n+                    + after.calculatePrintedLength(period, locale);\n+            \n+            if (iUseBefore) {\n+                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n+                    if (iUseAfter) {\n+                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n+                        if (afterCount > 0) {\n+                            sum += (afterCount > 1 ? iText : iFinalText).length();\n+                        }\n+                    } else {\n+                        sum += iText.length();\n+                    }\n+                }\n+            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n+                sum += iText.length();\n+            }\n+            \n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n+            PeriodPrinter before = iBeforePrinter;\n+            PeriodPrinter after = iAfterPrinter;\n+            \n+            before.printTo(buf, period, locale);\n+            if (iUseBefore) {\n+                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n+                    if (iUseAfter) {\n+                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n+                        if (afterCount > 0) {\n+                            buf.append(afterCount > 1 ? iText : iFinalText);\n+                        }\n+                    } else {\n+                        buf.append(iText);\n+                    }\n+                }\n+            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n+                buf.append(iText);\n+            }\n+            after.printTo(buf, period, locale);\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n+            PeriodPrinter before = iBeforePrinter;\n+            PeriodPrinter after = iAfterPrinter;\n+            \n+            before.printTo(out, period, locale);\n+            if (iUseBefore) {\n+                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n+                    if (iUseAfter) {\n+                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n+                        if (afterCount > 0) {\n+                            out.write(afterCount > 1 ? iText : iFinalText);\n+                        }\n+                    } else {\n+                        out.write(iText);\n+                    }\n+                }\n+            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n+                out.write(iText);\n+            }\n+            after.printTo(out, period, locale);\n+        }\n+\n+        public int parseInto(\n+                ReadWritablePeriod period, String periodStr,\n+                int position, Locale locale) {\n+            int oldPos = position;\n+            position = iBeforeParser.parseInto(period, periodStr, position, locale);\n+\n+            if (position < 0) {\n+                return position;\n+            }\n+\n+            boolean found = false;\n+            if (position > oldPos) {\n+                // Consume this separator.\n+                String[] parsedForms = iParsedForms;\n+                int length = parsedForms.length;\n+                for (int i=0; i < length; i++) {\n+                    String parsedForm = parsedForms[i];\n+                    if ((parsedForm == null || parsedForm.length() == 0) ||\n+                        periodStr.regionMatches\n+                        (true, position, parsedForm, 0, parsedForm.length())) {\n+                        \n+                        position += parsedForm.length();\n+                        found = true;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            oldPos = position;\n+            position = iAfterParser.parseInto(period, periodStr, position, locale);\n+\n+            if (position < 0) {\n+                return position;\n+            }\n+\n+            if (found && position == oldPos) {\n+                // Separator should not have been supplied.\n+                return ~oldPos;\n+            }\n+\n+            if (position > oldPos && !found && !iUseBefore) {\n+                // Separator was required.\n+                return ~oldPos;\n+            }\n+\n+            return position;\n+        }\n+\n+        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n+            iAfterPrinter = afterPrinter;\n+            iAfterParser = afterParser;\n+            return this;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Composite implementation that merges other fields to create a full pattern.\n+     */\n+    static class Composite\n+            implements PeriodPrinter, PeriodParser {\n+        \n+        private final PeriodPrinter[] iPrinters;\n+        private final PeriodParser[] iParsers;\n+\n+        Composite(List<Object> elementPairs) {\n+            List<Object> printerList = new ArrayList<Object>();\n+            List<Object> parserList = new ArrayList<Object>();\n+\n+            decompose(elementPairs, printerList, parserList);\n+\n+            if (printerList.size() <= 0) {\n+                iPrinters = null;\n+            } else {\n+                iPrinters = printerList.toArray(\n+                        new PeriodPrinter[printerList.size()]);\n+            }\n+\n+            if (parserList.size() <= 0) {\n+                iParsers = null;\n+            } else {\n+                iParsers = parserList.toArray(\n+                        new PeriodParser[parserList.size()]);\n+            }\n+        }\n+\n+        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n+            int sum = 0;\n+            PeriodPrinter[] printers = iPrinters;\n+            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n+                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n+            }\n+            return sum;\n+        }\n+\n+        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n+            int sum = 0;\n+            PeriodPrinter[] printers = iPrinters;\n+            for (int i=printers.length; --i>=0; ) {\n+                sum += printers[i].calculatePrintedLength(period, locale);\n+            }\n+            return sum;\n+        }\n+\n+        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n+            PeriodPrinter[] printers = iPrinters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                printers[i].printTo(buf, period, locale);\n+            }\n+        }\n+\n+        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n+            PeriodPrinter[] printers = iPrinters;\n+            int len = printers.length;\n+            for (int i=0; i<len; i++) {\n+                printers[i].printTo(out, period, locale);\n+            }\n+        }\n+\n+        public int parseInto(\n+                ReadWritablePeriod period, String periodStr,\n+                int position, Locale locale) {\n+            PeriodParser[] parsers = iParsers;\n+            if (parsers == null) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            int len = parsers.length;\n+            for (int i=0; i<len && position >= 0; i++) {\n+                position = parsers[i].parseInto(period, periodStr, position, locale);\n+            }\n+            return position;\n+        }\n+\n+        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n+            int size = elementPairs.size();\n+            for (int i=0; i<size; i+=2) {\n+                Object element = elementPairs.get(i);\n+                if (element instanceof PeriodPrinter) {\n+                    if (element instanceof Composite) {\n+                        addArrayToList(printerList, ((Composite) element).iPrinters);\n+                    } else {\n+                        printerList.add(element);\n+                    }\n+                }\n+\n+                element = elementPairs.get(i + 1);\n+                if (element instanceof PeriodParser) {\n+                    if (element instanceof Composite) {\n+                        addArrayToList(parserList, ((Composite) element).iParsers);\n+                    } else {\n+                        parserList.add(element);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void addArrayToList(List<Object> list, Object[] array) {\n+            if (array != null) {\n+                for (int i=0; i<array.length; i++) {\n+                    list.add(array[i]);\n+                }\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/PeriodParser.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.util.Locale;\n+\n+import org.joda.time.ReadWritablePeriod;\n+\n+/**\n+ * Internal interface for parsing textual representations of time periods.\n+ * <p>\n+ * Application users will rarely use this class directly. Instead, you\n+ * will use one of the factory classes to create a {@link PeriodFormatter}.\n+ * <p>\n+ * The factory classes are:<br />\n+ * - {@link PeriodFormatterBuilder}<br />\n+ * - {@link PeriodFormat}<br />\n+ * - {@link ISOPeriodFormat}<br />\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see PeriodFormatter\n+ * @see PeriodFormatterBuilder\n+ * @see PeriodFormat\n+ */\n+public interface PeriodParser {\n+\n+    /**\n+     * Parses a period from the given text, at the given position, saving the\n+     * result into the fields of the given ReadWritablePeriod. If the parse\n+     * succeeds, the return value is the new text position. Note that the parse\n+     * may succeed without fully reading the text.\n+     * <p>\n+     * If it fails, the return value is negative, but the period may still be\n+     * modified. To determine the position where the parse failed, apply the\n+     * one's complement operator (~) on the return value.\n+     *\n+     * @param period  a period that will be modified\n+     * @param periodStr  text to parse\n+     * @param position position to start parsing from\n+     * @param locale  the locale to use for parsing\n+     * @return new position, if negative, parse failed. Apply complement\n+     * operator (~) to get position of failure\n+     * @throws IllegalArgumentException if any field is out of range\n+     */\n+    int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale);\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/format/PeriodPrinter.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Locale;\n+\n+import org.joda.time.ReadablePeriod;\n+\n+/**\n+ * Internal interface for printing textual representations of time periods.\n+ * <p>\n+ * Application users will rarely use this class directly. Instead, you\n+ * will use one of the factory classes to create a {@link PeriodFormatter}.\n+ * <p>\n+ * The factory classes are:<br />\n+ * - {@link PeriodFormatterBuilder}<br />\n+ * - {@link PeriodFormat}<br />\n+ * - {@link ISOPeriodFormat}<br />\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @see PeriodFormatter\n+ * @see PeriodFormatterBuilder\n+ * @see PeriodFormat\n+ */\n+public interface PeriodPrinter {\n+\n+    /**\n+     * Returns the exact number of characters produced for the given period.\n+     * \n+     * @param period  the period to use\n+     * @param locale  the locale to use\n+     * @return the estimated length\n+     */\n+    int calculatePrintedLength(ReadablePeriod period, Locale locale);\n+\n+    /**\n+     * Returns the amount of fields from the given period that this printer\n+     * will print.\n+     * \n+     * @param period  the period to use\n+     * @param stopAt stop counting at this value, enter a number &ge; 256 to count all\n+     * @param locale  the locale to use\n+     * @return amount of fields printed\n+     */\n+    int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Prints a ReadablePeriod to a StringBuffer.\n+     *\n+     * @param buf  the formatted period is appended to this buffer\n+     * @param period  the period to format\n+     * @param locale  the locale to use\n+     */\n+    void printTo(StringBuffer buf, ReadablePeriod period, Locale locale);\n+\n+    /**\n+     * Prints a ReadablePeriod to a Writer.\n+     *\n+     * @param out  the formatted period is written out\n+     * @param period  the period to format\n+     * @param locale  the locale to use\n+     */\n+    void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException;\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/CachedDateTimeZone.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Improves the performance of requesting time zone offsets and name keys by\n+ * caching the results. Time zones that have simple rules or are fixed should\n+ * not be cached, as it is unlikely to improve performance.\n+ * <p>\n+ * CachedDateTimeZone is thread-safe and immutable.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class CachedDateTimeZone extends DateTimeZone {\n+\n+    private static final long serialVersionUID = 5472298452022250685L;\n+\n+    private static final int cInfoCacheMask;\n+\n+    static {\n+        Integer i;\n+        try {\n+            i = Integer.getInteger(\"org.joda.time.tz.CachedDateTimeZone.size\");\n+        } catch (SecurityException e) {\n+            i = null;\n+        }\n+\n+        int cacheSize;\n+        if (i == null) {\n+            // With a cache size of 512, dates that lie within any 69.7 year\n+            // period have no cache collisions.\n+            cacheSize = 512; // (1 << 9)\n+        } else {\n+            cacheSize = i.intValue();\n+            // Ensure cache size is even power of 2.\n+            cacheSize--;\n+            int shift = 0;\n+            while (cacheSize > 0) {\n+                shift++;\n+                cacheSize >>= 1;\n+            }\n+            cacheSize = 1 << shift;\n+        }\n+\n+        cInfoCacheMask = cacheSize - 1;\n+    }\n+\n+    /**\n+     * Returns a new CachedDateTimeZone unless given zone is already cached.\n+     */\n+    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n+        if (zone instanceof CachedDateTimeZone) {\n+            return (CachedDateTimeZone)zone;\n+        }\n+        return new CachedDateTimeZone(zone);\n+    }\n+\n+    /*\n+     * Caching is performed by breaking timeline down into periods of 2^32\n+     * milliseconds, or about 49.7 days. A year has about 7.3 periods, usually\n+     * with only 2 time zone offset periods. Most of the 49.7 day periods will\n+     * have no transition, about one quarter have one transition, and very rare\n+     * cases have multiple transitions.\n+     */\n+\n+    private final DateTimeZone iZone;\n+\n+    private transient Info[] iInfoCache;\n+\n+    private CachedDateTimeZone(DateTimeZone zone) {\n+        super(zone.getID());\n+        iZone = zone;\n+        iInfoCache = new Info[cInfoCacheMask + 1];\n+    }\n+\n+    private void readObject(java.io.ObjectInputStream in)\n+        throws java.io.IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+        iInfoCache = new Info[cInfoCacheMask + 1];\n+    }\n+\n+    /**\n+     * Returns the DateTimeZone being wrapped.\n+     */\n+    public DateTimeZone getUncachedZone() {\n+        return iZone;\n+    }\n+\n+    public String getNameKey(long instant) {\n+        return getInfo(instant).getNameKey(instant);\n+    }\n+\n+    public int getOffset(long instant) {\n+        return getInfo(instant).getOffset(instant);\n+    }\n+\n+    public int getStandardOffset(long instant) {\n+        return getInfo(instant).getStandardOffset(instant);\n+    }\n+\n+    public boolean isFixed() {\n+        return iZone.isFixed();\n+    }\n+\n+    public long nextTransition(long instant) {\n+        return iZone.nextTransition(instant);\n+    }\n+\n+    public long previousTransition(long instant) {\n+        return iZone.previousTransition(instant);\n+    }\n+\n+    public int hashCode() {\n+        return iZone.hashCode();\n+    }\n+\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof CachedDateTimeZone) {\n+            return iZone.equals(((CachedDateTimeZone)obj).iZone);\n+        }\n+        return false;\n+    }\n+\n+    // Although accessed by multiple threads, this method doesn't need to be\n+    // synchronized.\n+\n+    private Info getInfo(long millis) {\n+        int period = (int)(millis >> 32);\n+        Info[] cache = iInfoCache;\n+        int index = period & cInfoCacheMask;\n+        Info info = cache[index];\n+        if (info == null || (int)((info.iPeriodStart >> 32)) != period) {\n+            info = createInfo(millis);\n+            cache[index] = info;\n+        }\n+        return info;\n+    }\n+\n+    private Info createInfo(long millis) {\n+        long periodStart = millis & (0xffffffffL << 32);\n+        Info info = new Info(iZone, periodStart);\n+        \n+        long end = periodStart | 0xffffffffL;\n+        Info chain = info;\n+        while (true) {\n+            long next = iZone.nextTransition(periodStart);\n+            if (next == periodStart || next > end) {\n+                break;\n+            }\n+            periodStart = next;\n+            chain = (chain.iNextInfo = new Info(iZone, periodStart));\n+        }\n+\n+        return info;\n+    }\n+\n+    private final static class Info {\n+        // For first Info in chain, iPeriodStart's lower 32 bits are clear.\n+        public final long iPeriodStart;\n+        public final DateTimeZone iZoneRef;\n+\n+        Info iNextInfo;\n+\n+        private String iNameKey;\n+        private int iOffset = Integer.MIN_VALUE;\n+        private int iStandardOffset = Integer.MIN_VALUE;\n+\n+        Info(DateTimeZone zone, long periodStart) {\n+            iPeriodStart = periodStart;\n+            iZoneRef = zone;\n+        }\n+\n+        public String getNameKey(long millis) {\n+            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n+                if (iNameKey == null) {\n+                    iNameKey = iZoneRef.getNameKey(iPeriodStart);\n+                }\n+                return iNameKey;\n+            }\n+            return iNextInfo.getNameKey(millis);\n+        }\n+\n+        public int getOffset(long millis) {\n+            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n+                if (iOffset == Integer.MIN_VALUE) {\n+                    iOffset = iZoneRef.getOffset(iPeriodStart);\n+                }\n+                return iOffset;\n+            }\n+            return iNextInfo.getOffset(millis);\n+        }\n+\n+        public int getStandardOffset(long millis) {\n+            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n+                if (iStandardOffset == Integer.MIN_VALUE) {\n+                    iStandardOffset = iZoneRef.getStandardOffset(iPeriodStart);\n+                }\n+                return iStandardOffset;\n+            }\n+            return iNextInfo.getStandardOffset(millis);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import java.io.DataInput;\n+import java.io.DataInputStream;\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.DateFormatSymbols;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Period;\n+import org.joda.time.PeriodType;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since\n+ * creating a new DateTimeZone this way is a relatively expensive operation,\n+ * built zones can be written to a file. Reading back the encoded data is a\n+ * quick operation.\n+ * <p>\n+ * DateTimeZoneBuilder itself is mutable and not thread-safe, but the\n+ * DateTimeZone objects that it builds are thread-safe and immutable.\n+ * <p>\n+ * It is intended that {@link ZoneInfoCompiler} be used to read time zone data\n+ * files, indirectly calling DateTimeZoneBuilder. The following complex\n+ * example defines the America/Los_Angeles time zone, with all historical\n+ * transitions:\n+ * \n+ * <pre>\n+ * DateTimeZone America_Los_Angeles = new DateTimeZoneBuilder()\n+ *     .addCutover(-2147483648, 'w', 1, 1, 0, false, 0)\n+ *     .setStandardOffset(-28378000)\n+ *     .setFixedSavings(\"LMT\", 0)\n+ *     .addCutover(1883, 'w', 11, 18, 0, false, 43200000)\n+ *     .setStandardOffset(-28800000)\n+ *     .addRecurringSavings(\"PDT\", 3600000, 1918, 1919, 'w',  3, -1, 7, false, 7200000)\n+ *     .addRecurringSavings(\"PST\",       0, 1918, 1919, 'w', 10, -1, 7, false, 7200000)\n+ *     .addRecurringSavings(\"PWT\", 3600000, 1942, 1942, 'w',  2,  9, 0, false, 7200000)\n+ *     .addRecurringSavings(\"PPT\", 3600000, 1945, 1945, 'u',  8, 14, 0, false, 82800000)\n+ *     .addRecurringSavings(\"PST\",       0, 1945, 1945, 'w',  9, 30, 0, false, 7200000)\n+ *     .addRecurringSavings(\"PDT\", 3600000, 1948, 1948, 'w',  3, 14, 0, false, 7200000)\n+ *     .addRecurringSavings(\"PST\",       0, 1949, 1949, 'w',  1,  1, 0, false, 7200000)\n+ *     .addRecurringSavings(\"PDT\", 3600000, 1950, 1966, 'w',  4, -1, 7, false, 7200000)\n+ *     .addRecurringSavings(\"PST\",       0, 1950, 1961, 'w',  9, -1, 7, false, 7200000)\n+ *     .addRecurringSavings(\"PST\",       0, 1962, 1966, 'w', 10, -1, 7, false, 7200000)\n+ *     .addRecurringSavings(\"PST\",       0, 1967, 2147483647, 'w', 10, -1, 7, false, 7200000)\n+ *     .addRecurringSavings(\"PDT\", 3600000, 1967, 1973, 'w', 4, -1,  7, false, 7200000)\n+ *     .addRecurringSavings(\"PDT\", 3600000, 1974, 1974, 'w', 1,  6,  0, false, 7200000)\n+ *     .addRecurringSavings(\"PDT\", 3600000, 1975, 1975, 'w', 2, 23,  0, false, 7200000)\n+ *     .addRecurringSavings(\"PDT\", 3600000, 1976, 1986, 'w', 4, -1,  7, false, 7200000)\n+ *     .addRecurringSavings(\"PDT\", 3600000, 1987, 2147483647, 'w', 4, 1, 7, true, 7200000)\n+ *     .toDateTimeZone(\"America/Los_Angeles\", true);\n+ * </pre>\n+ *\n+ * @author Brian S O'Neill\n+ * @see ZoneInfoCompiler\n+ * @see ZoneInfoProvider\n+ * @since 1.0\n+ */\n+public class DateTimeZoneBuilder {\n+    /**\n+     * Decodes a built DateTimeZone from the given stream, as encoded by\n+     * writeTo.\n+     *\n+     * @param in input stream to read encoded DateTimeZone from.\n+     * @param id time zone id to assign\n+     */\n+    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n+        if (in instanceof DataInput) {\n+            return readFrom((DataInput)in, id);\n+        } else {\n+            return readFrom((DataInput)new DataInputStream(in), id);\n+        }\n+    }\n+\n+    /**\n+     * Decodes a built DateTimeZone from the given stream, as encoded by\n+     * writeTo.\n+     *\n+     * @param in input stream to read encoded DateTimeZone from.\n+     * @param id time zone id to assign\n+     */\n+    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n+        switch (in.readUnsignedByte()) {\n+        case 'F':\n+            DateTimeZone fixed = new FixedDateTimeZone\n+                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n+            if (fixed.equals(DateTimeZone.UTC)) {\n+                fixed = DateTimeZone.UTC;\n+            }\n+            return fixed;\n+        case 'C':\n+            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n+        case 'P':\n+            return PrecalculatedZone.readFrom(in, id);\n+        default:\n+            throw new IOException(\"Invalid encoding\");\n+        }\n+    }\n+\n+    /**\n+     * Millisecond encoding formats:\n+     *\n+     * upper two bits  units       field length  approximate range\n+     * ---------------------------------------------------------------\n+     * 00              30 minutes  1 byte        +/- 16 hours\n+     * 01              minutes     4 bytes       +/- 1020 years\n+     * 10              seconds     5 bytes       +/- 4355 years\n+     * 11              millis      9 bytes       +/- 292,000,000 years\n+     *\n+     * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.\n+     */\n+    static void writeMillis(DataOutput out, long millis) throws IOException {\n+        if (millis % (30 * 60000L) == 0) {\n+            // Try to write in 30 minute units.\n+            long units = millis / (30 * 60000L);\n+            if (((units << (64 - 6)) >> (64 - 6)) == units) {\n+                // Form 00 (6 bits effective precision)\n+                out.writeByte((int)(units & 0x3f));\n+                return;\n+            }\n+        }\n+\n+        if (millis % 60000L == 0) {\n+            // Try to write minutes.\n+            long minutes = millis / 60000L;\n+            if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) {\n+                // Form 01 (30 bits effective precision)\n+                out.writeInt(0x40000000 | (int)(minutes & 0x3fffffff));\n+                return;\n+            }\n+        }\n+        \n+        if (millis % 1000L == 0) {\n+            // Try to write seconds.\n+            long seconds = millis / 1000L;\n+            if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) {\n+                // Form 10 (38 bits effective precision)\n+                out.writeByte(0x80 | (int)((seconds >> 32) & 0x3f));\n+                out.writeInt((int)(seconds & 0xffffffff));\n+                return;\n+            }\n+        }\n+\n+        // Write milliseconds either because the additional precision is\n+        // required or the minutes didn't fit in the field.\n+        \n+        // Form 11 (64 bits effective precision, but write as if 70 bits)\n+        out.writeByte(millis < 0 ? 0xff : 0xc0);\n+        out.writeLong(millis);\n+    }\n+\n+    /**\n+     * Reads encoding generated by writeMillis.\n+     */\n+    static long readMillis(DataInput in) throws IOException {\n+        int v = in.readUnsignedByte();\n+        switch (v >> 6) {\n+        case 0: default:\n+            // Form 00 (6 bits effective precision)\n+            v = (v << (32 - 6)) >> (32 - 6);\n+            return v * (30 * 60000L);\n+\n+        case 1:\n+            // Form 01 (30 bits effective precision)\n+            v = (v << (32 - 6)) >> (32 - 30);\n+            v |= (in.readUnsignedByte()) << 16;\n+            v |= (in.readUnsignedByte()) << 8;\n+            v |= (in.readUnsignedByte());\n+            return v * 60000L;\n+\n+        case 2:\n+            // Form 10 (38 bits effective precision)\n+            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n+            w |= (in.readUnsignedByte()) << 24;\n+            w |= (in.readUnsignedByte()) << 16;\n+            w |= (in.readUnsignedByte()) << 8;\n+            w |= (in.readUnsignedByte());\n+            return w * 1000L;\n+\n+        case 3:\n+            // Form 11 (64 bits effective precision)\n+            return in.readLong();\n+        }\n+    }\n+\n+    private static DateTimeZone buildFixedZone(String id, String nameKey,\n+                                               int wallOffset, int standardOffset) {\n+        if (\"UTC\".equals(id) && id.equals(nameKey) &&\n+            wallOffset == 0 && standardOffset == 0) {\n+            return DateTimeZone.UTC;\n+        }\n+        return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset);\n+    }\n+\n+    // List of RuleSets.\n+    private final ArrayList<RuleSet> iRuleSets;\n+\n+    public DateTimeZoneBuilder() {\n+        iRuleSets = new ArrayList<RuleSet>(10);\n+    }\n+\n+    /**\n+     * Adds a cutover for added rules. The standard offset at the cutover\n+     * defaults to 0. Call setStandardOffset afterwards to change it.\n+     *\n+     * @param year  the year of cutover\n+     * @param mode 'u' - cutover is measured against UTC, 'w' - against wall\n+     *  offset, 's' - against standard offset\n+     * @param monthOfYear  the month from 1 (January) to 12 (December)\n+     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n+     *  For example, if -1, set to last day of month\n+     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n+     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n+     *  dayOfWeek when true, retreat when false.\n+     * @param millisOfDay  additional precision for specifying time of day of cutover\n+     */\n+    public DateTimeZoneBuilder addCutover(int year,\n+                                          char mode,\n+                                          int monthOfYear,\n+                                          int dayOfMonth,\n+                                          int dayOfWeek,\n+                                          boolean advanceDayOfWeek,\n+                                          int millisOfDay)\n+    {\n+        OfYear ofYear = new OfYear\n+            (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n+        if (iRuleSets.size() > 0) {\n+            RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);\n+            lastRuleSet.setUpperLimit(year, ofYear);\n+        }\n+        iRuleSets.add(new RuleSet());\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the standard offset to use for newly added rules until the next\n+     * cutover is added.\n+     * @param standardOffset  the standard offset in millis\n+     */\n+    public DateTimeZoneBuilder setStandardOffset(int standardOffset) {\n+        getLastRuleSet().setStandardOffset(standardOffset);\n+        return this;\n+    }\n+\n+    /**\n+     * Set a fixed savings rule at the cutover.\n+     */\n+    public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) {\n+        getLastRuleSet().setFixedSavings(nameKey, saveMillis);\n+        return this;\n+    }\n+\n+    /**\n+     * Add a recurring daylight saving time rule.\n+     *\n+     * @param nameKey  the name key of new rule\n+     * @param saveMillis  the milliseconds to add to standard offset\n+     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates\n+     * beginning of time\n+     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE\n+     *  indicates end of time\n+     * @param mode  'u' - transitions are calculated against UTC, 'w' -\n+     *  transitions are calculated against wall offset, 's' - transitions are\n+     *  calculated against standard offset\n+     * @param monthOfYear  the month from 1 (January) to 12 (December)\n+     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n+     *  For example, if -1, set to last day of month\n+     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n+     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n+     *  dayOfWeek when true, retreat when false.\n+     * @param millisOfDay  additional precision for specifying time of day of transitions\n+     */\n+    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,\n+                                                   int fromYear, int toYear,\n+                                                   char mode,\n+                                                   int monthOfYear,\n+                                                   int dayOfMonth,\n+                                                   int dayOfWeek,\n+                                                   boolean advanceDayOfWeek,\n+                                                   int millisOfDay)\n+    {\n+        if (fromYear <= toYear) {\n+            OfYear ofYear = new OfYear\n+                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n+            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n+            Rule rule = new Rule(recurrence, fromYear, toYear);\n+            getLastRuleSet().addRule(rule);\n+        }\n+        return this;\n+    }\n+\n+    private RuleSet getLastRuleSet() {\n+        if (iRuleSets.size() == 0) {\n+            addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0);\n+        }\n+        return iRuleSets.get(iRuleSets.size() - 1);\n+    }\n+    \n+    /**\n+     * Processes all the rules and builds a DateTimeZone.\n+     *\n+     * @param id  time zone id to assign\n+     * @param outputID  true if the zone id should be output\n+     */\n+    public DateTimeZone toDateTimeZone(String id, boolean outputID) {\n+        if (id == null) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        // Discover where all the transitions occur and store the results in\n+        // these lists.\n+        ArrayList<Transition> transitions = new ArrayList<Transition>();\n+\n+        // Tail zone picks up remaining transitions in the form of an endless\n+        // DST cycle.\n+        DSTZone tailZone = null;\n+\n+        long millis = Long.MIN_VALUE;\n+        int saveMillis = 0;\n+            \n+        int ruleSetCount = iRuleSets.size();\n+        for (int i=0; i<ruleSetCount; i++) {\n+            RuleSet rs = iRuleSets.get(i);\n+            Transition next = rs.firstTransition(millis);\n+            if (next == null) {\n+                continue;\n+            }\n+            addTransition(transitions, next);\n+            millis = next.getMillis();\n+            saveMillis = next.getSaveMillis();\n+\n+            // Copy it since we're going to destroy it.\n+            rs = new RuleSet(rs);\n+\n+            while ((next = rs.nextTransition(millis, saveMillis)) != null) {\n+                if (addTransition(transitions, next)) {\n+                    if (tailZone != null) {\n+                        // Got the extra transition before DSTZone.\n+                        break;\n+                    }\n+                }\n+                millis = next.getMillis();\n+                saveMillis = next.getSaveMillis();\n+                if (tailZone == null && i == ruleSetCount - 1) {\n+                    tailZone = rs.buildTailZone(id);\n+                    // If tailZone is not null, don't break out of main loop until\n+                    // at least one more transition is calculated. This ensures a\n+                    // correct 'seam' to the DSTZone.\n+                }\n+            }\n+\n+            millis = rs.getUpperLimit(saveMillis);\n+        }\n+\n+        // Check if a simpler zone implementation can be returned.\n+        if (transitions.size() == 0) {\n+            if (tailZone != null) {\n+                // This shouldn't happen, but handle just in case.\n+                return tailZone;\n+            }\n+            return buildFixedZone(id, \"UTC\", 0, 0);\n+        }\n+        if (transitions.size() == 1 && tailZone == null) {\n+            Transition tr = transitions.get(0);\n+            return buildFixedZone(id, tr.getNameKey(),\n+                                  tr.getWallOffset(), tr.getStandardOffset());\n+        }\n+\n+        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);\n+        if (zone.isCachable()) {\n+            return CachedDateTimeZone.forZone(zone);\n+        }\n+        return zone;\n+    }\n+\n+    private boolean addTransition(ArrayList<Transition> transitions, Transition tr) {\n+        int size = transitions.size();\n+        if (size == 0) {\n+            transitions.add(tr);\n+            return true;\n+        }\n+\n+        Transition last = transitions.get(size - 1);\n+        if (!tr.isTransitionFrom(last)) {\n+            return false;\n+        }\n+\n+        // If local time of new transition is same as last local time, just\n+        // replace last transition with new one.\n+        int offsetForLast = 0;\n+        if (size >= 2) {\n+            offsetForLast = transitions.get(size - 2).getWallOffset();\n+        }\n+        int offsetForNew = last.getWallOffset();\n+\n+        long lastLocal = last.getMillis() + offsetForLast;\n+        long newLocal = tr.getMillis() + offsetForNew;\n+\n+        if (newLocal != lastLocal) {\n+            transitions.add(tr);\n+            return true;\n+        }\n+\n+        transitions.remove(size - 1);\n+        return addTransition(transitions, tr);\n+    }\n+\n+    /**\n+     * Encodes a built DateTimeZone to the given stream. Call readFrom to\n+     * decode the data into a DateTimeZone object.\n+     *\n+     * @param out  the output stream to receive the encoded DateTimeZone\n+     * @since 1.5 (parameter added)\n+     */\n+    public void writeTo(String zoneID, OutputStream out) throws IOException {\n+        if (out instanceof DataOutput) {\n+            writeTo(zoneID, (DataOutput)out);\n+        } else {\n+            writeTo(zoneID, (DataOutput)new DataOutputStream(out));\n+        }\n+    }\n+\n+    /**\n+     * Encodes a built DateTimeZone to the given stream. Call readFrom to\n+     * decode the data into a DateTimeZone object.\n+     *\n+     * @param out  the output stream to receive the encoded DateTimeZone\n+     * @since 1.5 (parameter added)\n+     */\n+    public void writeTo(String zoneID, DataOutput out) throws IOException {\n+        // pass false so zone id is not written out\n+        DateTimeZone zone = toDateTimeZone(zoneID, false);\n+\n+        if (zone instanceof FixedDateTimeZone) {\n+            out.writeByte('F'); // 'F' for fixed\n+            out.writeUTF(zone.getNameKey(0));\n+            writeMillis(out, zone.getOffset(0));\n+            writeMillis(out, zone.getStandardOffset(0));\n+        } else {\n+            if (zone instanceof CachedDateTimeZone) {\n+                out.writeByte('C'); // 'C' for cached, precalculated\n+                zone = ((CachedDateTimeZone)zone).getUncachedZone();\n+            } else {\n+                out.writeByte('P'); // 'P' for precalculated, uncached\n+            }\n+            ((PrecalculatedZone)zone).writeTo(out);\n+        }\n+    }\n+\n+    /**\n+     * Supports setting fields of year and moving between transitions.\n+     */\n+    private static final class OfYear {\n+        static OfYear readFrom(DataInput in) throws IOException {\n+            return new OfYear((char)in.readUnsignedByte(),\n+                              (int)in.readUnsignedByte(),\n+                              (int)in.readByte(),\n+                              (int)in.readUnsignedByte(),\n+                              in.readBoolean(),\n+                              (int)readMillis(in));\n+        }\n+\n+        // Is 'u', 'w', or 's'.\n+        final char iMode;\n+\n+        final int iMonthOfYear;\n+        final int iDayOfMonth;\n+        final int iDayOfWeek;\n+        final boolean iAdvance;\n+        final int iMillisOfDay;\n+\n+        OfYear(char mode,\n+               int monthOfYear,\n+               int dayOfMonth,\n+               int dayOfWeek, boolean advanceDayOfWeek,\n+               int millisOfDay)\n+        {\n+            if (mode != 'u' && mode != 'w' && mode != 's') {\n+                throw new IllegalArgumentException(\"Unknown mode: \" + mode);\n+            }\n+\n+            iMode = mode;\n+            iMonthOfYear = monthOfYear;\n+            iDayOfMonth = dayOfMonth;\n+            iDayOfWeek = dayOfWeek;\n+            iAdvance = advanceDayOfWeek;\n+            iMillisOfDay = millisOfDay;\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before instant\n+         */\n+        public long setInstant(int year, int standardOffset, int saveMillis) {\n+            int offset;\n+            if (iMode == 'w') {\n+                offset = standardOffset + saveMillis;\n+            } else if (iMode == 's') {\n+                offset = standardOffset;\n+            } else {\n+                offset = 0;\n+            }\n+\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+            long millis = chrono.year().set(0, year);\n+            millis = chrono.monthOfYear().set(millis, iMonthOfYear);\n+            millis = chrono.millisOfDay().set(millis, iMillisOfDay);\n+            millis = setDayOfMonth(chrono, millis);\n+\n+            if (iDayOfWeek != 0) {\n+                millis = setDayOfWeek(chrono, millis);\n+            }\n+\n+            // Convert from local time to UTC.\n+            return millis - offset;\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before next recurrence\n+         */\n+        public long next(long instant, int standardOffset, int saveMillis) {\n+            int offset;\n+            if (iMode == 'w') {\n+                offset = standardOffset + saveMillis;\n+            } else if (iMode == 's') {\n+                offset = standardOffset;\n+            } else {\n+                offset = 0;\n+            }\n+\n+            // Convert from UTC to local time.\n+            instant += offset;\n+\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+            long next = chrono.monthOfYear().set(instant, iMonthOfYear);\n+            // Be lenient with millisOfDay.\n+            next = chrono.millisOfDay().set(next, 0);\n+            next = chrono.millisOfDay().add(next, iMillisOfDay);\n+            next = setDayOfMonthNext(chrono, next);\n+\n+            if (iDayOfWeek == 0) {\n+                if (next <= instant) {\n+                    next = chrono.year().add(next, 1);\n+                    next = setDayOfMonthNext(chrono, next);\n+                }\n+            } else {\n+                next = setDayOfWeek(chrono, next);\n+                if (next <= instant) {\n+                    next = chrono.year().add(next, 1);\n+                    next = chrono.monthOfYear().set(next, iMonthOfYear);\n+                    next = setDayOfMonthNext(chrono, next);\n+                    next = setDayOfWeek(chrono, next);\n+                }\n+            }\n+\n+            // Convert from local time to UTC.\n+            return next - offset;\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before previous recurrence\n+         */\n+        public long previous(long instant, int standardOffset, int saveMillis) {\n+            int offset;\n+            if (iMode == 'w') {\n+                offset = standardOffset + saveMillis;\n+            } else if (iMode == 's') {\n+                offset = standardOffset;\n+            } else {\n+                offset = 0;\n+            }\n+\n+            // Convert from UTC to local time.\n+            instant += offset;\n+\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);\n+            // Be lenient with millisOfDay.\n+            prev = chrono.millisOfDay().set(prev, 0);\n+            prev = chrono.millisOfDay().add(prev, iMillisOfDay);\n+            prev = setDayOfMonthPrevious(chrono, prev);\n+\n+            if (iDayOfWeek == 0) {\n+                if (prev >= instant) {\n+                    prev = chrono.year().add(prev, -1);\n+                    prev = setDayOfMonthPrevious(chrono, prev);\n+                }\n+            } else {\n+                prev = setDayOfWeek(chrono, prev);\n+                if (prev >= instant) {\n+                    prev = chrono.year().add(prev, -1);\n+                    prev = chrono.monthOfYear().set(prev, iMonthOfYear);\n+                    prev = setDayOfMonthPrevious(chrono, prev);\n+                    prev = setDayOfWeek(chrono, prev);\n+                }\n+            }\n+\n+            // Convert from local time to UTC.\n+            return prev - offset;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof OfYear) {\n+                OfYear other = (OfYear)obj;\n+                return\n+                    iMode == other.iMode &&\n+                    iMonthOfYear == other.iMonthOfYear &&\n+                    iDayOfMonth == other.iDayOfMonth &&\n+                    iDayOfWeek == other.iDayOfWeek &&\n+                    iAdvance == other.iAdvance &&\n+                    iMillisOfDay == other.iMillisOfDay;\n+            }\n+            return false;\n+        }\n+\n+        /*\n+        public String toString() {\n+            return\n+                \"[OfYear]\\n\" + \n+                \"Mode: \" + iMode + '\\n' +\n+                \"MonthOfYear: \" + iMonthOfYear + '\\n' +\n+                \"DayOfMonth: \" + iDayOfMonth + '\\n' +\n+                \"DayOfWeek: \" + iDayOfWeek + '\\n' +\n+                \"AdvanceDayOfWeek: \" + iAdvance + '\\n' +\n+                \"MillisOfDay: \" + iMillisOfDay + '\\n';\n+        }\n+        */\n+\n+        public void writeTo(DataOutput out) throws IOException {\n+            out.writeByte(iMode);\n+            out.writeByte(iMonthOfYear);\n+            out.writeByte(iDayOfMonth);\n+            out.writeByte(iDayOfWeek);\n+            out.writeBoolean(iAdvance);\n+            writeMillis(out, iMillisOfDay);\n+        }\n+\n+        /**\n+         * If month-day is 02-29 and year isn't leap, advances to next leap year.\n+         */\n+        private long setDayOfMonthNext(Chronology chrono, long next) {\n+            try {\n+                next = setDayOfMonth(chrono, next);\n+            } catch (IllegalArgumentException e) {\n+                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n+                    while (chrono.year().isLeap(next) == false) {\n+                        next = chrono.year().add(next, 1);\n+                    }\n+                    next = setDayOfMonth(chrono, next);\n+                } else {\n+                    throw e;\n+                }\n+            }\n+            return next;\n+        }\n+\n+        /**\n+         * If month-day is 02-29 and year isn't leap, retreats to previous leap year.\n+         */\n+        private long setDayOfMonthPrevious(Chronology chrono, long prev) {\n+            try {\n+                prev = setDayOfMonth(chrono, prev);\n+            } catch (IllegalArgumentException e) {\n+                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n+                    while (chrono.year().isLeap(prev) == false) {\n+                        prev = chrono.year().add(prev, -1);\n+                    }\n+                    prev = setDayOfMonth(chrono, prev);\n+                } else {\n+                    throw e;\n+                }\n+            }\n+            return prev;\n+        }\n+\n+        private long setDayOfMonth(Chronology chrono, long instant) {\n+            if (iDayOfMonth >= 0) {\n+                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);\n+            } else {\n+                instant = chrono.dayOfMonth().set(instant, 1);\n+                instant = chrono.monthOfYear().add(instant, 1);\n+                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);\n+            }\n+            return instant;\n+        }\n+\n+        private long setDayOfWeek(Chronology chrono, long instant) {\n+            int dayOfWeek = chrono.dayOfWeek().get(instant);\n+            int daysToAdd = iDayOfWeek - dayOfWeek;\n+            if (daysToAdd != 0) {\n+                if (iAdvance) {\n+                    if (daysToAdd < 0) {\n+                        daysToAdd += 7;\n+                    }\n+                } else {\n+                    if (daysToAdd > 0) {\n+                        daysToAdd -= 7;\n+                    }\n+                }\n+                instant = chrono.dayOfWeek().add(instant, daysToAdd);\n+            }\n+            return instant;\n+        }\n+    }\n+\n+    /**\n+     * Extends OfYear with a nameKey and savings.\n+     */\n+    private static final class Recurrence {\n+        static Recurrence readFrom(DataInput in) throws IOException {\n+            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n+        }\n+\n+        final OfYear iOfYear;\n+        final String iNameKey;\n+        final int iSaveMillis;\n+\n+        Recurrence(OfYear ofYear, String nameKey, int saveMillis) {\n+            iOfYear = ofYear;\n+            iNameKey = nameKey;\n+            iSaveMillis = saveMillis;\n+        }\n+\n+        public OfYear getOfYear() {\n+            return iOfYear;\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before next recurrence\n+         */\n+        public long next(long instant, int standardOffset, int saveMillis) {\n+            return iOfYear.next(instant, standardOffset, saveMillis);\n+        }\n+\n+        /**\n+         * @param standardOffset standard offset just before previous recurrence\n+         */\n+        public long previous(long instant, int standardOffset, int saveMillis) {\n+            return iOfYear.previous(instant, standardOffset, saveMillis);\n+        }\n+\n+        public String getNameKey() {\n+            return iNameKey;\n+        }\n+\n+        public int getSaveMillis() {\n+            return iSaveMillis;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof Recurrence) {\n+                Recurrence other = (Recurrence)obj;\n+                return\n+                    iSaveMillis == other.iSaveMillis &&\n+                    iNameKey.equals(other.iNameKey) &&\n+                    iOfYear.equals(other.iOfYear);\n+            }\n+            return false;\n+        }\n+\n+        public void writeTo(DataOutput out) throws IOException {\n+            iOfYear.writeTo(out);\n+            out.writeUTF(iNameKey);\n+            writeMillis(out, iSaveMillis);\n+        }\n+\n+        Recurrence rename(String nameKey) {\n+            return new Recurrence(iOfYear, nameKey, iSaveMillis);\n+        }\n+\n+        Recurrence renameAppend(String appendNameKey) {\n+            return rename((iNameKey + appendNameKey).intern());\n+        }\n+    }\n+\n+    /**\n+     * Extends Recurrence with inclusive year limits.\n+     */\n+    private static final class Rule {\n+        final Recurrence iRecurrence;\n+        final int iFromYear; // inclusive\n+        final int iToYear;   // inclusive\n+\n+        Rule(Recurrence recurrence, int fromYear, int toYear) {\n+            iRecurrence = recurrence;\n+            iFromYear = fromYear;\n+            iToYear = toYear;\n+        }\n+\n+        public int getFromYear() {\n+            return iFromYear;\n+        }\n+\n+        public int getToYear() {\n+            return iToYear;\n+        }\n+\n+        public OfYear getOfYear() {\n+            return iRecurrence.getOfYear();\n+        }\n+\n+        public String getNameKey() {\n+            return iRecurrence.getNameKey();\n+        }\n+\n+        public int getSaveMillis() {\n+            return iRecurrence.getSaveMillis();\n+        }\n+\n+        public long next(final long instant, int standardOffset, int saveMillis) {\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+\n+            final int wallOffset = standardOffset + saveMillis;\n+            long testInstant = instant;\n+\n+            int year;\n+            if (instant == Long.MIN_VALUE) {\n+                year = Integer.MIN_VALUE;\n+            } else {\n+                year = chrono.year().get(instant + wallOffset);\n+            }\n+\n+            if (year < iFromYear) {\n+                // First advance instant to start of from year.\n+                testInstant = chrono.year().set(0, iFromYear) - wallOffset;\n+                // Back off one millisecond to account for next recurrence\n+                // being exactly at the beginning of the year.\n+                testInstant -= 1;\n+            }\n+\n+            long next = iRecurrence.next(testInstant, standardOffset, saveMillis);\n+\n+            if (next > instant) {\n+                year = chrono.year().get(next + wallOffset);\n+                if (year > iToYear) {\n+                    // Out of range, return original value.\n+                    next = instant;\n+                }\n+            }\n+\n+            return next;\n+        }\n+    }\n+\n+    private static final class Transition {\n+        private final long iMillis;\n+        private final String iNameKey;\n+        private final int iWallOffset;\n+        private final int iStandardOffset;\n+\n+        Transition(long millis, Transition tr) {\n+            iMillis = millis;\n+            iNameKey = tr.iNameKey;\n+            iWallOffset = tr.iWallOffset;\n+            iStandardOffset = tr.iStandardOffset;\n+        }\n+\n+        Transition(long millis, Rule rule, int standardOffset) {\n+            iMillis = millis;\n+            iNameKey = rule.getNameKey();\n+            iWallOffset = standardOffset + rule.getSaveMillis();\n+            iStandardOffset = standardOffset;\n+        }\n+\n+        Transition(long millis, String nameKey,\n+                   int wallOffset, int standardOffset) {\n+            iMillis = millis;\n+            iNameKey = nameKey;\n+            iWallOffset = wallOffset;\n+            iStandardOffset = standardOffset;\n+        }\n+\n+        public long getMillis() {\n+            return iMillis;\n+        }\n+\n+        public String getNameKey() {\n+            return iNameKey;\n+        }\n+\n+        public int getWallOffset() {\n+            return iWallOffset;\n+        }\n+\n+        public int getStandardOffset() {\n+            return iStandardOffset;\n+        }\n+\n+        public int getSaveMillis() {\n+            return iWallOffset - iStandardOffset;\n+        }\n+\n+        /**\n+         * There must be a change in the millis, wall offsets or name keys.\n+         */\n+        public boolean isTransitionFrom(Transition other) {\n+            if (other == null) {\n+                return true;\n+            }\n+            return iMillis > other.iMillis &&\n+                (iWallOffset != other.iWallOffset ||\n+                 //iStandardOffset != other.iStandardOffset ||\n+                 !(iNameKey.equals(other.iNameKey)));\n+        }\n+    }\n+\n+    private static final class RuleSet {\n+        private static final int YEAR_LIMIT;\n+\n+        static {\n+            // Don't pre-calculate more than 100 years into the future. Almost\n+            // all zones will stop pre-calculating far sooner anyhow. Either a\n+            // simple DST cycle is detected or the last rule is a fixed\n+            // offset. If a zone has a fixed offset set more than 100 years\n+            // into the future, then it won't be observed.\n+            long now = DateTimeUtils.currentTimeMillis();\n+            YEAR_LIMIT = ISOChronology.getInstanceUTC().year().get(now) + 100;\n+        }\n+\n+        private int iStandardOffset;\n+        private ArrayList<Rule> iRules;\n+\n+        // Optional.\n+        private String iInitialNameKey;\n+        private int iInitialSaveMillis;\n+\n+        // Upper limit is exclusive.\n+        private int iUpperYear;\n+        private OfYear iUpperOfYear;\n+\n+        RuleSet() {\n+            iRules = new ArrayList<Rule>(10);\n+            iUpperYear = Integer.MAX_VALUE;\n+        }\n+\n+        /**\n+         * Copy constructor.\n+         */\n+        RuleSet(RuleSet rs) {\n+            iStandardOffset = rs.iStandardOffset;\n+            iRules = new ArrayList<Rule>(rs.iRules);\n+            iInitialNameKey = rs.iInitialNameKey;\n+            iInitialSaveMillis = rs.iInitialSaveMillis;\n+            iUpperYear = rs.iUpperYear;\n+            iUpperOfYear = rs.iUpperOfYear;\n+        }\n+\n+        public int getStandardOffset() {\n+            return iStandardOffset;\n+        }\n+\n+        public void setStandardOffset(int standardOffset) {\n+            iStandardOffset = standardOffset;\n+        }\n+\n+        public void setFixedSavings(String nameKey, int saveMillis) {\n+            iInitialNameKey = nameKey;\n+            iInitialSaveMillis = saveMillis;\n+        }\n+\n+        public void addRule(Rule rule) {\n+            if (!iRules.contains(rule)) {\n+                iRules.add(rule);\n+            }\n+        }\n+\n+        public void setUpperLimit(int year, OfYear ofYear) {\n+            iUpperYear = year;\n+            iUpperOfYear = ofYear;\n+        }\n+\n+        /**\n+         * Returns a transition at firstMillis with the first name key and\n+         * offsets for this rule set. This method may return null.\n+         *\n+         * @param firstMillis millis of first transition\n+         */\n+        public Transition firstTransition(final long firstMillis) {\n+            if (iInitialNameKey != null) {\n+                // Initial zone info explicitly set, so don't search the rules.\n+                return new Transition(firstMillis, iInitialNameKey,\n+                                      iStandardOffset + iInitialSaveMillis, iStandardOffset);\n+            }\n+\n+            // Make a copy before we destroy the rules.\n+            ArrayList<Rule> copy = new ArrayList<Rule>(iRules);\n+\n+            // Iterate through all the transitions until firstMillis is\n+            // reached. Use the name key and savings for whatever rule reaches\n+            // the limit.\n+\n+            long millis = Long.MIN_VALUE;\n+            int saveMillis = 0;\n+            Transition first = null;\n+\n+            Transition next;\n+            while ((next = nextTransition(millis, saveMillis)) != null) {\n+                millis = next.getMillis();\n+\n+                if (millis == firstMillis) {\n+                    first = new Transition(firstMillis, next);\n+                    break;\n+                }\n+\n+                if (millis > firstMillis) {\n+                    if (first == null) {\n+                        // Find first rule without savings. This way a more\n+                        // accurate nameKey is found even though no rule\n+                        // extends to the RuleSet's lower limit.\n+                        for (Rule rule : copy) {\n+                            if (rule.getSaveMillis() == 0) {\n+                                first = new Transition(firstMillis, rule, iStandardOffset);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    if (first == null) {\n+                        // Found no rule without savings. Create a transition\n+                        // with no savings anyhow, and use the best available\n+                        // name key.\n+                        first = new Transition(firstMillis, next.getNameKey(),\n+                                               iStandardOffset, iStandardOffset);\n+                    }\n+                    break;\n+                }\n+                \n+                // Set first to the best transition found so far, but next\n+                // iteration may find something closer to lower limit.\n+                first = new Transition(firstMillis, next);\n+\n+                saveMillis = next.getSaveMillis();\n+            }\n+\n+            iRules = copy;\n+            return first;\n+        }\n+\n+        /**\n+         * Returns null if RuleSet is exhausted or upper limit reached. Calling\n+         * this method will throw away rules as they each become\n+         * exhausted. Copy the RuleSet before using it to compute transitions.\n+         *\n+         * Returned transition may be a duplicate from previous\n+         * transition. Caller must call isTransitionFrom to filter out\n+         * duplicates.\n+         *\n+         * @param saveMillis savings before next transition\n+         */\n+        public Transition nextTransition(final long instant, final int saveMillis) {\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+\n+            // Find next matching rule.\n+            Rule nextRule = null;\n+            long nextMillis = Long.MAX_VALUE;\n+            \n+            Iterator<Rule> it = iRules.iterator();\n+            while (it.hasNext()) {\n+                Rule rule = it.next();\n+                long next = rule.next(instant, iStandardOffset, saveMillis);\n+                if (next <= instant) {\n+                    it.remove();\n+                    continue;\n+                }\n+                // Even if next is same as previous next, choose the rule\n+                // in order for more recently added rules to override.\n+                if (next <= nextMillis) {\n+                    // Found a better match.\n+                    nextRule = rule;\n+                    nextMillis = next;\n+                }\n+            }\n+            \n+            if (nextRule == null) {\n+                return null;\n+            }\n+            \n+            // Stop precalculating if year reaches some arbitrary limit.\n+            if (chrono.year().get(nextMillis) >= YEAR_LIMIT) {\n+                return null;\n+            }\n+            \n+            // Check if upper limit reached or passed.\n+            if (iUpperYear < Integer.MAX_VALUE) {\n+                long upperMillis =\n+                    iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n+                if (nextMillis >= upperMillis) {\n+                    // At or after upper limit.\n+                    return null;\n+                }\n+            }\n+            \n+            return new Transition(nextMillis, nextRule, iStandardOffset);\n+        }\n+\n+        /**\n+         * @param saveMillis savings before upper limit\n+         */\n+        public long getUpperLimit(int saveMillis) {\n+            if (iUpperYear == Integer.MAX_VALUE) {\n+                return Long.MAX_VALUE;\n+            }\n+            return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n+        }\n+\n+        /**\n+         * Returns null if none can be built.\n+         */\n+        public DSTZone buildTailZone(String id) {\n+            if (iRules.size() == 2) {\n+                Rule startRule = iRules.get(0);\n+                Rule endRule = iRules.get(1);\n+                if (startRule.getToYear() == Integer.MAX_VALUE &&\n+                    endRule.getToYear() == Integer.MAX_VALUE) {\n+\n+                    // With exactly two infinitely recurring rules left, a\n+                    // simple DSTZone can be formed.\n+\n+                    // The order of rules can come in any order, and it doesn't\n+                    // really matter which rule was chosen the 'start' and\n+                    // which is chosen the 'end'. DSTZone works properly either\n+                    // way.\n+                    return new DSTZone(id, iStandardOffset,\n+                                       startRule.iRecurrence, endRule.iRecurrence);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class DSTZone extends DateTimeZone {\n+        private static final long serialVersionUID = 6941492635554961361L;\n+\n+        static DSTZone readFrom(DataInput in, String id) throws IOException {\n+            return new DSTZone(id, (int)readMillis(in), \n+                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n+        }\n+\n+        final int iStandardOffset;\n+        final Recurrence iStartRecurrence;\n+        final Recurrence iEndRecurrence;\n+\n+        DSTZone(String id, int standardOffset,\n+                Recurrence startRecurrence, Recurrence endRecurrence) {\n+            super(id);\n+            iStandardOffset = standardOffset;\n+            iStartRecurrence = startRecurrence;\n+            iEndRecurrence = endRecurrence;\n+        }\n+\n+        public String getNameKey(long instant) {\n+            return findMatchingRecurrence(instant).getNameKey();\n+        }\n+\n+        public int getOffset(long instant) {\n+            return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();\n+        }\n+\n+        public int getStandardOffset(long instant) {\n+            return iStandardOffset;\n+        }\n+\n+        public boolean isFixed() {\n+            return false;\n+        }\n+\n+        public long nextTransition(long instant) {\n+            int standardOffset = iStandardOffset;\n+            Recurrence startRecurrence = iStartRecurrence;\n+            Recurrence endRecurrence = iEndRecurrence;\n+\n+            long start, end;\n+\n+            try {\n+                start = startRecurrence.next\n+                    (instant, standardOffset, endRecurrence.getSaveMillis());\n+                if (instant > 0 && start < 0) {\n+                    // Overflowed.\n+                    start = instant;\n+                }\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                start = instant;\n+            } catch (ArithmeticException e) {\n+                // Overflowed.\n+                start = instant;\n+            }\n+\n+            try {\n+                end = endRecurrence.next\n+                    (instant, standardOffset, startRecurrence.getSaveMillis());\n+                if (instant > 0 && end < 0) {\n+                    // Overflowed.\n+                    end = instant;\n+                }\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                end = instant;\n+            } catch (ArithmeticException e) {\n+                // Overflowed.\n+                end = instant;\n+            }\n+\n+            return (start > end) ? end : start;\n+        }\n+\n+        public long previousTransition(long instant) {\n+            // Increment in order to handle the case where instant is exactly at\n+            // a transition.\n+            instant++;\n+\n+            int standardOffset = iStandardOffset;\n+            Recurrence startRecurrence = iStartRecurrence;\n+            Recurrence endRecurrence = iEndRecurrence;\n+\n+            long start, end;\n+\n+            try {\n+                start = startRecurrence.previous\n+                    (instant, standardOffset, endRecurrence.getSaveMillis());\n+                if (instant < 0 && start > 0) {\n+                    // Overflowed.\n+                    start = instant;\n+                }\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                start = instant;\n+            } catch (ArithmeticException e) {\n+                // Overflowed.\n+                start = instant;\n+            }\n+\n+            try {\n+                end = endRecurrence.previous\n+                    (instant, standardOffset, startRecurrence.getSaveMillis());\n+                if (instant < 0 && end > 0) {\n+                    // Overflowed.\n+                    end = instant;\n+                }\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                end = instant;\n+            } catch (ArithmeticException e) {\n+                // Overflowed.\n+                end = instant;\n+            }\n+\n+            return ((start > end) ? start : end) - 1;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof DSTZone) {\n+                DSTZone other = (DSTZone)obj;\n+                return\n+                    getID().equals(other.getID()) &&\n+                    iStandardOffset == other.iStandardOffset &&\n+                    iStartRecurrence.equals(other.iStartRecurrence) &&\n+                    iEndRecurrence.equals(other.iEndRecurrence);\n+            }\n+            return false;\n+        }\n+\n+        public void writeTo(DataOutput out) throws IOException {\n+            writeMillis(out, iStandardOffset);\n+            iStartRecurrence.writeTo(out);\n+            iEndRecurrence.writeTo(out);\n+        }\n+\n+        private Recurrence findMatchingRecurrence(long instant) {\n+            int standardOffset = iStandardOffset;\n+            Recurrence startRecurrence = iStartRecurrence;\n+            Recurrence endRecurrence = iEndRecurrence;\n+\n+            long start, end;\n+\n+            try {\n+                start = startRecurrence.next\n+                    (instant, standardOffset, endRecurrence.getSaveMillis());\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                start = instant;\n+            } catch (ArithmeticException e) {\n+                // Overflowed.\n+                start = instant;\n+            }\n+\n+            try {\n+                end = endRecurrence.next\n+                    (instant, standardOffset, startRecurrence.getSaveMillis());\n+            } catch (IllegalArgumentException e) {\n+                // Overflowed.\n+                end = instant;\n+            } catch (ArithmeticException e) {\n+                // Overflowed.\n+                end = instant;\n+            }\n+\n+            return (start > end) ? startRecurrence : endRecurrence;\n+        }\n+    }\n+\n+    private static final class PrecalculatedZone extends DateTimeZone {\n+        private static final long serialVersionUID = 7811976468055766265L;\n+\n+        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n+            // Read string pool.\n+            int poolSize = in.readUnsignedShort();\n+            String[] pool = new String[poolSize];\n+            for (int i=0; i<poolSize; i++) {\n+                pool[i] = in.readUTF();\n+            }\n+\n+            int size = in.readInt();\n+            long[] transitions = new long[size];\n+            int[] wallOffsets = new int[size];\n+            int[] standardOffsets = new int[size];\n+            String[] nameKeys = new String[size];\n+            \n+            for (int i=0; i<size; i++) {\n+                transitions[i] = readMillis(in);\n+                wallOffsets[i] = (int)readMillis(in);\n+                standardOffsets[i] = (int)readMillis(in);\n+                try {\n+                    int index;\n+                    if (poolSize < 256) {\n+                        index = in.readUnsignedByte();\n+                    } else {\n+                        index = in.readUnsignedShort();\n+                    }\n+                    nameKeys[i] = pool[index];\n+                } catch (ArrayIndexOutOfBoundsException e) {\n+                    throw new IOException(\"Invalid encoding\");\n+                }\n+            }\n+\n+            DSTZone tailZone = null;\n+            if (in.readBoolean()) {\n+                tailZone = DSTZone.readFrom(in, id);\n+            }\n+\n+            return new PrecalculatedZone\n+                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n+        }\n+\n+        /**\n+         * Factory to create instance from builder.\n+         * \n+         * @param id  the zone id\n+         * @param outputID  true if the zone id should be output\n+         * @param transitions  the list of Transition objects\n+         * @param tailZone  optional zone for getting info beyond precalculated tables\n+         */\n+        static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions,\n+                                        DSTZone tailZone) {\n+            int size = transitions.size();\n+            if (size == 0) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            long[] trans = new long[size];\n+            int[] wallOffsets = new int[size];\n+            int[] standardOffsets = new int[size];\n+            String[] nameKeys = new String[size];\n+\n+            Transition last = null;\n+            for (int i=0; i<size; i++) {\n+                Transition tr = transitions.get(i);\n+\n+                if (!tr.isTransitionFrom(last)) {\n+                    throw new IllegalArgumentException(id);\n+                }\n+\n+                trans[i] = tr.getMillis();\n+                wallOffsets[i] = tr.getWallOffset();\n+                standardOffsets[i] = tr.getStandardOffset();\n+                nameKeys[i] = tr.getNameKey();\n+\n+                last = tr;\n+            }\n+\n+            // Some timezones (Australia) have the same name key for\n+            // summer and winter which messes everything up. Fix it here.\n+            String[] zoneNameData = new String[5];\n+            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n+            for (int j = 0; j < zoneStrings.length; j++) {\n+                String[] set = zoneStrings[j];\n+                if (set != null && set.length == 5 && id.equals(set[0])) {\n+                    zoneNameData = set;\n+                }\n+            }\n+\n+            Chronology chrono = ISOChronology.getInstanceUTC();\n+\n+            for (int i = 0; i < nameKeys.length - 1; i++) {\n+                String curNameKey = nameKeys[i];\n+                String nextNameKey = nameKeys[i + 1];\n+                long curOffset = wallOffsets[i];\n+                long nextOffset = wallOffsets[i + 1];\n+                long curStdOffset = standardOffsets[i];\n+                long nextStdOffset = standardOffsets[i + 1];\n+                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n+                if (curOffset != nextOffset &&\n+                        curStdOffset == nextStdOffset &&\n+                        curNameKey.equals(nextNameKey) &&\n+                        p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 &&\n+                        curNameKey.equals(zoneNameData[2]) &&\n+                        curNameKey.equals(zoneNameData[4])) {\n+                    \n+                    System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n+                    System.out.println(\"     - \" + new DateTime(trans[i], chrono) +\n+                                       \" - \" + new DateTime(trans[i + 1], chrono));\n+                    if (curOffset > nextOffset) {\n+                        nameKeys[i] = (curNameKey + \"-Summer\").intern();\n+                    } else if (curOffset < nextOffset) {\n+                        nameKeys[i + 1] = (nextNameKey + \"-Summer\").intern();\n+                        i++;\n+                    }\n+                }\n+            }\n+\n+            if (tailZone != null) {\n+                if (tailZone.iStartRecurrence.getNameKey()\n+                    .equals(tailZone.iEndRecurrence.getNameKey())) {\n+                    System.out.println(\"Fixing duplicate recurrent name key - \" +\n+                                       tailZone.iStartRecurrence.getNameKey());\n+                    if (tailZone.iStartRecurrence.getSaveMillis() > 0) {\n+                        tailZone = new DSTZone(\n+                            tailZone.getID(),\n+                            tailZone.iStandardOffset,\n+                            tailZone.iStartRecurrence.renameAppend(\"-Summer\"),\n+                            tailZone.iEndRecurrence);\n+                    } else {\n+                        tailZone = new DSTZone(\n+                            tailZone.getID(),\n+                            tailZone.iStandardOffset,\n+                            tailZone.iStartRecurrence,\n+                            tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n+                    }\n+                }\n+            }\n+            \n+            return new PrecalculatedZone\n+                ((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n+        }\n+\n+        // All array fields have the same length.\n+\n+        private final long[] iTransitions;\n+\n+        private final int[] iWallOffsets;\n+        private final int[] iStandardOffsets;\n+        private final String[] iNameKeys;\n+\n+        private final DSTZone iTailZone;\n+\n+        /**\n+         * Constructor used ONLY for valid input, loaded via static methods.\n+         */\n+        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\n+                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)\n+        {\n+            super(id);\n+            iTransitions = transitions;\n+            iWallOffsets = wallOffsets;\n+            iStandardOffsets = standardOffsets;\n+            iNameKeys = nameKeys;\n+            iTailZone = tailZone;\n+        }\n+\n+        public String getNameKey(long instant) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, instant);\n+            if (i >= 0) {\n+                return iNameKeys[i];\n+            }\n+            i = ~i;\n+            if (i < transitions.length) {\n+                if (i > 0) {\n+                    return iNameKeys[i - 1];\n+                }\n+                return \"UTC\";\n+            }\n+            if (iTailZone == null) {\n+                return iNameKeys[i - 1];\n+            }\n+            return iTailZone.getNameKey(instant);\n+        }\n+\n+        public int getOffset(long instant) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, instant);\n+            if (i >= 0) {\n+                return iWallOffsets[i];\n+            }\n+            i = ~i;\n+            if (i < transitions.length) {\n+                if (i > 0) {\n+                    return iWallOffsets[i - 1];\n+                }\n+                return 0;\n+            }\n+            if (iTailZone == null) {\n+                return iWallOffsets[i - 1];\n+            }\n+            return iTailZone.getOffset(instant);\n+        }\n+\n+        public int getStandardOffset(long instant) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, instant);\n+            if (i >= 0) {\n+                return iStandardOffsets[i];\n+            }\n+            i = ~i;\n+            if (i < transitions.length) {\n+                if (i > 0) {\n+                    return iStandardOffsets[i - 1];\n+                }\n+                return 0;\n+            }\n+            if (iTailZone == null) {\n+                return iStandardOffsets[i - 1];\n+            }\n+            return iTailZone.getStandardOffset(instant);\n+        }\n+\n+        public boolean isFixed() {\n+            return false;\n+        }\n+\n+        public long nextTransition(long instant) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, instant);\n+            i = (i >= 0) ? (i + 1) : ~i;\n+            if (i < transitions.length) {\n+                return transitions[i];\n+            }\n+            if (iTailZone == null) {\n+                return instant;\n+            }\n+            long end = transitions[transitions.length - 1];\n+            if (instant < end) {\n+                instant = end;\n+            }\n+            return iTailZone.nextTransition(instant);\n+        }\n+\n+        public long previousTransition(long instant) {\n+            long[] transitions = iTransitions;\n+            int i = Arrays.binarySearch(transitions, instant);\n+            if (i >= 0) {\n+                if (instant > Long.MIN_VALUE) {\n+                    return instant - 1;\n+                }\n+                return instant;\n+            }\n+            i = ~i;\n+            if (i < transitions.length) {\n+                if (i > 0) {\n+                    long prev = transitions[i - 1];\n+                    if (prev > Long.MIN_VALUE) {\n+                        return prev - 1;\n+                    }\n+                }\n+                return instant;\n+            }\n+            if (iTailZone != null) {\n+                long prev = iTailZone.previousTransition(instant);\n+                if (prev < instant) {\n+                    return prev;\n+                }\n+            }\n+            long prev = transitions[i - 1];\n+            if (prev > Long.MIN_VALUE) {\n+                return prev - 1;\n+            }\n+            return instant;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof PrecalculatedZone) {\n+                PrecalculatedZone other = (PrecalculatedZone)obj;\n+                return\n+                    getID().equals(other.getID()) &&\n+                    Arrays.equals(iTransitions, other.iTransitions) &&\n+                    Arrays.equals(iNameKeys, other.iNameKeys) &&\n+                    Arrays.equals(iWallOffsets, other.iWallOffsets) &&\n+                    Arrays.equals(iStandardOffsets, other.iStandardOffsets) &&\n+                    ((iTailZone == null)\n+                     ? (null == other.iTailZone)\n+                     : (iTailZone.equals(other.iTailZone)));\n+            }\n+            return false;\n+        }\n+\n+        public void writeTo(DataOutput out) throws IOException {\n+            int size = iTransitions.length;\n+\n+            // Create unique string pool.\n+            Set<String> poolSet = new HashSet<String>();\n+            for (int i=0; i<size; i++) {\n+                poolSet.add(iNameKeys[i]);\n+            }\n+\n+            int poolSize = poolSet.size();\n+            if (poolSize > 65535) {\n+                throw new UnsupportedOperationException(\"String pool is too large\");\n+            }\n+            String[] pool = new String[poolSize];\n+            Iterator<String> it = poolSet.iterator();\n+            for (int i=0; it.hasNext(); i++) {\n+                pool[i] = it.next();\n+            }\n+\n+            // Write out the pool.\n+            out.writeShort(poolSize);\n+            for (int i=0; i<poolSize; i++) {\n+                out.writeUTF(pool[i]);\n+            }\n+\n+            out.writeInt(size);\n+\n+            for (int i=0; i<size; i++) {\n+                writeMillis(out, iTransitions[i]);\n+                writeMillis(out, iWallOffsets[i]);\n+                writeMillis(out, iStandardOffsets[i]);\n+                \n+                // Find pool index and write it out.\n+                String nameKey = iNameKeys[i];\n+                for (int j=0; j<poolSize; j++) {\n+                    if (pool[j].equals(nameKey)) {\n+                        if (poolSize < 256) {\n+                            out.writeByte(j);\n+                        } else {\n+                            out.writeShort(j);\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            out.writeBoolean(iTailZone != null);\n+            if (iTailZone != null) {\n+                iTailZone.writeTo(out);\n+            }\n+        }\n+\n+        public boolean isCachable() {\n+            if (iTailZone != null) {\n+                return true;\n+            }\n+            long[] transitions = iTransitions;\n+            if (transitions.length <= 1) {\n+                return false;\n+            }\n+\n+            // Add up all the distances between transitions that are less than\n+            // about two years.\n+            double distances = 0;\n+            int count = 0;\n+\n+            for (int i=1; i<transitions.length; i++) {\n+                long diff = transitions[i] - transitions[i - 1];\n+                if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) {\n+                    distances += (double)diff;\n+                    count++;\n+                }\n+            }\n+\n+            if (count > 0) {\n+                double avg = distances / count;\n+                avg /= 24 * 60 * 60 * 1000;\n+                if (avg >= 25) {\n+                    // Only bother caching if average distance between\n+                    // transitions is at least 25 days. Why 25?\n+                    // CachedDateTimeZone is more efficient if the distance\n+                    // between transitions is large. With an average of 25, it\n+                    // will on average perform about 2 tests per cache\n+                    // hit. (49.7 / 25) is approximately 2.\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/DefaultNameProvider.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import java.text.DateFormatSymbols;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.joda.time.DateTimeUtils;\n+\n+/**\n+ * The default name provider acquires localized names from\n+ * {@link DateFormatSymbols java.text.DateFormatSymbols}.\n+ * <p>\n+ * DefaultNameProvider is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class DefaultNameProvider implements NameProvider {\n+    // locale -> (id -> (nameKey -> [shortName, name]))\n+    private HashMap<Locale, Map<String, Map<String, Object>>> iByLocaleCache = createCache();\n+\n+    public DefaultNameProvider() {\n+    }\n+\n+    public String getShortName(Locale locale, String id, String nameKey) {\n+        String[] nameSet = getNameSet(locale, id, nameKey);\n+        return nameSet == null ? null : nameSet[0];\n+    }\n+    \n+    public String getName(Locale locale, String id, String nameKey) {\n+        String[] nameSet = getNameSet(locale, id, nameKey);\n+        return nameSet == null ? null : nameSet[1];\n+    }\n+\n+    private synchronized String[] getNameSet(Locale locale, String id, String nameKey) {\n+        if (locale == null || id == null || nameKey == null) {\n+            return null;\n+        }\n+\n+        Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale);\n+        if (byIdCache == null) {\n+            iByLocaleCache.put(locale, byIdCache = createCache());\n+        }\n+\n+        Map<String, Object> byNameKeyCache = byIdCache.get(id);\n+        if (byNameKeyCache == null) {\n+            byIdCache.put(id, byNameKeyCache = createCache());\n+            String[][] zoneStrings = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();\n+            for (int i=0; i<zoneStrings.length; i++) {\n+                String[] set = zoneStrings[i];\n+                if (set != null && set.length == 5 && id.equals(set[0])) {\n+                    byNameKeyCache.put(set[2], new String[] {set[2], set[1]});\n+                    // need to handle case where summer and winter have the same\n+                    // abbreviation, such as EST in Australia [1716305]\n+                    // we handle this by appending \"-Summer\", cf ZoneInfoCompiler\n+                    if (set[2].equals(set[4])) {\n+                        byNameKeyCache.put(set[4] + \"-Summer\", new String[] {set[4], set[3]});\n+                    } else {\n+                        byNameKeyCache.put(set[4], new String[] {set[4], set[3]});\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return (String[])byNameKeyCache.get(nameKey);\n+    }\n+\n+    private HashMap createCache() {\n+        return new HashMap(7);\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/FixedDateTimeZone.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Basic DateTimeZone implementation that has a fixed name key and offsets.\n+ * <p>\n+ * FixedDateTimeZone is thread-safe and immutable.\n+ * \n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class FixedDateTimeZone extends DateTimeZone {\n+\n+    private static final long serialVersionUID = -3513011772763289092L;\n+\n+    private final String iNameKey;\n+    private final int iWallOffset;\n+    private final int iStandardOffset;\n+\n+    public FixedDateTimeZone(String id, String nameKey,\n+                             int wallOffset, int standardOffset) {\n+        super(id);\n+        iNameKey = nameKey;\n+        iWallOffset = wallOffset;\n+        iStandardOffset = standardOffset;\n+    }\n+\n+    public String getNameKey(long instant) {\n+        return iNameKey;\n+    }\n+\n+    public int getOffset(long instant) {\n+        return iWallOffset;\n+    }\n+\n+    public int getStandardOffset(long instant) {\n+        return iStandardOffset;\n+    }\n+\n+    public int getOffsetFromLocal(long instantLocal) {\n+        return iWallOffset;\n+    }\n+\n+    public boolean isFixed() {\n+        return true;\n+    }\n+\n+    public long nextTransition(long instant) {\n+        return instant;\n+    }\n+\n+    public long previousTransition(long instant) {\n+        return instant;\n+    }\n+\n+    /**\n+     * Override to return the correct timzone instance.\n+     * @since 1.5\n+     */\n+    public java.util.TimeZone toTimeZone() {\n+        String id = getID();\n+        if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n+            // standard format offset [+-]hh:mm\n+            // our ID is without any prefix, so we need to add the GMT back\n+            return java.util.TimeZone.getTimeZone(\"GMT\" + getID());\n+        }\n+        // unusual offset, so setup a SimpleTimeZone as best we can\n+        return new java.util.SimpleTimeZone(iWallOffset, getID());\n+    }\n+\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof FixedDateTimeZone) {\n+            FixedDateTimeZone other = (FixedDateTimeZone)obj;\n+            return\n+                getID().equals(other.getID()) &&\n+                iStandardOffset == other.iStandardOffset &&\n+                iWallOffset == other.iWallOffset;\n+        }\n+        return false;\n+    }\n+\n+    public int hashCode() {\n+        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/NameProvider.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Service provider factory for localized time zone names.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface NameProvider {\n+    /**\n+     * Returns a localized short name, or null if not found.\n+     *\n+     * @param locale locale to use for selecting name set\n+     * @param id time zone id\n+     * @param nameKey time zone name key\n+     */\n+    String getShortName(Locale locale, String id, String nameKey);\n+    \n+    /**\n+     * Returns a localized name, or null if not found.\n+     *\n+     * @param locale locale to use for selecting name set\n+     * @param id time zone id\n+     * @param nameKey time zone name key\n+     */\n+    String getName(Locale locale, String id, String nameKey);\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/Provider.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import java.util.Set;\n+\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Service provider factory for time zones.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public interface Provider {\n+\n+    /**\n+     * Retrieves a DateTimeZone for the given id. All providers must at\n+     * least support id \"UTC\".\n+     *\n+     * @return null if not found\n+     */\n+    DateTimeZone getZone(String id);\n+\n+    /**\n+     * Returns an unmodifiable set of ids. All providers must at least\n+     * support id \"UTC\".\n+     */        \n+    Set<String> getAvailableIDs();\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/UTCProvider.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * Simple time zone provider that supports only UTC.\n+ * <p>\n+ * UTCProvider is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public final class UTCProvider implements Provider {\n+\n+    /**\n+     * Constructor.\n+     */\n+    public UTCProvider() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns {@link DateTimeZone#UTC UTC} for <code>\"UTC\"</code>, null\n+     * otherwise.\n+     */\n+    public DateTimeZone getZone(String id) {\n+        if (\"UTC\".equalsIgnoreCase(id)) {\n+            return DateTimeZone.UTC;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a singleton collection containing only <code>\"UTC\"</code>.\n+     */    \n+    public Set<String> getAvailableIDs() {\n+        return Collections.singleton(\"UTC\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+import java.util.TreeMap;\n+import java.util.Map.Entry;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.LocalDate;\n+import org.joda.time.MutableDateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.LenientChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+/**\n+ * Compiles Olson ZoneInfo database files into binary files for each time zone\n+ * in the database. {@link DateTimeZoneBuilder} is used to construct and encode\n+ * compiled data files. {@link ZoneInfoProvider} loads the encoded files and\n+ * converts them back into {@link DateTimeZone} objects.\n+ * <p>\n+ * Although this tool is similar to zic, the binary formats are not\n+ * compatible. The latest Olson database files may be obtained\n+ * <a href=\"http://www.twinsun.com/tz/tz-link.htm\">here</a>.\n+ * <p>\n+ * ZoneInfoCompiler is mutable and not thread-safe, although the main method\n+ * may be safely invoked by multiple threads.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class ZoneInfoCompiler {\n+    static DateTimeOfYear cStartOfYear;\n+\n+    static Chronology cLenientISO;\n+\n+    /**\n+     * Launches the ZoneInfoCompiler tool.\n+     *\n+     * <pre>\n+     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;\n+     * where possible options include:\n+     *   -src &lt;directory&gt;    Specify where to read source files\n+     *   -dst &lt;directory&gt;    Specify where to write generated files\n+     * </pre>\n+     */\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            printUsage();\n+            return;\n+        }\n+\n+        File inputDir = null;\n+        File outputDir = null;\n+\n+        int i;\n+        for (i=0; i<args.length; i++) {\n+            try {\n+                if (\"-src\".equals(args[i])) {\n+                    inputDir = new File(args[++i]);\n+                } else if (\"-dst\".equals(args[i])) {\n+                    outputDir = new File(args[++i]);\n+                } else if (\"-?\".equals(args[i])) {\n+                    printUsage();\n+                    return;\n+                } else {\n+                    break;\n+                }\n+            } catch (IndexOutOfBoundsException e) {\n+                printUsage();\n+                return;\n+            }\n+        }\n+\n+        if (i >= args.length) {\n+            printUsage();\n+            return;\n+        }\n+\n+        File[] sources = new File[args.length - i];\n+        for (int j=0; i<args.length; i++,j++) {\n+            sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);\n+        }\n+\n+        ZoneInfoCompiler zic = new ZoneInfoCompiler();\n+        zic.compile(outputDir, sources);\n+    }\n+\n+    private static void printUsage() {\n+        System.out.println(\"Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>\");\n+        System.out.println(\"where possible options include:\");\n+        System.out.println(\"  -src <directory>    Specify where to read source files\");\n+        System.out.println(\"  -dst <directory>    Specify where to write generated files\");\n+    }\n+\n+    static DateTimeOfYear getStartOfYear() {\n+        if (cStartOfYear == null) {\n+            cStartOfYear = new DateTimeOfYear();\n+        }\n+        return cStartOfYear;\n+    }\n+\n+    static Chronology getLenientISOChronology() {\n+        if (cLenientISO == null) {\n+            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n+        }\n+        return cLenientISO;\n+    }\n+\n+    /**\n+     * @param zimap maps string ids to DateTimeZone objects.\n+     */\n+    static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {\n+        // Build the string pool.\n+        Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n+        TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n+\n+        short count = 0;\n+        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n+            String id = (String)entry.getKey();\n+            if (!idToIndex.containsKey(id)) {\n+                Short index = Short.valueOf(count);\n+                idToIndex.put(id, index);\n+                indexToId.put(index, id);\n+                if (++count == 0) {\n+                    throw new InternalError(\"Too many time zone ids\");\n+                }\n+            }\n+            id = ((DateTimeZone)entry.getValue()).getID();\n+            if (!idToIndex.containsKey(id)) {\n+                Short index = Short.valueOf(count);\n+                idToIndex.put(id, index);\n+                indexToId.put(index, id);\n+                if (++count == 0) {\n+                    throw new InternalError(\"Too many time zone ids\");\n+                }\n+            }\n+        }\n+\n+        // Write the string pool, ordered by index.\n+        dout.writeShort(indexToId.size());\n+        for (String id : indexToId.values()) {\n+            dout.writeUTF(id);\n+        }\n+\n+        // Write the mappings.\n+        dout.writeShort(zimap.size());\n+        for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n+            String id = entry.getKey();\n+            dout.writeShort(idToIndex.get(id).shortValue());\n+            id = entry.getValue().getID();\n+            dout.writeShort(idToIndex.get(id).shortValue());\n+        }\n+    }\n+\n+    static int parseYear(String str, int def) {\n+        str = str.toLowerCase();\n+        if (str.equals(\"minimum\") || str.equals(\"min\")) {\n+            return Integer.MIN_VALUE;\n+        } else if (str.equals(\"maximum\") || str.equals(\"max\")) {\n+            return Integer.MAX_VALUE;\n+        } else if (str.equals(\"only\")) {\n+            return def;\n+        }\n+        return Integer.parseInt(str);\n+    }\n+\n+    static int parseMonth(String str) {\n+        DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();\n+        return field.get(field.set(0, str, Locale.ENGLISH));\n+    }\n+\n+    static int parseDayOfWeek(String str) {\n+        DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();\n+        return field.get(field.set(0, str, Locale.ENGLISH));\n+    }\n+    \n+    static String parseOptional(String str) {\n+        return (str.equals(\"-\")) ? null : str;\n+    }\n+\n+    static int parseTime(String str) {\n+        DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();\n+        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n+        int pos = 0;\n+        if (str.startsWith(\"-\")) {\n+            pos = 1;\n+        }\n+        int newPos = p.parseInto(mdt, str, pos);\n+        if (newPos == ~pos) {\n+            throw new IllegalArgumentException(str);\n+        }\n+        int millis = (int)mdt.getMillis();\n+        if (pos == 1) {\n+            millis = -millis;\n+        }\n+        return millis;\n+    }\n+\n+    static char parseZoneChar(char c) {\n+        switch (c) {\n+        case 's': case 'S':\n+            // Standard time\n+            return 's';\n+        case 'u': case 'U': case 'g': case 'G': case 'z': case 'Z':\n+            // UTC\n+            return 'u';\n+        case 'w': case 'W': default:\n+            // Wall time\n+            return 'w';\n+        }\n+    }\n+\n+    /**\n+     * @return false if error.\n+     */\n+    static boolean test(String id, DateTimeZone tz) {\n+        if (!id.equals(tz.getID())) {\n+            return true;\n+        }\n+\n+        // Test to ensure that reported transitions are not duplicated.\n+\n+        long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n+        long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n+\n+        int offset = tz.getOffset(millis);\n+        String key = tz.getNameKey(millis);\n+\n+        List<Long> transitions = new ArrayList<Long>();\n+\n+        while (true) {\n+            long next = tz.nextTransition(millis);\n+            if (next == millis || next > end) {\n+                break;\n+            }\n+\n+            millis = next;\n+\n+            int nextOffset = tz.getOffset(millis);\n+            String nextKey = tz.getNameKey(millis);\n+\n+            if (offset == nextOffset\n+                && key.equals(nextKey)) {\n+                System.out.println(\"*d* Error in \" + tz.getID() + \" \"\n+                                   + new DateTime(millis,\n+                                                  ISOChronology.getInstanceUTC()));\n+                return false;\n+            }\n+\n+            if (nextKey == null || (nextKey.length() < 3 && !\"??\".equals(nextKey))) {\n+                System.out.println(\"*s* Error in \" + tz.getID() + \" \"\n+                                   + new DateTime(millis,\n+                                                  ISOChronology.getInstanceUTC())\n+                                   + \", nameKey=\" + nextKey);\n+                return false;\n+            }\n+\n+            transitions.add(Long.valueOf(millis));\n+\n+            offset = nextOffset;\n+            key = nextKey;\n+        }\n+\n+        // Now verify that reverse transitions match up.\n+\n+        millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n+        end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n+\n+        for (int i=transitions.size(); --i>= 0; ) {\n+            long prev = tz.previousTransition(millis);\n+            if (prev == millis || prev < end) {\n+                break;\n+            }\n+\n+            millis = prev;\n+\n+            long trans = transitions.get(i).longValue();\n+            \n+            if (trans - 1 != millis) {\n+                System.out.println(\"*r* Error in \" + tz.getID() + \" \"\n+                                   + new DateTime(millis,\n+                                                  ISOChronology.getInstanceUTC()) + \" != \"\n+                                   + new DateTime(trans - 1,\n+                                                  ISOChronology.getInstanceUTC()));\n+                                   \n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    // Maps names to RuleSets.\n+    private Map<String, RuleSet> iRuleSets;\n+\n+    // List of Zone objects.\n+    private List<Zone> iZones;\n+\n+    // List String pairs to link.\n+    private List<String> iLinks;\n+\n+    public ZoneInfoCompiler() {\n+        iRuleSets = new HashMap<String, RuleSet>();\n+        iZones = new ArrayList<Zone>();\n+        iLinks = new ArrayList<String>();\n+    }\n+\n+    /**\n+     * Returns a map of ids to DateTimeZones.\n+     *\n+     * @param outputDir optional directory to write compiled data files to\n+     * @param sources optional list of source files to parse\n+     */\n+    public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {\n+        if (sources != null) {\n+            for (int i=0; i<sources.length; i++) {\n+                BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n+                parseDataFile(in);\n+                in.close();\n+            }\n+        }\n+\n+        if (outputDir != null) {\n+            if (!outputDir.exists()) {\n+                throw new IOException(\"Destination directory doesn't exist: \" + outputDir);\n+            }\n+            if (!outputDir.isDirectory()) {\n+                throw new IOException(\"Destination is not a directory: \" + outputDir);\n+            }\n+        }\n+\n+        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n+\n+        for (int i=0; i<iZones.size(); i++) {\n+            Zone zone = iZones.get(i);\n+            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n+            zone.addToBuilder(builder, iRuleSets);\n+            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n+            DateTimeZone tz = original;\n+            if (test(tz.getID(), tz)) {\n+                map.put(tz.getID(), tz);\n+                if (outputDir != null) {\n+                    System.out.println(\"Writing \" + tz.getID());\n+                    File file = new File(outputDir, tz.getID());\n+                    if (!file.getParentFile().exists()) {\n+                        file.getParentFile().mkdirs();\n+                    }\n+                    OutputStream out = new FileOutputStream(file);\n+                    builder.writeTo(zone.iName, out);\n+                    out.close();\n+\n+                    // Test if it can be read back.\n+                    InputStream in = new FileInputStream(file);\n+                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());\n+                    in.close();\n+\n+                    if (!original.equals(tz2)) {\n+                        System.out.println(\"*e* Error in \" + tz.getID() +\n+                                           \": Didn't read properly from file\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int pass=0; pass<2; pass++) {\n+            for (int i=0; i<iLinks.size(); i += 2) {\n+                String id = iLinks.get(i);\n+                String alias = iLinks.get(i + 1);\n+                DateTimeZone tz = map.get(id);\n+                if (tz == null) {\n+                    if (pass > 0) {\n+                        System.out.println(\"Cannot find time zone '\" + id +\n+                                           \"' to link alias '\" + alias + \"' to\");\n+                    }\n+                } else {\n+                    map.put(alias, tz);\n+                }\n+            }\n+        }\n+\n+        if (outputDir != null) {\n+            System.out.println(\"Writing ZoneInfoMap\");\n+            File file = new File(outputDir, \"ZoneInfoMap\");\n+            if (!file.getParentFile().exists()) {\n+                file.getParentFile().mkdirs();\n+            }\n+\n+            OutputStream out = new FileOutputStream(file);\n+            DataOutputStream dout = new DataOutputStream(out);\n+            // Sort and filter out any duplicates that match case.\n+            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n+            zimap.putAll(map);\n+            writeZoneInfoMap(dout, zimap);\n+            dout.close();\n+        }\n+\n+        return map;\n+    }\n+\n+    public void parseDataFile(BufferedReader in) throws IOException {\n+        Zone zone = null;\n+        String line;\n+        while ((line = in.readLine()) != null) {\n+            String trimmed = line.trim();\n+            if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {\n+                continue;\n+            }\n+\n+            int index = line.indexOf('#');\n+            if (index >= 0) {\n+                line = line.substring(0, index);\n+            }\n+\n+            //System.out.println(line);\n+\n+            StringTokenizer st = new StringTokenizer(line, \" \\t\");\n+\n+            if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {\n+                if (zone != null) {\n+                    // Zone continuation\n+                    zone.chain(st);\n+                }\n+                continue;\n+            } else {\n+                if (zone != null) {\n+                    iZones.add(zone);\n+                }\n+                zone = null;\n+            }\n+\n+            if (st.hasMoreTokens()) {\n+                String token = st.nextToken();\n+                if (token.equalsIgnoreCase(\"Rule\")) {\n+                    Rule r = new Rule(st);\n+                    RuleSet rs = iRuleSets.get(r.iName);\n+                    if (rs == null) {\n+                        rs = new RuleSet(r);\n+                        iRuleSets.put(r.iName, rs);\n+                    } else {\n+                        rs.addRule(r);\n+                    }\n+                } else if (token.equalsIgnoreCase(\"Zone\")) {\n+                    zone = new Zone(st);\n+                } else if (token.equalsIgnoreCase(\"Link\")) {\n+                    iLinks.add(st.nextToken());\n+                    iLinks.add(st.nextToken());\n+                } else {\n+                    System.out.println(\"Unknown line: \" + line);\n+                }\n+            }\n+        }\n+\n+        if (zone != null) {\n+            iZones.add(zone);\n+        }\n+    }\n+\n+    static class DateTimeOfYear {\n+        public final int iMonthOfYear;\n+        public final int iDayOfMonth;\n+        public final int iDayOfWeek;\n+        public final boolean iAdvanceDayOfWeek;\n+        public final int iMillisOfDay;\n+        public final char iZoneChar;\n+\n+        DateTimeOfYear() {\n+            iMonthOfYear = 1;\n+            iDayOfMonth = 1;\n+            iDayOfWeek = 0;\n+            iAdvanceDayOfWeek = false;\n+            iMillisOfDay = 0;\n+            iZoneChar = 'w';\n+        }\n+\n+        DateTimeOfYear(StringTokenizer st) {\n+            int month = 1;\n+            int day = 1;\n+            int dayOfWeek = 0;\n+            int millis = 0;\n+            boolean advance = false;\n+            char zoneChar = 'w';\n+\n+            if (st.hasMoreTokens()) {\n+                month = parseMonth(st.nextToken());\n+\n+                if (st.hasMoreTokens()) {\n+                    String str = st.nextToken();\n+                    if (str.startsWith(\"last\")) {\n+                        day = -1;\n+                        dayOfWeek = parseDayOfWeek(str.substring(4));\n+                        advance = false;\n+                    } else {\n+                        try {\n+                            day = Integer.parseInt(str);\n+                            dayOfWeek = 0;\n+                            advance = false;\n+                        } catch (NumberFormatException e) {\n+                            int index = str.indexOf(\">=\");\n+                            if (index > 0) {\n+                                day = Integer.parseInt(str.substring(index + 2));\n+                                dayOfWeek = parseDayOfWeek(str.substring(0, index));\n+                                advance = true;\n+                            } else {\n+                                index = str.indexOf(\"<=\");\n+                                if (index > 0) {\n+                                    day = Integer.parseInt(str.substring(index + 2));\n+                                    dayOfWeek = parseDayOfWeek(str.substring(0, index));\n+                                    advance = false;\n+                                } else {\n+                                    throw new IllegalArgumentException(str);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    if (st.hasMoreTokens()) {\n+                        str = st.nextToken();\n+                        zoneChar = parseZoneChar(str.charAt(str.length() - 1));\n+                        if (str.equals(\"24:00\")) {\n+                            LocalDate date = (day == -1 ?\n+                                    new LocalDate(2001, month, 1).plusMonths(1) :\n+                                    new LocalDate(2001, month, day).plusDays(1));\n+                            advance = (day != -1);\n+                            month = date.getMonthOfYear();\n+                            day = date.getDayOfMonth();\n+                            dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;\n+                        } else {\n+                            millis = parseTime(str);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            iMonthOfYear = month;\n+            iDayOfMonth = day;\n+            iDayOfWeek = dayOfWeek;\n+            iAdvanceDayOfWeek = advance;\n+            iMillisOfDay = millis;\n+            iZoneChar = zoneChar;\n+        }\n+\n+        /**\n+         * Adds a recurring savings rule to the builder.\n+         */\n+        public void addRecurring(DateTimeZoneBuilder builder, String nameKey,\n+                                 int saveMillis, int fromYear, int toYear)\n+        {\n+            builder.addRecurringSavings(nameKey, saveMillis,\n+                                        fromYear, toYear,\n+                                        iZoneChar,\n+                                        iMonthOfYear,\n+                                        iDayOfMonth,\n+                                        iDayOfWeek,\n+                                        iAdvanceDayOfWeek,\n+                                        iMillisOfDay);\n+        }\n+\n+        /**\n+         * Adds a cutover to the builder.\n+         */\n+        public void addCutover(DateTimeZoneBuilder builder, int year) {\n+            builder.addCutover(year,\n+                               iZoneChar,\n+                               iMonthOfYear,\n+                               iDayOfMonth,\n+                               iDayOfWeek,\n+                               iAdvanceDayOfWeek,\n+                               iMillisOfDay);\n+        }\n+\n+        public String toString() {\n+            return\n+                \"MonthOfYear: \" + iMonthOfYear + \"\\n\" +\n+                \"DayOfMonth: \" + iDayOfMonth + \"\\n\" +\n+                \"DayOfWeek: \" + iDayOfWeek + \"\\n\" +\n+                \"AdvanceDayOfWeek: \" + iAdvanceDayOfWeek + \"\\n\" +\n+                \"MillisOfDay: \" + iMillisOfDay + \"\\n\" +\n+                \"ZoneChar: \" + iZoneChar + \"\\n\";\n+        }\n+    }\n+\n+    private static class Rule {\n+        public final String iName;\n+        public final int iFromYear;\n+        public final int iToYear;\n+        public final String iType;\n+        public final DateTimeOfYear iDateTimeOfYear;\n+        public final int iSaveMillis;\n+        public final String iLetterS;\n+\n+        Rule(StringTokenizer st) {\n+            iName = st.nextToken().intern();\n+            iFromYear = parseYear(st.nextToken(), 0);\n+            iToYear = parseYear(st.nextToken(), iFromYear);\n+            if (iToYear < iFromYear) {\n+                throw new IllegalArgumentException();\n+            }\n+            iType = parseOptional(st.nextToken());\n+            iDateTimeOfYear = new DateTimeOfYear(st);\n+            iSaveMillis = parseTime(st.nextToken());\n+            iLetterS = parseOptional(st.nextToken());\n+        }\n+\n+        /**\n+         * Adds a recurring savings rule to the builder.\n+         */\n+        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n+            String nameKey = formatName(nameFormat);\n+            iDateTimeOfYear.addRecurring\n+                (builder, nameKey, iSaveMillis, iFromYear, iToYear);\n+        }\n+\n+        private String formatName(String nameFormat) {\n+            int index = nameFormat.indexOf('/');\n+            if (index > 0) {\n+                if (iSaveMillis == 0) {\n+                    // Extract standard name.\n+                    return nameFormat.substring(0, index).intern();\n+                } else {\n+                    return nameFormat.substring(index + 1).intern();\n+                }\n+            }\n+            index = nameFormat.indexOf(\"%s\");\n+            if (index < 0) {\n+                return nameFormat;\n+            }\n+            String left = nameFormat.substring(0, index);\n+            String right = nameFormat.substring(index + 2);\n+            String name;\n+            if (iLetterS == null) {\n+                name = left.concat(right);\n+            } else {\n+                name = left + iLetterS + right;\n+            }\n+            return name.intern();\n+        }\n+\n+        public String toString() {\n+            return\n+                \"[Rule]\\n\" + \n+                \"Name: \" + iName + \"\\n\" +\n+                \"FromYear: \" + iFromYear + \"\\n\" +\n+                \"ToYear: \" + iToYear + \"\\n\" +\n+                \"Type: \" + iType + \"\\n\" +\n+                iDateTimeOfYear +\n+                \"SaveMillis: \" + iSaveMillis + \"\\n\" +\n+                \"LetterS: \" + iLetterS + \"\\n\";\n+        }\n+    }\n+\n+    private static class RuleSet {\n+        private List<Rule> iRules;\n+\n+        RuleSet(Rule rule) {\n+            iRules = new ArrayList<Rule>();\n+            iRules.add(rule);\n+        }\n+\n+        void addRule(Rule rule) {\n+            if (!(rule.iName.equals(iRules.get(0).iName))) {\n+                throw new IllegalArgumentException(\"Rule name mismatch\");\n+            }\n+            iRules.add(rule);\n+        }\n+\n+        /**\n+         * Adds recurring savings rules to the builder.\n+         */\n+        public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n+            for (int i=0; i<iRules.size(); i++) {\n+                Rule rule = iRules.get(i);\n+                rule.addRecurring(builder, nameFormat);\n+            }\n+        }\n+    }\n+\n+    private static class Zone {\n+        public final String iName;\n+        public final int iOffsetMillis;\n+        public final String iRules;\n+        public final String iFormat;\n+        public final int iUntilYear;\n+        public final DateTimeOfYear iUntilDateTimeOfYear;\n+\n+        private Zone iNext;\n+\n+        Zone(StringTokenizer st) {\n+            this(st.nextToken(), st);\n+        }\n+\n+        private Zone(String name, StringTokenizer st) {\n+            iName = name.intern();\n+            iOffsetMillis = parseTime(st.nextToken());\n+            iRules = parseOptional(st.nextToken());\n+            iFormat = st.nextToken().intern();\n+\n+            int year = Integer.MAX_VALUE;\n+            DateTimeOfYear dtOfYear = getStartOfYear();\n+\n+            if (st.hasMoreTokens()) {\n+                year = Integer.parseInt(st.nextToken());\n+                if (st.hasMoreTokens()) {\n+                    dtOfYear = new DateTimeOfYear(st);\n+                }\n+            }\n+\n+            iUntilYear = year;\n+            iUntilDateTimeOfYear = dtOfYear;\n+        }\n+\n+        void chain(StringTokenizer st) {\n+            if (iNext != null) {\n+                iNext.chain(st);\n+            } else {\n+                iNext = new Zone(iName, st);\n+            }\n+        }\n+\n+        /*\n+        public DateTimeZone buildDateTimeZone(Map ruleSets) {\n+            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n+            addToBuilder(builder, ruleSets);\n+            return builder.toDateTimeZone(iName);\n+        }\n+        */\n+\n+        /**\n+         * Adds zone info to the builder.\n+         */\n+        public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n+            addToBuilder(this, builder, ruleSets);\n+        }\n+\n+        private static void addToBuilder(Zone zone,\n+                                         DateTimeZoneBuilder builder,\n+                                         Map<String, RuleSet> ruleSets)\n+        {\n+            for (; zone != null; zone = zone.iNext) {\n+                builder.setStandardOffset(zone.iOffsetMillis);\n+\n+                if (zone.iRules == null) {\n+                    builder.setFixedSavings(zone.iFormat, 0);\n+                } else {\n+                    try {\n+                        // Check if iRules actually just refers to a savings.\n+                        int saveMillis = parseTime(zone.iRules);\n+                        builder.setFixedSavings(zone.iFormat, saveMillis);\n+                    }\n+                    catch (Exception e) {\n+                        RuleSet rs = ruleSets.get(zone.iRules);\n+                        if (rs == null) {\n+                            throw new IllegalArgumentException\n+                                (\"Rules not found: \" + zone.iRules);\n+                        }\n+                        rs.addRecurring(builder, zone.iFormat);\n+                    }\n+                }\n+\n+                if (zone.iUntilYear == Integer.MAX_VALUE) {\n+                    break;\n+                }\n+\n+                zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);\n+            }\n+        }\n+\n+        public String toString() {\n+            String str =\n+                \"[Zone]\\n\" + \n+                \"Name: \" + iName + \"\\n\" +\n+                \"OffsetMillis: \" + iOffsetMillis + \"\\n\" +\n+                \"Rules: \" + iRules + \"\\n\" +\n+                \"Format: \" + iFormat + \"\\n\" +\n+                \"UntilYear: \" + iUntilYear + \"\\n\" +\n+                iUntilDateTimeOfYear;\n+\n+            if (iNext == null) {\n+                return str;\n+            }\n+\n+            return str + \"...\\n\" + iNext.toString();\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/JodaTime/src/main/java/org/joda/time/tz/ZoneInfoProvider.java\n+/*\n+ *  Copyright 2001-2009 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.tz;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.ref.SoftReference;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * ZoneInfoProvider loads compiled data files as generated by\n+ * {@link ZoneInfoCompiler}.\n+ * <p>\n+ * ZoneInfoProvider is thread-safe and publicly immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+public class ZoneInfoProvider implements Provider {\n+\n+    /** The directory where the files are held. */\n+    private final File iFileDir;\n+    /** The resource path. */\n+    private final String iResourcePath;\n+    /** The class loader to use. */\n+    private final ClassLoader iLoader;\n+    /** Maps ids to strings or SoftReferences to DateTimeZones. */\n+    private final Map<String, Object> iZoneInfoMap;\n+\n+    /**\n+     * ZoneInfoProvider searches the given directory for compiled data files.\n+     *\n+     * @throws IOException if directory or map file cannot be read\n+     */\n+    public ZoneInfoProvider(File fileDir) throws IOException {\n+        if (fileDir == null) {\n+            throw new IllegalArgumentException(\"No file directory provided\");\n+        }\n+        if (!fileDir.exists()) {\n+            throw new IOException(\"File directory doesn't exist: \" + fileDir);\n+        }\n+        if (!fileDir.isDirectory()) {\n+            throw new IOException(\"File doesn't refer to a directory: \" + fileDir);\n+        }\n+\n+        iFileDir = fileDir;\n+        iResourcePath = null;\n+        iLoader = null;\n+\n+        iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n+    }\n+\n+    /**\n+     * ZoneInfoProvider searches the given ClassLoader resource path for\n+     * compiled data files. Resources are loaded from the ClassLoader that\n+     * loaded this class.\n+     *\n+     * @throws IOException if directory or map file cannot be read\n+     */\n+    public ZoneInfoProvider(String resourcePath) throws IOException {\n+        this(resourcePath, null, false);\n+    }\n+\n+    /**\n+     * ZoneInfoProvider searches the given ClassLoader resource path for\n+     * compiled data files.\n+     *\n+     * @param loader ClassLoader to load compiled data files from. If null,\n+     * use system ClassLoader.\n+     * @throws IOException if directory or map file cannot be read\n+     */\n+    public ZoneInfoProvider(String resourcePath, ClassLoader loader)\n+        throws IOException\n+    {\n+        this(resourcePath, loader, true);\n+    }\n+\n+    /**\n+     * @param favorSystemLoader when true, use the system class loader if\n+     * loader null. When false, use the current class loader if loader is null.\n+     */\n+    private ZoneInfoProvider(String resourcePath,\n+                             ClassLoader loader, boolean favorSystemLoader) \n+        throws IOException\n+    {\n+        if (resourcePath == null) {\n+            throw new IllegalArgumentException(\"No resource path provided\");\n+        }\n+        if (!resourcePath.endsWith(\"/\")) {\n+            resourcePath += '/';\n+        }\n+\n+        iFileDir = null;\n+        iResourcePath = resourcePath;\n+\n+        if (loader == null && !favorSystemLoader) {\n+            loader = getClass().getClassLoader();\n+        }\n+\n+        iLoader = loader;\n+\n+        iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * If an error is thrown while loading zone data, uncaughtException is\n+     * called to log the error and null is returned for this and all future\n+     * requests.\n+     * \n+     * @param id  the id to load\n+     * @return the loaded zone\n+     */\n+    public synchronized DateTimeZone getZone(String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        Object obj = iZoneInfoMap.get(id);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        if (id.equals(obj)) {\n+            // Load zone data for the first time.\n+            return loadZoneData(id);\n+        }\n+\n+        if (obj instanceof SoftReference<?>) {\n+            @SuppressWarnings(\"unchecked\")\n+            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n+            DateTimeZone tz = ref.get();\n+            if (tz != null) {\n+                return tz;\n+            }\n+            // Reference cleared; load data again.\n+            return loadZoneData(id);\n+        }\n+\n+        // If this point is reached, mapping must link to another.\n+        return getZone((String)obj);\n+    }\n+\n+    /**\n+     * Gets a list of all the available zone ids.\n+     * \n+     * @return the zone ids\n+     */\n+    public synchronized Set<String> getAvailableIDs() {\n+        // Return a copy of the keys rather than an umodifiable collection.\n+        // This prevents ConcurrentModificationExceptions from being thrown by\n+        // some JVMs if zones are opened while this set is iterated over.\n+        return new TreeSet<String>(iZoneInfoMap.keySet());\n+    }\n+\n+    /**\n+     * Called if an exception is thrown from getZone while loading zone data.\n+     * \n+     * @param ex  the exception\n+     */\n+    protected void uncaughtException(Exception ex) {\n+        Thread t = Thread.currentThread();\n+        t.getThreadGroup().uncaughtException(t, ex);\n+    }\n+\n+    /**\n+     * Opens a resource from file or classpath.\n+     * \n+     * @param name  the name to open\n+     * @return the input stream\n+     * @throws IOException if an error occurs\n+     */\n+    private InputStream openResource(String name) throws IOException {\n+        InputStream in;\n+        if (iFileDir != null) {\n+            in = new FileInputStream(new File(iFileDir, name));\n+        } else {\n+            String path = iResourcePath.concat(name);\n+            if (iLoader != null) {\n+                in = iLoader.getResourceAsStream(path);\n+            } else {\n+                in = ClassLoader.getSystemResourceAsStream(path);\n+            }\n+            if (in == null) {\n+                StringBuffer buf = new StringBuffer(40)\n+                    .append(\"Resource not found: \\\"\")\n+                    .append(path)\n+                    .append(\"\\\" ClassLoader: \")\n+                    .append(iLoader != null ? iLoader.toString() : \"system\");\n+                throw new IOException(buf.toString());\n+            }\n+        }\n+        return in;\n+    }\n+\n+    /**\n+     * Loads the time zone data for one id.\n+     * \n+     * @param id  the id to load\n+     * @return the zone\n+     */\n+    private DateTimeZone loadZoneData(String id) {\n+        InputStream in = null;\n+        try {\n+            in = openResource(id);\n+            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n+            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n+            return tz;\n+        } catch (IOException e) {\n+            uncaughtException(e);\n+            iZoneInfoMap.remove(id);\n+            return null;\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Loads the zone info map.\n+     * \n+     * @param in  the input stream\n+     * @return the map\n+     */\n+    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n+        Map<String, Object> map = new TreeMap<String, Object>(String.CASE_INSENSITIVE_ORDER);\n+        DataInputStream din = new DataInputStream(in);\n+        try {\n+            readZoneInfoMap(din, map);\n+        } finally {\n+            try {\n+                din.close();\n+            } catch (IOException e) {\n+            }\n+        }\n+        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n+        return map;\n+    }\n+\n+    /**\n+     * Reads the zone info map from file.\n+     * \n+     * @param din  the input stream\n+     * @param zimap  gets filled with string id to string id mappings\n+     */\n+    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n+        // Read the string pool.\n+        int size = din.readUnsignedShort();\n+        String[] pool = new String[size];\n+        for (int i=0; i<size; i++) {\n+            pool[i] = din.readUTF().intern();\n+        }\n+\n+        // Read the mappings.\n+        size = din.readUnsignedShort();\n+        for (int i=0; i<size; i++) {\n+            try {\n+                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IOException(\"Corrupt zone info map\");\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1281313027, "metainfo": ""}