{"sha": "ccddaff1a7295a4cb39f77589d781e760fd3b382", "log": "Remove BoundPrinter code   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java\n  */\n public abstract class BaseDateTimeFormatter {\n \n-    public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n-        return (BoundDateTimePrinter) this;\n-    }\n-\n-    //-----------------------------------------------------------------------\n     public void printTo(StringBuffer buf, ReadableInstant instant) {\n         long millis = DateTimeUtils.getInstantMillis(instant);\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n             mPrinter = printer;\n         }\n \n-        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n-            return mPrinter.bindPrinter(chrono);\n-        }\n-\n         public void printTo(StringBuffer buf, ReadableInstant instant) {\n             mPrinter.printTo(buf, instant);\n         }\n             mParser = parser;\n         }\n \n-        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n-            throw unsupported();\n-        }\n-\n         public void printTo(StringBuffer buf, ReadableInstant instant) {\n             throw unsupported();\n         }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n-import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.MillisDurationField;\n     //-----------------------------------------------------------------------\n     static class CharacterLiteral\n             extends BaseDateTimeFormatter\n-            implements DateTimeFormatter, BoundDateTimePrinter {\n+            implements DateTimeFormatter {\n \n         private final char iValue;\n \n     //-----------------------------------------------------------------------\n     static class StringLiteral\n             extends BaseDateTimeFormatter\n-            implements DateTimeFormatter, BoundDateTimePrinter {\n+            implements DateTimeFormatter {\n \n         private final String iValue;\n \n             super(fieldType, maxParsedDigits, signed);\n         }\n \n-        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n-            chrono = DateTimeUtils.getChronology(chrono);\n-            DateTimeField field = iFieldType.getField(chrono.withUTC());\n-            return new BoundUnpaddedNumber(field, iMaxParsedDigits, iSigned);\n-        }\n-\n         protected int estimatePrintedLength() {\n             return iMaxParsedDigits;\n         }\n     }\n \n     //-----------------------------------------------------------------------\n-    static class BoundUnpaddedNumber\n-            extends UnpaddedNumber\n-            implements BoundDateTimePrinter {\n-\n-        private final DateTimeField iField;\n-\n-        BoundUnpaddedNumber(DateTimeField field, int maxParsedDigits, boolean signed) {\n-            super(field.getType(), maxParsedDigits, signed);\n-            iField = field;\n-        }\n-\n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n-            try {\n-                FormatUtils.appendUnpaddedInteger(buf, iField.get(instantLocal));\n-            } catch (RuntimeException e) {\n-                buf.append('\\ufffd');\n-            }\n-        }\n-\n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n-            try {\n-                FormatUtils.writeUnpaddedInteger(out, iField.get(instantLocal));\n-            } catch (RuntimeException e) {\n-                out.write('\\ufffd');\n-            }\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n     static class PaddedNumber extends NumberFormatter {\n \n         protected final int iMinPrintedDigits;\n         {\n             super(fieldType, maxParsedDigits, signed);\n             iMinPrintedDigits = minPrintedDigits;\n-        }\n-\n-        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n-            chrono = DateTimeUtils.getChronology(chrono);\n-            DateTimeField field = iFieldType.getField(chrono.withUTC());\n-            return new BoundPaddedNumber(field, iMaxParsedDigits, iSigned, iMinPrintedDigits);\n         }\n \n         protected int estimatePrintedLength() {\n     }\n \n     //-----------------------------------------------------------------------\n-    static class BoundPaddedNumber\n-            extends PaddedNumber\n-            implements BoundDateTimePrinter {\n-\n-        private final DateTimeField iField;\n-\n-        BoundPaddedNumber(DateTimeField field, int maxParsedDigits,\n-                          boolean signed, int minPrintedDigits)\n-        {\n-            super(field.getType(), maxParsedDigits, signed, minPrintedDigits);\n-            iField = field;\n-        }\n-\n-        protected void printTo(StringBuffer buf,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) {\n-            try {\n-                FormatUtils.appendPaddedInteger(buf, iField.get(instantLocal), iMinPrintedDigits);\n-            } catch (RuntimeException e) {\n-                appendUnknownString(buf, iMinPrintedDigits);\n-            }\n-        }\n-\n-        protected void printTo(Writer out,\n-                               long instantLocal, Chronology chronoLocal,\n-                               long instant, Chronology chrono) throws IOException {\n-            try {\n-                FormatUtils.writePaddedInteger(out, iField.get(instantLocal), iMinPrintedDigits);\n-            } catch (RuntimeException e) {\n-                printUnknownString(out, iMinPrintedDigits);\n-            }\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n     static class TwoDigitYear\n             extends BaseDateTimeFormatter\n-            implements DateTimeFormatter, BoundDateTimePrinter {\n+            implements DateTimeFormatter {\n \n         private final int iPivot;\n \n     //-----------------------------------------------------------------------\n     static class TextField\n             extends BaseDateTimeFormatter\n-            implements DateTimeFormatter, BoundDateTimePrinter {\n+            implements DateTimeFormatter {\n \n         private final DateTimeFieldType iFieldType;\n         private final Locale iLocale;\n             }\n             iMinDigits = minDigits;\n             iMaxDigits = maxDigits;\n-        }\n-\n-        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n-            chrono = DateTimeUtils.getChronology(chrono);\n-            DateTimeField field = iFieldType.getField(chrono.withUTC());\n-            return new BoundFraction(field, iMinDigits, iMaxDigits);\n         }\n \n         protected int estimatePrintedLength() {\n     }\n \n     //-----------------------------------------------------------------------\n-    static class BoundFraction\n-            extends Fraction\n-            implements BoundDateTimePrinter {\n-\n-        private final DateTimeField iField;\n-        private final long iScalar;\n-        private final long iRangeMillis;\n-\n-        BoundFraction(DateTimeField field, int minDigits, int maxDigits) {\n-            super(field.getType(), minDigits, maxDigits);\n-            iField = field;\n-            iMinDigits = minDigits;\n-            \n-            long rangeMillis = field.getDurationField().getUnitMillis();\n-            long scalar;\n-            while (true) {\n-                switch (maxDigits) {  // know this is 18 or less\n-                default: scalar = 1L; break;\n-                case 1:  scalar = 10L; break;\n-                case 2:  scalar = 100L; break;\n-                case 3:  scalar = 1000L; break;\n-                case 4:  scalar = 10000L; break;\n-                case 5:  scalar = 100000L; break;\n-                case 6:  scalar = 1000000L; break;\n-                case 7:  scalar = 10000000L; break;\n-                case 8:  scalar = 100000000L; break;\n-                case 9:  scalar = 1000000000L; break;\n-                case 10: scalar = 10000000000L; break;\n-                case 11: scalar = 100000000000L; break;\n-                case 12: scalar = 1000000000000L; break;\n-                case 13: scalar = 10000000000000L; break;\n-                case 14: scalar = 100000000000000L; break;\n-                case 15: scalar = 1000000000000000L; break;\n-                case 16: scalar = 10000000000000000L; break;\n-                case 17: scalar = 100000000000000000L; break;\n-                case 18: scalar = 1000000000000000000L; break;\n-                }\n-                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n-                    break;\n-                }\n-                // Overflowed: scale down.\n-                maxDigits--;\n-            }\n-            iMaxDigits = maxDigits;\n-            iScalar = scalar;\n-            iRangeMillis = rangeMillis;\n-        }\n-\n-        protected void printTo(StringBuffer buf, Writer out, long instantLocal, Chronology chronoLocal)\n-            throws IOException\n-        {\n-            DateTimeField field = iField;\n-            int minDigits = iMinDigits;\n-\n-            long fraction;\n-            try {\n-                fraction = field.remainder(instantLocal);\n-            } catch (RuntimeException e) {\n-                if (buf != null) {\n-                    appendUnknownString(buf, minDigits);\n-                } else {\n-                    printUnknownString(out, minDigits);\n-                }\n-                return;\n-            }\n-\n-            if (fraction == 0) {\n-                if (buf != null) {\n-                    while (--minDigits >= 0) {\n-                        buf.append('0');\n-                    }\n-                } else {\n-                    while (--minDigits >= 0) {\n-                        out.write('0');\n-                    }\n-                }\n-                return;\n-            }\n-\n-            String str;\n-            long scaled = fraction * iScalar / iRangeMillis;\n-            int maxDigits = iMaxDigits;\n-            \n-            if ((scaled & 0x7fffffff) == scaled) {\n-                str = Integer.toString((int) scaled);\n-            } else {\n-                str = Long.toString(scaled);\n-            }\n-\n-            int length = str.length();\n-            int digits = maxDigits;\n-            while (length < digits) {\n-                if (buf != null) {\n-                    buf.append('0');\n-                } else {\n-                    out.write('0');\n-                }\n-                minDigits--;\n-                digits--;\n-            }\n-\n-            if (minDigits < digits) {\n-                // Chop off as many trailing zero digits as necessary.\n-                while (minDigits < digits) {\n-                    if (length <= 1 || str.charAt(length - 1) != '0') {\n-                        break;\n-                    }\n-                    digits--;\n-                    length--;\n-                }\n-                if (length < str.length()) {\n-                    if (buf != null) {\n-                        for (int i=0; i<length; i++) {\n-                            buf.append(str.charAt(i));\n-                        }\n-                    } else {\n-                        for (int i=0; i<length; i++) {\n-                            out.write(str.charAt(i));\n-                        }\n-                    }\n-                    return;\n-                }\n-            }\n-\n-            if (buf != null) {\n-                buf.append(str);\n-            } else {\n-                out.write(str);\n-            }\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n     static class TimeZoneOffsetFormatter\n             extends BaseDateTimeFormatter\n-            implements DateTimeFormatter, BoundDateTimePrinter {\n+            implements DateTimeFormatter {\n \n         private final String iZeroOffsetText;\n         private final boolean iShowSeparators;\n     //-----------------------------------------------------------------------\n     static class TimeZonePrinter\n             extends BaseDateTimeFormatter\n-            implements DateTimePrinter, BoundDateTimePrinter {\n+            implements DateTimePrinter {\n \n         private final Locale iLocale;\n         private final boolean iShortFormat;\n     //-----------------------------------------------------------------------\n     static class Composite\n             extends BaseDateTimeFormatter\n-            implements DateTimeFormatter, BoundDateTimePrinter {\n+            implements DateTimeFormatter {\n \n         private final BaseDateTimeFormatter[] iPrinters;\n         private final BaseDateTimeFormatter[] iParsers;\n             iParsedLengthEstimate = base.iParsedLengthEstimate;\n         }\n \n-        public BoundDateTimePrinter bindPrinter(Chronology chrono) {\n-            BaseDateTimeFormatter[] elements = iPrinters;\n-            if (elements == null) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            int len = elements.length;\n-            BaseDateTimeFormatter[] array = new BaseDateTimeFormatter[len];\n-            for (int i = 0; i < len; i++) {\n-                BoundDateTimePrinter bound = ((DateTimePrinter) elements[i]).bindPrinter(chrono);\n-                array[i] = (BaseDateTimeFormatter) bound;\n-            }\n-            return new Composite(this, array);\n-        }\n-\n         protected int estimatePrintedLength() {\n             return iPrintedLengthEstimate;\n         }\n-    \n+\n         protected void printTo(StringBuffer buf,\n                                long instantLocal, Chronology chronoLocal,\n                                long instant, Chronology chrono) {\n--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java\n public interface DateTimePrinter {\n \n     /**\n-     * Returns another printer instance that can only be used with the specified chronology.\n-     * <p>\n-     * The normal DateTimePrinter is a fast implementation of printing dates\n-     * and times, well over twice as fast as the JDK. However, it is possible to\n-     * go even faster by specifying in advance the chronology to use. Note that\n-     * this optimisation should be rarely used, and only when you have identified a\n-     * performance problem.\n-     * <p>\n-     * You should only use this method if you are going to use the printer for the\n-     * returned chronology multiple times, typically storing it in an instance or\n-     * static variable. You should not use this method if you will only use the\n-     * printer once or a few times, as the setup cost will cause performance to be\n-     * worse than using an ordinary printer.\n-     * <p>\n-     * It is the callers resposibility to ensure that the printer is then only\n-     * used with instances of the correct chronology.\n-     * \n-     * @param chrono  the chronology to use, null means ISO\n-     * @return the chronology specific printer\n-     */\n-    BoundDateTimePrinter bindPrinter(Chronology chrono);\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Prints a ReadableInstant, using the chronology supplied by the instant.\n      *\n      * @param buf  formatted instant is appended to this buffer", "timestamp": 1099612402, "metainfo": ""}