{"sha": "f31d0996d5eefb8c5384795b8c9f1f6a4149f219", "log": "Added time zone table.   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/example/org/joda/example/time/TimeZoneTable.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.example.time;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.joda.time.*;\n+import org.joda.time.format.*;\n+\n+/**\n+ * Prints out all available time zones to standard out in an HTML table.\n+ *\n+ * @author Brian S O'Neill\n+ */\n+public class TimeZoneTable {\n+    static final long cNow = System.currentTimeMillis();\n+\n+    static final DateTimeFormatter cOffsetFormatter = new DateTimeFormatterBuilder()\n+        .appendTimeZoneOffset(null, true, 2, 4)\n+        .toFormatter();\n+\n+    public static void main(String[] args) throws Exception {\n+        Set idSet = DateTimeZone.getAvailableIDs();\n+        ZoneData[] zones = new ZoneData[idSet.size()];\n+        \n+        {\n+            Iterator it = idSet.iterator();\n+            int i = 0;\n+            while (it.hasNext()) {\n+                String id = (String) it.next();\n+                zones[i++] = new ZoneData(id, DateTimeZone.getInstance(id));\n+            }\n+            Arrays.sort(zones);\n+        }\n+\n+        PrintStream out = System.out;\n+\n+        out.println(\"<table>\");\n+\n+        out.println(\"<tr>\" +\n+                    \"<th align=\\\"left\\\">Standard Offset</th>\" +\n+                    \"<th align=\\\"left\\\">Canonical ID</th>\" +\n+                    \"<th align=\\\"left\\\">Aliases</th>\" +\n+                    \"</tr>\");\n+\n+        ZoneData canonical = null;\n+        List aliases = new ArrayList();\n+\n+        for (int i=0; i<zones.length; i++) {\n+            ZoneData zone = zones[i];\n+\n+            if (!zone.isCanonical()) {\n+                aliases.add(zone);\n+                continue;\n+            }\n+\n+            if (canonical != null) {\n+                printRow(out, canonical, aliases);\n+            }\n+\n+            canonical = zone;\n+            aliases.clear();\n+        }\n+\n+        if (canonical != null) {\n+            printRow(out, canonical, aliases);\n+        }\n+\n+        out.println(\"</table>\");\n+    }\n+\n+    private static void printRow(PrintStream out, ZoneData zone, List aliases) {\n+        out.print(\"<tr>\");\n+                \n+        out.print(\"<td align=\\\"left\\\" valign=\\\"top\\\">\");\n+        out.print(zone.getStandardOffsetStr());\n+        out.print(\"</td>\");\n+        \n+        out.print(\"<td align=\\\"left\\\" valign=\\\"top\\\">\");\n+        out.print(zone.getCanonicalID());\n+        out.print(\"</td>\");\n+        \n+        out.print(\"<td align=\\\"left\\\" valign=\\\"top\\\">\");\n+        if (aliases.size() > 0) {\n+            for (int j=0; j<aliases.size(); j++) {\n+                if (j > 0) {\n+                    out.print(\", \");\n+                }\n+                out.print(((ZoneData) aliases.get(j)).getID());\n+            }\n+        }\n+        out.print(\"</td>\");\n+        \n+        out.println(\"</tr>\");\n+    }\n+\n+    private static class ZoneData implements Comparable {\n+        private final String iID;\n+        private final DateTimeZone iZone;\n+        \n+        ZoneData(String id, DateTimeZone zone) {\n+            iID = id;\n+            iZone = zone;\n+        }\n+\n+        public String getID() {\n+            return iID;\n+        }\n+\n+        public String getCanonicalID() {\n+            return iZone.getID();\n+        }\n+\n+        public boolean isCanonical() {\n+            return getID().equals(getCanonicalID());\n+        }\n+\n+        public String getStandardOffsetStr() {\n+            long millis = cNow;\n+            while (iZone.getOffset(millis) != iZone.getStandardOffset(millis)) {\n+                millis = iZone.nextTransition(millis);\n+            }\n+            return cOffsetFormatter.print(millis, iZone);\n+        }\n+\n+        public int compareTo(Object obj) {\n+            ZoneData other = (ZoneData) obj;\n+\n+            int offsetA = iZone.getStandardOffset(cNow);\n+            int offsetB = other.iZone.getStandardOffset(cNow);\n+\n+            if (offsetA < offsetB) {\n+                return -1;\n+            }\n+            if (offsetA > offsetB) {\n+                return 1;\n+            }\n+\n+            int result = getCanonicalID().compareTo(other.getCanonicalID());\n+\n+            if (result != 0) {\n+                return result;\n+            }\n+\n+            if (isCanonical()) {\n+                if (!other.isCanonical()) {\n+                    return -1;\n+                }\n+            } else if (other.isCanonical()) {\n+                return 1;\n+            }\n+\n+            return getID().compareTo(other.getID());\n+        }\n+    }\n+}", "timestamp": 1102811693, "metainfo": ""}