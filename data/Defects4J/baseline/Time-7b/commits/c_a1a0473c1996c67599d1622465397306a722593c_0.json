{"sha": "a1a0473c1996c67599d1622465397306a722593c", "log": "Create BaseDuration   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Duration.java\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n \n import java.io.Serializable;\n \n-import org.joda.time.base.*;\n-import org.joda.time.convert.ConverterManager;\n-import org.joda.time.convert.DurationConverter;\n+import org.joda.time.base.BaseDuration;\n import org.joda.time.field.FieldUtils;\n \n /**\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public class Duration\n-        extends AbstractDuration\n+public final class Duration\n+        extends BaseDuration\n         implements ReadableDuration, Serializable {\n \n     /** Constant representing zero millisecond duration */\n     /** Serialization version */\n     private static final long serialVersionUID = 2471658376918L;\n \n-    /** The duration length */\n-    private final long iMillis;\n-\n     /**\n      * Creates a duration from the given millisecond duration.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     public Duration(long duration) {\n-        super();\n-        iMillis = duration;\n+        super(duration);\n     }\n \n     /**\n      * @throws ArithmeticException if the duration exceeds a 64 bit long\n      */\n     public Duration(long startInstant, long endInstant) {\n-        super();\n-        iMillis = FieldUtils.safeAdd(endInstant, -startInstant);\n+        super(startInstant, endInstant);\n     }\n \n     /**\n      * @throws ArithmeticException if the duration exceeds a 64 bit long\n      */\n     public Duration(ReadableInstant start, ReadableInstant end) {\n-        super();\n-        if (start == end) {\n-            iMillis = 0L;\n-        } else {\n-            long startMillis = DateTimeUtils.getInstantMillis(start);\n-            long endMillis = DateTimeUtils.getInstantMillis(end);\n-            iMillis = FieldUtils.safeAdd(endMillis, -startMillis);\n-        }\n+        super(start, end);\n     }\n \n     /**\n      * @throws IllegalArgumentException if duration is invalid\n      */\n     public Duration(Object duration) {\n-        super();\n-        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n-        iMillis = converter.getDurationMillis(duration);\n+        super(duration);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the total length of this duration in milliseconds.\n-     *\n-     * @return the total length of the duration in milliseconds.\n-     */\n-    public final long getMillis() {\n-        return iMillis;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Creates a new Duration instance with a different milisecond length.\n      * \n      * @param duration  the new length of the duration\n      * @return the new duration instance\n      */\n-    public final Duration withMillis(long duration) {\n+    public Duration withMillis(long duration) {\n         if (duration == getMillis()) {\n             return this;\n         }\n      * @param durationToAdd  the duration to add to this one\n      * @return the new duration instance\n      */\n-    public final Duration withDurationAdded(long durationToAdd) {\n+    public Duration withDurationAdded(long durationToAdd) {\n         return withDurationAdded(durationToAdd, 1);\n     }\n \n      * @param scalar  the amount of times to add, such as -1 to subtract once\n      * @return the new duration instance\n      */\n-    public final Duration withDurationAdded(long durationToAdd, int scalar) {\n+    public Duration withDurationAdded(long durationToAdd, int scalar) {\n         if (durationToAdd == 0 || scalar == 0) {\n             return this;\n         }\n      * @param durationToAdd  the duration to add to this one, null means zero\n      * @return the new duration instance\n      */\n-    public final Duration withDurationAdded(ReadableDuration durationToAdd) {\n+    public Duration withDurationAdded(ReadableDuration durationToAdd) {\n         if (durationToAdd == null) {\n             return this;\n         }\n      * @param scalar  the amount of times to add, such as -1 to subtract once\n      * @return the new duration instance\n      */\n-    public final Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n+    public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) {\n         if (durationToAdd == null || scalar == 0) {\n             return this;\n         }\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n      * \n      * @return a Duration created using the millisecond duration from this instance\n      */\n-    public final Duration toDuration() {\n+    public Duration toDuration() {\n         if (this instanceof Duration) {\n             return (Duration) this;\n         }\n      * \n      * @return a Period created using the millisecond duration from this instance\n      */\n-    public final Period toPeriod() {\n+    public Period toPeriod() {\n         return new Period(getMillis());\n     }\n \n      * @param type  the period type determining how to split the duration into fields, null means All type\n      * @return a Period created using the millisecond duration from this instance\n      */\n-    public final Period toPeriod(PeriodType type) {\n+    public Period toPeriod(PeriodType type) {\n         return new Period(getMillis(), type);\n     }\n \n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the given object is not supported\n      */\n-    public final int compareTo(Object obj) {\n+    public int compareTo(Object obj) {\n         // Comparable contract means we cannot handle null or other types gracefully\n         ReadableDuration thisDuration = (ReadableDuration) this;\n         ReadableDuration otherDuration = (ReadableDuration) obj;\n      * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n      */\n-    public final boolean isEqual(ReadableDuration duration) {\n+    public boolean isEqual(ReadableDuration duration) {\n         if (duration == null) {\n             duration = Duration.ZERO;\n         }\n      * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n      */\n-    public final boolean isLongerThan(ReadableDuration duration) {\n+    public boolean isLongerThan(ReadableDuration duration) {\n         if (duration == null) {\n             duration = Duration.ZERO;\n         }\n      * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n      */\n-    public final boolean isShorterThan(ReadableDuration duration) {\n+    public boolean isShorterThan(ReadableDuration duration) {\n         if (duration == null) {\n             duration = Duration.ZERO;\n         }\n      * @param duration  a readable duration to check against\n      * @return true if the length of the duration is equal\n      */\n-    public final boolean equals(Object duration) {\n+    public boolean equals(Object duration) {\n         if (this == duration) {\n             return true;\n         }\n     }\n \n     /**\n-     * Gets a hash code for the duration that is compatable with the \n+     * Gets a hash code for the duration that is compatible with the \n      * equals method.\n      *\n      * @return a hash code\n      */\n-    public final int hashCode() {\n+    public int hashCode() {\n         long len = getMillis();\n         return (int) (len ^ (len >>> 32));\n     }\n      *\n      * @return the value as an ISO8601 string\n      */\n-    public final String toString() {\n+    public String toString() {\n         return ISOPeriodFormat.getInstance().standard().print(toPeriod());\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/base/BaseDuration.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.base;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.ReadableDuration;\n+import org.joda.time.ReadableInstant;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.DurationConverter;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * BaseDateTime is an abstract implementation of ReadableDuration that stores\n+ * data in a <code>long</code> duration milliseconds field.\n+ * <p>\n+ * This class should generally not be used directly by API users.\n+ * The {@link ReadableDateTime} interface should be used when different \n+ * kinds of date/time objects are to be referenced.\n+ * <p>\n+ * BaseDateTime subclasses may be mutable and not thread-safe.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public class BaseDuration\n+        extends AbstractDuration\n+        implements ReadableDuration, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2581698638990L;\n+\n+    /** The duration length */\n+    private long iMillis;\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public BaseDuration(long duration) {\n+        super();\n+        iMillis = duration;\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n+     */\n+    public BaseDuration(long startInstant, long endInstant) {\n+        super();\n+        iMillis = FieldUtils.safeAdd(endInstant, -startInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param start  interval start, null means now\n+     * @param end  interval end, null means now\n+     * @throws ArithmeticException if the duration exceeds a 64 bit long\n+     */\n+    public BaseDuration(ReadableInstant start, ReadableInstant end) {\n+        super();\n+        if (start == end) {\n+            iMillis = 0L;\n+        } else {\n+            long startMillis = DateTimeUtils.getInstantMillis(start);\n+            long endMillis = DateTimeUtils.getInstantMillis(end);\n+            iMillis = FieldUtils.safeAdd(endMillis, -startMillis);\n+        }\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     */\n+    public BaseDuration(Object duration) {\n+        super();\n+        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n+        iMillis = converter.getDurationMillis(duration);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of this duration in milliseconds.\n+     *\n+     * @return the length of the duration in milliseconds.\n+     */\n+    public long getMillis() {\n+        return iMillis;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the length of this duration in milliseconds.\n+     * \n+     * @param duration  the new length of the duration\n+     */\n+    public void setMillis(long duration) {\n+        iMillis = duration;\n+    }\n+\n+}", "timestamp": 1093042020, "metainfo": ""}