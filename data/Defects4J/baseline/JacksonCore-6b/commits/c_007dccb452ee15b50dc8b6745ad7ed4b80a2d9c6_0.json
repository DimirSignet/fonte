{"sha": "007dccb452ee15b50dc8b6745ad7ed4b80a2d9c6", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n     /**********************************************************\n      */\n \n-    public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in)\n-    {\n+    public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in) {\n         _context = ctxt;\n         _in = in;\n         _inputBuffer = ctxt.allocReadIOBuffer();\n         _bufferRecyclable = true;\n     }\n \n-    public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen)\n-    {\n+    public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen) {\n         _context = ctxt;\n         _in = null;\n         _inputBuffer = inputBuffer;\n      * It will figure out encoding that content uses, to allow\n      * for instantiating a proper scanner object.\n      */\n-    public JsonEncoding detectEncoding()\n-        throws IOException, JsonParseException\n+    public JsonEncoding detectEncoding() throws IOException\n     {\n         boolean foundEncoding = false;\n \n             enc = JsonEncoding.UTF8;\n         } else {\n             switch (_bytesPerChar) {\n-            case 1:\n-                enc = JsonEncoding.UTF8;\n+            case 1: enc = JsonEncoding.UTF8;\n                 break;\n-            case 2:\n-                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n+            case 2: enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n                 break;\n-            case 4:\n-                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n+            case 4: enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n                 break;\n-            default:\n-                throw new RuntimeException(\"Internal error\"); // should never get here\n+            default: throw new RuntimeException(\"Internal error\"); // should never get here\n             }\n         }\n         _context.setEncoding(enc);\n      */\n     \n     @SuppressWarnings(\"resource\")\n-    public Reader constructReader()\n-        throws IOException\n+    public Reader constructReader() throws IOException\n     {\n         JsonEncoding enc = _context.getEncoding();\n         switch (enc.bits()) {\n \n     public JsonParser constructParser(int parserFeatures, ObjectCodec codec,\n             BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n-            boolean canonicalize, boolean intern)\n-        throws IOException\n+            boolean canonicalize, boolean intern) throws IOException\n     {\n         JsonEncoding enc = detectEncoding();\n \n      * @return True if a BOM was succesfully found, and encoding\n      *   thereby recognized.\n      */\n-    private boolean handleBOM(int quad)\n-        throws IOException\n+    private boolean handleBOM(int quad) throws IOException\n     {\n         /* Handling of (usually) optional BOM (required for\n          * multi-byte formats); first 32-bit charsets:\n         return false;\n     }\n \n-    private boolean checkUTF32(int quad)\n-        throws IOException\n+    private boolean checkUTF32(int quad) throws IOException\n     {\n         /* Handling of (usually) optional BOM (required for\n          * multi-byte formats); first 32-bit charsets:\n     /**********************************************************\n      */\n \n-    private void reportWeirdUCS4(String type)\n-        throws IOException\n-    {\n+    private void reportWeirdUCS4(String type) throws IOException {\n         throw new CharConversionException(\"Unsupported UCS-4 endianness (\"+type+\") detected\");\n     }\n \n     /**********************************************************\n      */\n \n-    protected boolean ensureLoaded(int minimum)\n-        throws IOException\n-    {\n+    protected boolean ensureLoaded(int minimum) throws IOException {\n         /* Let's assume here buffer has enough room -- this will always\n          * be true for the limited used this method gets\n          */\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n  * core methods needed, and also exposes\n  * more complete API to parser implementation classes.\n  */\n-public final class JsonReadContext\n-    extends JsonStreamContext\n+public final class JsonReadContext extends JsonStreamContext\n {\n     // // // Configuration\n \n     /**********************************************************\n      */\n \n-    public JsonReadContext(JsonReadContext parent, DupDetector dups,\n-            int type, int lineNr, int colNr)\n-    {\n+    public JsonReadContext(JsonReadContext parent, DupDetector dups, int type, int lineNr, int colNr) {\n         super();\n         _parent = parent;\n         _dups = dups;\n         _index = -1;\n     }\n \n-    protected void reset(int type, int lineNr, int colNr)\n-    {\n+    protected void reset(int type, int lineNr, int colNr) {\n         _type = type;\n         _index = -1;\n         _lineNr = lineNr;\n         return createRootContext(lineNr, colNr, null);\n     }\n     \n-    public static JsonReadContext createRootContext(int lineNr, int colNr,\n-            DupDetector dups)\n-    {\n+    public static JsonReadContext createRootContext(int lineNr, int colNr, DupDetector dups) {\n         return new JsonReadContext(null, dups, TYPE_ROOT, lineNr, colNr);\n     }\n \n         return new JsonReadContext(null, dups, TYPE_ROOT, 1, 0);\n     }\n     \n-    public JsonReadContext createChildArrayContext(int lineNr, int colNr)\n-    {\n+    public JsonReadContext createChildArrayContext(int lineNr, int colNr) {\n         JsonReadContext ctxt = _child;\n         if (ctxt == null) {\n             _child = ctxt = new JsonReadContext(this,\n-                    (_dups == null) ? null : _dups.child(),\n-                            TYPE_ARRAY, lineNr, colNr);\n+                    (_dups == null) ? null : _dups.child(), TYPE_ARRAY, lineNr, colNr);\n         } else {\n             ctxt.reset(TYPE_ARRAY, lineNr, colNr);\n         }\n         return ctxt;\n     }\n \n-    public JsonReadContext createChildObjectContext(int lineNr, int colNr)\n-    {\n+    public JsonReadContext createChildObjectContext(int lineNr, int colNr) {\n         JsonReadContext ctxt = _child;\n         if (ctxt == null) {\n             _child = ctxt = new JsonReadContext(this,\n-                    (_dups == null) ? null : _dups.child(),\n-                    TYPE_OBJECT, lineNr, colNr);\n+                    (_dups == null) ? null : _dups.child(), TYPE_OBJECT, lineNr, colNr);\n             return ctxt;\n         }\n         ctxt.reset(TYPE_OBJECT, lineNr, colNr);\n     /**********************************************************\n      */\n \n-    @Override\n-    public String getCurrentName() { return _currentName; }\n-\n-    @Override\n-    public JsonReadContext getParent() { return _parent; }\n+    @Override public String getCurrentName() { return _currentName; }\n+    @Override public JsonReadContext getParent() { return _parent; }\n \n     /*\n     /**********************************************************\n      * @return Location pointing to the point where the context\n      *   start marker was found\n      */\n-    public JsonLocation getStartLocation(Object srcRef)\n-    {\n-        /* We don't keep track of offsets at this level (only\n-         * reader does)\n-         */\n+    public JsonLocation getStartLocation(Object srcRef) {\n+        // We don't keep track of offsets at this level (only reader does)\n         long totalChars = -1L;\n-\n         return new JsonLocation(srcRef, totalChars, _lineNr, _columnNr);\n     }\n \n     /**********************************************************\n      */\n \n-    public boolean expectComma()\n-    {\n+    public boolean expectComma() {\n         /* Assumption here is that we will be getting a value (at least\n          * before calling this method again), and\n          * so will auto-increment index to avoid having to do another call\n         return (_type != TYPE_ROOT && ix > 0);\n     }\n \n-    public void setCurrentName(String name) throws JsonProcessingException\n-    {\n+    public void setCurrentName(String name) throws JsonProcessingException {\n         _currentName = name;\n-        if (_dups != null) {\n-            _checkDup(_dups, name);\n-        }\n-    }\n-\n-    private void _checkDup(DupDetector dd, String name) throws JsonProcessingException\n-    {\n+        if (_dups != null) { _checkDup(_dups, name); }\n+    }\n+\n+    private void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n         if (dd.isDup(name)) {\n             throw new JsonParseException(\"Duplicate field '\"+name+\"'\", dd.findLocation());\n         }\n      * of the context.\n      */\n     @Override\n-    public String toString()\n-    {\n+    public String toString() {\n         StringBuilder sb = new StringBuilder(64);\n         switch (_type) {\n         case TYPE_ROOT:\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n  * core methods needed, and also exposes\n  * more complete API to generator implementation classes.\n  */\n-public class JsonWriteContext\n-    extends JsonStreamContext\n+public class JsonWriteContext extends JsonStreamContext\n {\n     // // // Return values for writeValue()\n \n     /**********************************************************\n      */\n \n-    protected JsonWriteContext(int type, JsonWriteContext parent,\n-            DupDetector dups)\n-    {\n+    protected JsonWriteContext(int type, JsonWriteContext parent, DupDetector dups) {\n         super();\n         _type = type;\n         _parent = parent;\n         _index = -1;\n         _currentName = null;\n         _gotName = false;\n-        if (_dups != null) {\n-            _dups.reset();\n-        }\n+        if (_dups != null) { _dups.reset(); }\n         return this;\n     }\n     \n      * @deprecated Since 2.3; use method that takes argument\n      */\n     @Deprecated\n-    public static JsonWriteContext createRootContext() {\n-        return createRootContext(null);\n-    }\n+    public static JsonWriteContext createRootContext() { return createRootContext(null); }\n \n-    public static JsonWriteContext createRootContext(DupDetector dd) {\n-        return new JsonWriteContext(TYPE_ROOT, null, dd);\n-    }\n+    public static JsonWriteContext createRootContext(DupDetector dd) { return new JsonWriteContext(TYPE_ROOT, null, dd); }\n \n-    public JsonWriteContext createChildArrayContext()\n-    {\n+    public JsonWriteContext createChildArrayContext() {\n         JsonWriteContext ctxt = _child;\n         if (ctxt == null) {\n-            _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this,\n-                    (_dups == null) ? null : _dups.child());\n+            _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this, (_dups == null) ? null : _dups.child());\n             return ctxt;\n         }\n         return ctxt.reset(TYPE_ARRAY);\n     }\n \n-    public JsonWriteContext createChildObjectContext()\n-    {\n+    public JsonWriteContext createChildObjectContext() {\n         JsonWriteContext ctxt = _child;\n         if (ctxt == null) {\n-            _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this,\n-                    (_dups == null) ? null : _dups.child());\n+            _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this, (_dups == null) ? null : _dups.child());\n             return ctxt;\n         }\n         return ctxt.reset(TYPE_OBJECT);\n \n     // // // Shared API\n \n-    @Override\n-    public final JsonWriteContext getParent() { return _parent; }\n-\n-    @Override\n-    public final String getCurrentName() { return _currentName; }\n+    @Override public final JsonWriteContext getParent() { return _parent; }\n+    @Override public final String getCurrentName() { return _currentName; }\n     \n     // // // API sub-classes are to implement\n \n      *\n      * @return Index of the field entry (0-based)\n      */\n-    public final int writeFieldName(String name) throws JsonProcessingException\n-    {\n+    public final int writeFieldName(String name) throws JsonProcessingException {\n         _gotName = true;\n         _currentName = name;\n-        if (_dups != null) {\n-            _checkDup(_dups, name);\n-        }\n+        if (_dups != null) { _checkDup(_dups, name); }\n         return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n     }\n \n-    private void _checkDup(DupDetector dd, String name) throws JsonProcessingException\n-    {\n-        if (dd.isDup(name)) {\n-            throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\");\n-        }\n+    private void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n+        if (dd.isDup(name)) { throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\"); }\n     }\n     \n-    public final int writeValue()\n-    {\n+    public final int writeValue() {\n         // Most likely, object:\n         if (_type == TYPE_OBJECT) {\n             _gotName = false;\n \n     // // // Internally used abstract methods\n \n-    protected final void appendDesc(StringBuilder sb)\n-    {\n+    protected final void appendDesc(StringBuilder sb) {\n         if (_type == TYPE_OBJECT) {\n             sb.append('{');\n             if (_currentName != null) {\n      * Overridden to provide developer writeable \"JsonPath\" representation\n      * of the context.\n      */\n-    @Override\n-    public final String toString()\n-    {\n+    @Override public final String toString() {\n         StringBuilder sb = new StringBuilder(64);\n         appendDesc(sb);\n         return sb.toString();\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n         return false;\n     }\n \n-    protected char getNextChar(String eofMsg) throws IOException\n-    {\n+    protected char getNextChar(String eofMsg) throws IOException {\n         if (_inputPtr >= _inputEnd) {\n-            if (!loadMore()) {\n-                _reportInvalidEOF(eofMsg);\n-            }\n+            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n         }\n         return _inputBuffer[_inputPtr++];\n     }\n \n     @Override\n-    protected void _closeInput() throws IOException\n-    {\n+    protected void _closeInput() throws IOException {\n         /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n          *   on the underlying Reader, unless we \"own\" it, or auto-closing\n          *   feature is enabled.\n      * separately (if need be).\n      */\n     @Override\n-    protected void _releaseBuffers() throws IOException\n-    {\n+    protected void _releaseBuffers() throws IOException {\n         super._releaseBuffers();\n         // merge new symbols, if any\n         _symbols.release();\n          * actual conversion to a number is deferred. Thus, need to\n          * note that no representations are valid yet\n          */\n-        boolean negative = (ch == INT_MINUS);\n+        boolean neg = (ch == INT_MINUS);\n         int ptr = _inputPtr;\n         int startPtr = ptr-1; // to include sign/digit already read\n         final int inputLen = _inputEnd;\n \n         dummy_loop:\n         do { // dummy loop, to be able to break out\n-            if (negative) { // need to read the next digit\n+            if (neg) { // need to read the next digit\n                 if (ptr >= _inputEnd) {\n                     break dummy_loop;\n                 }\n             }\n             int len = ptr-startPtr;\n             _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n-            return reset(negative, intLen, fractLen, expLen);\n+            return reset(neg, intLen, fractLen, expLen);\n         } while (false);\n \n-        _inputPtr = negative ? (startPtr+1) : startPtr;\n-        return _parseNumber2(negative);\n+        _inputPtr = neg ? (startPtr+1) : startPtr;\n+        return _parseNumber2(neg);\n     }\n \n     /**\n      * that it has to explicitly copy contents to the text buffer\n      * instead of just sharing the main input buffer.\n      */\n-    private JsonToken _parseNumber2(boolean negative) throws IOException\n+    private JsonToken _parseNumber2(boolean neg) throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n \n         // Need to prepend sign?\n-        if (negative) {\n+        if (neg) {\n             outBuf[outPtr++] = '-';\n         }\n \n         }\n         _textBuffer.setCurrentLength(outPtr);\n         // And there we have it!\n-        return reset(negative, intLen, fractLen, expLen);\n+        return reset(neg, intLen, fractLen, expLen);\n     }\n \n     /**\n     {\n         if (ch == 'I') {\n             if (_inputPtr >= _inputEnd) {\n-                if (!loadMore()) {\n-                    _reportInvalidEOFInValue();\n-                }\n+                if (!loadMore()) { _reportInvalidEOFInValue(); }\n             }\n             ch = _inputBuffer[_inputPtr++];\n             if (ch == 'N') {\n \n     protected String _parseName(int i) throws IOException\n     {\n-        if (i != INT_QUOTE) {\n-            return _handleOddName(i);\n-        }\n-        /* First: let's try to see if we have a simple name: one that does\n-         * not cross input buffer boundary, and does not contain escape\n-         * sequences.\n-         */\n+        if (i != INT_QUOTE) { return _handleOddName(i); }\n+\n+        // First: let's try to see if we have a simple name: one that does\n+        // not cross input buffer boundary, and does not contain escape sequences.\n         int ptr = _inputPtr;\n         int hash = _hashSeed;\n         final int inputLen = _inputEnd;\n     {\n         _tokenIncomplete = false;\n \n-        int inputPtr = _inputPtr;\n-        int inputLen = _inputEnd;\n-        char[] inputBuffer = _inputBuffer;\n+        int inPtr = _inputPtr;\n+        int inLen = _inputEnd;\n+        char[] inBuf = _inputBuffer;\n \n         while (true) {\n-            if (inputPtr >= inputLen) {\n-                _inputPtr = inputPtr;\n+            if (inPtr >= inLen) {\n+                _inputPtr = inPtr;\n                 if (!loadMore()) {\n                     _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                 }\n-                inputPtr = _inputPtr;\n-                inputLen = _inputEnd;\n-            }\n-            char c = inputBuffer[inputPtr++];\n+                inPtr = _inputPtr;\n+                inLen = _inputEnd;\n+            }\n+            char c = inBuf[inPtr++];\n             int i = (int) c;\n             if (i <= INT_BACKSLASH) {\n                 if (i == INT_BACKSLASH) {\n                      * an UTF-16 surrogate pair, does that affect decoding?\n                      * For now let's assume it does not.\n                      */\n-                    _inputPtr = inputPtr;\n+                    _inputPtr = inPtr;\n                     c = _decodeEscaped();\n-                    inputPtr = _inputPtr;\n-                    inputLen = _inputEnd;\n+                    inPtr = _inputPtr;\n+                    inLen = _inputEnd;\n                 } else if (i <= INT_QUOTE) {\n                     if (i == INT_QUOTE) {\n-                        _inputPtr = inputPtr;\n+                        _inputPtr = inPtr;\n                         break;\n                     }\n                     if (i < INT_SPACE) {\n-                        _inputPtr = inputPtr;\n+                        _inputPtr = inPtr;\n                         _throwUnquotedSpace(i, \"string value\");\n                     }\n                 }\n      * We actually need to check the character value here\n      * (to see if we have \\n following \\r).\n      */\n-    protected void _skipCR() throws IOException\n-    {\n+    protected void _skipCR() throws IOException {\n         if (_inputPtr < _inputEnd || loadMore()) {\n             if (_inputBuffer[_inputPtr] == '\\n') {\n                 ++_inputPtr;\n     private void _skipCComment() throws IOException\n     {\n         // Ok: need the matching '*/'\n-        main_loop:\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n             int i = (int) _inputBuffer[_inputPtr++];\n             if (i <= '*') {\n                 if (i == '*') { // end?\n                     if ((_inputPtr >= _inputEnd) && !loadMore()) {\n-                        break main_loop;\n+                        break;\n                     }\n                     if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                         ++_inputPtr;", "timestamp": 1390627123, "metainfo": ""}