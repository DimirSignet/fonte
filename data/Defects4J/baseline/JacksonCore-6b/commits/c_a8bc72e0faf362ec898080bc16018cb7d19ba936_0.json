{"sha": "a8bc72e0faf362ec898080bc16018cb7d19ba936", "log": "Change IOContext to be sub-classable (remove 'final')", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n  * contextual objects that need to be passed by the factory to\n  * readers and writers are combined under this object. One instance\n  * is created for each reader and writer.\n+ *<p>\n+ * NOTE: non-final since 2.4, to allow sub-classing.\n  */\n-public final class IOContext\n+public class IOContext\n {\n     /*\n     /**********************************************************\n      * Note: the method can only be called once during its life cycle.\n      * This is to protect against accidental sharing.\n      */\n-    public byte[] allocReadIOBuffer()\n-    {\n+    public byte[] allocReadIOBuffer() {\n         _verifyAlloc(_readIOBuffer);\n         return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER));\n     }\n \n-    public byte[] allocWriteEncodingBuffer()\n-    {\n+    public byte[] allocWriteEncodingBuffer() {\n         _verifyAlloc(_writeEncodingBuffer);\n         return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER));\n     }\n     /**\n      * @since 2.1\n      */\n-    public byte[] allocBase64Buffer()\n-    {\n+    public byte[] allocBase64Buffer() {\n         _verifyAlloc(_base64Buffer);\n         return (_base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_BASE64_CODEC_BUFFER));\n     }\n     \n-    public char[] allocTokenBuffer()\n-    {\n+    public char[] allocTokenBuffer() {\n         _verifyAlloc(_tokenCBuffer);\n         return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER));\n     }\n \n-    public char[] allocConcatBuffer()\n-    {\n+    public char[] allocConcatBuffer() {\n         _verifyAlloc(_concatCBuffer);\n         return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER));\n     }\n \n-    public char[] allocNameCopyBuffer(int minSize)\n-    {\n+    public char[] allocNameCopyBuffer(int minSize) {\n         _verifyAlloc(_nameCopyBuffer);\n         return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, minSize));\n     }\n      * Method to call when all the processing buffers can be safely\n      * recycled.\n      */\n-    public void releaseReadIOBuffer(byte[] buf)\n-    {\n+    public void releaseReadIOBuffer(byte[] buf) {\n         if (buf != null) {\n             /* Let's do sanity checks to ensure once-and-only-once release,\n              * as well as avoiding trying to release buffers not owned\n         }\n     }\n \n-    public void releaseWriteEncodingBuffer(byte[] buf)\n-    {\n+    public void releaseWriteEncodingBuffer(byte[] buf) {\n         if (buf != null) {\n             /* Let's do sanity checks to ensure once-and-only-once release,\n              * as well as avoiding trying to release buffers not owned\n         }\n     }\n \n-    public void releaseBase64Buffer(byte[] buf)\n-    {\n+    public void releaseBase64Buffer(byte[] buf) {\n         if (buf != null) { // sanity checks, release once-and-only-once, must be one owned\n             _verifyRelease(buf, _base64Buffer);\n             _base64Buffer = null;\n         }\n     }\n     \n-    public void releaseTokenBuffer(char[] buf)\n-    {\n+    public void releaseTokenBuffer(char[] buf) {\n         if (buf != null) {\n             _verifyRelease(buf, _tokenCBuffer);\n             _tokenCBuffer = null;\n         }\n     }\n \n-    public void releaseConcatBuffer(char[] buf)\n-    {\n+    public void releaseConcatBuffer(char[] buf) {\n         if (buf != null) {\n             _verifyRelease(buf, _concatCBuffer);\n             _concatCBuffer = null;\n         }\n     }\n \n-    public void releaseNameCopyBuffer(char[] buf)\n-    {\n+    public void releaseNameCopyBuffer(char[] buf) {\n         if (buf != null) {\n             _verifyRelease(buf, _nameCopyBuffer);\n             _nameCopyBuffer = null;\n     /**********************************************************\n      */\n \n-    private final void _verifyAlloc(Object buffer)\n-    {\n+    protected void _verifyAlloc(Object buffer) {\n         if (buffer != null) {\n             throw new IllegalStateException(\"Trying to call same allocXxx() method second time\");\n         }\n     }\n-    \n-    private final void _verifyRelease(Object toRelease, Object src)\n-    {\n+\n+    protected void _verifyRelease(Object toRelease, Object src) {\n         if (toRelease != src) {\n             throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n         }", "timestamp": 1389669731, "metainfo": ""}