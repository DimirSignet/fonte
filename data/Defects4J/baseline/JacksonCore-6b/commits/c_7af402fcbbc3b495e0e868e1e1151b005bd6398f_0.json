{"sha": "7af402fcbbc3b495e0e868e1e1151b005bd6398f", "log": "Refactoring: moving JavaType into databind, creating more abstract base type, ResolvedType to define ObjectCodec", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n+++ b/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n import java.io.IOException;\n import java.util.Iterator;\n \n-import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n /**\n      * of just a single node if the current event is a\n      * value event, not container).\n      */\n-    public abstract <T> T readValue(JsonParser jp, JavaType valueType)\n+    public abstract <T> T readValue(JsonParser jp, ResolvedType valueType)\n         throws IOException, JsonProcessingException;\n \n     /**\n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n-     * \n-     * @since 1.9\n      */\n     public abstract <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)\n         throws IOException, JsonProcessingException;\n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n-     * \n-     * @since 1.9\n      */\n     public abstract <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n         throws IOException, JsonProcessingException;\n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n-     * \n-     * @since 1.9\n      */\n-    public abstract <T> Iterator<T> readValues(JsonParser jp, JavaType valueType)\n+    public abstract <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType)\n         throws IOException, JsonProcessingException;\n     \n     /*\n     /**\n      * Method for construct root level Object nodes\n      * for Tree Model instances.\n-     *\n-     * @since 1.2\n      */\n     public abstract JsonNode createObjectNode();\n \n     /**\n      * Method for construct root level Array nodes\n      * for Tree Model instances.\n-     *\n-     * @since 1.2\n      */\n     public abstract JsonNode createArrayNode();\n \n      * Method for constructing a {@link JsonParser} for reading\n      * contents of a JSON tree, as if it was external serialized\n      * JSON content.\n-     *\n-     * @since 1.3\n      */\n     public abstract JsonParser treeAsTokens(JsonNode n);\n \n      * Convenience method for converting given JSON tree into instance of specified\n      * value type. This is equivalent to first constructing a {@link JsonParser} to\n      * iterate over contents of the tree, and using that parser for data binding.\n-     * \n-     * @since 1.3\n      */\n     public abstract <T> T treeToValue(JsonNode n, Class<T> valueType)\n         throws IOException, JsonProcessingException;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n+package com.fasterxml.jackson.core.type;\n+\n+/**\n+ * Type abstraction that represents Java type that has been resolved\n+ * (i.e. has all generic information, if any, resolved to concrete\n+ * types).\n+ * Note that this is an intermediate type, and all concrete instances\n+ * MUST be of type <code>JavaType</code> from \"databind\" bundle -- this\n+ * abstraction is only needed so that types can be passed through\n+ * {@link com.fasterxml.jackson.core.JsonParser#readValueAs} methods.\n+ * \n+ * @since 2.0\n+ */\n+public abstract class ResolvedType\n+{\n+    /*\n+    /**********************************************************\n+    /* Public API, simple property accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for type-erased {@link Class} of resolved type.\n+     */\n+    public abstract Class<?> getRawClass();\n+\n+    public abstract boolean hasRawClass(Class<?> clz);\n+\n+    public abstract boolean isAbstract();\n+    \n+    public abstract boolean isConcrete();\n+\n+    public abstract boolean isThrowable();\n+\n+    public abstract boolean isArrayType();\n+\n+    public abstract boolean isEnumType();\n+\n+    public abstract boolean isInterface();\n+\n+    public abstract boolean isPrimitive();\n+\n+    public abstract boolean isFinal();\n+\n+    public abstract boolean isContainerType();\n+\n+    public abstract boolean isCollectionLikeType();\n+\n+    public abstract boolean isMapLikeType();\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, type parameter access\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be used to find out if the type directly declares generic\n+     * parameters (for its direct super-class and/or super-interfaces).\n+     */\n+    public abstract boolean hasGenericTypes();\n+    \n+    /**\n+     * Method for accessing key type for this type, assuming type\n+     * has such a concept (only Map types do)\n+     */\n+    public abstract ResolvedType getKeyType();\n+\n+    /**\n+     * Method for accessing content type of this type, if type has\n+     * such a thing: simple types do not, structured types do\n+     * (like arrays, Collections and Maps)\n+     */\n+    public abstract ResolvedType getContentType();\n+\n+    /**\n+     * Method for checking how many contained types this type\n+     * has. Contained types are usually generic types, so that\n+     * generic Maps have 2 contained types.\n+     */\n+    public abstract int containedTypeCount();\n+\n+    /**\n+     * Method for accessing definitions of contained (\"child\")\n+     * types.\n+     * \n+     * @param index Index of contained type to return\n+     * \n+     * @return Contained type at index, or null if no such type\n+     *    exists (no exception thrown)\n+     */\n+    public abstract ResolvedType containedType(int index);\n+    \n+    /**\n+     * Method for accessing name of type variable in indicated\n+     * position. If no name is bound, will use placeholders (derived\n+     * from 0-based index); if no type variable or argument exists\n+     * with given index, null is returned.\n+     * \n+     * @param index Index of contained type to return\n+     * \n+     * @return Contained type at index, or null if no such type\n+     *    exists (no exception thrown)\n+     */\n+    public abstract String containedTypeName(int index);\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to serialize type into form from which\n+     * it can be fully deserialized from at a later point (using\n+     * <code>TypeFactory</code> from mapper package).\n+     * For simple types this is same as calling\n+     * {@link Class#getName}, but for structured types it may additionally\n+     * contain type information about contents.\n+     */\n+    public abstract String toCanonical();\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n import java.lang.reflect.Type;\n \n /**\n- * This class is used to pass full generics type information, and\n- * avoid problems with type erasure (that basically removes most\n- * usable type references from runtime Class objects).\n- * It is based on ideas from\n+ * This generic abstract class is used for obtaining full generics type information\n+ * by sub-classing; it must be converted to {@link ResolvedType} implementation\n+ * (implemented by <code>JavaType</code> from \"databind\" bundle) to be used.\n+ * Class is based on ideas from\n  * <a href=\"http://gafter.blogspot.com/2006/12/super-type-tokens.html\"\n  * >http://gafter.blogspot.com/2006/12/super-type-tokens.html</a>,\n  * Additional idea (from a suggestion made in comments of the article)\n  *<pre>\n  *  TypeReference ref = new TypeReference&lt;List&lt;Integer>>() { };\n  *</pre>\n- * which can be passed to methods that accept TypeReference.\n+ * which can be passed to methods that accept TypeReference, or resolved\n+ * using <code>TypeFactory</code> to obtain {@link ResolvedType}.\n  */\n public abstract class TypeReference<T>\n     implements Comparable<TypeReference<T>>", "timestamp": 1324693350, "metainfo": ""}