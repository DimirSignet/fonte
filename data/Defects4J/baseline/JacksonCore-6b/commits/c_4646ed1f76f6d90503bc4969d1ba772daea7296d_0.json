{"sha": "4646ed1f76f6d90503bc4969d1ba772daea7296d", "log": "minor cleanup", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n      * Index of character after last available one in the buffer.\n      */\n     protected int _inputEnd = 0;\n-    \n+\n     /*\n     /**********************************************************\n     /* Current input location information\n      * the current event.\n      */\n     @Override\n-    public String getCurrentName()\n-        throws IOException, JsonParseException\n+    public String getCurrentName() throws IOException\n     {\n         // [JACKSON-395]: start markers require information from parent\n         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n     }\n     \n     @Override\n-    public void close() throws IOException\n-    {\n+    public void close() throws IOException {\n         if (!_closed) {\n             _closed = true;\n             try {\n     public boolean isClosed() { return _closed; }\n \n     @Override\n-    public JsonReadContext getParsingContext()\n-    {\n+    public JsonReadContext getParsingContext() {\n         return _parsingContext;\n     }\n \n \n     // No embedded objects with base impl...\n     @Override\n-    public Object getEmbeddedObject() throws IOException, JsonParseException {\n+    public Object getEmbeddedObject() throws IOException {\n         return null;\n     }\n     \n     /**********************************************************\n      */\n \n-    protected final void loadMoreGuaranteed()\n-        throws IOException\n-    {\n-        if (!loadMore()) {\n-            _reportInvalidEOF();\n-        }\n+    protected final void loadMoreGuaranteed() throws IOException {\n+        if (!loadMore()) { _reportInvalidEOF(); }\n     }\n     \n     /*\n \n     protected abstract boolean loadMore() throws IOException;\n     \n-    protected abstract void _finishString() throws IOException, JsonParseException;\n+    protected abstract void _finishString() throws IOException;\n \n     protected abstract void _closeInput() throws IOException;\n     \n     /**********************************************************\n      */\n     \n-    protected void _reportMismatchedEndMarker(int actCh, char expCh)\n-        throws JsonParseException\n+    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException\n     {\n         String startDesc = \"\"+_parsingContext.getStartLocation(_ioContext.getSourceReference());\n         _reportError(\"Unexpected close marker '\"+((char) actCh)+\"': expected '\"+expCh+\"' (for \"+_parsingContext.getTypeDesc()+\" starting at \"+startDesc+\")\");\n      */\n     \n     @Override\n-    public Number getNumberValue() throws IOException, JsonParseException\n+    public Number getNumberValue() throws IOException\n     {\n         if (_numTypesValid == NR_UNKNOWN) {\n             _parseNumericValue(NR_UNKNOWN); // will also check event type\n     }\n     \n     @Override\n-    public NumberType getNumberType() throws IOException, JsonParseException\n+    public NumberType getNumberType() throws IOException\n     {\n         if (_numTypesValid == NR_UNKNOWN) {\n             _parseNumericValue(NR_UNKNOWN); // will also check event type\n     }\n     \n     @Override\n-    public int getIntValue() throws IOException, JsonParseException\n+    public int getIntValue() throws IOException\n     {\n         if ((_numTypesValid & NR_INT) == 0) {\n             if (_numTypesValid == NR_UNKNOWN) { // not parsed at all\n     }\n     \n     @Override\n-    public long getLongValue() throws IOException, JsonParseException\n+    public long getLongValue() throws IOException\n     {\n         if ((_numTypesValid & NR_LONG) == 0) {\n             if (_numTypesValid == NR_UNKNOWN) {\n     }\n     \n     @Override\n-    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+    public BigInteger getBigIntegerValue() throws IOException\n     {\n         if ((_numTypesValid & NR_BIGINT) == 0) {\n             if (_numTypesValid == NR_UNKNOWN) {\n     }\n     \n     @Override\n-    public double getDoubleValue() throws IOException, JsonParseException\n+    public double getDoubleValue() throws IOException\n     {\n         if ((_numTypesValid & NR_DOUBLE) == 0) {\n             if (_numTypesValid == NR_UNKNOWN) {\n     }\n     \n     @Override\n-    public BigDecimal getDecimalValue() throws IOException, JsonParseException\n+    public BigDecimal getDecimalValue() throws IOException\n     {\n         if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n             if (_numTypesValid == NR_UNKNOWN) {\n      * @param expType Numeric type that we will immediately need, if any;\n      *   mostly necessary to optimize handling of floating point numbers\n      */\n-    protected void _parseNumericValue(int expType)\n-        throws IOException, JsonParseException\n+    protected void _parseNumericValue(int expType) throws IOException\n     {\n         // Int or float?\n         if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n         _reportError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n     }\n     \n-    private void _parseSlowFloat(int expType)\n-        throws IOException, JsonParseException\n+    private void _parseSlowFloat(int expType) throws IOException\n     {\n         /* Nope: floating point. Here we need to be careful to get\n          * optimal parsing strategy: choice is between accurate but\n         }\n     }\n     \n-    private void _parseSlowInt(int expType, char[] buf, int offset, int len)\n-        throws IOException, JsonParseException\n+    private void _parseSlowInt(int expType, char[] buf, int offset, int len) throws IOException\n     {\n         String numStr = _textBuffer.contentsAsString();\n         try {\n     /**********************************************************\n      */    \n     \n-    protected void convertNumberToInt()\n-        throws IOException, JsonParseException\n+    protected void convertNumberToInt() throws IOException\n     {\n         // First, converting from long ought to be easy\n         if ((_numTypesValid & NR_LONG) != 0) {\n         _numTypesValid |= NR_INT;\n     }\n     \n-    protected void convertNumberToLong()\n-        throws IOException, JsonParseException\n+    protected void convertNumberToLong() throws IOException\n     {\n         if ((_numTypesValid & NR_INT) != 0) {\n             _numberLong = (long) _numberInt;\n         _numTypesValid |= NR_LONG;\n     }\n     \n-    protected void convertNumberToBigInteger()\n-        throws IOException, JsonParseException\n+    protected void convertNumberToBigInteger() throws IOException\n     {\n         if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n             // here it'll just get truncated, no exceptions thrown\n         _numTypesValid |= NR_BIGINT;\n     }\n     \n-    protected void convertNumberToDouble()\n-        throws IOException, JsonParseException\n+    protected void convertNumberToDouble() throws IOException\n     {\n         /* 05-Aug-2008, tatus: Important note: this MUST start with\n          *   more accurate representations, since we don't know which\n         _numTypesValid |= NR_DOUBLE;\n     }\n     \n-    protected void convertNumberToBigDecimal()\n-        throws IOException, JsonParseException\n+    protected void convertNumberToBigDecimal() throws IOException\n     {\n         /* 05-Aug-2008, tatus: Important note: this MUST start with\n          *   more accurate representations, since we don't know which\n     /**********************************************************\n      */    \n     \n-    protected void reportUnexpectedNumberChar(int ch, String comment)\n-        throws JsonParseException\n-    {\n+    protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {\n         String msg = \"Unexpected character (\"+_getCharDesc(ch)+\") in numeric value\";\n         if (comment != null) {\n             msg += \": \"+comment;\n         _reportError(msg);\n     }\n     \n-    protected void reportInvalidNumber(String msg)\n-        throws JsonParseException\n-    {\n+    protected void reportInvalidNumber(String msg) throws JsonParseException {\n         _reportError(\"Invalid numeric value: \"+msg);\n     }\n-    \n-    protected void reportOverflowInt()\n-        throws IOException, JsonParseException\n-    {\n+\n+    protected void reportOverflowInt() throws IOException {\n         _reportError(\"Numeric value (\"+getText()+\") out of range of int (\"+Integer.MIN_VALUE+\" - \"+Integer.MAX_VALUE+\")\");\n     }\n     \n-    protected void reportOverflowLong()\n-        throws IOException, JsonParseException\n-    {\n+    protected void reportOverflowLong() throws IOException {\n         _reportError(\"Numeric value (\"+getText()+\") out of range of long (\"+Long.MIN_VALUE+\" - \"+Long.MAX_VALUE+\")\");\n     }    \n \n      * in base64-encoded sections.\n      * Sub-classes that do not need base64 support can leave this as is\n      */\n-    protected char _decodeEscaped()\n-        throws IOException, JsonParseException {\n+    protected char _decodeEscaped() throws IOException {\n         throw new UnsupportedOperationException();\n     }\n     \n-    protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index)\n-        throws IOException, JsonParseException\n+    protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException\n     {\n         // 17-May-2011, tatu: As per [JACKSON-xxx], need to handle escaped chars\n         if (ch != '\\\\') {\n         return bits;\n     }\n     \n-    protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index)\n-        throws IOException, JsonParseException\n+    protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException\n     {\n         // 17-May-2011, tatu: As per [JACKSON-xxx], need to handle escaped chars\n         if (ch != '\\\\') {\n--- a/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n     /**\n      * Buffer used for concatenating binary data that is either being\n      * encoded as base64 output, or decoded from base64 input.\n-     * \n+     *\n      * @since 2.1\n      */\n     public final static int BYTE_BASE64_CODEC_BUFFER = 3;", "timestamp": 1389335979, "metainfo": ""}