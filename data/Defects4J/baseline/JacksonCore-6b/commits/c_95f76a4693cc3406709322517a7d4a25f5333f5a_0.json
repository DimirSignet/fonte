{"sha": "95f76a4693cc3406709322517a7d4a25f5333f5a", "log": "Implement [Issue#33]: make `JsonFactory` JDK Serializable", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n  *\n  * @author Tatu Saloranta\n  */\n-public class JsonFactory implements Versioned\n+public class JsonFactory\n+    implements Versioned,\n+        java.io.Serializable // since 2.1 (for Android, mostly)\n {\n+    /**\n+     * Computed for Jackson 2.1.0 release\n+     */\n+    private static final long serialVersionUID = -5207101305402257257L;\n+\n     /**\n      * Name used to identify JSON format\n      * (and returned by {@link #getFormatName()}\n      * It should not be linked back to the original blueprint, to\n      * avoid contents from leaking between factories.\n      */\n-    protected CharsToNameCanonicalizer _rootCharSymbols = CharsToNameCanonicalizer.createRoot();\n+    protected final transient CharsToNameCanonicalizer _rootCharSymbols = CharsToNameCanonicalizer.createRoot();\n \n     /**\n      * Alternative to the basic symbol table, some stream-based\n      * TODO: should clean up this; looks messy having 2 alternatives\n      * with not very clear differences.\n      */\n-    protected BytesToNameCanonicalizer _rootByteSymbols = BytesToNameCanonicalizer.createRoot();\n+    protected final transient BytesToNameCanonicalizer _rootByteSymbols = BytesToNameCanonicalizer.createRoot();\n \n     /*\n     /**********************************************************\n             throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n                     +\" (version: \"+version()+\") does not override copy(); it has to\");\n         }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serializable overrides\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that we need to override to actually make restoration go\n+     * through constructors etc.\n+     * Also: must be overridden by sub-classes as well.\n+     */\n+    protected Object readResolve() {\n+        return new JsonFactory(_objectCodec);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n  * For JSON this applies to both property names and String values.\n  */\n public abstract class CharacterEscapes\n+    implements java.io.Serializable // since 2.1\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Value used for lookup tables to indicate that matching characters\n      * do not need to be escaped.\n--- a/src/main/java/com/fasterxml/jackson/core/io/InputDecorator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/InputDecorator.java\n  * processing during read operations.\n  */\n public abstract class InputDecorator\n+    implements java.io.Serializable // since 2.1\n {\n+    private static final long serialVersionUID = 1L;\n+    \n     /**\n      * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n      * creating parser given an {@link InputStream}, when this decorator\n--- a/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n  * processing during write operations.\n  */\n public abstract class OutputDecorator\n+    implements java.io.Serializable // since 2.1\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n      * creating generator for given {@link OutputStream}, when this decorator\n--- a/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n package com.fasterxml.jackson.core.io;\n \n-import java.io.IOException;\n-import java.io.OutputStream;\n+import java.io.*;\n import java.nio.ByteBuffer;\n \n import com.fasterxml.jackson.core.SerializableString;\n  * Class is final for performance reasons and since this is not designed to\n  * be extensible or customizable (customizations would occur in calling code)\n  */\n-public class SerializedString implements SerializableString\n+public class SerializedString\n+    implements SerializableString, java.io.Serializable\n {\n     protected final String _value;\n \n \n     protected /*volatile*/ char[] _quotedChars;\n \n-    public SerializedString(String v) { _value = v; }\n+    public SerializedString(String v) {\n+        if (v == null) {\n+            throw new IllegalStateException(\"Null String illegal for SerializedString\");\n+        }\n+        _value = v;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Serializable overrides\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Ugly hack, to work through the requirement that _value is indeed final,\n+     * and that JDK serialization won't call ctor(s).\n+     * \n+     * @since 2.1\n+     */\n+    protected transient String _jdkSerializeValue;\n+\n+    private void readObject(ObjectInputStream in) throws IOException {\n+        _jdkSerializeValue = in.readUTF();\n+    }\n+\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.writeUTF(_value);\n+    }\n+\n+    protected Object readResolve() {\n+        return new SerializedString(_jdkSerializeValue);\n+    }\n \n     /*\n     /**********************************************************\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/TestSerializability.java\n+package com.fasterxml.jackson.core;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Unit tests for [Issue#31] (https://github.com/FasterXML/jackson-core/issues/31)\n+ */\n+public class TestSerializability extends BaseTest\n+{\n+    public void testJsonFactorySerializable() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        String origJson = \"{\\\"simple\\\":[1,true,{}]}\";\n+        assertEquals(origJson, _copyJson(f, origJson, false));\n+\n+        // Ok: freeze dry factory, thaw, and try to use again:\n+        byte[] frozen = jdkSerialize(f);\n+        JsonFactory f2 = jdkDeserialize(frozen);\n+        assertNotNull(f2);\n+        assertEquals(origJson, _copyJson(f2, origJson, false));\n+\n+        // Let's also try byte-based variant, for fun...\n+        assertEquals(origJson, _copyJson(f2, origJson, true));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected byte[] jdkSerialize(Object o) throws IOException\n+    {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream(1000);\n+        ObjectOutputStream obOut = new ObjectOutputStream(bytes);\n+        obOut.writeObject(o);\n+        obOut.close();\n+        return bytes.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T jdkDeserialize(byte[] raw) throws IOException\n+    {\n+        ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(raw));\n+        try {\n+            return (T) objIn.readObject();\n+        } catch (ClassNotFoundException e) {\n+            fail(\"Missing class: \"+e.getMessage());\n+            return null;\n+        } finally {\n+            objIn.close();\n+        }\n+    }\n+    \n+    protected String _copyJson(JsonFactory f, String json, boolean useBytes) throws IOException\n+    {\n+        if (useBytes) {\n+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            JsonGenerator jg = f.createGenerator(bytes);\n+            _copyJson(f, json, jg);\n+            return bytes.toString(\"UTF-8\");\n+        }\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = f.createGenerator(sw);\n+        _copyJson(f, json, jg);\n+        return sw.toString();\n+    }\n+        \n+    protected void _copyJson(JsonFactory f, String json, JsonGenerator jg) throws IOException\n+    {\n+        JsonParser jp = f.createParser(json);\n+        while (jp.nextToken() != null) {\n+            jg.copyCurrentEvent(jp);\n+        }\n+        jp.close();\n+        jg.close();\n+    }\n+}", "timestamp": 1349467463, "metainfo": ""}