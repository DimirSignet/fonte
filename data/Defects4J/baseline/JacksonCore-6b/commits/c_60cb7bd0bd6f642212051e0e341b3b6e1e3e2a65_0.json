{"sha": "60cb7bd0bd6f642212051e0e341b3b6e1e3e2a65", "log": "Minor clean up to start using Arrays.copyOf() (since we require Java 1.6)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n package com.fasterxml.jackson.core.io;\n+\n+import java.util.Arrays;\n \n import com.fasterxml.jackson.core.SerializableString;\n \n     public static int[] standardAsciiEscapesForJSON()\n     {\n         int[] esc = CharTypes.get7BitOutputEscapes();\n-        int len = esc.length;\n-        int[] result = new int[len];\n-        System.arraycopy(esc, 0, result, 0, esc.length);\n-        return result;\n+        return Arrays.copyOf(esc, esc.length);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n package com.fasterxml.jackson.core.json;\n \n import java.io.*;\n+import java.util.Arrays;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.base.ParserBase;\n         if (arr == null) {\n             return new int[more];\n         }\n-        int[] old = arr;\n-        int len = arr.length;\n-        arr = new int[len + more];\n-        System.arraycopy(old, 0, arr, 0, len);\n-        return arr;\n+        return Arrays.copyOf(arr, arr.length + more);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n      */\n     private void unshareMain()\n     {\n-        int[] old = _mainHash;\n-        int len = _mainHash.length;\n-\n-        _mainHash = new int[len];\n-        System.arraycopy(old, 0, _mainHash, 0, len);\n+        final int[] old = _mainHash;\n+        _mainHash = Arrays.copyOf(old, old.length);\n         _mainHashShared = false;\n     }\n \n         if (old == null) {\n             _collList = new Bucket[INITIAL_COLLISION_LEN];\n         } else {\n-            int len = old.length;\n-            _collList = new Bucket[len];\n-            System.arraycopy(old, 0, _collList, 0, len);\n+            _collList = Arrays.copyOf(old, old.length);\n         }\n         _collListShared = false;\n     }\n \n     private void unshareNames()\n     {\n-        Name[] old = _mainNames;\n-        int len = old.length;\n-        _mainNames = new Name[len];\n-        System.arraycopy(old, 0, _mainNames, 0, len);\n+        final Name[] old = _mainNames;\n+        _mainNames = Arrays.copyOf(old, old.length);\n         _mainNamesShared = false;\n     }\n \n     private void expandCollision()\n     {\n-        Bucket[] old = _collList;\n-        int len = old.length;\n-        _collList = new Bucket[len+len];\n-        System.arraycopy(old, 0, _collList, 0, len);\n-    }\n-\n+        final Bucket[] old = _collList;\n+        _collList = Arrays.copyOf(old, old.length * 2);\n+    }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n      * Method called when copy-on-write is needed; generally when first\n      * change is made to a derived symbol table.\n      */\n-    private void copyArrays() {\n-        String[] oldSyms = _symbols;\n-        int size = oldSyms.length;\n-        _symbols = new String[size];\n-        System.arraycopy(oldSyms, 0, _symbols, 0, size);\n-        Bucket[] oldBuckets = _buckets;\n-        size = oldBuckets.length;\n-        _buckets = new Bucket[size];\n-        System.arraycopy(oldBuckets, 0, _buckets, 0, size);\n+    private void copyArrays()\n+    {\n+        final String[] oldSyms = _symbols;\n+        _symbols = Arrays.copyOf(oldSyms, oldSyms.length);\n+        final Bucket[] oldBuckets = _buckets;\n+        _buckets = Arrays.copyOf(oldBuckets, oldBuckets.length);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n+import java.util.Arrays;\n \n import com.fasterxml.jackson.core.io.NumberInput;\n \n \n     /**\n      * Method called to expand size of the current segment, to\n-     * accomodate for more contiguous content. Usually only\n-     * used when parsing tokens like names.\n+     * accommodate for more contiguous content. Usually only\n+     * used when parsing tokens like names if even then.\n      */\n     public char[] expandCurrentSegment()\n     {\n-        char[] curr = _currentSegment;\n+        final char[] curr = _currentSegment;\n         // Let's grow by 50%\n-        int len = curr.length;\n+        final int len = curr.length;\n         // Must grow by at least 1 char, no matter what\n         int newLen = (len == MAX_SEGMENT_LEN) ?\n             (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n-        _currentSegment = _charArray(newLen);\n-        System.arraycopy(curr, 0, _currentSegment, 0, len);\n-        return _currentSegment;\n+        return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /*\n         if (sizeAddition < minNewSegmentSize) {\n             sizeAddition = minNewSegmentSize;\n         }\n-        curr = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n         _currentSize = 0;\n-        _currentSegment = curr;\n+        _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n     }\n \n     private char[] buildResultArray()\n         if (_resultString != null) { // Can take a shortcut...\n             return _resultString.toCharArray();\n         }\n-        char[] result;\n-        \n         // Do we use shared array?\n         if (_inputStart >= 0) {\n-            if (_inputLen < 1) {\n+            final int len = _inputLen;\n+            if (len < 1) {\n                 return NO_CHARS;\n             }\n-            result = _charArray(_inputLen);\n-            System.arraycopy(_inputBuffer, _inputStart, result, 0,\n-                             _inputLen);\n-        } else { // nope \n-            int size = size();\n-            if (size < 1) {\n-                return NO_CHARS;\n+            final int start = _inputStart;\n+            if (start == 0) {\n+                return Arrays.copyOf(_inputBuffer, len);\n             }\n-            int offset = 0;\n-            result = _charArray(size);\n-            if (_segments != null) {\n-                for (int i = 0, len = _segments.size(); i < len; ++i) {\n-                    char[] curr = (char[]) _segments.get(i);\n-                    int currLen = curr.length;\n-                    System.arraycopy(curr, 0, result, offset, currLen);\n-                    offset += currLen;\n-                }\n+            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n+        }\n+        // nope, not shared\n+        int size = size();\n+        if (size < 1) {\n+            return NO_CHARS;\n+        }\n+        int offset = 0;\n+        final char[] result = _charArray(size);\n+        if (_segments != null) {\n+            for (int i = 0, len = _segments.size(); i < len; ++i) {\n+                char[] curr = (char[]) _segments.get(i);\n+                int currLen = curr.length;\n+                System.arraycopy(curr, 0, result, offset, currLen);\n+                offset += currLen;\n             }\n-            System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n-        }\n+        }\n+        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n         return result;\n     }\n ", "timestamp": 1370554103, "metainfo": ""}