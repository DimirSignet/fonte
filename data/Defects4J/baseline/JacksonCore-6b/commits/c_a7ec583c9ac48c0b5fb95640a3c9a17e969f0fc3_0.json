{"sha": "a7ec583c9ac48c0b5fb95640a3c9a17e969f0fc3", "log": "Start work on [Issue-22], trying to prevent hash-collision based attacks", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     protected ObjectCodec _objectCodec;\n \n     final protected CharsToNameCanonicalizer _symbols;\n+    \n+    final protected int _hashSeed;\n \n     /*\n     /**********************************************************\n      */\n \n     public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n-                             ObjectCodec codec, CharsToNameCanonicalizer st)\n+            ObjectCodec codec, CharsToNameCanonicalizer st)\n     {\n         super(ctxt, features);\n         _reader = r;\n         _inputBuffer = ctxt.allocTokenBuffer();\n         _objectCodec = codec;\n         _symbols = st;\n+        _hashSeed = st.hashSeed();\n     }\n \n     @Override\n          * sequences.\n          */\n         int ptr = _inputPtr;\n-        int hash = 0;\n+        int hash = _hashSeed;\n         final int inputLen = _inputEnd;\n \n         if (ptr < inputLen) {\n             _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n         }\n         int ptr = _inputPtr;\n-        int hash = 0;\n+        int hash = _hashSeed;\n         final int inputLen = _inputEnd;\n \n         if (ptr < inputLen) {\n     {\n         // Note: mostly copy of_parseFieldName\n         int ptr = _inputPtr;\n-        int hash = 0;\n+        int hash = _hashSeed;\n         final int inputLen = _inputEnd;\n \n         if (ptr < inputLen) {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n  * parsers; especially when number of symbols (keywords) is limited.\n  *<p>\n  * For optimal performance, usage pattern should be one where matches\n- * should be very common (esp. after \"warm-up\"), and as with most hash-based\n+ * should be very common (especially after \"warm-up\"), and as with most hash-based\n  * maps/sets, that hash codes are uniformly distributed. Also, collisions\n  * are slightly more expensive than with HashMap or HashSet, since hash codes\n  * are not used in resolving collisions; that is, equals() comparison is\n  * (much like generic collection classes), concurrently used \"child\"\n  * instances can be freely used without synchronization. However, using\n  * master table concurrently with child instances can only be done if\n- * access to master instance is read-only (ie. no modifications done).\n+ * access to master instance is read-only (i.e. no modifications done).\n  */\n-\n public final class CharsToNameCanonicalizer\n {\n     /**\n      */\n     final static int MAX_ENTRIES_FOR_REUSE = 12000;\n \n+    /**\n+     * Also: to thwart attacks based on hash collisions (which may or may not\n+     * be cheap to calculate), we will need to detect \"too long\"\n+     * collision chains. Let's start with static value of 255 entries\n+     * for the longest legal chain.\n+     * \n+     * @since 2.1\n+     */\n+    final static int MAX_COLL_CHAIN_LENGTH = 255;\n+\n+    /**\n+     * And to support reduce likelihood of accidental collisons causing\n+     * exceptions, let's prevent reuse of tables with long collision\n+     * overflow lists as well.\n+     * \n+     * @since 2.1\n+     */\n+    final static int MAX_COLL_CHAIN_FOR_REUSE  = 63;\n+    \n     final static CharsToNameCanonicalizer sBootstrapSymbolTable;\n     static {\n         sBootstrapSymbolTable = new CharsToNameCanonicalizer();\n     }\n \n     /*\n-    /****************************************\n-    /* Configuration:\n-    /****************************************\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n      */\n \n     /**\n     protected CharsToNameCanonicalizer _parent;\n \n     /**\n+     * Seed value we use as the base to make hash codes non-static between\n+     * different runs, but still stable for lifetime of a single symbol table\n+     * instance.\n+     * This is done for security reasons, to avoid potential DoS attack via\n+     * hash collisions.\n+     * \n+     * @since 2.1\n+     */\n+    final protected int _hashSeed;\n+    \n+    /**\n      * Whether canonical symbol Strings are to be intern()ed before added\n      * to the table or not\n      */\n     final protected boolean _canonicalize;\n     \n     /*\n-    /****************************************\n-    /* Actual symbol table data:\n-    /****************************************\n+    /**********************************************************\n+    /* Actual symbol table data\n+    /**********************************************************\n      */\n \n     /**\n      */\n     protected int _indexMask;\n \n-    /*\n-    /****************************************\n+    /**\n+     * We need to keep track of the longest collision list; this is needed\n+     * both to indicate problems with attacks and to allow flushing for\n+     * other cases.\n+     * \n+     * @since 2.1\n+     */\n+    protected int _longestCollisionList;\n+    \n+    /*\n+    /**********************************************************\n     /* State regarding shared arrays\n-    /****************************************\n+    /**********************************************************\n      */\n \n     /**\n     protected boolean _dirty;\n \n     /*\n-    /****************************************\n+    /**********************************************************\n     /* Life-cycle\n-    /****************************************\n+    /**********************************************************\n      */\n \n     /**\n      */\n     public static CharsToNameCanonicalizer createRoot()\n     {\n-        return sBootstrapSymbolTable.makeOrphan();\n+        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n+         * based attacks.\n+         */\n+        long now = System.currentTimeMillis();\n+        int seed = ((int) now) + ((int) now >>> 32);\n+        return createRoot(seed);\n+    }\n+    \n+    protected static CharsToNameCanonicalizer createRoot(int hashSeed) {\n+        return sBootstrapSymbolTable.makeOrphan(hashSeed);\n     }\n \n     /**\n         _intern = true;\n         // And we'll also set flags so no copying of buckets is needed:\n         _dirty = true;\n+        _hashSeed = 0;\n+        _longestCollisionList = 0;\n         initTables(DEFAULT_TABLE_SIZE);\n     }\n \n         // Mask is easy to calc for powers of two.\n         _indexMask = initialSize - 1;\n         _size = 0;\n+        _longestCollisionList = 0;\n         // Hard-coded fill factor is 75%\n         _sizeThreshold = (initialSize - (initialSize >> 2));\n     }\n      */\n     private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent,\n             boolean canonicalize, boolean intern,\n-            String[] symbols, Bucket[] buckets, int size)\n+            String[] symbols, Bucket[] buckets, int size,\n+            int hashSeed, int longestColl)\n     {\n         _parent = parent;\n         _canonicalize = canonicalize;\n         _symbols = symbols;\n         _buckets = buckets;\n         _size = size;\n+        _hashSeed = hashSeed;\n         // Hard-coded fill factor, 75%\n         int arrayLen = (symbols.length);\n         _sizeThreshold = arrayLen - (arrayLen >> 2);\n         _indexMask =  (arrayLen - 1);\n+        _longestCollisionList = longestColl;\n \n         // Need to make copies of arrays, if/when adding new entries\n         _dirty = false;\n      */\n     public synchronized CharsToNameCanonicalizer makeChild(boolean canonicalize, boolean intern)\n     {\n-        return new CharsToNameCanonicalizer(this, canonicalize, intern, _symbols, _buckets, _size);\n-    }\n-\n-    private CharsToNameCanonicalizer makeOrphan()\n-    {\n-        return new CharsToNameCanonicalizer(null, true, true, _symbols, _buckets, _size);\n+        return new CharsToNameCanonicalizer(this, canonicalize, intern,\n+                _symbols, _buckets, _size, _hashSeed, _longestCollisionList);\n+    }\n+\n+    private CharsToNameCanonicalizer makeOrphan(int seed)\n+    {\n+        return new CharsToNameCanonicalizer(null, true, true,\n+                _symbols, _buckets, _size, seed, _longestCollisionList);\n     }\n \n     /**\n          * One way to do this is to just purge tables if they grow\n          * too large, and that's what we'll do here.\n          */\n-        if (child.size() > MAX_ENTRIES_FOR_REUSE) {\n+        if (child.size() > MAX_ENTRIES_FOR_REUSE\n+                || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) {\n             /* Should there be a way to get notified about this\n              * event, to log it or such? (as it's somewhat abnormal\n              * thing to happen)\n             _size = child._size;\n             _sizeThreshold = child._sizeThreshold;\n             _indexMask = child._indexMask;\n+            _longestCollisionList = child._longestCollisionList;\n         }\n         /* Dirty flag... well, let's just clear it, to force copying just\n          * in case. Shouldn't really matter, for master tables.\n     }\n \n     /*\n-    /****************************************\n+    /**********************************************************\n     /* Public API, generic accessors:\n-    /****************************************\n+    /**********************************************************\n      */\n \n     public int size() { return _size; }\n \n     public boolean maybeDirty() { return _dirty; }\n \n-    /*\n-    /****************************************\n+    public int hashSeed() { return _hashSeed; }\n+    \n+    /**\n+     * Method mostly needed by unit tests; calculates number of\n+     * entries that are in collision list. Value can be at most\n+     * ({@link #size} - 1), but should usually be much lower, ideally 0.\n+     */\n+    public int collisionCount()\n+    {\n+        int count = 0;\n+        \n+        for (Bucket bucket : _buckets) {\n+            if (bucket != null) {\n+                count += bucket.length();\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates length of the\n+     * longest collision chain. This should typically be a low number,\n+     * but may be up to {@link #size} - 1 in the pathological case\n+     * \n+     * @since 2.1\n+     */\n+    public int maxCollisionLength()\n+    {\n+        return _longestCollisionList;\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Public API, accessing symbols:\n-    /****************************************\n+    /**********************************************************\n      */\n \n     public String findSymbol(char[] buffer, int start, int len, int hash)\n              */\n             hash = calcHash(buffer, start, len) & _indexMask;\n         }\n-        ++_size;\n \n         String newSymbol = new String(buffer, start, len);\n         if (_intern) {\n             newSymbol = InternCache.instance.intern(newSymbol);\n         }\n+        ++_size;\n         // Ok; do we need to add primary entry, or a bucket?\n         if (_symbols[hash] == null) {\n             _symbols[hash] = newSymbol;\n         } else {\n-            int bix = hash >> 1;\n-            _buckets[bix] = new Bucket(newSymbol, _buckets[bix]);\n+            int bix = (hash >> 1);\n+            Bucket newB = new Bucket(newSymbol, _buckets[bix]);\n+            _buckets[bix] = newB;\n+            _longestCollisionList = Math.max(newB.length(), _longestCollisionList);\n+            if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) {\n+                reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH);\n+            }\n         }\n \n         return newSymbol;\n      * @param len Length of String; has to be at least 1 (caller guarantees\n      *   this pre-condition)\n      */\n-    public static int calcHash(char[] buffer, int start, int len) {\n-        int hash = (int) buffer[0];\n-        for (int i = 1; i < len; ++i) {\n+    public int calcHash(char[] buffer, int start, int len) {\n+        int hash = _hashSeed;\n+        for (int i = 0; i < len; ++i) {\n             hash = (hash * 31) + (int) buffer[i];\n         }\n         return hash;\n     }\n \n-    public static int calcHash(String key) {\n-        int hash = (int) key.charAt(0);\n-        for (int i = 1, len = key.length(); i < len; ++i) {\n+    public int calcHash(String key) {\n+        int hash = _hashSeed;\n+        for (int i = 0, len = key.length(); i < len; ++i) {\n             hash = (hash * 31) + (int) key.charAt(i);\n-\n         }\n         return hash;\n     }\n \n     /*\n-    /****************************************\n+    /**********************************************************\n     /* Internal methods\n-    /****************************************\n+    /**********************************************************\n      */\n \n     /**\n         /* Need to do two loops, unfortunately, since spill-over area is\n          * only half the size:\n          */\n+        int maxColl = 0;\n         for (int i = 0; i < size; ++i) {\n             String symbol = oldSyms[i];\n             if (symbol != null) {\n                 if (_symbols[index] == null) {\n                     _symbols[index] = symbol;\n                 } else {\n-                    int bix = index >> 1;\n-                    _buckets[bix] = new Bucket(symbol, _buckets[bix]);\n+                    int bix = (index >> 1);\n+                    Bucket newB = new Bucket(symbol, _buckets[bix]);\n+                    _buckets[bix] = newB;\n+                    maxColl = Math.max(maxColl, newB.length());\n                 }\n             }\n         }\n+        _longestCollisionList = maxColl;\n \n         size >>= 1;\n         for (int i = 0; i < size; ++i) {\n                 if (_symbols[index] == null) {\n                     _symbols[index] = symbol;\n                 } else {\n-                    int bix = index >> 1;\n-                    _buckets[bix] = new Bucket(symbol, _buckets[bix]);\n+                    int bix = (index >> 1);\n+                    Bucket newB = new Bucket(symbol, _buckets[bix]);\n+                    _buckets[bix] = newB;\n+                    maxColl = Math.max(maxColl, newB.length());\n                 }\n                 b = b.getNext();\n             }\n         }\n     }\n \n-    /*\n-    /****************************************\n+    /**\n+     * @since 2.1\n+     */\n+    protected void reportTooManyCollisions(int maxLen)\n+    {\n+        throw new IllegalStateException(\"Longest collision chain in symbol table (of size \"+_size\n+                +\") now exceeds maximum, \"+maxLen+\" -- suspect a DoS attack based on hash collisions\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Bucket class\n-    /****************************************\n+    /**********************************************************\n      */\n \n     /**\n      * This class is a symbol table entry. Each entry acts as a node\n      * in a linked list.\n      */\n-    static final class Bucket {\n+    static final class Bucket\n+    {\n         private final String _symbol;\n-        private final Bucket mNext;\n+        private final Bucket _next;\n+        private final int _length;\n \n         public Bucket(String symbol, Bucket next) {\n             _symbol = symbol;\n-            mNext = next;\n+            _next = next;\n+            _length = (next == null) ? 1 : next._length+1;\n         }\n \n         public String getSymbol() { return _symbol; }\n-        public Bucket getNext() { return mNext; }\n+        public Bucket getNext() { return _next; }\n+        public int length() { return _length; }\n \n         public String find(char[] buf, int start, int len) {\n             String sym = _symbol;\n-            Bucket b = mNext;\n+            Bucket b = _next;\n \n             while (true) { // Inlined equality comparison:\n                 if (sym.length() == len) {\n             }\n             return null;\n         }\n-\n-    /* 26-Nov-2008, tatu: not used currently; if not used in near future,\n-     *   let's just delete it.\n-     */\n-        /*\n-        public String find(String str) {\n-            String sym = _symbol;\n-            Bucket b = mNext;\n-\n-            while (true) {\n-                if (sym.equals(str)) {\n-                    return sym;\n-                }\n-                if (b == null) {\n-                    break;\n-                }\n-                sym = b.getSymbol();\n-                b = b.getNext();\n-            }\n-            return null;\n-        }\n-        */\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n \n import com.fasterxml.jackson.core.json.*;\n import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n \n /**\n     public void testCoreVersions()\n     {\n         assertVersion(new JsonFactory().version());\n-        assertVersion(new ReaderBasedJsonParser(getIOContext(), 0, null, null, null).version());\n+        assertVersion(new ReaderBasedJsonParser(getIOContext(), 0, null, null,\n+                CharsToNameCanonicalizer.createRoot()).version());\n         assertVersion(new WriterBasedJsonGenerator(getIOContext(), 0, null, null).version());\n     }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+package com.fasterxml.jackson.core.sym;\n+\n+public class TestSymbolTables extends com.fasterxml.jackson.test.BaseTest\n+{\n+    // 11 3-char snippets that hash to 0xFFFF (with default JDK hashCode() calc),\n+    // and which can be combined as\n+    // sequences, like, say, 11x11x11 (1331) 9-character thingies\n+    final static String[] CHAR_COLLISION_SNIPPETS = {\n+        \"@~}\", \"@\u007f^\", \"A_}\", \"A`^\", \n+        \"Aa?\", \"B@}\", \"BA^\", \"BB?\", \n+        \"C!}\", \"C\\\"^\", \"C#?\"\n+    };\n+    final static String[] CHAR_COLLISIONS;\n+    static {\n+        final int len = CHAR_COLLISION_SNIPPETS.length;\n+        CHAR_COLLISIONS = new String[len*len*len];\n+        int ix = 0;\n+        for (int i1 = 0; i1 < len; ++i1) {\n+            for (int i2 = 0; i2 < len; ++i2) {\n+                for (int i3 = 0; i3 < len; ++i3) {\n+                    CHAR_COLLISIONS[ix++] = CHAR_COLLISION_SNIPPETS[i1]\n+                            +CHAR_COLLISION_SNIPPETS[i2] + CHAR_COLLISION_SNIPPETS[i3];\n+                }\n+            }\n+        }\n+    }\n+    \n+    public void testCharBasedCollisions()\n+    {\n+        CharsToNameCanonicalizer sym = CharsToNameCanonicalizer.createRoot(0);\n+\n+        // first, verify that we'd get a few collisions...\n+        try {\n+            int firstHash = 0;\n+            for (String str : CHAR_COLLISIONS) {\n+                int hash = sym.calcHash(str);\n+                if (firstHash == 0) {\n+                    firstHash = hash;\n+                } else {\n+                    assertEquals(firstHash, hash); \n+                }\n+                sym.findSymbol(str.toCharArray(), 0, str.length(), hash);\n+            }\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"exceeds maximum\");\n+            // should fail right after addition:\n+            assertEquals(CharsToNameCanonicalizer.MAX_COLL_CHAIN_LENGTH+1, sym.maxCollisionLength());\n+            assertEquals(CharsToNameCanonicalizer.MAX_COLL_CHAIN_LENGTH+1, sym.collisionCount());\n+            // one \"non-colliding\" entry (head of collision chain), thus:\n+            assertEquals(CharsToNameCanonicalizer.MAX_COLL_CHAIN_LENGTH+2, sym.size());\n+        }\n+    }\n+}", "timestamp": 1341981894, "metainfo": ""}