{"sha": "1313ea3369312ef6bbb96192afbd3a12e5b8bbc4", "log": "try to simplify VersionUtil", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n  */\n public class VersionUtil\n {\n-    /**\n-     * @deprecated Since 2.2, use of version file is deprecated, and generated\n-     *    class should be used instead.\n-     */\n-    @Deprecated\n-    public final static String VERSION_FILE = \"VERSION.txt\";\n-    public final static String PACKAGE_VERSION_CLASS_NAME = \"PackageVersion\";\n-//    public final static String PACKAGE_VERSION_FIELD = \"VERSION\";\n-\n     private final static Pattern VERSION_SEPARATOR = Pattern.compile(\"[-_./;:]\");\n \n     private final Version _version;\n \n     /*\n     /**********************************************************\n-    /* Instance life-cycle, accesso\n+    /* Instance life-cycle\n     /**********************************************************\n      */\n     \n              */\n             v = VersionUtil.versionFor(getClass());\n         } catch (Exception e) { // not good to dump to stderr; but that's all we have at this low level\n-            System.err.println(\"ERROR: Failed to load Version information for bundle (via \"+getClass().getName()+\").\");\n+            System.err.println(\"ERROR: Failed to load Version information from \"+getClass());\n         }\n         if (v == null) {\n             v = Version.unknownVersion();\n      *\n      * If no version information is found, {@link Version#unknownVersion()} is returned.\n      */\n+    @SuppressWarnings(\"resource\")\n     public static Version versionFor(Class<?> cls)\n     {\n         Version packageVersion = packageVersionFor(cls);\n         if (packageVersion != null) {\n             return packageVersion;\n         }\n-\n-        final InputStream in = cls.getResourceAsStream(VERSION_FILE);\n-\n-        if (in == null)\n+        final InputStream in = cls.getResourceAsStream(\"VERSION.txt\");\n+        if (in == null) {\n             return Version.unknownVersion();\n-\n+        }\n         try {\n             InputStreamReader reader = new InputStreamReader(in, \"UTF-8\");\n-            try {\n-                return doReadVersion(reader);\n-            } finally {\n-                try {\n-                    reader.close();\n-                } catch (IOException ignored) {\n-                }\n-            }\n+            return doReadVersion(reader);\n         } catch (UnsupportedEncodingException e) {\n             return Version.unknownVersion();\n         } finally {\n-            try {\n-                in.close();\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n+            _close(in);\n         }\n     }\n \n      */\n     public static Version packageVersionFor(Class<?> cls)\n     {\n-        Class<?> versionInfoClass = null;\n-        try {\n-            Package p = cls.getPackage();\n-            String versionInfoClassName =\n-                new StringBuilder(p.getName())\n-                    .append(\".\")\n-                    .append(PACKAGE_VERSION_CLASS_NAME)\n-                    .toString();\n-            versionInfoClass = Class.forName(versionInfoClassName, true, cls.getClassLoader());\n+        Class<?> vClass = null;\n+        try {\n+            String versionInfoClassName = cls.getPackage().getName() + \".PackageVersion\";\n+            vClass = Class.forName(versionInfoClassName, true, cls.getClassLoader());\n         } catch (Exception e) { // ok to be missing (not good, acceptable)\n             return null;\n         }\n-        if (versionInfoClass == null) {\n+        if (vClass == null) {\n             return null;\n         }\n         // However, if class exists, it better work correctly, no swallowing exceptions\n         Object v;\n         try {\n-            v = versionInfoClass.newInstance();\n+            v = vClass.newInstance();\n         } catch (RuntimeException e) {\n             throw e;\n         } catch (Exception e) {\n-            throw new IllegalArgumentException(\"Failed to instantiate \"+versionInfoClass.getName()\n-                    +\" to find version information, problem: \"+e.getMessage(), e);\n+            throw new IllegalArgumentException(\"Failed to create \"+vClass+\": \"+e.getMessage(), e);\n         }\n         if (!(v instanceof Versioned)) {\n-            throw new IllegalArgumentException(\"Bad version class \"+versionInfoClass.getName()\n-        \t\t\t+\": does not implement \"+Versioned.class.getName());\n+            throw new IllegalArgumentException(\"\"+vClass+\": does not implement Versioned\");\n         }\n         return ((Versioned) v).version();\n     }\n         final BufferedReader br = new BufferedReader(reader);\n         try {\n             version = br.readLine();\n-            if (version != null) {\n-                group = br.readLine();\n-                if (group != null)\n-                    artifact = br.readLine();\n-            }\n-        } catch (IOException ignored) {\n+                if (version != null) {\n+                    group = br.readLine();\n+                    if (group != null) {\n+                        artifact = br.readLine();\n+                    }\n+                }\n+            } catch (IOException ignored) {\n         } finally {\n-            try {\n-                br.close();\n-            } catch (IOException ignored) {\n-            }\n+            _close(br);\n         }\n \n         // We don't trim() version: parseVersion() takes care ot that\n-        if (group != null)\n+        if (group != null) {\n             group = group.trim();\n-        if (artifact != null)\n+        }\n+        if (artifact != null) {\n             artifact = artifact.trim();\n+        }\n         return parseVersion(version, group, artifact);\n     }\n \n      * @param artifactId the artifactId of the library\n      * @return The version\n      */\n-    public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId) {\n-        InputStream pomPoperties = classLoader.getResourceAsStream(\"META-INF/maven/\" + groupId.replaceAll(\"\\\\.\", \"/\")\n+    @SuppressWarnings(\"resource\")\n+    public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId)\n+    {\n+        InputStream pomProperties = classLoader.getResourceAsStream(\"META-INF/maven/\" + groupId.replaceAll(\"\\\\.\", \"/\")\n                 + \"/\" + artifactId + \"/pom.properties\");\n-        if (pomPoperties != null) {\n+        if (pomProperties != null) {\n             try {\n                 Properties props = new Properties();\n-                props.load(pomPoperties);\n+                props.load(pomProperties);\n                 String versionStr = props.getProperty(\"version\");\n                 String pomPropertiesArtifactId = props.getProperty(\"artifactId\");\n                 String pomPropertiesGroupId = props.getProperty(\"groupId\");\n             } catch (IOException e) {\n                 // Ignore\n             } finally {\n-                try {\n-                    pomPoperties.close();\n-                } catch (IOException e) {\n-                    // Ignore\n-                }\n+                _close(pomProperties);\n             }\n         }\n         return Version.unknownVersion();\n     }\n \n-    /**\n-     * Use variant that takes three arguments instead\n-     * \n-     * @deprecated\n-     */\n-    @Deprecated\n-    public static Version parseVersion(String versionStr) {\n-        return parseVersion(versionStr, null, null);\n-    }\n-\n     public static Version parseVersion(String versionStr, String groupId, String artifactId)\n     {\n-        if (versionStr == null) {\n-            return null;\n-        }\n-        versionStr = versionStr.trim();\n-        if (versionStr.length() == 0) {\n-            return null;\n-        }\n-        String[] parts = VERSION_SEPARATOR.split(versionStr);\n-        int major = parseVersionPart(parts[0]);\n-        int minor = (parts.length > 1) ? parseVersionPart(parts[1]) : 0;\n-        int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0;\n-        String snapshot = (parts.length > 3) ? parts[3] : null;\n-\n-        return new Version(major, minor, patch, snapshot,\n-                groupId, artifactId);\n+        if (versionStr != null && (versionStr = versionStr.trim()).length() > 0) {\n+            String[] parts = VERSION_SEPARATOR.split(versionStr);\n+            int major = parseVersionPart(parts[0]);\n+            int minor = (parts.length > 1) ? parseVersionPart(parts[1]) : 0;\n+            int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0;\n+            String snapshot = (parts.length > 3) ? parts[3] : null;\n+            return new Version(major, minor, patch, snapshot, groupId, artifactId);\n+        }\n+        return null;\n     }\n \n     protected static int parseVersionPart(String partStr)\n         return number;\n     }\n \n+    private final static void _close(Closeable c) {\n+        try {\n+            c.close();\n+        } catch (IOException e) { }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Orphan utility methods", "timestamp": 1378528594, "metainfo": ""}