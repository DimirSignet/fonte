{"sha": "383bc8f251ad42419354d1f40f8487435f470bb2", "log": "Fix a minor bug in handling of char-based symbol tables (calc of hash code of)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n          *<p>\n          * This setting is enabled by default.\n          */\n-        CANONICALIZE_FIELD_NAMES(true)\n+        CANONICALIZE_FIELD_NAMES(true),\n+\n+        /**\n+         * Feature that determines what happens if we encounter a case in symbol\n+         * handling where number of hash collisions exceeds a safety threshold\n+         * -- which almost certainly means a denial-of-service attack via generated\n+         * duplicate hash codes.\n+         * If feature is enabled, an {@link IllegalStateException} is\n+         * thrown to indicate the suspected denial-of-service attack; if disabled, processing continues but\n+         * canonicalization (and thereby <code>intern()</code>ing) is disabled) as protective\n+         * measure.\n+         *<p>\n+         * This setting is enabled by default.\n+         * \n+         * @since 2.4\n+         */\n+        FAIL_ON_SYMBOL_HASH_OVERFLOW(true),\n \n         ;\n \n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n     /**\n      * Default initial table size. Shouldn't be miniscule (as there's\n      * cost to both array realloc and rehashing), but let's keep\n-     * it reasonably small nonetheless. For systems that properly \n+     * it reasonably small. For systems that properly \n      * reuse factories it doesn't matter either way; but when\n      * recreating factories often, initial overhead may dominate.\n      */\n     /**\n      * Let's not expand symbol tables past some maximum size;\n      * this should protected against OOMEs caused by large documents\n-     * with uniquer (~= random) names.\n+     * with unique (~= random) names.\n      */\n     protected static final int MAX_T_SIZE = 0x10000; // 64k entries == 256k mem\n \n      * \n      * @since 2.1\n      */\n-    final static int MAX_COLL_CHAIN_LENGTH = 255;\n-\n-    /**\n-     * And to reduce likelihood of accidental collisions causing\n-     * exceptions, let's prevent reuse of tables with long collision\n-     * overflow lists as well.\n-     * \n-     * @since 2.1\n-     */\n-    final static int MAX_COLL_CHAIN_FOR_REUSE  = 63;\n+    final static int MAX_COLL_CHAIN_LENGTH = 100;\n     \n     final static CharsToNameCanonicalizer sBootstrapSymbolTable = new CharsToNameCanonicalizer();\n \n      * @since 2.1\n      */\n     final private int _hashSeed;\n-    \n-    /**\n-     * Whether canonical symbol Strings are to be intern()ed before added\n-     * to the table or not\n-     */\n-    final protected boolean _intern;\n-\n+\n+    final protected int _flags;\n+    \n     /**\n      * Whether any canonicalization should be attempted (whether using\n      * intern or not)\n      */\n-    final protected boolean _canonicalize;\n+    protected boolean _canonicalize;\n     \n     /*\n     /**********************************************************\n \n     /**\n      * Main method for constructing a master symbol table instance.\n-     *\n-     * @param initialSize Minimum initial size for bucket array; internally\n-     *   will always use a power of two equal to or bigger than this value.\n      */\n     private CharsToNameCanonicalizer() {\n         // these settings don't really matter for the bootstrap instance\n         _canonicalize = true;\n-        _intern = true;\n+        _flags = -1;\n         // And we'll also set flags so no copying of buckets is needed:\n         _dirty = true;\n         _hashSeed = 0;\n     /**\n      * Internal constructor used when creating child instances.\n      */\n-    private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern,\n+    private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, int flags,\n             String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl) {\n         _parent = parent;\n-        _canonicalize = canonicalize;\n-        _intern = intern;\n+\n+        _flags = flags;\n+        _canonicalize = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(flags);\n \n         _symbols = symbols;\n         _buckets = buckets;\n         final int size;\n         final int hashSeed;\n         final int longestCollisionList;\n-\n-        final boolean canon = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(flags);\n-        final boolean intern = canon && JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags);\n         \n         synchronized (this) {\n             symbols = _symbols;\n             hashSeed = _hashSeed;\n             longestCollisionList = _longestCollisionList;\n         }\n-        \n-        return new CharsToNameCanonicalizer(this, canon, intern,\n+        return new CharsToNameCanonicalizer(this, flags,\n                 symbols, buckets, size, hashSeed, longestCollisionList);\n     }\n \n     private CharsToNameCanonicalizer makeOrphan(int seed) {\n-        return new CharsToNameCanonicalizer(null, true, true, _symbols, _buckets, _size, seed, _longestCollisionList);\n+        return new CharsToNameCanonicalizer(null, -1, _symbols, _buckets, _size, seed, _longestCollisionList);\n     }\n \n     /**\n          * One way to do this is to just purge tables if they grow\n          * too large, and that's what we'll do here.\n          */\n-        if (child.size() > MAX_ENTRIES_FOR_REUSE\n-                || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) {\n+        if (child.size() > MAX_ENTRIES_FOR_REUSE) {\n             // Should there be a way to get notified about this event, to log it or such?\n             // (as it's somewhat abnormal thing to happen)\n             // At any rate, need to clean up the tables, then:\n             synchronized (this) {\n-                initTables(DEFAULT_T_SIZE);\n+                initTables(DEFAULT_T_SIZE * 4); // no point in starting from tiny tho\n                 // Dirty flag... well, let's just clear it. Shouldn't really matter for master tables\n                 // (which this is, given something is merged to it)\n                 _dirty = false;\n     public void release(){\n         // If nothing has been added, nothing to do\n         if (!maybeDirty()) { return; }\n-        if (_parent != null) {\n+        if (_parent != null && _canonicalize) { // canonicalize set to false if max size was reached\n             _parent.mergeChild(this);\n             /* Let's also mark this instance as dirty, so that just in\n              * case release was too early, there's no corruption\n             copyArrays();\n             _dirty = true;\n         } else if (_size >= _sizeThreshold) { // Need to expand?\n-           rehash();\n-           /* Need to recalc hash; rare occurence (index mask has been\n-            * recalculated as part of rehash)\n-            */\n-           index = _hashToIndex(calcHash(buffer, start, len));\n+            rehash();\n+            /* Need to recalc hash; rare occurence (index mask has been\n+             * recalculated as part of rehash)\n+             */\n+            index = _hashToIndex(calcHash(buffer, start, len));\n         }\n \n         String newSymbol = new String(buffer, start, len);\n-        if (_intern) {\n+        if (JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(_flags)) {\n             newSymbol = InternCache.instance.intern(newSymbol);\n         }\n         ++_size;\n         if (_symbols[index] == null) {\n             _symbols[index] = newSymbol;\n         } else {\n-            int bix = (index >> 1);\n+            final int bix = (index >> 1);\n             Bucket newB = new Bucket(newSymbol, _buckets[bix]);\n-            _buckets[bix] = newB;\n-            _longestCollisionList = Math.max(newB.length, _longestCollisionList);\n-            if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) {\n-                reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH);\n+            int collLen = newB.length;\n+            if (collLen > MAX_COLL_CHAIN_LENGTH) {\n+                /* 23-May-2014, tatu: Instead of throwing an exception right away, let's handle\n+                 *   in bit smarter way.\n+                 */\n+                _handleSpillOverflow(bix, newB);\n+            } else {\n+                _buckets[bix] = newB;\n+                _longestCollisionList = Math.max(collLen, _longestCollisionList);\n             }\n         }\n \n         return newSymbol;\n+    }\n+\n+    private void _handleSpillOverflow(int bindex, Bucket newBucket)\n+    {\n+        if (_overflows == null) {\n+            _overflows = new BitSet();\n+            _overflows.set(bindex);\n+        } else {\n+            if (_overflows.get(bindex)) {\n+                // Has happened once already, so not a coincident...\n+                if (JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(_flags)) {\n+                    reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH);\n+                }\n+                // but even if we don't fail, we will stop canonicalizing:\n+                _canonicalize = false;\n+            } else {\n+                _overflows.set(bindex);\n+            }\n+        }\n+        // regardless, if we get this far, clear up the bucket, adjust size appropriately.\n+        _symbols[bindex + bindex] = newBucket.symbol;\n+        _buckets[bindex] = null;\n+        // newBucket contains new symbol; but we wil \n+        _size -= (newBucket.length);\n     }\n \n     /**\n      */\n     public int calcHash(char[] buffer, int start, int len) {\n         int hash = _hashSeed;\n-        for (int i = 0; i < len; ++i) {\n+        for (int i = start, end = start+len; i < end; ++i) {\n             hash = (hash * HASH_MULT) + (int) buffer[i];\n         }\n         // NOTE: shuffling, if any, is done in 'findSymbol()', not here:\n          *    name sets (unique [non-repeating] names)\n          */\n         if (newSize > MAX_T_SIZE) {\n-            /* If this happens, there's no point in either growing or\n-             * shrinking hash areas. Rather, it's better to just clean\n-             * them up for reuse.\n+            /* If this happens, there's no point in either growing or shrinking hash areas.\n+             * Rather, let's just cut our losses and stop canonicalizing.\n              */\n             _size = 0;\n-            Arrays.fill(_symbols, null);\n-            Arrays.fill(_buckets, null);\n+            _canonicalize = false;\n+            // in theory, could just leave these as null, but...\n+            _symbols = new String[DEFAULT_T_SIZE];\n+            _buckets = new Bucket[DEFAULT_T_SIZE>>1];\n+            _indexMask = DEFAULT_T_SIZE-1;\n             _dirty = true;\n             return;\n         }\n             }\n         }\n         _longestCollisionList = maxColl;\n+        _overflows = null;\n \n         if (count != _size) {\n             throw new Error(\"Internal error on SymbolTable.rehash(): had \"+_size+\" entries; now have \"+count+\".\");\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestHashCollisionChars.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Some unit tests to try to exercise part of parser code that\n+ * deals with symbol (table) management.\n+ */\n+public class TestHashCollisionChars\n+    extends BaseTest\n+{\n+    // // // And then a nastier variant; collisions generated using\n+    // // // CollisionGenerator\n+\n+    // for 33\n+    final static String[] MULT_COLLISION_FRAGMENTS = new String[] {\n+        // Ones generated for 33/65536...\n+        \"9fa\", \"9g@\", \":Ea\", \":F@\", \";$a\", \";%@\"\n+    };\n+\n+    // for 31\n+    /*\n+    final static String[] MULT_COLLISION_FRAGMENTS = new String[] {\n+        // Ones generated for 31/65536...\n+        \"@~~\", \"A_~\", \"A`_\", \"Aa@\", \"Ab!\", \"B@~\", // \"BA_\", \"BB@\", \"BC!\", \"C!~\"\n+    };\n+    */\n+    \n+    public void testReaderCollisions() throws Exception\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        List<String> coll = collisions();\n+        \n+        for (String field : coll) {\n+            if (sb.length() == 0) {\n+                sb.append(\"{\");\n+            } else {\n+                sb.append(\",\\n\");\n+            }\n+            sb.append('\"');\n+            sb.append(field);\n+            sb.append(\"\\\":3\");\n+        }\n+        sb.append(\"}\");\n+\n+        // First: attempt with exceptions turned on; should catch an exception\n+\n+        JsonFactory jf = new JsonFactory();\n+        JsonParser jp = jf.createParser(sb.toString());\n+        jf.enable(JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW);\n+\n+        try {\n+            while (jp.nextToken() != null) {\n+                ;\n+            }\n+            fail(\"Should have failed\");\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"hash collision\");\n+        }\n+        jp.close();\n+\n+        // but then without feature, should pass\n+        jf = new JsonFactory();\n+        jf.disable(JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW);\n+        jp = jf.createParser(sb.toString());\n+        while (jp.nextToken() != null) {\n+            ;\n+        }\n+        jp.close();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    static List<String> collisions() {\n+        // we'll get 6^4, which is bit over 1k\n+        ArrayList<String> result = new ArrayList<String>(36 * 36);\n+        \n+        final String[] FRAGMENTS = MULT_COLLISION_FRAGMENTS;\n+        \n+        for (String str1 : FRAGMENTS) {\n+            for (String str2 : FRAGMENTS) {\n+                for (String str3 : FRAGMENTS) {\n+                    for (String str4 : FRAGMENTS) {\n+                        result.add(str1+str2+str3+str4);\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper class(es)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper class to use for generating substrings to use for substring\n+     * substitution collisions.\n+     */\n+    public static class CollisionGenerator\n+    {\n+        /* JDK uses 31, but Jackson `CharsToNameCanonicalizer.HASH_MULT`,\n+         * which for 2.3 is 33.\n+         */\n+        final static int MULT = CharsToNameCanonicalizer.HASH_MULT;\n+\n+        public void generate3(int h0) {\n+          int p1 = MULT;\n+          int p0 = MULT * MULT;\n+\n+          // Generate chars in printable ASCII range\n+          \n+          final char minChar = (char) 32;\n+//        final char maxChar = (char) 127;\n+        final char maxChar = (char) 127;\n+\n+        for (char c0 = minChar; c0 <= maxChar && c0 <= h0 / p0; c0++) {\n+          int h1 = h0 - c0 * p0;\n+          for (char c1 = minChar; c1 <= maxChar && c1 <= h1 / p1; c1++) {\n+            int h2 = h1 - c1 * p1;\n+            \n+            if (h2 < minChar || h2 > maxChar) {\n+                continue;\n+            }\n+            char c2 = (char) h2;\n+            if (h2 != c2) {\n+                continue;\n+            }\n+            printString(new String(new char[] { c0, c1, c2 } ));\n+          }\n+        }\n+      }\n+\n+      void printString(String s) {\n+          //System.out.println(s.length() + \" \" + s.hashCode() + \" \" + asIntArray(s));\n+          System.out.println(s.length() + \" \" + s.hashCode() + \" \\\"\" + s + \"\\\"\");\n+      }\n+\n+      String asIntArray(String s) {\n+        StringBuilder result = new StringBuilder().append(\"[\");\n+        for (int c = 0; c < s.length(); c++) {\n+          if (c > 0) {\n+            result.append(\", \");\n+          }\n+          result.append((int) s.charAt(c));\n+        }\n+        result.append(\"]\");\n+        return result.toString();\n+      }\n+\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"<stuff>\");\n+//        new CollisionGenerator().generate3(1 << 20);\n+        new CollisionGenerator().generate3(1 << 16);\n+\n+        System.out.println();\n+        System.out.println(\"</stuff>\");\n+    }\n+}", "timestamp": 1400917627, "metainfo": ""}