{"sha": "9c9622d985ee4feb2b5f2acaad779b04f4676be4", "log": "Improving sharing/merging of symbol tables (wrt synchronization)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n \n     /*\n     /**********************************************************\n-    /* Construction, merging\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Factory method to call to create a symbol table instance with a\n-     * randomized seed value.\n-     */\n-    public static BytesToNameCanonicalizer createRoot()\n-    {\n-        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n-         * based attacks.\n-         */\n-        long now = System.currentTimeMillis();\n-        // ensure it's not 0; and might as well require to be odd so:\n-        int seed = (((int) now) + ((int) now >>> 32)) | 1;\n-        return createRoot(seed);\n-    }\n-\n-    /**\n-     * Factory method that should only be called from unit tests, where seed\n-     * value should remain the same.\n-     */\n-    protected static BytesToNameCanonicalizer createRoot(int hashSeed) {\n-        return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true, hashSeed);\n-    }\n-    \n-    /**\n-     * @param intern Whether canonical symbol Strings should be interned\n-     *   or not\n-     */\n-    public synchronized BytesToNameCanonicalizer makeChild(boolean canonicalize,\n-        boolean intern)\n-    {\n-        return new BytesToNameCanonicalizer(this, intern, _hashSeed);\n-    }\n-\n-    /**\n-     * Method called by the using code to indicate it is done\n-     * with this instance. This lets instance merge accumulated\n-     * changes into parent (if need be), safely and efficiently,\n-     * and without calling code having to know about parent\n-     * information\n-     */\n-    public void release()\n-    {\n-        if (maybeDirty() && _parent != null) {\n-            _parent.mergeChild(this);\n-            /* Let's also mark this instance as dirty, so that just in\n-             * case release was too early, there's no corruption\n-             * of possibly shared data.\n-             */\n-            markAsShared();\n-        }\n-    }\n-\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n+     * symbol tables: ones used for merging and sharing common symbols\n+     * \n+     * @param hashSize Initial hash area size\n+     * @param intern Whether Strings contained should be {@link String#intern}ed\n+     * @param seed Random seed valued used to make it more difficult to cause\n+     *   collisions (used for collision-based DoS attacks).\n+     */\n     private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed)\n     {\n         _parent = null;\n     /**\n      * Constructor used when creating a child instance\n      */\n-    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern,\n-            int seed)\n+    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed,\n+            int count, int mainHashMask,\n+            int[] mainHash, Name[] mainNames,\n+            Bucket[] collList, int collCount, int collEnd, int longestCollisionList)\n     {\n         _parent = parent;\n         _hashSeed = seed;\n         _intern = intern;\n \n-        // First, let's copy the state as is:\n-        _count = parent._count;\n-        _mainHashMask = parent._mainHashMask;\n-        _mainHash = parent._mainHash;\n-        _mainNames = parent._mainNames;\n-        _collList = parent._collList;\n-        _collCount = parent._collCount;\n-        _collEnd = parent._collEnd;\n-        _longestCollisionList = parent._longestCollisionList;\n+        // Then copy shared state\n+        _count = count;\n+        _mainHashMask = mainHashMask;\n+        _mainHash = mainHash;\n+        _mainNames = mainNames;\n+        _collList = collList;\n+        _collCount = collCount;\n+        _collEnd = collEnd;\n+        _longestCollisionList = longestCollisionList;\n+\n+        // and then set other state to reflect sharing status\n         _needRehash = false;\n-        // And consider all shared, so far:\n         _mainHashShared = true;\n         _mainNamesShared = true;\n         _collListShared = true;\n \n         _needRehash = false;\n     }\n-\n-    private synchronized void mergeChild(BytesToNameCanonicalizer child)\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, merging\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method to call to create a symbol table instance with a\n+     * randomized seed value.\n+     */\n+    public static BytesToNameCanonicalizer createRoot()\n+    {\n+        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n+         * based attacks.\n+         */\n+        long now = System.currentTimeMillis();\n+        // ensure it's not 0; and might as well require to be odd so:\n+        int seed = (((int) now) + ((int) now >>> 32)) | 1;\n+        return createRoot(seed);\n+    }\n+\n+    /**\n+     * Factory method that should only be called from unit tests, where seed\n+     * value should remain the same.\n+     */\n+    protected static BytesToNameCanonicalizer createRoot(int hashSeed) {\n+        return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true, hashSeed);\n+    }\n+    \n+    /**\n+     * Factory method used to create actual symbol table instance to\n+     * use for parsing.\n+     * \n+     * @param intern Whether canonical symbol Strings should be interned\n+     *   or not\n+     */\n+    public BytesToNameCanonicalizer makeChild(boolean canonicalize,\n+        boolean intern)\n+    {\n+        final int hashSeed;\n+        final int count;\n+        final int mainHashMask;\n+        final int[] mainHash;\n+        final Name[] mainNames;\n+        final Bucket[] collList;\n+        final int collCount;\n+        final int collEnd;\n+        final int longestCollisionList;\n+\n+        // 24-Jul-2012, tatu: Try to reduce synchronized scope, to exclude actual ctor:\n+        synchronized (this) {\n+            hashSeed = _hashSeed;\n+            count = _count;\n+            mainHashMask = _mainHashMask;\n+            mainHash = _mainHash;\n+            mainNames = _mainNames;\n+            collList = _collList;\n+            collCount = _collCount;\n+            collEnd = _collEnd;\n+            longestCollisionList = _longestCollisionList;\n+        }\n+        return new BytesToNameCanonicalizer(this, intern, hashSeed,\n+                count,mainHashMask, mainHash, mainNames,\n+                collList,collCount, collEnd, longestCollisionList);\n+    }\n+\n+    /**\n+     * Method called by the using code to indicate it is done\n+     * with this instance. This lets instance merge accumulated\n+     * changes into parent (if need be), safely and efficiently,\n+     * and without calling code having to know about parent\n+     * information\n+     */\n+    public void release()\n+    {\n+        if (maybeDirty() && _parent != null) {\n+            _parent.mergeChild(this);\n+            /* Let's also mark this instance as dirty, so that just in\n+             * case release was too early, there's no corruption\n+             * of possibly shared data.\n+             */\n+            markAsShared();\n+        }\n+    }\n+\n+    private void mergeChild(BytesToNameCanonicalizer child)\n     {\n         // Only makes sense if child has more entries\n         int childCount = child._count;\n              * thing to happen)\n              */\n             // At any rate, need to clean up the tables, then:\n-            initTables(DEFAULT_TABLE_SIZE);\n-        } else {\n+            synchronized (this) {\n+                initTables(DEFAULT_TABLE_SIZE);\n+            }\n+            return;\n+        }\n+\n+        synchronized (this) {\n             _count = child._count;\n             _longestCollisionList = child._longestCollisionList;\n             _mainHash = child._mainHash;\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n      * on which only makeChild/mergeChild are called, but instance itself\n      * is not used as a symbol table.\n      */\n-    public synchronized CharsToNameCanonicalizer makeChild(boolean canonicalize, boolean intern)\n-    {\n+    public synchronized CharsToNameCanonicalizer makeChild(final boolean canonicalize,\n+            final boolean intern)\n+    {\n+        /* 24-Jul-2012, tatu: Trying to reduce scope of synchronization, assuming\n+         *   that synchronizing construction is the (potentially) expensive part,\n+         *   and not so much short copy-the-variables thing.\n+         */\n+        final String[] symbols;\n+        final Bucket[] buckets;\n+        final int size;\n+        final int hashSeed;\n+        final int longestCollisionList;\n+        \n+        synchronized (this) {\n+            symbols = _symbols;\n+            buckets = _buckets;\n+            size = _size;\n+            hashSeed = _hashSeed;\n+            longestCollisionList = _longestCollisionList;\n+        }\n+        \n         return new CharsToNameCanonicalizer(this, canonicalize, intern,\n-                _symbols, _buckets, _size, _hashSeed, _longestCollisionList);\n+                symbols, buckets, size, hashSeed, longestCollisionList);\n     }\n \n     private CharsToNameCanonicalizer makeOrphan(int seed)\n      * Note that caller has to make sure symbol table passed in is\n      * really a child or sibling of this symbol table.\n      */\n-    private synchronized void mergeChild(CharsToNameCanonicalizer child)\n+    private void mergeChild(CharsToNameCanonicalizer child)\n     {\n         /* One caveat: let's try to avoid problems with\n          * degenerate cases of documents with generated \"random\"\n          */\n         if (child.size() > MAX_ENTRIES_FOR_REUSE\n                 || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) {\n-            /* Should there be a way to get notified about this\n-             * event, to log it or such? (as it's somewhat abnormal\n-             * thing to happen)\n-             */\n+            // Should there be a way to get notified about this event, to log it or such?\n+            // (as it's somewhat abnormal thing to happen)\n             // At any rate, need to clean up the tables, then:\n-            initTables(DEFAULT_TABLE_SIZE);\n+            synchronized (this) {\n+                initTables(DEFAULT_TABLE_SIZE);\n+                // Dirty flag... well, let's just clear it. Shouldn't really matter for master tables\n+                // (which this is, given something is merged to it)\n+                _dirty = false;\n+            }\n         } else {\n-            /* Otherwise, we'll merge changed stuff in, if there are\n-             * more entries (which may not be the case if one of siblings\n-             * has added symbols first or such)\n-             */\n+            // Otherwise, we'll merge changed stuff in, if there are  more entries (which\n+            // may not be the case if one of siblings has added symbols first or such)\n             if (child.size() <= size()) { // nothing to add\n                 return;\n             }\n             // Okie dokie, let's get the data in!\n-            _symbols = child._symbols;\n-            _buckets = child._buckets;\n-            _size = child._size;\n-            _sizeThreshold = child._sizeThreshold;\n-            _indexMask = child._indexMask;\n-            _longestCollisionList = child._longestCollisionList;\n-        }\n-        /* Dirty flag... well, let's just clear it, to force copying just\n-         * in case. Shouldn't really matter, for master tables.\n-         * (which this is, given something is merged to it etc)\n-         */\n-        _dirty = false;\n+            synchronized (this) {\n+                _symbols = child._symbols;\n+                _buckets = child._buckets;\n+                _size = child._size;\n+                _sizeThreshold = child._sizeThreshold;\n+                _indexMask = child._indexMask;\n+                _longestCollisionList = child._longestCollisionList;\n+                // Dirty flag... well, let's just clear it. Shouldn't really matter for master tables\n+                // (which this is, given something is merged to it)\n+                _dirty = false;\n+            }\n+        }\n     }\n \n     public void release()", "timestamp": 1343180223, "metainfo": ""}