{"sha": "30f0352b18c52a05e379898dc4ce77d461c9ba94", "log": "Yet better way to share/merge symbol table contents for byte-backed entries", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n package com.fasterxml.jackson.core.sym;\n \n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.util.InternCache;\n \n /**\n- * This class is basically a caching symbol table implementation used for\n- * canonicalizing {@link Name}s, constructed directly from a byte-based\n- * input source.\n+ * A caching symbol table implementation used for canonicalizing JSON field\n+ * names (as {@link Name}s which are constructed directly from a byte-based\n+ * input source).\n+ * Complications arise from trying to do efficient reuse and merging of\n+ * symbol tables, to be able to make use of usually shared vocabulary\n+ * of subsequent parsing runs.\n  *\n  * @author Tatu Saloranta\n  */\n      */\n     final static int MAX_COLL_CHAIN_FOR_REUSE  = 63;\n \n+    /**\n+     * No point in trying to construct tiny tables, just need to resize\n+     * soon.\n+     */\n     final static int MIN_HASH_SIZE = 16;\n \n+    /**\n+     * We will also need to defin\n+     */\n     final static int INITIAL_COLLISION_LEN = 32;\n \n     /**\n     /**********************************************************\n      */\n \n+    /**\n+     * Reference to the root symbol table, for child tables, so\n+     * that they can merge table information back as necessary.\n+     */\n     final protected BytesToNameCanonicalizer _parent;\n \n+    /**\n+     * Member that is only used by the root table instance: root\n+     * passes immutable state into child instances, and children\n+     * may return new state if they add entries to the table.\n+     * Child tables do NOT use the reference.\n+     */\n+    final protected AtomicReference<TableInfo> _tableInfo;\n+    \n     /**\n      * Seed value we use as the base to make hash codes non-static between\n      * different runs, but still stable for lifetime of a single symbol table\n      */\n \n     /**\n-     * Whether canonial symbol Strings are to be intern()ed before added\n+     * Whether canonical symbol Strings are to be intern()ed before added\n      * to the table or not\n      */\n-    private final boolean _intern;\n+    protected final boolean _intern;\n     \n     // // // First, global information\n \n     /**\n-     * Total number of Names in the symbol table\n-     */\n-    private int _count;\n+     * Total number of Names in the symbol table;\n+     * only used for child tables.\n+     */\n+    protected int _count;\n \n     /**\n      * We need to keep track of the longest collision list; this is needed\n      * size; essentially, hash array size - 1 (since hash array sizes\n      * are 2^N).\n      */\n-    private int _mainHashMask;\n+    protected int _mainHashMask;\n \n     /**\n      * Array of 2^N size, which contains combination\n      * and 8-bit collision bucket index (0 to indicate empty\n      * collision bucket chain; otherwise subtract one from index)\n      */\n-    private int[] _mainHash;\n+    protected int[] _mainHash;\n \n     /**\n      * Array that contains <code>Name</code> instances matching\n      * entries in <code>_mainHash</code>. Contains nulls for unused\n      * entries.\n      */\n-    private Name[] _mainNames;\n+    protected Name[] _mainNames;\n \n     // // // Then the collision/spill-over area info\n \n     /**\n      * Array of heads of collision bucket chains; size dynamically\n      */\n-    private Bucket[] _collList;\n+    protected Bucket[] _collList;\n \n     /**\n      * Total number of Names in collision buckets (included in\n      * <code>_count</code> along with primary entries)\n      */\n-    private int _collCount;\n+    protected int _collCount;\n \n     /**\n      * Index of the first unused collision bucket entry (== size of\n      * or equal to 0xFF (255), since max number of entries is 255\n      * (8-bit, minus 0 used as 'empty' marker)\n      */\n-    private int _collEnd;\n+    protected int _collEnd;\n \n     // // // Info regarding pending rehashing...\n \n                 hashSize = curr;\n             }\n         }\n-        initTables(hashSize);\n+        _tableInfo = new AtomicReference<TableInfo>(initTableInfo(hashSize));\n     }\n \n     /**\n      * Constructor used when creating a child instance\n      */\n     private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed,\n-            int count, int mainHashMask,\n-            int[] mainHash, Name[] mainNames,\n-            Bucket[] collList, int collCount, int collEnd, int longestCollisionList)\n+            TableInfo state)\n     {\n         _parent = parent;\n         _hashSeed = seed;\n         _intern = intern;\n+        _tableInfo = null; // not used by child tables\n \n         // Then copy shared state\n-        _count = count;\n-        _mainHashMask = mainHashMask;\n-        _mainHash = mainHash;\n-        _mainNames = mainNames;\n-        _collList = collList;\n-        _collCount = collCount;\n-        _collEnd = collEnd;\n-        _longestCollisionList = longestCollisionList;\n+        _count = state.count;\n+        _mainHashMask = state.mainHashMask;\n+        _mainHash = state.mainHash;\n+        _mainNames = state.mainNames;\n+        _collList = state.collList;\n+        _collCount = state.collCount;\n+        _collEnd = state.collEnd;\n+        _longestCollisionList = state.longestCollisionList;\n \n         // and then set other state to reflect sharing status\n         _needRehash = false;\n         _collListShared = true;\n     }\n \n-    private void initTables(int hashSize)\n-    {\n-        _count = 0;\n-        _longestCollisionList = 0;\n-        _mainHash = new int[hashSize];\n-        _mainNames = new Name[hashSize];\n-        _mainHashShared = false;\n-        _mainNamesShared = false;\n-        _mainHashMask = hashSize - 1;\n-\n-        _collListShared = true; // just since it'll need to be allocated\n-        _collList = null;\n-        _collEnd = 0;\n-\n-        _needRehash = false;\n+    /*\n+        public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames,\n+                Bucket[] collList, int collCount, int collEnd, int longestCollisionList)\n+     */\n+    private TableInfo initTableInfo(int hashSize)\n+    {\n+        return new TableInfo(0, // count\n+                hashSize - 1, // mainHashMask\n+                new int[hashSize], // mainHash\n+                new Name[hashSize], // mainNames\n+                null, // collList\n+                0, // collCount,\n+                0, // collEnd\n+                0 // longestCollisionList\n+        );\n     }\n     \n     /*\n     public BytesToNameCanonicalizer makeChild(boolean canonicalize,\n         boolean intern)\n     {\n-        final int hashSeed;\n-        final int count;\n-        final int mainHashMask;\n-        final int[] mainHash;\n-        final Name[] mainNames;\n-        final Bucket[] collList;\n-        final int collCount;\n-        final int collEnd;\n-        final int longestCollisionList;\n-\n-        // 24-Jul-2012, tatu: Try to reduce synchronized scope, to exclude actual ctor:\n-        synchronized (this) {\n-            hashSeed = _hashSeed;\n-            count = _count;\n-            mainHashMask = _mainHashMask;\n-            mainHash = _mainHash;\n-            mainNames = _mainNames;\n-            collList = _collList;\n-            collCount = _collCount;\n-            collEnd = _collEnd;\n-            longestCollisionList = _longestCollisionList;\n-        }\n-        return new BytesToNameCanonicalizer(this, intern, hashSeed,\n-                count,mainHashMask, mainHash, mainNames,\n-                collList,collCount, collEnd, longestCollisionList);\n+        return new BytesToNameCanonicalizer(this, intern, _hashSeed, _tableInfo.get());\n     }\n \n     /**\n      */\n     public void release()\n     {\n-        if (maybeDirty() && _parent != null) {\n-            _parent.mergeChild(this);\n+        // we will try to merge if child table has new entries\n+        if (_parent != null && maybeDirty()) {\n+            _parent.mergeChild(new TableInfo(this));\n             /* Let's also mark this instance as dirty, so that just in\n-             * case release was too early, there's no corruption\n-             * of possibly shared data.\n+             * case release was too early, there's no corruption of possibly shared data.\n              */\n-            markAsShared();\n-        }\n-    }\n-\n-    private void mergeChild(BytesToNameCanonicalizer child)\n-    {\n-        // Only makes sense if child has more entries\n-        int childCount = child._count;\n-        if (childCount <= _count) {\n+            _mainHashShared = true;\n+            _mainNamesShared = true;\n+            _collListShared = true;\n+        }\n+    }\n+\n+    private void mergeChild(TableInfo childState)\n+    {\n+        final int childCount = childState.count;\n+        TableInfo currState = _tableInfo.get();\n+        \n+        // Only makes sense if child actually has more entries\n+        if (childCount <= currState.count) {\n             return;\n         }\n \n          * One way to do this is to just purge tables if they grow\n          * too large, and that's what we'll do here.\n          */\n-        if (child.size() > MAX_ENTRIES_FOR_REUSE\n-                || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) {\n+        if (childCount > MAX_ENTRIES_FOR_REUSE\n+                || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) {\n             /* Should there be a way to get notified about this\n              * event, to log it or such? (as it's somewhat abnormal\n              * thing to happen)\n              */\n-            // At any rate, need to clean up the tables, then:\n-            synchronized (this) {\n-                initTables(DEFAULT_TABLE_SIZE);\n-            }\n-            return;\n-        }\n-\n-        synchronized (this) {\n-            _count = child._count;\n-            _longestCollisionList = child._longestCollisionList;\n-            _mainHash = child._mainHash;\n-            _mainNames = child._mainNames;\n-            _mainHashShared = true; // shouldn't matter for parent\n-            _mainNamesShared = true; // - \"\" -\n-            _mainHashMask = child._mainHashMask;\n-            _collList = child._collList;\n-            _collCount = child._collCount;\n-            _collEnd = child._collEnd;\n-        }\n-    }\n-\n-    private void markAsShared()\n-    {\n-        _mainHashShared = true;\n-        _mainNamesShared = true;\n-        _collListShared = true;\n+            // At any rate, need to clean up the tables\n+            childState = initTableInfo(DEFAULT_TABLE_SIZE);\n+        }\n+        _tableInfo.compareAndSet(currState, childState);\n     }\n \n     /*\n     /**********************************************************\n      */\n \n-    public int size() { return _count; }\n+    public int size()\n+    {\n+        if (_tableInfo != null) { // root table\n+            return _tableInfo.get().count;\n+        }\n+        // nope, child table\n+        return _count;\n+    }\n \n     /**\n      * @since 2.1\n      *   name; if less than 8 bytes, padded with up to 3 zero bytes\n      *   in front (zero MSBs, ie. right aligned)\n      *\n-     * @return Name matching the symbol passed (or constructed for\n-     *   it)\n+     * @return Name matching the symbol passed (or constructed for it)\n      */\n     public Name findName(int firstQuad, int secondQuad)\n     {\n         int hash = quads[0] ^ _hashSeed;\n         hash += (hash >>> 9);\n         hash *= MULT;\n-        int x = quads[1];\n         hash += quads[1];\n         hash *= MULT2;\n         hash += (hash >>> 15);\n     /**********************************************************\n      */\n \n+    /**\n+     * Immutable value class used for sharing information as efficiently\n+     * as possible, by only require synchronization of reference manipulation\n+     * but not access to contents.\n+     * \n+     * @since 2.1\n+     */\n+    private final static class TableInfo\n+    {\n+        public final int count;\n+        public final int mainHashMask;\n+        public final int[] mainHash;\n+        public final Name[] mainNames;\n+        public final Bucket[] collList;\n+        public final int collCount;\n+        public final int collEnd;\n+        public final int longestCollisionList;\n+\n+        public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames,\n+                Bucket[] collList, int collCount, int collEnd, int longestCollisionList)\n+        {\n+            this.count = count;\n+            this.mainHashMask = mainHashMask;\n+            this.mainHash = mainHash;\n+            this.mainNames = mainNames;\n+            this.collList = collList;\n+            this.collCount = collCount;\n+            this.collEnd = collEnd;\n+            this.longestCollisionList = longestCollisionList;\n+        }\n+\n+        public TableInfo(BytesToNameCanonicalizer src)\n+        {\n+            count = src._count;\n+            mainHashMask = src._mainHashMask;\n+            mainHash = src._mainHash;\n+            mainNames = src._mainNames;\n+            collList = src._collList;\n+            collCount = src._collCount;\n+            collEnd = src._collEnd;\n+            longestCollisionList = src._longestCollisionList;\n+        }\n+    \n+    }\n+    \n+    /**\n+     * \n+     */\n     final static class Bucket\n     {\n         protected final Name _name;\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n         final int A_BYTES = 0x41414141; // \"AAAA\"\n         final int B_BYTES = 0x42424242; // \"BBBB\"\n \n-        BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot();\n+        BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot()\n+                .makeChild(true, true);\n         assertNull(nc.findName(A_BYTES));\n         assertNull(nc.findName(A_BYTES, B_BYTES));\n ", "timestamp": 1343197550, "metainfo": ""}