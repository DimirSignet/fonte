{"sha": "eaa2b0c4797e04b10d9c26f18e75da532e9b6439", "log": "Fixed #102", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n         // Also: first char must be a valid name char, but NOT be number\n         boolean firstOk;\n \n-        if (i < maxCode) { // identifier, and not a number\n-            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n+        if (i < maxCode) { // identifier, or a number ([Issue#102])\n+            firstOk = (codes[i] == 0);\n         } else {\n             firstOk = Character.isJavaIdentifierPart((char) i);\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             return _nextTokenNotInObject(i);\n         }\n         // So first parse the field name itself:\n-        Name n = _parseFieldName(i);\n+        Name n = _parseName(i);\n         _parsingContext.setCurrentName(n.getName());\n         _currToken = JsonToken.FIELD_NAME;\n \n     {\n         // // // and this is back to standard nextToken()\n             \n-        Name n = _parseFieldName(i);\n+        Name n = _parseName(i);\n         final boolean match;\n         {\n             String nameStr = n.getName();\n     /**********************************************************\n      */\n     \n-    protected Name _parseFieldName(int i)\n-        throws IOException, JsonParseException\n+    protected Name _parseName(int i) throws IOException\n     {\n         if (i != INT_QUOTE) {\n             return _handleOddName(i);\n         return parseName(0, q, 0); // quoting or invalid char\n     }\n \n-    protected Name parseMediumName(int q2, final int[] codes)\n-        throws IOException, JsonParseException\n+    protected Name parseMediumName(int q2, final int[] codes) throws IOException\n     {\n         // Ok, got 5 name bytes so far\n         int i = _inputBuffer[_inputPtr++] & 0xFF;\n         return parseLongName(i);\n     }\n \n-    protected Name parseLongName(int q)\n-        throws IOException, JsonParseException\n+    protected Name parseLongName(int q) throws IOException\n     {\n         // As explained above, will ignore UTF-8 encoding at this point\n         final int[] codes = _icLatin1;\n      * to come consequtively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n-    protected Name slowParseName()\n-        throws IOException, JsonParseException\n+    protected Name slowParseName() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n         return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n     }\n \n-    private Name parseName(int q1, int ch, int lastQuadBytes)\n-        throws IOException, JsonParseException\n+    private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException\n     {\n         return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n     }\n \n-    private Name parseName(int q1, int q2, int ch, int lastQuadBytes)\n-        throws IOException, JsonParseException\n+    private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException\n     {\n         _quadBuffer[0] = q1;\n         return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n      * slower, and hance is offlined to a separate method.\n      */\n     protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n-            int currQuadBytes)\n-        throws IOException, JsonParseException\n+            int currQuadBytes) throws IOException\n     {\n         /* 25-Nov-2008, tatu: This may seem weird, but here we do\n          *   NOT want to worry about UTF-8 decoding. Rather, we'll\n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n      */\n-    protected Name _handleOddName(int ch)\n-        throws IOException, JsonParseException\n+    protected Name _handleOddName(int ch) throws IOException\n     {\n         // [JACKSON-173]: allow single quotes\n         if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n      * for valid JSON -- more alternatives, more code, generally\n      * bit slower execution.\n      */\n-    protected Name _parseAposName()\n-        throws IOException, JsonParseException\n+    protected Name _parseAposName() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n {\n     // // // And then tests to verify [JACKSON-69]:\n \n-    public void testSimpleUnquoted() throws Exception\n-    {\n+    public void testSimpleUnquotedBytes() throws Exception {\n+        _testSimpleUnquoted(true);\n+    }\n+\n+    public void testSimpleUnquotedChars() throws Exception {\n         _testSimpleUnquoted(false);\n-        _testSimpleUnquoted(true);\n-    }\n-\n+    }\n+    \n     public void testLargeUnquoted() throws Exception\n     {\n         _testLargeUnquoted(false);\n     \n     private void _testSimpleUnquoted(boolean useStream) throws Exception\n     {\n-        final String JSON = \"{ a : 1, _foo:true, $:\\\"money!\\\", \\\" \\\":null }\";\n-        JsonFactory f = new JsonFactory();\n+        final JsonFactory f = new JsonFactory();\n         f.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n+\n+        String JSON = \"{ a : 1, _foo:true, $:\\\"money!\\\", \\\" \\\":null }\";\n         JsonParser jp = useStream ?\n             createParserUsingStream(f, JSON, \"UTF-8\")\n             : createParserUsingReader(f, JSON)\n         assertEquals(\" \", jp.getCurrentName());\n \n         assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        jp.close();\n+\n+        // Another thing, as per [Issue#102]: numbers\n+\n+        JSON = \"{ 123:true,4:false }\";\n+        jp = useStream ?\n+            createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON)\n+        ;\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"123\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"4\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n \n         assertToken(JsonToken.END_OBJECT, jp.nextToken());\n         jp.close();", "timestamp": 1379788793, "metainfo": ""}