{"sha": "c088f8432aa8305e5512aa20431f1755872179ca", "log": "...", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic parser\n+ * functionality works as expected.\n+ */\n+public class TestNumericValues\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSimpleInt()\n+        throws Exception\n+    {\n+        int EXP_I = 1234;\n+\n+        JsonParser jp = createParserUsingReader(\"[ \"+EXP_I+\" ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(JsonParser.NumberType.INT, jp.getNumberType());\n+        assertEquals(\"\"+EXP_I, jp.getText());\n+\n+        assertEquals(EXP_I, jp.getIntValue());\n+        assertEquals((long) EXP_I, jp.getLongValue());\n+        assertEquals((double) EXP_I, jp.getDoubleValue());\n+        assertEquals(BigDecimal.valueOf((long) EXP_I), jp.getDecimalValue());\n+    }\n+\n+    public void testIntRange()\n+        throws Exception\n+    {\n+        // let's test with readers and streams, separate code paths:\n+        for (int i = 0; i < 2; ++i) {\n+            String input = \"[ \"+Integer.MAX_VALUE+\",\"+Integer.MIN_VALUE+\" ]\";\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.INT, jp.getNumberType());\n+            assertEquals(Integer.MAX_VALUE, jp.getIntValue());\n+    \n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.INT, jp.getNumberType());\n+            assertEquals(Integer.MIN_VALUE, jp.getIntValue());\n+        }\n+    }\n+    \n+    public void testInvalidIntAccess()\n+        throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ \\\"abc\\\" ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        try {\n+            jp.getIntValue();\n+            fail(\"Expected error trying to call getIntValue on non-numeric value\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"can not use numeric value accessors\");\n+        }\n+    }\n+\n+    public void testSimpleLong()\n+        throws Exception\n+    {\n+        long EXP_L = 12345678907L;\n+\n+        JsonParser jp = createParserUsingReader(\"[ \"+EXP_L+\" ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        // beyond int, should be long\n+        assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+        assertEquals(\"\"+EXP_L, jp.getText());\n+\n+        assertEquals(EXP_L, jp.getLongValue());\n+        // Should get an exception if trying to convert to int \n+        try {\n+            jp.getIntValue();\n+        } catch (JsonParseException jpe) {\n+            verifyException(jpe, \"out of range\");\n+        }\n+        assertEquals((double) EXP_L, jp.getDoubleValue());\n+        assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue());\n+    }\n+\n+    public void testLongRange()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 2; ++i) {\n+            long belowMinInt = -1L + Integer.MIN_VALUE;\n+            long aboveMaxInt = 1L + Integer.MAX_VALUE;\n+            String input = \"[ \"+Long.MAX_VALUE+\",\"+Long.MIN_VALUE+\",\"+aboveMaxInt+\", \"+belowMinInt+\" ]\";\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+            assertEquals(Long.MAX_VALUE, jp.getLongValue());\n+        \n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+            assertEquals(Long.MIN_VALUE, jp.getLongValue());\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+            assertEquals(aboveMaxInt, jp.getLongValue());\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+            assertEquals(belowMinInt, jp.getLongValue());\n+\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());        \n+            jp.close();\n+        }\n+    }\n+\n+    public void testBigDecimalRange()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 2; ++i) {\n+            // let's test first values outside of Long range\n+            BigInteger small = new BigDecimal(Long.MIN_VALUE).toBigInteger();\n+            small = small.subtract(BigInteger.ONE);\n+            BigInteger big = new BigDecimal(Long.MAX_VALUE).toBigInteger();\n+            big = big.add(BigInteger.ONE);\n+            String input = \"[ \"+small+\"  ,  \"+big+\"]\";\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType());\n+            assertEquals(small, jp.getBigIntegerValue());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType());\n+            assertEquals(big, jp.getBigIntegerValue());\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());        \n+            jp.close();\n+        }\n+}\n+    \n+    public void testSimpleDouble()\n+        throws Exception\n+    {\n+        final String[] INPUTS = new String[] {\n+            \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\"\n+        };\n+        for (int input = 0; input < 2; ++input) {\n+            for (int i = 0; i < INPUTS.length; ++i) {\n+\n+                /* Testing double is more difficult, given the rounding\n+                 * errors and such. But let's try anyways.\n+                 */\n+                String STR = INPUTS[i];\n+                double EXP_D = Double.parseDouble(STR);\n+                String DOC = \"[\"+STR+\"]\";\n+                \n+                JsonParser jp;\n+                \n+                if (input == 0) {\n+                    jp = createParserUsingStream(DOC, \"UTF-8\");\n+                } else {\n+                    jp = createParserUsingReader(DOC);\n+                }\n+                assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+                assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+                assertEquals(STR, jp.getText());\n+                assertEquals(EXP_D, jp.getDoubleValue());\n+                assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+                jp.close();\n+            }\n+        }\n+    }\n+\n+    public void testNumbers() throws Exception\n+    {\n+        final String DOC = \"[ -13, 8100200300, 13.5, 0.00010, -2.033 ]\";\n+\n+        for (int input = 0; input < 2; ++input) {\n+            JsonParser jp;\n+\n+            if (input == 0) {\n+                jp = createParserUsingStream(DOC, \"UTF-8\");\n+            } else {\n+                jp = createParserUsingReader(DOC);\n+            }\n+\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(-13, jp.getIntValue());\n+            assertEquals(-13L, jp.getLongValue());\n+            assertEquals(-13., jp.getDoubleValue());\n+            assertEquals(\"-13\", jp.getText());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(8100200300L, jp.getLongValue());\n+            // Should get exception for overflow:\n+            try {\n+                /*int x =*/ jp.getIntValue();\n+                fail(\"Expected an exception for overflow\");\n+            } catch (Exception e) {\n+                verifyException(e, \"out of range of int\");\n+            }\n+            assertEquals(8100200300., jp.getDoubleValue());\n+            assertEquals(\"8100200300\", jp.getText());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(13, jp.getIntValue());\n+            assertEquals(13L, jp.getLongValue());\n+            assertEquals(13.5, jp.getDoubleValue());\n+            assertEquals(\"13.5\", jp.getText());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(0, jp.getIntValue());\n+            assertEquals(0L, jp.getLongValue());\n+            assertEquals(0.00010, jp.getDoubleValue());\n+            assertEquals(\"0.00010\", jp.getText());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(-2, jp.getIntValue());\n+            assertEquals(-2L, jp.getLongValue());\n+            assertEquals(-2.033, jp.getDoubleValue());\n+            assertEquals(\"-2.033\", jp.getText());\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testLongOverflow() throws Exception\n+    {\n+        BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);\n+        below = below.subtract(BigInteger.ONE);\n+        BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);\n+        above = above.add(BigInteger.ONE);\n+\n+        String DOC_BELOW = below.toString() + \" \";\n+        String DOC_ABOVE = below.toString() + \" \";\n+        for (int input = 0; input < 2; ++input) {\n+            JsonParser jp;\n+\n+            if (input == 0) {\n+                jp = createParserUsingStream(DOC_BELOW, \"UTF-8\");\n+            } else {\n+                jp = createParserUsingReader(DOC_BELOW);\n+            }\n+            jp.nextToken();\n+            try {\n+                long x = jp.getLongValue();\n+                fail(\"Expected an exception for underflow (input \"+jp.getText()+\"): instead, got long value: \"+x);\n+            } catch (JsonParseException e) {\n+                verifyException(e, \"out of range of long\");\n+            }\n+            jp.close();\n+\n+            if (input == 0) {\n+                jp = createParserUsingStream(DOC_ABOVE, \"UTF-8\");\n+            } else {\n+                jp = createParserUsingReader(DOC_ABOVE);\n+            }\n+            jp.nextToken();\n+            try {\n+                long x = jp.getLongValue();\n+                fail(\"Expected an exception for underflow (input \"+jp.getText()+\"): instead, got long value: \"+x);\n+            } catch (JsonParseException e) {\n+                verifyException(e, \"out of range of long\");\n+            }\n+            jp.close();\n+            \n+        }\n+    }\n+    \n+    /**\n+     * Method that tries to test that number parsing works in cases where\n+     * input is split between buffer boundaries.\n+     */\n+    public void testParsingOfLongerSequences()\n+        throws Exception\n+    {\n+        double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 };\n+        StringBuilder sb = new StringBuilder();\n+\n+        for (int i = 0; i < values.length; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(values[i]);\n+        }\n+        String segment = sb.toString();\n+\n+        int COUNT = 1000;\n+        sb = new StringBuilder(COUNT * segment.length() + 20);\n+        sb.append(\"[\");\n+        for (int i = 0; i < COUNT; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(segment);\n+            sb.append('\\n');\n+            // let's add somewhat arbitray number of spaces\n+            int x = (i & 3);\n+            if (i > 300) {\n+                x += i % 5;\n+            }\n+            while (--x > 0) {\n+                sb.append(' ');\n+            }\n+        }\n+        sb.append(\"]\");\n+        String DOC = sb.toString();\n+\n+        for (int input = 0; input < 2; ++input) {\n+            JsonParser jp;\n+\n+            if (input == 0) {\n+                jp = createParserUsingStream(DOC, \"UTF-8\");\n+            } else {\n+                jp = createParserUsingReader(DOC);\n+            }\n+\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            for (int i = 0; i < COUNT; ++i) {\n+                for (double d : values) {\n+                    assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+                    assertEquals(d, jp.getDoubleValue());\n+                }\n+            }\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* New tests for 1.3 features\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleBoolean()\n+        throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ true ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertEquals(true, jp.getBooleanValue());\n+    }\n+\n+    public void testInvalidBooleanAccess()\n+        throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ \\\"abc\\\" ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        try {\n+            jp.getBooleanValue();\n+            fail(\"Expected error trying to call getBooleanValue on non-boolean value\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"not of boolean type\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/misc/TestExceptions.java\n+package com.fasterxml.jackson.core.misc;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+public class TestExceptions extends BaseTest\n+{\n+    // For [Issue#10]\n+    public void testOriginalMesssage()\n+    {\n+        JsonProcessingException exc = new JsonParseException(\"Foobar\", JsonLocation.NA);\n+        String msg = exc.getMessage();\n+        String orig = exc.getOriginalMessage();\n+        assertEquals(\"Foobar\", orig);\n+        assertTrue(msg.length() > orig.length());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/misc/TestJDKSerializability.java\n+package com.fasterxml.jackson.core.misc;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.Base64Variant;\n+import com.fasterxml.jackson.core.Base64Variants;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.PrettyPrinter;\n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Unit tests for [Issue#31] (https://github.com/FasterXML/jackson-core/issues/31)\n+ */\n+public class TestJDKSerializability extends BaseTest\n+{\n+    public void testJsonFactorySerializable() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        String origJson = \"{\\\"simple\\\":[1,true,{}]}\";\n+        assertEquals(origJson, _copyJson(f, origJson, false));\n+\n+        // Ok: freeze dry factory, thaw, and try to use again:\n+        byte[] frozen = jdkSerialize(f);\n+        JsonFactory f2 = jdkDeserialize(frozen);\n+        assertNotNull(f2);\n+        assertEquals(origJson, _copyJson(f2, origJson, false));\n+\n+        // Let's also try byte-based variant, for fun...\n+        assertEquals(origJson, _copyJson(f2, origJson, true));\n+    }\n+\n+    public void testBase64Variant() throws Exception\n+    {\n+        Base64Variant orig = Base64Variants.PEM;\n+        byte[] stuff = jdkSerialize(orig);\n+        Base64Variant back = jdkDeserialize(stuff);\n+        assertSame(orig, back);\n+    }\n+\n+    public void testPrettyPrinter() throws Exception\n+    {\n+        PrettyPrinter p = new DefaultPrettyPrinter();\n+        byte[] stuff = jdkSerialize(p);\n+        PrettyPrinter back = jdkDeserialize(stuff);\n+        // what should we test?\n+        assertNotNull(back);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected byte[] jdkSerialize(Object o) throws IOException\n+    {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream(1000);\n+        ObjectOutputStream obOut = new ObjectOutputStream(bytes);\n+        obOut.writeObject(o);\n+        obOut.close();\n+        return bytes.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T jdkDeserialize(byte[] raw) throws IOException\n+    {\n+        ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(raw));\n+        try {\n+            return (T) objIn.readObject();\n+        } catch (ClassNotFoundException e) {\n+            fail(\"Missing class: \"+e.getMessage());\n+            return null;\n+        } finally {\n+            objIn.close();\n+        }\n+    }\n+    \n+    protected String _copyJson(JsonFactory f, String json, boolean useBytes) throws IOException\n+    {\n+        if (useBytes) {\n+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            JsonGenerator jg = f.createGenerator(bytes);\n+            _copyJson(f, json, jg);\n+            return bytes.toString(\"UTF-8\");\n+        }\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = f.createGenerator(sw);\n+        _copyJson(f, json, jg);\n+        return sw.toString();\n+    }\n+        \n+    protected void _copyJson(JsonFactory f, String json, JsonGenerator jg) throws IOException\n+    {\n+        JsonParser jp = f.createParser(json);\n+        while (jp.nextToken() != null) {\n+            jg.copyCurrentEvent(jp);\n+        }\n+        jp.close();\n+        jg.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/misc/TestVersions.java\n+package com.fasterxml.jackson.core.misc;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.json.*;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+\n+/**\n+ * Tests to verify [JACKSON-278]\n+ */\n+public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testCoreVersions() throws Exception\n+    {\n+        assertVersion(new JsonFactory().version());\n+        JsonParser jp = new ReaderBasedJsonParser(getIOContext(), 0, null, null,\n+                CharsToNameCanonicalizer.createRoot());\n+        assertVersion(jp.version());\n+        jp.close();\n+        JsonGenerator jgen = new WriterBasedJsonGenerator(getIOContext(), 0, null, null);\n+        assertVersion(jgen.version());\n+        jgen.close();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private void assertVersion(Version v)\n+    {\n+        assertEquals(PackageVersion.VERSION, v);\n+    }\n+\n+    private IOContext getIOContext() {\n+        return new IOContext(new BufferRecycler(), null, false);\n+    }\n+}\n+", "timestamp": 1370550049, "metainfo": ""}