{"sha": "2574bd6816039d77ab0caee0c6c108141bb92f62", "log": "Make ReaderBasedJsonParser non-final, to allow sub-classing (but keep most critical path methods final, can relax as needed)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n  * based on a {@link java.io.Reader} to handle low-level character\n  * conversion tasks.\n  */\n-public final class ReaderBasedJsonParser\n+public class ReaderBasedJsonParser // final in 2.3, earlier\n     extends ParserBase\n {\n     // Latin1 encoding is not supported, but we do use 8-bit subset for\n      * Method can be called for any event.\n      */\n     @Override\n-    public String getText() throws IOException\n+    public final String getText() throws IOException\n     {\n         JsonToken t = _currToken;\n         if (t == JsonToken.VALUE_STRING) {\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString() throws IOException\n+    public final String getValueAsString() throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString(String defValue) throws IOException {\n+    public final String getValueAsString(String defValue) throws IOException {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n         return super.getValueAsString(defValue);\n     }\n \n-    protected String _getText2(JsonToken t) {\n+    protected final String _getText2(JsonToken t) {\n         if (t == null) {\n             return null;\n         }\n     }\n \n     @Override\n-    public char[] getTextCharacters() throws IOException\n+    public final char[] getTextCharacters() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextLength() throws IOException\n+    public final int getTextLength() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextOffset() throws IOException\n+    public final int getTextOffset() throws IOException\n     {\n         // Most have offset of 0, only some may have other values:\n         if (_currToken != null) {\n      *   to indicate end-of-input\n      */\n     @Override\n-    public JsonToken nextToken() throws IOException\n+    public final JsonToken nextToken() throws IOException\n     {\n         _numTypesValid = NR_UNKNOWN;\n \n         return t;\n     }\n \n-    private JsonToken _nextAfterName()\n+    private final JsonToken _nextAfterName()\n     {\n         _nameCopied = false; // need to invalidate if it was copied\n         JsonToken t = _nextToken;\n \n     // note: identical to one in UTF8StreamJsonParser\n     @Override\n-    public String nextTextValue() throws IOException\n+    public final String nextTextValue() throws IOException\n     {\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n             _nameCopied = false;\n \n     // note: identical to one in Utf8StreamParser\n     @Override\n-    public int nextIntValue(int defaultValue) throws IOException\n+    public final int nextIntValue(int defaultValue) throws IOException\n     {\n         if (_currToken == JsonToken.FIELD_NAME) {\n             _nameCopied = false;\n \n     // note: identical to one in Utf8StreamParser\n     @Override\n-    public long nextLongValue(long defaultValue) throws IOException\n+    public final long nextLongValue(long defaultValue) throws IOException\n     {\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n             _nameCopied = false;\n \n     // note: identical to one in UTF8StreamJsonParser\n     @Override\n-    public Boolean nextBooleanValue() throws IOException\n+    public final Boolean nextBooleanValue() throws IOException\n     {\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n             _nameCopied = false;\n      * deferred, since it is usually the most complicated and costliest\n      * part of processing.\n      */\n-    protected JsonToken _parseNumber(int ch) throws IOException\n+    protected final JsonToken _parseNumber(int ch) throws IOException\n     {\n         /* Although we will always be complete with respect to textual\n          * representation (that is, all characters will be parsed),\n      * that it has to explicitly copy contents to the text buffer\n      * instead of just sharing the main input buffer.\n      */\n-    private JsonToken _parseNumber2(boolean neg) throws IOException\n+    private final JsonToken _parseNumber2(boolean neg) throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n      * Method called when we have seen one zero, and want to ensure\n      * it is not followed by another\n      */\n-    private char _verifyNoLeadingZeroes() throws IOException\n-    {\n-        // Ok to have plain \"0\"\n+    private final char _verifyNoLeadingZeroes() throws IOException\n+    {\n+        // Fast case first:\n+        if (_inputPtr < _inputEnd) {\n+            char ch = _inputBuffer[_inputPtr];\n+            // if not followed by a number (probably '.'); return zero as is, to be included\n+            if (ch < '0' || ch > '9') {\n+                return '0';\n+            }\n+        }\n+        // and offline the less common case\n+        return _verifyNLZ2();\n+    }\n+        \n+    private char _verifyNLZ2() throws IOException\n+    {\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n             return '0';\n         }\n         char ch = _inputBuffer[_inputPtr];\n-        // if not followed by a number (probably '.'); return zero as is, to be included\n         if (ch < '0' || ch > '9') {\n             return '0';\n         }\n     /**********************************************************\n      */\n \n-    protected String _parseName(int i) throws IOException\n+    protected final String _parseName(int i) throws IOException\n     {\n         if (i != INT_QUOTE) { return _handleOddName(i); }\n \n     }\n   \n     @Override\n-    protected void _finishString() throws IOException\n+    protected final void _finishString() throws IOException\n     {\n         /* First: let's try to see if we have simple String value: one\n          * that does not cross input buffer boundary, and does not\n      * if it is not needed. This can be done bit faster if contents\n      * need not be stored for future access.\n      */\n-    protected void _skipString() throws IOException\n+    protected final void _skipString() throws IOException\n     {\n         _tokenIncomplete = false;\n \n      * We actually need to check the character value here\n      * (to see if we have \\n following \\r).\n      */\n-    protected void _skipCR() throws IOException {\n+    protected final void _skipCR() throws IOException {\n         if (_inputPtr < _inputEnd || loadMore()) {\n             if (_inputBuffer[_inputPtr] == '\\n') {\n                 ++_inputPtr;\n     }\n \n     /*\n-    private int _skipCR(int ptr) throws IOException {\n+    private final int _skipCR(int ptr) throws IOException {\n         if (ptr < _inputEnd) {\n             if (_inputBuffer[ptr] == '\\n') {\n                 ++ptr;\n     }\n     */\n     \n-    private int _skipColon() throws IOException\n+    private final int _skipColon() throws IOException\n     {\n         if ((_inputPtr + 4) >= _inputEnd) {\n             return _skipColon2(false);\n         return _skipColon2(false);\n     }\n \n-    private int _skipColon2(boolean gotColon) throws IOException\n+    private final int _skipColon2(boolean gotColon) throws IOException\n     {\n         final int[] codes = _icWS;\n         while (true) {\n         }\n     }\n     \n-    private int _skipComma(int i) throws IOException\n+    private final int _skipComma(int i) throws IOException\n     {\n         if (i != INT_COMMA) {\n             _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n         return _skipAfterComma();\n     }\n \n-    private int _skipAfterComma() throws IOException\n+    private final int _skipAfterComma() throws IOException\n     {\n         final int[] codes = _icWS;\n         while (_inputPtr < _inputEnd || loadMore()) {\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n     \n-    private int _skipWSOrEnd() throws IOException\n+    private final int _skipWSOrEnd() throws IOException\n     {\n         final int[] codes = _icWS;\n         while (_inputPtr < _inputEnd) {\n     /**\n      * Helper method for checking whether input matches expected token\n      */\n-    protected void _matchToken(String matchStr, int i) throws IOException\n+    protected final void _matchToken(String matchStr, int i) throws IOException\n     {\n         final int len = matchStr.length();\n ", "timestamp": 1398739149, "metainfo": ""}