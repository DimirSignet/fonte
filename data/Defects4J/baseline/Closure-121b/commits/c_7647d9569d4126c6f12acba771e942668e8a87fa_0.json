{"sha": "7647d9569d4126c6f12acba771e942668e8a87fa", "log": "Add an options for transforming source map file locations  R=mwr DELTA=224  (201 added, 2 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2613   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     // Create the source map if necessary.\n     if (options.sourceMapOutputPath != null) {\n       sourceMap = options.sourceMapFormat.getInstance();\n+      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n     }\n   }\n \n \n   /** Add a source input dynamically. Intended for incremental compilation. */\n   void addIncrementalSourceAst(JsAst ast) {\n-    String sourceName = ast.getSourceFile().getName();\n+    String intputName = ast.getSourceFile().getName();\n     Preconditions.checkState(\n-        getInput(sourceName) == null,\n-        \"Duplicate input of name \" + sourceName);\n-    inputsByName.put(sourceName, new CompilerInput(ast));\n+        getInput(intputName) == null,\n+        \"Duplicate input of name \" + intputName);\n+    inputsByName.put(intputName, new CompilerInput(ast));\n   }\n \n   /**\n    * @return Whether the new AST was attached successfully.\n    */\n   boolean replaceIncrementalSourceAst(JsAst ast) {\n-    String sourceName = ast.getSourceFile().getName();\n+    String inputName = ast.getSourceFile().getName();\n     CompilerInput oldInput =\n         Preconditions.checkNotNull(\n-            getInput(sourceName),\n-            \"No input to replace: \" + sourceName);\n+            getInput(inputName),\n+            \"No input to replace: \" + inputName);\n     Node newRoot = ast.getAstRoot(this);\n     if (newRoot == null) {\n       return false;\n     }\n \n     CompilerInput newInput = new CompilerInput(ast);\n-    inputsByName.put(sourceName, newInput);\n+    inputsByName.put(inputName, newInput);\n \n     JSModule module = oldInput.getModule();\n     if (module != null) {\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   /** The source map file format */\n   public SourceMap.Format sourceMapFormat =\n       SourceMap.Format.DEFAULT;\n+\n+  public List<SourceMap.LocationMapping> sourceMapLocationMappings =\n+      Collections.emptyList();\n \n   /**\n    * Charset to use when generating code.  If null, then output ASCII.\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Predicate;\n+import com.google.common.collect.Maps;\n import com.google.debugging.sourcemap.FilePosition;\n import com.google.debugging.sourcemap.SourceMapFormat;\n import com.google.debugging.sourcemap.SourceMapGenerator;\n import com.google.javascript.rhino.Node;\n \n import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Collects information mapping the generated (compiled) source back to\n     };\n   }\n \n-  final SourceMapGenerator generator;\n+  public static class LocationMapping {\n+    final String prefix;\n+    final String replacement;\n+    LocationMapping(String prefix, String replacement) {\n+      this.prefix = prefix;\n+      this.replacement = replacement;\n+    }\n+  }\n+\n+  private final SourceMapGenerator generator;\n+  private List<LocationMapping> prefixMappings = Collections.emptyList();\n+  private final Map<String, String> sourceLocationFixupCache =\n+      Maps.newHashMap();\n \n   private SourceMap(SourceMapGenerator generator) {\n     this.generator = generator;\n       FilePosition outputStartPosition,\n       FilePosition outputEndPosition) {\n     String sourceFile = node.getSourceFileName();\n+\n     // If the node does not have an associated source file or\n     // its line number is -1, then the node does not have sufficient\n     // information for a mapping to be useful.\n     if (sourceFile == null || node.getLineno() < 0) {\n       return;\n     }\n+\n+    sourceFile = fixupSourceLocation(sourceFile);\n \n     String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n \n         outputStartPosition, outputEndPosition);\n   }\n \n+  /**\n+   * @param sourceFile The source file location to fixup.\n+   * @return a remapped source file.\n+   */\n+  private String fixupSourceLocation(String sourceFile) {\n+    if (prefixMappings.isEmpty()) {\n+      return sourceFile;\n+    }\n+\n+    String fixed = sourceLocationFixupCache.get(sourceFile);\n+    if (fixed != null) {\n+      return fixed;\n+    }\n+\n+    // Replace the first prefix found with its replacement\n+    for (LocationMapping mapping : prefixMappings) {\n+      if (sourceFile.startsWith(mapping.prefix)) {\n+        fixed = mapping.replacement + sourceFile.substring(\n+          mapping.prefix.length());\n+        break;\n+      }\n+    }\n+\n+    sourceLocationFixupCache.put(sourceFile, fixed);\n+    return fixed;\n+  }\n+\n   public void appendTo(Appendable out, String name) throws IOException {\n     generator.appendTo(out, name);\n   }\n \n   public void reset() {\n     generator.reset();\n+    sourceLocationFixupCache.clear();\n   }\n \n   public void setStartingPosition(int offsetLine, int offsetIndex) {\n   public void validate(boolean validate) {\n     generator.validate(validate);\n   }\n+\n+  /**\n+   * @param sourceMapLocationMappings\n+   */\n+  public void setPrefixMappings(List<LocationMapping> sourceMapLocationMappings) {\n+     this.prefixMappings = sourceMapLocationMappings;\n+  }\n }\n--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV1Test.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV1Test.java\n public class SourceMapGeneratorV1Test extends SourceMapTestCase {\n \n   @Override\n-  SourceMapConsumer getSourceMapConsumer() {\n+  protected SourceMapConsumer getSourceMapConsumer() {\n     return new SourceMapConsumerV1();\n   }\n \n   @Override\n-  Format getSourceMapFormat() {\n+  protected Format getSourceMapFormat() {\n     return SourceMap.Format.V1;\n   }\n \n--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV2Test.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV2Test.java\n public class SourceMapGeneratorV2Test extends SourceMapTestCase {\n \n   @Override\n-  SourceMapConsumer getSourceMapConsumer() {\n+  protected SourceMapConsumer getSourceMapConsumer() {\n     return new SourceMapConsumerV2();\n   }\n \n   @Override\n-  Format getSourceMapFormat() {\n+  protected Format getSourceMapFormat() {\n     return SourceMap.Format.V2;\n   }\n \n--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java\n public class SourceMapGeneratorV3Test extends SourceMapTestCase {\n \n   @Override\n-  SourceMapConsumer getSourceMapConsumer() {\n+  protected SourceMapConsumer getSourceMapConsumer() {\n     return new SourceMapConsumerV3();\n   }\n \n   @Override\n-  Format getSourceMapFormat() {\n+  protected Format getSourceMapFormat() {\n     return SourceMap.Format.V3;\n   }\n \n--- a/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n     return tokens;\n   }\n \n-  abstract SourceMap.Format getSourceMapFormat();\n-\n-  abstract SourceMapConsumer getSourceMapConsumer();\n+  abstract protected SourceMap.Format getSourceMapFormat();\n+\n+  abstract protected SourceMapConsumer getSourceMapConsumer();\n \n   protected void compileAndCheck(String js) {\n     String inputName = \"testcode\";\n     return compile(js, fileName, null, null);\n   }\n \n-  protected RunResult compile(\n-      String js1, String fileName1, String js2, String fileName2) {\n-    Compiler compiler = new Compiler();\n+  protected CompilerOptions getCompilerOptions() {\n     CompilerOptions options = new CompilerOptions();\n     options.sourceMapOutputPath = \"testcode_source_map.out\";\n     options.sourceMapFormat = getSourceMapFormat();\n     options.sourceMapDetailLevel = detailLevel;\n+    return options;\n+  }\n+\n+  protected RunResult compile(\n+      String js1, String fileName1, String js2, String fileName2) {\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = getCompilerOptions();\n \n     // Turn on IDE mode to get rid of optimizations.\n     options.ideMode = true;\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/SourceMapTest.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.debugging.sourcemap.SourceMapConsumer;\n+import com.google.debugging.sourcemap.SourceMapConsumerV2;\n+import com.google.debugging.sourcemap.SourceMapTestCase;\n+import com.google.javascript.jscomp.SourceMap.Format;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMapTest extends SourceMapTestCase {\n+\n+  private List<SourceMap.LocationMapping> mappings;\n+\n+  public void testPrefixReplacement1() throws IOException {\n+    mappings = new ArrayList<SourceMap.LocationMapping>();\n+    // mapping can be used to remove a prefix\n+    mappings.add( new SourceMap.LocationMapping(\"pre/\",\"\") );\n+    checkSourceMap2(\"\", \"pre/file1\", \"\", \"pre/file2\" , \"{\\n\" +\n+        \"\\\"version\\\":2,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":1,\\n\" +\n+        \"\\\"lineMaps\\\":[\\\"\\\"],\\n\" +\n+        \"\\\"mappings\\\":[],\\n\" +\n+        \"\\\"sources\\\":[\\\"file1\\\",\\\"file2\\\"],\\n\" +\n+        \"\\\"names\\\":[]\\n\" +\n+        \"}\\n\");\n+  }\n+\n+    public void testPrefixReplacement2() throws IOException {\n+    mappings = new ArrayList<SourceMap.LocationMapping>();\n+    // mapping can be used to replace a prefix\n+    mappings.add( new SourceMap.LocationMapping(\"pre/file\",\"src\") );\n+    checkSourceMap2(\"\", \"pre/file1\", \"\", \"pre/file2\" , \"{\\n\" +\n+        \"\\\"version\\\":2,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":1,\\n\" +\n+        \"\\\"lineMaps\\\":[\\\"\\\"],\\n\" +\n+        \"\\\"mappings\\\":[],\\n\" +\n+        \"\\\"sources\\\":[\\\"src1\\\",\\\"src2\\\"],\\n\" +\n+        \"\\\"names\\\":[]\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testPrefixReplacement3() throws IOException {\n+    mappings = new ArrayList<SourceMap.LocationMapping>();\n+    // multiple mappings can be applied\n+    mappings.add( new SourceMap.LocationMapping(\"file1\",\"x\") );\n+    mappings.add( new SourceMap.LocationMapping(\"file2\",\"y\") );\n+    checkSourceMap2(\"\", \"file1\", \"\", \"file2\" , \"{\\n\" +\n+        \"\\\"version\\\":2,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":1,\\n\" +\n+        \"\\\"lineMaps\\\":[\\\"\\\"],\\n\" +\n+        \"\\\"mappings\\\":[],\\n\" +\n+        \"\\\"sources\\\":[\\\"x\\\",\\\"y\\\"],\\n\" +\n+        \"\\\"names\\\":[]\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testPrefixReplacement4() throws IOException {\n+    mappings = new ArrayList<SourceMap.LocationMapping>();\n+    // first match wins\n+    mappings.add( new SourceMap.LocationMapping(\"file1\",\"x\") );\n+    mappings.add( new SourceMap.LocationMapping(\"file\",\"y\") );\n+    checkSourceMap2(\"\", \"file1\", \"\", \"file2\" , \"{\\n\" +\n+        \"\\\"version\\\":2,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":1,\\n\" +\n+        \"\\\"lineMaps\\\":[\\\"\\\"],\\n\" +\n+        \"\\\"mappings\\\":[],\\n\" +\n+        \"\\\"sources\\\":[\\\"x\\\",\\\"y2\\\"],\\n\" +\n+        \"\\\"names\\\":[]\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  @Override\n+  protected CompilerOptions getCompilerOptions() {\n+    CompilerOptions options = super.getCompilerOptions();\n+    if (mappings != null) {\n+      options.sourceMapLocationMappings = mappings;\n+    }\n+    return options;\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+  }\n+\n+  private void checkSourceMap2(\n+      String js1, String file1, String js2, String file2, String expectedMap)\n+      throws IOException {\n+    RunResult result = compile(js1, file1, js2, file2);\n+    assertEquals(expectedMap, result.sourceMapFileContent);\n+    assertEquals(result.sourceMapFileContent, getSourceMap(result));\n+  }\n+\n+  @Override\n+  protected Format getSourceMapFormat() {\n+    return Format.V2;\n+  }\n+\n+  @Override\n+  protected SourceMapConsumer getSourceMapConsumer() {\n+    return new SourceMapConsumerV2();\n+  }\n+}", "timestamp": 1310763490, "metainfo": ""}