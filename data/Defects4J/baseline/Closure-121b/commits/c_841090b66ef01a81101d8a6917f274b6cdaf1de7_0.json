{"sha": "841090b66ef01a81101d8a6917f274b6cdaf1de7", "log": "Process Extens in GlobalVarReferencesMap so that we can deal with the newly supported reference collecting in Externs added in other places in the compiler.  R=bashir,acleung DELTA=59  (49 added, 0 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2706   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   }\n \n   /**\n+   * Gets the externs in the order in which they are being processed.\n+   */\n+  List<CompilerInput> getExternsInOrder() {\n+    return Collections.<CompilerInput>unmodifiableList(externs);\n+  }\n+\n+  /**\n    * Stores the internal compiler state just before optimization is performed.\n    * This can be saved and restored in order to efficiently optimize multiple\n    * different output targets without having to perform checking multiple times.\n     Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT\n         || collectionRoot.getType() == Token.BLOCK);\n     if (globalRefMap == null) {\n-      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder());\n+      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n+          getExternsInOrder());\n     }\n     globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n   }\n--- a/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n+++ b/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n   /**\n    * @param inputs The ordered list of all inputs for the compiler.\n    */\n-  GlobalVarReferenceMap(List<CompilerInput> inputs) {\n+  GlobalVarReferenceMap(List<CompilerInput> inputs,\n+      List<CompilerInput> externs) {\n     inputOrder = Maps.newHashMap();\n     int ind = 0;\n+    for (CompilerInput extern : externs) {\n+      inputOrder.put(extern.getName(), ind);\n+      ind++;\n+    }\n     for (CompilerInput input : inputs) {\n       inputOrder.put(input.getName(), ind);\n       ind++;\n--- a/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n+++ b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n       new CompilerInput(null, \"input2\", false);\n   private static final CompilerInput INPUT3 =\n       new CompilerInput(null, \"input3\", false);\n+  private static final CompilerInput EXTERN1 =\n+    new CompilerInput(null, \"extern1\", true);\n \n   private final GlobalVarReferenceMap map = new GlobalVarReferenceMap(\n-      Lists.newArrayList(INPUT1, INPUT2, INPUT3));\n+      Lists.newArrayList(INPUT1, INPUT2, INPUT3), Lists.newArrayList(EXTERN1));\n   private final Map<Var, ReferenceCollection> globalMap = Maps.newHashMap();\n   private final Node root = new Node(Token.BLOCK);\n   private final Scope globalScope = new Scope(root, (ObjectType) null);\n   Node scriptRoot = new Node(Token.SCRIPT);\n \n   // In the initial setUp we have 3 references to var1 (one in each input) and\n-  // 2 references to var2 (in first and third inputs).\n+  // 2 references to var2 (in first and third inputs), and 2 references to var3\n+  // (in second input and first extern)\n   private static final String VAR1 = \"var1\";\n   private static final String VAR2 = \"var2\";\n+  private static final String VAR3 = \"var3\";\n   private final ReferenceCollection var1Refs = new ReferenceCollection();\n   private final ReferenceCollection var2Refs = new ReferenceCollection();\n+  private final ReferenceCollection var3Refs = new ReferenceCollection();\n   private final Reference var1In1Ref =  createRefForTest(INPUT1.getName());\n   private final Reference var1In2Ref =  createRefForTest(INPUT2.getName());\n   private final Reference var1In3Ref =  createRefForTest(INPUT3.getName());\n   private final Reference var2In1Ref =  createRefForTest(INPUT1.getName());\n   private final Reference var2In3Ref =  createRefForTest(INPUT3.getName());\n+  private final Reference var3In2Ref =  createRefForTest(INPUT2.getName());\n+  private final Reference var3In1Ext =  createRefForTest(EXTERN1.getName());\n \n   @Override\n   protected void setUp() throws Exception {\n         var1In2Ref, var1In3Ref);\n     globalScope.declare(VAR2, new Node(Token.NAME), null, INPUT1);\n     var2Refs.references = Lists.newArrayList(var2In1Ref, var2In3Ref);\n+    globalScope.declare(VAR3, new Node(Token.NAME), null, EXTERN1);\n+    var3Refs.references = Lists.newArrayList(var3In1Ext, var3In2Ref);\n+\n     // We recreate these two ReferenceCollection to keep var1Refs and\n     // var2Refs intact in update operations for comparison in the tests.\n     ReferenceCollection var1TempRefs = new ReferenceCollection();\n     var1TempRefs.references = Lists.newArrayList(var1Refs.references);\n     ReferenceCollection var2TempRefs = new ReferenceCollection();\n     var2TempRefs.references = Lists.newArrayList(var2Refs.references);\n+    ReferenceCollection var3TempRefs = new ReferenceCollection();\n+    var3TempRefs.references = Lists.newArrayList(var3Refs.references);\n     globalMap.put(globalScope.getVar(VAR1), var1TempRefs);\n     globalMap.put(globalScope.getVar(VAR2), var2TempRefs);\n+    globalMap.put(globalScope.getVar(VAR3), var3TempRefs);\n     map.updateGlobalVarReferences(globalMap, root);\n     scriptRoot.putProp(Node.SOURCENAME_PROP, INPUT2.getName());\n   }\n           map.getReferences(globalScope.getVar(VAR1)).references);\n       assertEquals(var2Refs.references,\n           map.getReferences(globalScope.getVar(VAR2)).references);\n+      assertEquals(var3Refs.references,\n+          map.getReferences(globalScope.getVar(VAR3)).references);\n       map.updateGlobalVarReferences(globalMap, root);\n     }\n   }\n     assertEquals(2, refs.references.size());\n     assertEquals(var1Refs.references.get(0), refs.references.get(0));\n     assertEquals(var1Refs.references.get(2), refs.references.get(1));\n+    refs = map.getReferences(globalScope.getVar(VAR3));\n+    assertEquals(1, refs.references.size());\n+    assertEquals(var3Refs.references.get(0), refs.references.get(0));\n   }\n \n   /** Changes variable references in second script. */\n   public void testUpdateGlobalVarReferences_UpdateScriptNewRefs() {\n     Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap();\n+\n     ReferenceCollection newVar1Refs = new ReferenceCollection();\n     Reference newVar1In2Ref = createRefForTest(INPUT2.getName());\n     newVar1Refs.references = Lists.newArrayList(newVar1In2Ref);\n+\n     ReferenceCollection newVar2Refs = new ReferenceCollection();\n     Reference newVar2In2Ref = createRefForTest(INPUT2.getName());\n     newVar2Refs.references = Lists.newArrayList(newVar2In2Ref);\n+\n+    ReferenceCollection newVar3Refs = new ReferenceCollection();\n+    Reference newVar3In2Ref = createRefForTest(INPUT2.getName());\n+    newVar3Refs.references = Lists.newArrayList(newVar3In2Ref);\n+\n     scriptMap.put(globalScope.getVar(VAR1), newVar1Refs);\n     scriptMap.put(globalScope.getVar(VAR2), newVar2Refs);\n+    scriptMap.put(globalScope.getVar(VAR3), newVar3Refs);\n     map.updateGlobalVarReferences(scriptMap, scriptRoot);\n     ReferenceCollection refs = map.getReferences(globalScope.getVar(VAR1));\n     assertEquals(3, refs.references.size());\n     assertEquals(var2Refs.references.get(0), refs.references.get(0));\n     assertEquals(newVar2In2Ref, refs.references.get(1));\n     assertEquals(var2Refs.references.get(1), refs.references.get(2));\n+    refs = map.getReferences(globalScope.getVar(VAR3));\n+    assertEquals(2, refs.references.size());\n+    assertEquals(var3Refs.references.get(0), refs.references.get(0));\n+    assertEquals(newVar3In2Ref, refs.references.get(1));\n   }\n \n   /** Changes variable references in second script. */\n   public void testUpdateGlobalVarReferences_UpdateScriptNewVar() {\n     Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap();\n-    final String var3 = \"var3\";\n-    globalScope.declare(var3, new Node(Token.NAME), null, INPUT2);\n+    final String var4 = \"var4\";\n+    globalScope.declare(var4, new Node(Token.NAME), null, INPUT2);\n     ReferenceCollection newVar3Refs = new ReferenceCollection();\n     Reference newVar3In2Ref = createRefForTest(INPUT2.getName());\n     newVar3Refs.references = Lists.newArrayList(newVar3In2Ref);\n-    scriptMap.put(globalScope.getVar(var3), newVar3Refs);\n+    scriptMap.put(globalScope.getVar(var4), newVar3Refs);\n     map.updateGlobalVarReferences(scriptMap, scriptRoot);\n-    ReferenceCollection refs = map.getReferences(globalScope.getVar(var3));\n+    ReferenceCollection refs = map.getReferences(globalScope.getVar(var4));\n     assertEquals(1, refs.references.size());\n     assertEquals(newVar3In2Ref, refs.references.get(0));\n   }", "timestamp": 1311363538, "metainfo": ""}