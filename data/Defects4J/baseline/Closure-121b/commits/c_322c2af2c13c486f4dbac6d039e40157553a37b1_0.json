{"sha": "322c2af2c13c486f4dbac6d039e40157553a37b1", "log": "Add support for String.split to peephole optimizations. No longer depends on Java's implementation of split.  R=acleung,johnlenz  Revision created by MOE tool push_codebase. MOE re-sync of r1698  DELTA=152  (136 added, 4 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4020   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       final boolean late = false;\n       return new PeepholeOptimizationsPass(compiler,\n             new PeepholeSubstituteAlternateSyntax(late),\n-            new PeepholeReplaceKnownMethods(),\n+            new PeepholeReplaceKnownMethods(late),\n             new PeepholeRemoveDeadCode(),\n             new PeepholeFoldConstants(late),\n             new PeepholeCollectPropertyAssignments());\n             new StatementFusion(),\n             new PeepholeRemoveDeadCode(),\n             new PeepholeSubstituteAlternateSyntax(late),\n-            new PeepholeReplaceKnownMethods(),\n+            new PeepholeReplaceKnownMethods(late),\n             new PeepholeFoldConstants(late),\n             new ReorderConstantExpression());\n     }\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n \n   // The LOCALE independent \"locale\"\n   private static final Locale ROOT_LOCALE = new Locale(\"\");\n+  private final boolean late;\n+\n+  /**\n+   * @param late When late is true, this mean we are currently running after\n+   * most of the other optimizations. In this case we avoid changes that make\n+   * the code larger (but otherwise easier to analyze - such as using string\n+   * splitting).\n+   */\n+  PeepholeReplaceKnownMethods(boolean late) {\n+    this.late = late;\n+  }\n \n   @Override\n   Node optimizeSubtree(Node subtree) {\n \n     String functionNameString = functionName.getString();\n     Node firstArg = callTarget.getNext();\n-    if (firstArg == null) {\n+    if (functionNameString.equals(\"split\")) {\n+      subtree = tryFoldStringSplit(subtree, stringNode, firstArg);\n+    } else if (firstArg == null) {\n       if (functionNameString.equals(\"toLowerCase\")) {\n         subtree = tryFoldStringToLowerCase(subtree, stringNode);\n       } else if (functionNameString.equals(\"toUpperCase\")) {\n     reportCodeChange();\n     return resultNode;\n   }\n-}\n+\n+  /**\n+   * Support function for jsSplit, find the first occurrence of\n+   * separator within stringValue starting at startIndex.\n+   */\n+  private int jsSplitMatch(String stringValue, int startIndex,\n+      String separator) {\n+\n+    if (startIndex + separator.length() > stringValue.length()) {\n+      return -1;\n+    }\n+\n+    int matchIndex = stringValue.indexOf(separator, startIndex);\n+\n+    if (matchIndex < 0) {\n+      return -1;\n+    }\n+\n+    return matchIndex + separator.length();\n+  }\n+\n+  /**\n+   * Implement the JS String.split method using a string separator.\n+   */\n+  private String[] jsSplit(String stringValue, String separator, int limit) {\n+    Preconditions.checkArgument(limit >= 0);\n+\n+    // For limits of 0, return an empty array\n+    if (limit == 0) {\n+      return new String[0];\n+    }\n+\n+    /* If a separator is not specified, return the entire string as\n+     * the only element of an array.\n+     */\n+    if (separator == null) {\n+      return new String[] {stringValue};\n+    }\n+\n+    List<String> splitStrings = Lists.newArrayList();\n+\n+    /* If an empty string is specified for the separator, split apart each\n+     * character of the string.\n+     */\n+    if (separator.length() == 0) {\n+      for (int i = 0; i < stringValue.length() && i < limit; i++) {\n+        splitStrings.add(stringValue.substring(i, i + 1));\n+      }\n+    } else {\n+      int startIndex = 0, matchEndIndex;\n+      while ((matchEndIndex =\n+          jsSplitMatch(stringValue, startIndex, separator)) >= 0 &&\n+          splitStrings.size() < limit) {\n+        if (separator.length() == 0) {\n+          matchEndIndex++;\n+        }\n+        splitStrings.add(stringValue.substring(startIndex,\n+            matchEndIndex - separator.length()));\n+        startIndex = matchEndIndex;\n+      }\n+      if (startIndex < stringValue.length() && splitStrings.size() < limit) {\n+        splitStrings.add(stringValue.substring(startIndex));\n+      }\n+    }\n+\n+    return splitStrings.toArray(new String[splitStrings.size()]);\n+  }\n+\n+  /**\n+   * Try to fold .split() calls on strings\n+   */\n+  private Node tryFoldStringSplit(Node n, Node stringNode, Node arg1) {\n+    if (late) {\n+      return n;\n+    }\n+\n+    Preconditions.checkArgument(n.isCall());\n+    Preconditions.checkArgument(stringNode.isString());\n+\n+    String separator = null;\n+    String stringValue = stringNode.getString();\n+\n+    // Maximum number of possible splits\n+    int limit = stringValue.length() + 1;\n+\n+    if (arg1 != null) {\n+      if (arg1.isString()) {\n+        separator = arg1.getString();\n+      } else if (!arg1.isNull()) {\n+        return n;\n+      }\n+\n+      Node arg2 = arg1.getNext();\n+      if (arg2 != null) {\n+        if (arg2.isNumber()) {\n+          limit = Math.min((int) arg2.getDouble(), limit);\n+          if (limit < 0) {\n+            return n;\n+          }\n+        } else {\n+          return n;\n+        }\n+      }\n+    }\n+\n+    // Split the string and convert the returned array into JS nodes\n+    String[] stringArray = jsSplit(stringValue, separator, limit);\n+    Node arrayOfStrings = IR.arraylit();\n+    for (int i = 0; i < stringArray.length; i++) {\n+      arrayOfStrings.addChildToBack(\n+          IR.string(stringArray[i]).srcref(stringNode));\n+    }\n+\n+    Node parent = n.getParent();\n+    parent.replaceChild(n, arrayOfStrings);\n+    reportCodeChange();\n+    return arrayOfStrings;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler,\n-          new PeepholeReplaceKnownMethods());\n+          new PeepholeReplaceKnownMethods(late));\n     return peepholePass;\n   }\n \n   }\n \n   public void testFoldStringSplit() {\n-    // NOTE(nicksantos): These are cases that will have to be resolved\n-    // properly if we want to implement split()\n     late = false;\n-    foldSame(\"x = 'abcde'.split()\");\n-    foldSame(\"x = 'abcde'.split(null)\");\n-    foldSame(\"x = 'a b c d e'.split(' ')\");\n-    foldSame(\"x = 'a b c d e'.split(' ', 0)\");\n-    foldSame(\"x = 'abcde'.split('cd')\");\n-    foldSame(\"x = 'a b c d e'.split(' ', 1)\");\n-    foldSame(\"x = 'a b c d e'.split(' ', 3)\");\n-    foldSame(\"x = 'a b c d e'.split(null, 1)\");\n+    fold(\"x = 'abcde'.split('foo')\", \"x = ['abcde']\");\n+    fold(\"x = 'abcde'.split()\", \"x = ['abcde']\");\n+    fold(\"x = 'abcde'.split(null)\", \"x = ['abcde']\");\n+    fold(\"x = 'a b c d e'.split(' ')\", \"x = ['a','b','c','d','e']\");\n+    fold(\"x = 'a b c d e'.split(' ', 0)\", \"x = []\");\n+    fold(\"x = 'abcde'.split('cd')\", \"x = ['ab','e']\");\n+    fold(\"x = 'a b c d e'.split(' ', 1)\", \"x = ['a']\");\n+    fold(\"x = 'a b c d e'.split(' ', 3)\", \"x = ['a','b','c']\");\n+    fold(\"x = 'a b c d e'.split(null, 1)\", \"x = ['a b c d e']\");\n+    fold(\"x = 'aaaaa'.split('a')\", \"x = ['', '', '', '', '']\");\n+    fold(\"x = 'abcde'.split('')\", \"x = ['a','b','c','d','e']\");\n+    fold(\"x = 'abcde'.split('', 3)\", \"x = ['a','b','c']\");\n+\n     foldSame(\"x = 'abcde'.split(/ /)\");\n     foldSame(\"x = 'abcde'.split(' ', -1)\");\n-    foldSame(\"x = 'abcde'.split('')\");\n-    foldSame(\"x = 'aaaaa'.split('a')\");\n \n     late = true;\n     foldSame(\"x = 'a b c d e'.split(' ')\");", "timestamp": 1325619389, "metainfo": ""}