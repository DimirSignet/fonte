{"sha": "6829657ab0be6215e9cc0143f89af82753d5203d", "log": "Add a warning (disabled by default) controlled by the MISPLACED_TYPE_ANNOTATION, that limits the places we accept JSDoc with \"@type\" annotations.  This will help us detect useless ones (aka floaters).  R=nicksantos DELTA=274  (240 added, 11 deleted, 23 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5721   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n       \"checkTypes, checkVars, const, constantProperty, deprecated, \" +\n       \"duplicateMessage, \" +\n       \"es5Strict, externsValidation, fileoverviewTags, globalThis, \" +\n-      \"internetExplorerChecks, invalidCasts, missingProperties, \" +\n+      \"internetExplorerChecks, invalidCasts, misplacedTypeAnnotation, \" +\n+      \"missingProperties, \" +\n       \"nonStandardJsDocs, strictModuleDepCheck, typeInvalidation, \" +\n       \"undefinedNames, undefinedVars, unknownDefines, uselessCode, \" +\n       \"visibility\";\n       DiagnosticGroups.registerGroup(\"duplicateMessage\",\n           JsMessageVisitor.MESSAGE_DUPLICATE_KEY);\n \n+  public static DiagnosticGroup MISPLACED_TYPE_ANNOTATION =\n+      DiagnosticGroups.registerGroup(\"misplacedTypeAnnotation\",\n+          RhinoErrorReporter.MISPLACED_TYPE_ANNOTATION);\n+\n   /**\n    * Adds warning levels by name.\n    */\n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n       DiagnosticType.error(\"JSC_DUPLICATE_PARAM\", \"Parse error. {0}\");\n \n   static final DiagnosticType BAD_JSDOC_ANNOTATION =\n-    DiagnosticType.warning(\"JSC_BAD_JSDOC_ANNOTATION\", \"Parse error. {0}\");\n+      DiagnosticType.warning(\"JSC_BAD_JSDOC_ANNOTATION\", \"Parse error. {0}\");\n+\n+  static final DiagnosticType MISPLACED_TYPE_ANNOTATION =\n+      DiagnosticType.disabled(\"JSC_MISPLACED_TYPE_ANNOTATION\",\n+          \"Type annotations are not allowed here. \" +\n+          \"Are you missing parentheses?\");\n \n   // A map of Rhino messages to their DiagnosticType.\n   private final Map<Pattern, DiagnosticType> typeMap;\n         replacePlaceHolders(ScriptRuntime.getMessage0(\"msg.bad.jsdoc.tag\")),\n         BAD_JSDOC_ANNOTATION,\n \n+        Pattern.compile(\"^Type annotations are not allowed here.*\"),\n+        MISPLACED_TYPE_ANNOTATION,\n+\n         // Type annotation errors.\n         Pattern.compile(\"^Bad type annotation.*\"),\n-        TYPE_PARSE_ERROR);\n+        TYPE_PARSE_ERROR\n+        );\n   }\n \n   public static com.google.javascript.rhino.head.ErrorReporter\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n       \"Non-JSDoc comment has annotations. \" +\n       \"Did you mean to start it with '/**'?\";\n \n+  static final String MISPLACED_TYPE_ANNOTATION =\n+      \"Type annotations are not allowed here. Are you missing parentheses?\";\n+\n   private final String sourceString;\n   private final StaticSourceFile sourceFile;\n   private final String sourceName;\n       JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n       parsedComments.add(comment);\n       if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n-        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n+        JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n+        if (info != null) {\n+          validateTypeAnnotations(info, node, irNode);\n+        }\n+        return info;\n       }\n     }\n     return null;\n+  }\n+\n+  private void validateTypeAnnotations(\n+      JSDocInfo info, AstNode node, Node irNode) {\n+    if (info.getType() != null) {\n+      boolean valid = false;\n+      switch (node.getType()) {\n+        // Casts are valid\n+        case com.google.javascript.rhino.head.Token.LP:\n+          valid = node instanceof ParenthesizedExpression;\n+          break;\n+        // Variable declarations are valid\n+        case com.google.javascript.rhino.head.Token.VAR:\n+          valid = true;\n+          break;\n+        // Function declarations are valid\n+        case com.google.javascript.rhino.head.Token.FUNCTION:\n+          FunctionNode fnNode = (FunctionNode)node;\n+          valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n+          break;\n+        // Object literal properties are valid\n+        case com.google.javascript.rhino.head.Token.GET:\n+        case com.google.javascript.rhino.head.Token.SET:\n+        case com.google.javascript.rhino.head.Token.NAME:\n+        case com.google.javascript.rhino.head.Token.NUMBER:\n+        case com.google.javascript.rhino.head.Token.STRING:\n+          valid = node.getParent() instanceof ObjectProperty;\n+          break;\n+\n+        // Property assignments are valid, if at the root of an expression.\n+        case com.google.javascript.rhino.head.Token.ASSIGN:\n+          if (node instanceof Assignment) {\n+            valid = isExprStmt(node.getParent())\n+                && isPropAccess(((Assignment)node).getLeft());\n+          }\n+          break;\n+\n+        // Property definitions are valid, if at the root of an expression.\n+        case com.google.javascript.rhino.head.Token.GETPROP:\n+        case com.google.javascript.rhino.head.Token.GETELEM:\n+          valid = isExprStmt(node.getParent());\n+          break;\n+      }\n+      if (!valid) {\n+        errorReporter.warning(MISPLACED_TYPE_ANNOTATION,\n+            sourceName,\n+            node.getLineno(), \"\", 0);\n+      }\n+    }\n+  }\n+\n+  private boolean isPropAccess(AstNode node) {\n+    return node.getType() == com.google.javascript.rhino.head.Token.GETPROP\n+        || node.getType() == com.google.javascript.rhino.head.Token.GETELEM;\n+  }\n+\n+  private boolean isExprStmt(AstNode node) {\n+    return node.getType() == com.google.javascript.rhino.head.Token.EXPR_RESULT\n+        || node.getType() == com.google.javascript.rhino.head.Token.EXPR_VOID;\n   }\n \n   private Node transform(AstNode node) {\n \n     @Override\n     Node processNewExpression(NewExpression exprNode) {\n-      Node node = newNode(transformTokenType(exprNode.getType()), transform(exprNode.getTarget()));\n+      Node node = newNode(\n+          transformTokenType(exprNode.getType()),\n+          transform(exprNode.getTarget()));\n       for (AstNode child : exprNode.getArguments()) {\n         node.addChildToBack(transform(child));\n       }\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n     options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n     options.setWarningLevel(\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n+    options.setWarningLevel(\n+        DiagnosticGroups.MISPLACED_TYPE_ANNOTATION, CheckLevel.WARNING);\n     options.setCodingConvention(getCodingConvention());\n     return options;\n   }\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         \"function foo(opt_f) {\" +\n         \"  /** @type {Function} */\" +\n         \"  return opt_f || function () {};\" +\n-        \"}\");\n+        \"}\",\n+        \"Type annotations are not allowed here. Are you missing parentheses?\");\n   }\n \n   /**\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ ({})\");\n \n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n-        \"/** @type {Foo} */ var x = (/** @type {Foo} */ {})\");\n-\n-    // Not really encourage because of possible ambiguity but it works.\n-    testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n-        \"/** @type {Foo} */ var x = /** @type {Foo} */ {}\");\n+        \"/** @type {Foo} */ var x = (/** @type {Foo} */ y)\");\n   }\n \n   public void testNestedCasts() throws Exception {\n   }\n \n   public void testUnknownConstructorInstanceType2() throws Exception {\n-    testTypes(\"function g(f) { return /** @type Array */ new f(); }\");\n+    testTypes(\"function g(f) { return /** @type Array */ (new f()); }\");\n   }\n \n   public void testUnknownConstructorInstanceType3() throws Exception {\n--- a/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java\n+++ b/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import com.google.javascript.rhino.Node;\n-\n import junit.framework.TestCase;\n \n import java.util.List;\n  */\n public class RhinoErrorReporterTest extends TestCase {\n \n-  public CompilerPass getProcessor(Compiler compiler) {\n-    return new CompilerPass() {\n-      @Override\n-      public void process(Node externs, Node root) {}\n-    };\n+  private boolean reportMisplacedTypeAnnotations;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    reportMisplacedTypeAnnotations = false;\n+    super.setUp();\n   }\n \n   public void testTrailingComma() throws Exception {\n     assertEquals(4, error.getCharno());\n   }\n \n+  public void testMisplacedTypeAnnotation() throws Exception {\n+    reportMisplacedTypeAnnotations = false;\n+\n+    assertNoWarningOrError(\"var x = /** @type {string} */ y;\");\n+\n+    reportMisplacedTypeAnnotations = true;\n+\n+    String message =\n+        \"Type annotations are not allowed here. \" +\n+        \"Are you missing parentheses?\";\n+    assertWarning(\n+        \"var x = /** @type {string} */ y;\",\n+        RhinoErrorReporter.MISPLACED_TYPE_ANNOTATION,\n+        message);\n+    JSError error = assertWarning(\n+        \"var x = /** @type {string} */ y;\",\n+        RhinoErrorReporter.MISPLACED_TYPE_ANNOTATION,\n+        message);\n+\n+    assertEquals(1, error.getLineNumber());\n+\n+    // Rhino uses the \"beginning\" of the line where the comma appears,\n+    // for some odd reason.\n+    assertEquals(0, error.getCharno());\n+  }\n+\n+  /**\n+   * Verifies that the compiler emits an error for the given code.\n+   */\n+  private void assertNoWarningOrError(String code) {\n+    Compiler compiler = parseCode(code);\n+    assertEquals(\"Expected error\", 0, compiler.getErrorCount());\n+    assertEquals(\"Expected warning\", 0, compiler.getErrorCount());\n+  }\n+\n   /**\n    * Verifies that the compiler emits an error for the given code.\n    */\n   private JSError assertError(\n       String code, DiagnosticType type, String description) {\n-    Compiler compiler = new Compiler();\n-    List<SourceFile> externs = ImmutableList.of();\n-    List<SourceFile> inputs = ImmutableList.of(\n-        SourceFile.fromCode(\"input\", code));\n-    compiler.init(externs, inputs, new CompilerOptions());\n-    compiler.parseInputs();\n+    Compiler compiler = parseCode(code);\n     assertEquals(\"Expected error\", 1, compiler.getErrorCount());\n \n     JSError error =\n     assertEquals(description, error.description);\n     return error;\n   }\n+\n+  /**\n+   * Verifies that the compiler emits an error for the given code.\n+   */\n+  private JSError assertWarning(\n+      String code, DiagnosticType type, String description) {\n+    Compiler compiler = parseCode(code);\n+    assertEquals(\"Expected warning\", 1, compiler.getWarningCount());\n+\n+    JSError error =\n+        Iterables.getOnlyElement(Lists.newArrayList(compiler.getWarnings()));\n+    assertEquals(type, error.getType());\n+    assertEquals(description, error.description);\n+    return error;\n+  }\n+\n+  private Compiler parseCode(String code) {\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    if (reportMisplacedTypeAnnotations) {\n+      options.setWarningLevel(\n+          DiagnosticGroups.MISPLACED_TYPE_ANNOTATION,\n+          CheckLevel.WARNING);\n+    }\n+\n+    List<SourceFile> externs = ImmutableList.of();\n+    List<SourceFile> inputs = ImmutableList.of(\n+        SourceFile.fromCode(\"input\", code));\n+    compiler.init(externs, inputs, options);\n+    compiler.parseInputs();\n+    return compiler;\n+  }\n+\n+\n }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n   public void testIssue380() throws Exception {\n     testTypes(\n-        \"/** @type { function(string): {innerHTML: string} } */\" +\n-        \"document.getElementById;\" +\n+        \"/** @type { function(string): {innerHTML: string} } */\\n\" +\n+        \"document.getElementById;\\n\" +\n         \"var list = /** @type {!Array.<string>} */ ['hello', 'you'];\\n\" +\n         \"list.push('?');\\n\" +\n-        \"document.getElementById('node').innerHTML = list.toString();\");\n+        \"document.getElementById('node').innerHTML = list.toString();\",\n+        // Parse warning, but still applied.\n+        \"Type annotations are not allowed here. \" +\n+        \"Are you missing parentheses?\");\n   }\n \n   public void testIssue483() throws Exception {\n         \"function foo(opt_f) {\" +\n         \"  /** @type {Function} */\" +\n         \"  return opt_f || function () {};\" +\n-        \"}\");\n+        \"}\",\n+        \"Type annotations are not allowed here. Are you missing parentheses?\");\n   }\n \n   /**\n   public void testCast17() throws Exception {\n     // Mostly verifying that rhino actually understands these JsDocs.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n+        \"/** @type {Foo} */ var x = /** @type {Foo} */ (y)\");\n+\n+    testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n+        \"/** @type {Foo} */ var x = (/** @type {Foo} */ y)\");\n+\n+    // Mostly verifying that rhino actually understands these JsDocs.\n+    testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ ({})\");\n-\n+  }\n+\n+  public void testCast18() throws Exception {\n+    // Mostly verifying that legacy annotations are applied\n+    // despite the parser warning.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n-        \"/** @type {Foo} */ var x = (/** @type {Foo} */ {})\");\n+        \"/** @type {Foo} */ var x = (/** @type {Foo} */ {})\",\n+        \"Type annotations are not allowed here. \" +\n+        \"Are you missing parentheses?\");\n \n     // Not really encourage because of possible ambiguity but it works.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n-        \"/** @type {Foo} */ var x = /** @type {Foo} */ {}\");\n+        \"/** @type {Foo} */ var x = /** @type {Foo} */ {}\",\n+        \"Type annotations are not allowed here. \" +\n+        \"Are you missing parentheses?\");\n   }\n \n   public void testNestedCasts() throws Exception {\n   }\n \n   public void testUnknownConstructorInstanceType2() throws Exception {\n-    testTypes(\"function g(f) { return /** @type Array */ new f(); }\");\n+    testTypes(\"function g(f) { return /** @type Array */(new f()); }\");\n   }\n \n   public void testUnknownConstructorInstanceType3() throws Exception {\n         \"/** @extends {base} \\n @interface */ var Int = function() {}\\n\" +\n         \"/** @type {{bar : !Function}} */ var x; \\n\" +\n         \"/** @type {!Function} */ base.prototype.bar = abstractMethod; \\n\" +\n-        \"/** @type {Int} */ foo;\\n\" +\n+        \"/** @type {Int} */ var foo;\\n\" +\n         \"foo.bar();\");\n   }\n \n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n       \"Bad type annotation. \" +\n       com.google.javascript.rhino.ScriptRuntime.getMessage0(\n           \"msg.jsdoc.missing.gt\");\n+\n+  private static final String MISPLACED_TYPE_ANNOTATION =\n+      IRFactory.MISPLACED_TYPE_ANNOTATION;\n \n   private Config.LanguageMode mode;\n   private boolean isIdeMode = false;\n         \"unsupported language extension: for each\");\n   }\n \n+  public void testMisplacedTypeAnnotation1() {\n+    // misuse with COMMA\n+    parse(\n+        \"var o = {};\" +\n+        \"/** @type {string} */ o.prop1 = 1, o.prop2 = 2;\",\n+        MISPLACED_TYPE_ANNOTATION);\n+  }\n+\n+  public void testMisplacedTypeAnnotation2() {\n+    // missing parenthese for the cast.\n+    parse(\n+        \"var o = /** @type {string} */ getValue();\",\n+        MISPLACED_TYPE_ANNOTATION);\n+  }\n+\n+  public void testMisplacedTypeAnnotation3() {\n+    // missing parenthese for the cast.\n+    parse(\n+        \"var o = 1 + /** @type {string} */ value;\",\n+        MISPLACED_TYPE_ANNOTATION);\n+  }\n+\n+  public void testMisplacedTypeAnnotation4() {\n+    // missing parenthese for the cast.\n+    parse(\n+        \"var o = /** @type {!Array.<string>} */ ['hello', 'you'];\",\n+        MISPLACED_TYPE_ANNOTATION);\n+  }\n+\n+  public void testMisplacedTypeAnnotation5() {\n+    // missing parenthese for the cast.\n+    parse(\n+        \"var o = (/** @type {!Foo} */ {});\",\n+        MISPLACED_TYPE_ANNOTATION);\n+  }\n+\n+  public void testMisplacedTypeAnnotation6() {\n+    parse(\"var o = /** @type {function():string} */ function() {return 'str';}\",\n+        MISPLACED_TYPE_ANNOTATION);\n+  }\n+\n+  public void testMisplacedTypeAnnotation7() {\n+    // TODO(johnlenz): handle this case\n+    parse(\"function f(/** @type {string} */ a) {}\");\n+  }\n+\n+  public void testValidTypeAnnotation1() {\n+    parse(\"/** @type {string} */ var o = 'str';\");\n+    parse(\"var /** @type {string} */ o = 'str', /** @type {number} */ p = 0;\");\n+    parse(\"/** @type {function():string} */ function o() { return 'str'; }\");\n+    parse(\"var o = {}; /** @type {string} */ o.prop = 'str';\");\n+    parse(\"var o = {}; /** @type {string} */ o['prop'] = 'str';\");\n+    parse(\"var o = { /** @type {string} */ prop : 'str' };\");\n+    parse(\"var o = { /** @type {string} */ 'prop' : 'str' };\");\n+    parse(\"var o = { /** @type {string} */ 1 : 'str' };\");\n+  }\n+\n+  public void testValidTypeAnnotation2() {\n+    mode = LanguageMode.ECMASCRIPT5;\n+    parse(\"var o = { /** @type {string} */ get prop() { return 'str' }};\");\n+    parse(\"var o = { /** @type {string} */ set prop(s) {}};\");\n+  }\n+\n   /**\n    * Verify that the given code has the given parse errors.\n    * @return If in IDE mode, returns a partial tree.", "timestamp": 1351629428, "metainfo": ""}