{"sha": "06c4d2f84718b7ad601a1429420d000911192d80", "log": "split type-checking helpers into separate packages  R=johnlenz DELTA=3502  (1784 added, 1674 deleted, 44 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4472   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.parsing.Config;\n+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.head.ErrorReporter;\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n   }\n \n   @Override\n-  public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n-      Node callNode) {\n+  public ObjectLiteralCast getObjectLiteralCast(Node callNode) {\n     Preconditions.checkArgument(callNode.isCall());\n     Node callName = callNode.getFirstChild();\n     if (!\"goog.reflect.object\".equals(callName.getQualifiedName()) ||\n \n     Node objectNode = typeNode.getNext();\n     if (!objectNode.isObjectLit()) {\n-      // TODO(johnlenz): The coding convention should not be performing checks.\n-      t.getCompiler().report(JSError.make(t.getSourceName(), callNode,\n-                                          OBJECTLIT_EXPECTED));\n-      return null;\n-    }\n-\n-    return new ObjectLiteralCast(typeNode.getQualifiedName(),\n-                                 typeNode.getNext());\n+      return new ObjectLiteralCast(null, null, OBJECTLIT_EXPECTED);\n+    }\n+\n+    return new ObjectLiteralCast(\n+        typeNode.getQualifiedName(), typeNode.getNext(), null);\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n \n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticScope;\n \n import java.io.Serializable;\n import java.util.Collection;\n    * @param delegateProxyPrototypes List of delegate proxy prototypes.\n    */\n   public void defineDelegateProxyPrototypeProperties(\n-      JSTypeRegistry registry, Scope scope,\n+      JSTypeRegistry registry, StaticScope<JSType> scope,\n       List<ObjectType> delegateProxyPrototypes,\n       Map<String, String> delegateCallingConventions);\n \n    * @param t The node traversal.\n    * @param callNode A CALL node.\n    */\n-  public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n-      Node callNode);\n+  public ObjectLiteralCast getObjectLiteralCast(Node callNode);\n \n   /**\n    * Returns the set of AssertionFunction.\n     /** Object to cast. */\n     final Node objectNode;\n \n-    ObjectLiteralCast(String typeName, Node objectNode) {\n+    /** Error message */\n+    final DiagnosticType diagnosticType;\n+\n+    ObjectLiteralCast(String typeName, Node objectNode,\n+        DiagnosticType diagnosticType) {\n       this.typeName = typeName;\n       this.objectNode = objectNode;\n+      this.diagnosticType = diagnosticType;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CodingConventions.java\n+++ b/src/com/google/javascript/jscomp/CodingConventions.java\n \n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticScope;\n \n import java.util.Collection;\n import java.util.Collections;\n \n     @Override\n     public void defineDelegateProxyPrototypeProperties(\n-        JSTypeRegistry registry, Scope scope,\n+        JSTypeRegistry registry, StaticScope<JSType> scope,\n         List<ObjectType> delegateProxyPrototypes,\n         Map<String, String> delegateCallingConventions) {\n       nextConvention.defineDelegateProxyPrototypeProperties(\n     }\n \n     @Override\n-    public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n-        Node callNode) {\n-      return nextConvention.getObjectLiteralCast(t, callNode);\n+    public ObjectLiteralCast getObjectLiteralCast(Node callNode) {\n+      return nextConvention.getObjectLiteralCast(callNode);\n     }\n   }\n \n \n     @Override\n     public void defineDelegateProxyPrototypeProperties(\n-        JSTypeRegistry registry, Scope scope,\n+        JSTypeRegistry registry, StaticScope<JSType> scope,\n         List<ObjectType> delegateProxyPrototypes,\n         Map<String, String> delegateCallingConventions) {\n       // do nothing.\n     }\n \n     @Override\n-    public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n-        Node callNode) {\n+    public ObjectLiteralCast getObjectLiteralCast(Node callNode) {\n       return null;\n     }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n+import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.graph.LatticeElement;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.Annotation;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.jscomp.graph.LatticeElement;\n import com.google.javascript.rhino.Node;\n+\n import java.util.ArrayList;\n import java.util.Comparator;\n import java.util.Iterator;\n--- a/src/com/google/javascript/jscomp/JoinOp.java\n+++ b/src/com/google/javascript/jscomp/JoinOp.java\n \n import com.google.common.base.Function;\n import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.graph.LatticeElement;\n \n import java.util.List;\n \n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.type.FlowScope;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.SimpleSlot;\n    * with stuff that we've inferred in the local flow.\n    */\n   @Override\n-  public void completeScope(Scope scope) {\n+  public void completeScope(StaticScope<JSType> staticScope) {\n+    Scope scope = (Scope) staticScope;\n     for (Iterator<Var> it = scope.getVars(); it.hasNext();) {\n       Var var = it.next();\n       if (var.isTypeInferred()) {\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.LatticeElement;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.LatticeElement;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.LatticeElement;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.TernaryValue;\n \n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Set;\n-import java.util.HashMap;\n \n /**\n  * <p>Checks the types of JS expressions against any declared type\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.type.FlowScope;\n+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n \n import java.util.Map;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       }\n \n       ObjectLiteralCast objectLiteralCast =\n-          codingConvention.getObjectLiteralCast(t, n);\n+          codingConvention.getObjectLiteralCast(n);\n       if (objectLiteralCast != null) {\n-        ObjectType type = ObjectType.cast(\n-            typeRegistry.getType(objectLiteralCast.typeName));\n-        if (type != null && type.getConstructor() != null) {\n-          setDeferredType(objectLiteralCast.objectNode, type);\n+        if (objectLiteralCast.diagnosticType == null) {\n+          ObjectType type = ObjectType.cast(\n+              typeRegistry.getType(objectLiteralCast.typeName));\n+          if (type != null && type.getConstructor() != null) {\n+            setDeferredType(objectLiteralCast.objectNode, type);\n+          } else {\n+            compiler.report(JSError.make(t.getSourceName(), n,\n+                    CONSTRUCTOR_EXPECTED));\n+          }\n         } else {\n           compiler.report(JSError.make(t.getSourceName(), n,\n-                  CONSTRUCTOR_EXPECTED));\n+                  objectLiteralCast.diagnosticType));\n         }\n       }\n     }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/graph/LatticeElement.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.graph;\n+\n+/**\n+ * A lattice element.\n+ *\n+ */\n+public interface LatticeElement {\n+\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+/*\n+ * Copyright 2007 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.type;\n+\n+import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.CodingConvention;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.EnumElementType;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+import com.google.javascript.rhino.jstype.UnionType;\n+import com.google.javascript.rhino.jstype.Visitor;\n+\n+/**\n+ * Chainable reverse abstract interpreter providing basic functionality.\n+ *\n+ */\n+public abstract class ChainableReverseAbstractInterpreter\n+    implements ReverseAbstractInterpreter {\n+  protected final CodingConvention convention;\n+  final JSTypeRegistry typeRegistry;\n+  private ChainableReverseAbstractInterpreter firstLink;\n+  private ChainableReverseAbstractInterpreter nextLink;\n+\n+  /**\n+   * Constructs an interpreter, which is the only link in a chain. Interpreters\n+   * can be appended using {@link #append}.\n+   */\n+  public ChainableReverseAbstractInterpreter(CodingConvention convention,\n+      JSTypeRegistry typeRegistry) {\n+    Preconditions.checkNotNull(convention);\n+    this.convention = convention;\n+    this.typeRegistry = typeRegistry;\n+    firstLink = this;\n+    nextLink = null;\n+  }\n+\n+  /**\n+   * Appends a link to {@code this}, returning the updated last link.\n+   * <p>\n+   * The pattern {@code new X().append(new Y())...append(new Z())} forms a\n+   * chain starting with X, then Y, then ... Z.\n+   * @param lastLink a chainable interpreter, with no next link\n+   * @return the updated last link\n+   */\n+  public ChainableReverseAbstractInterpreter append(\n+      ChainableReverseAbstractInterpreter lastLink) {\n+    Preconditions.checkArgument(lastLink.nextLink == null);\n+    this.nextLink = lastLink;\n+    lastLink.firstLink = this.firstLink;\n+    return lastLink;\n+  }\n+\n+  /**\n+   * Gets the first link of this chain.\n+   */\n+  public ChainableReverseAbstractInterpreter getFirst() {\n+    return firstLink;\n+  }\n+\n+  /**\n+   * Calculates the preciser scope starting with the first link.\n+   */\n+  protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition,\n+      FlowScope blindScope, boolean outcome) {\n+    return firstLink.getPreciserScopeKnowingConditionOutcome(\n+        condition, blindScope, outcome);\n+  }\n+\n+  /**\n+   * Delegates the calculation of the preciser scope to the next link.\n+   * If there is no next link, returns the blind scope.\n+   */\n+  protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition,\n+      FlowScope blindScope, boolean outcome) {\n+    return nextLink != null ? nextLink.getPreciserScopeKnowingConditionOutcome(\n+        condition, blindScope, outcome) : blindScope;\n+  }\n+\n+  /**\n+   * Returns the type of a node in the given scope if the node corresponds to a\n+   * name whose type is capable of being refined.\n+   * @return The current type of the node if it can be refined, null otherwise.\n+   */\n+  JSType getTypeIfRefinable(Node node, FlowScope scope) {\n+    switch (node.getType()) {\n+      case Token.NAME:\n+        StaticSlot<JSType> nameVar = scope.getSlot(node.getString());\n+        if (nameVar != null) {\n+          JSType nameVarType = nameVar.getType();\n+          if (nameVarType == null) {\n+            nameVarType = node.getJSType();\n+          }\n+          return nameVarType;\n+        }\n+        return null;\n+\n+      case Token.GETPROP:\n+        String qualifiedName = node.getQualifiedName();\n+        if (qualifiedName == null) {\n+          return null;\n+        }\n+        StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);\n+        JSType propVarType = null;\n+        if (propVar != null) {\n+          propVarType = propVar.getType();\n+        }\n+        if (propVarType == null) {\n+          propVarType = node.getJSType();\n+        }\n+        if (propVarType == null) {\n+          propVarType = getNativeType(UNKNOWN_TYPE);\n+        }\n+        return propVarType;\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Declares a refined type in {@code scope} for the name represented by\n+   * {@code node}. It must be possible to refine the type of the given node in\n+   * the given scope, as determined by {@link #getTypeIfRefinable}.\n+   */\n+  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n+    switch (node.getType()) {\n+      case Token.NAME:\n+        scope.inferSlotType(node.getString(), type);\n+        break;\n+\n+      case Token.GETPROP:\n+        String qualifiedName = node.getQualifiedName();\n+        Preconditions.checkNotNull(qualifiedName);\n+\n+        JSType origType = node.getJSType();\n+        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n+        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+        break;\n+\n+      default:\n+        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n+            node.toStringTree());\n+    }\n+  }\n+\n+  /**\n+   * @see #getRestrictedWithoutUndefined(JSType)\n+   */\n+  private final Visitor<JSType> restrictUndefinedVisitor =\n+    new Visitor<JSType>() {\n+      @Override\n+      public JSType caseEnumElementType(EnumElementType enumElementType) {\n+        JSType type = enumElementType.getPrimitiveType().visit(this);\n+        if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n+          return enumElementType;\n+        } else {\n+          return type;\n+        }\n+      }\n+\n+      @Override\n+      public JSType caseAllType() {\n+        return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE,\n+            STRING_TYPE, BOOLEAN_TYPE, NULL_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseNoObjectType() {\n+        return getNativeType(NO_OBJECT_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseNoType() {\n+        return getNativeType(NO_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseBooleanType() {\n+        return getNativeType(BOOLEAN_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseFunctionType(FunctionType type) {\n+        return type;\n+      }\n+\n+      @Override\n+      public JSType caseNullType() {\n+        return getNativeType(NULL_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseNumberType() {\n+        return getNativeType(NUMBER_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseObjectType(ObjectType type) {\n+        return type;\n+      }\n+\n+      @Override\n+      public JSType caseStringType() {\n+        return getNativeType(STRING_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseUnionType(UnionType type) {\n+        return type.getRestrictedUnion(getNativeType(VOID_TYPE));\n+      }\n+\n+      @Override\n+      public JSType caseUnknownType() {\n+        return getNativeType(UNKNOWN_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseVoidType() {\n+        return null;\n+      }\n+    };\n+\n+\n+  /**\n+   * @see #getRestrictedWithoutNull(JSType)\n+   */\n+  private final Visitor<JSType> restrictNullVisitor =\n+    new Visitor<JSType>() {\n+      @Override\n+      public JSType caseEnumElementType(EnumElementType enumElementType) {\n+        JSType type = enumElementType.getPrimitiveType().visit(this);\n+        if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n+          return enumElementType;\n+        } else {\n+          return type;\n+        }\n+      }\n+\n+      @Override\n+      public JSType caseAllType() {\n+        return typeRegistry.createUnionType(OBJECT_TYPE, NUMBER_TYPE,\n+            STRING_TYPE, BOOLEAN_TYPE, VOID_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseNoObjectType() {\n+        return getNativeType(NO_OBJECT_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseNoType() {\n+        return getNativeType(NO_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseBooleanType() {\n+        return getNativeType(BOOLEAN_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseFunctionType(FunctionType type) {\n+        return type;\n+      }\n+\n+      @Override\n+      public JSType caseNullType() {\n+        return null;\n+      }\n+\n+      @Override\n+      public JSType caseNumberType() {\n+        return getNativeType(NUMBER_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseObjectType(ObjectType type) {\n+        return type;\n+      }\n+\n+      @Override\n+      public JSType caseStringType() {\n+        return getNativeType(STRING_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseUnionType(UnionType type) {\n+        return type.getRestrictedUnion(getNativeType(NULL_TYPE));\n+      }\n+\n+      @Override\n+      public JSType caseUnknownType() {\n+        return getNativeType(UNKNOWN_TYPE);\n+      }\n+\n+      @Override\n+      public JSType caseVoidType() {\n+        return getNativeType(VOID_TYPE);\n+      }\n+    };\n+\n+  /**\n+   * A class common to all visitors that need to restrict the type based on\n+   * {@code typeof}-like conditions.\n+   */\n+  abstract class RestrictByTypeOfResultVisitor\n+      implements Visitor<JSType> {\n+\n+    /**\n+     * Abstracts away the similarities between visiting the unknown type and the\n+     * all type.\n+     * @param topType {@code UNKNOWN_TYPE} or {@code ALL_TYPE}\n+     * @return the restricted type\n+     * @see #caseAllType\n+     * @see #caseUnknownType\n+     */\n+    protected abstract JSType caseTopType(JSType topType);\n+\n+    @Override\n+    public JSType caseAllType() {\n+      return caseTopType(getNativeType(ALL_TYPE));\n+    }\n+\n+    @Override\n+    public JSType caseUnknownType() {\n+      return caseTopType(getNativeType(UNKNOWN_TYPE));\n+    }\n+\n+    @Override\n+    public JSType caseUnionType(UnionType type) {\n+      JSType restricted = null;\n+      for (JSType alternate : type.getAlternates()) {\n+        JSType restrictedAlternate = alternate.visit(this);\n+        if (restrictedAlternate != null) {\n+          if (restricted == null) {\n+            restricted = restrictedAlternate;\n+          } else {\n+            restricted = restrictedAlternate.getLeastSupertype(restricted);\n+          }\n+        }\n+      }\n+      return restricted;\n+    }\n+\n+    @Override\n+    public JSType caseNoType() {\n+      return getNativeType(NO_TYPE);\n+    }\n+\n+    @Override\n+    public JSType caseEnumElementType(EnumElementType enumElementType) {\n+      // NOTE(nicksantos): This is a white lie. Suppose we have:\n+      // /** @enum {string|number} */ var MyEnum = ...;\n+      // if (goog.isNumber(myEnumInstance)) {\n+      //   /* what is myEnumInstance here? */\n+      // }\n+      // There is no type that represents {MyEnum - string}. What we really\n+      // need is a notion of \"enum subtyping\", so that we could dynamically\n+      // create a subtype of MyEnum restricted by string. In any case,\n+      // this should catch the common case.\n+      JSType type = enumElementType.getPrimitiveType().visit(this);\n+      if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n+        return enumElementType;\n+      } else {\n+        return type;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A class common to all visitors that need to restrict the type based on\n+   * some {@code typeof}-like condition being true. All base cases return\n+   * {@code null}. It is up to the subclasses to override the appropriate ones.\n+   */\n+  abstract class RestrictByTrueTypeOfResultVisitor\n+      extends RestrictByTypeOfResultVisitor {\n+    @Override\n+    public JSType caseNoObjectType() {\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseBooleanType() {\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseFunctionType(FunctionType type) {\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseNullType() {\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseNumberType() {\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseObjectType(ObjectType type) {\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseStringType() {\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseVoidType() {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * A class common to all visitors that need to restrict the type based on\n+   * some {@code typeof}-like condition being false. All base cases return\n+   * their type. It is up to the subclasses to override the appropriate ones.\n+   */\n+  abstract class RestrictByFalseTypeOfResultVisitor\n+      extends RestrictByTypeOfResultVisitor {\n+    @Override\n+    protected JSType caseTopType(JSType topType) {\n+      return topType;\n+    }\n+\n+    @Override\n+    public JSType caseNoObjectType() {\n+      return getNativeType(NO_OBJECT_TYPE);\n+    }\n+\n+    @Override\n+    public JSType caseBooleanType() {\n+      return getNativeType(BOOLEAN_TYPE);\n+    }\n+\n+    @Override\n+    public JSType caseFunctionType(FunctionType type) {\n+      return type;\n+    }\n+\n+    @Override\n+    public JSType caseNullType() {\n+      return getNativeType(NULL_TYPE);\n+    }\n+\n+    @Override\n+    public JSType caseNumberType() {\n+      return getNativeType(NUMBER_TYPE);\n+    }\n+\n+    @Override\n+    public JSType caseObjectType(ObjectType type) {\n+      return type;\n+    }\n+\n+    @Override\n+    public JSType caseStringType() {\n+      return getNativeType(STRING_TYPE);\n+    }\n+\n+    @Override\n+    public JSType caseVoidType() {\n+      return getNativeType(VOID_TYPE);\n+    }\n+  }\n+\n+  /**\n+   * @see ChainableReverseAbstractInterpreter#getRestrictedByTypeOfResult\n+   */\n+  private class RestrictByOneTypeOfResultVisitor\n+      extends RestrictByTypeOfResultVisitor {\n+    /**\n+     * A value known to be equal or not equal to the result of the\n+     * {@code typeOf} operation.\n+     */\n+    private final String value;\n+\n+    /**\n+     * {@code true} if the {@code typeOf} result is known to equal\n+     * {@code value}; {@code false} if it is known <em>not</em> to equal\n+     * {@code value}.\n+     */\n+    private final boolean resultEqualsValue;\n+\n+    RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue) {\n+      this.value = value;\n+      this.resultEqualsValue = resultEqualsValue;\n+    }\n+\n+    /**\n+     * Computes whether the given result of a {@code typeof} operator matches\n+     * expectations, i.e. whether a type that gives such a result should be\n+     * kept.\n+     */\n+    private boolean matchesExpectation(String result) {\n+      return result.equals(value) == resultEqualsValue;\n+    }\n+\n+    @Override\n+    protected JSType caseTopType(JSType topType) {\n+      JSType result = topType;\n+      if (resultEqualsValue) {\n+        JSType typeByName = getNativeTypeForTypeOf(value);\n+        if (typeByName != null) {\n+          result = typeByName;\n+        }\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public JSType caseNoObjectType() {\n+      return (value.equals(\"object\") || value.equals(\"function\")) ==\n+          resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null;\n+    }\n+\n+    @Override\n+    public JSType caseBooleanType() {\n+      return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null;\n+    }\n+\n+    @Override\n+    public JSType caseFunctionType(FunctionType type) {\n+      return matchesExpectation(\"function\") ? type : null;\n+    }\n+\n+    @Override\n+    public JSType caseNullType() {\n+      return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null;\n+    }\n+\n+    @Override\n+    public JSType caseNumberType() {\n+      return matchesExpectation(\"number\") ? getNativeType(NUMBER_TYPE) : null;\n+    }\n+\n+    @Override\n+    public JSType caseObjectType(ObjectType type) {\n+      if (value.equals(\"function\")) {\n+        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n+        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+      }\n+      return matchesExpectation(\"object\") ? type : null;\n+    }\n+\n+    @Override\n+    public JSType caseStringType() {\n+      return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null;\n+    }\n+\n+    @Override\n+    public JSType caseVoidType() {\n+      return matchesExpectation(\"undefined\") ? getNativeType(VOID_TYPE) : null;\n+    }\n+  }\n+\n+  /**\n+   * Returns a version of type where undefined is not present.\n+   */\n+  final JSType getRestrictedWithoutUndefined(JSType type) {\n+    return type == null ? null : type.visit(restrictUndefinedVisitor);\n+  }\n+\n+  /**\n+   * Returns a version of type where null is not present.\n+   */\n+  final JSType getRestrictedWithoutNull(JSType type) {\n+    return type == null ? null : type.visit(restrictNullVisitor);\n+  }\n+\n+  /**\n+   * Returns a version of {@code type} that is restricted by some knowledge\n+   * about the result of the {@code typeof} operation.\n+   * <p>\n+   * The behavior of the {@code typeof} operator can be summarized by the\n+   * following table:\n+   * <table>\n+   * <tr><th>type</th><th>result</th></tr>\n+   * <tr><td>{@code undefined}</td><td>\"undefined\"</td></tr>\n+   * <tr><td>{@code null}</td><td>\"object\"</td></tr>\n+   * <tr><td>{@code boolean}</td><td>\"boolean\"</td></tr>\n+   * <tr><td>{@code number}</td><td>\"number\"</td></tr>\n+   * <tr><td>{@code string}</td><td>\"string\"</td></tr>\n+   * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>\n+   *     <td>\"object\"</td></tr>\n+   * <tr><td>{@code Object} (which implements [[Call]])</td>\n+   *     <td>\"function\"</td></tr>\n+   * </table>\n+   * @param type the type to restrict\n+   * @param value A value known to be equal or not equal to the result of the\n+   *        {@code typeof} operation\n+   * @param resultEqualsValue {@code true} if the {@code typeOf} result is known\n+   *        to equal {@code value}; {@code false} if it is known <em>not</em> to\n+   *        equal {@code value}\n+   * @return the restricted type or null if no version of the type matches the\n+   *         restriction\n+   */\n+  JSType getRestrictedByTypeOfResult(JSType type, String value,\n+                                     boolean resultEqualsValue) {\n+    if (type == null) {\n+      if (resultEqualsValue) {\n+        JSType result = getNativeTypeForTypeOf(value);\n+        return result == null ? getNativeType(UNKNOWN_TYPE) : result;\n+      } else {\n+        return null;\n+      }\n+    }\n+    return type.visit(\n+        new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));\n+  }\n+\n+  JSType getNativeType(JSTypeNative typeId) {\n+    return typeRegistry.getNativeType(typeId);\n+  }\n+\n+  /**\n+   * If we definitely know what a type is based on the typeof result,\n+   * return it.  Otherwise, return null.\n+   *\n+   * The typeof operation in JS is poorly defined, and this function works\n+   * for both the native typeof and goog.typeOf. It should not be made public,\n+   * because its semantics are informally defined, and would be wrong in\n+   * the general case.\n+   */\n+  private JSType getNativeTypeForTypeOf(String value) {\n+    if (value.equals(\"number\")) {\n+      return getNativeType(NUMBER_TYPE);\n+    } else if (value.equals(\"boolean\")) {\n+      return getNativeType(BOOLEAN_TYPE);\n+    } else if (value.equals(\"string\")) {\n+      return getNativeType(STRING_TYPE);\n+    } else if (value.equals(\"undefined\")) {\n+      return getNativeType(VOID_TYPE);\n+    } else if (value.equals(\"function\")) {\n+      return getNativeType(U2U_CONSTRUCTOR_TYPE);\n+    } else {\n+      return null;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\n+/*\n+ * Copyright 2007 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.type;\n+\n+import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n+\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.javascript.jscomp.CodingConvention;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.Visitor;\n+\n+import java.util.Map;\n+\n+/**\n+ * A reverse abstract interpreter (RAI) for specific closure patterns such as\n+ * {@code goog.isDef}.\n+ *\n+ */\n+public class ClosureReverseAbstractInterpreter\n+    extends ChainableReverseAbstractInterpreter {\n+\n+  /**\n+   * For when {@code goog.isArray} returns true.\n+   */\n+  private final Visitor<JSType> restrictToArrayVisitor =\n+      new RestrictByTrueTypeOfResultVisitor() {\n+        @Override\n+        protected JSType caseTopType(JSType topType) {\n+          // Ideally, we would like to return any subtype of Array.\n+          // Since that's not possible, we don't restrict the type.\n+          return topType;\n+        }\n+\n+        @Override\n+        public JSType caseObjectType(ObjectType type) {\n+          JSType arrayType = getNativeType(ARRAY_TYPE);\n+          return arrayType.isSubtype(type) ? arrayType : null;\n+        }\n+      };\n+\n+  /**\n+   * For when {@code goog.isArray} returns false.\n+   */\n+  private final Visitor<JSType> restrictToNotArrayVisitor =\n+      new RestrictByFalseTypeOfResultVisitor() {\n+        @Override\n+        public JSType caseObjectType(ObjectType type) {\n+          return type.isSubtype(getNativeType(ARRAY_TYPE)) ? null : type;\n+        }\n+      };\n+\n+  /**\n+   * For when {@code goog.isObject} returns true. This includes functions, but\n+   * not {@code null}.\n+   */\n+  private final Visitor<JSType> restrictToObjectVisitor =\n+      new RestrictByTrueTypeOfResultVisitor() {\n+        @Override\n+        protected JSType caseTopType(JSType topType) {\n+          return getNativeType(NO_OBJECT_TYPE);\n+        }\n+\n+        @Override\n+        public JSType caseObjectType(ObjectType type) {\n+          return type;\n+        }\n+\n+        @Override\n+        public JSType caseFunctionType(FunctionType type) {\n+          return type;\n+        }\n+      };\n+\n+  /**\n+   * For when {@code goog.isObject} returns false.\n+   */\n+  private final Visitor<JSType> restrictToNotObjectVisitor =\n+      new RestrictByFalseTypeOfResultVisitor() {\n+        @Override\n+        public JSType caseObjectType(ObjectType type) {\n+          return null;\n+        }\n+\n+        @Override\n+        public JSType caseFunctionType(FunctionType type) {\n+          return null;\n+        }\n+      };\n+\n+  /** Functions used to restrict types. */\n+  private Map<String, Function<TypeRestriction, JSType>> restricters;\n+\n+  /**\n+   * Creates a {@link ClosureReverseAbstractInterpreter}.\n+   */\n+  public ClosureReverseAbstractInterpreter(CodingConvention convention,\n+      final JSTypeRegistry typeRegistry) {\n+    super(convention, typeRegistry);\n+    this.restricters =\n+      new ImmutableMap.Builder<String, Function<TypeRestriction, JSType>>()\n+      .put(\"isDef\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          if (p.outcome) {\n+            return getRestrictedWithoutUndefined(p.type);\n+          } else {\n+            return null;\n+          }\n+         }\n+      })\n+      .put(\"isNull\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          if (p.outcome) {\n+            return getNativeType(NULL_TYPE);\n+          } else {\n+            return getRestrictedWithoutNull(p.type);\n+          }\n+        }\n+      })\n+      .put(\"isDefAndNotNull\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          if (p.outcome) {\n+            return getRestrictedWithoutUndefined(\n+                getRestrictedWithoutNull(p.type));\n+          } else {\n+            return null;\n+          }\n+        }\n+      })\n+      .put(\"isString\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          return getRestrictedByTypeOfResult(p.type, \"string\", p.outcome);\n+        }\n+      })\n+      .put(\"isBoolean\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          return getRestrictedByTypeOfResult(p.type, \"boolean\", p.outcome);\n+        }\n+      })\n+      .put(\"isNumber\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          return getRestrictedByTypeOfResult(p.type, \"number\", p.outcome);\n+        }\n+      })\n+      .put(\"isFunction\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          return getRestrictedByTypeOfResult(p.type, \"function\", p.outcome);\n+        }\n+      })\n+      .put(\"isArray\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          if (p.type == null) {\n+            return p.outcome ? getNativeType(ARRAY_TYPE) : null;\n+          }\n+\n+          Visitor<JSType> visitor = p.outcome ? restrictToArrayVisitor :\n+              restrictToNotArrayVisitor;\n+          return p.type.visit(visitor);\n+        }\n+      })\n+      .put(\"isObject\", new Function<TypeRestriction, JSType>() {\n+        @Override\n+        public JSType apply(TypeRestriction p) {\n+          if (p.type == null) {\n+            return p.outcome ? getNativeType(OBJECT_TYPE) : null;\n+          }\n+\n+          Visitor<JSType> visitor = p.outcome ? restrictToObjectVisitor :\n+              restrictToNotObjectVisitor;\n+          return p.type.visit(visitor);\n+        }\n+      })\n+      .build();\n+  }\n+\n+  @Override\n+  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n+      FlowScope blindScope, boolean outcome) {\n+    if (condition.isCall() && condition.getChildCount() == 2) {\n+      Node callee = condition.getFirstChild();\n+      Node param = condition.getLastChild();\n+      if (callee.isGetProp() && param.isQualifiedName()) {\n+        JSType paramType =  getTypeIfRefinable(param, blindScope);\n+        Node left = callee.getFirstChild();\n+        Node right = callee.getLastChild();\n+        if (left.isName() && \"goog\".equals(left.getString()) &&\n+            right.isString()) {\n+          Function<TypeRestriction, JSType> restricter =\n+              restricters.get(right.getString());\n+          if (restricter != null) {\n+            return restrictParameter(param, paramType, blindScope, restricter,\n+                outcome);\n+          }\n+        }\n+      }\n+    }\n+    return nextPreciserScopeKnowingConditionOutcome(\n+        condition, blindScope, outcome);\n+  }\n+\n+  private FlowScope restrictParameter(Node parameter, JSType type,\n+      FlowScope blindScope, Function<TypeRestriction, JSType> restriction,\n+      boolean outcome) {\n+    // restricting\n+    type = restriction.apply(new TypeRestriction(type, outcome));\n+\n+    // changing the scope\n+    if (type != null) {\n+      FlowScope informed = blindScope.createChildFlowScope();\n+      declareNameInScope(informed, parameter, type);\n+      return informed;\n+    } else {\n+      return blindScope;\n+    }\n+  }\n+\n+  private static class TypeRestriction {\n+    private final JSType type;\n+    private final boolean outcome;\n+\n+    private TypeRestriction(JSType type, boolean outcome) {\n+      this.type = type;\n+      this.outcome = outcome;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/type/FlowScope.java\n+/*\n+ * Copyright 2008 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.type;\n+\n+import com.google.javascript.jscomp.graph.LatticeElement;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+\n+/**\n+ * A symbol table for inferring types during data flow analysis.\n+ *\n+ * Each flow scope represents the types of all variables in the scope at\n+ * a particular point in the flow analysis.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public interface FlowScope extends StaticScope<JSType>, LatticeElement {\n+\n+  /**\n+   * Creates a child of this flow scope, to represent an instruction\n+   * directly following this one.\n+   */\n+  FlowScope createChildFlowScope();\n+\n+  /**\n+   * Defines the type of a symbol at this point in the flow.\n+   * @throws IllegalArgumentException If no slot for this symbol exists.\n+   */\n+  void inferSlotType(String symbol, JSType type);\n+\n+  /**\n+   * Infer the type of a qualified name.\n+   *\n+   * When traversing the control flow of a function, simple names are\n+   * declared at the bottom of the flow lattice. But there are far too many\n+   * qualified names to be able to do this and be performant. So the bottoms\n+   * of qualified names are declared lazily.\n+   *\n+   * Therefore, when inferring a qualified slot, we need both the \"bottom\"\n+   * type of the slot when we enter the scope, and the current type being\n+   * inferred.\n+   */\n+  void inferQualifiedSlot(Node node, String symbol, JSType bottomType,\n+      JSType inferredType);\n+\n+  /**\n+   * Optimize this scope and return a new FlowScope with faster lookup.\n+   */\n+  FlowScope optimize();\n+\n+  /**\n+   * Tries to find a unique refined variable in the refined scope, up to the\n+   * the blind scope.\n+   * @param blindScope The scope before the refinement, i.e. some parent of the\n+   *     this scope or itself.\n+   * @return The unique refined variable if found or null.\n+   */\n+  StaticSlot<JSType> findUniqueRefinedSlot(FlowScope blindScope);\n+\n+  /**\n+   * Look through the given scope, and try to find slots where it doesn't\n+   * have enough type information. Then fill in that type information\n+   * with stuff that we've inferred in the local flow.\n+   */\n+  void completeScope(StaticScope<JSType> scope);\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/type/ReverseAbstractInterpreter.java\n+/*\n+ * Copyright 2007 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.type;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * This interface defines what reversed abstract interpreters provide.\n+ * <p>Abstract interpretation is the process of interpreting a program at an\n+ * abstracted level (such as at the type level) instead of the concrete level\n+ * (the flow of values). This reversed abstract interpreter reverses the\n+ * abstract interpretation process by knowing the outcome of some computation\n+ * and calculating a preciser view of the world than the view without knowing\n+ * the outcome of the computation.</p>\n+ *\n+ */\n+public interface ReverseAbstractInterpreter {\n+  /**\n+   * Calculates a precise version of the scope knowing the outcome of the\n+   * condition.\n+   *\n+   *  @param condition the condition's expression\n+   *  @param blindScope the scope without knowledge about the outcome of the\n+   *  condition\n+   *  @param outcome the outcome of the condition\n+   */\n+  FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n+      FlowScope blindScope, boolean outcome);\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\n+/*\n+ * Copyright 2007 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.type;\n+\n+import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n+\n+import com.google.common.base.Function;\n+import com.google.javascript.jscomp.CodingConvention;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSType.TypePair;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+import com.google.javascript.rhino.jstype.UnionType;\n+import com.google.javascript.rhino.jstype.Visitor;\n+\n+/**\n+ * A reverse abstract interpreter using the semantics of the JavaScript\n+ * language as a means to reverse interpret computations. This interpreter\n+ * expects the parse tree inputs to be typed.\n+ *\n+ */\n+public class SemanticReverseAbstractInterpreter\n+    extends ChainableReverseAbstractInterpreter {\n+\n+  /**\n+   * Merging function for equality between types.\n+   */\n+  private static final Function<TypePair, TypePair> EQ =\n+    new Function<TypePair, TypePair>() {\n+      @Override\n+      public TypePair apply(TypePair p) {\n+        if (p.typeA == null || p.typeB == null) {\n+          return null;\n+        }\n+        return p.typeA.getTypesUnderEquality(p.typeB);\n+      }\n+    };\n+\n+  /**\n+   * Merging function for non-equality between types.\n+   */\n+  private static final Function<TypePair, TypePair> NE =\n+    new Function<TypePair, TypePair>() {\n+      @Override\n+      public TypePair apply(TypePair p) {\n+        if (p.typeA == null || p.typeB == null) {\n+          return null;\n+        }\n+        return p.typeA.getTypesUnderInequality(p.typeB);\n+      }\n+    };\n+\n+  /**\n+   * Merging function for strict equality between types.\n+   */\n+  private static final\n+      Function<TypePair, TypePair> SHEQ =\n+    new Function<TypePair, TypePair>() {\n+      @Override\n+      public TypePair apply(TypePair p) {\n+        if (p.typeA == null || p.typeB == null) {\n+          return null;\n+        }\n+        return p.typeA.getTypesUnderShallowEquality(p.typeB);\n+      }\n+    };\n+\n+  /**\n+   * Merging function for strict non-equality between types.\n+   */\n+  private static final\n+      Function<TypePair, TypePair> SHNE =\n+    new Function<TypePair, TypePair>() {\n+      @Override\n+      public TypePair apply(TypePair p) {\n+        if (p.typeA == null || p.typeB == null) {\n+          return null;\n+        }\n+        return p.typeA.getTypesUnderShallowInequality(p.typeB);\n+      }\n+    };\n+\n+  /**\n+   * Merging function for inequality comparisons between types.\n+   */\n+  private final\n+      Function<TypePair, TypePair> INEQ =\n+    new Function<TypePair, TypePair>() {\n+      @Override\n+      public TypePair apply(TypePair p) {\n+        return new TypePair(\n+            getRestrictedWithoutUndefined(p.typeA),\n+            getRestrictedWithoutUndefined(p.typeB));\n+      }\n+    };\n+\n+  /**\n+   * Creates a semantic reverse abstract interpreter.\n+   */\n+  public SemanticReverseAbstractInterpreter(CodingConvention convention,\n+      JSTypeRegistry typeRegistry) {\n+    super(convention, typeRegistry);\n+  }\n+\n+  @Override\n+  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n+      FlowScope blindScope, boolean outcome) {\n+    // Check for the typeof operator.\n+    int operatorToken = condition.getType();\n+    switch (operatorToken) {\n+      case Token.EQ:\n+      case Token.NE:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.CASE:\n+        Node left;\n+        Node right;\n+        if (operatorToken == Token.CASE) {\n+          left = condition.getParent().getFirstChild(); // the switch condition\n+          right = condition.getFirstChild();\n+        } else {\n+          left = condition.getFirstChild();\n+          right = condition.getLastChild();\n+        }\n+\n+        Node typeOfNode = null;\n+        Node stringNode = null;\n+        if (left.isTypeOf() && right.isString()) {\n+          typeOfNode = left;\n+          stringNode = right;\n+        } else if (right.isTypeOf() &&\n+                   left.isString()) {\n+          typeOfNode = right;\n+          stringNode = left;\n+        }\n+        if (typeOfNode != null && stringNode != null) {\n+          Node operandNode = typeOfNode.getFirstChild();\n+          JSType operandType = getTypeIfRefinable(operandNode, blindScope);\n+          if (operandType != null) {\n+            boolean resultEqualsValue = operatorToken == Token.EQ ||\n+                operatorToken == Token.SHEQ || operatorToken == Token.CASE;\n+            if (!outcome) {\n+              resultEqualsValue = !resultEqualsValue;\n+            }\n+            return caseTypeOf(operandNode, operandType, stringNode.getString(),\n+                resultEqualsValue, blindScope);\n+          }\n+        }\n+    }\n+    switch (operatorToken) {\n+      case Token.AND:\n+        if (outcome) {\n+          return caseAndOrNotShortCircuiting(condition.getFirstChild(),\n+              condition.getLastChild(), blindScope, true);\n+        } else {\n+          return caseAndOrMaybeShortCircuiting(condition.getFirstChild(),\n+              condition.getLastChild(), blindScope, true);\n+        }\n+\n+      case Token.OR:\n+        if (!outcome) {\n+          return caseAndOrNotShortCircuiting(condition.getFirstChild(),\n+              condition.getLastChild(), blindScope, false);\n+        } else {\n+          return caseAndOrMaybeShortCircuiting(condition.getFirstChild(),\n+              condition.getLastChild(), blindScope, false);\n+        }\n+\n+      case Token.EQ:\n+        if (outcome) {\n+          return caseEquality(condition, blindScope, EQ);\n+        } else {\n+          return caseEquality(condition, blindScope, NE);\n+        }\n+\n+      case Token.NE:\n+        if (outcome) {\n+          return caseEquality(condition, blindScope, NE);\n+        } else {\n+          return caseEquality(condition, blindScope, EQ);\n+        }\n+\n+      case Token.SHEQ:\n+        if (outcome) {\n+          return caseEquality(condition, blindScope, SHEQ);\n+        } else {\n+          return caseEquality(condition, blindScope, SHNE);\n+        }\n+\n+      case Token.SHNE:\n+        if (outcome) {\n+          return caseEquality(condition, blindScope, SHNE);\n+        } else {\n+          return caseEquality(condition, blindScope, SHEQ);\n+        }\n+\n+      case Token.NAME:\n+      case Token.GETPROP:\n+        return caseNameOrGetProp(condition, blindScope, outcome);\n+\n+      case Token.ASSIGN:\n+        return firstPreciserScopeKnowingConditionOutcome(\n+            condition.getFirstChild(),\n+            firstPreciserScopeKnowingConditionOutcome(\n+                condition.getFirstChild().getNext(), blindScope, outcome),\n+            outcome);\n+\n+      case Token.NOT:\n+        return firstPreciserScopeKnowingConditionOutcome(\n+            condition.getFirstChild(), blindScope, !outcome);\n+\n+      case Token.LE:\n+      case Token.LT:\n+      case Token.GE:\n+      case Token.GT:\n+        if (outcome) {\n+          return caseEquality(condition, blindScope, INEQ);\n+        }\n+        break;\n+\n+      case Token.INSTANCEOF:\n+        return caseInstanceOf(\n+            condition.getFirstChild(), condition.getLastChild(), blindScope,\n+            outcome);\n+\n+      case Token.IN:\n+        if (outcome && condition.getFirstChild().isString()) {\n+          return caseIn(condition.getLastChild(),\n+              condition.getFirstChild().getString(), blindScope);\n+        }\n+        break;\n+\n+      case Token.CASE:\n+        Node left =\n+            condition.getParent().getFirstChild(); // the switch condition\n+        Node right = condition.getFirstChild();\n+        if (outcome) {\n+          return caseEquality(left, right, blindScope, SHEQ);\n+        } else {\n+          return caseEquality(left, right, blindScope, SHNE);\n+        }\n+    }\n+    return nextPreciserScopeKnowingConditionOutcome(\n+        condition, blindScope, outcome);\n+  }\n+\n+  private FlowScope caseEquality(Node condition, FlowScope blindScope,\n+      Function<TypePair, TypePair> merging) {\n+    return caseEquality(condition.getFirstChild(), condition.getLastChild(),\n+                        blindScope, merging);\n+  }\n+\n+  private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n+      Function<TypePair, TypePair> merging) {\n+    // left type\n+    JSType leftType = getTypeIfRefinable(left, blindScope);\n+    boolean leftIsRefineable;\n+    if (leftType != null) {\n+      leftIsRefineable = true;\n+    } else {\n+      leftIsRefineable = false;\n+      leftType = left.getJSType();\n+    }\n+\n+    // right type\n+    JSType rightType = getTypeIfRefinable(right, blindScope);\n+    boolean rightIsRefineable;\n+    if (rightType != null) {\n+      rightIsRefineable = true;\n+    } else {\n+      rightIsRefineable = false;\n+      rightType = right.getJSType();\n+    }\n+\n+    // merged types\n+    TypePair merged = merging.apply(new TypePair(leftType, rightType));\n+\n+    // creating new scope\n+    if (merged != null &&\n+        ((leftIsRefineable && merged.typeA != null) ||\n+         (rightIsRefineable && merged.typeB != null))) {\n+      FlowScope informed = blindScope.createChildFlowScope();\n+      if (leftIsRefineable && merged.typeA != null) {\n+        declareNameInScope(informed, left, merged.typeA);\n+      }\n+      if (rightIsRefineable && merged.typeB != null) {\n+        declareNameInScope(informed, right, merged.typeB);\n+      }\n+      return informed;\n+    }\n+    return blindScope;\n+  }\n+\n+  private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,\n+        FlowScope blindScope, boolean condition) {\n+    // left type\n+    JSType leftType = getTypeIfRefinable(left, blindScope);\n+    boolean leftIsRefineable;\n+    if (leftType != null) {\n+      leftIsRefineable = true;\n+    } else {\n+      leftIsRefineable = false;\n+      leftType = left.getJSType();\n+      blindScope = firstPreciserScopeKnowingConditionOutcome(\n+          left, blindScope, condition);\n+    }\n+\n+    // restricting left type\n+    leftType = (leftType == null) ? null :\n+        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\n+    if (leftType == null) {\n+      return firstPreciserScopeKnowingConditionOutcome(\n+          right, blindScope, condition);\n+    }\n+\n+    // right type\n+    JSType rightType = getTypeIfRefinable(right, blindScope);\n+    boolean rightIsRefineable;\n+    if (rightType != null) {\n+      rightIsRefineable = true;\n+    } else {\n+      rightIsRefineable = false;\n+      rightType = right.getJSType();\n+      blindScope = firstPreciserScopeKnowingConditionOutcome(\n+          right, blindScope, condition);\n+    }\n+\n+    if (condition) {\n+      rightType = (rightType == null) ? null :\n+          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\n+\n+      // creating new scope\n+      if ((leftType != null && leftIsRefineable) ||\n+          (rightType != null && rightIsRefineable)) {\n+        FlowScope informed = blindScope.createChildFlowScope();\n+        if (leftIsRefineable && leftType != null) {\n+          declareNameInScope(informed, left, leftType);\n+        }\n+        if (rightIsRefineable && rightType != null) {\n+          declareNameInScope(informed, right, rightType);\n+        }\n+        return informed;\n+      }\n+    }\n+    return blindScope;\n+  }\n+\n+  private FlowScope caseAndOrMaybeShortCircuiting(Node left, Node right,\n+      FlowScope blindScope, boolean condition) {\n+    FlowScope leftScope = firstPreciserScopeKnowingConditionOutcome(\n+        left, blindScope, !condition);\n+    StaticSlot<JSType> leftVar = leftScope.findUniqueRefinedSlot(blindScope);\n+    if (leftVar == null) {\n+      return blindScope;\n+    }\n+    FlowScope rightScope = firstPreciserScopeKnowingConditionOutcome(\n+        left, blindScope, condition);\n+    rightScope = firstPreciserScopeKnowingConditionOutcome(\n+        right, rightScope, !condition);\n+    StaticSlot<JSType> rightVar = rightScope.findUniqueRefinedSlot(blindScope);\n+    if (rightVar == null || !leftVar.getName().equals(rightVar.getName())) {\n+      return blindScope;\n+    }\n+    JSType type = leftVar.getType().getLeastSupertype(rightVar.getType());\n+    FlowScope informed = blindScope.createChildFlowScope();\n+    informed.inferSlotType(leftVar.getName(), type);\n+    return informed;\n+  }\n+\n+  private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,\n+      boolean outcome) {\n+    JSType type = getTypeIfRefinable(name, blindScope);\n+    if (type != null) {\n+      JSType restrictedType =\n+          type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n+      FlowScope informed = blindScope.createChildFlowScope();\n+      declareNameInScope(informed, name, restrictedType);\n+      return informed;\n+    }\n+    return blindScope;\n+  }\n+\n+  private FlowScope caseTypeOf(Node node, JSType type, String value,\n+        boolean resultEqualsValue, FlowScope blindScope) {\n+    JSType restrictedType =\n+        getRestrictedByTypeOfResult(type, value, resultEqualsValue);\n+    if (restrictedType == null) {\n+      return blindScope;\n+    }\n+    FlowScope informed = blindScope.createChildFlowScope();\n+    declareNameInScope(informed, node, restrictedType);\n+    return informed;\n+  }\n+\n+  private FlowScope caseInstanceOf(Node left, Node right, FlowScope blindScope,\n+      boolean outcome) {\n+    JSType leftType = getTypeIfRefinable(left, blindScope);\n+    if (leftType == null) {\n+      return blindScope;\n+    }\n+    JSType rightType = right.getJSType();\n+    ObjectType targetType =\n+        typeRegistry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n+    if (rightType != null && rightType.isFunctionType()) {\n+      targetType = rightType.toMaybeFunctionType();\n+    }\n+    Visitor<JSType> visitor;\n+    if (outcome) {\n+      visitor = new RestrictByTrueInstanceOfResultVisitor(targetType);\n+    } else {\n+      visitor = new RestrictByFalseInstanceOfResultVisitor(targetType);\n+    }\n+    JSType restrictedLeftType = leftType.visit(visitor);\n+    if (restrictedLeftType != null && !restrictedLeftType.equals(leftType)) {\n+      FlowScope informed = blindScope.createChildFlowScope();\n+      declareNameInScope(informed, left, restrictedLeftType);\n+      return informed;\n+    }\n+    return blindScope;\n+  }\n+\n+  /**\n+   * Given 'property in object', ensures that the object has the property in the\n+   * informed scope by defining it as a qualified name if the object type lacks\n+   * the property and it's not in the blind scope.\n+   * @param object The node of the right-side of the in.\n+   * @param propertyName The string of the left-side of the in.\n+   */\n+  private FlowScope caseIn(Node object, String propertyName, FlowScope blindScope) {\n+    JSType jsType = object.getJSType();\n+    jsType = this.getRestrictedWithoutNull(jsType);\n+    jsType = this.getRestrictedWithoutUndefined(jsType);\n+\n+    boolean hasProperty = false;\n+    ObjectType objectType = ObjectType.cast(jsType);\n+    if (objectType != null) {\n+      hasProperty = objectType.hasProperty(propertyName);\n+    }\n+    if (!hasProperty) {\n+      String qualifiedName = object.getQualifiedName();\n+      if (qualifiedName != null) {\n+        String propertyQualifiedName = qualifiedName + \".\" + propertyName;\n+        if (blindScope.getSlot(propertyQualifiedName) == null) {\n+          FlowScope informed = blindScope.createChildFlowScope();\n+          JSType unknownType = typeRegistry.getNativeType(\n+              JSTypeNative.UNKNOWN_TYPE);\n+          informed.inferQualifiedSlot(\n+              object, propertyQualifiedName, unknownType, unknownType);\n+          return informed;\n+        }\n+      }\n+    }\n+    return blindScope;\n+  }\n+\n+  /**\n+   * @see SemanticReverseAbstractInterpreter#caseInstanceOf\n+   */\n+  private class RestrictByTrueInstanceOfResultVisitor\n+      extends RestrictByTrueTypeOfResultVisitor {\n+    private final ObjectType target;\n+\n+    RestrictByTrueInstanceOfResultVisitor(ObjectType target) {\n+      this.target = target;\n+    }\n+\n+    @Override\n+    protected JSType caseTopType(JSType type) {\n+      return applyCommonRestriction(type);\n+    }\n+\n+    @Override\n+    public JSType caseUnknownType() {\n+      FunctionType funcTarget = JSType.toMaybeFunctionType(target);\n+      if (funcTarget != null && funcTarget.hasInstanceType()) {\n+        return funcTarget.getInstanceType();\n+      }\n+      return getNativeType(UNKNOWN_TYPE);\n+    }\n+\n+    @Override\n+    public JSType caseObjectType(ObjectType type) {\n+      return applyCommonRestriction(type);\n+    }\n+\n+    @Override\n+    public JSType caseUnionType(UnionType type) {\n+      return applyCommonRestriction(type);\n+    }\n+\n+    @Override\n+    public JSType caseFunctionType(FunctionType type) {\n+      return caseObjectType(type);\n+    }\n+\n+    private JSType applyCommonRestriction(JSType type) {\n+      if (target.isUnknownType()) {\n+        return type;\n+      }\n+\n+      FunctionType funcTarget = target.toMaybeFunctionType();\n+      if (funcTarget.hasInstanceType()) {\n+        return type.getGreatestSubtype(funcTarget.getInstanceType());\n+      }\n+\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * @see SemanticReverseAbstractInterpreter#caseInstanceOf\n+   */\n+  private class RestrictByFalseInstanceOfResultVisitor\n+      extends RestrictByFalseTypeOfResultVisitor {\n+    private final ObjectType target;\n+\n+    RestrictByFalseInstanceOfResultVisitor(ObjectType target) {\n+      this.target = target;\n+    }\n+\n+    @Override\n+    public JSType caseObjectType(ObjectType type) {\n+      if (target.isUnknownType()) {\n+        return type;\n+      }\n+\n+      FunctionType funcTarget = target.toMaybeFunctionType();\n+      if (funcTarget.hasInstanceType()) {\n+        if (type.isSubtype(funcTarget.getInstanceType())) {\n+          return null;\n+        }\n+\n+        return type;\n+      }\n+\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseUnionType(UnionType type) {\n+      if (target.isUnknownType()) {\n+        return type;\n+      }\n+\n+      FunctionType funcTarget = target.toMaybeFunctionType();\n+      if (funcTarget.hasInstanceType()) {\n+        return type.getRestrictedUnion(funcTarget.getInstanceType());\n+      }\n+\n+      return null;\n+    }\n+\n+    @Override\n+    public JSType caseFunctionType(FunctionType type) {\n+      return caseObjectType(type);\n+    }\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n \n   private void assertNotObjectLiteralCast(String code) {\n     Node n = parseTestCode(code);\n-    assertNull(conv.getObjectLiteralCast(null, n.getFirstChild()));\n+    assertNull(conv.getObjectLiteralCast(n.getFirstChild()));\n   }\n \n   private void assertObjectLiteralCast(String code) {\n     Node n = parseTestCode(code);\n-    assertNotNull(conv.getObjectLiteralCast(null, n.getFirstChild()));\n+    assertNotNull(conv.getObjectLiteralCast(n.getFirstChild()));\n   }\n \n   private void assertNotClassDefining(String code) {\n--- a/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.FlowScope;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n \n public class ClosureReverseAbstractInterpreterTest extends\n     CompilerTypeTestCase {\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n import com.google.javascript.jscomp.DataFlowAnalysis.MaxIterationsExceededException;\n import com.google.javascript.jscomp.JoinOp.BinaryJoinOp;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.GraphNode;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.LatticeElement;\n \n import junit.framework.TestCase;\n \n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n--- a/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n+++ b/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.type.FlowScope;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n-\n \n /**\n  * Tests for LinkedFlowScope.\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n--- a/test/com/google/javascript/jscomp/RemoveUnusedNamesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedNamesTest.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n \n /**\n--- a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n+++ b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.type.FlowScope;\n+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState;\n+import com.google.javascript.jscomp.type.FlowScope;\n+import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.EnumType;\n import com.google.javascript.rhino.jstype.JSType;", "timestamp": 1333498260, "metainfo": ""}