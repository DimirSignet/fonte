{"sha": "0b054d7d1b185b02c595c646bc0f11a6d809c934", "log": "Automated g4 rollback  *** Reason for rollback ***  Disable cast warnings by default. Most projects however have it turn up to ERROR.  *** Original change description ***  Automated g4 rollback.  *** Reason for rollback ***  breaks various projects without whitelists  *** Original change description ***  Introduced a CAST ast node  R=nicksantos DELTA=1968  (1746 added, 44 deleted, 178 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5970   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n       case Token.TYPEOF:\n       case Token.VOID:\n       case Token.BITNOT:\n+      case Token.CAST:\n         validateUnaryOp(n);\n         return;\n \n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n             last, getContextForNonEmptyExpression(context), true);\n         break;\n \n+      case Token.CAST:\n+        add(\"(\");\n+        add(first);\n+        add(\")\");\n+        break;\n+\n       default:\n         throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       case Token.TRUE:\n       case Token.FALSE:\n         return true;\n+      case Token.CAST:\n       case Token.NOT:\n         return isImmutableValue(n.getFirstChild());\n       case Token.VOID:\n    */\n   static boolean isLiteralValue(Node n, boolean includeFunctions) {\n     switch (n.getType()) {\n+      case Token.CAST:\n+        return isLiteralValue(n.getFirstChild(), includeFunctions);\n+\n       case Token.ARRAYLIT:\n         for (Node child = n.getFirstChild(); child != null;\n              child = child.getNext()) {\n     // that we know to be safe\n     switch (n.getType()) {\n       // other side-effect free statements and expressions\n+      case Token.CAST:\n       case Token.AND:\n       case Token.BLOCK:\n       case Token.EXPR_RESULT:\n       case Token.THIS:\n       case Token.TRUE:\n         return 15;\n+      case Token.CAST:\n+        return 16;\n \n       default: throw new Error(\"Unknown precedence for \" +\n                                Token.name(type) +\n    */\n   static boolean allResultsMatch(Node n, Predicate<Node> p) {\n     switch (n.getType()) {\n+      case Token.CAST:\n+        return allResultsMatch(n.getFirstChild(), p);\n       case Token.ASSIGN:\n       case Token.COMMA:\n         return allResultsMatch(n.getLastChild(), p);\n    */\n   static boolean anyResultsMatch(Node n, Predicate<Node> p) {\n     switch (n.getType()) {\n+      case Token.CAST:\n+        return anyResultsMatch(n.getFirstChild(), p);\n       case Token.ASSIGN:\n       case Token.COMMA:\n         return anyResultsMatch(n.getLastChild(), p);\n    */\n   static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n     switch (value.getType()) {\n+      case Token.CAST:\n+        return evaluatesToLocalValue(value.getFirstChild(), locals);\n       case Token.ASSIGN:\n         // A result that is aliased by a non-local name, is the effectively the\n         // same as returning a non-local name, but this doesn't matter if the\n                  parent.isAnd() ||\n                  (parent.isComma() && parent.getFirstChild() != n)) {\n         return getBestJSDocInfo(parent);\n+      } else if (parent.isCast()) {\n+        return parent.getJSDocInfo();\n       }\n     }\n     return info;\n         parent.isAnd() ||\n         (parent.isComma() && parent.getFirstChild() != n)) {\n       return getBestLValue(parent);\n+    } else if (parent.isCast()) {\n+      return getBestLValue(parent);\n     }\n     return null;\n   }\n       case Token.BLOCK:\n       case Token.EXPR_RESULT:\n         return false;\n+      case Token.CAST:\n+        return isExpressionResultUsed(parent);\n       case Token.HOOK:\n       case Token.AND:\n       case Token.OR:\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n             annotateConstantsByConvention(n, parent);\n           }\n           break;\n+\n+        case Token.CAST:\n+          parent.replaceChild(n, n.removeFirstChild());\n+          break;\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     boolean typeable = true;\n \n     switch (n.getType()) {\n+      case Token.CAST:\n+        Node expr = n.getFirstChild();\n+        ensureTyped(t, n, getJSType(expr));\n+\n+        // If the cast, tightens the type apply it, so it is available post\n+        // normalization.\n+        JSType castType = getJSType(n);\n+        JSType exprType = getJSType(expr);\n+        if (castType.isSubtype(exprType)) {\n+          expr.setJSType(castType);\n+        }\n+        break;\n+\n       case Token.NAME:\n         typeable = visitName(t, n, parent);\n         break;\n     JSDocInfo info = n.getJSDocInfo();\n     if (info != null) {\n       if (info.hasType()) {\n+        // TODO(johnlenz): Change this so that we only look for casts on CAST\n+        // nodes one the misplaced type annotation warning is on by default and\n+        // people have been given a chance to fix them.  As is, this is here\n+        // simply for legacy casts.\n         JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n-        // remove cast check here.\n         validator.expectCanCast(t, n, infoType, type);\n         type = infoType;\n       }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       case Token.CATCH:\n         scope = traverseCatch(n, scope);\n         break;\n-    }\n+\n+      case Token.CAST:\n+        scope = traverseChildren(n, scope);\n+        break;\n+    }\n+\n+    // TODO(johnlenz): remove this after the CAST node change has shaken out.\n     if (!n.isFunction()) {\n       JSDocInfo info = n.getJSDocInfo();\n       if (info != null && info.hasType()) {\n         JSType castType = info.getType().evaluate(syntacticScope, registry);\n \n-        // validate cast here\n-\n-        // A stubbed type cast on a qualified name should take\n+        // A stubbed type declaration on a qualified name should take\n         // effect for all subsequent accesses of that name,\n         // so treat it the same as an assign to that name.\n         if (n.isQualifiedName() &&\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n       \"found   : {1}\\n\" +\n       \"required: {2}\";\n \n+  // TODO(johnlenz): reenable this after after the next release.\n   static final DiagnosticType INVALID_CAST =\n-      DiagnosticType.warning(\"JSC_INVALID_CAST\",\n+      DiagnosticType.disabled(\"JSC_INVALID_CAST\",\n           \"invalid cast - must be a subtype or supertype\\n\" +\n           \"from: {0}\\n\" +\n           \"to  : {1}\");\n \n   /**\n    * Expect that the first type can be cast to the second type. The first type\n-   * should be either a subtype or supertype of the second.\n+   * must have some relationship with the second.\n    *\n    * @param t The node traversal.\n    * @param n The node where warnings should point.\n    * @param type The type being cast from.\n    * @param castType The type being cast to.\n    */\n-  void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) {\n-    castType = castType.restrictByNotNullOrUndefined();\n-    type = type.restrictByNotNullOrUndefined();\n-\n-    if (!type.isSubtype(castType) && !castType.isSubtype(type)) {\n+  void expectCanCast(NodeTraversal t, Node n, JSType castType, JSType type) {\n+    if (!type.canCastTo(castType)) {\n       registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n-          castType.toString(), type.toString())));\n+          type.toString(), castType.toString())));\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n   private void validateTypeAnnotations(\n       JSDocInfo info, AstNode node, Node irNode) {\n-    if (info.getType() != null) {\n+    if (info.hasType()) {\n       boolean valid = false;\n       switch (node.getType()) {\n         // Casts are valid\n     Node irNode = justTransform(node);\n     JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n     if (jsDocInfo != null) {\n+      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n       irNode.setJSDocInfo(jsDocInfo);\n     }\n     setSourceInfo(irNode, node);\n+    return irNode;\n+  }\n+\n+  private Node maybeInjectCastNode(AstNode node, JSDocInfo info, Node irNode) {\n+    if (node.getType() == com.google.javascript.rhino.head.Token.LP\n+        && node instanceof ParenthesizedExpression\n+        && info.hasType()\n+        // TODO(johnlenz): for now, attach object literal type directly.\n+        && !irNode.isObjectLit()) {\n+      irNode = newNode(Token.CAST, irNode);\n+    }\n     return irNode;\n   }\n \n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n \n     options.setWarningLevel(\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n+    options.setWarningLevel(\n+        DiagnosticGroups.CAST, CheckLevel.WARNING);\n     options.setCodingConvention(getCodingConvention());\n     return options;\n   }\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n     options.setWarningLevel(\n         DiagnosticGroups.MISPLACED_TYPE_ANNOTATION, CheckLevel.WARNING);\n+    options.setWarningLevel(\n+        DiagnosticGroups.CAST, CheckLevel.WARNING);\n     options.setCodingConvention(getCodingConvention());\n     return options;\n   }\n--- a/test/com/google/javascript/jscomp/TightenTypesTest.java\n+++ b/test/com/google/javascript/jscomp/TightenTypesTest.java\n   public TightenTypesTest() {\n     parseTypeInfo = true;\n     enableTypeCheck(CheckLevel.WARNING);\n+    enableNormalize(true);\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"}\", null);\n   }\n \n+  public void testTypeOfReduction16() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @interface */ function I() {}\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {*} x\\n\" +\n+        \" * @return {I}\\n\" +\n+        \" */\\n\" +\n+        \"function f(x) { \" +\n+        \"  if(goog.isObject(x)) {\" +\n+        \"    return /** @type {I} */(x);\" +\n+        \"  }\" +\n+        \"  return null;\" +\n+        \"}\", null);\n+  }\n+\n   public void testQualifiedNameReduction1() throws Exception {\n     testTypes(\"var x = {}; /** @type {string?} */ x.a = 'a';\\n\" +\n         \"/** @return {string} */ var f = function() {\\n\" +\n         \"/** @param {number=} x \\n * @param {number=} y */ \" +\n         \"SubFoo.prototype.bar = \" +\n         \"    function(x, y) { f(y); };\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : (number|undefined)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testInferredParam7() throws Exception {\n+    testTypes(\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"var bar = /** @type {function(number=,number=)} */ (\" +\n+        \"    function(x, y) { f(y); });\",\n         \"actual parameter 1 of f does not match formal parameter\\n\" +\n         \"found   : (number|undefined)\\n\" +\n         \"required: string\");\n         \"required: derived\");\n   }\n \n+  public void testCast3a() throws Exception {\n+    // cannot downcast\n+    testTypes(\"/** @constructor */function Base() {}\\n\" +\n+        \"/** @constructor @extends {Base} */function Derived() {}\\n\" +\n+        \"var baseInstance = new Base();\" +\n+        \"/** @type {!Derived} */ var baz = baseInstance;\\n\",\n+        \"initializing variable\\n\" +\n+        \"found   : Base\\n\" +\n+        \"required: Derived\");\n+  }\n+\n   public void testCast4() throws Exception {\n     // downcast must be explicit\n     testTypes(\"/** @constructor */function base() {}\\n\" +\n     testTypes(\"/** @constructor */function foo() {}\\n\" +\n         \"/** @constructor */function bar() {}\\n\" +\n         \"var baz = /** @type {!foo} */(new bar);\\n\",\n+        \"invalid cast - must be a subtype or supertype\\n\" +\n+        \"from: bar\\n\" +\n+        \"to  : foo\");\n+  }\n+\n+  public void testCast5a() throws Exception {\n+    // cannot explicitly cast to an unrelated type\n+    testTypes(\"/** @constructor */function foo() {}\\n\" +\n+        \"/** @constructor */function bar() {}\\n\" +\n+        \"var barInstance = new bar;\\n\" +\n+        \"var baz = /** @type {!foo} */(barInstance);\\n\",\n         \"invalid cast - must be a subtype or supertype\\n\" +\n         \"from: bar\\n\" +\n         \"to  : foo\");\n         \"required: string\");\n   }\n \n-  public void testCast17() throws Exception {\n+  public void testCast17a() throws Exception {\n     // Mostly verifying that rhino actually understands these JsDocs.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ (y)\");\n \n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = (/** @type {Foo} */ y)\");\n-\n+  }\n+\n+  public void testCast17b() throws Exception {\n     // Mostly verifying that rhino actually understands these JsDocs.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ ({})\");\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ {}\",\n         \"Type annotations are not allowed here. \" +\n         \"Are you missing parentheses?\");\n+  }\n+\n+  public void testCast19() throws Exception {\n+    testTypes(\n+        \"var x = 'string';\\n\" +\n+        \"/** @type {number} */\\n\" +\n+        \"var y = /** @type {number} */(x);\",\n+        \"invalid cast - must be a subtype or supertype\\n\" +\n+        \"from: string\\n\" +\n+        \"to  : number\");\n+  }\n+\n+  public void testCast20() throws Exception {\n+    testTypes(\n+        \"/** @enum {boolean|null} */\\n\" +\n+        \"var X = {\" +\n+        \"  AA: true,\" +\n+        \"  BB: false,\" +\n+        \"  CC: null\" +\n+        \"};\\n\" +\n+        \"var y = /** @type {X} */(true);\");\n+  }\n+\n+  public void testCast21() throws Exception {\n+    testTypes(\n+        \"/** @enum {boolean|null} */\\n\" +\n+        \"var X = {\" +\n+        \"  AA: true,\" +\n+        \"  BB: false,\" +\n+        \"  CC: null\" +\n+        \"};\\n\" +\n+        \"var value = true;\\n\" +\n+        \"var y = /** @type {X} */(value);\");\n+  }\n+\n+  public void testCast22() throws Exception {\n+    testTypes(\n+        \"var x = null;\\n\" +\n+        \"var y = /** @type {number} */(x);\",\n+        \"invalid cast - must be a subtype or supertype\\n\" +\n+        \"from: null\\n\" +\n+        \"to  : number\");\n+  }\n+\n+  public void testCast23() throws Exception {\n+    testTypes(\n+        \"var x = null;\\n\" +\n+        \"var y = /** @type {Number} */(x);\");\n+  }\n+\n+  public void testCast24() throws Exception {\n+    testTypes(\n+        \"var x = undefined;\\n\" +\n+        \"var y = /** @type {number} */(x);\",\n+        \"invalid cast - must be a subtype or supertype\\n\" +\n+        \"from: undefined\\n\" +\n+        \"to  : number\");\n+  }\n+\n+  public void testCast25() throws Exception {\n+    testTypes(\n+        \"var x = undefined;\\n\" +\n+        \"var y = /** @type {number|undefined} */(x);\");\n+  }\n+\n+  public void testCast26() throws Exception {\n+    testTypes(\n+        \"function fn(dir) {\\n\" +\n+        \"  var node = dir ? 1 : 2;\\n\" +\n+        \"  fn(/** @type {number} */ (node));\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testCast27() throws Exception {\n+    // C doesn't implement I but a subtype might.\n+    testTypes(\n+        \"/** @interface */ function I() {}\\n\" +\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"var y = /** @type {I} */(x);\");\n+  }\n+\n+  public void testCast27a() throws Exception {\n+    // C doesn't implement I but a subtype might.\n+    testTypes(\n+        \"/** @interface */ function I() {}\\n\" +\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {C} */ var x ;\\n\" +\n+        \"var y = /** @type {I} */(x);\");\n+  }\n+\n+  public void testCast28() throws Exception {\n+    // C doesn't implement I but a subtype might.\n+    testTypes(\n+        \"/** @interface */ function I() {}\\n\" +\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {!I} */ var x;\\n\" +\n+        \"var y = /** @type {C} */(x);\");\n+  }\n+\n+  public void testCast28a() throws Exception {\n+    // C doesn't implement I but a subtype might.\n+    testTypes(\n+        \"/** @interface */ function I() {}\\n\" +\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {I} */ var x;\\n\" +\n+        \"var y = /** @type {C} */(x);\");\n+  }\n+\n+  public void testCast29a() throws Exception {\n+    // C doesn't implement the record type but a subtype might.\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"var x = new C();\\n\" +\n+        \"var y = /** @type {{remoteJids: Array, sessionId: string}} */(x);\");\n+  }\n+\n+  public void testCast29b() throws Exception {\n+    // C doesn't implement the record type but a subtype might.\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {C} */ var x;\\n\" +\n+        \"var y = /** @type {{prop1: Array, prop2: string}} */(x);\");\n+  }\n+\n+  public void testCast29c() throws Exception {\n+    // C doesn't implement the record type but a subtype might.\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {{remoteJids: Array, sessionId: string}} */ var x ;\\n\" +\n+        \"var y = /** @type {C} */(x);\");\n+  }\n+\n+  public void testCast30() throws Exception {\n+    // Should be able to cast to a looser return type\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {function():string} */ var x ;\\n\" +\n+        \"var y = /** @type {function():?} */(x);\");\n+  }\n+\n+  public void testCast31() throws Exception {\n+    // Should be able to cast to a tighter parameter type\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {function(*)} */ var x ;\\n\" +\n+        \"var y = /** @type {function(string)} */(x);\");\n+  }\n+\n+  public void testCast32() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {Object} */ var x ;\\n\" +\n+        \"var y = /** @type {null|{length:number}} */(x);\");\n+  }\n+\n+  public void testCast33() throws Exception {\n+    // null and void should be assignable to any type that accepts one or the\n+    // other or both.\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {null|undefined} */ var x ;\\n\" +\n+        \"var y = /** @type {string?|undefined} */(x);\");\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {null|undefined} */ var x ;\\n\" +\n+        \"var y = /** @type {string|undefined} */(x);\");\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {null|undefined} */ var x ;\\n\" +\n+        \"var y = /** @type {string?} */(x);\");\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {null|undefined} */ var x ;\\n\" +\n+        \"var y = /** @type {null} */(x);\");\n+  }\n+\n+  public void testCast34a() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {Object} */ var x ;\\n\" +\n+        \"var y = /** @type {Function} */(x);\");\n+  }\n+\n+  public void testCast34b() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function C() {}\\n\" +\n+        \"/** @type {Function} */ var x ;\\n\" +\n+        \"var y = /** @type {Object} */(x);\");\n   }\n \n   public void testNestedCasts() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n     verify(\"x\", NUMBER_TYPE);\n   }\n \n+  public void testExprWithinCast() {\n+    assuming(\"x\", OBJECT_TYPE);\n+    inFunction(\"/** @type {string} */ (x = 1);\");\n+    verify(\"x\", NUMBER_TYPE);\n+  }\n+\n   public void testGetProp() {\n     assuming(\"x\", createNullableType(OBJECT_TYPE));\n     inFunction(\"x.y();\");", "timestamp": 1355361504, "metainfo": ""}