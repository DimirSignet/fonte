{"sha": "e97b7c780615e11ebe76e034b44ef0ef28a5520a", "log": "Allow generated externs to use '?'.  R=nicksantos DELTA=219 (112 added, 49 deleted, 58 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6144   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n import com.google.debugging.sourcemap.FilePosition;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n     private boolean outputTypes = false;\n     private SourceMap sourceMap = null;\n     private boolean tagAsStrict;\n+    private JSTypeRegistry registry;\n \n     /**\n      * Sets the root node from which to generate the source code.\n       return this;\n     }\n \n+    Builder setTypeRegistry(JSTypeRegistry registry) {\n+      this.registry = registry;\n+      return this;\n+    }\n+\n     /**\n      * Sets whether pretty printing should be used.\n      * @param prettyPrint If true, pretty printing will be used.\n               ? Format.PRETTY\n               : Format.COMPACT;\n \n-      return toSource(root, outputFormat, options, sourceMap, tagAsStrict);\n+      return toSource(root, outputFormat, options, registry,\n+          sourceMap, tagAsStrict);\n     }\n   }\n \n    * Converts a tree to JS code\n    */\n   private static String toSource(Node root, Format outputFormat,\n-      CompilerOptions options, SourceMap sourceMap,  boolean tagAsStrict) {\n+      CompilerOptions options, JSTypeRegistry registry,\n+      SourceMap sourceMap,  boolean tagAsStrict) {\n     Preconditions.checkState(options.sourceMapDetailLevel != null);\n \n     boolean createSourceMap = (sourceMap != null);\n             options.sourceMapDetailLevel);\n     CodeGenerator cg =\n         outputFormat == Format.TYPED\n-        ? new TypedCodeGenerator(mcp, options)\n+        ? new TypedCodeGenerator(mcp, options, registry)\n         : new CodeGenerator(mcp, options);\n \n     if (tagAsStrict) {\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n    */\n   public String getGeneratedExterns() {\n     CodePrinter.Builder builder = new CodePrinter.Builder(externsRoot)\n-      .setPrettyPrint(true).setOutputTypes(true);\n+      .setPrettyPrint(true)\n+      .setOutputTypes(true)\n+      .setTypeRegistry(compiler.getTypeRegistry());\n \n     return builder.build();\n   }\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.Set;\n  * constructors.\n  */\n class TypedCodeGenerator extends CodeGenerator {\n-  TypedCodeGenerator(CodeConsumer consumer, CompilerOptions options) {\n+  private final JSTypeRegistry registry;\n+  TypedCodeGenerator(\n+      CodeConsumer consumer, CompilerOptions options, JSTypeRegistry registry) {\n     super(consumer, options);\n+    Preconditions.checkNotNull(registry);\n+    this.registry = registry;\n   }\n \n   @Override\n    */\n   private String getFunctionAnnotation(Node fnNode) {\n     Preconditions.checkState(fnNode.isFunction());\n+    JSType type = fnNode.getJSType();\n+\n+    if (type == null || type.isUnknownType()) {\n+      return \"\";\n+    }\n+\n+    FunctionType funType = type.toMaybeFunctionType();\n+\n+    if (JSType.isEquivalent(\n+        type, registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE))) {\n+      return \"/** @type {!Function} */\\n\";\n+    }\n+\n     StringBuilder sb = new StringBuilder(\"/**\\n\");\n \n-    JSType type = fnNode.getJSType();\n-\n-    if (type == null || type.isUnknownType()) {\n-      return \"\";\n-    }\n-\n-    FunctionType funType = type.toMaybeFunctionType();\n \n     // We need to use the child nodes of the function as the nodes for the\n     // parameters of the function type do not have the real parameter names.\n     // Return type\n     JSType retType = funType.getReturnType();\n     if (retType != null &&\n-        (retType.isTemplateType() || !retType.isUnknownType()) &&\n-        !retType.isEmptyType()) {\n+        !retType.isEmptyType() && // There is no annotation for the empty type.\n+        !funType.isInterface()) { // Interfaces never return a value.\n       sb.append(\" * \");\n       appendAnnotation(sb, \"return\", retType.toAnnotationString());\n       sb.append(\"\\n\");\n     JSType parameterType = parameterNode.getJSType();\n     String typeString;\n \n-    // Emit unknown types as '*' (AllType) since '?' (UnknownType) is not\n-    // a valid JSDoc type.\n-    // TODO(johnlenz): Removing '?' is incorrect, update code\n-    if (!parameterType.isTemplateType() && parameterType.isUnknownType()) {\n-      typeString = \"*\";\n+    if (parameterNode.isOptionalArg()) {\n+      typeString = restrictByUndefined(parameterType).toAnnotationString() +\n+          \"=\";\n+    } else if (parameterNode.isVarArgs()) {\n+      typeString = \"...\" +\n+          restrictByUndefined(parameterType).toAnnotationString();\n     } else {\n-      // Fix-up optional and vararg parameters to match JSDoc type language\n-      if (parameterNode.isOptionalArg()) {\n-        typeString =\n-            parameterType.restrictByNotNullOrUndefined().toAnnotationString() +\n-            \"=\";\n-      } else if (parameterNode.isVarArgs()) {\n-        typeString = \"...\" +\n-            parameterType.restrictByNotNullOrUndefined().toAnnotationString();\n-      } else {\n-        typeString = parameterType.toAnnotationString();\n-      }\n+      typeString = parameterType.toAnnotationString();\n     }\n \n     return typeString;\n   }\n+\n+  private JSType restrictByUndefined(JSType type) {\n+    if (type.isUnionType()) {\n+      return type.toMaybeUnionType().getRestrictedUnion(\n+          registry.getNativeType(JSTypeNative.VOID_TYPE));\n+    }\n+    return type;\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n import java.util.List;\n \n public class CodePrinterTest extends TestCase {\n-  boolean trustedStrings = true;\n+  private boolean trustedStrings = true;\n+  private Compiler lastCompiler = null;\n \n   @Override public void setUp() {\n     trustedStrings = true;\n+    lastCompiler = null;\n   }\n \n   Node parse(String js) {\n \n   Node parse(String js, boolean checkTypes) {\n     Compiler compiler = new Compiler();\n+    lastCompiler = compiler;\n     CompilerOptions options = new CompilerOptions();\n     options.setTrustedStrings(trustedStrings);\n \n \n   String parsePrint(String js, boolean prettyprint, boolean lineBreak,\n       int lineThreshold, boolean outputTypes) {\n+    Node node = parse(js, true);\n     CompilerOptions options = new CompilerOptions();\n     options.setTrustedStrings(trustedStrings);\n     options.setPrettyPrint(prettyprint);\n     options.setLineLengthThreshold(lineThreshold);\n     options.setLineBreak(lineBreak);\n-    return new CodePrinter.Builder(parse(js, true)).setCompilerOptions(options)\n+    return new CodePrinter.Builder(node).setCompilerOptions(options)\n         .setOutputTypes(outputTypes)\n+        .setTypeRegistry(lastCompiler.getTypeRegistry())\n         .build();\n   }\n \n   String parsePrint(String js, boolean prettyprint, boolean lineBreak,\n                     int lineThreshold, boolean outputTypes,\n                     boolean tagAsStrict) {\n+    Node node = parse(js, true);\n     CompilerOptions options = new CompilerOptions();\n     options.setTrustedStrings(trustedStrings);\n     options.setPrettyPrint(prettyprint);\n     options.setLineLengthThreshold(lineThreshold);\n     options.setLineBreak(lineBreak);\n-    return new CodePrinter.Builder(parse(js, true)).setCompilerOptions(options)\n+    return new CodePrinter.Builder(node).setCompilerOptions(options)\n         .setOutputTypes(outputTypes)\n+        .setTypeRegistry(lastCompiler.getTypeRegistry())\n         .setTagAsStrict(tagAsStrict)\n         .build();\n   }\n         \"};\\n\");\n   }\n \n-  public void testU2UFunctionTypeAnnotation() {\n+  public void testU2UFunctionTypeAnnotation1() {\n     assertTypeAnnotations(\n         \"/** @type {!Function} */ var x = function() {}\",\n-        \"/**\\n * @constructor\\n */\\nvar x = function() {\\n};\\n\");\n+        \"/** @type {!Function} */\\n\" +\n+        \"var x = function() {\\n};\\n\");\n+  }\n+\n+  public void testU2UFunctionTypeAnnotation2() {\n+    // TODO(johnlenz): we currently report the type of the RHS which is not\n+    // correct, we should export the type of the LHS.\n+    assertTypeAnnotations(\n+        \"/** @type {Function} */ var x = function() {}\",\n+        \"/** @type {!Function} */\\n\" +\n+        \"var x = function() {\\n};\\n\");\n   }\n \n   public void testEmitUnknownParamTypesAsAllType() {\n     assertTypeAnnotations(\n         \"var a = function(x) {}\",\n         \"/**\\n\" +\n-        \" * @param {*} x\\n\" +\n+        \" * @param {?} x\\n\" +\n         \" * @return {undefined}\\n\" +\n         \" */\\n\" +\n         \"var a = function(x) {\\n};\\n\");\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n     compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportSymbol('foobar', a.b.c)\",\n                     \"/**\\n\" +\n-                    \" * @param {*} d\\n\" +\n-                    \" * @param {*} e\\n\" +\n-                    \" * @param {*} f\\n\" +\n+                    \" * @param {?} d\\n\" +\n+                    \" * @param {?} e\\n\" +\n+                    \" * @param {?} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"var foobar = function(d, e, f) {\\n};\\n\");\n     compileAndCheck(\"var a = function(d, e, f) {};\" +\n                     \"goog.exportSymbol('foobar', a)\",\n                     \"/**\\n\" +\n-                    \" * @param {*} d\\n\" +\n-                    \" * @param {*} e\\n\" +\n-                    \" * @param {*} f\\n\" +\n+                    \" * @param {?} d\\n\" +\n+                    \" * @param {?} e\\n\" +\n+                    \" * @param {?} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"var foobar = function(d, e, f) {\\n};\\n\");\n                     \"var a;\\n\" +\n                     \"a.b;\\n\" +\n                     \"/**\\n\" +\n-                    \" * @param {*} d\\n\" +\n-                    \" * @param {*} e\\n\" +\n-                    \" * @param {*} f\\n\" +\n+                    \" * @param {?} d\\n\" +\n+                    \" * @param {?} e\\n\" +\n+                    \" * @param {?} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"a.b.cprop = function(d, e, f) {\\n};\\n\");\n \n                     \"var a;\\n\" +\n                     \"/**\\n\" +\n-                    \" * @param {*} p1\\n\" +\n+                    \" * @param {?} p1\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"a.b = function(p1) {\\n};\\n\" +\n                     \"/**\\n\" +\n-                    \" * @param {*} d\\n\" +\n-                    \" * @param {*} e\\n\" +\n-                    \" * @param {*} f\\n\" +\n+                    \" * @param {?} d\\n\" +\n+                    \" * @param {?} e\\n\" +\n+                    \" * @param {?} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"a.b.c = function(d, e, f) {\\n};\\n\" +\n                     \"/**\\n\" +\n-                    \" * @param {*} g\\n\" +\n-                    \" * @param {*} h\\n\" +\n-                    \" * @param {*} i\\n\" +\n+                    \" * @param {?} g\\n\" +\n+                    \" * @param {?} h\\n\" +\n+                    \" * @param {?} i\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"a.b.prototype.c = function(g, h, i) {\\n};\\n\");\n                     \"var hello = {};\\n\" +\n                     \"hello.b;\\n\" +\n                     \"/**\\n\" +\n-                    \" * @param {*} d\\n\" +\n-                    \" * @param {*} e\\n\" +\n-                    \" * @param {*} f\\n\" +\n+                    \" * @param {?} d\\n\" +\n+                    \" * @param {?} e\\n\" +\n+                    \" * @param {?} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"hello.b.c = function(d, e, f) {\\n};\\n\" +\n                     \"/**\\n\" +\n-                    \" * @param {*} g\\n\" +\n-                    \" * @param {*} h\\n\" +\n-                    \" * @param {*} i\\n\" +\n+                    \" * @param {?} g\\n\" +\n+                    \" * @param {?} h\\n\" +\n+                    \" * @param {?} i\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"hello.b.prototype.c = function(g, h, i) {\\n};\\n\");\n                     \"goog.exportProperty(a.b, 'c', a.b.c);\",\n \n                     \"/**\\n\" +\n-                    \" * @param {*} p1\\n\" +\n+                    \" * @param {?} p1\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"var prefix = function(p1) {\\n};\\n\" +\n                     \"/**\\n\" +\n-                    \" * @param {*} d\\n\" +\n-                    \" * @param {*} e\\n\" +\n-                    \" * @param {*} f\\n\" +\n+                    \" * @param {?} d\\n\" +\n+                    \" * @param {?} e\\n\" +\n+                    \" * @param {?} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"prefix.c = function(d, e, f) {\\n};\\n\");\n                     \"var externalName = function() {\\n};\\n\");\n   }\n \n-  public void testExportFunctionWithOptionalArguments() {\n+  public void testExportFunctionWithOptionalArguments1() {\n+    compileAndCheck(\"var internalName;\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {number=} a\\n\" +\n+        \" */\\n\" +\n+        \"internalName = function(a) {\" +\n+        \"};\" +\n+        \"goog.exportSymbol('externalName', internalName)\",\n+        \"/**\\n\" +\n+        \" * @param {number=} a\\n\" +\n+        \" * @return {undefined}\\n\" +\n+        \" */\\n\" +\n+        \"var externalName = function(a) {\\n};\\n\");\n+  }\n+\n+  public void testExportFunctionWithOptionalArguments2() {\n     compileAndCheck(\"var internalName;\\n\" +\n         \"/**\\n\" +\n         \" * @param {number=} a\\n\" +\n         \"goog.exportSymbol('externalName', internalName)\",\n         \"/**\\n\" +\n         \" * @param {number=} a\\n\" +\n+        \" * @return {?}\\n\" +\n+        \" */\\n\" +\n+        \"var externalName = function(a) {\\n};\\n\");\n+  }\n+\n+  public void testExportFunctionWithOptionalArguments3() {\n+    compileAndCheck(\"var internalName;\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {number=} a\\n\" +\n+        \" */\\n\" +\n+        \"internalName = function(a) {\" +\n+        \"  return a;\\n\" +\n+        \"};\" +\n+        \"goog.exportSymbol('externalName', internalName)\",\n+        \"/**\\n\" +\n+        \" * @param {number=} a\\n\" +\n+        \" * @return {?}\\n\" +\n         \" */\\n\" +\n         \"var externalName = function(a) {\\n};\\n\");\n   }\n         \"var fn = function(a) {\\n};\\n\");\n   }\n \n+  public void testExportParamWithNull() throws Exception {\n+    compileAndCheck(\n+        \"/** @param {string|null=} d */\\n\" +\n+        \"var f = function(d) {};\\n\" +\n+        \"goog.exportSymbol('foobar', f)\\n\",\n+        \"/**\\n\" +\n+        \" * @param {(null|string)=} d\\n\" +\n+        \" * @return {undefined}\\n\" +\n+        \" */\\n\" +\n+        \"var foobar = function(d) {\\n\" +\n+        \"};\\n\");\n+  }\n+\n+  public void testExportConstructor() throws Exception {\n+    compileAndCheck(\"/** @constructor */ var a = function() {};\" +\n+                    \"goog.exportSymbol('foobar', a)\",\n+                    \"/**\\n\" +\n+                    \" * @return {undefined}\\n\" +\n+                    \" * @constructor\\n\" +\n+                    \" */\\n\" +\n+                    \"var foobar = function() {\\n};\\n\");\n+  }\n+\n   private void compileAndCheck(String js, String expected) {\n     Result result = compileAndExportExterns(js);\n ", "timestamp": 1358298583, "metainfo": ""}