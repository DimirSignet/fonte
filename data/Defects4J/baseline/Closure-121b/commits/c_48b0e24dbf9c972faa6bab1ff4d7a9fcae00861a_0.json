{"sha": "48b0e24dbf9c972faa6bab1ff4d7a9fcae00861a", "log": "Add support for @idgenerator {mapped} ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44543125", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Sets;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.SourcePosition;\n   boolean replaceIdGenerators = true;  // true by default for legacy reasons.\n \n   /** Id generators to replace. */\n-  Set<String> idGenerators;\n+  ImmutableMap<String, RenamingMap> idGenerators;\n \n   /**\n    * A previous map of ids (serialized to a string by a previous compile).\n     cssRenamingMap = null;\n     cssRenamingWhitelist = null;\n     processObjectPropertyString = false;\n-    idGenerators = Collections.emptySet();\n+    idGenerators = ImmutableMap.of();\n     replaceStringsFunctionDescriptions = Collections.emptyList();\n     replaceStringsPlaceholderToken = \"\";\n     replaceStringsReservedStrings = Collections.emptySet();\n    * Sets the id generators to replace.\n    */\n   public void setIdGenerators(Set<String> idGenerators) {\n-    this.idGenerators = Sets.newHashSet(idGenerators);\n+    ImmutableMap.Builder<String, RenamingMap> builder = ImmutableMap.builder();\n+    for (String name : idGenerators) {\n+       builder.put(name, UNIQUE_ID_GENERATOR);\n+    }\n+    this.idGenerators = builder.build();\n+  }\n+\n+  /**\n+   * A renaming map instance to use to signal the use of the \"inconsistent\"\n+   * id generator type.\n+   */\n+  public static final RenamingMap UNIQUE_ID_GENERATOR =\n+      ReplaceIdGenerators.UNIQUE;\n+\n+  /**\n+   * Sets the id generators to replace.\n+   */\n+  public void setIdGenerators(Map<String, RenamingMap> idGenerators) {\n+    this.idGenerators = ImmutableMap.copyOf(idGenerators);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CssRenamingMap.java\n+++ b/src/com/google/javascript/jscomp/CssRenamingMap.java\n /**\n  * Interface used by {@link ReplaceCssNames} to substitute CSS class names.\n  */\n-public interface CssRenamingMap {\n+public interface CssRenamingMap extends RenamingMap {\n \n   /** Kind of renaming map */\n   public static enum Style {\n     BY_PART,\n   }\n \n+  @Override\n   String get(String value);\n \n   Style getStyle();\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/RenamingMap.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Interface used by to substitute names.\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public interface RenamingMap {\n+  String get(String value);\n+}\n--- a/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n+++ b/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n import java.io.StringReader;\n import java.util.Collections;\n import java.util.Map;\n-import java.util.Set;\n+import java.util.Map.Entry;\n \n /**\n  * Replaces calls to id generators with ids.\n   static final DiagnosticType CONFLICTING_GENERATOR_TYPE =\n       DiagnosticType.error(\n           \"JSC_CONFLICTING_ID_GENERATOR_TYPE\",\n-          \"Id generator can only be one of consistent, inconsistent, or stable.\");\n+          \"Id generator can only be one of \" +\n+          \"consistent, inconsistent, mapped or stable.\");\n \n   static final DiagnosticType INVALID_GENERATOR_ID_MAPPING =\n       DiagnosticType.error(\n           \"JSC_INVALID_GENERATOR_ID_MAPPING\",\n           \"Invalid generator id mapping. {0}\");\n \n+  static final DiagnosticType MISSING_NAME_MAP_FOR_GENERATOR =\n+      DiagnosticType.warning(\n+          \"JSC_MISSING_NAME_MAP_FOR_GENERATOR\",\n+          \"The mapped id generator, does not have a renaming map supplied.\");\n+\n   private final AbstractCompiler compiler;\n   private final Map<String, NameSupplier> nameGenerators;\n   private final Map<String, Map<String, String>> consistNameMap;\n \n   private final boolean generatePseudoNames;\n \n+  public static final RenamingMap UNIQUE = new RenamingMap() {\n+    @Override public String get(String value) { return null; }};\n+\n   public ReplaceIdGenerators(\n-      AbstractCompiler compiler, Set<String> idGens,\n+      AbstractCompiler compiler, Map<String, RenamingMap> idGens,\n       boolean generatePseudoNames,\n       String previousMapSerialized) {\n     this.compiler = compiler;\n     this.previousMap = previousMap;\n \n     if (idGens != null) {\n-      for (String gen : idGens) {\n-        nameGenerators.put(\n-            gen, createNameSupplier(RenameStrategy.INCONSISTENT, previousMap.get(gen)));\n-        idGeneratorMaps.put(gen, Maps.<String, String>newLinkedHashMap());\n-      }\n-    }\n-  }\n-\n-  private enum RenameStrategy {\n+      for (Entry<String, RenamingMap> gen : idGens.entrySet()) {\n+        String name = gen.getKey();\n+        RenamingMap map = gen.getValue();\n+        if (map == ReplaceIdGenerators.UNIQUE) {\n+          nameGenerators.put(name,\n+              createNameSupplier(\n+                  RenameStrategy.INCONSISTENT, previousMap.get(name)));\n+        } else {\n+          nameGenerators.put(name,\n+              createNameSupplier(\n+                  RenameStrategy.MAPPED, map));\n+        }\n+        idGeneratorMaps.put(name, Maps.<String, String>newLinkedHashMap());\n+      }\n+    }\n+  }\n+\n+  enum RenameStrategy {\n     CONSISTENT,\n     INCONSISTENT,\n+    MAPPED,\n     STABLE\n   }\n \n     @Override\n     public RenameStrategy getRenameStrategy() {\n       return RenameStrategy.STABLE;\n+    }\n+  }\n+\n+  private static class MappedNameSupplier implements NameSupplier {\n+    private final RenamingMap map;\n+\n+    MappedNameSupplier(RenamingMap map) {\n+      this.map = map;\n+    }\n+\n+    @Override\n+    public String getName(String id, String name) {\n+      return map.get(name);\n+    }\n+\n+    @Override\n+    public RenameStrategy getRenameStrategy() {\n+      return RenameStrategy.MAPPED;\n     }\n   }\n \n     }\n   }\n \n+  private NameSupplier createNameSupplier(\n+      RenameStrategy renameStrategy, RenamingMap mappings) {\n+    Preconditions.checkState(renameStrategy == RenameStrategy.MAPPED);\n+    return new MappedNameSupplier(mappings);\n+  }\n+\n   private class GatherGenerators extends AbstractPostOrderCallback {\n \n     @Override\n       int numGeneratorAnnotations =\n           (doc.isConsistentIdGenerator() ? 1 : 0) +\n           (doc.isIdGenerator() ? 1 : 0) +\n-          (doc.isStableIdGenerator() ? 1 : 0);\n+          (doc.isStableIdGenerator() ? 1 : 0) +\n+          (doc.isMappedIdGenerator() ? 1 : 0);\n       if (numGeneratorAnnotations == 0) {\n         return;\n       } else if (numGeneratorAnnotations > 1) {\n       if (doc.isConsistentIdGenerator()) {\n         consistNameMap.put(name, Maps.<String, String>newLinkedHashMap());\n         nameGenerators.put(\n-            name, createNameSupplier(RenameStrategy.CONSISTENT, previousMap.get(name)));\n+            name, createNameSupplier(\n+                RenameStrategy.CONSISTENT, previousMap.get(name)));\n       } else if (doc.isStableIdGenerator()) {\n         nameGenerators.put(\n-            name, createNameSupplier(RenameStrategy.STABLE, previousMap.get(name)));\n+            name, createNameSupplier(\n+                RenameStrategy.STABLE, previousMap.get(name)));\n+      } else if (doc.isIdGenerator()) {\n+        nameGenerators.put(\n+            name, createNameSupplier(\n+                RenameStrategy.INCONSISTENT, previousMap.get(name)));\n+      } else if (doc.isMappedIdGenerator()) {\n+        NameSupplier supplier = nameGenerators.get(name);\n+        if (supplier == null\n+            || supplier.getRenameStrategy() != RenameStrategy.MAPPED) {\n+          compiler.report(t.makeError(n, MISSING_NAME_MAP_FOR_GENERATOR));\n+          // skip registering the name in the list of Generators if there no\n+          // mapping.\n+          return;\n+        }\n       } else {\n-        nameGenerators.put(\n-            name, createNameSupplier(RenameStrategy.INCONSISTENT, previousMap.get(name)));\n+        throw new IllegalStateException(\"unexpected\");\n       }\n       idGeneratorMaps.put(name, Maps.<String, String>newLinkedHashMap());\n     }\n       Node arg = n.getFirstChild().getNext();\n \n       if (arg.isString()) {\n-        String rename = getObfuscatedName(arg, callName, nameGenerator, arg.getString());\n+        String rename = getObfuscatedName(\n+            arg, callName, nameGenerator, arg.getString());\n         parent.replaceChild(n, IR.string(rename));\n         compiler.reportCodeChange();\n       } else if (arg.isObjectLit()) {\n         for (Node key : arg.children()) {\n-          String rename = getObfuscatedName(key, callName, nameGenerator, key.getString());\n+          String rename = getObfuscatedName(\n+              key, callName, nameGenerator, key.getString());\n           key.setString(rename);\n           // Prevent standard renaming by marking the key as quoted.\n           key.putBooleanProp(Node.QUOTED_PROP, true);\n       // TODO(user): Error on id not a string or object literal.\n     }\n \n-    private String getObfuscatedName(Node id, String callName, NameSupplier nameGenerator,\n-        String name) {\n+    private String getObfuscatedName(\n+        Node id, String callName, NameSupplier nameGenerator, String name) {\n       String rename = null;\n       Map<String, String> idGeneratorMap = idGeneratorMaps.get(callName);\n       String instanceId = getIdForGeneratorNode(\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n   private static final int MASK_STRUCT        = 0x00200000; // @struct\n   private static final int MASK_DICT          = 0x00400000; // @dict\n   private static final int MASK_STALBEIDGEN   = 0x00800000; // @stableIdGenerator\n-  private static final int MASK_MAPPEDIDGEN   = 0x00800000; // @idGenerator {mapped}\n+  private static final int MASK_MAPPEDIDGEN   = 0x01000000; // @idGenerator {mapped}\n \n   // 3 bit type field stored in the top 3 bits of the most significant\n   // nibble.\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n         \"var f = function() {};\" +\n         \"var s = 'a' + 'b'\",\n \n-        InstrumentMemoryAllocPass.JS_INSTRUMENT_ALLOCATION_CODE + \n+        InstrumentMemoryAllocPass.JS_INSTRUMENT_ALLOCATION_CODE +\n         \"var obj=__alloc(new Object(),\\\"i0:1\\\",4,\\\"new Unknown\\\");\" +\n         \"var o=__alloc({},\\\"i0:1\\\",5,\\\"Object\\\");\" +\n         \"var a=__alloc([],\\\"i0:1\\\",6,\\\"Array\\\");\" +\n     CompilerOptions options = createCompilerOptions();\n     testSame(options, code);\n \n-    options.idGenerators = Sets.newHashSet(\"f\");\n+    options.setIdGenerators(Sets.newHashSet(\"f\"));\n     test(options, code, \"function f() {} 'a';\");\n   }\n \n--- a/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableMap;\n \n \n /**\n \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n+    RenamingMap xidTestMap = new RenamingMap() {\n+      private final ImmutableMap<String, String> map = ImmutableMap.of(\n+          \"foo\", \":foo:\",\n+          \"bar\", \":bar:\");\n+      @Override\n+      public String get(String value) {\n+        String replacement = map.get(value);\n+        return replacement != null ? replacement : \"unknown:\" + value;\n+      }\n+    };\n+\n     lastPass = new ReplaceIdGenerators(\n         compiler,\n-        new ImmutableSet.Builder<String>()\n-            .add(\"goog.events.getUniqueId\")\n-            .add(\"goog.place.getUniqueId\")\n+        new ImmutableMap.Builder<String, RenamingMap>()\n+            .put(\"goog.events.getUniqueId\", ReplaceIdGenerators.UNIQUE)\n+            .put(\"goog.place.getUniqueId\", ReplaceIdGenerators.UNIQUE)\n+            .put(\"xid\", xidTestMap)\n             .build(),\n         generatePseudoNames,\n         previousMappings);\n \n         \"get.id = function() {};\" +\n         \"foo.bar = {a: '125lGg'}\");\n+  }\n+\n+  public void testInObjLit2() {\n+    test(\"/** @idGenerator {mapped}*/ xid = function() {};\" +\n+         \"foo.bar = {a: xid('foo')}\",\n+\n+         \"xid = function() {};\" +\n+         \"foo.bar = {a: ':foo:'}\",\n+\n+         \"xid = function() {};\" +\n+         \"foo.bar = {a: ':foo:'}\");\n+  }\n+\n+  public void testMapped() {\n+    test(\"/** @idGenerator {mapped}*/ xid = function() {};\" +\n+        \"foo.bar = xid('foo');\",\n+\n+        \"xid = function() {};\" +\n+        \"foo.bar = ':foo:';\",\n+\n+        \"xid = function() {};\" +\n+        \"foo.bar = ':foo:';\");\n   }\n \n   public void testTwoGenerators() {\n                            \"var id = function() {}; \"},\n         ReplaceIdGenerators.CONFLICTING_GENERATOR_TYPE);\n \n-    testSame(new String[] {\"/** @stableIdGenerator \\n @consistentIdGenerator \\n*/\" +\n+    testSame(new String[] {\"/** @stableIdGenerator \\n \" +\n+                           \"@consistentIdGenerator \\n*/\" +\n                            \"var id = function() {}; \"},\n         ReplaceIdGenerators.CONFLICTING_GENERATOR_TYPE);\n \n \n         \"var id = function() {};\" +\n         \"if (x) {foo.bar = 'foo_bar$0'}\");\n+  }\n+\n+  public void testUnknownMapping() {\n+    testSame(\"\" +\n+        \"/** @idGenerator {mapped} */\\n\" +\n+        \"var id = function() {};\\n\" +\n+        \"function Foo() { id('foo'); }\\n\",\n+        ReplaceIdGenerators.MISSING_NAME_MAP_FOR_GENERATOR);\n   }\n \n   private void testMap(String code, String expected, String expectedMap) {", "timestamp": 1364512784, "metainfo": ""}