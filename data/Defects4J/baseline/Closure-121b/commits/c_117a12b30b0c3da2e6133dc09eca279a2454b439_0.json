{"sha": "117a12b30b0c3da2e6133dc09eca279a2454b439", "log": "Automated g4 rollback  *** Reason for rollback ***  Breaks things  *** Original change description ***  Check for common misuses of NaN. Fixes issue 857   Revision created by MOE tool push_codebase. MOE_MIGRATION=5855   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n+/*\n+ * Copyright 2006 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Checks for misplaced semicolons, such as\n+ * <pre>\n+ * if (foo()); act_now();\n+ * </pre>\n+ * and generates warnings.\n+ *\n+ */\n+final class CheckAccidentalSemicolon extends AbstractPostOrderCallback {\n+\n+  static final DiagnosticType SUSPICIOUS_SEMICOLON = DiagnosticType.warning(\n+      \"JSC_SUSPICIOUS_SEMICOLON\",\n+      \"If this if/for/while really shouldn't have a body, use {}\");\n+\n+  private final CheckLevel level;\n+\n+  CheckAccidentalSemicolon(CheckLevel level) {\n+    this.level = level;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    Node child;\n+    switch (n.getType()) {\n+      case Token.IF:\n+        child = n.getFirstChild().getNext();  // skip the condition child\n+        break;\n+\n+      case Token.WHILE:\n+      case Token.FOR:\n+        child = NodeUtil.getLoopCodeBlock(n);\n+        break;\n+\n+      default:\n+        return;  // don't check other types\n+    }\n+\n+    // semicolons cause VOID children. Empty blocks are allowed because\n+    // that's usually intentional, especially with loops.\n+    for (; child != null; child = child.getNext()) {\n+      if ((child.isBlock()) && (!child.hasChildren())) {\n+        // Only warn on empty blocks that replaced EMPTY nodes.  BLOCKs with no\n+        // children are considered OK.\n+        if (child.wasEmptyNode()) {\n+          t.getCompiler().report(\n+              t.makeError(n, level, SUSPICIOUS_SEMICOLON));\n+        }\n+      }\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n         compiler) {\n       List<Callback> sharedCallbacks = Lists.newArrayList();\n       if (options.checkSuspiciousCode) {\n-        sharedCallbacks.add(new CheckSuspiciousCode());\n+        sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));\n       }\n \n       if (options.enables(DiagnosticGroups.GLOBAL_THIS)) {\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n       \"es5Strict, externsValidation, fileoverviewTags, globalThis, \" +\n       \"internetExplorerChecks, invalidCasts, misplacedTypeAnnotation, \" +\n       \"missingProperties, \" +\n-      \"nonStandardJsDocs, suspiciousCode, strictModuleDepCheck, \" +\n-      \"typeInvalidation, \" +\n+      \"nonStandardJsDocs, strictModuleDepCheck, typeInvalidation, \" +\n       \"undefinedNames, undefinedVars, unknownDefines, uselessCode, \" +\n       \"visibility\";\n \n       DiagnosticGroups.registerGroup(\"nonStandardJsDocs\",\n           RhinoErrorReporter.BAD_JSDOC_ANNOTATION);\n \n-  public static final DiagnosticGroup ACCESS_CONTROLS =\n+  public static DiagnosticGroup ACCESS_CONTROLS =\n       DiagnosticGroups.registerGroup(\"accessControls\",\n           DEPRECATED, VISIBILITY);\n \n       DiagnosticGroups.registerGroup(\"violatedModuleDep\",\n           VarCheck.VIOLATED_MODULE_DEP_ERROR);\n \n-  public static final DiagnosticGroup EXTERNS_VALIDATION =\n+  public static DiagnosticGroup EXTERNS_VALIDATION =\n       DiagnosticGroups.registerGroup(\"externsValidation\",\n           VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR,\n           VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n       DiagnosticGroups.registerGroup(\"missingProperties\",\n           TypeCheck.INEXISTENT_PROPERTY);\n \n+  // TODO: add more IE specific checks here.\n   public static final DiagnosticGroup INTERNET_EXPLORER_CHECKS =\n       DiagnosticGroups.registerGroup(\"internetExplorerChecks\",\n           RhinoErrorReporter.TRAILING_COMMA);\n       DiagnosticGroups.registerGroup(\"cast\",\n           TypeValidator.INVALID_CAST);\n \n-  public static final DiagnosticGroup SUSPICIOUS_CODE =\n-      DiagnosticGroups.registerGroup(\"suspiciousCode\",\n-          CheckSuspiciousCode.SUSPICIOUS_SEMICOLON,\n-          CheckSuspiciousCode.SUSPICIOUS_COMPARISON_WITH_NAN);\n-\n   /**\n    * Adds warning levels by name.\n    */\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * Gets the boolean value of a node that represents a literal. This method\n    * effectively emulates the <code>Boolean()</code> JavaScript cast function\n    * except it return UNKNOWN for known values with side-effects, use\n-   * getImpureBooleanValue if you don't care about side-effects.\n+   * getExpressionBooleanValue if you don't care about side-effects.\n    */\n   static TernaryValue getPureBooleanValue(Node n) {\n     switch (n.getType()) {\n     }\n     return result;\n   }\n-\n-  static boolean isNaN(Node n) {\n-    if ((n.isName() && n.getString().equals(\"NaN\")) ||\n-        (n.getType() == Token.DIV &&\n-         n.getFirstChild().isNumber() && n.getFirstChild().getDouble() == 0 &&\n-         n.getLastChild().isNumber() && n.getLastChild().getDouble() == 0)) {\n-      return true;\n-    }\n-    return false;\n-  }\n }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CheckAccidentalSemicolonTest.java\n+/*\n+ * Copyright 2006 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.CheckLevel;\n+\n+public class CheckAccidentalSemicolonTest extends CompilerTestCase {\n+  public CheckAccidentalSemicolonTest() {\n+    this.parseTypeInfo = true;\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new CombinedCompilerPass(compiler,\n+        new CheckAccidentalSemicolon(CheckLevel.ERROR));\n+  }\n+\n+  public void test(String js, DiagnosticType error) {\n+    test(js, error == null ? js : null, error);\n+  }\n+\n+  public void testSuspiciousSemi() {\n+    final DiagnosticType e = CheckAccidentalSemicolon.SUSPICIOUS_SEMICOLON;\n+    final DiagnosticType ok = null;  //  code is 'ok', verify no warning\n+\n+    test(\"if(x()) x = y;\", ok);\n+    test(\"if(x()); x = y;\", e);  // I've had this bug, damned ;\n+    test(\"if(x()){} x = y;\", ok);\n+\n+    test(\"if(x()) x = y; else y=z;\", ok);\n+    test(\"if(x()); else y=z;\", e);\n+    test(\"if(x()){} else y=z;\", ok);\n+    test(\"if(x()) x = y; else;\", e);\n+    test(\"if(x()) x = y; else {}\", ok);\n+\n+    test(\"while(x()) x = y;\", ok);\n+    test(\"while(x()); x = y;\", e);\n+    test(\"while(x()){} x = y;\", ok);\n+    test(\"while(x()); {x = y}\", e);\n+    test(\"while(x()){} {x = y}\", ok);\n+\n+    test(\"for(;;) x = y;\", ok);\n+    test(\"for(;;); x = y;\", e);\n+    test(\"for(;;){} x = y;\", ok);\n+    test(\"for(x in y) x = y;\", ok);\n+    test(\"for(x in y); x = y;\", e);\n+    test(\"for(x in y){} x = y;\", ok);\n+  }\n+\n+}\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n-import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n import java.util.Collection;\n import java.util.Set;\n \n-/**\n- * Tests for NodeUtil\n- */\n public class NodeUtilTest extends TestCase {\n \n   private static Node parse(String js) {\n     assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild()));\n   }\n \n-  private void assertSideEffect(boolean se, String js, boolean globalRegExp) {\n+  private void assertSideEffect(boolean se, String js, boolean GlobalRegExp) {\n     Node n = parse(js);\n     Compiler compiler = new Compiler();\n-    compiler.setHasRegExpGlobalReferences(globalRegExp);\n+    compiler.setHasRegExpGlobalReferences(GlobalRegExp);\n     assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler));\n   }\n \n     assertNodeNames(Sets.newHashSet(\"foo\"),\n         NodeUtil.getVarsDeclaredInBranch(\n             parse(\"var foo;\")));\n-    assertNodeNames(Sets.newHashSet(\"foo\", \"goo\"),\n+    assertNodeNames(Sets.newHashSet(\"foo\",\"goo\"),\n         NodeUtil.getVarsDeclaredInBranch(\n             parse(\"var foo,goo;\")));\n     assertNodeNames(Sets.<String>newHashSet(),\n   }\n \n   private boolean testValidDefineValue(String js) {\n-    Node script = parse(\"var test = \" + js + \";\");\n+    Node script = parse(\"var test = \" + js +\";\");\n     Node var = script.getFirstChild();\n     Node name = var.getFirstChild();\n     Node value = name.getFirstChild();\n     assertEquals(\"x\", getFunctionLValue(\"var x = (y, function() {});\"));\n   }\n \n-  public void testIsNaN() {\n-    assertEquals(true, NodeUtil.isNaN(getNode(\"NaN\")));\n-    assertEquals(false, NodeUtil.isNaN(getNode(\"Infinity\")));\n-    assertEquals(false, NodeUtil.isNaN(getNode(\"x\")));\n-    assertEquals(true, NodeUtil.isNaN(getNode(\"0/0\")));\n-    assertEquals(false, NodeUtil.isNaN(getNode(\"1/0\")));\n-    assertEquals(false, NodeUtil.isNaN(getNode(\"0/1\")));\n-    assertEquals(false, NodeUtil.isNaN(IR.number(0.0)));\n-  }\n-\n   public void testIsExecutedExactlyOnce() {\n     assertEquals(true, executedOnceTestCase(\"x;\"));\n ", "timestamp": 1353439964, "metainfo": ""}