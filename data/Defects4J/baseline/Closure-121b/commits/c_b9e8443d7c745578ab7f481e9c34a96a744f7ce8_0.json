{"sha": "b9e8443d7c745578ab7f481e9c34a96a744f7ce8", "log": "Delete the stale code that used to compute optimal pass orderings. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=47568706", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   private static final String OUTPUT_MARKER = \"%output%\";\n   private static final String OUTPUT_MARKER_JS_STRING = \"%output|jsstring%\";\n \n-  private final RunTimeStats runTimeStats = new RunTimeStats();\n-\n   AbstractCommandLineRunner() {\n     this(System.out, System.err);\n   }\n   public final void run() {\n     int result = 0;\n     int runs = 1;\n-    if (config.computePhaseOrdering) {\n-      runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;\n-      PhaseOptimizer.randomizeLoops();\n-    }\n     try {\n       for (int i = 0; i < runs && result == 0; i++) {\n-        runTimeStats.recordStartRun();\n         result = doRun();\n-        runTimeStats.recordEndRun();\n       }\n     } catch (AbstractCommandLineRunner.FlagUsageException e) {\n       System.err.println(e.getMessage());\n     } catch (Throwable t) {\n       t.printStackTrace();\n       result = -2;\n-    }\n-\n-    if (config.computePhaseOrdering) {\n-      runTimeStats.outputBestPhaseOrdering();\n     }\n \n     try {\n    */\n   int processResults(Result result, List<JSModule> modules, B options)\n        throws FlagUsageException, IOException {\n-    if (config.computePhaseOrdering) {\n-      return 0;\n-    }\n-\n     if (config.printPassGraph) {\n       if (compiler.getRoot() == null) {\n         return 1;\n     return rootRelativePathsMap;\n   }\n \n-  private class RunTimeStats {\n-    private long bestRunTime = Long.MAX_VALUE;\n-    private long worstRunTime = Long.MIN_VALUE;\n-    private long lastStartTime = 0;\n-    private List<List<String>> loopedPassesInBestRun = null;\n-\n-    /**\n-     * Record the start of a run.\n-     */\n-    private void recordStartRun() {\n-      lastStartTime = System.currentTimeMillis();\n-      PhaseOptimizer.clearLoopsRun();\n-    }\n-\n-    /**\n-     * Record the end of a run.\n-     */\n-    private void recordEndRun() {\n-      long endTime = System.currentTimeMillis();\n-      long length = endTime - lastStartTime;\n-      worstRunTime = Math.max(length, worstRunTime);\n-      if (length < bestRunTime) {\n-        loopedPassesInBestRun = PhaseOptimizer.getLoopsRun();\n-        bestRunTime = length;\n-      }\n-    }\n-\n-    /**\n-     * Print the best phase loop to stderr.\n-     */\n-    private void outputBestPhaseOrdering() {\n-      try {\n-        jsOutput.append(\"Best time: \" + bestRunTime + \"\\n\");\n-        jsOutput.append(\"Worst time: \" + worstRunTime + \"\\n\");\n-\n-        int i = 1;\n-        for (List<String> loop : loopedPassesInBestRun) {\n-          jsOutput.append(\n-              \"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop) + \"\\n\");\n-          i++;\n-        }\n-      } catch (IOException e) {\n-        throw new RuntimeException(\"unexpected exception\", e);\n-      }\n-    }\n-  }\n-\n   /**\n    * Configurations for the command line configs. Designed for easy\n    * building, so that we can decouple the flags-parsing library from\n       return this;\n     }\n \n-    private boolean computePhaseOrdering = false;\n-\n-    /**\n-     * Runs the compile job many times, then prints out the best phase\n-     * ordering from this run\n-     */\n-    CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) {\n-      this.computePhaseOrdering = computePhaseOrdering;\n-      return this;\n-    }\n-\n     private boolean printAst = false;\n \n     /**\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n \n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n  */\n class PhaseOptimizer implements CompilerPass {\n \n-  // This ordering is computed offline by running with compute_phase_ordering.\n+  // NOTE(user): There used to be some code that tried various orderings of\n+  // loopable passes and picked the fastest one. This code became stale\n+  // gradually and I decided to remove it. It was also never tried after the\n+  // new pass scheduler was written. If we need to revisit this order in the\n+  // future, we should write new code to do it.\n   @VisibleForTesting\n   static final List<String> OPTIMAL_ORDER = ImmutableList.of(\n      \"deadAssignmentsElimination\",\n \n   private double progress = 0.0;\n   private double progressStep = 0.0;\n-\n-  // The following static properties are only used for computing optimal\n-  // phase orderings. They should not be touched by normal compiler runs.\n-  private static boolean randomizeLoops = false;\n-  private static List<List<String>> loopsRun = Lists.newArrayList();\n-\n   private final ProgressRange progressRange;\n \n   // These fields are used during optimization loops.\n     this.inLoop = false;\n     this.crossScopeReporting = false;\n     this.timestamp = this.lastChange = START_TIME;\n-  }\n-\n-  /**\n-   * Randomizes loops. This should only be used when computing optimal phase\n-   * orderings.\n-   */\n-  static void randomizeLoops() {\n-    randomizeLoops = true;\n-  }\n-\n-  /**\n-   * Get the phase ordering of loops during this run.\n-   * Returns an empty list when the loops are not randomized.\n-   */\n-  static List<List<String>> getLoopsRun() {\n-    return loopsRun;\n-  }\n-\n-  /**\n-   * Clears the phase ordering of loops during this run.\n-   */\n-  static void clearLoopsRun() {\n-    loopsRun.clear();\n   }\n \n   /**\n     public void process(Node externs, Node root) {\n       Preconditions.checkState(!inLoop, \"Nested loops are forbidden\");\n       inLoop = true;\n-      if (randomizeLoops) {\n-        randomizePasses();\n-      } else {\n-        optimizePasses();\n-      }\n+      optimizePasses();\n \n       // Set up function-change tracking\n       scopeHandler = new ScopedChangeHandler();\n       }\n     }\n \n-    /** Re-arrange the passes in a random order. */\n-    private void randomizePasses() {\n-      Collections.shuffle(myPasses);\n-    }\n-\n     /** Re-arrange the passes in an optimal order. */\n     private void optimizePasses() {\n       // It's important that this ordering is deterministic, so that", "timestamp": 1370475920, "metainfo": ""}