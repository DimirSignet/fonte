{"sha": "b2866728fe81d4d35431946a5f17e6fc77b6793f", "log": "Don't eat Rhino parser exceptions.  Report an error instead. Also fix the error where we attempted to remove a empty SCRIPT node. Fixes issue 915. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=42648115", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n       c = next;\n     }\n \n-    if (n.isSyntheticBlock() ||  n.getParent() == null) {\n+    if (n.isSyntheticBlock() || n.isScript() || n.getParent() == null) {\n       return n;\n     }\n \n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n           \"Type annotations are not allowed here. \" +\n           \"Are you missing parentheses?\");\n \n+  static final DiagnosticType PARSE_TREE_TOO_DEEP =\n+      DiagnosticType.error(\"PARSE_TREE_TOO_DEEP\",\n+          \"Parse tree too deep.\");\n+\n   // A map of Rhino messages to their DiagnosticType.\n   private final Map<Pattern, DiagnosticType> typeMap;\n \n \n   private RhinoErrorReporter(AbstractCompiler compiler) {\n     this.compiler = compiler;\n-    typeMap = ImmutableMap.of(\n+    typeMap = ImmutableMap.<Pattern,DiagnosticType>builder()\n         // Trailing comma\n-        replacePlaceHolders(\n-            com.google.javascript.rhino.head.ScriptRuntime\n-              .getMessage0(\"msg.extra.trailing.comma\")),\n-        TRAILING_COMMA,\n+        .put(replacePlaceHolders(\n+            com.google.javascript.rhino.head.ScriptRuntime.getMessage0(\n+                \"msg.extra.trailing.comma\")),\n+            TRAILING_COMMA)\n \n         // Duplicate parameter\n-        replacePlaceHolders(\n-            com.google.javascript.rhino.head.ScriptRuntime\n-              .getMessage0(\"msg.dup.parms\")),\n-        DUPLICATE_PARAM,\n+        .put(replacePlaceHolders(\n+            com.google.javascript.rhino.head.ScriptRuntime.getMessage0(\n+                \"msg.dup.parms\")),\n+            DUPLICATE_PARAM)\n \n         // Unknown @annotations.\n-        replacePlaceHolders(ScriptRuntime.getMessage0(\"msg.bad.jsdoc.tag\")),\n-        BAD_JSDOC_ANNOTATION,\n-\n-        Pattern.compile(\"^Type annotations are not allowed here.*\"),\n-        MISPLACED_TYPE_ANNOTATION,\n+        .put(replacePlaceHolders(ScriptRuntime.getMessage0(\"msg.bad.jsdoc.tag\")),\n+            BAD_JSDOC_ANNOTATION)\n+\n+        .put(Pattern.compile(\"^Type annotations are not allowed here.*\"),\n+            MISPLACED_TYPE_ANNOTATION)\n \n         // Type annotation errors.\n-        Pattern.compile(\"^Bad type annotation.*\"),\n-        TYPE_PARSE_ERROR\n-        );\n+        .put(Pattern.compile(\"^Bad type annotation.*\"),\n+            TYPE_PARSE_ERROR)\n+\n+        // Parse tree too deep.\n+        .put(replacePlaceHolders(\n+            com.google.javascript.rhino.head.ScriptRuntime.getMessage0(\n+                \"msg.too.deep.parser.recursion\")),\n+            PARSE_TREE_TOO_DEEP)\n+        .build();\n   }\n \n   public static com.google.javascript.rhino.head.ErrorReporter\n         makeError(message, sourceName, line, lineOffset, CheckLevel.ERROR));\n   }\n \n+  protected DiagnosticType mapError(String message) {\n+    for (Entry<Pattern, DiagnosticType> entry : typeMap.entrySet()) {\n+      if (entry.getKey().matcher(message).matches()) {\n+        return entry.getValue();\n+      }\n+    }\n+    return null;\n+  }\n+\n   private JSError makeError(String message, String sourceName, int line,\n       int lineOffset, CheckLevel defaultLevel) {\n \n     // Try to see if the message is one of the rhino errors we want to\n     // expose as DiagnosticType by matching it with the regex key.\n-    for (Entry<Pattern, DiagnosticType> entry : typeMap.entrySet()) {\n-      if (entry.getKey().matcher(message).matches()) {\n-        return JSError.make(\n-            sourceName, line, lineOffset, entry.getValue(), message);\n-      }\n+    DiagnosticType type = mapError(message);\n+    if (type != null) {\n+      return JSError.make(\n+          sourceName, line, lineOffset, type, message);\n     }\n \n     return JSError.make(sourceName, line, lineOffset, defaultLevel,\n     public com.google.javascript.rhino.head.EvaluatorException\n         runtimeError(String message, String sourceName, int line,\n             String lineSource, int lineOffset) {\n+      DiagnosticType type = mapError(message);\n+      if (type != null) {\n+        super.errorAtLine(message, sourceName, line, lineOffset);\n+      }\n       return new com.google.javascript.rhino.head.EvaluatorException(\n           message, sourceName, line, lineSource, lineOffset);\n     }", "timestamp": 1361320222, "metainfo": ""}