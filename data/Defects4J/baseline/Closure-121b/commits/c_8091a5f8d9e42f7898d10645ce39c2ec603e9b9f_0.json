{"sha": "8091a5f8d9e42f7898d10645ce39c2ec603e9b9f", "log": "Open source the code coverage instrumentation pass ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=48894638", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/BitField.java\n+/*\n+ * Copyright 2004 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Implements a few functionalities of a bit field.\n+ * Copied (and re-written) in parts from 'com.google.testing.coverage.BitField'\n+ *\n+ */\n+class BitField {\n+\n+  private byte[] bytes;\n+\n+  public BitField() {\n+    this.bytes = new byte[0];\n+  }\n+\n+  /**\n+   * Sets or clears a bit at the given 0-based index.\n+   *\n+   * @param index 0-based bit position.\n+   */\n+  public void setBit(int index) {\n+    if (index < 0) {\n+      return;\n+    }\n+\n+    int byteIndex = index / 8;\n+    int newByteSize = byteIndex + 1;\n+\n+    if (bytes.length < newByteSize) {\n+      bytes = Arrays.copyOf(bytes, newByteSize);\n+    }\n+\n+    int bitIndex = index % 8;\n+    int mask = 1 << bitIndex;\n+    bytes[byteIndex] |= mask;\n+  }\n+\n+  /**\n+   * Checks whether a bit at the given 0-based index is set.\n+   *\n+   * @param index 0-based bit position\n+   * @return true if set, false otherwise\n+   */\n+  public boolean isBitSet(int index) {\n+    int byteIndex = index / 8;\n+\n+    if (byteIndex >= bytes.length) {\n+      return false;\n+    }\n+\n+    int bitIndex = index % 8;\n+    int mask = 1 << bitIndex;\n+    return (bytes[byteIndex] & mask) != 0;\n+  }\n+\n+  /**\n+   * Returns a byte-wise hex string representation of the BitField from\n+   * MSB (Most Significant Byte) to LSB (Least Significant Byte).\n+   * Eg. Single byte: a setting of \"0001 1111\", returns \"1f\"\n+   * Eg. Multiple bytes: a setting of \"0000 0010 0001 1111\", returns \"1f02\"\n+   *\n+   * @return string representation of bits set\n+   */\n+  @Override\n+  public String toString() {\n+    StringBuilder result = new StringBuilder();\n+    for (int i = 0; i < bytes.length; i++) {\n+      int byteValue = 0;\n+      for (int j = i * 8 + 7; j >= i * 8; j--) {\n+        byteValue = 2 * byteValue + (isBitSet(j) ? 1 : 0);\n+      }\n+      result.append(getHexPair(byteValue));\n+    }\n+    return result.toString();\n+  }\n+\n+  /**\n+   * Returns a hex pair string representation of the given int value.\n+   *\n+   * @param byteValue int value\n+   * @return string representation of hex pair corresponding to the int value\n+   */\n+  public static String getHexPair(int byteValue) {\n+    Preconditions.checkArgument((byteValue >= 0) && (byteValue < 256));\n+    int firstHex = (int) Math.floor(byteValue / 16);\n+    int secondHex = byteValue % 16;\n+    return Integer.toHexString(firstHex) + Integer.toHexString(secondHex);\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * Handler for compiler warnings and errors.\n    */\n   transient ErrorHandler errorHandler;\n+\n+  /**\n+   * Instrument code for the purpose of collecting coverage data.\n+   */\n+  public boolean instrumentForCoverage;\n \n   /**\n    * Initializes compiler options. All options are disabled by default.\n     propertyInvalidationErrors = Maps.newHashMap();\n \n     // Instrumentation\n-    instrumentationTemplate = null;\n-    instrumentMemoryAllocations = false;\n+    instrumentationTemplate = null;  // instrument functions\n+    instrumentMemoryAllocations = false; // instrument allocations\n+    instrumentForCoverage = false;  // instrument lines\n \n     // Output\n     printInputDelimiter = false;\n     this.instrumentMemoryAllocations = instrumentMemoryAllocations;\n   }\n \n+  /**\n+   * Set whether or not code should be modified to provide coverage\n+   * information.\n+   */\n+  public void setInstrumentForCoverage(boolean instrumentForCoverage) {\n+    this.instrumentForCoverage = instrumentForCoverage;\n+  }\n \n   //////////////////////////////////////////////////////////////////////////////\n   // Enums\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CoverageInstrumentationCallback.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.CoverageInstrumentationPass.CoverageReach;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class implements a traversal to instrument an AST for code coverage.\n+ *\n+ */\n+class CoverageInstrumentationCallback extends\n+    NodeTraversal.AbstractPostOrderCallback {\n+\n+  private final Map<String, FileInstrumentationData> instrumentationData;\n+\n+  private CoverageReach reach;\n+\n+  static final String ARRAY_NAME_PREFIX = \"JSCompiler_lcov_data_\";\n+\n+\n+  public CoverageInstrumentationCallback(\n+      Map<String, FileInstrumentationData> instrumentationData,\n+      CoverageReach reach) {\n+    this.instrumentationData = instrumentationData;\n+    this.reach = reach;\n+  }\n+\n+  /**\n+   * Returns the name of the source file from which the given node originates.\n+   * @param traversal the traversal\n+   * @return the name of the file it originates from\n+   */\n+  private String getFileName(NodeTraversal traversal) {\n+    return traversal.getSourceName();\n+  }\n+\n+  /**\n+   * Returns a string that can be used as array name. The name is based on the\n+   * source filename of the AST node.\n+   */\n+  private String createArrayName(NodeTraversal traversal) {\n+    return ARRAY_NAME_PREFIX +\n+        CoverageUtil.createIdentifierFromText(getFileName(traversal));\n+  }\n+\n+  /**\n+   * Creates and return a new instrumentation node. The instrumentation Node is\n+   * of the form: \"arrayName[lineNumber] = true;\"\n+   * Note 1: Node returns a 1-based line number.\n+   * Note 2: Line numbers in instrumentation are made 0-based. This is done to\n+   * map to their bit representation in BitField. Thus, there's a one-to-one\n+   * correspondence of the line number seen on instrumented files and their bit\n+   * encodings.\n+   *\n+   * @param lineNumber the line number corresponding to which an instrumentation\n+   *  node is needed\n+   * @return an instrumentation node corresponding to the line number\n+   */\n+  private Node newInstrumentationNode(NodeTraversal traversal, int lineNumber) {\n+    String fileName = getFileName(traversal);\n+    String arrayName = createArrayName(traversal);\n+\n+    // Create instrumentation Node\n+    //   arr[line] = true;\n+    Node nameNode = IR.name(arrayName);\n+    Node numNode = IR.number(lineNumber - 1);  // Make line number 0-based\n+    Node getElemNode = IR.getelem(nameNode, numNode);\n+    Node trueNode = IR.trueNode();\n+    Node assignNode = IR.assign(getElemNode, trueNode);\n+    Node exprNode = IR.exprResult(assignNode);\n+\n+    // Note line as instrumented\n+    if (!instrumentationData.containsKey(fileName)) {\n+      instrumentationData.put(fileName,\n+                              new FileInstrumentationData(fileName, arrayName));\n+    }\n+    instrumentationData.get(fileName).setLineAsInstrumented(lineNumber);\n+\n+    return exprNode;\n+  }\n+\n+  /**\n+   * Create and return a new array declaration node. The array name is\n+   * generated based on the source filename, and declaration is of the form:\n+   * \"var arrayNameUsedInFile = [];\"\n+   */\n+  private Node newArrayDeclarationNode(NodeTraversal traversal) {\n+    Node arraylitNode = IR.arraylit();\n+    Node nameNode = IR.name(createArrayName(traversal));\n+    nameNode.addChildToFront(arraylitNode);\n+    Node varNode = IR.var(nameNode);\n+    return varNode;\n+  }\n+\n+  /**\n+   * @returns a Node containing file specific setup logic.\n+   */\n+  private Node newHeaderNode(NodeTraversal traversal) {\n+    String fileName = getFileName(traversal);\n+    String arrayName = createArrayName(traversal);\n+    FileInstrumentationData data = instrumentationData.get(fileName);\n+    Preconditions.checkNotNull(data);\n+\n+    return IR.block(\n+      newArrayDeclarationNode(traversal),\n+      IR.exprResult(IR.call(\n+          IR.getprop(\n+              IR.name(\"JSCompiler_lcov_executedLines\"),\n+              IR.string(\"push\")),\n+          IR.name(arrayName))),\n+      IR.exprResult(IR.call(\n+          IR.getprop(\n+              IR.name(\"JSCompiler_lcov_instrumentedLines\"),\n+              IR.string(\"push\")),\n+          IR.string(data.getInstrumentedLinesAsHexString()))),\n+      IR.exprResult(IR.call(\n+          IR.getprop(\n+              IR.name(\"JSCompiler_lcov_fileNames\"),\n+              IR.string(\"push\")),\n+          IR.string(fileName))));\n+  }\n+\n+  /**\n+   * Instruments the JS code by inserting appropriate nodes into the AST. The\n+   * instrumentation logic is tuned to collect \"line coverage\" data only.\n+   */\n+  @Override\n+  public void visit(NodeTraversal traversal, Node node, Node parent) {\n+    // SCRIPT node is special - it is the root of the AST for code from a file.\n+    // Append code to declare and initialize structures used in instrumentation.\n+    if (node.isScript()) {\n+      String fileName = getFileName(traversal);\n+      if (instrumentationData.get(fileName) != null) {\n+        node.addChildToFront(newHeaderNode(traversal));\n+      }\n+      return;\n+    }\n+\n+    // Don't instrument global statements\n+    if (reach == CoverageReach.CONDITIONAL\n+        && parent != null && parent.isScript()) {\n+      return;\n+    }\n+\n+    // Add instrumentation code just before a function block.\n+    // Similarly before other constructs: 'with', 'case', 'default', 'catch'\n+    if (node.isFunction() ||\n+        node.isWith() ||\n+        node.isCase() ||\n+        node.isDefaultCase() ||\n+        node.isCatch()) {\n+      Node codeBlock = node.getLastChild();\n+      codeBlock.addChildToFront(\n+          newInstrumentationNode(traversal, node.getLineno()));\n+      return;\n+    }\n+\n+    // Add instrumentation code as the first child of a 'try' block.\n+    if (node.isTry()) {\n+      Node firstChild = node.getFirstChild();\n+      firstChild.addChildToFront(\n+          newInstrumentationNode(traversal, node.getLineno()));\n+      return;\n+    }\n+\n+    // For any other statement, add instrumentation code just before it.\n+    if (parent != null && NodeUtil.isStatementBlock(parent)) {\n+      parent.addChildBefore(\n+          newInstrumentationNode(traversal, node.getLineno()), node);\n+      return;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CoverageInstrumentationPass.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.Map;\n+\n+/**\n+ * This code implements the instrumentation pass over the AST\n+ * (returned by JSCompiler).\n+ *\n+ */\n+class CoverageInstrumentationPass implements CompilerPass {\n+\n+  final AbstractCompiler compiler;\n+  private Map<String, FileInstrumentationData> instrumentationData;\n+  private CoverageReach reach;\n+\n+  private static final String JS_INSTRUMENTATION_EXTERNS_CODE =\n+      \"var JSCompiler_lcov_executedLines;\\n\" +\n+      \"var JSCompiler_lcov_instrumentedLines;\\n\" +\n+      \"var JSCompiler_lcov_fileNames;\\n\";\n+\n+  public enum CoverageReach {\n+    ALL,\n+    CONDITIONAL\n+  }\n+\n+  /**\n+   *\n+   * @param compiler the compiler which generates the AST.\n+   */\n+  public CoverageInstrumentationPass(AbstractCompiler compiler,\n+      CoverageReach reach) {\n+    this.compiler = compiler;\n+    this.reach = reach;\n+    instrumentationData = Maps.newLinkedHashMap();\n+  }\n+\n+  /**\n+   * Creates the js code to be added to source. This code declares and\n+   * initializes the variables required for collection of coverage data.\n+   */\n+  private void addHeaderCode(Node script) {\n+    script.addChildToFront(\n+        createConditionalVarDecl(\"JSCompiler_lcov_executedLines\"));\n+    script.addChildToFront(\n+        createConditionalVarDecl(\"JSCompiler_lcov_instrumentedLines\"));\n+    script.addChildToFront(\n+        createConditionalVarDecl(\"JSCompiler_lcov_fileNames\"));\n+  }\n+\n+  /**\n+   * Creates a node of externs code required for the arrays used for\n+   * instrumentation.\n+   */\n+  private Node getInstrumentationExternsNode() {\n+    Node externsNode = compiler.parseSyntheticCode(\n+        \"ExternsCodeForCoverageInstrumentation\",\n+        JS_INSTRUMENTATION_EXTERNS_CODE);\n+\n+    return externsNode;\n+  }\n+\n+  @Override\n+  public void process(Node externsNode, Node rootNode) {\n+    if (rootNode.hasChildren()) {\n+      NodeTraversal.traverse(compiler, rootNode,\n+          new CoverageInstrumentationCallback(instrumentationData, reach));\n+\n+      Node firstScript = rootNode.getFirstChild();\n+      Preconditions.checkState(firstScript.isScript());\n+      addHeaderCode(firstScript);\n+    }\n+\n+    externsNode.addChildToBack(getInstrumentationExternsNode());\n+  }\n+\n+  private Node createConditionalVarDecl(String name) {\n+    Node var = IR.var(\n+        IR.name(name),\n+        IR.or(\n+            IR.name(name),\n+            IR.arraylit()));\n+    var.addSuppression(\"duplicate\");\n+    return var;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CoverageUtil.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * This class contains all general purpose static methods that are used by\n+ * coverage instrumentation related classes - not limited to them, though.\n+ */\n+class CoverageUtil {\n+  /**\n+   * Utility Class: do not instantiate.\n+   */\n+  private CoverageUtil() {}\n+\n+  /**\n+   * Returns a string with all non-alphanumeric characters in the given string\n+   * replaced with underscrores. This is to create a valid identifier based on\n+   * the given text.\n+   * @param inputText the text to create an identifier from\n+   * @return the new string that can be used as in identifier\n+   */\n+  static String createIdentifierFromText(String inputText) {\n+    return inputText.replaceAll(\"[^\\\\p{Alnum}]\", \"_\");\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n+import com.google.javascript.jscomp.CoverageInstrumentationPass.CoverageReach;\n import com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.Pattern;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n \n     // TODO(nicksantos): The order of these passes makes no sense, and needs\n     // to be re-arranged.\n+\n+    if (options.instrumentForCoverage) {\n+      passes.add(instrumentForCodeCoverage);\n+    }\n \n     if (options.runtimeTypeCheck) {\n       passes.add(runtimeTypeCheck);\n         @Override\n         protected CompilerPass create(final AbstractCompiler compiler) {\n           return new InstrumentMemoryAllocPass(compiler);\n+        }\n+      };\n+\n+  final PassFactory instrumentForCodeCoverage =\n+      new PassFactory(\"instrumentForCodeCoverage\", true) {\n+        @Override\n+        protected CompilerPass create(final AbstractCompiler compiler) {\n+          // TODO(johnlenz): make global instrumentation an option\n+          return new CoverageInstrumentationPass(\n+              compiler, CoverageReach.CONDITIONAL);\n         }\n       };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/FileInstrumentationData.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * Holds instrumentation details related to a file, namely, the filename,\n+ * the array name used in instrumentation, and the lines which were\n+ * instrumented (in encoded form).\n+ */\n+class FileInstrumentationData {\n+  private final BitField instrumentedBits;\n+  private final String arrayName;\n+  private final String fileName;\n+\n+\n+  FileInstrumentationData(String fileName, String arrayName) {\n+    this.fileName = fileName;\n+    this.arrayName = arrayName;\n+    instrumentedBits = new BitField();\n+  }\n+\n+  String getArrayName() {\n+    return arrayName;\n+  }\n+\n+  String getFileName() {\n+    return fileName;\n+  }\n+\n+  /**\n+   * Returns instrumented bits represented as a BitField.\n+   *\n+   * @return BitField representation of bits set\n+   */\n+  BitField getInstrumentedLinesAsBitField() {\n+    return instrumentedBits;\n+  }\n+\n+  /**\n+   * Returns a byte-wise hex string representation of the BitField from\n+   * MSB (Most Significant Byte) to LSB (Least Significant Byte).\n+   * Eg. Single byte: a setting of \"0001 1111\", returns \"1f\"\n+   * Eg. Multiple bytes: a setting of \"0000 0010 0001 1111\", returns \"1f02\"\n+   *\n+   * @return string representation of bits set\n+   */\n+  String getInstrumentedLinesAsHexString() {\n+    return instrumentedBits.toString();\n+  }\n+\n+  /**\n+   * Mark given 1-based line number as instrumented. Zero, Negative numbers\n+   * are not allowed.\n+   * @param lineNumber the line number which was instrumented\n+   */\n+  void setLineAsInstrumented(int lineNumber) {\n+    Preconditions.checkArgument(lineNumber > 0,\n+                                \"Expected non-zero positive integer as line \" +\n+                                \"number.\");\n+\n+    // Map the 1-based line number to 0-based bit position\n+    instrumentedBits.setBit(lineNumber - 1);\n+  }\n+}", "timestamp": 1373325957, "metainfo": ""}