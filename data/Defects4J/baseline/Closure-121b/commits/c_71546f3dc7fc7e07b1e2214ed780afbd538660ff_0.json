{"sha": "71546f3dc7fc7e07b1e2214ed780afbd538660ff", "log": "Fix opensource closure compiler build breakage.  R=nicksantos DELTA=4  (3 added, 0 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1862   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/regex/CaseCanonicalize.java\n+/* Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.regex;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Implements the EcmaScript 5\n+ * <a href=\"http://es5.github.com/#Canonicalize\">Canonicalize</a> operation\n+ * used to specify how case-insensitive regular expressions match.\n+ *\n+ * <p>\n+ * From section <a href=\"http://es5.github.com/#x15.10.2.9\">15.10.2.9</a>,\n+ * <blockquote>\n+ * The abstract operation Canonicalize takes a character parameter ch and\n+ * performs the following steps:\n+ * <ul>\n+ *   <li>If IgnoreCase is false, return ch.\n+ *   <li>Let u be ch converted to upper case as if by calling the standard\n+ *   built-in method {@code String.prototype.toUpperCase} on the one-character\n+ *   String ch.\n+ *   <li>If u does not consist of a single character, return ch.\n+ *   <li>Let cu be u's character.\n+ *   <li>If ch's code unit value is greater than or equal to decimal 128 and\n+ *   cu's code unit value is less than decimal 128, then return ch.\n+ *   <li>Return cu.\n+ * </ul>\n+ *\n+ */\n+public final class CaseCanonicalize {\n+\n+  private CaseCanonicalize() {\n+    // Uninstantiable.\n+  }\n+\n+  // Below are tables that implement the Canonicalize operation.\n+  // We cannot use java.lang.Character.toUpperCase since that is based on\n+  // a more modern version of Unicode than that required by the EcmaScript spec.\n+\n+  /**\n+   * Set of code units that are case-insensitively equivalent to some other\n+   * code unit according to the EcmaScript\n+   * <a href=\"http://es5.github.com/#Canonicalize\">Canonicalize</a> operation\n+   * described in section 15.10.2.8.\n+   * The case sensitive characters are the ones that canonicalize to a character\n+   * other than themselves or have a character that canonicalizes to them.\n+   * Canonicalize is based on the definition of\n+   * {@code String.prototype.toUpperCase} which is itself based on Unicode 3.0.0\n+   * as specified at\n+   * <a href=\"ftp://ftp.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\">\n+   * UnicodeData-3.0.0\n+   * </a>\n+   * and <a href=\"ftp://ftp.unicode.org/Public/3.0-Update/SpecialCasing-2.txt\">\n+   * SpecialCasings-2.txt\n+   * </a>.\n+   *\n+   * <p>\n+   * This table was generated by running the below on Chrome:\n+   * </p>\n+   * <pre>\n+   * for (var cc = 0; cc < 0x10000; ++cc) {\n+   *   var ch = String.fromCharCode(cc);\n+   *   var u = ch.toUpperCase();\n+   *   if (ch != u && u.length === 1) {\n+   *     var cu = u.charCodeAt(0);\n+   *     if (cc <= 128 || u.charCodeAt(0) > 128) {\n+   *       print('0x' + cc.toString(16) + ', 0x' + cu.toString(16) + ',');\n+   *     }\n+   *   }\n+   * }\n+   * </pre>\n+   */\n+  public static final CharRanges CASE_SENSITIVE = CharRanges.withRanges(\n+      0x41, 0x5b,\n+      0x61, 0x7b,\n+      0xb5, 0xb6,\n+      0xc0, 0xd7,\n+      0xd8, 0xdf,\n+      0xe0, 0xf7,\n+      0xf8, 0x130,\n+      0x132, 0x138,\n+      0x139, 0x149,\n+      0x14a, 0x17f,\n+      0x180, 0x18d,\n+      0x18e, 0x19b,\n+      0x19c, 0x1aa,\n+      0x1ac, 0x1ba,\n+      0x1bc, 0x1be,\n+      0x1bf, 0x1c0,\n+      0x1c4, 0x1f0,\n+      0x1f1, 0x221,\n+      0x222, 0x234,\n+      0x23a, 0x23f,\n+      0x241, 0x250,\n+      0x253, 0x255,\n+      0x256, 0x258,\n+      0x259, 0x25a,\n+      0x25b, 0x25c,\n+      0x260, 0x261,\n+      0x263, 0x264,\n+      0x268, 0x26a,\n+      0x26b, 0x26c,\n+      0x26f, 0x270,\n+      0x272, 0x273,\n+      0x275, 0x276,\n+      0x27d, 0x27e,\n+      0x280, 0x281,\n+      0x283, 0x284,\n+      0x288, 0x28d,\n+      0x292, 0x293,\n+      0x345, 0x346,\n+      0x37b, 0x37e,\n+      0x386, 0x387,\n+      0x388, 0x38b,\n+      0x38c, 0x38d,\n+      0x38e, 0x390,\n+      0x391, 0x3a2,\n+      0x3a3, 0x3b0,\n+      0x3b1, 0x3cf,\n+      0x3d0, 0x3d2,\n+      0x3d5, 0x3d7,\n+      0x3d8, 0x3f3,\n+      0x3f5, 0x3f6,\n+      0x3f7, 0x3fc,\n+      0x3fd, 0x482,\n+      0x48a, 0x514,\n+      0x531, 0x557,\n+      0x561, 0x587,\n+      0x10a0, 0x10c6,\n+      0x1d7d, 0x1d7e,\n+      0x1e00, 0x1e96,\n+      0x1e9b, 0x1e9c,\n+      0x1ea0, 0x1efa,\n+      0x1f00, 0x1f16,\n+      0x1f18, 0x1f1e,\n+      0x1f20, 0x1f46,\n+      0x1f48, 0x1f4e,\n+      0x1f51, 0x1f52,\n+      0x1f53, 0x1f54,\n+      0x1f55, 0x1f56,\n+      0x1f57, 0x1f58,\n+      0x1f59, 0x1f5a,\n+      0x1f5b, 0x1f5c,\n+      0x1f5d, 0x1f5e,\n+      0x1f5f, 0x1f7e,\n+      0x1fb0, 0x1fb2,\n+      0x1fb8, 0x1fbc,\n+      0x1fbe, 0x1fbf,\n+      0x1fc8, 0x1fcc,\n+      0x1fd0, 0x1fd2,\n+      0x1fd8, 0x1fdc,\n+      0x1fe0, 0x1fe2,\n+      0x1fe5, 0x1fe6,\n+      0x1fe8, 0x1fed,\n+      0x1ff8, 0x1ffc,\n+      0x2132, 0x2133,\n+      0x214e, 0x214f,\n+      0x2160, 0x2180,\n+      0x2183, 0x2185,\n+      0x24b6, 0x24ea,\n+      0x2c00, 0x2c2f,\n+      0x2c30, 0x2c5f,\n+      0x2c60, 0x2c6d,\n+      0x2c75, 0x2c77,\n+      0x2c80, 0x2ce4,\n+      0x2d00, 0x2d26,\n+      0xff21, 0xff3b,\n+      0xff41, 0xff5b\n+      );\n+\n+\n+  /**\n+   * Returns the case canonical version of the given string.\n+   */\n+  public static String caseCanonicalize(String s) {\n+    for (int i = 0, n = s.length(); i < n; ++i) {\n+      char ch = s.charAt(i);\n+      char cu = caseCanonicalize(ch);\n+      if (cu != ch) {\n+        StringBuilder sb = new StringBuilder(s);\n+        sb.setCharAt(i, cu);\n+        while (++i < n) {\n+          sb.setCharAt(i, caseCanonicalize(s.charAt(i)));\n+        }\n+        return sb.toString();\n+      }\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the case canonical version of the given code-unit.  EcmaScript 5\n+   * explicitly says that code-units are to be treated as their code-point\n+   * equivalent, even surrogates.\n+   */\n+  public static char caseCanonicalize(char ch) {\n+    if (ch < 0x80) {  // Normal case.\n+      return ('A' <= ch && ch <= 'Z') ? (char) (ch | 32) : ch;\n+    }\n+    // Non-ASCII case.\n+    if (CASE_SENSITIVE.contains(ch)) {\n+      for (DeltaSet ds : CANON_DELTA_SETS) {\n+        if (ds.codeUnits.contains(ch)) {\n+          return (char) (ch - ds.delta);\n+        }\n+      }\n+    }\n+    return ch;\n+  }\n+\n+  /**\n+   * Given a character range that may include case sensitive code-units,\n+   * such as {@code [0-9B-M]}, returns the character range that includes all\n+   * the code-units in the input and those that are case-insensitively\n+   * equivalent to a code-unit in the input.\n+   */\n+  public static CharRanges expandToAllMatched(CharRanges ranges) {\n+    CharRanges caseSensitive = ranges.intersection(CASE_SENSITIVE);\n+    if (caseSensitive.isEmpty()) { return ranges; }\n+    CharRanges expanded = CharRanges.EMPTY;\n+    for (DeltaSet ds : DELTA_SETS) {\n+      expanded = expanded.union(\n+          caseSensitive.intersection(ds.codeUnits).shift(-ds.delta));\n+    }\n+    return ranges.union(expanded);\n+  }\n+\n+\n+  private static final CharRanges UCASE_ASCII_LETTERS\n+      = CharRanges.inclusive('A', 'Z');\n+\n+  /**\n+   * Given a character range that may include case sensitive code-units,\n+   * such as {@code [0-9B-M]}, returns the character range that includes\n+   * the minimal set of code units such that for every code unit in the\n+   * input there is a case-sensitively equivalent canonical code unit in the\n+   * output.\n+   */\n+  public static CharRanges reduceToMinimum(CharRanges ranges) {\n+    CharRanges caseSensitive = ranges.intersection(CASE_SENSITIVE);\n+    if (caseSensitive.isEmpty()) { return ranges; }\n+    CharRanges expanded = CharRanges.EMPTY;\n+    for (DeltaSet ds : CANON_DELTA_SETS) {\n+      expanded = expanded.union(\n+          caseSensitive.intersection(ds.codeUnits).shift(-ds.delta));\n+    }\n+    // Letters a-z gzip better than uppercase A-Z since JavaScript keywords\n+    // are lower-case, so, even though the definition of Canonicalize is\n+    // based on String.prototype.toUpperCase, we use lowercase ASCII characters\n+    // in the minimal form.\n+    expanded = expanded.difference(UCASE_ASCII_LETTERS).union(\n+        expanded.intersection(UCASE_ASCII_LETTERS).shift(32));\n+    return ranges.difference(caseSensitive).union(expanded);\n+  }\n+\n+  /**\n+   * Sets of code units broken down by delta that are case-insensitively\n+   * equivalent to another code unit that differs from the first by that delta.\n+   */\n+  private static final ImmutableList<DeltaSet> DELTA_SETS = ImmutableList.of(\n+      new DeltaSet(-10795, CharRanges.withMembers(0x23a)),\n+      new DeltaSet(-10792, CharRanges.withMembers(0x23e)),\n+      new DeltaSet(-10743, CharRanges.withMembers(0x26b)),\n+      new DeltaSet(-10727, CharRanges.withMembers(0x27d)),\n+      new DeltaSet(-7264, CharRanges.withRanges(0x10a0, 0x10c6)),\n+      new DeltaSet(-7205, CharRanges.withMembers(0x399)),\n+      new DeltaSet(-3814, CharRanges.withMembers(0x1d7d)),\n+      new DeltaSet(-743, CharRanges.withMembers(0xb5)),\n+      new DeltaSet(-219, CharRanges.withMembers(0x1b7)),\n+      new DeltaSet(-218, CharRanges.withMembers(0x1a6, 0x1a9, 0x1ae)),\n+      new DeltaSet(-217, CharRanges.withRanges(0x1b1, 0x1b3)),\n+      new DeltaSet(-214, CharRanges.withMembers(0x19f)),\n+      new DeltaSet(-213, CharRanges.withMembers(0x19d)),\n+      new DeltaSet(-211, CharRanges.withMembers(0x196, 0x19c)),\n+      new DeltaSet(-210, CharRanges.withMembers(0x181)),\n+      new DeltaSet(-209, CharRanges.withMembers(0x197)),\n+      new DeltaSet(-207, CharRanges.withMembers(0x194)),\n+      new DeltaSet(-206, CharRanges.withMembers(0x186)),\n+      new DeltaSet(-205, CharRanges.withRanges(0x189, 0x18b, 0x193, 0x194)),\n+      new DeltaSet(-203, CharRanges.withMembers(0x190)),\n+      new DeltaSet(-202, CharRanges.withMembers(0x18f)),\n+      new DeltaSet(-195, CharRanges.withMembers(0x180)),\n+      new DeltaSet(-163, CharRanges.withMembers(0x19a)),\n+      new DeltaSet(-130, CharRanges.withRanges(0x19e, 0x19f, 0x37b, 0x37e)),\n+      new DeltaSet(-128, CharRanges.withRanges(0x1f78, 0x1f7a)),\n+      new DeltaSet(-126, CharRanges.withRanges(0x1f7c, 0x1f7e)),\n+      new DeltaSet(-121, CharRanges.withMembers(0xff)),\n+      new DeltaSet(-112, CharRanges.withRanges(0x1f7a, 0x1f7c)),\n+      new DeltaSet(-100, CharRanges.withRanges(0x1f76, 0x1f78)),\n+      new DeltaSet(-97, CharRanges.withMembers(0x195)),\n+      new DeltaSet(-96, CharRanges.withMembers(0x395)),\n+      new DeltaSet(-86, CharRanges.withRanges(0x39a, 0x39b, 0x1f72, 0x1f76)),\n+      new DeltaSet(-84, CharRanges.withMembers(0x345)),\n+      new DeltaSet(-80, CharRanges.withRanges(0x3a1, 0x3a2, 0x400, 0x410)),\n+      new DeltaSet(-79, CharRanges.withMembers(0x18e)),\n+      new DeltaSet(-74, CharRanges.withRanges(0x1f70, 0x1f72)),\n+      new DeltaSet(-71, CharRanges.withMembers(0x245)),\n+      new DeltaSet(-69, CharRanges.withMembers(0x244)),\n+      new DeltaSet(-64, CharRanges.withMembers(0x38c)),\n+      new DeltaSet(-63, CharRanges.withRanges(0x38e, 0x390)),\n+      new DeltaSet(-62, CharRanges.withMembers(0x392)),\n+      new DeltaSet(-59, CharRanges.withMembers(0x1e60)),\n+      new DeltaSet(-57, CharRanges.withMembers(0x398)),\n+      new DeltaSet(-56, CharRanges.withMembers(0x1bf)),\n+      new DeltaSet(-54, CharRanges.withMembers(0x3a0)),\n+      new DeltaSet(-48, CharRanges.withRanges(0x531, 0x557, 0x2c00, 0x2c2f)),\n+      new DeltaSet(-47, CharRanges.withMembers(0x3a6)),\n+      new DeltaSet(-38, CharRanges.withMembers(0x386)),\n+      new DeltaSet(-37, CharRanges.withRanges(0x388, 0x38b)),\n+      new DeltaSet(-32, CharRanges.withRanges(\n+          0x41, 0x5b, 0xc0, 0xd7, 0xd8, 0xdf, 0x391, 0x3a2, 0x3a3, 0x3ac,\n+          0x410, 0x430, 0xff21, 0xff3b)),\n+      new DeltaSet(-31, CharRanges.withMembers(0x3a3)),\n+      new DeltaSet(-28, CharRanges.withMembers(0x2132)),\n+      new DeltaSet(-26, CharRanges.withRanges(0x24b6, 0x24d0)),\n+      new DeltaSet(-16, CharRanges.withRanges(0x2160, 0x2170)),\n+      new DeltaSet(-15, CharRanges.withMembers(0x4c0)),\n+      new DeltaSet(-8, CharRanges.withRanges(\n+          0x1f00, 0x1f08, 0x1f10, 0x1f16, 0x1f20, 0x1f28, 0x1f30, 0x1f38,\n+          0x1f40, 0x1f46, 0x1f51, 0x1f52, 0x1f53, 0x1f54, 0x1f55, 0x1f56,\n+          0x1f57, 0x1f58, 0x1f60, 0x1f68, 0x1fb0, 0x1fb2, 0x1fd0, 0x1fd2,\n+          0x1fe0, 0x1fe2)),\n+      new DeltaSet(-7, CharRanges.withMembers(0x3f2, 0x1fe5)),\n+      new DeltaSet(-2, CharRanges.withMembers(0x1c4, 0x1c7, 0x1ca, 0x1f1)),\n+      new DeltaSet(-1, CharRanges.withMembers(\n+          0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 0x10e, 0x110, 0x112,\n+          0x114, 0x116, 0x118, 0x11a, 0x11c, 0x11e, 0x120, 0x122, 0x124, 0x126,\n+          0x128, 0x12a, 0x12c, 0x12e, 0x132, 0x134, 0x136, 0x139, 0x13b, 0x13d,\n+          0x13f, 0x141, 0x143, 0x145, 0x147, 0x14a, 0x14c, 0x14e, 0x150, 0x152,\n+          0x154, 0x156, 0x158, 0x15a, 0x15c, 0x15e, 0x160, 0x162, 0x164, 0x166,\n+          0x168, 0x16a, 0x16c, 0x16e, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17b,\n+          0x17d, 0x182, 0x184, 0x187, 0x18b, 0x191, 0x198, 0x1a0, 0x1a2, 0x1a4,\n+          0x1a7, 0x1ac, 0x1af, 0x1b3, 0x1b5, 0x1b8, 0x1bc, 0x1c4, 0x1c7, 0x1ca,\n+          0x1cd, 0x1cf, 0x1d1, 0x1d3, 0x1d5, 0x1d7, 0x1d9, 0x1db, 0x1de, 0x1e0,\n+          0x1e2, 0x1e4, 0x1e6, 0x1e8, 0x1ea, 0x1ec, 0x1ee, 0x1f1, 0x1f4, 0x1f8,\n+          0x1fa, 0x1fc, 0x1fe, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 0x20c,\n+          0x20e, 0x210, 0x212, 0x214, 0x216, 0x218, 0x21a, 0x21c, 0x21e, 0x222,\n+          0x224, 0x226, 0x228, 0x22a, 0x22c, 0x22e, 0x230, 0x232, 0x23b, 0x241,\n+          0x246, 0x248, 0x24a, 0x24c, 0x24e, 0x3d8, 0x3da, 0x3dc, 0x3de, 0x3e0,\n+          0x3e2, 0x3e4, 0x3e6, 0x3e8, 0x3ea, 0x3ec, 0x3ee, 0x3f7, 0x3fa, 0x460,\n+          0x462, 0x464, 0x466, 0x468, 0x46a, 0x46c, 0x46e, 0x470, 0x472, 0x474,\n+          0x476, 0x478, 0x47a, 0x47c, 0x47e, 0x480, 0x48a, 0x48c, 0x48e, 0x490,\n+          0x492, 0x494, 0x496, 0x498, 0x49a, 0x49c, 0x49e, 0x4a0, 0x4a2, 0x4a4,\n+          0x4a6, 0x4a8, 0x4aa, 0x4ac, 0x4ae, 0x4b0, 0x4b2, 0x4b4, 0x4b6, 0x4b8,\n+          0x4ba, 0x4bc, 0x4be, 0x4c1, 0x4c3, 0x4c5, 0x4c7, 0x4c9, 0x4cb, 0x4cd,\n+          0x4d0, 0x4d2, 0x4d4, 0x4d6, 0x4d8, 0x4da, 0x4dc, 0x4de, 0x4e0, 0x4e2,\n+          0x4e4, 0x4e6, 0x4e8, 0x4ea, 0x4ec, 0x4ee, 0x4f0, 0x4f2, 0x4f4, 0x4f6,\n+          0x4f8, 0x4fa, 0x4fc, 0x4fe, 0x500, 0x502, 0x504, 0x506, 0x508, 0x50a,\n+          0x50c, 0x50e, 0x510, 0x512, 0x1e00, 0x1e02, 0x1e04, 0x1e06, 0x1e08,\n+          0x1e0a, 0x1e0c, 0x1e0e, 0x1e10, 0x1e12, 0x1e14, 0x1e16, 0x1e18,\n+          0x1e1a, 0x1e1c, 0x1e1e, 0x1e20, 0x1e22, 0x1e24, 0x1e26, 0x1e28,\n+          0x1e2a, 0x1e2c, 0x1e2e, 0x1e30, 0x1e32, 0x1e34, 0x1e36, 0x1e38,\n+          0x1e3a, 0x1e3c, 0x1e3e, 0x1e40, 0x1e42, 0x1e44, 0x1e46, 0x1e48,\n+          0x1e4a, 0x1e4c, 0x1e4e, 0x1e50, 0x1e52, 0x1e54, 0x1e56, 0x1e58,\n+          0x1e5a, 0x1e5c, 0x1e5e, 0x1e60, 0x1e62, 0x1e64, 0x1e66, 0x1e68,\n+          0x1e6a, 0x1e6c, 0x1e6e, 0x1e70, 0x1e72, 0x1e74, 0x1e76, 0x1e78,\n+          0x1e7a, 0x1e7c, 0x1e7e, 0x1e80, 0x1e82, 0x1e84, 0x1e86, 0x1e88,\n+          0x1e8a, 0x1e8c, 0x1e8e, 0x1e90, 0x1e92, 0x1e94, 0x1ea0, 0x1ea2,\n+          0x1ea4, 0x1ea6, 0x1ea8, 0x1eaa, 0x1eac, 0x1eae, 0x1eb0, 0x1eb2,\n+          0x1eb4, 0x1eb6, 0x1eb8, 0x1eba, 0x1ebc, 0x1ebe, 0x1ec0, 0x1ec2,\n+          0x1ec4, 0x1ec6, 0x1ec8, 0x1eca, 0x1ecc, 0x1ece, 0x1ed0, 0x1ed2,\n+          0x1ed4, 0x1ed6, 0x1ed8, 0x1eda, 0x1edc, 0x1ede, 0x1ee0, 0x1ee2,\n+          0x1ee4, 0x1ee6, 0x1ee8, 0x1eea, 0x1eec, 0x1eee, 0x1ef0, 0x1ef2,\n+          0x1ef4, 0x1ef6, 0x1ef8, 0x2183, 0x2c60, 0x2c67, 0x2c69, 0x2c6b,\n+          0x2c75, 0x2c80, 0x2c82, 0x2c84, 0x2c86, 0x2c88, 0x2c8a, 0x2c8c,\n+          0x2c8e, 0x2c90, 0x2c92, 0x2c94, 0x2c96, 0x2c98, 0x2c9a, 0x2c9c,\n+          0x2c9e, 0x2ca0, 0x2ca2, 0x2ca4, 0x2ca6, 0x2ca8, 0x2caa, 0x2cac,\n+          0x2cae, 0x2cb0, 0x2cb2, 0x2cb4, 0x2cb6, 0x2cb8, 0x2cba, 0x2cbc,\n+          0x2cbe, 0x2cc0, 0x2cc2, 0x2cc4, 0x2cc6, 0x2cc8, 0x2cca, 0x2ccc,\n+          0x2cce, 0x2cd0, 0x2cd2, 0x2cd4, 0x2cd6, 0x2cd8, 0x2cda, 0x2cdc,\n+          0x2cde, 0x2ce0, 0x2ce2)),\n+      new DeltaSet(1, CharRanges.withMembers(\n+          0x101, 0x103, 0x105, 0x107, 0x109, 0x10b, 0x10d, 0x10f, 0x111, 0x113,\n+          0x115, 0x117, 0x119, 0x11b, 0x11d, 0x11f, 0x121, 0x123, 0x125, 0x127,\n+          0x129, 0x12b, 0x12d, 0x12f, 0x133, 0x135, 0x137, 0x13a, 0x13c, 0x13e,\n+          0x140, 0x142, 0x144, 0x146, 0x148, 0x14b, 0x14d, 0x14f, 0x151, 0x153,\n+          0x155, 0x157, 0x159, 0x15b, 0x15d, 0x15f, 0x161, 0x163, 0x165, 0x167,\n+          0x169, 0x16b, 0x16d, 0x16f, 0x171, 0x173, 0x175, 0x177, 0x17a, 0x17c,\n+          0x17e, 0x183, 0x185, 0x188, 0x18c, 0x192, 0x199, 0x1a1, 0x1a3, 0x1a5,\n+          0x1a8, 0x1ad, 0x1b0, 0x1b4, 0x1b6, 0x1b9, 0x1bd, 0x1c5, 0x1c8, 0x1cb,\n+          0x1ce, 0x1d0, 0x1d2, 0x1d4, 0x1d6, 0x1d8, 0x1da, 0x1dc, 0x1df, 0x1e1,\n+          0x1e3, 0x1e5, 0x1e7, 0x1e9, 0x1eb, 0x1ed, 0x1ef, 0x1f2, 0x1f5, 0x1f9,\n+          0x1fb, 0x1fd, 0x1ff, 0x201, 0x203, 0x205, 0x207, 0x209, 0x20b, 0x20d,\n+          0x20f, 0x211, 0x213, 0x215, 0x217, 0x219, 0x21b, 0x21d, 0x21f, 0x223,\n+          0x225, 0x227, 0x229, 0x22b, 0x22d, 0x22f, 0x231, 0x233, 0x23c, 0x242,\n+          0x247, 0x249, 0x24b, 0x24d, 0x24f, 0x3d9, 0x3db, 0x3dd, 0x3df, 0x3e1,\n+          0x3e3, 0x3e5, 0x3e7, 0x3e9, 0x3eb, 0x3ed, 0x3ef, 0x3f8, 0x3fb, 0x461,\n+          0x463, 0x465, 0x467, 0x469, 0x46b, 0x46d, 0x46f, 0x471, 0x473, 0x475,\n+          0x477, 0x479, 0x47b, 0x47d, 0x47f, 0x481, 0x48b, 0x48d, 0x48f, 0x491,\n+          0x493, 0x495, 0x497, 0x499, 0x49b, 0x49d, 0x49f, 0x4a1, 0x4a3, 0x4a5,\n+          0x4a7, 0x4a9, 0x4ab, 0x4ad, 0x4af, 0x4b1, 0x4b3, 0x4b5, 0x4b7, 0x4b9,\n+          0x4bb, 0x4bd, 0x4bf, 0x4c2, 0x4c4, 0x4c6, 0x4c8, 0x4ca, 0x4cc, 0x4ce,\n+          0x4d1, 0x4d3, 0x4d5, 0x4d7, 0x4d9, 0x4db, 0x4dd, 0x4df, 0x4e1, 0x4e3,\n+          0x4e5, 0x4e7, 0x4e9, 0x4eb, 0x4ed, 0x4ef, 0x4f1, 0x4f3, 0x4f5, 0x4f7,\n+          0x4f9, 0x4fb, 0x4fd, 0x4ff, 0x501, 0x503, 0x505, 0x507, 0x509, 0x50b,\n+          0x50d, 0x50f, 0x511, 0x513, 0x1e01, 0x1e03, 0x1e05, 0x1e07, 0x1e09,\n+          0x1e0b, 0x1e0d, 0x1e0f, 0x1e11, 0x1e13, 0x1e15, 0x1e17, 0x1e19,\n+          0x1e1b, 0x1e1d, 0x1e1f, 0x1e21, 0x1e23, 0x1e25, 0x1e27, 0x1e29,\n+          0x1e2b, 0x1e2d, 0x1e2f, 0x1e31, 0x1e33, 0x1e35, 0x1e37, 0x1e39,\n+          0x1e3b, 0x1e3d, 0x1e3f, 0x1e41, 0x1e43, 0x1e45, 0x1e47, 0x1e49,\n+          0x1e4b, 0x1e4d, 0x1e4f, 0x1e51, 0x1e53, 0x1e55, 0x1e57, 0x1e59,\n+          0x1e5b, 0x1e5d, 0x1e5f, 0x1e61, 0x1e63, 0x1e65, 0x1e67, 0x1e69,\n+          0x1e6b, 0x1e6d, 0x1e6f, 0x1e71, 0x1e73, 0x1e75, 0x1e77, 0x1e79,\n+          0x1e7b, 0x1e7d, 0x1e7f, 0x1e81, 0x1e83, 0x1e85, 0x1e87, 0x1e89,\n+          0x1e8b, 0x1e8d, 0x1e8f, 0x1e91, 0x1e93, 0x1e95, 0x1ea1, 0x1ea3,\n+          0x1ea5, 0x1ea7, 0x1ea9, 0x1eab, 0x1ead, 0x1eaf, 0x1eb1, 0x1eb3,\n+          0x1eb5, 0x1eb7, 0x1eb9, 0x1ebb, 0x1ebd, 0x1ebf, 0x1ec1, 0x1ec3,\n+          0x1ec5, 0x1ec7, 0x1ec9, 0x1ecb, 0x1ecd, 0x1ecf, 0x1ed1, 0x1ed3,\n+          0x1ed5, 0x1ed7, 0x1ed9, 0x1edb, 0x1edd, 0x1edf, 0x1ee1, 0x1ee3,\n+          0x1ee5, 0x1ee7, 0x1ee9, 0x1eeb, 0x1eed, 0x1eef, 0x1ef1, 0x1ef3,\n+          0x1ef5, 0x1ef7, 0x1ef9, 0x2184, 0x2c61, 0x2c68, 0x2c6a, 0x2c6c,\n+          0x2c76, 0x2c81, 0x2c83, 0x2c85, 0x2c87, 0x2c89, 0x2c8b, 0x2c8d,\n+          0x2c8f, 0x2c91, 0x2c93, 0x2c95, 0x2c97, 0x2c99, 0x2c9b, 0x2c9d,\n+          0x2c9f, 0x2ca1, 0x2ca3, 0x2ca5, 0x2ca7, 0x2ca9, 0x2cab, 0x2cad,\n+          0x2caf, 0x2cb1, 0x2cb3, 0x2cb5, 0x2cb7, 0x2cb9, 0x2cbb, 0x2cbd,\n+          0x2cbf, 0x2cc1, 0x2cc3, 0x2cc5, 0x2cc7, 0x2cc9, 0x2ccb, 0x2ccd,\n+          0x2ccf, 0x2cd1, 0x2cd3, 0x2cd5, 0x2cd7, 0x2cd9, 0x2cdb, 0x2cdd,\n+          0x2cdf, 0x2ce1, 0x2ce3)),\n+      new DeltaSet(2, CharRanges.withMembers(0x1c6, 0x1c9, 0x1cc, 0x1f3)),\n+      new DeltaSet(7, CharRanges.withMembers(0x3f9, 0x1fec)),\n+      new DeltaSet(8, CharRanges.withRanges(\n+          0x1f08, 0x1f10, 0x1f18, 0x1f1e, 0x1f28, 0x1f30, 0x1f38, 0x1f40,\n+          0x1f48, 0x1f4e, 0x1f59, 0x1f5a, 0x1f5b, 0x1f5c, 0x1f5d, 0x1f5e,\n+          0x1f5f, 0x1f60, 0x1f68, 0x1f70, 0x1fb8, 0x1fba, 0x1fd8, 0x1fda,\n+          0x1fe8, 0x1fea)),\n+      new DeltaSet(15, CharRanges.withMembers(0x4cf)),\n+      new DeltaSet(16, CharRanges.withRanges(0x2170, 0x2180)),\n+      new DeltaSet(26, CharRanges.withRanges(0x24d0, 0x24ea)),\n+      new DeltaSet(28, CharRanges.withMembers(0x214e)),\n+      new DeltaSet(31, CharRanges.withMembers(0x3c2)),\n+      new DeltaSet(32, CharRanges.withRanges(\n+          0x61, 0x7b, 0xe0, 0xf7, 0xf8, 0xff, 0x3b1, 0x3c2, 0x3c3, 0x3cc,\n+          0x430, 0x450, 0xff41, 0xff5b)),\n+      new DeltaSet(37, CharRanges.withRanges(0x3ad, 0x3b0)),\n+      new DeltaSet(38, CharRanges.withMembers(0x3ac)),\n+      new DeltaSet(47, CharRanges.withMembers(0x3d5)),\n+      new DeltaSet(48, CharRanges.withRanges(0x561, 0x587, 0x2c30, 0x2c5f)),\n+      new DeltaSet(54, CharRanges.withMembers(0x3d6)),\n+      new DeltaSet(56, CharRanges.withMembers(0x1f7)),\n+      new DeltaSet(57, CharRanges.withMembers(0x3d1)),\n+      new DeltaSet(59, CharRanges.withMembers(0x1e9b)),\n+      new DeltaSet(62, CharRanges.withMembers(0x3d0)),\n+      new DeltaSet(63, CharRanges.withRanges(0x3cd, 0x3cf)),\n+      new DeltaSet(64, CharRanges.withMembers(0x3cc)),\n+      new DeltaSet(69, CharRanges.withMembers(0x289)),\n+      new DeltaSet(71, CharRanges.withMembers(0x28c)),\n+      new DeltaSet(74, CharRanges.withRanges(0x1fba, 0x1fbc)),\n+      new DeltaSet(79, CharRanges.withMembers(0x1dd)),\n+      new DeltaSet(80, CharRanges.withRanges(0x3f1, 0x3f2, 0x450, 0x460)),\n+      new DeltaSet(84, CharRanges.withMembers(0x399)),\n+      new DeltaSet(86, CharRanges.withRanges(0x3f0, 0x3f1, 0x1fc8, 0x1fcc)),\n+      new DeltaSet(96, CharRanges.withMembers(0x3f5)),\n+      new DeltaSet(97, CharRanges.withMembers(0x1f6)),\n+      new DeltaSet(100, CharRanges.withRanges(0x1fda, 0x1fdc)),\n+      new DeltaSet(112, CharRanges.withRanges(0x1fea, 0x1fec)),\n+      new DeltaSet(121, CharRanges.withMembers(0x178)),\n+      new DeltaSet(126, CharRanges.withRanges(0x1ffa, 0x1ffc)),\n+      new DeltaSet(128, CharRanges.withRanges(0x1ff8, 0x1ffa)),\n+      new DeltaSet(130, CharRanges.withRanges(0x220, 0x221, 0x3fd, 0x400)),\n+      new DeltaSet(163, CharRanges.withMembers(0x23d)),\n+      new DeltaSet(195, CharRanges.withMembers(0x243)),\n+      new DeltaSet(202, CharRanges.withMembers(0x259)),\n+      new DeltaSet(203, CharRanges.withMembers(0x25b)),\n+      new DeltaSet(205, CharRanges.withRanges(0x256, 0x258, 0x260, 0x261)),\n+      new DeltaSet(206, CharRanges.withMembers(0x254)),\n+      new DeltaSet(207, CharRanges.withMembers(0x263)),\n+      new DeltaSet(209, CharRanges.withMembers(0x268)),\n+      new DeltaSet(210, CharRanges.withMembers(0x253)),\n+      new DeltaSet(211, CharRanges.withMembers(0x269, 0x26f)),\n+      new DeltaSet(213, CharRanges.withMembers(0x272)),\n+      new DeltaSet(214, CharRanges.withMembers(0x275)),\n+      new DeltaSet(217, CharRanges.withRanges(0x28a, 0x28c)),\n+      new DeltaSet(218, CharRanges.withMembers(0x280, 0x283, 0x288)),\n+      new DeltaSet(219, CharRanges.withMembers(0x292)),\n+      new DeltaSet(743, CharRanges.withMembers(0x39c)),\n+      new DeltaSet(3814, CharRanges.withMembers(0x2c63)),\n+      new DeltaSet(7205, CharRanges.withMembers(0x1fbe)),\n+      new DeltaSet(7264, CharRanges.withRanges(0x2d00, 0x2d26)),\n+      new DeltaSet(10727, CharRanges.withMembers(0x2c64)),\n+      new DeltaSet(10743, CharRanges.withMembers(0x2c62)),\n+      new DeltaSet(10792, CharRanges.withMembers(0x2c66)),\n+      new DeltaSet(10795, CharRanges.withMembers(0x2c65))\n+      );\n+\n+  private static final ImmutableList<DeltaSet> CANON_DELTA_SETS\n+      = ImmutableList.of(\n+      new DeltaSet(-10743, CharRanges.withMembers(0x26b)),\n+      new DeltaSet(-10727, CharRanges.withMembers(0x27d)),\n+      new DeltaSet(-3814, CharRanges.withMembers(0x1d7d)),\n+      new DeltaSet(-743, CharRanges.withMembers(0xb5)),\n+      new DeltaSet(-195, CharRanges.withMembers(0x180)),\n+      new DeltaSet(-163, CharRanges.withMembers(0x19a)),\n+      new DeltaSet(-130, CharRanges.withRanges(0x19e, 0x19f, 0x37b, 0x37e)),\n+      new DeltaSet(-128, CharRanges.withRanges(0x1f78, 0x1f7a)),\n+      new DeltaSet(-126, CharRanges.withRanges(0x1f7c, 0x1f7e)),\n+      new DeltaSet(-121, CharRanges.withMembers(0xff)),\n+      new DeltaSet(-112, CharRanges.withRanges(0x1f7a, 0x1f7c)),\n+      new DeltaSet(-100, CharRanges.withRanges(0x1f76, 0x1f78)),\n+      new DeltaSet(-97, CharRanges.withMembers(0x195)),\n+      new DeltaSet(-86, CharRanges.withRanges(0x1f72, 0x1f76)),\n+      new DeltaSet(-84, CharRanges.withMembers(0x345)),\n+      new DeltaSet(-74, CharRanges.withRanges(0x1f70, 0x1f72)),\n+      new DeltaSet(-56, CharRanges.withMembers(0x1bf)),\n+      new DeltaSet(-8, CharRanges.withRanges(\n+          0x1f00, 0x1f08, 0x1f10, 0x1f16, 0x1f20, 0x1f28, 0x1f30, 0x1f38,\n+          0x1f40, 0x1f46, 0x1f51, 0x1f52, 0x1f53, 0x1f54, 0x1f55, 0x1f56,\n+          0x1f57, 0x1f58, 0x1f60, 0x1f68, 0x1fb0, 0x1fb2, 0x1fd0, 0x1fd2,\n+          0x1fe0, 0x1fe2)),\n+      new DeltaSet(-7, CharRanges.withMembers(0x3f2, 0x1fe5)),\n+      new DeltaSet(1, CharRanges.withMembers(\n+          0x101, 0x103, 0x105, 0x107, 0x109, 0x10b, 0x10d, 0x10f, 0x111, 0x113,\n+          0x115, 0x117, 0x119, 0x11b, 0x11d, 0x11f, 0x121, 0x123, 0x125, 0x127,\n+          0x129, 0x12b, 0x12d, 0x12f, 0x133, 0x135, 0x137, 0x13a, 0x13c, 0x13e,\n+          0x140, 0x142, 0x144, 0x146, 0x148, 0x14b, 0x14d, 0x14f, 0x151, 0x153,\n+          0x155, 0x157, 0x159, 0x15b, 0x15d, 0x15f, 0x161, 0x163, 0x165, 0x167,\n+          0x169, 0x16b, 0x16d, 0x16f, 0x171, 0x173, 0x175, 0x177, 0x17a, 0x17c,\n+          0x17e, 0x183, 0x185, 0x188, 0x18c, 0x192, 0x199, 0x1a1, 0x1a3, 0x1a5,\n+          0x1a8, 0x1ad, 0x1b0, 0x1b4, 0x1b6, 0x1b9, 0x1bd, 0x1c5, 0x1c8, 0x1cb,\n+          0x1ce, 0x1d0, 0x1d2, 0x1d4, 0x1d6, 0x1d8, 0x1da, 0x1dc, 0x1df, 0x1e1,\n+          0x1e3, 0x1e5, 0x1e7, 0x1e9, 0x1eb, 0x1ed, 0x1ef, 0x1f2, 0x1f5, 0x1f9,\n+          0x1fb, 0x1fd, 0x1ff, 0x201, 0x203, 0x205, 0x207, 0x209, 0x20b, 0x20d,\n+          0x20f, 0x211, 0x213, 0x215, 0x217, 0x219, 0x21b, 0x21d, 0x21f, 0x223,\n+          0x225, 0x227, 0x229, 0x22b, 0x22d, 0x22f, 0x231, 0x233, 0x23c, 0x242,\n+          0x247, 0x249, 0x24b, 0x24d, 0x24f, 0x3d9, 0x3db, 0x3dd, 0x3df, 0x3e1,\n+          0x3e3, 0x3e5, 0x3e7, 0x3e9, 0x3eb, 0x3ed, 0x3ef, 0x3f8, 0x3fb, 0x461,\n+          0x463, 0x465, 0x467, 0x469, 0x46b, 0x46d, 0x46f, 0x471, 0x473, 0x475,\n+          0x477, 0x479, 0x47b, 0x47d, 0x47f, 0x481, 0x48b, 0x48d, 0x48f, 0x491,\n+          0x493, 0x495, 0x497, 0x499, 0x49b, 0x49d, 0x49f, 0x4a1, 0x4a3, 0x4a5,\n+          0x4a7, 0x4a9, 0x4ab, 0x4ad, 0x4af, 0x4b1, 0x4b3, 0x4b5, 0x4b7, 0x4b9,\n+          0x4bb, 0x4bd, 0x4bf, 0x4c2, 0x4c4, 0x4c6, 0x4c8, 0x4ca, 0x4cc, 0x4ce,\n+          0x4d1, 0x4d3, 0x4d5, 0x4d7, 0x4d9, 0x4db, 0x4dd, 0x4df, 0x4e1, 0x4e3,\n+          0x4e5, 0x4e7, 0x4e9, 0x4eb, 0x4ed, 0x4ef, 0x4f1, 0x4f3, 0x4f5, 0x4f7,\n+          0x4f9, 0x4fb, 0x4fd, 0x4ff, 0x501, 0x503, 0x505, 0x507, 0x509, 0x50b,\n+          0x50d, 0x50f, 0x511, 0x513, 0x1e01, 0x1e03, 0x1e05, 0x1e07, 0x1e09,\n+          0x1e0b, 0x1e0d, 0x1e0f, 0x1e11, 0x1e13, 0x1e15, 0x1e17, 0x1e19,\n+          0x1e1b, 0x1e1d, 0x1e1f, 0x1e21, 0x1e23, 0x1e25, 0x1e27, 0x1e29,\n+          0x1e2b, 0x1e2d, 0x1e2f, 0x1e31, 0x1e33, 0x1e35, 0x1e37, 0x1e39,\n+          0x1e3b, 0x1e3d, 0x1e3f, 0x1e41, 0x1e43, 0x1e45, 0x1e47, 0x1e49,\n+          0x1e4b, 0x1e4d, 0x1e4f, 0x1e51, 0x1e53, 0x1e55, 0x1e57, 0x1e59,\n+          0x1e5b, 0x1e5d, 0x1e5f, 0x1e61, 0x1e63, 0x1e65, 0x1e67, 0x1e69,\n+          0x1e6b, 0x1e6d, 0x1e6f, 0x1e71, 0x1e73, 0x1e75, 0x1e77, 0x1e79,\n+          0x1e7b, 0x1e7d, 0x1e7f, 0x1e81, 0x1e83, 0x1e85, 0x1e87, 0x1e89,\n+          0x1e8b, 0x1e8d, 0x1e8f, 0x1e91, 0x1e93, 0x1e95, 0x1ea1, 0x1ea3,\n+          0x1ea5, 0x1ea7, 0x1ea9, 0x1eab, 0x1ead, 0x1eaf, 0x1eb1, 0x1eb3,\n+          0x1eb5, 0x1eb7, 0x1eb9, 0x1ebb, 0x1ebd, 0x1ebf, 0x1ec1, 0x1ec3,\n+          0x1ec5, 0x1ec7, 0x1ec9, 0x1ecb, 0x1ecd, 0x1ecf, 0x1ed1, 0x1ed3,\n+          0x1ed5, 0x1ed7, 0x1ed9, 0x1edb, 0x1edd, 0x1edf, 0x1ee1, 0x1ee3,\n+          0x1ee5, 0x1ee7, 0x1ee9, 0x1eeb, 0x1eed, 0x1eef, 0x1ef1, 0x1ef3,\n+          0x1ef5, 0x1ef7, 0x1ef9, 0x2184, 0x2c61, 0x2c68, 0x2c6a, 0x2c6c,\n+          0x2c76, 0x2c81, 0x2c83, 0x2c85, 0x2c87, 0x2c89, 0x2c8b, 0x2c8d,\n+          0x2c8f, 0x2c91, 0x2c93, 0x2c95, 0x2c97, 0x2c99, 0x2c9b, 0x2c9d,\n+          0x2c9f, 0x2ca1, 0x2ca3, 0x2ca5, 0x2ca7, 0x2ca9, 0x2cab, 0x2cad,\n+          0x2caf, 0x2cb1, 0x2cb3, 0x2cb5, 0x2cb7, 0x2cb9, 0x2cbb, 0x2cbd,\n+          0x2cbf, 0x2cc1, 0x2cc3, 0x2cc5, 0x2cc7, 0x2cc9, 0x2ccb, 0x2ccd,\n+          0x2ccf, 0x2cd1, 0x2cd3, 0x2cd5, 0x2cd7, 0x2cd9, 0x2cdb, 0x2cdd,\n+          0x2cdf, 0x2ce1, 0x2ce3)),\n+      new DeltaSet(2, CharRanges.withMembers(0x1c6, 0x1c9, 0x1cc, 0x1f3)),\n+      new DeltaSet(15, CharRanges.withMembers(0x4cf)),\n+      new DeltaSet(16, CharRanges.withRanges(0x2170, 0x2180)),\n+      new DeltaSet(26, CharRanges.withRanges(0x24d0, 0x24ea)),\n+      new DeltaSet(28, CharRanges.withMembers(0x214e)),\n+      new DeltaSet(31, CharRanges.withMembers(0x3c2)),\n+      new DeltaSet(32, CharRanges.withRanges(\n+          0x61, 0x7b, 0xe0, 0xf7, 0xf8, 0xff, 0x3b1, 0x3c2, 0x3c3, 0x3cc, 0x430,\n+          0x450, 0xff41, 0xff5b)),\n+      new DeltaSet(37, CharRanges.withRanges(0x3ad, 0x3b0)),\n+      new DeltaSet(38, CharRanges.withMembers(0x3ac)),\n+      new DeltaSet(47, CharRanges.withMembers(0x3d5)),\n+      new DeltaSet(48, CharRanges.withRanges(0x561, 0x587, 0x2c30, 0x2c5f)),\n+      new DeltaSet(54, CharRanges.withMembers(0x3d6)),\n+      new DeltaSet(57, CharRanges.withMembers(0x3d1)),\n+      new DeltaSet(59, CharRanges.withMembers(0x1e9b)),\n+      new DeltaSet(62, CharRanges.withMembers(0x3d0)),\n+      new DeltaSet(63, CharRanges.withRanges(0x3cd, 0x3cf)),\n+      new DeltaSet(64, CharRanges.withMembers(0x3cc)),\n+      new DeltaSet(69, CharRanges.withMembers(0x289)),\n+      new DeltaSet(71, CharRanges.withMembers(0x28c)),\n+      new DeltaSet(79, CharRanges.withMembers(0x1dd)),\n+      new DeltaSet(80, CharRanges.withRanges(0x3f1, 0x3f2, 0x450, 0x460)),\n+      new DeltaSet(86, CharRanges.withMembers(0x3f0)),\n+      new DeltaSet(96, CharRanges.withMembers(0x3f5)),\n+      new DeltaSet(202, CharRanges.withMembers(0x259)),\n+      new DeltaSet(203, CharRanges.withMembers(0x25b)),\n+      new DeltaSet(205, CharRanges.withRanges(0x256, 0x258, 0x260, 0x261)),\n+      new DeltaSet(206, CharRanges.withMembers(0x254)),\n+      new DeltaSet(207, CharRanges.withMembers(0x263)),\n+      new DeltaSet(209, CharRanges.withMembers(0x268)),\n+      new DeltaSet(210, CharRanges.withMembers(0x253)),\n+      new DeltaSet(211, CharRanges.withMembers(0x269, 0x26f)),\n+      new DeltaSet(213, CharRanges.withMembers(0x272)),\n+      new DeltaSet(214, CharRanges.withMembers(0x275)),\n+      new DeltaSet(217, CharRanges.withRanges(0x28a, 0x28c)),\n+      new DeltaSet(218, CharRanges.withMembers(0x280, 0x283, 0x288)),\n+      new DeltaSet(219, CharRanges.withMembers(0x292)),\n+      new DeltaSet(7205, CharRanges.withMembers(0x1fbe)),\n+      new DeltaSet(7264, CharRanges.withRanges(0x2d00, 0x2d26)),\n+      new DeltaSet(10792, CharRanges.withMembers(0x2c66)),\n+      new DeltaSet(10795, CharRanges.withMembers(0x2c65))\n+      );\n+\n+\n+  /**\n+   * A group of code units such that for all cu in codeUnits, cu is equivalent,\n+   * case-insensitively, to cu + delta.\n+   */\n+  private static final class DeltaSet {\n+    final int delta;\n+    final CharRanges codeUnits;\n+\n+    DeltaSet(int delta, CharRanges codeUnits) {\n+      this.delta = delta;\n+      this.codeUnits = codeUnits;\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/regex/CharRanges.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.regex;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * An immutable sparse bitset that deals well where the data is chunky:\n+ * where P(bit[x+1] == bit[x]).  E.g. [101,102,103,104,105,1001,1002,1003,1004]\n+ * is chunky.\n+ *\n+ */\n+final class CharRanges {\n+  /**\n+   * A strictly increasing set of bit indices where even members are the\n+   * inclusive starts of ranges, and odd members are the exclusive ends.\n+   * <p>\n+   * E.g., { 1, 5, 6, 10 } represents the set ( 1, 2, 3, 4, 6, 7, 8, 9 ).\n+   */\n+  private final int[] ranges;\n+\n+  public static final CharRanges EMPTY = new CharRanges(new int[0]);\n+\n+  public static final CharRanges ALL_CODE_UNITS\n+      = new CharRanges(new int[] { 0, 0x10000 });\n+\n+  public static CharRanges inclusive(int start, int end) {\n+    if (start > end) {\n+      throw new IndexOutOfBoundsException(start + \" > \" + end);\n+    }\n+    return new CharRanges(new int[] { start, end + 1 });\n+  }\n+\n+  /**\n+   * Returns an instance containing all and only the given members.\n+   */\n+  public static CharRanges withMembers(int... members) {\n+    return new CharRanges(intArrayToRanges(members.clone()));\n+  }\n+\n+  /**\n+   * Returns an instance containing the given ranges.\n+   * @param ranges An even-length ordered sequence of non-overlapping,\n+   *     non-contiguous, [inclusive start, exclusive end) ranges.\n+   */\n+  public static CharRanges withRanges(int... ranges) {\n+    ranges = ranges.clone();\n+    if ((ranges.length & 1) != 0) { throw new IllegalArgumentException(); }\n+    for (int i = 1; i < ranges.length; ++i) {\n+      if (ranges[i] <= ranges[i - 1]) {\n+        throw new IllegalArgumentException(ranges[i] + \" > \" + ranges[i - 1]);\n+      }\n+    }\n+    return new CharRanges(ranges);\n+  }\n+\n+  private CharRanges(int[] ranges) {\n+    this.ranges = ranges;\n+  }\n+\n+  private static int[] intArrayToRanges(int[] members) {\n+    int nMembers = members.length;\n+    if (nMembers == 0) {\n+      return new int[0];\n+    }\n+\n+    Arrays.sort(members);\n+\n+    // Count the number of runs.\n+    int nRuns = 1;\n+    for (int i = 1; i < nMembers; ++i) {\n+      int current = members[i], last = members[i - 1];\n+      if (current == last) { continue; }\n+      if (current != last + 1) { ++nRuns; }\n+    }\n+\n+    int[] ranges = new int[nRuns * 2];\n+    ranges[0] = members[0];\n+    int k = 0;\n+    for (int i = 1; k + 2 < ranges.length; ++i) {\n+      int current = members[i], last = members[i - 1];\n+      if (current == last) { continue; }\n+      if (current != last + 1) {\n+        ranges[++k] = last + 1;  // add 1 to make end exclusive\n+        ranges[++k] = current;\n+      }\n+    }\n+    ranges[++k] = members[nMembers - 1] + 1;  // add 1 to make end exclusive\n+    return ranges;\n+  }\n+\n+  public boolean contains(int bit) {\n+    return (Arrays.binarySearch(ranges, bit) & 1) == 0;\n+    // By the contract of Arrays.binarySearch, its result is either the position\n+    // of bit in ranges or it is the bitwise inverse of the position of the\n+    // least element greater than bit.\n+\n+    // Two cases\n+    // case (idx >= 0)\n+    //     We ended up exactly on a range boundary.\n+    //     Starts are inclusive and ends are both exclusive, so this contains\n+    //     bit iff idx is even.\n+    //\n+    // case (idx < 0)\n+    //     If the least element greater than bit is an odd element,\n+    //     then bit must be greater than a start and less than an end, so\n+    //     contained.\n+    //\n+    //     If bit is greater than all elements, then idx will be past the end of\n+    //     the array, and will be even since ranges.length is even.\n+    //\n+    //     Otherwise bit must be in the space between two runs, so not\n+    //     contained.\n+    //\n+    //     In all cases, oddness is equivalent to containedness.\n+\n+    // Those two cases lead to\n+    //     idx >= 0 ? ((idx & 1) == 0) : ((~idx & 1) == 1)\n+\n+    // But ~n & bit == bit   <=>   n & bit == 0, so\n+    //     idx >= 0 ? ((idx & 1) == 0) : ((~idx & 1) == 1)\n+    // =>  idx >= 0 ? ((idx & 1) == 0) : ((idx & 1) == 0)\n+    // =>  (idx & 1) == 0\n+  }\n+\n+  public int minSetBit() {\n+    return ranges.length >= 0 ? ranges[0] : Integer.MIN_VALUE;\n+  }\n+\n+  public boolean isEmpty() {\n+    return ranges.length == 0;\n+  }\n+\n+  public int getNumRanges() { return ranges.length >> 1; }\n+\n+  public int start(int i) { return ranges[i << 1]; }\n+\n+  public int end(int i) { return ranges[(i << 1) | 1]; }\n+\n+  public CharRanges union(CharRanges other) {\n+    // Index of the input ranges\n+    int[] q = this.ranges, r = other.ranges;\n+    // Lengths of the inputs\n+    int m = q.length, n = r.length;\n+\n+    if (m == 0) { return other; }\n+    if (n == 0) { return this; }\n+\n+    // The output array.  The length is m+n in the worst case when all the\n+    // ranges in a are disjoint from the ranges in b.\n+    int[] out = new int[m + n];\n+\n+    // Indexes into the various arrays\n+    int i = 0, j = 0, k = 0;\n+    // Since there are three arrays, and indices into them the following\n+    // should never occur in this function:\n+    // (1) q[j] or q[k]                         -- q is indexed by i\n+    // (2) r[i] or r[k]                         -- r is indexed by j\n+    // (3) out[i] or out[j]                     -- out is indexed by k\n+    // (4) i < n or j < m                       -- index compared to wrong limit\n+\n+    // This loop exits because we always increment at least one of i,j.\n+    while (i < m && j < n) {\n+      // Range starts and ends.\n+      int a0 = q[i], a1 = q[i + 1],\n+          b0 = r[j], b1 = r[j + 1];\n+      if (a1 < b0) {  // [a0, a1) ends before [b0, b1) starts\n+        out[k++] = a0;\n+        out[k++] = a1;\n+        i += 2;\n+      } else if (b1 < a0) {  // [b0, b1) ends before [a0, a1) starts\n+        out[k++] = b0;\n+        out[k++] = b1;\n+        j += 2;\n+      } else {  // ranges overlap\n+        // We need to compute a new range based on the set of ranges that\n+        // transitively overlap.\n+        //       AAAAAAAAA AAA\n+        //     BBB  BBB* BBB\n+        // In the range above, the start comes from one set, and the end from\n+        // another.  The range with the asterisk next to it is subsumed entirely\n+        // by a range from the other, and so not all ranges on the input\n+        // contribute a value to the output.\n+        // The last BBB run serves only as a bridge -- it overlaps two\n+        // disjoint ranges in the other one so establishes that they\n+        // transitively overlap.\n+        int start = Math.min(a0, b0);\n+        // Guess at the end, and lookahead to come up with a more complete\n+        // estimate.\n+        int end = Math.max(a1, b1);\n+        i += 2;\n+        j += 2;\n+        while (i < m || j < n) {\n+          if (i < m && q[i] <= end) {\n+            end = Math.max(end, q[i + 1]);\n+            i += 2;\n+          } else if (j < n && r[j] <= end) {\n+            end = Math.max(end, r[j + 1]);\n+            j += 2;\n+          } else {\n+            break;\n+          }\n+        }\n+        out[k++] = start;\n+        out[k++] = end;\n+      }\n+    }\n+    // There may be unprocessed ranges at the end of one of the inputs.\n+    if (i < m) {\n+      System.arraycopy(q, i, out, k, m - i);\n+      k += m - i;\n+    } else if (j < n) {\n+      System.arraycopy(r, j, out, k, n - j);\n+      k += n - j;\n+    }\n+    // We guessed at the output length above.  Cut off the tail.\n+    if (k != out.length) {\n+      int[] clipped = new int[k];\n+      System.arraycopy(out, 0, clipped, 0, k);\n+      out = clipped;\n+    }\n+    return new CharRanges(out);\n+  }\n+\n+  public CharRanges intersection(CharRanges other) {\n+    int[] aRanges = ranges, bRanges = other.ranges;\n+    int aLen = aRanges.length, bLen = bRanges.length;\n+    if (aLen == 0) { return this; }\n+    if (bLen == 0) { return other; }\n+    int aIdx = 0, bIdx = 0;\n+    int[] intersection = new int[Math.min(aLen, bLen)];\n+    int intersectionIdx = 0;\n+    int pos = Math.min(aRanges[0], bRanges[0]);\n+    while (aIdx < aLen && bIdx < bLen) {\n+      if (aRanges[aIdx + 1] <= pos) {\n+        aIdx += 2;\n+      } else if (bRanges[bIdx + 1] <= pos) {\n+        bIdx += 2;\n+      } else {\n+        int start = Math.max(aRanges[aIdx], bRanges[bIdx]);\n+        if (pos < start) {  // Advance to start of common block.\n+          pos = start;\n+        } else {\n+          // Now we know that pos is less than the ends of the two ranges and\n+          // greater or equal to the starts of the two ranges.\n+          int end = Math.min(aRanges[aIdx + 1], bRanges[bIdx + 1]);\n+          if (intersectionIdx != 0\n+              && pos == intersection[intersectionIdx - 1]) {\n+            intersection[intersectionIdx - 1] = end;\n+          } else {\n+            if (intersectionIdx == intersection.length) {\n+              int[] newArr = new int[intersectionIdx * 2];\n+              System.arraycopy(intersection, 0, newArr, 0, intersectionIdx);\n+              intersection = newArr;\n+            }\n+            intersection[intersectionIdx++] = pos;\n+            intersection[intersectionIdx++] = end;\n+          }\n+          pos = end;\n+        }\n+      }\n+    }\n+    if (intersectionIdx != intersection.length) {\n+      int[] newArr = new int[intersectionIdx];\n+      System.arraycopy(intersection, 0, newArr, 0, intersectionIdx);\n+      intersection = newArr;\n+    }\n+    return new CharRanges(intersection);\n+  }\n+\n+  public CharRanges difference(CharRanges subtrahendRanges) {\n+    // difference = minuend - subtrahend\n+    int[] minuend = this.ranges;\n+    int[] subtrahend = subtrahendRanges.ranges;\n+\n+    int mn = minuend.length, sn = subtrahend.length;\n+    if (mn == 0 || sn == 0) { return this; }\n+\n+    int[] difference = new int[minuend.length];\n+\n+    // Indices into minuend.ranges, subtrahend.ranges, and difference.\n+    int mIdx = 0, sIdx = 0, dIdx = 0;\n+\n+    int pos = minuend[0];\n+    while (mIdx < mn) {\n+      if (pos >= minuend[mIdx + 1]) {\n+        mIdx += 2;\n+      } else if (pos < minuend[mIdx]) {\n+        // Skip gaps in the minuend.\n+        pos = minuend[mIdx];\n+      } else if (sIdx < sn && pos >= subtrahend[sIdx]) {\n+        // Skip over a removed part.\n+        pos = subtrahend[sIdx + 1];\n+        sIdx += 2;\n+      } else {\n+        // Now we know that pos is between [minuend[i], minuend[i + 1])\n+        // and outside [subtrahend[j], subtrahend[j + 1]).\n+        int end = sIdx < sn\n+            ? Math.min(minuend[mIdx + 1], subtrahend[sIdx]) : minuend[mIdx + 1];\n+        if (dIdx != 0 && difference[dIdx - 1] == pos) {\n+          difference[dIdx - 1] = pos;\n+        } else {\n+          if (dIdx == difference.length) {\n+            int[] newArr = new int[dIdx * 2];\n+            System.arraycopy(difference, 0, newArr, 0, dIdx);\n+            difference = newArr;\n+          }\n+          difference[dIdx++] = pos;\n+          difference[dIdx++] = end;\n+        }\n+        pos = end;\n+      }\n+    }\n+\n+    if (dIdx != difference.length) {\n+      int[] newArr = new int[dIdx];\n+      System.arraycopy(difference, 0, newArr, 0, dIdx);\n+      difference = newArr;\n+    }\n+\n+    return new CharRanges(difference);\n+  }\n+\n+  public boolean containsAll(CharRanges sub) {\n+    int[] superRanges = this.ranges;\n+    int[] subRanges = sub.ranges;\n+\n+    int superIdx = 0, subIdx = 0;\n+    int superLen = superRanges.length, subLen = subRanges.length;\n+    while (subIdx < subLen) {\n+      if (superIdx == superLen) {\n+        return false;\n+      }\n+      if (superRanges[superIdx + 1] <= subRanges[subIdx]) {\n+        // Super range ends before subRange starts.\n+        superIdx += 2;\n+      } else if (superRanges[superIdx] > subRanges[subIdx]) {\n+        // Uncontained portion at start of sub range.\n+        return false;\n+      } else if (superRanges[superIdx + 1] >= subRanges[subIdx + 1]) {\n+        // A sub range is completely contained in the super range.\n+        // We know this because of the above condition and we have already\n+        // ruled out that subRanges[subIdx] < superRanges[superIdx].\n+        subIdx += 2;\n+      } else {\n+        // Uncontained portion at end of sub range.\n+        return false;\n+      }\n+    }\n+    return subIdx == subLen;\n+  }\n+\n+  /**\n+   * Shifts the bits matched by the given delta.\n+   * So if this has the bits (a, b, c, ..., z) set then the result has the bits\n+   * ((a - delta), (b - delta), (c - delta), ...., (z - delta)) set.\n+   *\n+   * @throws IndexOutOfBoundsException if shifting by delta would cause an\n+   *     overflow or underflow in a 32 bit {@code signed int} range boundary.\n+   *     Since the end boundaries of ranges are exclusive, even if there is no\n+   *     range containing {@link Integer#MAX_VALUE}, shifting by a delta of 1\n+   *     can cause an overflow.\n+   */\n+  public CharRanges shift(int delta) {\n+    int n = ranges.length;\n+    if (delta == 0 || n == 0) { return this; }\n+    // Test overflow/underflow\n+    if (delta < 0) {\n+      long lmin = ranges[0] + delta;\n+      if (lmin < Integer.MIN_VALUE) { throw new IndexOutOfBoundsException(); }\n+    } else {\n+      long lmax = ranges[n - 1] + delta;\n+      if (lmax > Integer.MAX_VALUE) { throw new IndexOutOfBoundsException(); }\n+    }\n+    // Create a shifted range.\n+    int[] shiftedRanges = new int[n];\n+    for (int i = n; --i >= 0;) {\n+      shiftedRanges[i] = ranges[i] + delta;\n+    }\n+    return new CharRanges(shiftedRanges);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append('[');\n+    for (int i = 0; i < ranges.length; ++i) {\n+      if ((i & 1) != 0 && ranges[i] == ranges[i - 1] + 1) { continue; }\n+      if (i != 0) { sb.append((i & 1) == 0 ? ' ' : '-'); }\n+      sb.append(\"0x\").append(Integer.toString(ranges[i] - (i & 1), 16));\n+    }\n+    sb.append(']');\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof CharRanges)) { return false; }\n+    return Arrays.equals(this.ranges, ((CharRanges) o).ranges);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int hc = 0;\n+    for (int i = 0, n = Math.min(16, ranges.length); i < n; ++i) {\n+      hc = (hc << 2) + ranges[i];\n+    }\n+    return hc;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/regex/RegExpTree.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.regex;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * An AST for JavaScript regular expressions.\n+ *\n+ */\n+public abstract class RegExpTree {\n+\n+  /**\n+   * Returns a simpler regular expression that is semantically the same assuming\n+   * the given flags.\n+   * @param flags Regular expression flags, e.g. {@code \"igm\"}.\n+   */\n+  public abstract RegExpTree simplify(String flags);\n+\n+  /**\n+   * True if the presence or absence of an {@code \"i\"} flag would change the\n+   * meaning of this regular expression.\n+   */\n+  public abstract boolean isCaseSensitive();\n+\n+  /**\n+   * True if the regular expression contains an anchor : {@code ^} or {@code $}.\n+   */\n+  public abstract boolean containsAnchor();\n+\n+  /**\n+   * True if the regular expression contains capturing groups.\n+   */\n+  public final boolean hasCapturingGroup() {\n+    return numCapturingGroups() != 0;\n+  }\n+\n+  /**\n+   * The number of capturing groups.\n+   */\n+  public abstract int numCapturingGroups();\n+\n+  /**\n+   * The children of this node.\n+   */\n+  public abstract List<? extends RegExpTree> children();\n+\n+  /**\n+   * Appends this regular expression source to the given buffer.\n+   */\n+  protected abstract void appendSourceCode(StringBuilder sb);\n+\n+  protected abstract void appendDebugInfo(StringBuilder sb);\n+\n+  @Override\n+  public final String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append('/');\n+    appendSourceCode(sb);\n+    // Don't emit a regular expression that looks like a line comment start.\n+    if (sb.length() == 1) {\n+      sb.append(\"(?:)\");\n+    }\n+    sb.append('/');\n+    return sb.toString();\n+  }\n+\n+  public final String toDebugString() {\n+    StringBuilder sb = new StringBuilder();\n+    appendDebugString(sb);\n+    return sb.toString();\n+  }\n+\n+  private void appendDebugString(StringBuilder sb) {\n+    sb.append('(').append(getClass().getSimpleName());\n+    int len = sb.length();\n+    sb.append(' ');\n+    appendDebugInfo(sb);\n+    if (sb.length() == len + 1) { sb.setLength(len); }\n+    for (RegExpTree child : children()) {\n+      sb.append(' ');\n+      child.appendDebugString(sb);\n+    }\n+    sb.append(')');\n+  }\n+\n+  @Override\n+  public abstract boolean equals(Object o);\n+\n+  @Override\n+  public abstract int hashCode();\n+\n+\n+  /**\n+   * Parses a regular expression to an AST.\n+   *\n+   * @param pattern The {@code foo} From {@code /foo/i}.\n+   * @param flags The {@code i} From {@code /foo/i}.\n+   */\n+  public static RegExpTree parseRegExp(\n+      final String pattern, final String flags) {\n+\n+    /** A recursive descent parser that closes over pattern and flags above. */\n+    class Parser {\n+      /** The number of characters in pattern consumed. */\n+      int pos;\n+      /** The number of capturing groups seen so far. */\n+      int numCapturingGroups = 0;\n+      /** The length of pattern. */\n+      final int limit = pattern.length();\n+\n+      RegExpTree parseTopLevel() {\n+        this.pos = 0;\n+        RegExpTree out = parse();\n+        if (pos < limit) {  // Unmatched closed paren maybe.\n+          throw new IllegalArgumentException(pattern.substring(pos));\n+        }\n+        return out;\n+      }\n+\n+      RegExpTree parse() {\n+        // Collects [\"foo\", \"bar\", \"baz\"] for /foo|bar|baz/.\n+        ImmutableList.Builder<RegExpTree> alternatives = null;\n+        // The last item parsed within an alternation.\n+        RegExpTree preceder = null;\n+\n+        topLoop:\n+        while (pos < limit) {\n+          char ch = pattern.charAt(pos);\n+          RegExpTree atom;\n+          switch (ch) {\n+            case '[':\n+              atom = parseCharset();\n+              break;\n+            case '(':\n+              atom = parseParenthetical();\n+              break;\n+            case ')':\n+              break topLoop;\n+            case '\\\\':\n+              atom = parseEscape();\n+              break;\n+            case '^':\n+            case '$':\n+              atom = new Anchor(ch);\n+              ++pos;\n+              break;\n+            case '.':\n+              // We represent . as a character set to make it easy to simplify\n+              // things like /.|[\\r\\n]/.\n+              atom = DOT_CHARSET;\n+              ++pos;\n+              break;\n+            case '|':\n+              // An alternative may be empty as in /foo||bar/.\n+              // The '|' is consumed below.\n+              atom = Empty.INSTANCE;\n+              break;\n+            default:\n+              // Find a run of concatenated characters to avoid building a\n+              // tree node per literal character.\n+              int start = pos;\n+              int end = pos + 1;\n+              charsLoop:\n+              while (end < limit) {\n+                switch (pattern.charAt(end)) {\n+                  case '[':\n+                  case '(':\n+                  case ')':\n+                  case '\\\\':\n+                  case '^':\n+                  case '$':\n+                  case '|':\n+                  case '.':\n+                  case '*':\n+                  case '+':\n+                  case '?':\n+                  case '{':\n+                    break charsLoop;\n+                  default:\n+                    // Repetition binds more tightly than concatenation.\n+                    // Only consume up to \"foo\" in /foob*/ so that the suffix\n+                    // operator parser below has the right precedence.\n+                    if (end + 1 >= limit\n+                        || !isRepetitionStart(pattern.charAt(end + 1))) {\n+                      ++end;\n+                    } else {\n+                      break charsLoop;\n+                    }\n+                }\n+              }\n+              atom = new Text(pattern.substring(start, end));\n+              pos = end;\n+              break;\n+          }\n+          if (pos < limit && isRepetitionStart(pattern.charAt(pos))) {\n+            atom = parseRepetition(atom);\n+          }\n+          if (preceder == null) {\n+            preceder = atom;\n+          } else {\n+            preceder = new Concatenation(preceder, atom);\n+          }\n+          // If this is an alternative in a alternation, then add it to the\n+          // list of complete alternatives, and reset the parser state for the\n+          // next alternative.\n+          if (pos < limit && pattern.charAt(pos) == '|') {\n+            if (alternatives == null) {\n+              alternatives = ImmutableList.builder();\n+            }\n+            alternatives.add(preceder);\n+            preceder = null;\n+            ++pos;\n+          }\n+        }\n+        // An alternative may have no parsed content blank as in /foo|/.\n+        if (preceder == null) { preceder = Empty.INSTANCE; }\n+        if (alternatives != null) {\n+          alternatives.add(preceder);\n+          return new Alternation(alternatives.build());\n+        } else {\n+          return preceder;\n+        }\n+      }\n+\n+      /**\n+       * Handles capturing groups {@code (...)},\n+       * non-capturing groups {@code (?:...)}, and lookahead assertions\n+       * {@code (?=...)}.\n+       */\n+      private RegExpTree parseParenthetical() {\n+        Preconditions.checkState(pattern.charAt(pos) == '(');\n+        int start = pos;\n+        ++pos;\n+        boolean capturing = true;\n+        int type = 0;\n+        if (pos < limit && pattern.charAt(pos) == '?') {\n+          if (pos + 1 < limit) {\n+            capturing = false;\n+            char ch = pattern.charAt(pos + 1);\n+            switch (ch) {\n+              case ':':  // A (?:...) style non-capturing group.\n+                pos += 2;\n+                break;\n+              case '!':  // A lookahead assertion\n+              case '=':\n+                pos += 2;\n+                type = ch;\n+                break;\n+              default:\n+                throw new IllegalArgumentException(\n+                    \"Malformed parenthetical: \" + pattern.substring(start));\n+            }\n+          }\n+        }\n+        RegExpTree body = parse();\n+        if (pos < limit && pattern.charAt(pos) == ')') {\n+          ++pos;\n+        } else {\n+          throw new IllegalArgumentException(\n+              \"Unclosed parenthetical group: \" + pattern.substring(start));\n+        }\n+        if (capturing) {\n+          ++numCapturingGroups;\n+          return new CapturingGroup(body);\n+        } else if (type != 0) {\n+          return new LookaheadAssertion(body, type == '=');\n+        } else {\n+          return body;\n+        }\n+      }\n+\n+      /**\n+       * Parses a square bracketed character set.\n+       * Standalone character groups (@code /\\d/} are handled by\n+       * {@link #parseEscape}.\n+       */\n+      private RegExpTree parseCharset() {\n+        Preconditions.checkState(pattern.charAt(pos) == '[');\n+        ++pos;\n+\n+        boolean isCaseInsensitive = flags.indexOf('i') >= 0;\n+        boolean inverse = pos < limit && pattern.charAt(pos) == '^';\n+        if (inverse) { ++pos; }\n+        CharRanges ranges = CharRanges.EMPTY;\n+        CharRanges ieExplicits = CharRanges.EMPTY;\n+        while (pos < limit && pattern.charAt(pos) != ']') {\n+          char ch = pattern.charAt(pos);\n+          char start;\n+          if (ch == '\\\\') {\n+            ++pos;\n+            char possibleGroupName = pattern.charAt(pos);\n+            CharRanges group = NAMED_CHAR_GROUPS.get(possibleGroupName);\n+            if (group != null) {\n+              ++pos;\n+              ranges = ranges.union(group);\n+              continue;\n+            }\n+            start = parseEscapeChar();\n+          } else {\n+            start = ch;\n+            ++pos;\n+          }\n+          char end = start;\n+          if (pos + 1 < limit && pattern.charAt(pos) == '-'\n+              && pattern.charAt(pos + 1) != ']') {\n+            ++pos;\n+            ch = pattern.charAt(pos);\n+            if (ch == '\\\\') {\n+              ++pos;\n+              end = parseEscapeChar();\n+            } else {\n+              end = ch;\n+              ++pos;\n+            }\n+          }\n+          CharRanges range = CharRanges.inclusive(start, end);\n+          ranges = ranges.union(range);\n+          if (IE_SPEC_ERRORS.contains(start) && IE_SPEC_ERRORS.contains(end)) {\n+            ieExplicits = ieExplicits.union(range.intersection(IE_SPEC_ERRORS));\n+          }\n+          if (isCaseInsensitive) {\n+            // If the flags contain the 'i' flag, then it is not correct to\n+            // say that [^a-z] contains the letter 'A', or that [a-z] does not\n+            // contain the letter 'A'.\n+            // We expand out letter groups here so that parse returns something\n+            // that is valid independent of flags.\n+            // Calls to simplify(flags) may later reintroduce flag assumptions.\n+            // but without this step, later steps might conflate\n+            //     /[a-z]/i\n+            // and\n+            //     /[^\\0-`{-\\uffff]/i\n+            // which matches nothing because the information about whether the\n+            // ^ is present has been lost during optimizations and charset\n+            // unioning as in /[...]|[^...]/.\n+            ranges = CaseCanonicalize.expandToAllMatched(ranges);\n+          }\n+        }\n+        ++pos;  // Consume ']'\n+\n+        if (inverse) {\n+          ranges = CharRanges.ALL_CODE_UNITS.difference(ranges);\n+        }\n+\n+        return new Charset(ranges, ieExplicits);\n+      }\n+\n+      /**\n+       * Parses an escape to a codepoint.\n+       * Some of the characters parsed here have special meanings in various\n+       * contexts, so contexts must filter those instead.\n+       * E.g. '\\b' means a different thing inside a charset than without.\n+       */\n+      private char parseEscapeChar() {\n+        char ch = pattern.charAt(pos++);\n+        switch (ch) {\n+          case 'b': return '\\b';\n+          case 'f': return '\\f';\n+          case 'n': return '\\n';\n+          case 'r': return '\\r';\n+          case 't': return '\\t';\n+          case 'u': return parseHex(4);\n+          case 'v': return '\\u000b';\n+          case 'x': return parseHex(2);\n+          default:\n+            if ('0' <= ch && ch <= '7') {\n+              char codeUnit = (char) (ch - '0');\n+              // Allow octal literals in the range \\0-\\377.\n+              // \\41 might be a group, but \\041 is not a group.\n+              // We read, but do not emit octal literals since they\n+              // are deprecated in ES5.\n+              int octLimit = Math.min(\n+                  limit, pos + (ch <= '3' ? 2 : 1) + (ch == '0' ? 1 : 0));\n+              while (pos < octLimit) {\n+                ch = pattern.charAt(pos);\n+                if ('0' <= ch && ch <= '7') {\n+                  codeUnit = (char) ((codeUnit << 3) + (ch - '0'));\n+                  ++pos;\n+                } else {\n+                  break;\n+                }\n+              }\n+              return codeUnit;\n+            }\n+            return ch;\n+        }\n+      }\n+\n+      /**\n+       * Parses an escape that appears outside a charset.\n+       */\n+      private RegExpTree parseEscape() {\n+        Preconditions.checkState(pattern.charAt(pos) == '\\\\');\n+        ++pos;\n+        char ch = pattern.charAt(pos);\n+        if (ch == 'b' || ch == 'B') {\n+          ++pos;\n+          return new WordBoundary(ch);\n+        } else if ('1' <= ch && ch <= '9') {\n+          ++pos;\n+          int possibleGroupIndex = ch - '0';\n+          if (numCapturingGroups >= possibleGroupIndex) {\n+            if (pos < limit) {\n+              char next = pattern.charAt(pos);\n+              if ('0' <= next && next <= '9') {\n+                int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0');\n+                if (numCapturingGroups >= twoDigitGroupIndex) {\n+                  ++pos;\n+                  possibleGroupIndex = twoDigitGroupIndex;\n+                }\n+              }\n+            }\n+            return new BackReference(possibleGroupIndex);\n+          } else {\n+            // \\1 - \\7 are octal escaps if there is no such group.\n+            // \\8 and \\9 are the literal characters '8' and '9' if there\n+            // is no such group.\n+            return new Text(Character.toString(\n+              possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch));\n+          }\n+        } else {\n+          CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch);\n+          if (charGroup != null) {  // Handle \\d, etc.\n+            ++pos;\n+            return new Charset(charGroup, CharRanges.EMPTY);\n+          }\n+          return new Text(\"\" + parseEscapeChar());\n+        }\n+      }\n+\n+      /**\n+       * Parses n hex digits to a code-unit.\n+       */\n+      private char parseHex(int n) {\n+        if (pos + n > limit) {\n+          throw new IllegalArgumentException(\n+              \"Abbreviated hex escape \" + pattern.substring(pos));\n+        }\n+        int result = 0;\n+        while (--n >= 0) {\n+          char ch = pattern.charAt(pos);\n+          int digit;\n+          if ('0' <= ch && ch <= '9') {\n+            digit = ch - '0';\n+          } else if ('a' <= ch && ch <= 'f') {\n+            digit = ch + (10 - 'a');\n+          } else if ('A' <= ch && ch <= 'F') {\n+            digit = ch + (10 - 'A');\n+          } else {\n+            throw new IllegalArgumentException(pattern.substring(pos));\n+          }\n+          ++pos;\n+          result = (result << 4) | digit;\n+        }\n+        return (char) result;\n+      }\n+\n+      private boolean isRepetitionStart(char ch) {\n+        switch (ch) {\n+          case '?':\n+          case '*':\n+          case '+':\n+          case '{':\n+            return true;\n+          default:\n+            return false;\n+        }\n+      }\n+\n+      /**\n+       * Parse a repetition.  {@code x?} is treated as a repetition --\n+       * an optional production can be matched 0 or 1 time.\n+       */\n+      private RegExpTree parseRepetition(RegExpTree body) {\n+        if (pos == limit) { return body; }\n+        int min, max;\n+        switch (pattern.charAt(pos)) {\n+          case '+':\n+            ++pos;\n+            min = 1;\n+            max = Integer.MAX_VALUE;\n+            break;\n+          case '*':\n+            ++pos;\n+            min = 0;\n+            max = Integer.MAX_VALUE;\n+            break;\n+          case '?':\n+            ++pos;\n+            min = 0;\n+            max = 1;\n+            break;\n+          case '{':\n+            ++pos;\n+            int start = pos;\n+            int end = pattern.indexOf('}', start);\n+            if (end < 0) {\n+              pos = start - 1;\n+              return body;\n+            }\n+            String counts = pattern.substring(start, end);\n+            pos = end + 1;\n+            int comma = counts.indexOf(',');\n+            try {\n+              min = Integer.parseInt(\n+                  comma >= 0 ? counts.substring(0, comma) : counts);\n+              max = comma >= 0\n+                  ? comma + 1 != counts.length()\n+                      ? Integer.parseInt(counts.substring(comma + 1))\n+                      : Integer.MAX_VALUE\n+                  : min;\n+            } catch (NumberFormatException ex) {\n+              min = max = -1;\n+            }\n+            if (min < 0 || min > max) {\n+              // Treat the open curly bracket literally.\n+              pos = start - 1;\n+              return body;\n+            }\n+            break;\n+          default:\n+            return body;\n+        }\n+        boolean greedy = true;\n+        if (pos < limit && pattern.charAt(pos) == '?') {\n+          greedy = false;\n+          ++pos;\n+        }\n+        return new Repetition(body, min, max, greedy);\n+      }\n+    }\n+\n+    return new Parser().parseTopLevel();\n+  }\n+\n+\n+  /**\n+   * True if, but not necessarily always when the, given regular expression\n+   * must match the whole input or none of it.\n+   */\n+  public static boolean matchesWholeInput(RegExpTree t, String flags) {\n+    if (flags.indexOf('m') >= 0) { return false; }\n+\n+    if (!(t instanceof Concatenation)) {\n+      return false;\n+    }\n+\n+    Concatenation c = (Concatenation) t;\n+    if (c.elements.isEmpty()) { return false; }\n+    RegExpTree first = c.elements.get(0),\n+        last = c.elements.get(c.elements.size() - 1);\n+    if (!(first instanceof Anchor && last instanceof Anchor)) { return false; }\n+    return ((Anchor) first).type == '^' && ((Anchor) last).type == '$';\n+  }\n+\n+\n+  static abstract class RegExpTreeAtom extends RegExpTree {\n+    @Override\n+    public boolean isCaseSensitive() {\n+      return false;\n+    }\n+\n+    @Override\n+    public boolean containsAnchor() {\n+      return false;\n+    }\n+\n+    @Override\n+    public final int numCapturingGroups() {\n+      return 0;\n+    }\n+\n+    @Override\n+    public final List<? extends RegExpTree> children() {\n+      return ImmutableList.of();\n+    }\n+  }\n+\n+  static final class Empty extends RegExpTreeAtom {\n+    static final Empty INSTANCE = new Empty();\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      return this;\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      // No output\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      // No output\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o instanceof Empty;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 0x7ee06141;\n+    }\n+  }\n+\n+  static final class Anchor extends RegExpTreeAtom {\n+    final char type;\n+    Anchor(char type) { this.type = type; }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      return this;\n+    }\n+\n+    @Override\n+    public boolean containsAnchor() {\n+      return true;\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      sb.append(type);\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      sb.append(type);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o instanceof Anchor && type == ((Anchor) o).type;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return type ^ 0xe85317ff;\n+    }\n+  }\n+\n+  static final class WordBoundary extends RegExpTreeAtom {\n+    final char type;\n+\n+    WordBoundary(char type) {\n+      this.type = type;\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      return this;\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      sb.append('\\\\').append(type);\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      sb.append(type);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o instanceof WordBoundary && type == ((WordBoundary) o).type;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 0x5673aa29 ^ type;\n+    }\n+  }\n+\n+  static final class BackReference extends RegExpTreeAtom {\n+    final int groupIndex;\n+\n+    BackReference(int groupIndex) {\n+      Preconditions.checkArgument(groupIndex >= 0 && groupIndex <= 99);\n+      this.groupIndex = groupIndex;\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      return this;\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      sb.append('\\\\').append(groupIndex);\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      sb.append(groupIndex);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o instanceof BackReference\n+          && groupIndex == ((BackReference) o).groupIndex;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 0xff072663 ^ groupIndex;\n+    }\n+  }\n+\n+  static final class Text extends RegExpTreeAtom {\n+    final String text;\n+\n+    Text(String text) {\n+      this.text = text;\n+    }\n+\n+    static void escapeRegularCharOnto(char ch, StringBuilder sb) {\n+      switch (ch) {\n+        case '$':\n+        case '^':\n+        case '*':\n+        case '(':\n+        case ')':\n+        case '+':\n+        case '{':\n+        case '[':\n+        case '|':\n+        case '.':\n+        case '/':\n+        case '?':\n+          sb.append('\\\\').append(ch);\n+          break;\n+        default:\n+          escapeCharOnto(ch, sb);\n+      }\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      int n = text.length();\n+      if (n == 0) {\n+        return Empty.INSTANCE;\n+      }\n+      if (flags.indexOf('i') >= 0) {\n+        String canonicalized = CaseCanonicalize.caseCanonicalize(text);\n+        if (text != canonicalized) {\n+          return new Text(canonicalized);\n+        }\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public boolean isCaseSensitive() {\n+      for (int i = 0, n = text.length(); i < n; ++i) {\n+        if (CaseCanonicalize.CASE_SENSITIVE.contains(text.charAt(i))) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      for (int i = 0, n = text.length(); i < n; ++i) {\n+        escapeRegularCharOnto(text.charAt(i), sb);\n+      }\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      sb.append('`').append(text).append('`');\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o instanceof Text && text.equals(((Text) o).text);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return text.hashCode() ^ 0x617e310;\n+    }\n+  }\n+\n+  static final class Repetition extends RegExpTree {\n+    final RegExpTree body;\n+    final int min, max;\n+    final boolean greedy;\n+\n+    Repetition(RegExpTree body, int min, int max, boolean greedy) {\n+      this.body = body;\n+      this.min = min;\n+      this.max = max;\n+      this.greedy = greedy;\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      RegExpTree body = this.body.simplify(flags);\n+      if (max == 0 && !body.hasCapturingGroup()) { return Empty.INSTANCE; }\n+      if (body instanceof Empty || NEVER_MATCHES.equals(body)) { return body; }\n+      int min = this.min;\n+      int max = this.max;\n+      if (body instanceof Repetition) {\n+        Repetition rbody = (Repetition) body;\n+        if (rbody.greedy == greedy) {\n+          long lmin = ((long) min) * rbody.min;\n+          long lmax = ((long) max) * rbody.max;\n+          if (lmin < Integer.MAX_VALUE) {\n+            body = rbody.body;\n+            min = (int) lmin;\n+            max = lmax >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) lmax;\n+          }\n+        }\n+      }\n+      if (min == 1 && max == 1) { return body; }\n+      boolean greedy = this.greedy || min == max;\n+      return body.equals(this.body) && min == this.min && max == this.max\n+          && greedy == this.greedy\n+          ? this\n+          : new Repetition(body, min, max, greedy).simplify(flags);\n+    }\n+\n+    @Override\n+    public boolean isCaseSensitive() {\n+      return body.isCaseSensitive();\n+    }\n+\n+    @Override\n+    public boolean containsAnchor() {\n+      return body.containsAnchor();\n+    }\n+\n+    @Override\n+    public int numCapturingGroups() {\n+      return body.numCapturingGroups();\n+    }\n+\n+    @Override\n+    public List<? extends RegExpTree> children() {\n+      return ImmutableList.of(body);\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      if (body instanceof Alternation || body instanceof Concatenation\n+          || body instanceof Repetition\n+          || (body instanceof Text && ((Text) body).text.length() > 1)) {\n+        sb.append(\"(?:\");\n+        body.appendSourceCode(sb);\n+        sb.append(')');\n+      } else {\n+        body.appendSourceCode(sb);\n+      }\n+      if (max == Integer.MAX_VALUE) {\n+        switch (min) {\n+          case 0: sb.append('*'); break;\n+          case 1: sb.append('+'); break;\n+          default:\n+            sb.append('{').append(min).append(\",}\");\n+        }\n+      } else if (min == 0 && max == 1) {\n+        sb.append('?');\n+      } else if (min == max) {\n+        sb.append('{').append(min).append('}');\n+      } else {\n+        sb.append('{').append(min).append(',').append(max).append('}');\n+      }\n+      if (!greedy) {\n+        sb.append('?');\n+      }\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      sb.append(\" min=\").append(min).append(\", max=\").append(max);\n+      if (!greedy) { sb.append(\"  not_greedy\"); }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (!(o instanceof Repetition)) { return false; }\n+      Repetition that = (Repetition) o;\n+      return this.body.equals(that.body)\n+          && this.min == that.min\n+          && this.max == that.max\n+          && this.greedy == that.greedy;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return min + 31 * (max + 31 * ((greedy ? 1 : 0) + 31 * body.hashCode()));\n+    }\n+  }\n+\n+  static final class Alternation extends RegExpTree {\n+    final ImmutableList<RegExpTree> alternatives;\n+\n+    Alternation(List<? extends RegExpTree> alternatives) {\n+      this.alternatives = ImmutableList.copyOf(alternatives);\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      List<RegExpTree> alternatives = Lists.newArrayList();\n+      for (RegExpTree alternative : this.alternatives) {\n+        alternative = alternative.simplify(flags);\n+        if (alternative instanceof Alternation) {\n+          alternatives.addAll(((Alternation) alternative).alternatives);\n+        } else {\n+          alternatives.add(alternative);\n+        }\n+      }\n+      // Remove duplicates\n+      RegExpTree last = null;\n+      for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext();) {\n+        RegExpTree alternative = it.next();\n+        if (alternative.equals(NEVER_MATCHES)) { continue; }\n+        if (alternative.equals(last) && !alternative.hasCapturingGroup()) {\n+          it.remove();\n+        } else {\n+          last = alternative;\n+        }\n+      }\n+      // Collapse character alternatives into character sets.\n+      for (int i = 0, n = alternatives.size(); i < n; ++i) {\n+        RegExpTree alternative = alternatives.get(i);\n+        if ((alternative instanceof Text\n+             && ((Text) alternative).text.length() == 1)\n+            || alternative instanceof Charset) {\n+          int end = i;\n+          int nCharsets = 0;\n+          while (end < n) {\n+            RegExpTree follower = alternatives.get(end);\n+            if (follower instanceof Charset) {\n+              ++nCharsets;\n+            } else if (!(follower instanceof Text\n+                         && ((Text) follower).text.length() == 1)) {\n+              break;\n+            }\n+            ++end;\n+          }\n+          if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) {\n+            int[] members = new int[end - i - nCharsets];\n+            int memberIdx = 0;\n+            CharRanges chars = CharRanges.EMPTY;\n+            CharRanges ieExplicits = CharRanges.EMPTY;\n+            List<RegExpTree> charAlternatives = alternatives.subList(i, end);\n+            for (RegExpTree charAlternative : charAlternatives) {\n+              if (charAlternative instanceof Text) {\n+                char ch = ((Text) charAlternative).text.charAt(0);\n+                members[memberIdx++] = ch;\n+                if (IE_SPEC_ERRORS.contains(ch)) {\n+                  ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch));\n+                }\n+              } else if (charAlternative instanceof Charset) {\n+                Charset cs = (Charset) charAlternative;\n+                chars = chars.union(cs.ranges);\n+                ieExplicits = ieExplicits.union(cs.ieExplicits);\n+              }\n+            }\n+            chars = chars.union(CharRanges.withMembers(members));\n+            charAlternatives.clear();\n+            charAlternatives.add(\n+                new Charset(chars, ieExplicits).simplify(flags));\n+            n = alternatives.size();\n+          }\n+        }\n+      }\n+      switch (alternatives.size()) {\n+        case 0: return Empty.INSTANCE;\n+        case 1: return alternatives.get(0);\n+        case 2:\n+          if (alternatives.get(1) instanceof Empty) {  // (?:a|) -> a?\n+            return new Repetition(alternatives.get(0), 0, 1, true);\n+          } else if (alternatives.get(0) instanceof Empty) {\n+            return new Repetition(alternatives.get(1), 0, 1, false);\n+          }\n+          break;\n+      }\n+      // TODO: maybe pull out common prefix or suffix\n+      return alternatives.equals(this.alternatives)\n+          ? this : new Alternation(alternatives);\n+    }\n+\n+    @Override\n+    public boolean isCaseSensitive() {\n+      for (RegExpTree alternative : alternatives) {\n+        if (alternative.isCaseSensitive()) { return true; }\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public boolean containsAnchor() {\n+      for (RegExpTree alternative : alternatives) {\n+        if (alternative.containsAnchor()) { return true; }\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int numCapturingGroups() {\n+      int n = 0;\n+      for (RegExpTree alternative : alternatives) {\n+        n += alternative.numCapturingGroups();\n+      }\n+      return n;\n+    }\n+\n+    @Override\n+    public List<? extends RegExpTree> children() {\n+      return alternatives;\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      for (int i = 0, n = alternatives.size(); i < n; ++i) {\n+        if (i != 0) {\n+          sb.append('|');\n+        }\n+        alternatives.get(i).appendSourceCode(sb);\n+      }\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      // Nothing besides children.\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return this == o || (\n+          (o instanceof Alternation)\n+          && alternatives.equals(((Alternation) o).alternatives));\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 0x51b57cd1 ^ alternatives.hashCode();\n+    }\n+  }\n+\n+  private static final RegExpTree NEVER_MATCHES = new LookaheadAssertion(\n+      Empty.INSTANCE, false);\n+\n+  static final class LookaheadAssertion extends RegExpTree {\n+    final RegExpTree body;\n+    final boolean positive;\n+\n+    LookaheadAssertion(RegExpTree body, boolean positive) {\n+      this.body = body;\n+      this.positive = positive;\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      RegExpTree simpleBody = body.simplify(flags);\n+      if (simpleBody instanceof Empty) {\n+        if (positive) {  // Always true\n+          return simpleBody;\n+        }\n+      }\n+      return new LookaheadAssertion(simpleBody, positive);\n+    }\n+\n+    @Override\n+    public boolean isCaseSensitive() {\n+      return body.isCaseSensitive();\n+    }\n+\n+    @Override\n+    public boolean containsAnchor() {\n+      return body.containsAnchor();\n+    }\n+\n+    @Override\n+    public int numCapturingGroups() {\n+      return body.numCapturingGroups();\n+    }\n+\n+    @Override\n+    public List<? extends RegExpTree> children() {\n+      return ImmutableList.of(body);\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      sb.append(positive ? \"(?=\" : \"(?!\");\n+      body.appendSourceCode(sb);\n+      sb.append(')');\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      sb.append(positive ? \"positive\" : \"negative\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (!(o instanceof LookaheadAssertion)) { return false; }\n+      LookaheadAssertion that = (LookaheadAssertion) o;\n+      return this.positive == that.positive && this.body.equals(that.body);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 0x723aba9 ^ body.hashCode();\n+    }\n+  }\n+\n+  static final class CapturingGroup extends RegExpTree {\n+    final RegExpTree body;\n+\n+    CapturingGroup(RegExpTree body) {\n+      this.body = body;\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      return new CapturingGroup(body.simplify(flags));\n+    }\n+\n+    @Override\n+    public boolean isCaseSensitive() {\n+      return body.isCaseSensitive();\n+    }\n+\n+    @Override\n+    public boolean containsAnchor() {\n+      return body.containsAnchor();\n+    }\n+\n+    @Override\n+    public int numCapturingGroups() {\n+      return 1;\n+    }\n+\n+    @Override\n+    public List<? extends RegExpTree> children() {\n+      return ImmutableList.of(body);\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      sb.append('(');\n+      body.appendSourceCode(sb);\n+      sb.append(')');\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      // Nothing besides children.\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o instanceof CapturingGroup\n+          && body.equals(((CapturingGroup) o).body);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 0x55781738 ^ body.hashCode();\n+    }\n+  }\n+\n+  private static final CharRanges DIGITS = CharRanges.inclusive('0', '9');\n+\n+  private static final CharRanges UCASE_LETTERS\n+      = CharRanges.inclusive('A', 'Z');\n+\n+  private static final CharRanges LCASE_LETTERS\n+      = CharRanges.inclusive('a', 'z');\n+\n+  private static final CharRanges LETTERS = UCASE_LETTERS.union(LCASE_LETTERS);\n+\n+  private static final CharRanges WORD_CHARS = DIGITS\n+      .union(LETTERS).union(CharRanges.withMembers('_'));\n+\n+  private static final CharRanges INVERSE_WORD_CHARS\n+      = CharRanges.ALL_CODE_UNITS.difference(WORD_CHARS);\n+\n+  private static final CharRanges SPACE_CHARS = CharRanges.withMembers(\n+      '\\t', '\\n', '\\u000b', '\\u000c', '\\r', ' ', '\\u00a0',\n+      // Unicode 3.0 Zs\n+      '\\u1680', '\\u180e', '\\u2000', '\\u2001',\n+      '\\u2002', '\\u2003', '\\u2004', '\\u2005',\n+      '\\u2006', '\\u2007', '\\u2008', '\\u2009',\n+      '\\u200a',\n+      // Line terminator chars\n+      '\\u2028', '\\u2029',\n+      // Unicode 3.0 Zs\n+      '\\u202f', '\\u205f', '\\u3000',\n+      // Byte order marker is a space character in ES5 but not ES3.\n+      '\\ufeff'\n+      );\n+\n+  /** IE is broken around \\s.  IE (6, 7, 8 at least), only recognize these. */\n+  private static final CharRanges IE_SPACE_CHARS = CharRanges.withMembers(\n+    '\\t', '\\n', '\\u000b', '\\u000c', '\\r', ' '\n+    );\n+\n+  /** IE is broken around \\s.  IE (6, 7, 8 at least), only recognize these. */\n+  private static final CharRanges IE_SPEC_ERRORS = SPACE_CHARS.difference(\n+      IE_SPACE_CHARS);\n+\n+  private static final ImmutableMap<Character, CharRanges> NAMED_CHAR_GROUPS\n+       = ImmutableMap.<Character, CharRanges>builder()\n+          .put('d', DIGITS)\n+          .put('D', CharRanges.ALL_CODE_UNITS.difference(DIGITS))\n+          .put('s', SPACE_CHARS)\n+          .put('S', CharRanges.ALL_CODE_UNITS.difference(SPACE_CHARS))\n+          .put('w', WORD_CHARS)\n+          .put('W', INVERSE_WORD_CHARS)\n+          .build();\n+\n+  private static final Charset DOT_CHARSET = new Charset(\n+      CharRanges.ALL_CODE_UNITS.difference(\n+          CharRanges.withMembers('\\n', '\\r', '\\u2028', '\\u2029')),\n+      CharRanges.EMPTY);\n+\n+  static final class Charset extends RegExpTreeAtom {\n+    final CharRanges ranges;\n+    /**\n+     * Code units that were mentioned explicitly and that might be matched by\n+     * a group according to EcmaScript 5 but would not because of specification\n+     * violations in IE.\n+     */\n+    final CharRanges ieExplicits;\n+\n+    Charset(CharRanges ranges, CharRanges ieExplicits) {\n+      this.ranges = ranges;\n+      this.ieExplicits = ieExplicits;\n+    }\n+\n+    private static int complexityWordFolded(CharRanges ranges) {\n+      return Math.min(\n+          complexityWordFoldedHelper(ranges),\n+          1 + complexityWordFoldedHelper(\n+              CharRanges.ALL_CODE_UNITS.difference(ranges)));\n+    }\n+\n+    private static int complexityWordFoldedHelper(CharRanges ranges) {\n+      int complexity = DecomposedCharset.complexity(ranges);\n+      if (ranges.containsAll(WORD_CHARS)) {\n+        complexity = Math.min(\n+            complexity,\n+            1 + DecomposedCharset.complexity(ranges.difference(WORD_CHARS)));\n+      }\n+      if (ranges.containsAll(INVERSE_WORD_CHARS)) {\n+        complexity = Math.min(\n+            complexity,\n+            1 + DecomposedCharset.complexity(\n+                ranges.difference(INVERSE_WORD_CHARS)));\n+      }\n+      return complexity;\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(String flags) {\n+      if (ranges.isEmpty()) {\n+        return NEVER_MATCHES;\n+      }\n+      CharRanges best = ranges;\n+      if (flags.indexOf('i') >= 0) {\n+        Set<CharRanges> options = Sets.newLinkedHashSet();\n+        options.add(CaseCanonicalize.expandToAllMatched(ranges));\n+        options.add(CaseCanonicalize.reduceToMinimum(ranges));\n+\n+        CharRanges lcaseLetters = ranges.intersection(LCASE_LETTERS);\n+        CharRanges ucaseLetters = ranges.intersection(UCASE_LETTERS);\n+\n+        CharRanges lcaseLettersToUpper = lcaseLetters.shift(-32);\n+        CharRanges ucaseLettersToLower = ucaseLetters.shift(32);\n+\n+        options.add(ranges.union(ucaseLettersToLower));\n+        options.add(ranges.union(lcaseLettersToUpper));\n+        options.add(ranges.union(lcaseLettersToUpper)\n+                    .union(ucaseLettersToLower));\n+\n+        options.add(ranges.union(ucaseLettersToLower).difference(ucaseLetters));\n+        options.add(ranges.union(lcaseLettersToUpper).difference(lcaseLetters));\n+\n+        int bestComplexity = complexityWordFolded(ranges);\n+\n+        for (CharRanges option : options) {\n+          int complexity = complexityWordFolded(option);\n+          if (complexity < bestComplexity) {\n+            bestComplexity = complexity;\n+            best = option;\n+          }\n+        }\n+      }\n+\n+      if (best.getNumRanges() == 1\n+          && best.end(0) - best.start(0) == 1) {\n+        return new Text(Character.toString((char) best.start(0)));\n+      }\n+\n+      if (!best.equals(ranges)) {\n+        return new Charset(best, ieExplicits);\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public boolean isCaseSensitive() {\n+      // We could test\n+      //     !ranges.equals(CaseCanonicalize.expandToAllMatched(ranges))\n+      // but we get better optimizations by leaving the 'i' flag on in most\n+      // cases.\n+\n+      // Check whether skipping all the character groups that are known\n+      // case-insensitive leaves us with something that matches the above\n+      // definition.\n+      CharRanges withoutNamedGroups = decompose().ranges;\n+      return !withoutNamedGroups.equals(\n+            CaseCanonicalize.expandToAllMatched(withoutNamedGroups));\n+    }\n+\n+    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n+      StringBuilder namedGroups = new StringBuilder();\n+      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n+      while (true) {\n+        char groupName = 0;\n+        CharRanges simplest = null;\n+        int minComplexity = DecomposedCharset.complexity(ranges);\n+        for (Map.Entry<Character, CharRanges> namedGroup\n+             : NAMED_CHAR_GROUPS.entrySet()) {\n+          CharRanges group = namedGroup.getValue();\n+          if (ranges.containsAll(group)) {\n+            CharRanges withoutGroup = ranges.difference(group).union(\n+                rangesInterIeExplicits);\n+            int complexity = DecomposedCharset.complexity(withoutGroup);\n+            if (complexity < minComplexity) {\n+              simplest = withoutGroup;\n+              groupName = namedGroup.getKey().charValue();\n+              minComplexity = complexity;\n+            }\n+          }\n+        }\n+        if (simplest != null) {\n+          namedGroups.append('\\\\').append(groupName);\n+          ranges = simplest;\n+        } else {\n+          break;\n+        }\n+      }\n+      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      if (DOT_CHARSET.ranges.equals(ranges)) {\n+        sb.append('.');\n+        return;\n+      }\n+      decompose().appendSourceCode(sb);\n+    }\n+\n+    DecomposedCharset decompose() {\n+      CharRanges negRanges = CharRanges.ALL_CODE_UNITS.difference(ranges);\n+      if (!ieExplicits.isEmpty()) {\n+        if (negRanges.intersection(ieExplicits).isEmpty()) {\n+          return decompose(ranges, false);\n+        } else if (ranges.intersection(ieExplicits).isEmpty()) {\n+          return decompose(negRanges, true);\n+        }\n+      }\n+      DecomposedCharset positive = decompose(ranges, false);\n+      DecomposedCharset negative = decompose(negRanges, true);\n+      return positive.complexity() <= negative.complexity()\n+          ? positive : negative;\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      sb.append(ranges);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o instanceof Charset && ranges.equals(((Charset) o).ranges);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return ranges.hashCode() ^ 0xdede2246;\n+    }\n+  }\n+\n+  static final class DecomposedCharset {\n+    boolean inverted;\n+    final CharRanges ranges;\n+    final String namedGroups;\n+\n+    DecomposedCharset(\n+        boolean inverted, CharRanges ranges, String namedGroups) {\n+      this.inverted = inverted;\n+      this.ranges = ranges;\n+      this.namedGroups = namedGroups;\n+    }\n+\n+    int complexity() {\n+      return (inverted ? 1 : 0) + namedGroups.length() + complexity(ranges);\n+    }\n+\n+    void appendSourceCode(StringBuilder sb) {\n+      if (ranges.isEmpty()) {\n+        if (!inverted && namedGroups.length() == 2) {\n+          sb.append(namedGroups);\n+          return;\n+        } else if (ranges.isEmpty() && namedGroups.length() == 0) {\n+          sb.append(inverted ? \"[\\\\S\\\\s]\" : \"(?!)\");\n+          return;\n+        }\n+      }\n+      sb.append('[');\n+      if (inverted) { sb.append('^'); }\n+      sb.append(namedGroups);\n+      boolean rangesStartCharset = !inverted && namedGroups.length() == 0;\n+      boolean emitDashAtEnd = false;\n+      for (int i = 0, n = ranges.getNumRanges(); i < n; ++i) {\n+        char start = (char) ranges.start(i);\n+        char end = (char) (ranges.end(i) - 1);\n+        switch (end - start) {\n+          case 0:\n+            if (start == '-') {\n+              // Put it at the end where it doesn't need escaping.\n+              emitDashAtEnd = true;\n+            } else {\n+              escapeRangeCharOnto(\n+                  start, rangesStartCharset, i == 0, i + 1 == n, sb);\n+            }\n+            break;\n+          case 1:\n+            escapeRangeCharOnto(start, rangesStartCharset, i == 0, false, sb);\n+            escapeRangeCharOnto(\n+                end, rangesStartCharset, false, i + 1 == n, sb);\n+            break;\n+          default:\n+            escapeRangeCharOnto(start, rangesStartCharset, i == 0, false, sb);\n+            sb.append('-');\n+            escapeRangeCharOnto(end, rangesStartCharset, false, true, sb);\n+            break;\n+        }\n+      }\n+      if (emitDashAtEnd) { sb.append('-'); }\n+      sb.append(']');\n+    }\n+\n+    static void escapeRangeCharOnto(\n+        char ch, boolean startIsFlush, boolean atStart, boolean atEnd,\n+        StringBuilder sb) {\n+      switch (ch) {\n+        case '\\b':\n+          sb.append(\"\\\\b\");\n+          break;\n+        case '^':\n+          sb.append(atStart && startIsFlush ? \"\\\\^\" : \"^\");\n+          break;\n+        case '-':\n+          sb.append(atStart || atEnd ? \"-\" : \"\\\\-\");\n+          break;\n+        case '\\\\':\n+        case ']':\n+          sb.append('\\\\').append(ch);\n+          break;\n+        default:\n+          escapeCharOnto(ch, sb);\n+      }\n+    }\n+\n+    static int complexity(CharRanges ranges) {\n+      int complexity = 0;\n+      for (int i = 0, n = ranges.getNumRanges(); i < n; ++i) {\n+        int start = ranges.start(i);\n+        int end = ranges.end(i) - 1;\n+        if (start < 0x20 || start >= 0x7f) {\n+          complexity += start >= 0x100 ? 6 : 4;\n+        } else {\n+          ++complexity;\n+        }\n+        switch (end - start) {\n+          case 0: continue;\n+          case 1: break;\n+          default: complexity += 1;\n+        }\n+        if (end < 0x20 || end >= 0x7f) {\n+          complexity += end >= 0x100 ? 6 : 4;\n+        } else {\n+          ++complexity;\n+        }\n+      }\n+      return complexity;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (!(o instanceof DecomposedCharset)) {\n+        return false;\n+      }\n+      DecomposedCharset that = (DecomposedCharset) o;\n+      return this.inverted = that.inverted\n+          && this.ranges.equals(that.ranges)\n+          && this.namedGroups.equals(that.namedGroups);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return ranges.hashCode()\n+          + 31 * (namedGroups.hashCode() + (inverted ? 1 : 0));\n+    }\n+  }\n+\n+  static final class Concatenation extends RegExpTree {\n+    final ImmutableList<RegExpTree> elements;\n+\n+    Concatenation(RegExpTree a, RegExpTree b) {\n+      elements = ImmutableList.of(a, b);\n+    }\n+\n+    Concatenation(List<? extends RegExpTree> elements) {\n+      this.elements = ImmutableList.copyOf(elements);\n+    }\n+\n+    @Override\n+    public RegExpTree simplify(final String flags) {\n+      class Simplifier {\n+        final List<RegExpTree> simplified = Lists.newArrayList();\n+\n+        void simplify(RegExpTree t) {\n+          if (t instanceof Concatenation) {\n+            for (RegExpTree child : ((Concatenation) t).elements) {\n+              simplify(child);\n+            }\n+          } else if (t instanceof Empty) {\n+            // Do nothing\n+          } else {\n+            int lastIndex = simplified.size() - 1;\n+            if (lastIndex >= 0) {\n+              RegExpTree pairwise = simplifyPairwise(\n+                  simplified.get(lastIndex), t);\n+              if (pairwise != null) {\n+                simplified.set(lastIndex, pairwise);\n+                return;\n+              }\n+            }\n+            simplified.add(t);\n+          }\n+        }\n+\n+        RegExpTree simplifyPairwise(RegExpTree before, RegExpTree after) {\n+          if (before instanceof Text && after instanceof Text) {\n+            return new Text(\n+                ((Text) before).text + ((Text) after).text).simplify(flags);\n+          }\n+          // Fold adjacent repetitions.\n+          int beforeMin = 1, beforeMax = 1;\n+          RegExpTree beforeBody = before;\n+          boolean beforeGreedy = false;\n+          if (before instanceof Repetition) {\n+            Repetition r = (Repetition) before;\n+            beforeMin = r.min;\n+            beforeMax = r.max;\n+            beforeBody = r.body;\n+            beforeGreedy = r.greedy;\n+          }\n+          int afterMin = 1, afterMax = 1;\n+          RegExpTree afterBody = after;\n+          boolean afterGreedy = false;\n+          if (after instanceof Repetition) {\n+            Repetition r = (Repetition) after;\n+            afterMin = r.min;\n+            afterMax = r.max;\n+            afterBody = r.body;\n+            afterGreedy = r.greedy;\n+          }\n+          if (beforeBody.equals(afterBody)\n+              && !beforeBody.hasCapturingGroup()) {\n+            long lmin = ((long) beforeMin) + afterMin;\n+            long lmax = ((long) beforeMax) + afterMax;\n+            if (lmin < Integer.MAX_VALUE) {\n+              int min = (int) lmin;\n+              int max = lmax >= Integer.MAX_VALUE\n+                  ? Integer.MAX_VALUE : (int) lmax;\n+              return new Repetition(\n+                  beforeBody, min, max,\n+                  beforeGreedy || afterGreedy || min == max);\n+            }\n+          }\n+          return null;\n+        }\n+      }\n+\n+      Simplifier s = new Simplifier();\n+      for (RegExpTree element : elements) {\n+        s.simplify(element.simplify(flags));\n+      }\n+\n+      switch (s.simplified.size()) {\n+        case 0: return Empty.INSTANCE;\n+        case 1: return s.simplified.get(0);\n+        default: return new Concatenation(s.simplified);\n+      }\n+    }\n+\n+    @Override\n+    public boolean isCaseSensitive() {\n+      for (RegExpTree element : elements) {\n+        if (element.isCaseSensitive()) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public boolean containsAnchor() {\n+      for (RegExpTree element : elements) {\n+        if (element.containsAnchor()) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int numCapturingGroups() {\n+      int n = 0;\n+      for (RegExpTree element : elements) {\n+        n += element.numCapturingGroups();\n+      }\n+      return n;\n+    }\n+\n+    @Override\n+    public List<? extends RegExpTree> children() {\n+      return elements;\n+    }\n+\n+    @Override\n+    protected void appendSourceCode(StringBuilder sb) {\n+      boolean digitsMightBleed = false;\n+      for (RegExpTree element : elements) {\n+        boolean parenthesize = false;\n+        if (element instanceof Alternation\n+            || element instanceof Concatenation) {\n+          parenthesize = true;\n+        } else {\n+          digitsMightBleed = element instanceof Text;\n+          if (digitsMightBleed) {\n+            Text text = (Text) element;\n+            if (text.text.length() != 0) {\n+              char first = text.text.charAt(0);\n+              parenthesize = '0' <= first && first <= '9';\n+            }\n+          }\n+        }\n+        if (parenthesize) {\n+          sb.append(\"(?:\");\n+          element.appendSourceCode(sb);\n+          sb.append(')');\n+        } else {\n+          element.appendSourceCode(sb);\n+        }\n+        digitsMightBleed = element instanceof BackReference\n+            && ((BackReference) element).groupIndex < 10;\n+      }\n+    }\n+\n+    @Override\n+    protected void appendDebugInfo(StringBuilder sb) {\n+      // Nothing besides children.\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o instanceof Concatenation\n+          && elements.equals(((Concatenation) o).elements);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 0x20997e3e ^ elements.hashCode();\n+    }\n+  }\n+\n+  static void escapeCharOnto(char ch, StringBuilder sb) {\n+    switch (ch) {\n+      case '\\u0000':\n+        sb.append(\"\\\\0\");\n+        break;\n+      case '\\f':\n+        sb.append(\"\\\\f\");\n+        break;\n+      case '\\t':\n+        sb.append(\"\\\\t\");\n+        break;\n+      case '\\n':\n+        sb.append(\"\\\\n\");\n+        break;\n+      case '\\r':\n+        sb.append(\"\\\\r\");\n+        break;\n+      case '\\\\':\n+        sb.append(\"\\\\\\\\\");\n+        break;\n+      default:\n+        if (ch < 0x20 || ch >= 0x7f) {\n+          if (ch >= 0x100) {\n+            sb.append(\"\\\\u\");\n+            sb.append(\"0123456789abcdef\".charAt((ch >> 12) & 0xf));\n+            sb.append(\"0123456789abcdef\".charAt((ch >> 8) & 0xf));\n+            sb.append(\"0123456789abcdef\".charAt((ch >> 4) & 0xf));\n+            sb.append(\"0123456789abcdef\".charAt((ch) & 0xf));\n+          } else {\n+            sb.append(\"\\\\x\");\n+            sb.append(\"0123456789abcdef\".charAt((ch >> 4) & 0xf));\n+            sb.append(\"0123456789abcdef\".charAt((ch) & 0xf));\n+          }\n+        } else {\n+          sb.append(ch);\n+        }\n+    }\n+  }\n+}", "timestamp": 1305249982, "metainfo": ""}