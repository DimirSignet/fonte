{"sha": "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa", "log": "Change on 2010/04/15 by nick          Move the construction of ArrowTypes out of FunctionType.          R=john         DELTA=197  (79 added, 27 deleted, 91 changed)  Change on 2010/04/15 by nick          if a file is marked as an @extern, then make it an extern.          R=robert         DELTA=51  (46 added, 0 deleted, 5 changed)  Change on 2010/04/15 by john          Maintain source information.          R=alan         DELTA=60  (28 added, 7 deleted, 25 changed)  Change on 2010/04/15 by john          Fix overly aggressive RegExp check.          R=alan         DELTA=15  (12 added, 0 deleted, 3 changed)  Change on 2010/04/15 by nick          more fun with function-type building.          R=john         DELTA=432  (206 added, 142 deleted, 84 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=oqlcyn   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckRegExp.java\n+++ b/src/com/google/javascript/jscomp/CheckRegExp.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n-import com.google.javascript.jscomp.mozilla.rhino.Token;\n+import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.Node;\n \n /**\n     if (NodeUtil.isReferenceName(n)) {\n       String name = n.getString();\n       if (name.equals(\"RegExp\") && t.getScope().getVar(name) == null) {\n-        if (parent.getType() != Token.NEW || n != parent.getFirstChild()) {\n+        int parentType = parent.getType();\n+        boolean first = (n == parent.getFirstChild()); \n+        if (!((parentType == Token.NEW && first)\n+               || (parentType == Token.CALL && first)\n+               || (parentType == Token.INSTANCEOF && !first))) {\n           t.report(n, REGEXP_REFERENCE);\n           globalRegExpPropertiesUsed = true;\n         }\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n       if (name.hasChildren()) {\n         Node value = name.removeFirstChild();\n         var.removeChild(name);\n-        Node assign = new Node(Token.ASSIGN, name, value);\n+        Node assign = new Node(Token.ASSIGN, name, value)\n+            .copyInformationFrom(name);\n \n         // We don't need to wrapped it with EXPR node if it is within a FOR.\n         if (parent.getType() != Token.FOR) {\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n         externsRoot.addChildToBack(n);\n       }\n \n-      for (CompilerInput input : inputs) {\n+      List<CompilerInput> annotatedExterns = Lists.newArrayList();\n+      Iterator<CompilerInput> inputIterator = inputs.iterator();\n+      while (inputIterator.hasNext()) {\n+        CompilerInput input = inputIterator.next();\n         Node n = input.getAstRoot(this);\n         if (hasErrors()) {\n           return null;\n \n         // Inputs can have a null AST during initial parse.\n         if (n == null) {\n+          continue;\n+        }\n+\n+        if (n.getJSDocInfo() != null && n.getJSDocInfo().isExterns()) {\n+          // If the input file is explicitly marked as an externs file, then\n+          // assume the programmer made a mistake and throw it into\n+          // the externs pile anyways.\n+          externsRoot.addChildToBack(n);\n+          input.setIsExtern(true);\n+          inputIterator.remove();\n+          externs.add(input);\n           continue;\n         }\n \n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.Scope.Var;\n               moduleVarParentMap.put(deepestDependency, destParent);\n             }\n \n-            // Nodes which are 1 of many children of a VAR need to be moved\n-            // carefully. We must dissect them out of the VAR, and create a new\n-            // VAR to hold them.\n+            // VAR Nodes are normalized to have only one child.\n             Node declParent = decl.node.getParent();\n-            if (declParent.getType() == Token.VAR &&\n-                declParent.getChildCount() > 1) {\n-              declParent.removeChild(decl.node);\n-\n-              // Make a new node\n-              Node var = new Node(Token.VAR, decl.node);\n-              destParent.addChildToFront(var);\n-            } else {\n-              // Remove it\n-              declParent.detachFromParent();\n-\n-              // Add it to the new spot\n-              destParent.addChildToFront(declParent);\n-            }\n+            Preconditions.checkState(\n+                declParent.getType() != Token.VAR || declParent.hasOneChild(),\n+                \"AST not normalized.\");\n+\n+            // Remove it\n+            declParent.detachFromParent();\n+\n+            // Add it to the new spot\n+            destParent.addChildToFront(declParent);\n \n             compiler.reportCodeChange();\n           }\n     boolean recursive = false;\n     Node rootNode = t.getScope().getRootNode();\n     if (rootNode.getType() == Token.FUNCTION) {\n-      \n+\n       // CASE #1:\n       String scopeFuncName = rootNode.getFirstChild().getString();\n       if (scopeFuncName.equals(name)) {\n         recursive = true;\n       }\n-      \n+\n       // CASE #2:\n \n \n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n         // deepestCommonModuleRef is null.\n         continue;\n       }\n-      \n+\n       if (nameInfo.readsClosureVariables()) {\n         continue;\n       }\n           valueParent.replaceChild(value,\n               // A.prototype.b = JSCompiler_stubMethod(id);\n               new Node(Token.CALL,\n-                  Node.newString(Token.NAME, STUB_METHOD_NAME),\n-                  Node.newNumber(stubId)));\n+                      Node.newString(Token.NAME, STUB_METHOD_NAME),\n+                      Node.newNumber(stubId))\n+                  .copyInformationFromForTree(value));\n \n           // unstub the function body in the deeper module\n           Node unstubParent = compiler.getNodeForCodeInsertion(\n                       new Node(Token.CALL,\n                           Node.newString(Token.NAME, UNSTUB_METHOD_NAME),\n                           Node.newNumber(stubId),\n-                          value))));\n+                          value)))\n+                  .copyInformationFromForTree(value));\n \n           compiler.reportCodeChange();\n           logger.fine(\"Moved method: \" +\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n         parent.replaceChild(n, op);\n       } else if (n.getType() == Token.INC || n.getType() == Token.DEC) {\n         if (NodeUtil.isExpressionNode(parent)) {\n-          parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0)));\n+          parent.replaceChild(n,\n+              new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n)));\n         } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) {\n           parent.removeChild(n);\n         } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) &&\n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n    */\n   private void doExtraction(GatherExtractionInfo info) {\n     // First declare the temp variable.\n-    Node var = new Node(Token.VAR, Node.newString(Token.NAME, prototypeAlias));\n-    compiler.getNodeForCodeInsertion(null).addChildrenToFront(var);\n+    Node injectionPoint = compiler.getNodeForCodeInsertion(null);\n+\n+    Node var = NodeUtil.newVarNode(prototypeAlias, null)\n+        .copyInformationFromForTree(injectionPoint);\n+    \n+    injectionPoint.addChildrenToFront(var);\n \n     // Go through all extraction instances and extract each of them.\n     for (ExtractionInstance instance : info.instances) {\n    */\n   private void extractInstance(ExtractionInstance instance) {\n     // Use the temp variable to hold the prototype.\n-    String className = instance.declarations.getFirst().qualifiedClassName;\n-    Node stmt = new Node(instance.declarations.getFirst().node.getType(),\n+    PrototypeMemberDeclaration first = instance.declarations.getFirst();\n+    String className = first.qualifiedClassName;\n+    Node stmt = new Node(first.node.getType(),\n         new Node(Token.ASSIGN,\n             Node.newString(Token.NAME, prototypeAlias),\n             NodeUtil.newQualifiedNameNode(className + \".prototype\",\n-                instance.parent, className + \".prototype\")));\n-\n-    instance.parent.addChildBefore(stmt, instance.declarations.getFirst().node);\n+                instance.parent, className + \".prototype\")))\n+        .copyInformationFromForTree(first.node);\n+\n+    instance.parent.addChildBefore(stmt, first.node);\n \n     // Go thought each member declaration and replace it with an assignment\n     // to the prototype variable.\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionBuilder;\n import com.google.javascript.rhino.jstype.FunctionParamBuilder;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.InstanceObjectType;\n       }\n       maybeSetBaseType(fnType);\n     } else {\n-      fnType = typeRegistry.createMethodTypeWithTypeTemplate(\n-          fnName, sourceNode,\n-          parametersNode, returnType, thisType, templateTypeName);\n+      fnType = new FunctionBuilder(typeRegistry)\n+          .withName(fnName)\n+          .withSourceNode(sourceNode)\n+          .withParamsNode(parametersNode)\n+          .withReturnType(returnType)\n+          .withTypeOfThis(thisType)\n+          .withTemplateName(templateTypeName)\n+          .build();\n       maybeSetBaseType(fnType);\n     }\n \n--- a/src/com/google/javascript/rhino/jstype/ErrorFunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/ErrorFunctionType.java\n   private static final long serialVersionUID = 1L;\n \n   ErrorFunctionType(JSTypeRegistry registry, String name) {\n-    super(registry, name, null,\n-          registry.createOptionalParameters(\n-              registry.getNativeType(ALL_TYPE),\n-              registry.getNativeType(ALL_TYPE),\n-              registry.getNativeType(ALL_TYPE)),\n-          null, null, null, true, true);\n-  }\n+    super(\n+        registry, name, null,\n+        registry.createArrowType(\n+            registry.createOptionalParameters(\n+                registry.getNativeType(ALL_TYPE),\n+                registry.getNativeType(ALL_TYPE),\n+                registry.getNativeType(ALL_TYPE)),\n+            null),\n+        null, null, true, true);\n \n-  @Override\n-  public JSType getReturnType() {\n-    return getInstanceType();\n+    // NOTE(nicksantos): Errors have the weird behavior in that they can\n+    // be called as functions, and they will return instances of themselves.\n+    // Error('x') instanceof Error => true\n+    //\n+    // In user-defined types, we would deal with this case by creating\n+    // a NamedType with the name \"Error\" and then resolve it later.\n+    //\n+    // For native types, we don't really want the native types to\n+    // depend on type-resolution. So we just set the return type manually\n+    // at the end of construction.\n+    //\n+    // There's similar logic in JSTypeRegistry for Array and RegExp.\n+    getInternalArrowType().returnType = getInstanceType();\n   }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Bob Jervis\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * A builder class for function and arrow types.\n+ *\n+ * If you need to build an interface constructor,\n+ * use {@link JSTypeRegistry#createInterfaceType}.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public final class FunctionBuilder {\n+  private final JSTypeRegistry registry;\n+  private String name = null;\n+  private Node sourceNode = null;\n+  private Node parametersNode = null;\n+  private JSType returnType = null;\n+  private ObjectType typeOfThis = null;\n+  private String templateTypeName = null;\n+  private boolean isConstructor = false;\n+  private boolean isNativeType = false;\n+\n+  public FunctionBuilder(JSTypeRegistry registry) {\n+    this.registry = registry;\n+  }\n+\n+  /** Set the name of the function type. */\n+  public FunctionBuilder withName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+\n+  /** Set the source node of the function type. */\n+  public FunctionBuilder withSourceNode(Node sourceNode) {\n+    this.sourceNode = sourceNode;\n+    return this;\n+  }\n+\n+  /** Set the parameters of the function type from a FunctionParamBuilder. */\n+  public FunctionBuilder withParams(FunctionParamBuilder params) {\n+    this.parametersNode = params.build();\n+    return this;\n+  }\n+\n+  /**\n+   * Set the parameters of the function type with a specially-formatted node.\n+   */\n+  public FunctionBuilder withParamsNode(Node parametersNode) {\n+    this.parametersNode = parametersNode;\n+    return this;\n+  }\n+\n+  /** Set the return type. */\n+  public FunctionBuilder withReturnType(JSType returnType) {\n+    this.returnType = returnType;\n+    return this;\n+  }\n+\n+  /** Set the \"this\" type. */\n+  public FunctionBuilder withTypeOfThis(ObjectType typeOfThis) {\n+    this.typeOfThis = typeOfThis;\n+    return this;\n+  }\n+\n+  /** Set the template name. */\n+  public FunctionBuilder withTemplateName(String templateTypeName) {\n+    this.templateTypeName = templateTypeName;\n+    return this;\n+  }\n+\n+  /** Make this a constructor. */\n+  public FunctionBuilder forConstructor() {\n+    this.isConstructor = true;\n+    return this;\n+  }\n+\n+  /** Make this a native type. */\n+  FunctionBuilder forNativeType() {\n+    this.isNativeType = true;\n+    return this;\n+  }\n+\n+  /** Copies all the information from another function type. */\n+  public FunctionBuilder copyFromOtherFunction(FunctionType otherType) {\n+    this.name = otherType.getReferenceName();\n+    this.sourceNode = otherType.getSource();\n+    this.parametersNode = otherType.getParametersNode();\n+    this.returnType = otherType.getReturnType();\n+    this.typeOfThis = otherType.getTypeOfThis();\n+    this.templateTypeName = otherType.getTemplateTypeName();\n+    this.isConstructor = otherType.isConstructor();\n+    this.isNativeType = otherType.isNativeObjectType();\n+    return this;\n+  }\n+\n+  /** Construct a new function type. */\n+  public FunctionType build() {\n+    return new FunctionType(registry, name, sourceNode,\n+        registry.createArrowType(parametersNode, returnType),\n+        typeOfThis, templateTypeName, isConstructor, isNativeType);\n+  }\n+}\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n    */\n   private String templateTypeName;\n \n-  /**\n-   * Creates a function type.\n-   * @param registry the owner registry for this type\n-   * @param name the function's name or {@code null} to indicate that the\n-   *        function is anonymous.\n-   * @param source the node defining this function. Its type\n-   *        ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n-   * @param parameters the function's parameters or {@code null}\n-   *        to indicate that the parameter types are unknown.\n-   * @param returnType the function's return type or {@code null} to indicate\n-   *        that the return type is unknown.\n-   */\n-  FunctionType(JSTypeRegistry registry, String name, Node source,\n-      Node parameters, JSType returnType) {\n-    this(registry, name, source, parameters, returnType, null, null, false,\n-         false);\n-  }\n-\n-  /**\n-   * Creates a function type.\n-   * @param registry the owner registry for this type\n-   * @param name the function's name or {@code null} to indicate that the\n-   *        function is anonymous.\n-   * @param source the node defining this function. Its type\n-   *        ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n-   * @param parameters the function's parameters or {@code null}\n-   *        to indicate that the parameter types are unknown.\n-   * @param returnType the function's return type or {@code null} to indicate\n-   *        that the return type is unknown.\n-   * @param typeOfThis The type of {@code this} in non-constructors.  May be\n-   *        {@code null} to indicate that the type of {@code this} is unknown.\n-   */\n-  FunctionType(JSTypeRegistry registry, String name, Node source,\n-      Node parameters, JSType returnType, ObjectType typeOfThis) {\n-    this(registry, name, source, parameters, returnType, typeOfThis,\n-        null, false, false);\n-  }\n-\n-  /**\n-   * Creates a function type.\n-   * @param registry the owner registry for this type\n-   * @param name the function's name or {@code null} to indicate that the\n-   *        function is anonymous.\n-   * @param source the node defining this function. Its type\n-   *        ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n-   * @param parameters the function's parameters or {@code null}\n-   *        to indicate that the parameter types are unknown.\n-   * @param returnType the function's return type or {@code null} to indicate\n-   *        that the return type is unknown.\n-   * @param typeOfThis The type of {@code this} in non-constructors.  May be\n-   *        {@code null} to indicate that the type of {@code this} is unknown.\n-   * @param templateTypeName The template type name or {@code null}.\n-   */\n-  FunctionType(JSTypeRegistry registry, String name, Node source,\n-      Node parameters, JSType returnType, ObjectType typeOfThis,\n-      String templateTypeName) {\n-    this(registry, name, source, parameters, returnType, typeOfThis,\n-        templateTypeName, false, false);\n-  }\n-\n   /** Creates an instance for a function that might be a constructor. */\n   FunctionType(JSTypeRegistry registry, String name, Node source,\n-      Node parameters, JSType returnType, ObjectType typeOfThis,\n+      ArrowType arrowType, ObjectType typeOfThis,\n       String templateTypeName,  boolean isConstructor, boolean nativeType) {\n     super(registry, name,\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n           typeOfThis :\n           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n     }\n-    // The call type should be set up last because we are calling getReturnType,\n-    // which may be overloaded and depend on other properties being set.\n-    this.call = new ArrowType(registry, parameters,\n-        (returnType == null ? getReturnType() : returnType));\n+    this.call = arrowType;\n     this.templateTypeName = templateTypeName;\n   }\n \n   /** Creates an instance for a function that is an interface. */\n-  FunctionType(JSTypeRegistry registry, String name, Node source) {\n+  private FunctionType(JSTypeRegistry registry, String name, Node source) {\n     super(registry, name,\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE));\n     Preconditions.checkArgument(source == null ||\n     this.call = null;\n     this.kind = Kind.INTERFACE;\n     this.typeOfThis = new InstanceObjectType(registry, this);\n+  }\n+\n+  /** Creates an instance for a function that is an interface. */\n+  static FunctionType forInterface(\n+      JSTypeRegistry registry, String name, Node source) {\n+    return new FunctionType(registry, name, source);\n   }\n \n   @Override\n \n   public JSType getReturnType() {\n     return call == null ? null : call.returnType;\n+  }\n+\n+  /** Gets the internal arrow type. For use by subclasses only. */\n+  ArrowType getInternalArrowType() {\n+    return call;\n   }\n \n   /**\n             // If there's no params array, don't do any type-checking\n             // in this CALL function.\n             defineDeclaredProperty(name,\n-                new FunctionType(registry, null, null,\n-                    null, getReturnType()),\n+                new FunctionBuilder(registry)\n+                    .withReturnType(getReturnType())\n+                    .build(),\n                 false);\n           } else {\n             params = params.cloneTree();\n             thisTypeNode.setOptionalArg(true);\n \n             defineDeclaredProperty(name,\n-                new FunctionType(registry, null, null,\n-                    params, getReturnType()),\n+                new FunctionBuilder(registry)\n+                    .withParamsNode(params)\n+                    .withReturnType(getReturnType())\n+                    .build(),\n                 false);\n           }\n         } else if (\"apply\".equals(name)) {\n                   registry.getNativeType(JSTypeNative.OBJECT_TYPE)));\n \n           defineDeclaredProperty(name,\n-              new FunctionType(registry, null, null,\n-                  builder.build(), getReturnType()),\n+              new FunctionBuilder(registry)\n+                  .withParams(builder)\n+                  .withReturnType(getReturnType())\n+                  .build(),\n               false);\n         }\n       }\n     return super.resolveInternal(t, scope);\n   }\n \n+  // A helper method for creating arrow types.\n+  private ArrowType createArrowType(Node parameters, JSType returnType) {\n+    return registry.createArrowType(parameters, returnType);\n+  }\n+\n   @Override\n   public String toDebugHashCodeString() {\n     if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n     // Object\n     FunctionType OBJECT_FUNCTION_TYPE =\n         new FunctionType(this, \"Object\", null,\n-            createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE,\n+            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n             null, null, true, true);\n     OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n         \"prototype\", TOP_LEVEL_PROTOTYPE, true);\n     // Function\n     FunctionType FUNCTION_FUNCTION_TYPE =\n         new FunctionType(this, \"Function\", null,\n-            createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE,\n+            createArrowType(\n+                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n             null, null, true, true);\n     FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n     registerNativeType(\n     // Array\n     FunctionType ARRAY_FUNCTION_TYPE =\n       new FunctionType(this, \"Array\", null,\n-          createParametersWithVarArgs(ALL_TYPE), null, null, null, true, true) {\n-        private static final long serialVersionUID = 1L;\n-\n-        @Override\n-        public JSType getReturnType() {\n-          return getInstanceType();\n-        }\n-      };\n+          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n+          null, null, true, true);\n+    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n+        ARRAY_FUNCTION_TYPE.getInstanceType();\n+\n     ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n     registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n \n     // Boolean\n     FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n         new FunctionType(this, \"Boolean\", null,\n-            createParameters(false, ALL_TYPE), BOOLEAN_TYPE, null, null, true,\n-            true);\n+            createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),\n+            null, null, true, true);\n     ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n     registerNativeType(\n         JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE, BOOLEAN_OBJECT_FUNCTION_TYPE);\n     // Date\n     FunctionType DATE_FUNCTION_TYPE =\n       new FunctionType(this, \"Date\", null,\n-          createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n-              UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n-          STRING_TYPE, null, null, true, true);\n+          createArrowType(\n+              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n+                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n+              STRING_TYPE),\n+          null, null, true, true);\n     ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n     registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n \n \n     // Number\n     FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n-        new FunctionType(this, \"Number\", null, createParameters(false, ALL_TYPE),\n-            NUMBER_TYPE, null, null, true, true);\n+        new FunctionType(this, \"Number\", null,\n+            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n+            null, null, true, true);\n     ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n     registerNativeType(\n         JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n     // RegExp\n     FunctionType REGEXP_FUNCTION_TYPE =\n       new FunctionType(this, \"RegExp\", null,\n-          createOptionalParameters(ALL_TYPE, ALL_TYPE),\n-          null, null, null, true, true) {\n-        private static final long serialVersionUID = 1L;\n-\n-        @Override\n-        public JSType getReturnType() {\n-          return getInstanceType();\n-        }\n-      };\n+          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n+          null, null, true, true);\n+    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n+        REGEXP_FUNCTION_TYPE.getInstanceType();\n+\n     ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n     registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n \n \n     // String\n     FunctionType STRING_OBJECT_FUNCTION_TYPE =\n-        new FunctionType(this, \"String\", null, createParameters(false, ALL_TYPE),\n-        STRING_TYPE, null, null, true, true);\n+        new FunctionType(this, \"String\", null,\n+            createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),\n+            null, null, true, true);\n     ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n     registerNativeType(\n         JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n         // in addition, overrides getInstanceType() to return the NoObject type\n         // instead of a new anonymous object.\n         new FunctionType(this, \"Function\", null,\n-          createParametersWithVarArgs(\n-              UNKNOWN_TYPE), UNKNOWN_TYPE, NO_OBJECT_TYPE, null, true, true) {\n+            createArrowType(\n+                createParametersWithVarArgs(UNKNOWN_TYPE),\n+                UNKNOWN_TYPE),\n+            NO_OBJECT_TYPE, null, true, true) {\n           private static final long serialVersionUID = 1L;\n \n           @Override public FunctionType getConstructor() {\n   }\n \n   /**\n+   * Creates an arrow type, an abstract representation of the parameters\n+   * and return value of a function.\n+   *\n+   * @param parametersNode the parameters' types, formatted as a Node with\n+   *     param names and optionality info.\n+   * @param returnType the function's return type\n+   */\n+  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n+    return new ArrowType(this, parametersNode, returnType);\n+  }\n+\n+  /**\n+   * Creates an arrow type with an unknown return type.\n+   *\n+   * @param parametersNode the parameters' types, formatted as a Node with\n+   *     param names and optionality info.\n+   */\n+  ArrowType createArrowType(Node parametersNode) {\n+    return new ArrowType(this, parametersNode, null);\n+  }\n+\n+  /**\n    * Creates a function type.\n    *\n    * @param returnType the function's return type\n    */\n   public FunctionType createFunctionType(\n       JSType returnType, JSType... parameterTypes) {\n-    return new FunctionType(\n-        this, null, null, createParameters(parameterTypes), returnType);\n+    return createFunctionType(returnType, createParameters(parameterTypes));\n   }\n \n   /**\n    */\n   public FunctionType createFunctionTypeWithVarArgs(\n       JSType returnType, List<JSType> parameterTypes) {\n-    return new FunctionType(\n-        this, null, null, createParametersWithVarArgs(parameterTypes),\n-        returnType);\n+    return createFunctionType(\n+        returnType, createParametersWithVarArgs(parameterTypes));\n   }\n \n   /**\n    */\n   public FunctionType createFunctionType(\n       JSType returnType, List<JSType> parameterTypes) {\n-    return new FunctionType(\n-        this, null, null, createParameters(parameterTypes), returnType);\n+    return createFunctionType(returnType, createParameters(parameterTypes));\n   }\n \n   /**\n    */\n   public FunctionType createFunctionTypeWithVarArgs(\n       JSType returnType, JSType... parameterTypes) {\n-    return new FunctionType(\n-        this, null, null, createParametersWithVarArgs(parameterTypes), returnType);\n+    return createFunctionType(\n+        returnType, createParametersWithVarArgs(parameterTypes));\n   }\n \n   /**\n    */\n   public JSType createFunctionType(ObjectType instanceType,\n       JSType returnType, List<JSType> parameterTypes) {\n-    return new FunctionType(this, null, null, createParameters(parameterTypes),\n-        returnType, instanceType);\n+    return new FunctionBuilder(this)\n+        .withParamsNode(createParameters(parameterTypes))\n+        .withReturnType(returnType)\n+        .withTypeOfThis(instanceType)\n+        .build();\n   }\n \n   /**\n    */\n   public JSType createFunctionTypeWithVarArgs(ObjectType instanceType,\n       JSType returnType, List<JSType> parameterTypes) {\n-    return new FunctionType(this, null, null,\n-        createParametersWithVarArgs(parameterTypes), returnType, instanceType);\n+    return new FunctionBuilder(this)\n+        .withParamsNode(createParametersWithVarArgs(parameterTypes))\n+        .withReturnType(returnType)\n+        .withTypeOfThis(instanceType)\n+        .build();\n   }\n \n   /**\n    */\n   public FunctionType createFunctionTypeWithNewReturnType(\n       FunctionType existingFunctionType, JSType returnType) {\n-    return new FunctionType(\n-        this,\n-        existingFunctionType.getReferenceName(),\n-        existingFunctionType.getSource(),\n-        existingFunctionType.getParametersNode(),\n-        returnType,\n-        existingFunctionType.getTypeOfThis(),\n-        existingFunctionType.getTemplateTypeName());\n+    return new FunctionBuilder(this)\n+        .copyFromOtherFunction(existingFunctionType)\n+        .withReturnType(returnType)\n+        .build();\n   }\n \n   /**\n    */\n   public FunctionType createFunctionTypeWithNewThisType(\n       FunctionType existingFunctionType, ObjectType thisType) {\n-    return new FunctionType(\n-        this,\n-        existingFunctionType.getReferenceName(),\n-        existingFunctionType.getSource(),\n-        existingFunctionType.getParametersNode(),\n-        existingFunctionType.getReturnType(),\n-        thisType,\n-        existingFunctionType.getTemplateTypeName());\n+    return new FunctionBuilder(this)\n+        .copyFromOtherFunction(existingFunctionType)\n+        .withTypeOfThis(thisType)\n+        .build();\n   }\n \n   /**\n    */\n   public FunctionType createFunctionType(\n       JSType returnType, Node parameters) {\n-    return new FunctionType(this, null, null, parameters, returnType);\n-  }\n-\n-  /**\n-   * @param name the function's name or {@code null} to indicate that the\n-   *        function is anonymous.\n-   * @param source the node defining this function. Its type\n-   *        ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n-   * @param parameters the function's parameters or {@code null}\n-   *        to indicate that the parameter types are unknown.\n-   * @param returnType the function's return type or {@code null} to indicate\n-   *        that the return type is unknown.\n-   * @param typeOfThis The type of {@code this} in non-constructors.  May be\n-   *        {@code null} to indicate that the type of {@code this} is unknown.\n-   * @param templateTypeName The template type name or {@code null}.\n-   */\n-  public FunctionType createMethodTypeWithTypeTemplate(String name, Node source,\n-      Node parameters, JSType returnType, ObjectType typeOfThis,\n-      String templateTypeName) {\n-    return new FunctionType(this, name, source, parameters, returnType,\n-        typeOfThis, templateTypeName);\n-  }\n-\n-  /**\n-   * @param name the function's name or {@code null} to indicate that the\n-   *        function is anonymous.\n-   * @param source the node defining this function. Its type\n-   *        ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n-   * @param parameters the function's parameters or {@code null}\n-   *        to indicate that the parameter types are unknown.\n-   * @param returnType the function's return type or {@code null} to indicate\n-   *        that the return type is unknown.\n-   * @param typeOfThis The type of {@code this} in non-constructors.  May be\n-   *        {@code null} to indicate that the type of {@code this} is unknown.\n-   */\n-  public FunctionType createMethodType(String name, Node source,\n-      Node parameters, JSType returnType, ObjectType typeOfThis) {\n-    return new FunctionType(this, name, source, parameters, returnType,\n-        typeOfThis);\n-  }\n-\n-  /**\n-   * @param parameters the function's parameters or {@code null}\n-   *        to indicate that the parameter types are unknown.\n-   * @param returnType the function's return type or {@code null} to indicate\n-   *        that the return type is unknown.\n-   * @param typeOfThis The type of {@code this} in non-constructors.  May be\n-   *        {@code null} to indicate that the type of {@code this} is unknown.\n-   */\n-  public FunctionType createMethodType(\n-      JSType returnType, Node parameters, ObjectType typeOfThis) {\n-    return new FunctionType(this, null, null, parameters,\n-        returnType, typeOfThis);\n+    return new FunctionBuilder(this)\n+        .withParamsNode(parameters)\n+        .withReturnType(returnType)\n+        .build();\n   }\n \n   /**\n    */\n   public FunctionType createConstructorType(String name, Node source,\n       Node parameters, JSType returnType) {\n-    return new FunctionType(this, name, source, parameters, returnType, null,\n+    return new FunctionType(this, name, source,\n+        createArrowType(parameters, returnType), null,\n         null, true, false);\n   }\n \n    *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n    */\n   public FunctionType createInterfaceType(String name, Node source) {\n-    return new FunctionType(this, name, source);\n+    return FunctionType.forInterface(this, name, source);\n   }\n \n   /**\n \n         JSType returnType = createFromTypeNodes(current, sourceName, scope);\n \n-        return new FunctionType(this, null, null, paramBuilder.build(),\n-             returnType, thisType, null);\n+        return new FunctionBuilder(this)\n+            .withParams(paramBuilder)\n+            .withReturnType(returnType)\n+            .withTypeOfThis(thisType)\n+            .build();\n     }\n \n     throw new IllegalStateException(\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   NoObjectType(JSTypeRegistry registry) {\n-    super(registry, null, null, null, null, null, null, true, true);\n-  }\n-\n-  @Override\n-  public JSType getReturnType() {\n-    return this;\n-  }\n-\n-  @Override\n-  public ObjectType getInstanceType() {\n-    return this;\n+    super(registry, null, null,\n+          registry.createArrowType(null, null),\n+          null, null, true, true);\n+    getInternalArrowType().returnType = this;\n+    this.setInstanceType(this);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n \n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.FunctionBuilder;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.RecordTypeBuilder;\n \n import junit.framework.TestCase;\n-\n \n public abstract class BaseJSTypeTestCase extends TestCase {\n   protected JSTypeRegistry registry;\n       JSTypeRegistry registry, ObjectType receivingType, String methodName,\n       JSType returnType) {\n     receivingType.defineDeclaredProperty(methodName,\n-        registry.createMethodType(returnType, null, null), true);\n+        new FunctionBuilder(registry).withReturnType(returnType).build(), true);\n   }\n \n   protected JSType createUnionType(JSType... variants) {\n--- a/test/com/google/javascript/jscomp/CheckRegExpTest.java\n+++ b/test/com/google/javascript/jscomp/CheckRegExpTest.java\n   }\n \n   public void testRegExp() {\n-    // creating regexp's is ok\n+    // Creating regexp's is ok\n+    testReference(\"RegExp();\", false);\n+    testReference(\"var x = RegExp();\", false);\n     testReference(\"new RegExp();\", false);\n     testReference(\"var x = new RegExp();\", false);\n+\n+    // Checking for RegExp instances is ok, as well.\n+    testReference(\"x instanceof RegExp;\", false);\n \n     // Any other reference isn't\n     testReference(\"RegExp.test();\", true);\n     testReference(\"RegExp.exec();\", true);\n     testReference(\"RegExp.$1;\", true);\n     testReference(\"RegExp.foobar;\", true);\n+    testReference(\"delete RegExp;\", true);\n \n     // Aliases aren't allowed\n     testReference(\"var x = RegExp;\", true);\n+    testReference(\"f(RegExp);\", true);\n+    testReference(\"new f(RegExp);\", true);\n     testReference(\"var x = RegExp; x.test()\", true);\n \n     // No RegExp reference is ok\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n \n   @Override\n   public void setUp() {\n+    super.enableLineNumberCheck(true);\n     usePseudoName = false;\n   }\n \n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   public void testHelpFlag() {\n     args.add(\"--help\");\n     testSame(\"function f() {}\");\n-  }  \n+  }\n+\n+  public void testExternsLifting1() {\n+    test(new String[] {\"/** @externs */ function f() {}\"},\n+         new String[] {});\n+  }\n+\n+  public void testExternsLifting2() {\n+    args.add(\"--warning_level=VERBOSE\");\n+    test(new String[] {\"/** @externs */ function f() {}\", \"f(3);\"},\n+         new String[] {\"f(3);\"},\n+         TypeCheck.WRONG_ARGUMENT_COUNT);\n+  }\n \n   /* Helper functions */\n \n    * {@code original} is transformed into {@code compiled}.\n    */\n   private void test(String[] original, String[] compiled) {\n+    test(original, compiled, null);\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * {@code original} is transformed into {@code compiled}.\n+   * If {@code warning} is non-null, we will also check if the given\n+   * warning type was emitted.\n+   */\n+  private void test(String[] original, String[] compiled,\n+                    DiagnosticType warning) {\n     Compiler compiler = compile(original);\n-    assertEquals(\"Expected no warnings or errors\\n\" +\n-        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n-        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n-        0, compiler.getErrors().length + compiler.getWarnings().length);\n+\n+    if (warning == null) {\n+      assertEquals(\"Expected no warnings or errors\\n\" +\n+          \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n+          \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n+          0, compiler.getErrors().length + compiler.getWarnings().length);\n+    } else {\n+      assertEquals(1, compiler.getWarnings().length);\n+      assertEquals(warning, compiler.getWarnings()[0].getType());\n+    }\n \n     Node root = compiler.getRoot().getLastChild();\n     if (useStringComparison) {\n         \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n         1, compiler.getErrors().length + compiler.getWarnings().length);\n     if (compiler.getErrors().length > 0) {\n+      assertEquals(1, compiler.getErrors().length);\n       assertEquals(warning, compiler.getErrors()[0].getType());\n     } else {\n+      assertEquals(1, compiler.getWarnings().length);\n       assertEquals(warning, compiler.getWarnings()[0].getType());\n     }\n   }\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n abstract class CompilerTypeTestCase extends BaseJSTypeTestCase {\n+\n+  static final String ACTIVE_X_OBJECT_DEF =\n+      \"/**\\n\" +\n+      \" * @param {string} progId\\n\" +\n+      \" * @param {string=} opt_location\\n\" +\n+      \" * @constructor\\n\" +\n+      \" * @see http://msdn.microsoft.com/en-us/library/7sw4ddf8.aspx\\n\" +\n+      \" */\\n\" +\n+      \"function ActiveXObject(progId, opt_location) {}\\n\";\n \n   static final String CLOSURE_DEFS =\n       \"var goog = {};\" +\n       \"/** @type {number} */ String.prototype.length;\" +\n       \"/** @constructor \\n * @param {*} var_args \\n @return {!Array} */\" +\n       \"function Array(var_args) {}\" +\n-      \"/** @type {number} */ Array.prototype.length;\";\n+      \"/** @type {number} */ Array.prototype.length;\" + ACTIVE_X_OBJECT_DEF;\n \n   protected Compiler compiler;\n \n--- a/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n   }\n \n   @Override\n+  public void setUp() {\n+    super.enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n     return new CrossModuleCodeMotion(compiler, compiler.getModuleGraph());\n   }\n     // Test moving 1 variable out of the block\n     JSModule[] modules = createModuleStar(\n       // m1\n-      \"var a = 0, b = 1, c = 2;\",\n+      \"var a = 0; var b = 1; var c = 2;\",\n       // m2\n       \"var x = b;\"\n     );\n \n     test(modules, new String[] {\n       // m1\n-      \"var a = 0, c = 2;\",\n+      \"var a = 0; var c = 2;\",\n       // m2\n       \"var b = 1;\" +\n       \"var x = b;\"\n     // Test moving all variables out of the block\n     JSModule[] modules = createModuleStar(\n       // m1\n-      \"var a = 0, b = 1;\",\n+      \"var a = 0; var b = 1;\",\n       // m2\n       \"var x = a + b;\"\n     );\n       // m2\n       \"function g(){};\"));\n   }\n-  \n+\n   public void testClone1() {\n     test(createModuleChain(\n              // m1\n            \"var a = (new f).cloneFun();\"\n          });\n   }\n-  \n+\n   public void testEmptyModule() {\n     // When the dest module is empty, it might try to move the code to the\n     // one of the modules that the empty module depends on. In some cases\n     // modules are non-empty.\n     JSModule m1 = new JSModule(\"m1\");\n     m1.add(JSSourceFile.fromCode(\"m1\", \"function x() {}\"));\n-    \n+\n     JSModule empty = new JSModule(\"empty\");\n     empty.addDependency(m1);\n-    \n+\n     JSModule m2 = new JSModule(\"m2\");\n     m2.add(JSSourceFile.fromCode(\"m2\", \"x()\"));\n     m2.addDependency(empty);\n-    \n+\n     JSModule m3 = new JSModule(\"m3\");\n     m3.add(JSSourceFile.fromCode(\"m3\", \"x()\"));\n     m3.addDependency(empty);\n-    \n+\n     test(new JSModule[] {m1,empty,m2,m3},\n         new String[] {\n           \"\",\n--- a/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n \n   @Override\n   public void setUp() {\n+    super.enableLineNumberCheck(true);\n     canMoveExterns = false;\n   }\n \n           \"x();\"\n         });\n   }\n-  \n+\n   // Read of closure variable disables method motions.\n   public void testClosureVariableReads1() {\n     testSame(createModuleChain(\n             // Module 2\n             \"var y = new Foo(); y.baz();\"));\n   }\n-  \n+\n   // Read of global variable is fine.\n   public void testClosureVariableReads2() {\n     test(createModuleChain(\n            \"y = new Foo(); z.b3();\"\n         });\n   }\n-  \n+\n   public void testClosureVariableReads3() {\n     test(createModuleChain(\n             \"function Foo() {}\" +\n            \"y = new Foo(); z.b3();\"\n         });\n   }\n-  \n+\n   // Read of global variable is fine.\n   public void testNoClosureVariableReads1() {\n     test(createModuleChain(\n            \"function Foo() {}\" +\n            \"var x = 'x';\" +\n            \"Foo.prototype.baz = JSCompiler_stubMethod(0);\",\n-           // Module 2             \n+           // Module 2\n            \"Foo.prototype.baz = JSCompiler_unstubMethod(0, function(){x});\" +\n            \"var y = new Foo(); y.baz();\"\n         });\n   }\n-  \n+\n   // Read of a local is fine.\n   public void testNoClosureVariableReads2() {\n     test(createModuleChain(\n            STUB_DECLARATIONS +\n            \"function Foo() {}\" +\n            \"Foo.prototype.baz = JSCompiler_stubMethod(0);\",\n-           // Module 2             \n-           \"Foo.prototype.baz = JSCompiler_unstubMethod(\" + \n+           // Module 2\n+           \"Foo.prototype.baz = JSCompiler_unstubMethod(\" +\n            \"    0, function(){var x = 1; x});\" +\n            \"var y = new Foo(); y.baz();\"\n         });\n--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n \n   public DeadAssignmentsEliminationTest() {\n     super(\"var extern;\");\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    super.enableLineNumberCheck(true);\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java\n \n /**\n  * Tests for {@link ExtractPrototypeMemberDeclarations}.\n- * \n+ *\n *\n  */\n public class ExtractPrototypeMemberDeclarationsTest extends CompilerTestCase {\n   private static final String TMP = \"a\";\n-  \n+\n+  @Override\n+  protected void setUp() {\n+    super.enableLineNumberCheck(true);\n+  }\n+\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new ExtractPrototypeMemberDeclarations(compiler);\n   }\n-  \n+\n   public void testNotEnoughPrototypeToExtract() {\n     // switch statement with stuff after \"return\"\n     for (int i = 0; i < 7; i++) {\n       testSame(generatePrototypeDeclarations(\"x\", i));\n     }\n   }\n-  \n-  public void testExtractingSingleClassPrototype() { \n-    extract(generatePrototypeDeclarations(\"x\", 7), \n+\n+  public void testExtractingSingleClassPrototype() {\n+    extract(generatePrototypeDeclarations(\"x\", 7),\n         loadPrototype(\"x\") +\n         generateExtractedDeclarations(7));\n   }\n \n-  public void testExtractingTwoClassPrototype() { \n+  public void testExtractingTwoClassPrototype() {\n     extract(\n         generatePrototypeDeclarations(\"x\", 6) +\n         generatePrototypeDeclarations(\"y\", 6),\n         generateExtractedDeclarations(6));\n   }\n \n-  public void testExtractingTwoClassPrototypeInDifferentBlocks() { \n+  public void testExtractingTwoClassPrototypeInDifferentBlocks() {\n     extract(\n         generatePrototypeDeclarations(\"x\", 6) +\n         \"if (foo()) {\" +\n         loadPrototype(\"y\") +\n         generateExtractedDeclarations(6) +\n         \"}\");\n-  }  \n-  \n-  public void testNoMemberDeclarations() { \n+  }\n+\n+  public void testNoMemberDeclarations() {\n     testSame(\n         \"x.prototype = {}; x.prototype = {}; x.prototype = {};\" +\n         \"x.prototype = {}; x.prototype = {}; x.prototype = {};\" +\n         \"x.prototype = {}; x.prototype = {}; x.prototype = {};\");\n   }\n-  \n-  public void testExtractingPrototypeWithQName() { \n+\n+  public void testExtractingPrototypeWithQName() {\n     extract(\n-        generatePrototypeDeclarations(\"com.google.javascript.jscomp.x\", 7), \n+        generatePrototypeDeclarations(\"com.google.javascript.jscomp.x\", 7),\n         loadPrototype(\"com.google.javascript.jscomp.x\") +\n         generateExtractedDeclarations(7));\n   }\n         TMP + \".y.f = 1;\" +\n         TMP + \".y.g = 1;\");\n   }\n-  \n+\n   public void testUsedNameInScope() {\n     test(\n         \"var a = 0;\" +\n   public String loadPrototype(String qName) {\n     return TMP + \" = \" + qName + \".prototype;\";\n   }\n-  \n+\n   public void extract(String src, String expected) {\n     test(src, \"var \" + TMP + \";\" + expected);\n   }\n-  \n+\n   public String generatePrototypeDeclarations(String className, int num) {\n     StringBuilder builder = new StringBuilder();\n     for (int i = 0; i < num; i++) {\n     }\n     return builder.toString();\n   }\n-  \n-  public String generatePrototypeDeclaration(String className, String member, \n+\n+  public String generatePrototypeDeclaration(String className, String member,\n       String value) {\n     return className + \".prototype.\" + member + \" = \" + value + \";\";\n   }\n-  \n+\n   public String generateExtractedDeclarations(int num) {\n     StringBuilder builder = new StringBuilder();\n     for (int i = 0; i < num; i++) {\n     }\n     return builder.toString();\n   }\n-  \n+\n   public String generateExtractedDeclaration(String member, String value) {\n     return TMP + \".\" + member + \" = \" + value + \";\";\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);\n   }\n \n+  public void testActiveXObject() throws Exception {\n+    testTypes(\n+        \"/** @type {Object} */ var x = new ActiveXObject();\" +\n+        \"/** @type { {impossibleProperty} } */ var y = new ActiveXObject();\");\n+  }\n+\n   private void checkObjectType(ObjectType objectType, String propertyName,\n         JSType expectedType) {\n     assertTrue(\"Expected \" + objectType.getReferenceName() +\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n  * @author nicksantos@google.com (Nick Santos)\n  */\n public class TypedScopeCreatorTest extends CompilerTestCase {\n+\n+  private static final String ACTIVE_X_OBJECT_DEF =\n+      \"/**\\n\" +\n+      \" * @param {string} progId\\n\" +\n+      \" * @param {string=} opt_location\\n\" +\n+      \" * @constructor\\n\" +\n+      \" * @see http://msdn.microsoft.com/en-us/library/7sw4ddf8.aspx\\n\" +\n+      \" */\\n\" +\n+      \"function ActiveXObject(progId, opt_location) {}\\n\";\n \n   private JSTypeRegistry registry;\n   private Scope globalScope;\n         findNameType(\"y\", globalScope).toString());\n   }\n \n+  public void testActiveXObject() {\n+    testSame(\n+        CompilerTypeTestCase.ACTIVE_X_OBJECT_DEF,\n+        \"var x = new ActiveXObject();\", null);\n+    assertEquals(\n+        \"NoObject\",\n+        findNameType(\"x\", globalScope).toString());\n+  }\n+\n   private JSType findNameType(String name, Scope scope) {\n     Node root = scope.getRootNode();\n     Deque<Node> queue = Lists.newLinkedList();\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.ArrowType;\n import com.google.javascript.rhino.jstype.JSType.TypePair;\n import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n     enumType = new EnumType(registry, \"Enum\", NUMBER_TYPE);\n     elementsType = enumType.getElementsType();\n-    functionType = new FunctionType(registry, null, null, null, NUMBER_TYPE);\n-    dateMethod = new FunctionType(registry, null, null, new Node(Token.LP),\n-        NUMBER_TYPE, DATE_TYPE);\n+    functionType = new FunctionBuilder(registry)\n+        .withReturnType(NUMBER_TYPE)\n+        .build();\n+    dateMethod = new FunctionBuilder(registry)\n+        .withParamsNode(new Node(Token.LP))\n+        .withReturnType(NUMBER_TYPE)\n+        .withTypeOfThis(DATE_TYPE)\n+        .build();\n     unresolvedNamedType =\n         new NamedType(registry, \"not.resolved.named.type\", null, -1, -1);\n     namedGoogBar = new NamedType(registry, \"goog.Bar\", null, -1, -1);\n \n     subclassCtor =\n-        new FunctionType(registry, null, null, null, null, null, null,\n-                         true, false);\n+        new FunctionType(registry, null, null, createArrowType(null),\n+            null, null, true, false);\n     subclassCtor.setPrototypeBasedOn(unresolvedNamedType);\n     subclassOfUnresolvedNamedType = subclassCtor.getInstanceType();\n \n-    interfaceType = new FunctionType(registry, \"Interface\", null);\n+    interfaceType = FunctionType.forInterface(registry, \"Interface\", null);\n     interfaceInstType = interfaceType.getInstanceType();\n \n     googBar = registry.createConstructorType(\"goog.Bar\", null, null, null);\n             STRING_TYPE).toString());\n \n     assertEquals(\"function (this:Date, number): (boolean|number|string)\",\n-        new FunctionType(registry, null,\n-            null,\n-            new JSTypeRegistry(null).createParameters(NUMBER_TYPE),\n-            NUMBER_STRING_BOOLEAN,\n-            DATE_TYPE).toString());\n+        new FunctionBuilder(registry)\n+            .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+            .withReturnType(NUMBER_STRING_BOOLEAN)\n+            .withTypeOfThis(DATE_TYPE)\n+            .build().toString());\n   }\n \n   /**\n    * Tests relationships between structural function types.\n    */\n   public void testFunctionTypeRelationships() {\n-    FunctionType dateMethodEmpty = new FunctionType(registry, null, null,\n-        null, null, DATE_TYPE);\n-    FunctionType dateMethodWithParam = new FunctionType(registry, null, null,\n-        new JSTypeRegistry(null).createParameters(NUMBER_TYPE), null, DATE_TYPE);\n-    FunctionType dateMethodWithReturn = new FunctionType(registry, null, null,\n-        null, NUMBER_TYPE, DATE_TYPE);\n-    FunctionType stringMethodEmpty = new FunctionType(registry, null, null,\n-        null, null, STRING_OBJECT_TYPE);\n-    FunctionType stringMethodWithParam = new FunctionType(registry, null, null,\n-        new JSTypeRegistry(null).createParameters(NUMBER_TYPE), null,\n-        STRING_OBJECT_TYPE);\n-    FunctionType stringMethodWithReturn = new FunctionType(registry, null,\n-        null, null, NUMBER_TYPE, STRING_OBJECT_TYPE);\n+    FunctionType dateMethodEmpty = new FunctionBuilder(registry)\n+        .withTypeOfThis(DATE_TYPE).build();\n+    FunctionType dateMethodWithParam = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+        .withTypeOfThis(DATE_TYPE).build();\n+    FunctionType dateMethodWithReturn = new FunctionBuilder(registry)\n+        .withReturnType(NUMBER_TYPE)\n+        .withTypeOfThis(DATE_TYPE).build();\n+    FunctionType stringMethodEmpty = new FunctionBuilder(registry)\n+        .withTypeOfThis(STRING_OBJECT_TYPE).build();\n+    FunctionType stringMethodWithParam = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+        .withTypeOfThis(STRING_OBJECT_TYPE).build();\n+    FunctionType stringMethodWithReturn = new FunctionBuilder(registry)\n+        .withReturnType(NUMBER_TYPE)\n+        .withTypeOfThis(STRING_OBJECT_TYPE).build();\n \n     // One-off tests.\n     assertFalse(stringMethodEmpty.isSubtype(dateMethodEmpty));\n    * Tests relationships between structural function types.\n    */\n   public void testFunctionSubTypeRelationships() {\n-    FunctionType googBarMethod = new FunctionType(registry, null, null,\n-        null, null, googBar);\n-    FunctionType googBarParamFn = new FunctionType(registry, null, null,\n-        new JSTypeRegistry(null).createParameters(googBar), null, null);\n-    FunctionType googBarReturnFn = new FunctionType(registry, null, null,\n-        null, googBar, null);\n-    FunctionType googSubBarMethod = new FunctionType(registry, null, null,\n-        null, null, googSubBar);\n-    FunctionType googSubBarParamFn = new FunctionType(registry, null, null,\n-        new JSTypeRegistry(null).createParameters(googSubBar), null, null);\n-    FunctionType googSubBarReturnFn = new FunctionType(registry, null, null,\n-        null, googSubBar, null);\n+    FunctionType googBarMethod = new FunctionBuilder(registry)\n+        .withTypeOfThis(googBar).build();\n+    FunctionType googBarParamFn = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(googBar)).build();\n+    FunctionType googBarReturnFn = new FunctionBuilder(registry)\n+        .withReturnType(googBar).build();\n+    FunctionType googSubBarMethod = new FunctionBuilder(registry)\n+        .withTypeOfThis(googSubBar).build();\n+    FunctionType googSubBarParamFn = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(googSubBar)).build();\n+    FunctionType googSubBarReturnFn = new FunctionBuilder(registry)\n+        .withReturnType(googSubBar).build();\n \n     assertTrue(googBarMethod.isSubtype(googSubBarMethod));\n     assertTrue(googBarReturnFn.isSubtype(googSubBarReturnFn));\n     assertTrue(registry.getDirectImplementors(\n         interfaceType.getInstanceType()).contains(googBar));\n   }\n+\n+  private ArrowType createArrowType(Node params) {\n+    return registry.createArrowType(params);\n+  }\n+\n+  private ArrowType createArrowType(Node params, JSType retType) {\n+    return registry.createArrowType(params, retType);\n+  }\n }", "timestamp": 1271375159, "metainfo": ""}