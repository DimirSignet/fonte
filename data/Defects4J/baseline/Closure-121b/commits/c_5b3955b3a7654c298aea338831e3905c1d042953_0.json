{"sha": "5b3955b3a7654c298aea338831e3905c1d042953", "log": "Introduce a working-titled \"classTemplate\" annotation. For use when declaring templatized classes. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=42665388", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/Annotation.java\n+++ b/src/com/google/javascript/jscomp/parsing/Annotation.java\n   STRUCT,\n   SUPPRESS,\n   TEMPLATE,\n+  CLASS_TEMPLATE,\n   THIS,\n   THROWS,\n   TYPE,\n       put(\"struct\", Annotation.STRUCT).\n       put(\"suppress\", Annotation.SUPPRESS).\n       put(\"template\", Annotation.TEMPLATE).\n+      put(\"classTemplate\", Annotation.CLASS_TEMPLATE).\n       put(\"this\", Annotation.THIS).\n       put(\"throws\", Annotation.THROWS).\n       put(\"type\", Annotation.TYPE).\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                   token = parseSuppressTag(next());\n                   continue retry;\n \n-                case TEMPLATE:\n+                case TEMPLATE: {\n                   ExtractionInfo templateInfo = extractSingleLineBlock();\n                   List<String> names = Lists.newArrayList(\n                       Splitter.on(',')\n \n                   token = templateInfo.token;\n                   continue retry;\n+                }\n+\n+                case CLASS_TEMPLATE: {\n+                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n+                  List<String> names = Lists.newArrayList(\n+                      Splitter.on(',')\n+                          .trimResults()\n+                          .split(classTemplateInfo.string));\n+\n+                  if (names.size() == 0 || names.get(0).length() == 0) {\n+                    parser.addTypeWarning(\n+                        \"msg.jsdoc.classtemplate.missing.type.name\",\n+                        stream.getLineno(), stream.getCharno());\n+                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n+                    parser.addTypeWarning(\n+                        \"msg.jsdoc.classtemplate.at.most.once\",\n+                        stream.getLineno(), stream.getCharno());\n+                  }\n+\n+                  token = classTemplateInfo.token;\n+                  continue retry;\n+                }\n \n                 case IDGENERATOR:\n                   if (!jsdocBuilder.recordIdGenerator()) {\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n     Map<String, JSTypeExpression> parameters = null;\n     List<JSTypeExpression> thrownTypes = null;\n     ImmutableList<String> templateTypeNames = null;\n+    ImmutableList<String> classTemplateTypeNames = null;\n \n     // Other information\n     String description = null;\n   }\n \n   /**\n+   * Declares a template type name. Template type names are described using the\n+   * {@code @template} annotation.\n+   *\n+   * @param templateTypeNames the template type name.\n+   */\n+  boolean declareClassTemplateTypeNames(List<String> templateTypeNames) {\n+    lazyInitInfo();\n+\n+    if (info.classTemplateTypeNames != null) {\n+      return false;\n+    }\n+\n+    info.classTemplateTypeNames = ImmutableList.copyOf(templateTypeNames);\n+    return true;\n+  }\n+\n+  /**\n    * Declares that the method throws a given type.\n    *\n    * @param jsType The type that can be thrown by the method.\n       return ImmutableList.of();\n     }\n     return info.templateTypeNames;\n+  }\n+\n+  public ImmutableList<String> getClassTemplateTypeNames() {\n+    if (info == null || info.classTemplateTypeNames == null) {\n+      return ImmutableList.of();\n+    }\n+    return info.classTemplateTypeNames;\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n   }\n \n   /**\n+   * Records a template type name.\n+   *\n+   * @return {@code true} if the template type name was recorded and\n+   *     {@code false} if a template type name was already defined.\n+   */\n+  public boolean recordClassTemplateTypeNames(List<String> names) {\n+    if (currentInfo.declareClassTemplateTypeNames(names)) {\n+      populated = true;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+\n+  /**\n    * Records a thrown type.\n    */\n   public boolean recordThrowType(JSTypeExpression type) {\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n \n   public void testParserWithTwoTemplates() {\n     parse(\"@template T,V */\");\n+  }\n+\n+  public void testParserWithClassTemplateTypeNameMissing() {\n+    parse(\"@classTemplate */\",\n+        \"Bad type annotation. @classTemplate tag missing type name\");\n+  }\n+\n+  public void testParserWithClassTemplateDuplicated() {\n+    parse(\"@classTemplate T\\n@classTemplate V */\",\n+        \"Bad type annotation. @classTemplate tag at most once\");\n+  }\n+\n+  public void testParserWithTwoClassTemplates() {\n+    parse(\"@classTemplate T,V */\");\n+  }\n+\n+  public void testParserWithClassTemplatesAndTemplate() {\n+    parse(\"@template T\\n@classTemplate T,V */\");\n   }\n \n   public void testWhitelistedNewAnnotations() {", "timestamp": 1361320233, "metainfo": ""}