{"sha": "f423b0e9d4b2c0f3f74b3850dd5a35fd89ebc8a5", "log": "Remove lint warnings ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44164469", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n         .setDependencySorting(true)\n         .setMoocherDropping(false)\n         .setEntryPoints(closureEntryPoints);\n-    }\n-    else if (manageClosureDependencies ||\n+    } else if (manageClosureDependencies ||\n         closureEntryPoints.size() > 0) {\n       return new DependencyOptions()\n           .setDependencyPruning(true)\n     options.angularPass = config.angularPass;\n   }\n \n-  final protected A getCompiler() {\n+  protected final A getCompiler() {\n     return compiler;\n   }\n \n    * Runs the Compiler and calls System.exit() with the exit status of the\n    * compiler.\n    */\n-  final public void run() {\n+  public final void run() {\n     int result = 0;\n     int runs = 1;\n     if (config.computePhaseOrdering) {\n         int i = 1;\n         for (List<String> loop : loopedPassesInBestRun) {\n           jsOutput.append(\n-              \"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\");\n+              \"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop) + \"\\n\");\n           i++;\n         }\n       } catch (IOException e) {\n--- a/src/com/google/javascript/jscomp/AbstractMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/AbstractMessageFormatter.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.ImmutableSet;\n-import com.google.javascript.jscomp.CheckLevel;\n \n import java.util.Set;\n \n   }\n \n   private String maybeColorize(String text, Color color) {\n-    if (!colorize) return text;\n-\n+    if (!colorize) {\n+      return text;\n+    }\n     return color.getControlCharacter() +\n         text + Color.RESET.getControlCharacter();\n   }\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n \n package com.google.javascript.jscomp;\n \n-import javax.annotation.Nullable;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Strings;\n import com.google.common.collect.Lists;\n import java.util.Map;\n import java.util.Set;\n \n+import javax.annotation.Nullable;\n \n /**\n  * <p>AliasExternals provides wrappers and aliases for external globals and\n       // one parameter to GETPROP_prop() call.\n       Node callName = IR.name(\n           getMutatorFor(propNameNode.getString()));\n-      Node call = IR.call( callName, propSrc, propDest);\n+      Node call = IR.call(callName, propSrc, propDest);\n       call.putBooleanProp(Node.FREE_CALL, true);\n \n       // And replace the assign statement with the new call\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n       Node name = NodeUtil.newName(\n           compiler.getCodingConvention(),\n           getAliasName(), throwNode, getAliasName());\n-      Node aliasCall = IR.call( name, throwNode.removeFirstChild());\n+      Node aliasCall = IR.call(name, throwNode.removeFirstChild());\n       aliasCall.putBooleanProp(Node.FREE_CALL, true);\n       Node exprResult = IR.exprResult(aliasCall);\n       parent.replaceChild(throwNode, exprResult);\n    * throw. The function throws the object.\n    */\n   private static Node createAliasFunctionNode(String aliasName) {\n-    final String PARAM_NAME = \"jscomp_throw_param\";\n+    final String paramName = \"jscomp_throw_param\";\n     return IR.function(\n         IR.name(aliasName),\n-        IR.paramList(IR.name(PARAM_NAME)),\n+        IR.paramList(IR.name(paramName)),\n         IR.block(\n-            IR.throwNode(IR.name(PARAM_NAME))));\n+            IR.throwNode(IR.name(paramName))));\n   }\n \n   /** Aliases literal keywords (e.g., null) with variable names. */\n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n      */\n     String encodeStringAsIdentifier(String prefix, String s) {\n       // Limit to avoid generating very long identifiers\n-      final int MAX_LIMIT = 20;\n+      final int maxLimit = 20;\n       final int length = s.length();\n-      final int limit = Math.min(length, MAX_LIMIT);\n+      final int limit = Math.min(length, maxLimit);\n \n       StringBuilder sb = new StringBuilder();\n       sb.append(prefix);\n--- a/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n+++ b/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NameReferenceGraph.Name;\n import com.google.javascript.jscomp.NameReferenceGraph.Reference;\n+import com.google.javascript.jscomp.graph.Annotation;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n-import com.google.javascript.jscomp.graph.Annotation;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n import com.google.javascript.jscomp.graph.GraphNode;\n-import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n import com.google.javascript.rhino.Node;\n \n /**\n     graph = gc.getNameReferenceGraph();\n     FixedPointGraphTraversal<Name, Reference> t =\n         FixedPointGraphTraversal.newTraversal(new PropagateReferences());\n-    getInfo(graph.MAIN).markReference(null);\n-    t.computeFixedPoint(graph, Sets.newHashSet(graph.MAIN));\n+    getInfo(graph.main).markReference(null);\n+    t.computeFixedPoint(graph, Sets.newHashSet(graph.main));\n   }\n \n   public NameReferenceGraph getGraph() {\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n-import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n class AnalyzePrototypeProperties implements CompilerPass {\n \n   // Constants for symbol types, for easier readability.\n-  private final SymbolType PROPERTY = SymbolType.PROPERTY;\n-  private final SymbolType VAR = SymbolType.VAR;\n+  private static final SymbolType PROPERTY = SymbolType.PROPERTY;\n+  private static final SymbolType VAR = SymbolType.VAR;\n \n   private final AbstractCompiler compiler;\n   private final boolean canModifyExterns;\n--- a/src/com/google/javascript/jscomp/AngularPass.java\n+++ b/src/com/google/javascript/jscomp/AngularPass.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n-\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n--- a/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n+++ b/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-\n \n /**\n  * Visitor that performs naming operations on anonymous functions by\n--- a/src/com/google/javascript/jscomp/AstParallelizer.java\n+++ b/src/com/google/javascript/jscomp/AstParallelizer.java\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.List;\n \n /**\n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n   // * optionally verify every node has an assigned JSType\n   //\n \n+  /** Violation handler */\n   public interface ViolationHandler {\n     void handleViolation(String message, Node n);\n   }\n--- a/src/com/google/javascript/jscomp/BasicErrorManager.java\n+++ b/src/com/google/javascript/jscomp/BasicErrorManager.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.CheckLevel;\n \n import java.util.ArrayList;\n import java.util.Comparator;\n--- a/src/com/google/javascript/jscomp/CheckDebuggerStatement.java\n+++ b/src/com/google/javascript/jscomp/CheckDebuggerStatement.java\n  */\n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.DiagnosticType;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n \n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.GlobalNamespace.Name;\n import com.google.javascript.jscomp.GlobalNamespace.Ref;\n import com.google.javascript.rhino.JSDocInfo;\n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n+\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n--- a/src/com/google/javascript/jscomp/CheckProvides.java\n+++ b/src/com/google/javascript/jscomp/CheckProvides.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Maps;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n         int index = -1;\n         boolean found = false;\n         do {\n-          index = ctor.indexOf('.', index +1);\n+          index = ctor.indexOf('.', index + 1);\n           String provideKey = index == -1 ? ctor : ctor.substring(0, index);\n           if (provides.containsKey(provideKey)) {\n             found = true;\n--- a/src/com/google/javascript/jscomp/CheckRegExp.java\n+++ b/src/com/google/javascript/jscomp/CheckRegExp.java\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.regex.RegExpTree;\n+import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.Node;\n \n /**\n  * Look for references to the global RegExp object that would cause\n--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n \n import java.util.List;\n import java.util.Set;\n-\n \n /**\n  * This pass walks the AST to create a Collection of 'new' nodes and\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Lists;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfoBuilder;\n--- a/src/com/google/javascript/jscomp/CleanupPasses.java\n+++ b/src/com/google/javascript/jscomp/CleanupPasses.java\n import com.google.javascript.rhino.jstype.JSType;\n \n import java.util.List;\n-\n \n /**\n  * Provides passes that should be run before hot-swap/incremental builds.\n--- a/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n+\n import java.util.List;\n import java.util.Set;\n \n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n   public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n     SubclassRelationship relationship =\n         super.getClassesDefinedByCall(callNode);\n-    if (relationship != null) return relationship;\n+    if (relationship != null) {\n+      return relationship;\n+    }\n \n     Node callName = callNode.getFirstChild();\n     SubclassType type = typeofClassDefiningName(callName);\n--- a/src/com/google/javascript/jscomp/ClosureRewriteClass.java\n+++ b/src/com/google/javascript/jscomp/ClosureRewriteClass.java\n       return null;\n     }\n \n-    int paramCount = callNode.getChildCount() -1;\n+    int paramCount = callNode.getChildCount() - 1;\n     if (paramCount > 2) {\n       compiler.report(JSError.make(callNode, GOOG_CLASS_UNEXPECTED_PARAMS));\n       return null;\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Comparator;\n import java.util.Deque;\n import java.util.Iterator;\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.rhino.Node;\n-\n \n /**\n  * Abstracted consumer of the CodeGenerator output.\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n   private static final String GT_ESCAPED = \"\\\\x3e\";\n \n   // A memoizer for formatting strings as JS strings.\n-  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n+  private final Map<String, String> escapedJsStrings = Maps.newHashMap();\n \n   private static final char[] HEX_CHARS\n       = { '0', '1', '2', '3', '4', '5', '6', '7',\n     if (useSlashV) {\n       add(jsString(n.getString(), useSlashV));\n     } else {\n-      String cached = ESCAPED_JS_STRINGS.get(s);\n+      String cached = escapedJsStrings.get(s);\n       if (cached == null) {\n         cached = jsString(n.getString(), useSlashV);\n-        ESCAPED_JS_STRINGS.put(s, cached);\n+        escapedJsStrings.put(s, cached);\n       }\n       add(cached);\n     }\n           // Break </script into <\\/script\n           // As above, this is just to prevent developers from doing this\n           // accidentally.\n-          final String END_SCRIPT = \"/script\";\n+          final String endScript = \"/script\";\n \n           // Break <!-- into <\\!--\n-          final String START_COMMENT = \"!--\";\n-\n-          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n-                              END_SCRIPT.length())) {\n+          final String startComment = \"!--\";\n+\n+          if (s.regionMatches(true, i + 1, endScript, 0,\n+                              endScript.length())) {\n             sb.append(LT_ESCAPED);\n-          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n-                                     START_COMMENT.length())) {\n+          } else if (s.regionMatches(false, i + 1, startComment, 0,\n+                                     startComment.length())) {\n             sb.append(LT_ESCAPED);\n           } else {\n             sb.append(c);\n     Node c = n.getFirstChild();\n     for (; c != null && i < maxCount; c = c.getNext()) {\n       if (c.isBlock()) {\n-        i += getNonEmptyChildCount(c, maxCount-i);\n+        i += getNonEmptyChildCount(c, maxCount - i);\n       } else if (!c.isEmpty()) {\n         i++;\n       }\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n   // version.\n \n   private abstract static class MappedCodePrinter extends CodeConsumer {\n-    final private Deque<Mapping> mappings;\n-    final private List<Mapping> allMappings;\n-    final private boolean createSrcMap;\n-    final private SourceMap.DetailLevel sourceMapDetailLevel;\n+    private final Deque<Mapping> mappings;\n+    private final List<Mapping> allMappings;\n+    private final boolean createSrcMap;\n+    private final SourceMap.DetailLevel sourceMapDetailLevel;\n     protected final StringBuilder code = new StringBuilder(1024);\n     protected final int lineLengthThreshold;\n     protected int lineLength = 0;\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n    */\n   public Bind describeFunctionBind(Node n, boolean useTypeInfo);\n \n+  /** Bind class */\n   public static class Bind {\n     // The target of the bind action\n     final Node target;\n    */\n   public Collection<AssertionFunctionSpec> getAssertionFunctions();\n \n+  /** Specify the kind of inheritance */\n   static enum SubclassType {\n     INHERITS,\n     MIXIN\n   }\n \n+  /** Record subclass relations */\n   static class SubclassRelationship {\n     final SubclassType type;\n     final String subclassName;\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n import com.google.javascript.jscomp.GlobalNamespace.Name;\n import com.google.javascript.jscomp.GlobalNamespace.Ref;\n import com.google.javascript.jscomp.GlobalNamespace.Ref.Type;\n-import com.google.javascript.jscomp.ReferenceCollectingCallback;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n-import com.google.javascript.jscomp.Scope;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n    */\n   private void flattenReferencesToCollapsibleDescendantNames(\n       Name n, String alias) {\n-    if (n.props == null) return;\n+    if (n.props == null) {\n+      return;\n+    }\n \n     for (Name p : n.props) {\n       String propAlias = appendPropForAlias(alias, p.getBaseName());\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n       }\n \n       // Only care about var nodes\n-      if (!n.isVar() && !canBeRedeclared(n, t.getScope())) return;\n+      if (!n.isVar() && !canBeRedeclared(n, t.getScope())) {\n+        return;\n+      }\n \n       // If we've already looked at this node, skip it\n-      if (nodesToCollapse.contains(n)) return;\n+      if (nodesToCollapse.contains(n)) {\n+        return;\n+      }\n \n       // Adjacent VAR children of an IF node are the if and else parts and can't\n       // be collapsed\n-      if (parent.isIf()) return;\n+      if (parent.isIf()) {\n+        return;\n+      }\n \n       Node varNode = n;\n \n         collapse.parent.removeChildAfter(var);\n \n         if (n.isVar()) {\n-          while(n.hasChildren()) {\n+          while (n.hasChildren()) {\n             var.addChildToBack(n.removeFirstChild());\n           }\n         } else {\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n     @Option(name = \"--help\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Displays this message\")\n-    private boolean display_help = false;\n+    private boolean displayHelp = false;\n \n     @Option(name = \"--print_tree\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Prints out the parse tree and exits\")\n-    private boolean print_tree = false;\n+    private boolean printTree = false;\n \n     @Option(name = \"--print_ast\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Prints a dot file describing the internal abstract syntax\"\n         + \" tree and exits\")\n-    private boolean print_ast = false;\n+    private boolean printAst = false;\n \n     @Option(name = \"--print_pass_graph\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Prints a dot file describing the passes that will get run\"\n         + \" and exits\")\n-    private boolean print_pass_graph = false;\n+    private boolean printPassGraph = false;\n \n     // Turn on (very slow) extra sanity checks for use when modifying the\n     // compiler.\n     @Option(name = \"--jscomp_dev_mode\",\n         // hidden, no usage\n         aliases = {\"--dev_mode\"})\n-    private CompilerOptions.DevMode jscomp_dev_mode =\n+    private CompilerOptions.DevMode jscompDevMode =\n         CompilerOptions.DevMode.OFF;\n \n     @Option(name = \"--logging_level\",\n         usage = \"The logging level (standard java.util.logging.Level\"\n         + \" values) for Compiler progress. Does not control errors or\"\n         + \" warnings for the JavaScript code under compilation\")\n-    private String logging_level = Level.WARNING.getName();\n+    private String loggingLevel = Level.WARNING.getName();\n \n     @Option(name = \"--externs\",\n         usage = \"The file containing JavaScript externs. You may specify\"\n     @Option(name = \"--js_output_file\",\n         usage = \"Primary output filename. If not specified, output is \" +\n         \"written to stdout\")\n-    private String js_output_file = \"\";\n+    private String jsOutputFile = \"\";\n \n     @Option(name = \"--module\",\n         usage = \"A JavaScript module specification. The format is \"\n     @Option(name = \"--variable_map_input_file\",\n         usage = \"File containing the serialized version of the variable \"\n         + \"renaming map produced by a previous compilation\")\n-    private String variable_map_input_file = \"\";\n+    private String variableMapInputFile = \"\";\n \n     @Option(name = \"--property_map_input_file\",\n         usage = \"File containing the serialized version of the property \"\n         + \"renaming map produced by a previous compilation\")\n-    private String property_map_input_file = \"\";\n+    private String propertyMapInputFile = \"\";\n \n     @Option(name = \"--variable_map_output_file\",\n         usage = \"File where the serialized version of the variable \"\n         + \"renaming map produced should be saved\")\n-    private String variable_map_output_file = \"\";\n+    private String variableMapOutputFile = \"\";\n \n     @Option(name = \"--create_name_map_files\",\n         handler = BooleanOptionHandler.class,\n         usage = \"If true, variable renaming and property renaming map \"\n         + \"files will be produced as {binary name}_vars_map.out and \"\n         + \"{binary name}_props_map.out. Note that this flag cannot be used \"\n-        + \"in conjunction with either variable_map_output_file or \"\n+        + \"in conjunction with either variableMapOutputFile or \"\n         + \"property_map_output_file\")\n-    private boolean create_name_map_files = false;\n+    private boolean createNameMapFiles = false;\n \n     @Option(name = \"--property_map_output_file\",\n         usage = \"File where the serialized version of the property \"\n         + \"renaming map produced should be saved\")\n-    private String property_map_output_file = \"\";\n+    private String propertyMapOutputFile = \"\";\n \n     @Option(name = \"--third_party\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Check source validity but do not enforce Closure style \"\n         + \"rules and conventions\")\n-    private boolean third_party = false;\n+    private boolean thirdParty = false;\n \n     @Option(name = \"--summary_detail_level\",\n         usage = \"Controls how detailed the compilation summary is. Values:\"\n         + \"errors or warnings), 2 (print summary if the 'checkTypes' \"\n         + \"diagnostic  group is enabled, see --jscomp_warning), \"\n         + \"3 (always print summary). The default level is 1\")\n-    private int summary_detail_level = 1;\n+    private int summaryDetailLevel = 1;\n \n     @Option(name = \"--output_wrapper\",\n         usage = \"Interpolate output into this string at the place denoted\"\n         + \" by the marker token %output%. Use marker token %output|jsstring%\"\n         + \" to do js string escaping on the output.\")\n-    private String output_wrapper = \"\";\n+    private String outputWrapper = \"\";\n \n     @Option(name = \"--module_wrapper\",\n         usage = \"An output wrapper for a JavaScript module (optional). \"\n         + \"with a module specified using --module. The wrapper must \"\n         + \"contain %s as the code placeholder. The %basename% placeholder can \"\n         + \"also be used to substitute the base name of the module output file.\")\n-    private List<String> module_wrapper = Lists.newArrayList();\n+    private List<String> moduleWrapper = Lists.newArrayList();\n \n     @Option(name = \"--module_output_path_prefix\",\n         usage = \"Prefix for filenames of compiled JS modules. \"\n         + \"<module-name>.js will be appended to this prefix. Directories \"\n         + \"will be created as needed. Use with --module\")\n-    private String module_output_path_prefix = \"./\";\n+    private String moduleOutputPathPrefix = \"./\";\n \n     @Option(name = \"--create_source_map\",\n         usage = \"If specified, a source map file mapping the generated \" +\n         \"output to the specified path. The %outname% placeholder will \" +\n         \"expand to the name of the output file that the source map \" +\n         \"corresponds to.\")\n-    private String create_source_map = \"\";\n+    private String createSourceMap = \"\";\n \n     @Option(name = \"--source_map_format\",\n         usage = \"The source map format to produce. \" +\n         \"Options: V1, V2, V3, DEFAULT. DEFAULT produces V2.\")\n-    private SourceMap.Format source_map_format = SourceMap.Format.DEFAULT;\n+    private SourceMap.Format sourceMapFormat = SourceMap.Format.DEFAULT;\n \n     // Used to define the flag, values are stored by the handler.\n     @SuppressWarnings(\"unused\")\n         handler = WarningGuardErrorOptionHandler.class,\n         usage = \"Make the named class of warnings an error. Options:\" +\n         DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-    private List<String> jscomp_error = Lists.newArrayList();\n+    private List<String> jscompError = Lists.newArrayList();\n \n     // Used to define the flag, values are stored by the handler.\n     @SuppressWarnings(\"unused\")\n         handler = WarningGuardWarningOptionHandler.class,\n         usage = \"Make the named class of warnings a normal warning. \" +\n         \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-    private List<String> jscomp_warning = Lists.newArrayList();\n+    private List<String> jscompWarning = Lists.newArrayList();\n \n     // Used to define the flag, values are stored by the handler.\n     @SuppressWarnings(\"unused\")\n         handler = WarningGuardOffOptionHandler.class,\n         usage = \"Turn off the named class of warnings. Options:\" +\n         DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-    private List<String> jscomp_off = Lists.newArrayList();\n+    private List<String> jscompOff = Lists.newArrayList();\n \n     @Option(name = \"--define\",\n         aliases = {\"--D\", \"-D\"},\n     @Option(name = \"--compilation_level\",\n         usage = \"Specifies the compilation level to use. Options: \" +\n         \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n-    private CompilationLevel compilation_level =\n+    private CompilationLevel compilationLevel =\n         CompilationLevel.SIMPLE_OPTIMIZATIONS;\n \n     @Option(name = \"--use_types_for_optimization\",\n         usage = \"Experimental: perform additional optimizations \" +\n         \"based on available information.  Inaccurate type annotations \" +\n         \"may result in incorrect results.\")\n-    private boolean use_types_for_optimization = false;\n+    private boolean useTypesForOptimization = false;\n \n     @Option(name = \"--warning_level\",\n         usage = \"Specifies the warning level to use. Options: \" +\n         \"QUIET, DEFAULT, VERBOSE\")\n-    private WarningLevel warning_level = WarningLevel.DEFAULT;\n+    private WarningLevel warningLevel = WarningLevel.DEFAULT;\n \n     @Option(name = \"--use_only_custom_externs\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Specifies whether the default externs should be excluded\")\n-    private boolean use_only_custom_externs = false;\n+    private boolean useOnlyCustomExterns = false;\n \n     @Option(name = \"--debug\",\n         handler = BooleanOptionHandler.class,\n     @Option(name = \"--generate_exports\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Generates export code for those marked with @export\")\n-    private boolean generate_exports = false;\n+    private boolean generateExports = false;\n \n     @Option(name = \"--formatting\",\n         usage = \"Specifies which formatting options, if any, should be \"\n \n     @Option(name = \"--process_common_js_modules\",\n         usage = \"Process CommonJS modules to a concatenable form.\")\n-    private boolean process_common_js_modules = false;\n+    private boolean processCommonJsModules = false;\n \n     @Option(name = \"--common_js_module_path_prefix\",\n         usage = \"Path prefix to be removed from CommonJS module names.\")\n-    private String common_js_path_prefix =\n+    private String commonJsPathPrefix =\n         ProcessCommonJSModules.DEFAULT_FILENAME_PREFIX;\n \n     @Option(name = \"--common_js_entry_module\",\n-        usage = \"Root of your common JS dependency hierarchy. \"+\n+        usage = \"Root of your common JS dependency hierarchy. \" +\n             \"Your main script.\")\n-    private String common_js_entry_module;\n+    private String commonJsEntryModule;\n \n     @Option(name = \"--transform_amd_modules\",\n         usage = \"Transform AMD to CommonJS modules.\")\n-    private boolean transform_amd_modules = false;\n+    private boolean transformAmdModules = false;\n \n     @Option(name = \"--process_closure_primitives\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Processes built-ins from the Closure library, such as \"\n         + \"goog.require(), goog.provide(), and goog.exportSymbol()\")\n-    private boolean process_closure_primitives = true;\n+    private boolean processClosurePrimitives = true;\n \n     @Option(name = \"--manage_closure_dependencies\",\n         handler = BooleanOptionHandler.class,\n         + \"goog.requires symbol X. If an input provides symbols, and \"\n         + \"those symbols are never required, then that input will not \"\n         + \"be included in the compilation.\")\n-    private boolean manage_closure_dependencies = false;\n+    private boolean manageClosureDependencies = false;\n \n     @Option(name = \"--only_closure_dependencies\",\n         handler = BooleanOptionHandler.class,\n         + \"entry points (specified by closure_entry_point). Files that do \"\n         + \"not provide dependencies will be removed. This supersedes\"\n         + \"manage_closure_dependencies\")\n-    private boolean only_closure_dependencies = false;\n+    private boolean onlyClosureDependencies = false;\n \n     @Option(name = \"--closure_entry_point\",\n         usage = \"Entry points to the program. Must be goog.provide'd \"\n         + \"If any entry points are specified, then the \"\n         + \"manage_closure_dependencies option will be set to true and \"\n         + \"all files will be sorted in dependency order.\")\n-    private List<String> closure_entry_point = Lists.newArrayList();\n+    private List<String> closureEntryPoint = Lists.newArrayList();\n \n     @Option(name = \"--process_jquery_primitives\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Processes built-ins from the Jquery library, such as \"\n         + \"jQuery.fn and jQuery.extend()\")\n-    private boolean process_jquery_primitives = false;\n+    private boolean processJqueryPrimitives = false;\n \n     @Option(name = \"--angular_pass\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Generate $inject properties for AngularJS for functions \"\n         + \"annotated with @ngInject\")\n-    private boolean angular_pass = false;\n+    private boolean angularPass = false;\n \n     @Option(name = \"--output_manifest\",\n         usage = \"Prints out a list of all the files in the compilation. \"\n         + \"The %outname% placeholder expands to the JS output file. \"\n         + \"If you're using modularization, using %outname% will create \"\n         + \"a manifest for each module.\")\n-    private String output_manifest = \"\";\n+    private String outputManifest = \"\";\n \n     @Option(name = \"--output_module_dependencies\",\n         usage = \"Prints out a JSON file of dependencies between modules.\")\n-    private String output_module_dependencies = \"\";\n+    private String outputModuleDependencies = \"\";\n \n     @Option(name = \"--accept_const_keyword\",\n         usage = \"Allows usage of const keyword.\")\n-    private boolean accept_const_keyword = false;\n+    private boolean acceptConstKeyword = false;\n \n     @Option(name = \"--language_in\",\n         usage = \"Sets what language spec that input sources conform. \"\n         + \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\")\n-    private String language_in = \"ECMASCRIPT3\";\n+    private String languageIn = \"ECMASCRIPT3\";\n \n     @Option(name = \"--version\",\n         handler = BooleanOptionHandler.class,\n \n     @Option(name = \"--flagfile\",\n         usage = \"A file containing additional command-line options.\")\n-    private String flag_file = \"\";\n+    private String flagFile = \"\";\n \n     @Option(name = \"--warnings_whitelist_file\",\n         usage = \"A file containing warnings to suppress. Each line should be \" +\n             \"of the form\\n\" +\n             \"<file-name>:<line-number>?  <warning-description>\")\n-    private String warnings_whitelist_file = \"\";\n+    private String warningsWhitelistFile = \"\";\n \n     @Option(name = \"--extra_annotation_name\",\n         usage = \"A whitelist of tag names in JSDoc. You may specify multiple\")\n-    private List<String> extra_annotation_name = Lists.newArrayList();\n+    private List<String> extraAnnotationName = Lists.newArrayList();\n \n     @Argument\n     private List<String> arguments = Lists.newArrayList();\n         String param = null;\n         try {\n           param = params.getParameter(0);\n-        } catch (CmdLineException e) {}\n+        } catch (CmdLineException e) {\n+          param = null; // to stop linter complaints\n+        }\n \n         if (param == null) {\n           setter.addValue(true);\n \n   private void processFlagFile(PrintStream err)\n             throws CmdLineException, IOException {\n-    File flagFileInput = new File(flags.flag_file);\n+    File flagFileInput = new File(flags.flagFile);\n     List<String> argsInFile = tokenizeKeepingQuotedStrings(\n         Files.readLines(flagFileInput, Charset.defaultCharset()));\n \n-    flags.flag_file = \"\";\n+    flags.flagFile = \"\";\n     List<String> processedFileArgs\n         = processArgs(argsInFile.toArray(new String[] {}));\n     CmdLineParser parserFileArgs = new CmdLineParser(flags);\n     Flags.guardLevels.addAll(previous);\n \n     // Currently we are not supporting this (prevent direct/indirect loops)\n-    if (!flags.flag_file.equals(\"\")) {\n+    if (!flags.flagFile.equals(\"\")) {\n       err.println(\"ERROR - Arguments in the file cannot contain \"\n           + \"--flagfile option.\");\n       isConfigValid = false;\n     try {\n       parser.parseArgument(processedArgs.toArray(new String[] {}));\n       // For contains --flagfile flag\n-      if (!flags.flag_file.equals(\"\")) {\n+      if (!flags.flagFile.equals(\"\")) {\n         processFlagFile(err);\n       }\n     } catch (CmdLineException e) {\n       err.println(e.getMessage());\n       isConfigValid = false;\n     } catch (IOException ioErr) {\n-      err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\n+      err.println(\"ERROR - \" + flags.flagFile + \" read error.\");\n       isConfigValid = false;\n     }\n \n       err.flush();\n     }\n \n-    if (flags.process_common_js_modules) {\n-      flags.process_closure_primitives = true;\n-      flags.manage_closure_dependencies = true;\n-      if (flags.common_js_entry_module == null) {\n+    if (flags.processCommonJsModules) {\n+      flags.processClosurePrimitives = true;\n+      flags.manageClosureDependencies = true;\n+      if (flags.commonJsEntryModule == null) {\n         err.println(\"Please specify --common_js_entry_module.\");\n         err.flush();\n         isConfigValid = false;\n       }\n-      flags.closure_entry_point = Lists.newArrayList(\n-          ProcessCommonJSModules.toModuleName(flags.common_js_entry_module));\n-    }\n-\n-    if (!isConfigValid || flags.display_help) {\n+      flags.closureEntryPoint = Lists.newArrayList(\n+          ProcessCommonJSModules.toModuleName(flags.commonJsEntryModule));\n+    }\n+\n+    if (!isConfigValid || flags.displayHelp) {\n       isConfigValid = false;\n       parser.printUsage(err);\n     } else {\n       CodingConvention conv;\n-      if (flags.third_party) {\n+      if (flags.thirdParty) {\n         conv = CodingConventions.getDefault();\n-      } else if (flags.process_jquery_primitives) {\n+      } else if (flags.processJqueryPrimitives) {\n         conv = new JqueryCodingConvention();\n       } else {\n         conv = new ClosureCodingConvention();\n       }\n \n       getCommandLineConfig()\n-          .setPrintTree(flags.print_tree)\n-          .setPrintAst(flags.print_ast)\n-          .setPrintPassGraph(flags.print_pass_graph)\n-          .setJscompDevMode(flags.jscomp_dev_mode)\n-          .setLoggingLevel(flags.logging_level)\n+          .setPrintTree(flags.printTree)\n+          .setPrintAst(flags.printAst)\n+          .setPrintPassGraph(flags.printPassGraph)\n+          .setJscompDevMode(flags.jscompDevMode)\n+          .setLoggingLevel(flags.loggingLevel)\n           .setExterns(flags.externs)\n           .setJs(flags.getJsFiles())\n-          .setJsOutputFile(flags.js_output_file)\n+          .setJsOutputFile(flags.jsOutputFile)\n           .setModule(flags.module)\n-          .setVariableMapInputFile(flags.variable_map_input_file)\n-          .setPropertyMapInputFile(flags.property_map_input_file)\n-          .setVariableMapOutputFile(flags.variable_map_output_file)\n-          .setCreateNameMapFiles(flags.create_name_map_files)\n-          .setPropertyMapOutputFile(flags.property_map_output_file)\n+          .setVariableMapInputFile(flags.variableMapInputFile)\n+          .setPropertyMapInputFile(flags.propertyMapInputFile)\n+          .setVariableMapOutputFile(flags.variableMapOutputFile)\n+          .setCreateNameMapFiles(flags.createNameMapFiles)\n+          .setPropertyMapOutputFile(flags.propertyMapOutputFile)\n           .setCodingConvention(conv)\n-          .setSummaryDetailLevel(flags.summary_detail_level)\n-          .setOutputWrapper(flags.output_wrapper)\n-          .setModuleWrapper(flags.module_wrapper)\n-          .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n-          .setCreateSourceMap(flags.create_source_map)\n-          .setSourceMapFormat(flags.source_map_format)\n+          .setSummaryDetailLevel(flags.summaryDetailLevel)\n+          .setOutputWrapper(flags.outputWrapper)\n+          .setModuleWrapper(flags.moduleWrapper)\n+          .setModuleOutputPathPrefix(flags.moduleOutputPathPrefix)\n+          .setCreateSourceMap(flags.createSourceMap)\n+          .setSourceMapFormat(flags.sourceMapFormat)\n           .setWarningGuardSpec(Flags.getWarningGuardSpec())\n           .setDefine(flags.define)\n           .setCharset(flags.charset)\n-          .setManageClosureDependencies(flags.manage_closure_dependencies)\n-          .setOnlyClosureDependencies(flags.only_closure_dependencies)\n-          .setClosureEntryPoints(flags.closure_entry_point)\n-          .setOutputManifest(ImmutableList.of(flags.output_manifest))\n-          .setOutputModuleDependencies(flags.output_module_dependencies)\n-          .setAcceptConstKeyword(flags.accept_const_keyword)\n-          .setLanguageIn(flags.language_in)\n-          .setProcessCommonJSModules(flags.process_common_js_modules)\n-          .setCommonJSModulePathPrefix(flags.common_js_path_prefix)\n-          .setTransformAMDToCJSModules(flags.transform_amd_modules)\n-          .setWarningsWhitelistFile(flags.warnings_whitelist_file);\n+          .setManageClosureDependencies(flags.manageClosureDependencies)\n+          .setOnlyClosureDependencies(flags.onlyClosureDependencies)\n+          .setClosureEntryPoints(flags.closureEntryPoint)\n+          .setOutputManifest(ImmutableList.of(flags.outputManifest))\n+          .setOutputModuleDependencies(flags.outputModuleDependencies)\n+          .setAcceptConstKeyword(flags.acceptConstKeyword)\n+          .setLanguageIn(flags.languageIn)\n+          .setProcessCommonJSModules(flags.processCommonJsModules)\n+          .setCommonJSModulePathPrefix(flags.commonJsPathPrefix)\n+          .setTransformAMDToCJSModules(flags.transformAmdModules)\n+          .setWarningsWhitelistFile(flags.warningsWhitelistFile);\n     }\n   }\n \n   @Override\n   protected CompilerOptions createOptions() {\n     CompilerOptions options = new CompilerOptions();\n-    if (flags.process_jquery_primitives) {\n+    if (flags.processJqueryPrimitives) {\n       options.setCodingConvention(new JqueryCodingConvention());\n     } else {\n       options.setCodingConvention(new ClosureCodingConvention());\n     }\n \n-    options.setExtraAnnotationNames(flags.extra_annotation_name);\n-\n-    CompilationLevel level = flags.compilation_level;\n+    options.setExtraAnnotationNames(flags.extraAnnotationName);\n+\n+    CompilationLevel level = flags.compilationLevel;\n     level.setOptionsForCompilationLevel(options);\n \n     if (flags.debug) {\n       level.setDebugOptionsForCompilationLevel(options);\n     }\n \n-    if (flags.use_types_for_optimization) {\n+    if (flags.useTypesForOptimization) {\n       level.setTypeBasedOptimizationOptions(options);\n     }\n \n-    if (flags.generate_exports) {\n-      options.setGenerateExports(flags.generate_exports);\n-    }\n-\n-    WarningLevel wLevel = flags.warning_level;\n+    if (flags.generateExports) {\n+      options.setGenerateExports(flags.generateExports);\n+    }\n+\n+    WarningLevel wLevel = flags.warningLevel;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n \n-    options.closurePass = flags.process_closure_primitives;\n-\n-    options.jqueryPass = flags.process_jquery_primitives &&\n+    options.closurePass = flags.processClosurePrimitives;\n+\n+    options.jqueryPass = flags.processJqueryPrimitives &&\n         CompilationLevel.ADVANCED_OPTIMIZATIONS == level;\n \n-    options.angularPass = flags.angular_pass;\n+    options.angularPass = flags.angularPass;\n \n     if (!flags.translationsFile.isEmpty()) {\n       try {\n   protected List<SourceFile> createExterns() throws FlagUsageException,\n       IOException {\n     List<SourceFile> externs = super.createExterns();\n-    if (flags.use_only_custom_externs || isInTestMode()) {\n+    if (flags.useOnlyCustomExterns || isInTestMode()) {\n       return externs;\n     } else {\n       List<SourceFile> defaultExterns = getDefaultExterns();\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n import com.google.javascript.jscomp.deps.JsFileParser;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n+\n import java.io.IOException;\n import java.util.Collection;\n import java.util.Collections;\n \n   // Info about where the file lives.\n   private JSModule module;\n-  final private InputId id;\n+  private final InputId id;\n \n   // The AST.\n   private final SourceAst ast;\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   @SuppressWarnings(\"unused\")\n   private boolean manageClosureDependencies = false;\n \n-  // A common enum for compiler passes that can run either globally or locally.\n+  /**\n+   * A common enum for compiler passes that can run either globally or locally.\n+   */\n   public enum Reach {\n     ALL,\n     LOCAL_ONLY,\n     this.cssRenamingWhitelist = whitelist;\n   }\n \n-  public void setReplaceStringsFunctionDescriptions(List<String> replaceStringsFunctionDescriptions) {\n-    this.replaceStringsFunctionDescriptions = replaceStringsFunctionDescriptions;\n-  }\n-\n-  public void setReplaceStringsPlaceholderToken(String replaceStringsPlaceholderToken) {\n-    this.replaceStringsPlaceholderToken = replaceStringsPlaceholderToken;\n-  }\n-\n-  public void setReplaceStringsReservedStrings(Set<String> replaceStringsReservedStrings) {\n-    this.replaceStringsReservedStrings = replaceStringsReservedStrings;\n+  public void setReplaceStringsFunctionDescriptions(\n+      List<String> replaceStringsFunctionDescriptions) {\n+    this.replaceStringsFunctionDescriptions =\n+        replaceStringsFunctionDescriptions;\n+  }\n+\n+  public void setReplaceStringsPlaceholderToken(\n+      String replaceStringsPlaceholderToken) {\n+    this.replaceStringsPlaceholderToken =\n+        replaceStringsPlaceholderToken;\n+  }\n+\n+  public void setReplaceStringsReservedStrings(\n+      Set<String> replaceStringsReservedStrings) {\n+    this.replaceStringsReservedStrings =\n+        replaceStringsReservedStrings;\n   }\n \n   public void setReplaceStringsInputMap(VariableMap serializedMap) {\n     this.sourceMapFormat = sourceMapFormat;\n   }\n \n-  public void setSourceMapLocationMappings(List<SourceMap.LocationMapping> sourceMapLocationMappings) {\n+  public void setSourceMapLocationMappings(\n+      List<SourceMap.LocationMapping> sourceMapLocationMappings) {\n     this.sourceMapLocationMappings = sourceMapLocationMappings;\n   }\n \n     EVERY_PASS\n   }\n \n+  /** How much tracing we want to do */\n   public static enum TracerMode {\n     ALL,  // Collect all timing and size metrics.\n     RAW_SIZE, // Collect all timing and size metrics, except gzipped size.\n     }\n   }\n \n+  /** Option for the ProcessTweaks pass */\n   public static enum TweakProcessing {\n     OFF,  // Do not run the ProcessTweaks pass.\n     CHECK, // Run the pass, but do not strip out the calls.\n--- a/src/com/google/javascript/jscomp/ComposeWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/ComposeWarningsGuard.java\n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.javascript.jscomp.CheckLevel;\n \n import java.io.Serializable;\n import java.util.*;\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n       this.emptyList = emptyList;\n     }\n \n-    abstract protected C filter(ConcreteType type);\n+    protected abstract C filter(ConcreteType type);\n   }\n \n   /** Returns all function types in this set. */\n--- a/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n+++ b/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.ArrayDeque;\n import java.util.Deque;\n import java.util.List;\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n \n import java.util.ArrayDeque;\n import java.util.Deque;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n-import java.util.HashMap;\n import java.util.Map;\n import java.util.logging.Logger;\n \n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n import com.google.javascript.jscomp.AnalyzePrototypeProperties.Symbol;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.io.Serializable;\n import java.util.Collection;\n import java.util.Iterator;\n--- a/src/com/google/javascript/jscomp/CssRenamingMap.java\n+++ b/src/com/google/javascript/jscomp/CssRenamingMap.java\n  * Interface used by {@link ReplaceCssNames} to substitute CSS class names.\n  */\n public interface CssRenamingMap {\n+\n+  /** Kind of renaming map */\n   public static enum Style {\n     BY_WHOLE,\n     BY_PART,\n \n   Style getStyle();\n \n-  public static abstract class ByPart implements CssRenamingMap {\n+  /** ByPart renaming map */\n+  public abstract static class ByPart implements CssRenamingMap {\n     @Override\n-    abstract public String get(String value);\n+    public abstract String get(String value);\n \n     @Override\n     public Style getStyle() {\n     }\n   }\n \n-  public static abstract class ByWhole implements CssRenamingMap {\n+  /** ByWhole renaming map */\n+  public abstract static class ByWhole implements CssRenamingMap {\n     @Override\n-    abstract public String get(String value);\n+    public abstract String get(String value);\n \n     @Override\n     public Style getStyle() {\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n         if (parent.isExprResult()) {\n           parent.replaceChild(n,\n               IR.voidNode(IR.number(0).srcref(n)));\n-        } else if(n.isComma() && n != parent.getLastChild()) {\n+        } else if (n.isComma() && n != parent.getLastChild()) {\n           parent.removeChild(n);\n         } else if (parent.isFor() && !NodeUtil.isForIn(parent) &&\n             NodeUtil.getConditionExpression(parent) != n) {\n           break;\n \n         default:\n-          for(Node sibling = n.getNext(); sibling != null;\n-              sibling = sibling.getNext()) {\n+          for (Node sibling = n.getNext(); sibling != null;\n+               sibling = sibling.getNext()) {\n             state = isVariableReadBeforeKill(sibling, variable);\n             if (state != VariableLiveness.MAYBE_LIVE) {\n               break;\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n   }\n \n \n-  static abstract class Definition {\n+  abstract static class Definition {\n \n     private final boolean isExtern;\n \n--- a/src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java\n  */\n \n package com.google.javascript.jscomp;\n-\n-import com.google.javascript.jscomp.CheckLevel;\n-\n \n /**\n  * Sets the level for a particular DiagnosticGroup.\n--- a/src/com/google/javascript/jscomp/DiagnosticType.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticType.java\n  * limitations under the License.\n  */\n package com.google.javascript.jscomp;\n-\n-import com.google.javascript.jscomp.CheckLevel;\n \n import java.io.Serializable;\n import java.text.MessageFormat;\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n             JSType jsType = (JSType) type;\n             if (jsType.isAllType() || jsType.isUnknownType()) {\n               if (n.getFirstChild().isThis()) {\n-                suggestion = \"The \\\"this\\\" object is unknown in the function,\"+\n+                suggestion = \"The \\\"this\\\" object is unknown in the function,\" +\n                     \"consider using @this\";\n               } else {\n                 String qName = n.getFirstChild().getQualifiedName();\n   /** Returns a map from field name to types for which it will be renamed. */\n   Multimap<String, Collection<T>> getRenamedTypesForTesting() {\n     Multimap<String, Collection<T>> ret = HashMultimap.create();\n-    for (Map.Entry<String, Property> entry: properties.entrySet()) {\n+    for (Map.Entry<String, Property> entry : properties.entrySet()) {\n       Property prop = entry.getValue();\n       if (!prop.skipRenaming) {\n         for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) {\n             }\n \n             // If this interface invalidated this property, return now.\n-            if (p.skipRenaming) return;\n+            if (p.skipRenaming) {\n+              return;\n+            }\n           }\n           if (constructor.isInterface() || constructor.isConstructor()) {\n             constructor = constructor.getSuperClassConstructor();\n--- a/src/com/google/javascript/jscomp/DotFormatter.java\n+++ b/src/com/google/javascript/jscomp/DotFormatter.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n-import com.google.javascript.jscomp.graph.GraphvizGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.jscomp.graph.GraphvizGraph;\n import com.google.javascript.jscomp.graph.GraphvizGraph.GraphvizEdge;\n import com.google.javascript.jscomp.graph.GraphvizGraph.GraphvizNode;\n import com.google.javascript.rhino.Node;\n--- a/src/com/google/javascript/jscomp/ErrorHandler.java\n+++ b/src/com/google/javascript/jscomp/ErrorHandler.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.CheckLevel;\n-\n /**\n  * The error handler is any generic sink for warnings and errors,\n  * after they've passed through any filtering {@code WarningsGuard}s.\n--- a/src/com/google/javascript/jscomp/ErrorManager.java\n+++ b/src/com/google/javascript/jscomp/ErrorManager.java\n  */\n \n package com.google.javascript.jscomp;\n-\n-import com.google.javascript.jscomp.CheckLevel;\n \n /**\n  * The error manager is in charge of storing, organizing and displaying\n--- a/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n+++ b/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n   private void maybeReplaceJqueryPrototypeAlias(Node n) {\n     // Check to see if this is the assignment of the original alias.\n     // If so, leave it intact.\n-    if(NodeUtil.isLValue(n)) {\n+    if (NodeUtil.isLValue(n)) {\n       Node maybeAssign = n.getParent();\n       while (!NodeUtil.isStatement(maybeAssign) && !maybeAssign.isAssign()) {\n         maybeAssign = maybeAssign.getParent();\n       Node propValue = currentProp.removeFirstChild();\n \n       Node newProp;\n-      if(currentProp.isQuotedString()) {\n+      if (currentProp.isQuotedString()) {\n         newProp = IR.getelem(objectToExtend.cloneTree(),\n             currentProp).srcref(currentProp);\n       } else {\n       n.putBooleanProp(Node.FREE_CALL, false);\n \n       // remove any other pre-existing call arguments\n-      while(newCallTarget.getNext() != null) {\n+      while (newCallTarget.getNext() != null) {\n         n.removeChildAfter(newCallTarget);\n       }\n       n.addChildToBack(IR.thisNode().srcref(n));\n     if (!objectToLoopOver.isObjectLit() &&\n         !(objectToLoopOver.isArrayLit() &&\n         isArrayLitValidForExpansion(objectToLoopOver))) {\n-      t.report(n, JQUERY_UNABLE_TO_EXPAND_INVALID_LIT_ERROR, (String)null);\n+      t.report(n, JQUERY_UNABLE_TO_EXPAND_INVALID_LIT_ERROR, (String) null);\n       return;\n     }\n \n             keyNodeReferences, valueNodeReferences,\n             objectToLoopOver.isArrayLit()));\n \n-    if(keyNodeReferences.size() == 0) {\n+    if (keyNodeReferences.size() == 0) {\n      // We didn't do anything useful ...\n-      t.report(n, JQUERY_USELESS_EACH_EXPANSION, (String)null);\n+      t.report(n, JQUERY_USELESS_EACH_EXPANSION, (String) null);\n       return;\n     }\n \n         replaceOriginalJqueryEachCall(n, fncBlock);\n     } else {\n       // We didn't do anything useful ...\n-      t.report(n, JQUERY_USELESS_EACH_EXPANSION, (String)null);\n+      t.report(n, JQUERY_USELESS_EACH_EXPANSION, (String) null);\n     }\n   }\n \n \n     // Expand the jQuery.expandedEach call\n     Node key = objectToLoopOver.getFirstChild(), val = null;\n-    for(int i = 0; key != null; key = key.getNext(), i++) {\n+    for (int i = 0; key != null; key = key.getNext(), i++) {\n       if (key != null) {\n         if (objectToLoopOver.isArrayLit()) {\n           // Arrays have a value of their index number\n       n.putBooleanProp(Node.FREE_CALL, true);\n \n       // remove any other pre-existing call arguments\n-      while(fnc.getNext() != null) {\n+      while (fnc.getNext() != null) {\n         n.removeChildAfter(fnc);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.regex.Pattern;\n \n /**\n     Node exportCallTarget = NodeUtil.newQualifiedNameNode(\n         compiler.getCodingConvention(),\n         exportSymbolFunction, node, testFunctionName);\n-    Node call = IR.call( exportCallTarget);\n+    Node call = IR.call(exportCallTarget);\n     if (exportCallTarget.isName()) {\n       call.putBooleanProp(Node.FREE_CALL, true);\n     }\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n       for (Node child = exportedObjectLit.getFirstChild();\n            child != null;\n            child = child.getNext()) {\n-        // TODO: handle getters or setters?\n+        // TODO(user): handle getters or setters?\n         if (child.isStringKey()) {\n           lit.addChildToBack(\n               IR.propdef(\n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.LinkedList;\n import java.util.List;\n \n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n       // NOTE 2: The aliasing overhead is currently an under-estimate,\n       // as some parameters are aliased because of the parameters used.\n       // Perhaps we should just assume all parameters will be aliased?\n-      final int INLINE_BLOCK_OVERHEAD = 4; // \"X:{}\"\n-      final int PER_RETURN_OVERHEAD = 2;   // \"return\" --> \"break X\"\n-      final int PER_RETURN_RESULT_OVERHEAD = 3; // \"XX=\"\n-      final int PER_ALIAS_OVERHEAD = 3; // \"XX=\"\n+      final int inlineBlockOverhead = 4; // \"X:{}\"\n+      final int perReturnOverhead = 2;   // \"return\" --> \"break X\"\n+      final int perReturnResultOverhead = 3; // \"XX=\"\n+      final int perAliasOverhead = 3; // \"XX=\"\n \n       // TODO(johnlenz): Counting the number of returns is relatively expensive\n       //   this information should be determined during the traversal and\n       int returnCount = NodeUtil.getNodeTypeReferenceCount(\n           block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n       int resultCount = (returnCount > 0) ? returnCount - 1 : 0;\n-      int baseOverhead = (returnCount > 0) ? INLINE_BLOCK_OVERHEAD : 0;\n+      int baseOverhead = (returnCount > 0) ? inlineBlockOverhead : 0;\n \n       int overhead = baseOverhead\n-          + returnCount * PER_RETURN_OVERHEAD\n-          + resultCount * PER_RETURN_RESULT_OVERHEAD\n-          + aliasCount * PER_ALIAS_OVERHEAD;\n+          + returnCount * perReturnOverhead\n+          + resultCount * perReturnResultOverhead\n+          + aliasCount * perAliasOverhead;\n \n       return (overhead - costDeltaFunctionOverhead);\n     }\n--- a/src/com/google/javascript/jscomp/FunctionNames.java\n+++ b/src/com/google/javascript/jscomp/FunctionNames.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n+\n import java.io.Serializable;\n import java.util.*;\n \n--- a/src/com/google/javascript/jscomp/GatherRawExports.java\n+++ b/src/com/google/javascript/jscomp/GatherRawExports.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Set;\n \n /**\n--- a/src/com/google/javascript/jscomp/GenerateExports.java\n+++ b/src/com/google/javascript/jscomp/GenerateExports.java\n import com.google.javascript.jscomp.FindExportableNodes.GenerateNodeContext;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Map;\n \n /**\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n           if (parent != null && parent.isObjectLit()) {\n             name = getNameForObjLitKey(n);\n           }\n-          if (name == null) return;\n+          if (name == null) {\n+            return;\n+          }\n           isSet = true;\n           switch (n.getType()) {\n             case Token.STRING_KEY:\n                 return;\n               case Token.FUNCTION:\n                 Node gramps = parent.getParent();\n-                if (gramps == null ||\n-                    NodeUtil.isFunctionExpression(parent)) return;\n+                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n+                  return;\n+                }\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n             }\n           }\n           name = n.getQualifiedName();\n-          if (name == null) return;\n+          if (name == null) {\n+            return;\n+          }\n           break;\n         default:\n           return;\n           // The same line of reasoning used for the OR case applies here.\n           Node second = n.getFirstChild().getNext();\n           Name.Type t = getValueType(second);\n-          if (t != Name.Type.OTHER) return t;\n+          if (t != Name.Type.OTHER) {\n+            return t;\n+          }\n           Node third = second.getNext();\n           return getValueType(third);\n       }\n      */\n     void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                              boolean isPropAssign, Name.Type type) {\n-      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n+      if (maybeHandlePrototypePrefix(t, n, parent, name)) {\n+        return;\n+      }\n \n       Name nameObj = getOrCreateName(name);\n       nameObj.type = type;\n      */\n     void handleSetFromLocal(NodeTraversal t, Node n, Node parent,\n                             String name) {\n-      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n+      if (maybeHandlePrototypePrefix(t, n, parent, name)) {\n+        return;\n+      }\n \n       Name nameObj = getOrCreateName(name);\n       Ref set = new Ref(t, n, nameObj,\n      * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n      */\n     void handleGet(NodeTraversal t, Node n, Node parent, String name) {\n-      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n+      if (maybeHandlePrototypePrefix(t, n, parent, name)) {\n+        return;\n+      }\n \n       Ref.Type type = Ref.Type.DIRECT_GET;\n       if (parent != null) {\n--- a/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n+++ b/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n+\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n--- a/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n+++ b/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n     String projectScopedMeaning =\n         (projectId != null ? (projectId + \": \") : \"\") + meaning;\n     return String.valueOf(\n-        MessageId.GenerateId(tcValue, projectScopedMeaning));\n+        MessageId.generateId(tcValue, projectScopedMeaning));\n   }\n \n \n         hi ^= 0x130f9bef;\n         lo ^= 0x94a0a928;\n       }\n-      return (((long) hi) << 32) | (lo & 0xffffffffl);\n+      return (((long) hi) << 32) | (lo & 0xffffffffL);\n     }\n \n     /**\n       }\n \n       c += limit - start;\n-      switch (limit - i) { // deal with rest. Cases fall through\n-        case 11:\n-          c += (str[i + 10] & 0xff) << 24;\n-        case 10:\n-          c += (str[i + 9] & 0xff) << 16;\n-        case 9:\n-          c += (str[i + 8] & 0xff) << 8;\n-          // the first byte of c is reserved for the length\n-        case 8:\n-          b += (str[i + 7] & 0xff) << 24;\n-        case 7:\n-          b += (str[i + 6] & 0xff) << 16;\n-        case 6:\n-          b += (str[i + 5] & 0xff) << 8;\n-        case 5:\n-          b += (str[i + 4] & 0xff);\n-        case 4:\n-          a += (str[i + 3] & 0xff) << 24;\n-        case 3:\n-          a += (str[i + 2] & 0xff) << 16;\n-        case 2:\n-          a += (str[i + 1] & 0xff) << 8;\n-        case 1:\n-          a += (str[i + 0] & 0xff);\n-          // case 0 : nothing left to add\n+      int tmp = limit - i;\n+      if (tmp == 11) {\n+        c += (str[i + 10] & 0xff) << 24;\n+      }\n+      if (tmp >= 10) {\n+        c += (str[i + 9] & 0xff) << 16;\n+      }\n+      if (tmp >= 9) {\n+        c += (str[i + 8] & 0xff) << 8;\n+        // the first byte of c is reserved for the length\n+      }\n+      if (tmp >= 8) {\n+        b += (str[i + 7] & 0xff) << 24;\n+      }\n+      if (tmp >= 7) {\n+        b += (str[i + 6] & 0xff) << 16;\n+      }\n+      if (tmp >= 6) {\n+        b += (str[i + 5] & 0xff) << 8;\n+      }\n+      if (tmp >= 5) {\n+        b += (str[i + 4] & 0xff);\n+      }\n+      if (tmp >= 4) {\n+        a += (str[i + 3] & 0xff) << 24;\n+      }\n+      if (tmp >= 3) {\n+        a += (str[i + 2] & 0xff) << 16;\n+      }\n+      if (tmp >= 2) {\n+        a += (str[i + 1] & 0xff) << 8;\n+      }\n+      if (tmp >= 1) {\n+        a += (str[i + 0] & 0xff);\n+        // case 0 : nothing left to add\n       }\n \n       // Mix\n    * Forked from the i18n library.\n    */\n   private static class MessageId {\n-    private final static long GenerateId(String message, String meaning) {\n+    private static final long generateId(String message, String meaning) {\n       long fp = FP.fingerprint(message);\n       if (null != meaning && meaning.length() > 0) {\n         // combine the fingerprints of message and meaning\n--- a/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Iterator;\n import java.util.Set;\n \n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.Set;\n-\n-\n \n /**\n  * Inlines functions that are divided into two types: \"direct call node\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n import java.util.Map;\n import java.util.Set;\n \n-\n /**\n  * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n  * identify variables that are only ever assigned to object literals\n         // Make sure that the value is not self-referential. IOW,\n         // disallow things like x = {b: x.a}.\n         //\n-        // TODO: Only exclude unorderable self-referential\n+        // TODO(user): Only exclude unorderable self-referential\n         // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n         // but x = {a: 1, b: x.a} is.\n         //\n \n       for (Reference ref : referenceInfo.references) {\n         // The init/decl have already been converted.\n-        if (defined && ref == init) continue;\n+        if (defined && ref == init) {\n+          continue;\n+        }\n \n         if (ref.isLvalue()) {\n           // Assignments have to be handled specially, since they\n--- a/src/com/google/javascript/jscomp/InlineProperties.java\n+++ b/src/com/google/javascript/jscomp/InlineProperties.java\n \n import java.util.Map;\n import java.util.Set;\n-\n \n /**\n  * InlineProperties attempts to find references to properties that are known to\n--- a/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n+++ b/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Collection;\n import java.util.List;\n import java.util.logging.Logger;\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n \n /**\n  * Using the infrastructure provided by VariableReferencePass, identify\n--- a/src/com/google/javascript/jscomp/InstrumentFunctions.java\n+++ b/src/com/google/javascript/jscomp/InstrumentFunctions.java\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n \n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Comparator;\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeSet;\n-\n-import org.json.JSONArray;\n-import org.json.JSONException;\n-import org.json.JSONObject;\n \n /**\n  * A {@link JSModule} dependency graph that assigns a depth to each module and\n     return d1 < d2 ? -1 : d2 == d1 ? m1.getName().compareTo(m2.getName()) : 1;\n   }\n \n-  /*\n+  /**\n    * Exception class for declaring when the modules being fed into a\n    * JSModuleGraph as input aren't in dependence order, and so can't be\n    * processed for caching of various dependency-related queries.\n    */\n-\n   protected static class ModuleDependenceException\n       extends IllegalArgumentException {\n     private static final long serialVersionUID = 1;\n     }\n   }\n \n+  /** Another exception class */\n   public static class MissingModuleException extends Exception {\n     MissingModuleException(String moduleName) {\n       super(moduleName);\n--- a/src/com/google/javascript/jscomp/JoinOp.java\n+++ b/src/com/google/javascript/jscomp/JoinOp.java\n    * An implementation of {@code JoinOp} that makes it easy to join to\n    * lattice elements at a time.\n    */\n-  static abstract class BinaryJoinOp<L extends LatticeElement>\n+  abstract static class BinaryJoinOp<L extends LatticeElement>\n       implements JoinOp<L> {\n     @Override\n     public final L apply(List<L> values) {\n--- a/src/com/google/javascript/jscomp/JqueryCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/JqueryCodingConvention.java\n \n package com.google.javascript.jscomp;\n \n-import java.util.Set;\n-\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.Node;\n+\n+import java.util.Set;\n \n /**\n  * This describes the jQuery specific JavaScript coding conventions.\n     return \"window\";\n   }\n \n-  private final static Set<String> propertyTestFunctions = ImmutableSet.of(\n+  private static final Set<String> propertyTestFunctions = ImmutableSet.of(\n       \"jQuery.isPlainObject\", \"jQuery.isFunction\", \"jQuery.isNumeric\",\n       \"jQuery.isEmptyObject\");\n \n         call.getFirstChild().getQualifiedName());\n   }\n \n-  private final static Set<String> prototypeAliases = ImmutableSet.of(\n+  private static final Set<String> prototypeAliases = ImmutableSet.of(\n       \"jQuery.fn\", \"jQuerySub.fn\");\n \n   @Override\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-\n import com.google.javascript.jscomp.parsing.ParserRunner;\n-\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n+\n import java.io.IOException;\n-\n import java.util.logging.Logger;\n \n /**\n--- a/src/com/google/javascript/jscomp/JsMessage.java\n+++ b/src/com/google/javascript/jscomp/JsMessage.java\n \n   @Override\n   public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof JsMessage)) return false;\n-\n+    if (o == this) {\n+      return true;\n+    }\n+    if (!(o instanceof JsMessage)) {\n+      return false;\n+    }\n     JsMessage m = (JsMessage) o;\n     return id.equals(m.id) &&\n            key.equals(m.key) &&\n    * <p>The original code for the hash function is courtesy\n    * <a href=\"http://burtleburtle.net/bob/hash/evahash.html\">Bob Jenkins</a>.\n    *\n-   * <p>TODO: Add stream hashing functionality.\n-   */\n-  final static class Hash {\n+   * <p>TODO(anatol): Add stream hashing functionality.\n+   */\n+  static final class Hash {\n     private Hash() {}\n \n     /** Default hash seed (64 bit) */\n       }\n \n       c += length;\n-      switch (keylen) { // deal with rest. Cases fall through\n-        case 23:\n+      if (keylen >= 16) {\n+        if (keylen == 23) {\n           c += ((long) value[offset + 22]) << 56;\n-        case 22:\n+        }\n+        if (keylen >= 22) {\n           c += (value[offset + 21] & 0xffL) << 48;\n-        case 21:\n+        }\n+        if (keylen >= 21) {\n           c += (value[offset + 20] & 0xffL) << 40;\n-        case 20:\n+        }\n+        if (keylen >= 20) {\n           c += (value[offset + 19] & 0xffL) << 32;\n-        case 19:\n+        }\n+        if (keylen >= 19) {\n           c += (value[offset + 18] & 0xffL) << 24;\n-        case 18:\n+        }\n+        if (keylen >= 18) {\n           c += (value[offset + 17] & 0xffL) << 16;\n-        case 17:\n+        }\n+        if (keylen >= 17) {\n           c += (value[offset + 16] & 0xffL) << 8;\n           // the first byte of c is reserved for the length\n-        case 16:\n+        }\n+        if (keylen >= 16) {\n           b += word64At(value, offset + 8);\n           a += word64At(value, offset);\n-          break;\n-        case 15:\n+        }\n+      } else if (keylen >= 8) {\n+        if (keylen == 15) {\n           b += (value[offset + 14] & 0xffL) << 48;\n-        case 14:\n+        }\n+        if (keylen >= 14) {\n           b += (value[offset + 13] & 0xffL) << 40;\n-        case 13:\n+        }\n+        if (keylen >= 13) {\n           b += (value[offset + 12] & 0xffL) << 32;\n-        case 12:\n+        }\n+        if (keylen >= 12) {\n           b += (value[offset + 11] & 0xffL) << 24;\n-        case 11:\n+        }\n+        if (keylen >= 11) {\n           b += (value[offset + 10] & 0xffL) << 16;\n-        case 10:\n+        }\n+        if (keylen >= 10) {\n           b += (value[offset + 9] & 0xffL) << 8;\n-        case 9:\n+        }\n+        if (keylen >= 9) {\n           b += (value[offset + 8] & 0xffL);\n-        case 8:\n+        }\n+        if (keylen >= 8) {\n           a += word64At(value, offset);\n-          break;\n-        case 7:\n+        }\n+      } else {\n+        if (keylen == 7) {\n           a += (value[offset + 6] & 0xffL) << 48;\n-        case 6:\n+        }\n+        if (keylen >= 6) {\n           a += (value[offset + 5] & 0xffL) << 40;\n-        case 5:\n+        }\n+        if (keylen >= 5) {\n           a += (value[offset + 4] & 0xffL) << 32;\n-        case 4:\n+        }\n+        if (keylen >= 4) {\n           a += (value[offset + 3] & 0xffL) << 24;\n-        case 3:\n+        }\n+        if (keylen >= 3) {\n           a += (value[offset + 2] & 0xffL) << 16;\n-        case 2:\n+        }\n+        if (keylen >= 2) {\n           a += (value[offset + 1] & 0xffL) << 8;\n-        case 1:\n+        }\n+        if (keylen >= 1) {\n           a += (value[offset + 0] & 0xffL);\n           // case 0: nothing left to add\n+        }\n       }\n       return mix64(a, b, c);\n     }\n     }\n   }\n \n+  /** ID generator */\n   public interface IdGenerator {\n     /**\n      * Generate the ID for the message. Messages with the same messageParts\n--- a/src/com/google/javascript/jscomp/JsMessageExtractor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageExtractor.java\n import java.io.IOException;\n import java.util.Collection;\n import java.util.List;\n-\n \n /**\n  * Extracts messages and message comments from JS code.\n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n   static final DiagnosticType MESSAGE_HAS_NO_TEXT =\n       DiagnosticType.warning(\"JSC_MSG_HAS_NO_TEXT\",\n           \"Message value of {0} is just an empty string. \"\n-              + \"Empty messages are forbidden.\" );\n+              + \"Empty messages are forbidden.\");\n \n   static final DiagnosticType MESSAGE_TREE_MALFORMED =\n       DiagnosticType.error(\"JSC_MSG_TREE_MALFORMED\",\n           // Check that all placeholders from the message text have appropriate\n           // object literal keys\n           for (String phName : builder.getPlaceholders()) {\n-            if(!phNames.contains(phName)) {\n+            if (!phNames.contains(phName)) {\n               throw new MalformedException(\n                   \"Unrecognized message placeholder referenced: \" + phName,\n                   returnNode);\n     // values\n     Set<String> usedPlaceholders = builder.getPlaceholders();\n     for (String phName : usedPlaceholders) {\n-      if(!phNames.contains(phName)) {\n+      if (!phNames.contains(phName)) {\n         throw new MalformedException(\n             \"Unrecognized message placeholder referenced: \" + phName,\n             objLitNode);\n     // Check that objLiteral have only names that are present in the\n     // message text\n     for (String phName : phNames) {\n-      if(!usedPlaceholders.contains(phName)) {\n+      if (!usedPlaceholders.contains(phName)) {\n         throw new MalformedException(\n             \"Unused message placeholder: \" + phName,\n             objLitNode);\n       throws MalformedException {\n     String value = extractStringFromStringExprNode(node);\n \n-    while(true) {\n+    while (true) {\n       int phBegin = value.indexOf(PH_JS_PREFIX);\n       if (phBegin < 0) {\n         // Just a string literal\n--- a/src/com/google/javascript/jscomp/JvmMetrics.java\n+++ b/src/com/google/javascript/jscomp/JvmMetrics.java\n  */\n class JvmMetrics {\n \n-  private static int TABULAR_COLON_POS = 40;\n-  private static long ONE_KILO_BYTE = 1L << 10L;\n-  private static long ONE_MEGA_BYTE = 1L << 20L;\n-  private static long ONE_GIGA_BYTE = 1L << 30L;\n+  private static final int TABULAR_COLON_POS = 40;\n+  private static final long ONE_KILO_BYTE = 1L << 10L;\n+  private static final long ONE_MEGA_BYTE = 1L << 20L;\n+  private static final long ONE_GIGA_BYTE = 1L << 30L;\n \n   public static void maybeWriteJvmMetrics(PrintStream out, String options) {\n     if (options == null) {\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Strings;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.SourceExcerptProvider.ExcerptFormatter;\n import com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt;\n \n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n    */\n   void markAllParametersEscaped() {\n     Node lp = jsScope.getRootNode().getFirstChild().getNext();\n-    for(Node arg = lp.getFirstChild(); arg != null; arg = arg.getNext()) {\n+    for (Node arg = lp.getFirstChild(); arg != null; arg = arg.getNext()) {\n       escaped.add(jsScope.getVar(arg.getString()));\n     }\n   }\n \n   private boolean isArgumentsName(Node n) {\n-    if (!n.isName()||\n+    if (!n.isName() ||\n         !n.getString().equals(ARGUMENT_ARRAY_ALIAS) ||\n         jsScope.isDeclared(ARGUMENT_ARRAY_ALIAS, false)) {\n       return false;\n--- a/src/com/google/javascript/jscomp/LoggerErrorManager.java\n+++ b/src/com/google/javascript/jscomp/LoggerErrorManager.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.CheckLevel;\n-\n+import java.util.logging.Level;\n import java.util.logging.Logger;\n-import java.util.logging.Level;\n \n /**\n  * An error manager that logs errors and warnings using a logger in addition to\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n     private final Map<String, String> declarations = Maps.newHashMap();\n     private final boolean global;\n \n-    final static String UNIQUE_ID_SEPARATOR = \"$$\";\n+    static final String UNIQUE_ID_SEPARATOR = \"$$\";\n \n     ContextualRenamer() {\n       this.global = true;\n--- a/src/com/google/javascript/jscomp/MoveFunctionDeclarations.java\n+++ b/src/com/google/javascript/jscomp/MoveFunctionDeclarations.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n+\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n \n     public MustDef(Iterator<Var> vars) {\n       this();\n-      while(vars.hasNext()) {\n+      while (vars.hasNext()) {\n         Var var = vars.next();\n         // Every variable in the scope is defined once in the beginning of the\n         // function: all the declared variables are undefined, all functions\n    * @param node The CFG node where the definition should be record to.\n    *     {@code null} if this is a conditional define.\n    */\n-  private void addToDefIfLocal( String name, @Nullable Node node,\n+  private void addToDefIfLocal(String name, @Nullable Node node,\n       @Nullable Node rValue, MustDef def) {\n     Var var = jsScope.getVar(name);\n \n     }\n \n     // Also, assume we no longer know anything that depends on a parameter.\n-    for (Entry<Var, Definition> pair: output.reachingDef.entrySet()) {\n+    for (Entry<Var, Definition> pair : output.reachingDef.entrySet()) {\n       Definition value = pair.getValue();\n       if (value == null) {\n         continue;\n--- a/src/com/google/javascript/jscomp/NameGenerator.java\n+++ b/src/com/google/javascript/jscomp/NameGenerator.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.rhino.TokenStream;\n-import javax.annotation.Nullable;\n import com.google.common.collect.Sets;\n import com.google.common.primitives.Chars;\n+import com.google.javascript.rhino.TokenStream;\n \n import java.util.*;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * A simple class for generating unique JavaScript variable/property names.\n--- a/src/com/google/javascript/jscomp/NameReferenceGraph.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraph.java\n \n   // If we have a call site that we absolutely have no idea what variable it\n   // it calls or reference, we'd point it to UNKNOWN.\n-  final Name UNKNOWN;\n+  final Name unknown;\n \n   // Represents the \"main\" global block as well as externs.\n-  final Name MAIN;\n+  final Name main;\n \n   // The implicit \"window\" object.\n-  final Name WINDOW;\n+  final Name window;\n \n   final AbstractCompiler compiler;\n \n     this.compiler = compiler;\n \n     // Initialize builtins.\n-    UNKNOWN = new Name(\"{UNKNOWN}\", true);\n-    UNKNOWN.isAliased = true;\n-    UNKNOWN.type = compiler.getTypeRegistry().getNativeType(\n+    unknown = new Name(\"{UNKNOWN}\", true);\n+    unknown.isAliased = true;\n+    unknown.type = compiler.getTypeRegistry().getNativeType(\n         JSTypeNative.NO_TYPE);\n-    this.createNode(UNKNOWN);\n-\n-    MAIN = new Name(\"{Global Main}\", true);\n-    this.createNode(MAIN);\n-\n-    WINDOW = new Name(\"window\", true);\n-    this.createNode(WINDOW);\n+    this.createNode(unknown);\n+\n+    main = new Name(\"{Global Main}\", true);\n+    this.createNode(main);\n+\n+    window = new Name(\"window\", true);\n+    this.createNode(window);\n   }\n \n   public Name defineNameIfNotExists(String name, boolean isExtern) {\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n \n     private Traversal(boolean isExtern) {\n       this.isExtern = isExtern;\n-      pushContainingFunction(graph.MAIN);\n+      pushContainingFunction(graph.main);\n     }\n \n     @Override\n           // When the name is null, we have a function that is presumably not\n           // reference-able again and should not be modeled in the name graph.\n           // A common example would be (function() { ... })();\n-          pushContainingFunction(graph.UNKNOWN);\n+          pushContainingFunction(graph.unknown);\n           return;\n         }\n \n \n     private Name recordStaticNameDefinition(String name, JSType type,\n         Node n, Node rValue) {\n-      if (getNamedContainingFunction() != graph.MAIN) {\n+      if (getNamedContainingFunction() != graph.main) {\n         // TODO(user): if A.B() defines A.C(), there is a dependence from\n         // A.C() -> A.B(). However, this is not important in module code motion\n         // and will be ignored (for now).\n     int pos;\n     for (pos = currentFunctionStack.size() - 1; pos >= 0; pos = pos - 1) {\n       Name cf = currentFunctionStack.get(pos);\n-      if (cf != graph.UNKNOWN) {\n+      if (cf != graph.unknown) {\n         containingFn = cf;\n         break;\n       }\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n import java.util.List;\n import java.util.Set;\n \n-\n /**\n  * NodeTraversal allows an iteration through the nodes in the parse tree,\n  * and facilitates the optimizations on the parse tree.\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-\n-\n \n /**\n  * Rewrites <code>new goog.testing.ObjectPropertyString(foo, 'bar')</code> to\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Deque;\n import java.util.List;\n \n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n         continueLooking = buildParameterList(parameters, cur, site.scope);\n         firstCall = false;\n       } else {\n-        continueLooking= findFixedParameters(parameters, cur);\n+        continueLooking = findFixedParameters(parameters, cur);\n       }\n       if (!continueLooking) {\n         return;\n       index++;\n     }\n \n-    for (;index < parameters.size(); index++) {\n+    for (; index < parameters.size(); index++) {\n       parameters.get(index).setShouldRemove(false);\n     }\n \n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Collection;\n import java.util.List;\n \n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n    * Clients that only want to analyze code (like IDEs) and not emit\n    * code will only run checks and not optimizations.\n    */\n-  abstract protected List<PassFactory> getChecks();\n+  protected abstract List<PassFactory> getChecks();\n \n   /**\n    * Gets the optimization passes to run.\n    * Optimization passes revolve around producing smaller and faster code.\n    * They should always run after checking passes.\n    */\n-  abstract protected List<PassFactory> getOptimizations();\n+  protected abstract List<PassFactory> getOptimizations();\n \n   /**\n    * Gets a graph of the passes run. For debugging.\n   /**\n    * Insert the given pass factory before the factory of the given name.\n    */\n-  final static void addPassFactoryBefore(\n+  static final void addPassFactoryBefore(\n       List<PassFactory> factoryList, PassFactory factory, String passName) {\n     factoryList.add(\n         findPassIndexByName(factoryList, passName), factory);\n   /**\n    * Find a pass factory with the same name as the given one, and replace it.\n    */\n-  final static void replacePassFactory(\n+  static final void replacePassFactory(\n       List<PassFactory> factoryList, PassFactory factory) {\n     factoryList.set(\n         findPassIndexByName(factoryList, factory.getName()), factory);\n--- a/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.Node;\n \n /**\n  * A pass that looks for assignments to properties of an object or array\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n         (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType))\n         || n.isAdd());\n \n-    Preconditions.checkState(\n-        !n.isAdd()|| !NodeUtil.mayBeString(n));\n+    Preconditions.checkState(!n.isAdd() || !NodeUtil.mayBeString(n));\n \n     // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n     // other values are converted to numbers elsewhere.\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.List;\n import java.util.Locale;\n \n \n   @Override\n   Node optimizeSubtree(Node subtree) {\n-    if (subtree.isCall() ){\n+    if (subtree.isCall()){\n       return tryFoldKnownMethods(subtree);\n     }\n     return subtree;\n         return n;\n       } else {\n         double tmpRadix = secondArg.getDouble();\n-        if (tmpRadix != (int)tmpRadix)\n+        if (tmpRadix != (int) tmpRadix) {\n           return n;\n-        radix = (int)tmpRadix;\n+        }\n+        radix = (int) tmpRadix;\n         if (radix < 0 || radix == 1 || radix > 36) {\n           return n;\n         }\n         double newVal = Double.parseDouble(stringVal);\n         newNode = IR.number(newVal);\n         normalizedNewVal = normalizeNumericString(String.valueOf(newVal));\n-      }\n-      catch(NumberFormatException e) {\n+      } catch (NumberFormatException e) {\n         return n;\n       }\n       // Make sure that the parsed number matches the original string\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n \n   private final boolean late;\n \n-  private final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n+  private static final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n \n   static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n     DiagnosticType.warning(\n     // Find the enclosing control structure, if any, that a \"break\" would exit\n     // from.\n     Node breakTarget = n;\n-    for (;!ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n+    for (; !ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n         breakTarget = breakTarget.getParent()) {\n       if (breakTarget.isFunction() || breakTarget.isScript()) {\n         // No break target.\n                 // If an expression has higher precedence than && or ||,\n                 // but lower precedence than NOT, an additional () is needed\n                 // Thus we do not preceed\n-                int op_precedence = NodeUtil.precedence(first.getType());\n+                int opPrecedence = NodeUtil.precedence(first.getType());\n                 if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n-                    && isHigherPrecedence(leftParent, op_precedence))\n+                    && isHigherPrecedence(leftParent, opPrecedence))\n                     || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n-                    && isHigherPrecedence(rightParent, op_precedence))) {\n+                    && isHigherPrecedence(rightParent, opPrecedence))) {\n                   return n;\n                 }\n               }\n   }\n \n   private Node tryMinimizeStringArrayLiteral(Node n) {\n-    if(!late) {\n+    if (!late) {\n       return n;\n     }\n \n \n     String[] delimiters = new String[]{\" \", \";\", \",\", \"{\", \"}\", null};\n     int i = 0;\n-    NEXT_DELIMITER: for (;delimiters[i] != null; i++) {\n+    NEXT_DELIMITER: for (; delimiters[i] != null; i++) {\n       for (String cur : strings) {\n         if (cur.contains(delimiters[i])) {\n           continue NEXT_DELIMITER;\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n         && !n.isLabel()\n         && !n.isSwitch()) {\n       for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-        if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n-            !c.isBlock()) {\n+        if (NodeUtil.isControlStructureCodeBlock(n, c) && !c.isBlock()) {\n           Node newBlock = IR.block().srcref(n);\n           n.replaceChild(c, newBlock);\n           if (!c.isEmpty()) {\n--- a/src/com/google/javascript/jscomp/PrintStreamErrorManager.java\n+++ b/src/com/google/javascript/jscomp/PrintStreamErrorManager.java\n  */\n \n package com.google.javascript.jscomp;\n-\n-import com.google.javascript.jscomp.CheckLevel;\n \n import java.io.PrintStream;\n \n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n         // To speed things up, only consider cases where len(b) <= 10\n         List<String> errors = Lists.newArrayList();\n         for (Map.Entry<String, String> b : cssNames.entrySet()) {\n-          if (b.getKey().length() > 10) continue;\n+          if (b.getKey().length() > 10) {\n+            continue;\n+          }\n           for (Map.Entry<String, String> a : cssNames.entrySet()) {\n             String combined = cssNames.get(a.getKey() + \"-\" + b.getKey());\n             if (combined != null &&\n                 !combined.equals(a.getValue() + \"-\" + b.getValue())) {\n-              errors.add(\"map(\" + a.getKey() + \"-\" + b.getKey() +\") != map(\" +\n-                         a.getKey() + \")-map(\" + b.getKey() +\")\");\n+              errors.add(\"map(\" + a.getKey() + \"-\" + b.getKey() + \") != map(\" +\n+                         a.getKey() + \")-map(\" + b.getKey() + \")\");\n             }\n           }\n         }\n         name);\n \n     // Offsets to add to source. Named for documentation purposes.\n-    final int FOR_QUOTE = 1;\n-    final int FOR_DOT = 1;\n+    final int forQuote = 1;\n+    final int forDot = 1;\n \n     Node current = null;\n     for (current = syntheticRef;\n       int fullLen = current.getQualifiedName().length();\n       int namespaceLen = current.getFirstChild().getQualifiedName().length();\n \n-      current.setSourceEncodedPosition(n.getSourcePosition() + FOR_QUOTE);\n+      current.setSourceEncodedPosition(n.getSourcePosition() + forQuote);\n       current.setLength(fullLen);\n \n       current.getLastChild().setSourceEncodedPosition(\n-          n.getSourcePosition() + namespaceLen + FOR_QUOTE + FOR_DOT);\n+          n.getSourcePosition() + namespaceLen + forQuote + forDot);\n       current.getLastChild().setLength(\n           current.getLastChild().getString().length());\n     }\n \n-    current.setSourceEncodedPosition(n.getSourcePosition() + FOR_QUOTE);\n+    current.setSourceEncodedPosition(n.getSourcePosition() + forQuote);\n     current.setLength(current.getString().length());\n \n     maybeAddToSymbolTable(syntheticRef);\n--- a/src/com/google/javascript/jscomp/ProcessTweaks.java\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n     NodeTraversal.traverse(compiler, root, pass);\n \n     Map<String, TweakInfo> tweakInfos = pass.allTweaks;\n-    for (TweakInfo tweakInfo: tweakInfos.values()) {\n+    for (TweakInfo tweakInfo : tweakInfos.values()) {\n       tweakInfo.emitAllWarnings();\n     }\n     return new CollectTweaksResult(tweakInfos, pass.getOverridesCalls);\n   }\n \n-  private final static class CollectTweaksResult {\n+  private static final class CollectTweaksResult {\n     final Map<String, TweakInfo> tweakInfos;\n     final List<TweakFunctionCall> getOverridesCalls;\n \n--- a/src/com/google/javascript/jscomp/RecordFunctionInformation.java\n+++ b/src/com/google/javascript/jscomp/RecordFunctionInformation.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Comparator;\n import java.util.TreeSet;\n \n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n     void afterExitScope(NodeTraversal t, ReferenceMap referenceMap);\n   }\n \n-  static Behavior DO_NOTHING_BEHAVIOR = new Behavior() {\n+  static final Behavior DO_NOTHING_BEHAVIOR = new Behavior() {\n     @Override\n     public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {}\n   };\n      */\n     private boolean isInitializingAssignmentAt(int index) {\n       if (index < references.size() && index > 0) {\n-        Reference maybeDecl = references.get(index-1);\n+        Reference maybeDecl = references.get(index - 1);\n         if (maybeDecl.isVarDeclaration()) {\n           Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n           Reference maybeInit = references.get(index);\n--- a/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n         } else if (parent.isInc() || parent.isDec()) {\n           parent.getParent().replaceChild(parent, IR.number(0));\n         } else {\n-          throw new IllegalStateException(\"unexpected: \"+ parent);\n+          throw new IllegalStateException(\"unexpected: \" + parent);\n         }\n         compiler.reportCodeChange();\n       }\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n       if (param != null) {\n         // Take care of the following siblings first.\n         boolean hasFollowing = markUnreferencedFunctionArgs(\n-            scope, function, referenced, param.getNext(), paramIndex+1,\n+            scope, function, referenced, param.getNext(), paramIndex + 1,\n             canChangeSignature);\n \n         Var var = scope.getVar(param.getString());\n       } else {\n         // Anything past the last formal parameter can be removed from the call\n         // sites.\n-        tryRemoveAllFollowingArgs(function, paramIndex-1);\n+        tryRemoveAllFollowingArgs(function, paramIndex - 1);\n         return false;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/RenameLabels.java\n+++ b/src/com/google/javascript/jscomp/RenameLabels.java\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n-\n \n /**\n  * RenameLabels renames all the labels so that they have short names, to reduce\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n       int affinityScore = 0;\n       for (Iterator<UndiGraphEdge<Property, PropertyAffinity>> edgeIterator =\n           node.getNeighborEdgesIterator(); edgeIterator.hasNext();) {\n-        UndiGraphEdge<Property,PropertyAffinity> edge = edgeIterator.next();\n+        UndiGraphEdge<Property, PropertyAffinity> edge = edgeIterator.next();\n         affinityScore += edge.getValue().affinity +\n             (node == edge.getNodeA() ?\n                 edge.getNodeB().getValue().numOccurrences :\n         for (Property p1 : currentHighAffinityProperties) {\n           for (Property p2 : currentHighAffinityProperties) {\n             if (p1.oldName.compareTo(p2.oldName) < 0) {\n-              GraphEdge<Property,PropertyAffinity> edge =\n+              GraphEdge<Property, PropertyAffinity> edge =\n                   affinityGraph.getFirstEdge(p1, p2);\n               if (edge == null) {\n                 affinityGraph.connect(p1, new PropertyAffinity(1), p2);\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n+\n import java.util.ArrayList;\n import java.util.Comparator;\n import java.util.HashMap;\n \n     @Override\n     public void enterScope(NodeTraversal t) {\n-      if (t.inGlobalScope()) return;\n-\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n       Iterator<Var> it = t.getScope().getVars();\n       while (it.hasNext()) {\n         Var current = it.next();\n   private void recordPseudoName(Node n) {\n     // Variable names should be in a different name space than\n     // property pseudo names.\n-    pseudoNameMap.put(n, '$' + n.getString() + \"$$\" );\n+    pseudoNameMap.put(n, '$' + n.getString() + \"$$\");\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ReplaceMessagesForChrome.java\n+++ b/src/com/google/javascript/jscomp/ReplaceMessagesForChrome.java\n \n import java.util.Collections;\n import java.util.List;\n-\n \n /**\n  * Replaces user-visible messages with appropriate calls to\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n           \"JSC_BAD_REPLACEMENT_CONFIGURATION\",\n           \"Bad replacement configuration.\");\n \n-  private final String DEFAULT_PLACEHOLDER_TOKEN = \"`\";\n+  private static final String DEFAULT_PLACEHOLDER_TOKEN = \"`\";\n   private final String placeholderToken;\n   private static final String REPLACE_ONE_MARKER = \"?\";\n   private static final String REPLACE_ALL_MARKER = \"*\";\n \n   private void initMapping(\n       VariableMap previousVarMap, Set<String> reservedNames) {\n-    Map<String,String> previous = previousVarMap.getOriginalNameToNewNameMap();\n-    for (Map.Entry<String,String> entry : previous.entrySet()) {\n+    Map<String, String> previous = previousVarMap.getOriginalNameToNewNameMap();\n+    for (Map.Entry<String, String> entry : previous.entrySet()) {\n       String key = entry.getKey();\n       if (!reservedNames.contains(key)) {\n         String value = entry.getValue();\n     Preconditions.checkState(first != -1 && last != -1);\n \n     String name = function.substring(0, first);\n-    String params = function.substring(first+1, last);\n+    String params = function.substring(first + 1, last);\n \n     int paramCount = 0;\n     int replacementParameter = -1;\n--- a/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n+++ b/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.ImmutableMap;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.SimpleErrorReporter;\n \n \n   private RhinoErrorReporter(AbstractCompiler compiler) {\n     this.compiler = compiler;\n-    typeMap = ImmutableMap.<Pattern,DiagnosticType>builder()\n+    typeMap = ImmutableMap.<Pattern, DiagnosticType>builder()\n         // Trailing comma\n         .put(replacePlaceHolders(\n             com.google.javascript.rhino.head.ScriptRuntime.getMessage0(\n--- a/src/com/google/javascript/jscomp/ShadowVariables.java\n+++ b/src/com/google/javascript/jscomp/ShadowVariables.java\n       for (Node n : references) {\n         n.setString(toShadow.oldName);\n         Node cur = n;\n-        while(cur != s.getRootNode()) {\n+        while (cur != s.getRootNode()) {\n           cur = cur.getParent();\n           if (cur.isFunction()) {\n             scopeUpRefMap.put(cur, toShadow.oldName);\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n--- a/src/com/google/javascript/jscomp/SpecializeModule.java\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n         if (NodeUtil.isForIn(last)) {\n           fuseExpresssonIntoSecondChild(commaTree, last);\n         }\n-        return ;\n+        return;\n       default:\n         throw new IllegalStateException(\"Statement fusion missing.\");\n     }\n     // tree comparison.\n     if (exp2.isComma()) {\n       Node leftMostChild = exp2;\n-      while(leftMostChild.isComma()) {\n+      while (leftMostChild.isComma()) {\n         leftMostChild = leftMostChild.getFirstChild();\n       }\n       Node parent = leftMostChild.getParent();\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n \n package com.google.javascript.jscomp;\n \n-import javax.annotation.Nullable;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Token;\n \n import java.util.Set;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * A pass for stripping a list of provided JavaScript object types.\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n    * undefined.\n    */\n   public Ordering<Symbol> getNaturalSymbolOrdering() {\n-    return SYMBOL_ORDERING;\n+    return symbolOrdering;\n   }\n \n   @Override\n    * \"function%0\", \"function%1\", etc.\n    */\n   public void addAnonymousFunctions() {\n-    TreeSet<SymbolScope> scopes = Sets.newTreeSet(LEXICAL_SCOPE_ORDERING);\n+    TreeSet<SymbolScope> scopes = Sets.newTreeSet(lexicalScopeOrdering);\n     for (SymbolScope scope : getAllScopes()) {\n       if (scope.isLexicalScope()) {\n         scopes.add(scope);\n     return myScope;\n   }\n \n+  /** A symbol-table entry */\n   public static final class Symbol extends SimpleSlot {\n     // Use a linked hash map, so that the results are deterministic\n     // (and so the declaration always comes first).\n     }\n   }\n \n+  /** Reference */\n   public static final class Reference extends SimpleReference<Symbol> {\n     Reference(Symbol symbol, Node node) {\n       super(symbol, node);\n     }\n   }\n \n+  /** Scope of a symbol */\n   public static final class SymbolScope implements StaticScope<JSType> {\n     private final Node rootNode;\n     private final SymbolScope parent;\n   }\n \n   // Comparators\n-  private final Ordering<String> SOURCE_NAME_ORDERING =\n+  private final Ordering<String> sourceNameOrdering =\n       Ordering.natural().nullsFirst();\n \n-  private final Ordering<Node> NODE_ORDERING = new Ordering<Node>() {\n+  private final Ordering<Node> nodeOrdering = new Ordering<Node>() {\n     @Override\n     public int compare(Node a, Node b) {\n-      int result = SOURCE_NAME_ORDERING.compare(\n+      int result = sourceNameOrdering.compare(\n           a.getSourceFileName(), b.getSourceFileName());\n       if (result != 0) {\n         return result;\n     }\n   };\n \n-  private final Ordering<SymbolScope> LEXICAL_SCOPE_ORDERING =\n+  private final Ordering<SymbolScope> lexicalScopeOrdering =\n       new Ordering<SymbolScope>() {\n     @Override\n     public int compare(SymbolScope a, SymbolScope b) {\n       Preconditions.checkState(a.isLexicalScope() && b.isLexicalScope(),\n                                \"We can only sort lexical scopes\");\n-      return NODE_ORDERING.compare(a.getRootNode(), b.getRootNode());\n+      return nodeOrdering.compare(a.getRootNode(), b.getRootNode());\n     }\n   };\n \n-  private final Ordering<Symbol> SYMBOL_ORDERING = new Ordering<Symbol>() {\n+  private final Ordering<Symbol> symbolOrdering = new Ordering<Symbol>() {\n     @Override\n     public int compare(Symbol a, Symbol b) {\n       SymbolScope scopeA = getScope(a);\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-\n \n /**\n  * <p>The syntactic scope creator scans the parse tree to create a Scope object\n--- a/src/com/google/javascript/jscomp/SyntheticAst.java\n+++ b/src/com/google/javascript/jscomp/SyntheticAst.java\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n-\n \n /**\n  * An AST generated totally by the compiler.\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n               scope = getTopScope();\n             }\n \n-            if (scope == null) break;\n+            if (scope == null) {\n+              break;\n+            }\n \n             ConcreteType type = inferConcreteType(getTopScope(), n);\n             if (type.isNone() || type.isAll()) {\n--- a/src/com/google/javascript/jscomp/Tracer.java\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n   private long[] extraTracingValues;\n \n   /** The type for grouping traces, may be null */\n-  private final @Nullable String type;\n+  @Nullable private final String type;\n \n   /** A comment string for the report */\n   private final String comment;\n    * @param v The value to convert.\n    * @param digits_column_width The desired with of the string.\n    */\n-  private static String longToPaddedString(long v, int digits_column_width) {\n-    int digit_width = numDigits(v);\n+  private static String longToPaddedString(long v, int digitsColumnWidth) {\n+    int digitWidth = numDigits(v);\n     StringBuilder sb = new StringBuilder();\n-    appendSpaces(sb, digits_column_width - digit_width);\n+    appendSpaces(sb, digitsColumnWidth - digitWidth);\n     sb.append(v);\n     return sb.toString();\n   }\n    * that the current ThreadTrace silence_threshold should be used.\n    * @return The time that this trace actually ran\n    */\n-  long stop(int silence_threshold) {\n+  long stop(int silenceThreshold) {\n     Preconditions.checkState(Thread.currentThread() == startThread);\n \n     ThreadTrace trace = getThreadTrace();\n       return 0;\n     }\n \n-    trace.endEvent(this, silence_threshold);\n+    trace.endEvent(this, silenceThreshold);\n     return stopTimeMs - startTimeMs;\n   }\n \n-  /** Stop the trace using the default silence_threshold\n+  /** Stop the trace using the default silenceThreshold\n    *\n    * @return  The time that this trace actually ran.\n    */\n     events.init();\n   }\n \n-  static void initCurrentThreadTrace(int default_silence_threshold) {\n+  static void initCurrentThreadTrace(int defaultSilenceThreshold) {\n     initCurrentThreadTrace();\n-    setDefaultSilenceThreshold(default_silence_threshold);\n+    setDefaultSilenceThreshold(defaultSilenceThreshold);\n   }\n \n   /**\n   /**\n    * This map tracks counts of tracers for each type over all time.\n    */\n-  private static @Nullable AtomicTracerStatMap typeToCountMap;\n+  @Nullable private static AtomicTracerStatMap typeToCountMap;\n \n   /**\n    * This map tracks counts of silent tracers for each type over all time.\n    */\n-  private static @Nullable AtomicTracerStatMap typeToSilentMap;\n+  @Nullable private static AtomicTracerStatMap typeToSilentMap;\n \n   /**\n    * This map tracks time (ms) for each type over all time.\n    */\n-  private static @Nullable AtomicTracerStatMap typeToTimeMap;\n+  @Nullable private static AtomicTracerStatMap typeToTimeMap;\n \n   /**\n    * This method MUST be called before getTypeToCountMap (and friends)\n    * map must be synchronized on the map.  If enableTypeMaps has not\n    * been called, this will return null.\n    */\n-  static @Nullable Map<String, Long> getTypeToCountMap() {\n+  @Nullable static Map<String, Long> getTypeToCountMap() {\n     return typeToCountMap != null ? typeToCountMap.getMap() : null;\n   }\n \n    * map must be synchronized on the map.  If enableTypeMaps has not\n    * been called, this will return null.\n    */\n-  static @Nullable Map<String, Long> getTypeToSilentMap() {\n+  @Nullable static Map<String, Long> getTypeToSilentMap() {\n     return typeToSilentMap != null ? typeToSilentMap.getMap() : null;\n   }\n \n    * map must be synchronized on the map.  If enableTypeMaps has not\n    * been called, this will return null.\n    */\n-  static @Nullable Map<String, Long> getTypeToTimeMap() {\n+  @Nullable static Map<String, Long> getTypeToTimeMap() {\n     return typeToTimeMap != null ? typeToTimeMap.getMap() : null;\n   }\n \n      */\n     private int getMaxDigits() {\n       long etime = -1;\n-      long max_time = 0;\n+      long maxTime = 0;\n       for (Event e : events) {\n         if (etime != -1) {\n           long time = e.eventTime() - etime;\n-          max_time = Math.max(max_time, time);\n+          maxTime = Math.max(maxTime, time);\n         }\n         if (!e.isStart) {\n           long time = e.tracer.stopTimeMs - e.tracer.startTimeMs;\n-          max_time = Math.max(max_time, time);\n+          maxTime = Math.max(maxTime, time);\n         }\n         etime = e.eventTime();\n       }\n       // Minimum is 3 to preserve an indent even when max is small.\n-      return Math.max(3, numDigits(max_time));\n+      return Math.max(3, numDigits(maxTime));\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java\n+++ b/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java\n  */\n package com.google.javascript.jscomp;\n \n-import java.util.Iterator;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Iterators;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n+\n+import java.util.Iterator;\n \n /**\n  * Rewrites an AMD module https://github.com/amdjs/amdjs-api/wiki/AMD to a\n class TransformAMDToCJSModule implements CompilerPass {\n \n   @VisibleForTesting\n-  final static DiagnosticType UNSUPPORTED_DEFINE_SIGNATURE_ERROR =\n+  static final DiagnosticType UNSUPPORTED_DEFINE_SIGNATURE_ERROR =\n       DiagnosticType.error(\n           \"UNSUPPORTED_DEFINE_SIGNATURE\",\n           \"Only define(function() ...), define(OBJECT_LITERAL) and define(\"\n               + \"['dep', 'dep1'], function(d0, d2, [exports, module]) ...) forms \"\n               + \"are currently supported.\");\n-  final static DiagnosticType NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR =\n+  static final DiagnosticType NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR =\n       DiagnosticType.error(\n             \"NON_TOP_LEVEL_STATEMENT_DEFINE\",\n             \"The define function must be called as a top-level statement.\");\n-  final static DiagnosticType REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING =\n+  static final DiagnosticType REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING =\n     DiagnosticType.warning(\n           \"REQUIREJS_PLUGINS_NOT_SUPPORTED\",\n           \"Plugins in define requirements are not supported: {0}\");\n \n-  final static String VAR_RENAME_SUFFIX = \"__alias\";\n+  static final String VAR_RENAME_SUFFIX = \"__alias\";\n \n \n   private final AbstractCompiler compiler;\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       ensureTyped(t, n);\n     }\n \n-    // TODO: Add something to check for calls of RegExp objects, which is not\n-    // supported by IE.  Either say something about the return type or warn\n-    // about the non-portability of the call or both.\n+    // TODO(nicksantos): Add something to check for calls of RegExp objects,\n+    // which is not supported by IE. Either say something about the return type\n+    // or warn about the non-portability of the call or both.\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n+\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ModificationVisitor;\n import com.google.javascript.rhino.jstype.ObjectType;\n-import com.google.javascript.rhino.jstype.TemplateTypeMap;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.TemplateType;\n+import com.google.javascript.rhino.jstype.TemplateTypeMap;\n import com.google.javascript.rhino.jstype.UnionType;\n \n import java.util.Collections;\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n+\n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n         member.getFirstChild().setJSType(thisType);\n \n-        // TODO: We are evaluating these values in the wrong scope:\n+        // TODO(johnlenz): We are evaluating these values in the wrong scope:\n         // https://code.google.com/p/closure-compiler/issues/detail?id=926\n         JSType thisObjectType = thisType.toObjectType();\n         if (thisObjectType != null) {\n      * @param parent The parent of n\n      */\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n == scope.getRootNode()) return;\n-\n+      if (n == scope.getRootNode()) {\n+        return;\n+      }\n       if (n.isParamList() && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n--- a/src/com/google/javascript/jscomp/UseSite.java\n+++ b/src/com/google/javascript/jscomp/UseSite.java\n \n   @Override\n   public boolean equals(Object o) {\n-    return (o instanceof UseSite && ((UseSite)(o)).node.equals(this.node));\n+    return (o instanceof UseSite && ((UseSite) o).node.equals(this.node));\n   }\n }\n--- a/src/com/google/javascript/jscomp/VariableMap.java\n+++ b/src/com/google/javascript/jscomp/VariableMap.java\n \n   private static int findIndexOfChar(String value, char stopChar) {\n     int len = value.length();\n-    for (int i=0; i<len; i++) {\n+    for (int i = 0; i < len; i++) {\n       char c = value.charAt(i);\n       if (c == '\\\\' && ++i < len) {\n         c = value.charAt(i);\n   private static String unescape(CharSequence value) {\n     StringBuilder sb = new StringBuilder();\n     int len = value.length();\n-    for (int i=0; i<len; i++) {\n+    for (int i = 0; i < len; i++) {\n       char c = value.charAt(i);\n       if (c == '\\\\' && ++i < len) {\n         c = value.charAt(i);\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n--- a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n+\n import java.util.Map;\n \n /**\n--- a/src/com/google/javascript/jscomp/VerboseMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/VerboseMessageFormatter.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Strings;\n-\n-import com.google.javascript.jscomp.CheckLevel;\n \n /**\n  * Verbose message formatter. This formatter generates very loud and long\n--- a/src/com/google/javascript/jscomp/WarningLevel.java\n+++ b/src/com/google/javascript/jscomp/WarningLevel.java\n  */\n \n package com.google.javascript.jscomp;\n-\n-import com.google.javascript.jscomp.CheckLevel;\n-import com.google.javascript.jscomp.CompilerOptions;\n \n /**\n  * Convert the warnings level to an Options object.\n--- a/src/com/google/javascript/jscomp/WarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/WarningsGuard.java\n  * limitations under the License.\n  */\n package com.google.javascript.jscomp;\n-\n-import com.google.javascript.jscomp.CheckLevel;\n \n import java.io.Serializable;\n \n  */\n public abstract class WarningsGuard implements Serializable {\n \n+  /** Priority */\n   public static enum Priority {\n     MAX(1),\n     MIN(100),\n--- a/src/com/google/javascript/jscomp/WhitelistWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/WhitelistWarningsGuard.java\n import com.google.common.io.CharStreams;\n import com.google.common.io.Files;\n import com.google.common.io.InputSupplier;\n-import com.google.javascript.jscomp.CheckLevel;\n \n import java.io.File;\n import java.io.IOException;\n     return warning;\n   }\n \n+  /** Whitelist builder */\n   public static class WhitelistBuilder implements ErrorHandler {\n     private final Set<JSError> warnings = Sets.newLinkedHashSet();\n     private String productName = null;\n         out.append(\"# When you fix any of these warnings, run \"\n             + generatorTarget + \" task.\\n\");\n       }\n-      \n+\n       if (headerNote != null) {\n         out.append(\"#\"\n             + Joiner.on(\"\\n# \").join(Splitter.on(\"\\n\").split(headerNote))\n--- a/src/com/google/javascript/jscomp/XtbMessageBundle.java\n+++ b/src/com/google/javascript/jscomp/XtbMessageBundle.java\n     factory.setFeature(\n         \"http://xml.org/sax/features/external-general-entities\", false);\n     factory.setFeature(\n-        \"http://xml.org/sax/features/external-parameter-entities\",false);\n+        \"http://xml.org/sax/features/external-parameter-entities\", false);\n     factory.setFeature(\n         \"http://apache.org/xml/features/nonvalidating/load-external-dtd\",\n         false);", "timestamp": 1363798128, "metainfo": ""}