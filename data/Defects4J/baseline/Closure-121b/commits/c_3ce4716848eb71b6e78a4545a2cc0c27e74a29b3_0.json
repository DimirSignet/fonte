{"sha": "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3", "log": "Tweak to allow chained initialization: new Node(Token.EXPR_RESULT, a).copyInformationFrom(a); (John) R=alan DELTA=10  (6 added, 0 deleted, 4 changed)   Teach PureFunctionnIdentifier about (f || g)() calls (antonio) Fixes issue 116 R=john DELTA=105  (84 added, 0 deleted, 21 changed)  Fix decomposition issue  Anonymous function declaration can not be side-effected and are side-effect free. (John) R=alan DELTA=115  (101 added, 8 deleted, 6 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n+++ b/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n     public static final int ID_FIELD_NUMBER = 2;\n     private boolean hasId;\n     private int id_ = 0;\n-    public boolean hasId() { return hasId; }\n-    public int getId() { return id_; }\n+    public boolean hasId() {\n+      return hasId;\n+    }\n+    public int getId() {\n+      return id_;\n+    }\n     \n     // required string source_name = 3;\n     public static final int SOURCE_NAME_FIELD_NUMBER = 3;\n     private boolean hasSourceName;\n     private java.lang.String sourceName_ = \"\";\n-    public boolean hasSourceName() { return hasSourceName; }\n-    public java.lang.String getSourceName() { return sourceName_; }\n+    public boolean hasSourceName() {\n+      return hasSourceName;\n+    }\n+    public java.lang.String getSourceName() {\n+      return sourceName_;\n+    }\n     \n     // required int32 line_number = 4;\n     public static final int LINE_NUMBER_FIELD_NUMBER = 4;\n     private boolean hasLineNumber;\n     private int lineNumber_ = 0;\n-    public boolean hasLineNumber() { return hasLineNumber; }\n-    public int getLineNumber() { return lineNumber_; }\n+    public boolean hasLineNumber() {\n+      return hasLineNumber;\n+    }\n+    public int getLineNumber() {\n+      return lineNumber_;\n+    }\n     \n     // required string module_name = 5;\n     public static final int MODULE_NAME_FIELD_NUMBER = 5;\n     private boolean hasModuleName;\n     private java.lang.String moduleName_ = \"\";\n-    public boolean hasModuleName() { return hasModuleName; }\n-    public java.lang.String getModuleName() { return moduleName_; }\n+    public boolean hasModuleName() {\n+      return hasModuleName;\n+    }\n+    public java.lang.String getModuleName() {\n+      return moduleName_;\n+    }\n     \n     // required int32 size = 6;\n     public static final int SIZE_FIELD_NUMBER = 6;\n     private boolean hasSize;\n     private int size_ = 0;\n-    public boolean hasSize() { return hasSize; }\n-    public int getSize() { return size_; }\n+    public boolean hasSize() {\n+      return hasSize;\n+    }\n+    public int getSize() {\n+      return size_;\n+    }\n     \n     // required string name = 7;\n     public static final int NAME_FIELD_NUMBER = 7;\n     private boolean hasName;\n     private java.lang.String name_ = \"\";\n-    public boolean hasName() { return hasName; }\n-    public java.lang.String getName() { return name_; }\n+    public boolean hasName() {\n+      return hasName;\n+    }\n+    public java.lang.String getName() {\n+      return name_;\n+    }\n     \n     // required string compiled_source = 8;\n     public static final int COMPILED_SOURCE_FIELD_NUMBER = 8;\n     private boolean hasCompiledSource;\n     private java.lang.String compiledSource_ = \"\";\n-    public boolean hasCompiledSource() { return hasCompiledSource; }\n-    public java.lang.String getCompiledSource() { return compiledSource_; }\n+    public boolean hasCompiledSource() {\n+      return hasCompiledSource;\n+    }\n+    public java.lang.String getCompiledSource() {\n+      return compiledSource_;\n+    }\n     \n     private void initFields() {\n     }\n     public static final int NAME_FIELD_NUMBER = 102;\n     private boolean hasName;\n     private java.lang.String name_ = \"\";\n-    public boolean hasName() { return hasName; }\n-    public java.lang.String getName() { return name_; }\n+    public boolean hasName() {\n+      return hasName;\n+    }\n+    public java.lang.String getName() {\n+      return name_;\n+    }\n     \n     // required string compiled_source = 103;\n     public static final int COMPILED_SOURCE_FIELD_NUMBER = 103;\n     private boolean hasCompiledSource;\n     private java.lang.String compiledSource_ = \"\";\n-    public boolean hasCompiledSource() { return hasCompiledSource; }\n-    public java.lang.String getCompiledSource() { return compiledSource_; }\n+    public boolean hasCompiledSource() {\n+      return hasCompiledSource;\n+    }\n+    public java.lang.String getCompiledSource() {\n+      return compiledSource_;\n+    }\n     \n     private void initFields() {\n     }\n   public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> getEntryList() {\n     return entry_;\n   }\n-  public int getEntryCount() { return entry_.size(); }\n+  public int getEntryCount() {\n+    return entry_.size();\n+  }\n   public com.google.javascript.jscomp.FunctionInformationMap.Entry getEntry(int index) {\n     return entry_.get(index);\n   }\n   public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> getModuleList() {\n     return module_;\n   }\n-  public int getModuleCount() { return module_.size(); }\n+  public int getModuleCount() {\n+    return module_.size();\n+  }\n   public com.google.javascript.jscomp.FunctionInformationMap.Module getModule(int index) {\n     return module_.get(index);\n   }\n     public com.google.javascript.jscomp.FunctionInformationMap.Entry getEntry(int index) {\n       return result.getEntry(index);\n     }\n-    public Builder setEntry(int index, com.google.javascript.jscomp.FunctionInformationMap.Entry value) {\n+    public Builder setEntry(\n+        int index, com.google.javascript.jscomp.FunctionInformationMap.Entry value) {\n       if (value == null) {\n         throw new NullPointerException();\n       }\n       result.entry_.set(index, value);\n       return this;\n     }\n-    public Builder setEntry(int index, com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n+    public Builder setEntry(\n+        int index, com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n       result.entry_.set(index, builderForValue.build());\n       return this;\n     }\n       result.entry_.add(value);\n       return this;\n     }\n-    public Builder addEntry(com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n+    public Builder addEntry(\n+        com.google.javascript.jscomp.FunctionInformationMap.Entry.Builder builderForValue) {\n       if (result.entry_.isEmpty()) {\n         result.entry_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Entry>();\n       }\n     public com.google.javascript.jscomp.FunctionInformationMap.Module getModule(int index) {\n       return result.getModule(index);\n     }\n-    public Builder setModule(int index, com.google.javascript.jscomp.FunctionInformationMap.Module value) {\n+    public Builder setModule(\n+        int index, com.google.javascript.jscomp.FunctionInformationMap.Module value) {\n       if (value == null) {\n         throw new NullPointerException();\n       }\n       result.module_.set(index, value);\n       return this;\n     }\n-    public Builder setModule(int index, com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n+    public Builder setModule(\n+        int index, com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n       result.module_.set(index, builderForValue.build());\n       return this;\n     }\n       result.module_.add(value);\n       return this;\n     }\n-    public Builder addModule(com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n+    public Builder addModule(\n+        com.google.javascript.jscomp.FunctionInformationMap.Module.Builder builderForValue) {\n       if (result.module_.isEmpty()) {\n         result.module_ = new java.util.ArrayList<com.google.javascript.jscomp.FunctionInformationMap.Module>();\n       }\n--- a/gen/com/google/javascript/jscomp/Instrumentation.java\n+++ b/gen/com/google/javascript/jscomp/Instrumentation.java\n   public static final int REPORT_DEFINED_FIELD_NUMBER = 1;\n   private boolean hasReportDefined;\n   private java.lang.String reportDefined_ = \"\";\n-  public boolean hasReportDefined() { return hasReportDefined; }\n-  public java.lang.String getReportDefined() { return reportDefined_; }\n+  public boolean hasReportDefined() {\n+    return hasReportDefined;\n+  }\n+  public java.lang.String getReportDefined() {\n+    return reportDefined_;\n+  }\n   \n   // optional string report_call = 2;\n   public static final int REPORT_CALL_FIELD_NUMBER = 2;\n   private boolean hasReportCall;\n   private java.lang.String reportCall_ = \"\";\n-  public boolean hasReportCall() { return hasReportCall; }\n-  public java.lang.String getReportCall() { return reportCall_; }\n+  public boolean hasReportCall() {\n+    return hasReportCall;\n+  }\n+  public java.lang.String getReportCall() {\n+    return reportCall_;\n+  }\n   \n   // optional string report_exit = 6;\n   public static final int REPORT_EXIT_FIELD_NUMBER = 6;\n   private boolean hasReportExit;\n   private java.lang.String reportExit_ = \"\";\n-  public boolean hasReportExit() { return hasReportExit; }\n-  public java.lang.String getReportExit() { return reportExit_; }\n+  public boolean hasReportExit() {\n+    return hasReportExit;\n+  }\n+  public java.lang.String getReportExit() {\n+    return reportExit_;\n+  }\n   \n   // repeated string declaration_to_remove = 3;\n   public static final int DECLARATION_TO_REMOVE_FIELD_NUMBER = 3;\n   private java.util.List<java.lang.String> declarationToRemove_ =\n     java.util.Collections.emptyList();\n-  public java.util.List<java.lang.String> getDeclarationToRemoveList() {\n+  public java.util.List<java.lang.String>\n+      getDeclarationToRemoveList() {\n     return declarationToRemove_;\n   }\n-  public int getDeclarationToRemoveCount() { return declarationToRemove_.size(); }\n+  public int getDeclarationToRemoveCount() {\n+    return declarationToRemove_.size();\n+  }\n   public java.lang.String getDeclarationToRemove(int index) {\n     return declarationToRemove_.get(index);\n   }\n   public static final int INIT_FIELD_NUMBER = 4;\n   private java.util.List<java.lang.String> init_ =\n     java.util.Collections.emptyList();\n-  public java.util.List<java.lang.String> getInitList() {\n+  public java.util.List<java.lang.String>\n+      getInitList() {\n     return init_;\n   }\n-  public int getInitCount() { return init_.size(); }\n+  public int getInitCount() {\n+    return init_.size();\n+  }\n   public java.lang.String getInit(int index) {\n     return init_.get(index);\n   }\n   public static final int APP_NAME_SETTER_FIELD_NUMBER = 5;\n   private boolean hasAppNameSetter;\n   private java.lang.String appNameSetter_ = \"\";\n-  public boolean hasAppNameSetter() { return hasAppNameSetter; }\n-  public java.lang.String getAppNameSetter() { return appNameSetter_; }\n+  public boolean hasAppNameSetter() {\n+    return hasAppNameSetter;\n+  }\n+  public java.lang.String getAppNameSetter() {\n+    return appNameSetter_;\n+  }\n   \n   private void initFields() {\n   }\n     }\n     \n     // repeated string declaration_to_remove = 3;\n-    public java.util.List<java.lang.String> getDeclarationToRemoveList() {\n+    public java.util.List<java.lang.String>\n+        getDeclarationToRemoveList() {\n       return java.util.Collections.unmodifiableList(result.declarationToRemove_);\n     }\n     public int getDeclarationToRemoveCount() {\n     public java.lang.String getDeclarationToRemove(int index) {\n       return result.getDeclarationToRemove(index);\n     }\n-    public Builder setDeclarationToRemove(int index, java.lang.String value) {\n+    public Builder setDeclarationToRemove(\n+        int index, java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n     }\n     \n     // repeated string init = 4;\n-    public java.util.List<java.lang.String> getInitList() {\n+    public java.util.List<java.lang.String>\n+        getInitList() {\n       return java.util.Collections.unmodifiableList(result.init_);\n     }\n     public int getInitCount() {\n     public java.lang.String getInit(int index) {\n       return result.getInit(index);\n     }\n-    public Builder setInit(int index, java.lang.String value) {\n+    public Builder setInit(\n+        int index, java.lang.String value) {\n       if (value == null) {\n     throw new NullPointerException();\n   }\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n     this.knownConstants = constNames;\n   }\n \n+  // An arbitrary limit to prevent catch infinite recursion.\n   private static final int MAX_INTERATIONS = 100;\n \n   /**\n       exposeExpression(expression);\n       if (i > MAX_INTERATIONS) {\n         throw new IllegalStateException(\n-            \"DecomposeExpression depth exceeded on :\\n\" + \n+            \"DecomposeExpression depth exceeded on :\\n\" +\n             expression.toStringTree());\n       }\n     }\n             // Either there were preexisting side-effects, or this node has\n             // side-effects.\n             state.sideEffects = true;\n-  \n+\n             // Rewrite the call so \"this\" is preserved.\n             Node replacement = rewriteCallExpression(parent, state);\n             // Continue from here.\n           }\n \n           // In Internet Explorer, DOM objects and other external objects\n-          // methods can not be called indirectly, as is required when the \n+          // methods can not be called indirectly, as is required when the\n           // object or its property can be side-effected.  For example,\n           // when exposing expression f() (with side-effects) in: x.m(f())\n           // either the value of x or its property m might have changed, so\n-          // both the 'this' value ('x') and the function to be called ('x.m') \n+          // both the 'this' value ('x') and the function to be called ('x.m')\n           // need to be preserved. Like so:\n           //   var t1 = x, t2 = x.m, t3 = f();\n           //   t2.call(t1, t3);\n-          // As IE doesn't support the call to these non-javascript objects \n+          // As IE doesn't support the call to these non-javascript objects\n           // methods in this way. We can't do this.\n           // We don't currently distinguish between these types of objects\n           // in the extern definitions and if we did we would need accurate\n           // type information.\n           //\n           Node first = parent.getFirstChild();\n-          if (requiresDecomposition \n-              && parent.getType() == Token.CALL \n+          if (requiresDecomposition\n+              && parent.getType() == Token.CALL\n               && NodeUtil.isGet(first)) {\n             if (maybeExternMethod(first)) {\n               return DecompositionType.UNDECOMPOSABLE;\n    * As the assignment is unaffected by side effect of \"foo()\"\n    * and the names assigned-to can not influence the state before\n    * the call to foo.\n-   * \n+   *\n    * It is also safe in cases like where the object is constant:\n    *    CONST_NAME.a = foo()\n-   *    CONST_NAME[CONST_VALUE] = foo(); \n-   * \n+   *    CONST_NAME[CONST_VALUE] = foo();\n+   *\n    * This is not true of more complex LHS values, such as\n    *     a.x = foo();\n    *     next().x = foo();\n    * in these cases the checks below are necessary.\n-   * \n+   *\n    * @param seenSideEffects If true, check to see if node-tree maybe affected by\n-   * side-effects, otherwise if the tree has side-effects. @see \n+   * side-effects, otherwise if the tree has side-effects. @see\n    * isExpressionTreeUnsafe\n    * @return Whether the assignment is safe from side-effects.\n    */\n         case Token.GETPROP:\n           return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects);\n         case Token.GETELEM:\n-          return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects) \n+          return !isExpressionTreeUnsafe(lhs.getFirstChild(), seenSideEffects)\n               && !isExpressionTreeUnsafe(lhs.getLastChild(), seenSideEffects);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       case Token.GETPROP:\n       case Token.GETELEM:\n         return true;\n+\n+      case Token.FUNCTION:\n+        // Anonymous functions definitions are not changed by side-effects,\n+        // and named functions are not part of expressions.\n+        Preconditions.checkState(NodeUtil.isAnonymousFunction(n));\n+        return false;\n     }\n \n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n    */\n   private static Collection<Definition> getCallableDefinitions(\n       DefinitionProvider definitionProvider, Node name) {\n-    List<Definition> result = Lists.newArrayList();\n-\n-    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n-      return null;\n-    }\n-\n-    Collection<Definition> decls =\n-        definitionProvider.getDefinitionsReferencedAt(name);\n-    if (decls == null) {\n-      return null;\n-    }\n-\n-    for (Definition current : decls) {\n-      Node rValue = current.getRValue();\n-      if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n-        result.add(current);\n+    if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {\n+      List<Definition> result = Lists.newArrayList();\n+\n+      Collection<Definition> decls =\n+          definitionProvider.getDefinitionsReferencedAt(name);\n+      if (decls == null) {\n+        return null;\n+      }\n+\n+      for (Definition current : decls) {\n+        Node rValue = current.getRValue();\n+        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n+          result.add(current);\n+        } else {\n+          return null;\n+        }\n+      }\n+\n+      return result;\n+    } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {\n+      Node firstVal;\n+      if (name.getType() == Token.HOOK) {\n+        firstVal = name.getFirstChild().getNext();\n+      } else {\n+        firstVal = name.getFirstChild();\n+      }\n+\n+      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,\n+                                                            firstVal);\n+      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,\n+                                                            firstVal.getNext());\n+      if (defs1 != null && defs2 != null) {\n+        defs1.addAll(defs2);\n+        return defs1;\n       } else {\n         return null;\n       }\n-    }\n-\n-    return result;\n+    } else {\n+      return null;\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n      * Copies source file and name information from the other\n      * node given to the current node. Used for maintaining\n      * debug information across node append and remove operations.\n-     */\n-    public void copyInformationFrom(Node other) {\n+     * @return this\n+     */\n+    public Node copyInformationFrom(Node other) {\n         if (getProp(ORIGINALNAME_PROP) == null) {\n             putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n         }\n             putProp(SOURCEFILE_PROP, other.getProp(SOURCEFILE_PROP));\n             sourcePosition = other.sourcePosition;\n         }\n+\n+        return this;\n     }\n \n     /**\n      * Copies source file and name information from the other node to the\n      * entire tree rooted at this node.\n-     */\n-    public void copyInformationFromForTree(Node other) {\n+     * @return this\n+     */\n+    public Node copyInformationFromForTree(Node other) {\n       copyInformationFrom(other);\n       for (Node child = getFirstChild();\n            child != null; child = child.getNext()) {\n         child.copyInformationFromForTree(other);\n       }\n+\n+      return this;\n     }\n \n     //==========================================================================\n--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n \n import java.util.Set;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Unit tests for ExpressionDecomposer\n  * @author johnlenz@google.com (John Lenz)\n         DecompositionType.UNDECOMPOSABLE, \"while(x = goo()&&foo()){}\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.UNDECOMPOSABLE, \"while(x += goo()&&foo()){}\", \"foo\");\n-    \n+\n     helperCanExposeExpression(\n         DecompositionType.UNDECOMPOSABLE, \"do{}while(foo());\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.MOVABLE, \"x = foo() || 1\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.MOVABLE, \"x = foo() ? 0 : 1\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"(function(a){b = a})(foo())\", \"foo\");\n   }\n \n   public void testCanExposeExpression3() {\n   public void testCanExposeExpression4() {\n     // 'this' must be preserved in call.\n     helperCanExposeExpression(\n-        DecompositionType.UNDECOMPOSABLE, \"if (goo.a(1, foo()));\", \"foo\");    \n+        DecompositionType.UNDECOMPOSABLE, \"if (goo.a(1, foo()));\", \"foo\");\n   }\n \n   public void testCanExposeExpression5() {\n     // 'this' must be preserved in call.\n     helperCanExposeExpression(\n-        DecompositionType.UNDECOMPOSABLE, \"if (goo['a'](foo()));\", \"foo\");    \n+        DecompositionType.UNDECOMPOSABLE, \"if (goo['a'](foo()));\", \"foo\");\n   }\n \n   public void testCanExposeExpression6() {\n     // 'this' must be preserved in call.\n     helperCanExposeExpression(\n-        DecompositionType.UNDECOMPOSABLE, \"z:if (goo.a(1, foo()));\", \"foo\");    \n-  }\n-  \n+        DecompositionType.UNDECOMPOSABLE, \"z:if (goo.a(1, foo()));\", \"foo\");\n+  }\n+\n+  public void testCanExposeExpression7() {\n+    // Verify calls to anonymous function are movable.\n+    helperCanExposeAnonymousFunctionExpression(\n+        DecompositionType.MOVABLE,\n+        \"(function(map){descriptions_=map})(\\n\" +\n+            \"function(){\\n\" +\n+                \"var ret={};\\n\" +\n+                \"ret[INIT]='a';\\n\" +\n+                \"ret[MIGRATION_BANNER_DISMISS]='b';\\n\" +\n+                \"return ret\\n\" +\n+            \"}()\\n\" +\n+        \");\", 2);\n+  }\n \n   public void testMoveExpression1() {\n     // There isn't a reason to do this, but it works.\n         \"if (1) temp_2 = foo(); else temp_2 = 0;\" +\n         \"if (temp_const_1(1, temp_const_0, temp_2));\");\n   }\n-  \n+\n   public void testExposePlusEquals() {\n     helperExposeExpression(\n         \"var x = 0; x += foo() + 1\",\n       String fnName\n       ) {\n     helperCanExposeExpression(expectedResult, code, fnName, null);\n+  }\n+\n+  private void helperCanExposeAnonymousFunctionExpression(\n+      DecompositionType expectedResult, String code, int call) {\n+    Compiler compiler = new Compiler();\n+    Set<String> knownConstants = Sets.newHashSet();\n+    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n+        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n+    Node tree = parse(compiler, code);\n+    assertNotNull(tree);\n+\n+    Node externsRoot = parse(compiler,\n+        \"function goo() {}\" +\n+        \"function foo() {}\");\n+    assertNotNull(externsRoot);\n+    Node mainRoot = tree;\n+\n+    Node callSite = findCall(tree, null, 2);\n+    assertNotNull(\"Call \" + call + \" was not found.\", callSite);\n+\n+    compiler.resetUniqueNameId();\n+    DecompositionType result = decomposer.canExposeExpression(\n+        callSite);\n+    assertEquals(expectedResult, result);\n   }\n \n   private void helperCanExposeExpression(\n         \"\\n\" + explanation, explanation);\n   }\n \n-\n   private static Node findCall(Node n, String name) {\n-    if (n.getType() == Token.CALL) {\n-      Node callee = n.getFirstChild();\n-      if (callee.getType() == Token.NAME\n-          && callee.getString().equals(name)) {\n-        return n;\n+    return findCall(n, name, 1);\n+  }\n+\n+  /**\n+   * @param name The name to look for.\n+   * @param call The call to look for.\n+   * @return The return the Nth CALL node to name found in a pre-order \n+   * traversal.\n+   */\n+  private static Node findCall(\n+      Node root, @Nullable final String name, final int call) {\n+    class Find {\n+      int found = 0;\n+      Node find(Node n) {\n+        if (n.getType() == Token.CALL) {\n+          Node callee = n.getFirstChild();\n+          if (name == null || (callee.getType() == Token.NAME\n+              && callee.getString().equals(name))) {\n+            found++;\n+            if (found == call) {\n+              return n;\n+            }\n+          }\n+        }\n+\n+        for (Node c : n.children()) {\n+          Node result = find(c);\n+          if (result != null) {\n+            return result;\n+          }\n+        }\n+\n+        return null;\n       }\n     }\n \n-    for (Node c : n.children()) {\n-      Node result = findCall(c, name);\n-      if (result != null) {\n-        return result;\n-      }\n-    }\n-\n-    return null;\n+    return (new Find()).find(root);\n   }\n \n   private static Node parse(Compiler compiler, String js) {\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n  */\n \n package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n \n /**\n  * Inline function tests.\n         \"x = JSCompiler_temp_const_0\");\n   }\n \n+  public void testDecomposeAnonymousInCall() {\n+    test(\n+        \"(function(map){descriptions_=map})(\\n\" +\n+           \"function(){\\n\" +\n+              \"var ret={};\\n\" +\n+              \"ret[ONE]='a';\\n\" +\n+              \"ret[TWO]='b';\\n\" +\n+              \"return ret\\n\" +\n+           \"}()\\n\" +\n+        \");\",\n+        \"{\" +\n+        \"var JSCompiler_inline_result_0;\" +\n+        \"var ret$$inline_2={};\\n\" +\n+        \"ret$$inline_2[ONE]='a';\\n\" +\n+        \"ret$$inline_2[TWO]='b';\\n\" +\n+        \"JSCompiler_inline_result_0 = ret$$inline_2;\\n\" +\n+        \"}\" +\n+        \"{\" +\n+        \"descriptions_=JSCompiler_inline_result_0;\" +\n+        \"}\"\n+        );\n+  }\n+\n   public void testInlineConstructor1() {\n     test(\"function f() {} function _g() {f.call(this)}\",\n          \"function _g() {void 0}\");\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n     checkMarkedCalls(source, ImmutableList.<String>of(\"A\", \"A\", \"f\"));\n   }\n \n+  public void testCallFunctionFOrG() throws Exception {\n+    String source = \"function f(){}\\n\" +\n+        \"function g(){}\\n\" +\n+        \"function h(){ (f || g)() }\\n\" +\n+        \"h()\";\n+\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"(f || g)\", \"h\"));\n+  }\n+\n+  public void testCallFunctionFOrGViaHook() throws Exception {\n+    String source = \"function f(){}\\n\" +\n+        \"function g(){}\\n\" +\n+        \"function h(){ (false ? f : g)() }\\n\" +\n+        \"h()\";\n+\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"(f : g)\", \"h\"));\n+  }\n+\n+  public void testCallFunctionForGorH() throws Exception {\n+    String source = \"function f(){}\\n\" +\n+        \"function g(){}\\n\" +\n+        \"function h(){}\\n\" +\n+        \"function i(){ (false ? f : (g || h))() }\\n\" +\n+        \"i()\";\n+\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"(f : (g || h))\", \"i\"));\n+  }\n+\n+  public void testCallFunctionFOrGWithSideEffects() throws Exception {\n+    String source = \"var x = 0;\\n\" +\n+        \"function f(){x = 10}\\n\" +\n+        \"function g(){}\\n\" +\n+        \"function h(){ (f || g)() }\\n\" +\n+        \"function i(){ (g || f)() }\\n\" +\n+        \"function j(){ (f || f)() }\\n\" +\n+        \"function k(){ (g || g)() }\\n\" +\n+        \"h(); i(); j(); k()\";\n+\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"(g || g)\", \"k\"));\n+  }\n+\n+  public void testCallFunctionFOrGViaHookWithSideEffects() throws Exception {\n+    String source = \"var x = 0;\\n\" +\n+        \"function f(){x = 10}\\n\" +\n+        \"function g(){}\\n\" +\n+        \"function h(){ (false ? f : g)() }\\n\" +\n+        \"function i(){ (false ? g : f)() }\\n\" +\n+        \"function j(){ (false ? f : f)() }\\n\" +\n+        \"function k(){ (false ? g : g)() }\\n\" +\n+        \"h(); i(); j(); k()\";\n+\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"(g : g)\", \"k\"));\n+  }\n+\n   public void testInvalidAnnotation1() throws Exception {\n     test(\"/** @nosideeffects */ function foo() {}\",\n          null, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.NEW) {\n         if (!NodeUtil.constructorCallHasSideEffects(n)) {\n-          noSideEffectCalls.add(n.getFirstChild().getQualifiedName());\n+          noSideEffectCalls.add(generateNameString(n.getFirstChild()));\n         }\n       } else if (n.getType() == Token.CALL) {\n         if (!NodeUtil.functionCallHasSideEffects(n)) {\n-          noSideEffectCalls.add(n.getFirstChild().getQualifiedName());\n+          noSideEffectCalls.add(generateNameString(n.getFirstChild()));\n         }\n       }\n     }\n+\n+    private String generateNameString(Node node) {\n+      if (node.getType() == Token.OR) {\n+        return \"(\" + generateNameString(node.getFirstChild()) +\n+            \" || \" + generateNameString(node.getLastChild()) + \")\";\n+      } else if (node.getType() == Token.HOOK) {\n+        return \"(\" + generateNameString(node.getFirstChild().getNext()) +\n+            \" : \" + generateNameString(node.getLastChild()) + \")\";\n+      } else {\n+        return node.getQualifiedName();\n+      }\n+    }\n   }\n }", "timestamp": 1269532700, "metainfo": ""}