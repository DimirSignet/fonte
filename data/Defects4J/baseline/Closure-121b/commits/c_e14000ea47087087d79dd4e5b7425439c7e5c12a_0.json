{"sha": "e14000ea47087087d79dd4e5b7425439c7e5c12a", "log": "Tighten leastSupertype/greatestSubtype relationships for parameterized types in advance of creating a true subtype relationship between the types.  R=nicksantos DELTA=1898  (1179 added, 275 deleted, 444 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5969   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n       return thisType.toMaybeUnionType().meet(thatType);\n     } else if (thatType.isUnionType()) {\n       return thatType.toMaybeUnionType().meet(thisType);\n+    } else if (thisType.isParameterizedType()) {\n+      return thisType.toMaybeParameterizedType().getGreatestSubtypeHelper(\n+          thatType);\n+    }  else if (thatType.isParameterizedType()) {\n+      return thatType.toMaybeParameterizedType().getGreatestSubtypeHelper(\n+          thisType);\n     } else if (thisType.isSubtype(thatType)) {\n       return filterNoResolvedType(thisType);\n     } else if (thatType.isSubtype(thisType)) {\n--- a/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n  * ***** END LICENSE BLOCK ***** */\n \n package com.google.javascript.rhino.jstype;\n+\n+import com.google.common.base.Preconditions;\n \n /**\n  * An object type with a declared default element type, such as\n   public boolean hasAnyTemplateTypesInternal() {\n     return super.hasAnyTemplateTypes() || parameterType.hasAnyTemplateTypes();\n   }\n+\n+  boolean wrapsSameRawType(JSType that) {\n+    return that.isParameterizedType() && this.getReferencedTypeInternal()\n+        .isEquivalentTo(\n+            that.toMaybeParameterizedType().getReferencedTypeInternal());\n+  }\n+\n+  boolean wrapsRawType(JSType that) {\n+    return this.getReferencedTypeInternal().isEquivalentTo(that);\n+  }\n+\n+  /**\n+   * Computes the greatest subtype of two related parameterized types.\n+   * @return The greatest subtype.\n+   */\n+  JSType getGreatestSubtypeHelper(JSType rawThat) {\n+    Preconditions.checkNotNull(rawThat);\n+\n+    if (!wrapsSameRawType(rawThat)) {\n+      if (!rawThat.isParameterizedType()) {\n+        if (this.isSubtype(rawThat)) {\n+          return this;\n+        } else if (rawThat.isSubtype(this)) {\n+          return filterNoResolvedType(rawThat);\n+        }\n+      }\n+      if (this.isObject() && rawThat.isObject()) {\n+        return this.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+      }\n+      return this.getNativeType(JSTypeNative.NO_TYPE);\n+    }\n+\n+    ParameterizedType that = rawThat.toMaybeParameterizedType();\n+    Preconditions.checkNotNull(that);\n+\n+    if (this.parameterType.isEquivalentTo(that.parameterType)) {\n+      return this;\n+    }\n+\n+    // For types that have the same raw type but different type parameters,\n+    // we simply create a type has a \"unknown\" type parameter.  This is\n+    // equivalent to the raw type.\n+    return getReferencedObjTypeInternal();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n-import com.google.javascript.rhino.jstype.UnionType;\n \n import java.io.Serializable;\n import java.util.Collection;\n         int currentIndex = 0;\n         Iterator<JSType> it = alternates.iterator();\n         while (it.hasNext()) {\n+          boolean removeCurrent = false;\n           JSType current = it.next();\n \n           // Unknown and NoResolved types may just be names that haven't\n               return this;\n             }\n           } else {\n-            if (alternate.isSubtype(current)) {\n+\n+            // Because \"Foo\" and \"Foo.<?>\" are roughly equivalent\n+            // parameterized types, special care is needed when building the\n+            // union. For example:\n+            //   Object is consider a subtype of Object.<string>\n+            // but we want to leave \"Object\" not \"Object.<string>\" when\n+            // building the subtype.\n+            //\n+\n+            if (alternate.isParameterizedType() || current.isParameterizedType()) {\n+              // Cases:\n+              // 1) alternate:Array.<string> and current:Object ==> Object\n+              // 2) alternate:Array.<string> and current:Array ==> Array\n+              // 3) alternate:Object.<string> and\n+              //    current:Array ==> Array|Object.<string>\n+              // 4) alternate:Object and current:Array.<string> ==> Object\n+              // 5) alternate:Array and current:Array.<string> ==> Array\n+              // 6) alternate:Array and\n+              //    current:Object.<string> ==> Array|Object.<string>\n+              // 7) alternate:Array.<string> and\n+              //    current:Array.<number> ==> Array.<?>\n+              // 8) alternate:Array.<string> and\n+              //    current:Array.<string> ==> Array.<string>\n+              // 9) alternate:Array.<string> and\n+              //    current:Object.<string> ==> Object.<string>|Array.<string>\n+\n+              if (!current.isParameterizedType()) {\n+                if (alternate.isSubtype(current)) {\n+                  // case 1, 2\n+                  return this;\n+                }\n+                // case 3: leave current, add alternate\n+              } else if (!alternate.isParameterizedType()) {\n+                if (current.isSubtype(alternate)) {\n+                  // case 4, 5\n+                  removeCurrent = true;\n+                }\n+                // case 6: leave current, add alternate\n+              } else {\n+                Preconditions.checkState(current.isParameterizedType()\n+                    && alternate.isParameterizedType());\n+                ParameterizedType parameterizedAlternate = alternate.toMaybeParameterizedType();\n+                ParameterizedType parameterizedCurrent = current.toMaybeParameterizedType();\n+\n+                if (parameterizedCurrent.wrapsSameRawType(parameterizedAlternate)) {\n+                  JSType alternateTypeParameter = parameterizedAlternate.getParameterType();\n+                  JSType currentTypeParameter = parameterizedCurrent.getParameterType();\n+                  if (currentTypeParameter.isEquivalentTo(parameterizedCurrent)) {\n+                    // case 8\n+                    return this;\n+                  } else {\n+                    // TODO(johnlenz): should we leave both types?\n+                    // case 7: add a merged alternate\n+                    // We currently merge to the parameterized types to \"unknown\"\n+                    // which is equivalent to the raw type.\n+                    JSType merged = parameterizedCurrent\n+                        .getReferencedObjTypeInternal();\n+                    return addAlternate(merged);\n+                  }\n+                }\n+                // case 9: leave current, add alternate\n+              }\n+              // Otherwise leave both parameterized types.\n+            } else if (alternate.isSubtype(current)) {\n               // Alternate is unnecessary.\n               return this;\n             } else if (current.isSubtype(alternate)) {\n               // Alternate makes current obsolete\n-              it.remove();\n-\n-              if (currentIndex == functionTypePosition) {\n-                functionTypePosition = -1;\n-              } else if (currentIndex < functionTypePosition) {\n-                functionTypePosition--;\n-                currentIndex--;\n-              }\n+              removeCurrent = true;\n+            }\n+          }\n+\n+          if (removeCurrent) {\n+            it.remove();\n+\n+            if (currentIndex == functionTypePosition) {\n+              functionTypePosition = -1;\n+            } else if (currentIndex < functionTypePosition) {\n+              functionTypePosition--;\n+              currentIndex--;\n             }\n           }\n           currentIndex++;\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n     return registry.createTemplatizedType(baseType, templatizedTypes);\n   }\n \n+  protected JSType createParameterizedType(\n+      ObjectType type, JSType typeParameter) {\n+    return registry.createParameterizedType(type, typeParameter);\n+  }\n+\n   /**\n    * Asserts that a Node representing a type expression resolves to the\n    * correct {@code JSType}.\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"required: string\");\n   }\n \n-  public void disable_testBackwardsInferenceGoogArrayFilter1()\n+  public void testFilter0()\n       throws Exception {\n-    // TODO(johnlenz): this doesn't fail because any Array is regarded as\n-    // a subtype of any other array regardless of the type parameter.\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {T} arr\\n\" +\n+        \" * @return {T}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"var filter = function(arr){};\\n\" +\n+\n+        \"/** @type {!Array.<string>} */\" +\n+        \"var arr;\\n\" +\n+        \"/** @type {!Array.<string>} */\" +\n+        \"var result = filter(arr);\");\n+  }\n+\n+  public void testFilter1()\n+      throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {!Array.<T>} arr\\n\" +\n+        \" * @return {!Array.<T>}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"var filter = function(arr){};\\n\" +\n+\n+        \"/** @type {!Array.<string>} */\" +\n+        \"var arr;\\n\" +\n+        \"/** @type {!Array.<string>} */\" +\n+        \"var result = filter(arr);\");\n+  }\n+\n+  public void testFilter2()\n+      throws Exception {\n+    // TODO(johnlenz): This should produce a warning.\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {!Array.<T>} arr\\n\" +\n+        \" * @return {!Array.<T>}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"var filter = function(arr){};\\n\" +\n+\n+        \"/** @type {!Array.<string>} */\" +\n+        \"var arr;\\n\" +\n+        \"/** @type {!Array.<number>} */\" +\n+        \"var result = filter(arr);\");\n+  }\n+\n+  public void testFilter3()\n+      throws Exception {\n+    // TODO(johnlenz): This should produce a warning.\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {Array.<T>} arr\\n\" +\n+        \" * @return {Array.<T>}\\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"var filter = function(arr){};\\n\" +\n+\n+        \"/** @type {Array.<string>} */\" +\n+        \"var arr;\\n\" +\n+        \"/** @type {Array.<number>} */\" +\n+        \"var result = filter(arr);\");\n+  }\n+\n+  public void testBackwardsInferenceGoogArrayFilter1()\n+      throws Exception {\n+    // TODO(johnlenz): This should produce a warning.\n     testClosureTypes(\n         CLOSURE_DEFS +\n         \"/** @type {Array.<string>} */\" +\n         \"var arr;\\n\" +\n-        \"/** @type {Array.<number>} */\" +\n+        \"/** @type {!Array.<number>} */\" +\n         \"var result = goog.array.filter(\" +\n         \"   arr,\" +\n         \"   function(item,index,src) {return false;});\",\n-        \"assignment\\n\" +\n-        \"found   : string\\n\" +\n-        \"required: number\");\n+        null);\n   }\n \n   public void testBackwardsInferenceGoogArrayFilter2() throws Exception {\n         \"    out = e;\" +\n         \"  }\" +\n         \"}\\n\");\n+  }\n+\n+  public void testParameterized1() throws Exception {\n+    // TODO(johnlenz): This should produce a warning.\n+    testTypes(\n+        \"/** @type {!Array.<string>} */\" +\n+        \"var arr1 = [];\\n\" +\n+        \"/** @type {!Array.<number>} */\" +\n+        \"var arr2 = [];\\n\" +\n+        \"arr1 = arr2;\");\n+  }\n+\n+  public void testParameterized2() throws Exception {\n+    // TODO(johnlenz): This should produce a warning.\n+    testTypes(\n+        \"/** @type {!Array.<string>} */\" +\n+        \"var arr1 = /** @type {!Array.<number>} */([]);\\n\");\n+  }\n+\n+  public void testParameterized3() throws Exception {\n+    // TODO(johnlenz): This should produce a warning.\n+    testTypes(\n+        \"/** @type {Array.<string>} */\" +\n+        \"var arr1 = /** @type {!Array.<number>} */([]);\\n\");\n+  }\n+\n+  public void testParameterized4() throws Exception {\n+    // TODO(johnlenz): This should produce a warning.\n+    testTypes(\n+        \"/** @type {Array.<string>} */\" +\n+        \"var arr1 = [];\\n\" +\n+        \"/** @type {Array.<number>} */\" +\n+        \"var arr2 = arr1;\\n\");\n   }\n \n   private void testTypes(String js) throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         subclassCtor,\n         recordType,\n         forwardDeclaredNamedType,\n-        createUnionType(forwardDeclaredNamedType, NULL_TYPE));\n+        createUnionType(forwardDeclaredNamedType, NULL_TYPE),\n+        createParameterizedType(OBJECT_TYPE, STRING_TYPE),\n+        createParameterizedType(OBJECT_TYPE, NUMBER_TYPE),\n+        createParameterizedType(ARRAY_TYPE, STRING_TYPE),\n+        createParameterizedType(ARRAY_TYPE, NUMBER_TYPE),\n+        createUnionType(\n+            createParameterizedType(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE),\n+        createUnionType(\n+            createParameterizedType(OBJECT_TYPE, BOOLEAN_TYPE), NULL_TYPE)\n+        );\n   }\n \n   public void testSymmetryOfTestForEquality() {\n     verifySubtypeChain(typeChain);\n   }\n \n+  public void testParameterizedArrayChain() throws Exception {\n+    JSType arrayOfNoType = createParameterizedType(\n+        ARRAY_TYPE, NO_TYPE);\n+    JSType arrayOfString = createParameterizedType(\n+        ARRAY_TYPE, STRING_TYPE);\n+    JSType arrayOfStringOrNumber = createParameterizedType(\n+        ARRAY_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE));\n+    JSType arrayOfAllType = createParameterizedType(\n+        ARRAY_TYPE, ALL_TYPE);\n+\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        arrayOfAllType,\n+        arrayOfStringOrNumber,\n+        arrayOfString,\n+        arrayOfNoType,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain, false);\n+  }\n+\n+  public void testParameterizedArrayChain2() throws Exception {\n+    JSType arrayOfNoType = createParameterizedType(\n+        ARRAY_TYPE, NO_TYPE);\n+    JSType arrayOfNoObjectType = createParameterizedType(\n+        ARRAY_TYPE, NO_OBJECT_TYPE);\n+    JSType arrayOfArray = createParameterizedType(\n+        ARRAY_TYPE, ARRAY_TYPE);\n+    JSType arrayOfObject = createParameterizedType(\n+        ARRAY_TYPE, OBJECT_TYPE);\n+    JSType arrayOfAllType = createParameterizedType(\n+        ARRAY_TYPE, ALL_TYPE);\n+\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        arrayOfAllType,\n+        arrayOfObject,\n+        arrayOfArray,\n+        arrayOfNoObjectType,\n+        arrayOfNoType,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain, false);\n+  }\n+\n+  public void testParameterizedObjectChain() throws Exception {\n+    JSType objectOfNoType = createParameterizedType(\n+        OBJECT_TYPE, NO_TYPE);\n+    JSType objectOfString = createParameterizedType(\n+        OBJECT_TYPE, STRING_TYPE);\n+    JSType objectOfStringOrNumber = createParameterizedType(\n+        OBJECT_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE));\n+    JSType objectOfAllType = createParameterizedType(\n+        OBJECT_TYPE, ALL_TYPE);\n+\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        objectOfAllType,\n+        objectOfStringOrNumber,\n+        objectOfString,\n+        objectOfNoType,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain, false);\n+  }\n+\n+  public void testMixedParameterizedTypeChain() throws Exception {\n+    JSType arrayOfNoType = createParameterizedType(\n+        ARRAY_TYPE, NO_TYPE);\n+    JSType arrayOfString = createParameterizedType(\n+        ARRAY_TYPE, STRING_TYPE);\n+    JSType objectOfString = createParameterizedType(\n+        OBJECT_TYPE, STRING_TYPE);\n+    JSType objectOfStringOrNumber = createParameterizedType(\n+        OBJECT_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE));\n+    JSType objectOfAllType = createParameterizedType(\n+        OBJECT_TYPE, ALL_TYPE);\n+\n+    List<JSType> typeChain = Lists.newArrayList(\n+        registry.getNativeType(JSTypeNative.ALL_TYPE),\n+        registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n+        objectOfAllType,\n+        objectOfStringOrNumber,\n+        objectOfString,\n+        arrayOfString,\n+        arrayOfNoType,\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain, false);\n+  }\n+\n+  public void testParameterizedTypeRelations() throws Exception {\n+    JSType objectOfString = createParameterizedType(\n+        OBJECT_TYPE, STRING_TYPE);\n+    JSType arrayOfString = createParameterizedType(\n+        ARRAY_TYPE, STRING_TYPE);\n+    JSType arrayOfNumber = createParameterizedType(\n+        ARRAY_TYPE, NUMBER_TYPE);\n+    JSType arrayOfUnknown = createParameterizedType(\n+        ARRAY_TYPE, UNKNOWN_TYPE);\n+\n+    assertFalse(objectOfString.isSubtype(ARRAY_TYPE));\n+    assertTrue(ARRAY_TYPE.isSubtype(objectOfString));\n+    assertFalse(objectOfString.isSubtype(ARRAY_TYPE));\n+    assertTrue(ARRAY_TYPE.isSubtype(objectOfString));\n+\n+    // Union and least super type cases:\n+    //\n+    // 1) alternate:Array.<string> and current:Object ==> Object\n+    // 2) alternate:Array.<string> and current:Array ==> Array\n+    // 3) alternate:Object.<string> and current:Array ==> Array|Object.<string>\n+    // 4) alternate:Object and current:Array.<string> ==> Object\n+    // 5) alternate:Array and current:Array.<string> ==> Array\n+    // 6) alternate:Array and current:Object.<string> ==> Array|Object.<string>\n+    // 7) alternate:Array.<string> and current:Array.<number> ==> Array.<?>\n+    // 8) alternate:Array.<string> and current:Array.<string> ==> Array.<string>\n+    // 9) alternate:Array.<string> and\n+    //    current:Object.<string> ==> Object.<string>|Array.<string>\n+\n+    assertTypeEquals(\n+        OBJECT_TYPE,\n+        JSType.getLeastSupertype(arrayOfString, OBJECT_TYPE));\n+    assertTypeEquals(\n+        OBJECT_TYPE,\n+        JSType.getLeastSupertype(OBJECT_TYPE, arrayOfString));\n+\n+    assertTypeEquals(\n+        ARRAY_TYPE,\n+        JSType.getLeastSupertype(arrayOfString, ARRAY_TYPE));\n+    assertTypeEquals(\n+        ARRAY_TYPE,\n+        JSType.getLeastSupertype(ARRAY_TYPE, arrayOfString));\n+\n+    assertEquals(\n+        \"(Array|Object.<string>)\",\n+        JSType.getLeastSupertype(objectOfString, ARRAY_TYPE).toString());\n+    assertEquals(\n+        \"(Array|Object.<string>)\",\n+        JSType.getLeastSupertype(ARRAY_TYPE, objectOfString).toString());\n+\n+    assertEquals(\n+        \"Array\",\n+        JSType.getLeastSupertype(arrayOfString, arrayOfNumber).toString());\n+    assertEquals(\n+        \"Array\",\n+        JSType.getLeastSupertype(arrayOfNumber, arrayOfString).toString());\n+    assertTypeEquals(\n+        arrayOfString,\n+        JSType.getLeastSupertype(arrayOfString, arrayOfString));\n+\n+    assertEquals(\n+        \"(Array.<string>|Object.<string>)\",\n+        JSType.getLeastSupertype(objectOfString, arrayOfString).toString());\n+    assertEquals(\n+        \"(Array.<string>|Object.<string>)\",\n+        JSType.getLeastSupertype(arrayOfString, objectOfString).toString());\n+\n+    assertTypeEquals(\n+        objectOfString,\n+        JSType.getGreatestSubtype(OBJECT_TYPE, objectOfString));\n+\n+    assertTypeEquals(\n+        objectOfString,\n+        JSType.getGreatestSubtype(objectOfString, OBJECT_TYPE));\n+\n+    assertTypeEquals(\n+        ARRAY_TYPE,\n+        JSType.getGreatestSubtype(objectOfString, ARRAY_TYPE));\n+\n+    assertTypeEquals(\n+        JSType.getGreatestSubtype(objectOfString, arrayOfString),\n+        NO_OBJECT_TYPE);\n+\n+    assertTypeEquals(\n+        JSType.getGreatestSubtype(OBJECT_TYPE, arrayOfString),\n+        arrayOfString);\n+  }\n+\n   /**\n    * Tests that the given chain of types has a total ordering defined\n    * by the subtype relationship, with types at the top of the lattice", "timestamp": 1355342055, "metainfo": ""}