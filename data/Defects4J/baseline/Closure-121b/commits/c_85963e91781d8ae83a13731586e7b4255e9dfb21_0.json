{"sha": "85963e91781d8ae83a13731586e7b4255e9dfb21", "log": "Automated g4 rollback  *** Reason for rollback ***  Fixes test  *** Original change description ***  Automated g4 rollback  *** Reason for rollback ***  Broken test  *** Original change description ***  Fix encoding of strings containing \":\" in the \"VariableMap\". Add a unit test for \"ReplaceIdGenerators\" serialization (which does not use VariableMap).  R=nicksantos DELTA=159  (144 added, 5 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5618   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n   VariableMap getStringMap() {\n     Map<String, String> map = Maps.newHashMap();\n     for (Result result : results.values()) {\n-      /* VariableMap don't support newlines, escape them. */\n-      map.put(result.replacement, escapeForVariableMap(result.original));\n+      map.put(result.replacement, result.original);\n     }\n \n     VariableMap stringMap = new VariableMap(map);\n     return stringMap;\n-  }\n-\n-  private String escapeForVariableMap(String original) {\n-    return original.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\n\", \"\\\\n\");\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/VariableMap.java\n+++ b/src/com/google/javascript/jscomp/VariableMap.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Charsets;\n import com.google.common.collect.Maps;\n import com.google.common.io.ByteStreams;\n     Writer writer = new OutputStreamWriter(baos, Charsets.UTF_8);\n     try {\n       for (Map.Entry<String, String> entry : map.entrySet()) {\n-        writer.write(entry.getKey());\n+        writer.write(escape(entry.getKey()));\n         writer.write(SEPARATOR);\n-        writer.write(entry.getValue());\n+        writer.write(escape(entry.getValue()));\n         writer.write('\\n');\n       }\n       writer.close();\n     Map<String, String> map = new HashMap<String, String>();\n \n     for (String line : lines) {\n-      int pos = line.lastIndexOf(SEPARATOR);\n+      int pos = findIndexOfChar(line, SEPARATOR);\n       if (pos <= 0 || pos == line.length() - 1) {\n         throw new ParseException(\"Bad line: \" + line, 0);\n       }\n-      map.put(line.substring(0, pos), line.substring(pos + 1));\n+      map.put(\n+          unescape(line.substring(0, pos)),\n+          unescape(line.substring(pos + 1)));\n     }\n     return new VariableMap(map);\n+  }\n+\n+  private static String escape(String value) {\n+    return value.replace(\"\\\\\", \"\\\\\\\\\")\n+        .replace(\":\", \"\\\\:\")\n+        .replace(\"\\n\", \"\\\\n\");\n+  }\n+\n+  private static int findIndexOfChar(String value, char stopChar) {\n+    int len = value.length();\n+    for (int i=0; i<len; i++) {\n+      char c = value.charAt(i);\n+      if (c == '\\\\' && ++i < len) {\n+        c = value.charAt(i);\n+      } else if (c == stopChar){\n+        return i;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private static String unescape(CharSequence value) {\n+    StringBuilder sb = new StringBuilder();\n+    int len = value.length();\n+    for (int i=0; i<len; i++) {\n+      char c = value.charAt(i);\n+      if (c == '\\\\' && ++i < len) {\n+        c = value.charAt(i);\n+      }\n+      sb.append(c);\n+    }\n+    return sb.toString();\n   }\n \n   /**\n   public static VariableMap fromMap(Map<String, String> map) {\n     return new VariableMap(Maps.newHashMap(map));\n   }\n-}\n+\n+  @VisibleForTesting\n+  Map<String, String> toMap() {\n+    return map;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java\n  */\n public class ReplaceIdGeneratorsTest extends CompilerTestCase {\n \n-  public boolean generatePseudoNames = false;\n+  private boolean generatePseudoNames = false;\n+  private ReplaceIdGenerators lastPass = null;\n \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n-    return new ReplaceIdGenerators(\n+    lastPass = new ReplaceIdGenerators(\n         compiler,\n         new ImmutableSet.Builder<String>()\n             .add(\"goog.events.getUniqueId\")\n-        .add(\"goog.place.getUniqueId\").build(),\n+            .add(\"goog.place.getUniqueId\")\n+            .build(),\n         generatePseudoNames);\n+    return lastPass;\n   }\n \n   @Override\n     test(\"foo.bar = goog.events.getUniqueId('foo_bar')\",\n          \"foo.bar = 'a'\",\n          \"foo.bar = 'foo_bar$0'\");\n+  }\n+\n+  public void testSerialization() {\n+    testMap(\"var x = goog.events.getUniqueId('xxx');\\n\" +\n+            \"var y = goog.events.getUniqueId('yyy');\\n\",\n+\n+            \"var x = 'a';\\n\" +\n+            \"var y = 'b';\\n\",\n+\n+            \"[goog.events.getUniqueId]\\n\" +\n+            \"\\n\" +\n+            \"a:testcode:1\\n\" +\n+            \"b:testcode:2\\n\" +\n+            \"\\n\" +\n+            \"[goog.place.getUniqueId]\\n\" +\n+            \"\\n\" +\n+            \"\\n\");\n   }\n \n   public void testSimple() {\n         \"if (x) {foo.bar = 'foo_bar$0'}\");\n   }\n \n+  private void testMap(String code, String expected, String expectedMap) {\n+    test(code, expected);\n+    assertEquals(expectedMap, lastPass.getIdGeneratorMap());\n+  }\n+\n   private void test(String code, String expected, String expectedPseudo) {\n     generatePseudoNames = false;\n     test(code, expected);\n--- a/test/com/google/javascript/jscomp/VariableMapTest.java\n+++ b/test/com/google/javascript/jscomp/VariableMapTest.java\n import java.text.ParseException;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * Tests for {@link VariableMap}.\n  *\n  */\n public class VariableMapTest extends TestCase {\n+\n+  public void testCycle1() throws ParseException {\n+    cycleTest(ImmutableMap.of(\"AAA\", \"a\", \"BBB\", \"b\"));\n+    cycleTest(ImmutableMap.of(\"AA:AA\", \"a\", \"BB:BB\", \"b\"));\n+    cycleTest(ImmutableMap.of(\"AAA\", \"a:a\", \"BBB\", \"b:b\"));\n+  }\n+\n+  public void cycleTest(Map<String, String> map) throws ParseException {\n+    VariableMap in = new VariableMap(map);\n+    String serialized = new String(in.toBytes(), Charsets.UTF_8);\n+    VariableMap out = VariableMap.fromBytes(serialized.getBytes());\n+    assertMapsEquals(in.toMap(), out.toMap());\n+  }\n+\n+  public void assertMapsEquals(\n+      Map<String, String> expected, Map<String, String> result) {\n+    assertEquals(expected.size(), result.size());\n+    for (String key : expected.keySet()) {\n+      assertEquals(expected.get(key), result.get(key));\n+    }\n+  }\n \n   public void testToBytes() {\n     VariableMap vm = new VariableMap(ImmutableMap.of(\"AAA\", \"a\", \"BBB\", \"b\"));\n     assertEquals(\"BBB\", vm.lookupSourceName(\"b\"));\n   }\n \n-  public void testFromBytesComplex() throws ParseException {\n-    VariableMap vm = VariableMap.fromBytes(\"AAA[':f']:a\\n\".getBytes());\n+  public void testFileFormat1() {\n+    assertEqual(\n+        new VariableMap(ImmutableMap.of(\"x\\ny\", \"a\")).toBytes(),\n+        \"x\\\\ny:a\\n\".getBytes());\n+\n+    assertEqual(\n+        new VariableMap(ImmutableMap.of(\"x:y\", \"a\")).toBytes(),\n+        \"x\\\\:y:a\\n\".getBytes());\n+\n+    assertEqual(\n+        new VariableMap(ImmutableMap.of(\"x\\ny\", \"a\")).toBytes(),\n+        \"x\\\\ny:a\\n\".getBytes());\n+\n+    assertEqual(\n+        new VariableMap(ImmutableMap.of(\"x\\\\y\", \"a\")).toBytes(),\n+        \"x\\\\\\\\y:a\\n\".getBytes());\n+\n+    assertEqual(\n+        new VariableMap(ImmutableMap.of(\"\\n\", \"a\")).toBytes(),\n+        \"\\\\n:a\\n\".getBytes());\n+\n+    assertEqual(\n+        new VariableMap(ImmutableMap.of(\":\", \"a\")).toBytes(),\n+        \"\\\\::a\\n\".getBytes());\n+\n+    assertEqual(\n+        new VariableMap(ImmutableMap.of(\"\\n\", \"a\")).toBytes(),\n+        \"\\\\n:a\\n\".getBytes());\n+\n+    assertEqual(\n+        new VariableMap(ImmutableMap.of(\"\\\\\", \"a\")).toBytes(),\n+        \"\\\\\\\\:a\\n\".getBytes());\n+  }\n+\n+  public void testFromBytesComplex1() throws ParseException {\n+    // Verify we get out what we put in.\n+    cycleTest(ImmutableMap.of(\"AAA[':f']\", \"a\"));\n+\n+    // Verify the file format is as expected.\n+    VariableMap in = new VariableMap(ImmutableMap.of(\"AAA[':f']\", \"a\"));\n+    assertEqual(in.toBytes(), \"AAA['\\\\:f']:a\\n\".getBytes());\n+  }\n+\n+  public void testFromBytesComplex2() throws ParseException {\n+    VariableMap vm = VariableMap.fromBytes(\"AAA['\\\\:f']:a\\n\".getBytes());\n+\n     assertEquals(1, vm.getOriginalNameToNewNameMap().size());\n     assertEquals(\"a\", vm.lookupNewName(\"AAA[':f']\"));\n+\n+    assertEquals(1, vm.getNewNameToOriginalNameMap().size());\n+    assertEquals(\"AAA[':f']\", vm.lookupSourceName(\"a\"));\n+\n+  }\n+\n+  private void assertEqual(byte[] bytes1, byte[] bytes2) {\n+    if (bytes1 != bytes2) {\n+      assertEquals(\"length differs.\", bytes1.length, bytes2.length);\n+      for (int i = 0; i < bytes1.length; i++) {\n+        assertEquals(\"byte \" + i + \"differs.\", bytes1[i], bytes2[i]);\n+      }\n+    }\n   }\n }", "timestamp": 1349720836, "metainfo": ""}