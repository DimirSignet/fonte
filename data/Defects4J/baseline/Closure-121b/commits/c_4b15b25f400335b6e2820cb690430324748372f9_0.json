{"sha": "4b15b25f400335b6e2820cb690430324748372f9", "log": "when handling a finally block like so, try { alert(1) } finally { } There needs to be 2 edges: an unconditional edge to the statement after the 'finally', and an edge for the code path that continues handling the exception. Label the second edge with ON_EX instead of UNCOND. Fixes issue 779  R=acleung DELTA=18  (14 added, 0 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5214   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n     ON_FALSE,\n     /** Unconditional branch. */\n     UNCOND,\n-    /** Exception related. */\n+    /**\n+     * Exception-handling code paths.\n+     * Conflates two kind of control flow passing:\n+     * - An exception is thrown, and falls into a catch or finally block\n+     * - During exception handling, a finally block finishes and control\n+     *   passes to the next finally block.\n+     * In theory, we need 2 different edge types. In practice, we\n+     * can just treat them as \"the edges we can't really optimize\".\n+     */\n     ON_EX,\n     /** Possible folded-away template */\n     SYN_BLOCK;\n--- a/test/com/google/javascript/jscomp/CheckMissingReturnTest.java\n+++ b/test/com/google/javascript/jscomp/CheckMissingReturnTest.java\n     testNotMissing(\"if (a) { return 1} else { while (1) {return 1} }\");\n   }\n \n+  public void testIssue779() {\n+    testNotMissing(\n+        \"var a = f(); try { alert(); if (a > 0) return 1; }\" +\n+        \"finally { a = 5; } return 2;\");\n+  }\n+\n   private static String createFunction(String returnType, String body) {\n     return \"/** @return {\" + returnType + \"} */ function foo() {\" + body + \"}\";\n   }\n--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n     // BREAK to FINALLY.\n     assertCrossEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND);\n     // FINALLY to FINALLY.\n-    assertCrossEdge(cfg, Token.BLOCK, Token.BLOCK, Branch.UNCOND);\n+    assertCrossEdge(cfg, Token.BLOCK, Token.BLOCK, Branch.ON_EX);\n     assertCrossEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_FALSE);\n     assertReturnEdge(cfg, Token.BLOCK);\n   }\n     ControlFlowGraph<Node> cfg = createCfg(src);\n     assertCrossEdge(cfg, Token.THROW, Token.BLOCK, Branch.ON_EX);\n     assertCrossEdge(cfg, Token.VAR, Token.BLOCK, Branch.UNCOND);\n-    assertCrossEdge(cfg, Token.IF, Token.BLOCK, Branch.UNCOND);\n+    assertCrossEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_EX);\n   }\n \n   public void testReturn() {", "timestamp": 1343163872, "metainfo": ""}