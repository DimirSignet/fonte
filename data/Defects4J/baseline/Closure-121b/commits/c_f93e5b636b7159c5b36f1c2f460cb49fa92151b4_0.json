{"sha": "f93e5b636b7159c5b36f1c2f460cb49fa92151b4", "log": "Fixes two issues with goog.inherits: - Makes goog.inherits gracefully accept templated subtypes. - Prevents goog.inherits from extending the subtype's TemplateTypeMap (this was causing the extension to happen twice). TemplateTypeMaps will now only be carried through to subtypes via @extends declarations. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=48425127", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n   private void maybeSetBaseType(FunctionType fnType) {\n     if (!fnType.isInterface() && baseType != null) {\n       fnType.setPrototypeBasedOn(baseType);\n+      fnType.extendTemplateTypeMapBasedOn(baseType);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n     ObjectType implicitProto = subObject.getImplicitPrototype();\n     ObjectType declaredSuper =\n         implicitProto == null ? null : implicitProto.getImplicitPrototype();\n+    if (declaredSuper != null && declaredSuper.isTemplatizedType()) {\n+      declaredSuper =\n+          declaredSuper.toMaybeTemplatizedType().getReferencedType();\n+    }\n     if (declaredSuper != null &&\n         !(superObject instanceof UnknownType) &&\n         !declaredSuper.isEquivalentTo(superObject)) {\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n     if (baseType.hasReferenceName() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType()) {\n-      typeOfThis.extendTemplateTypeMap(baseType.getTemplateTypeMap());\n       baseType = new PrototypeObjectType(\n           registry, getReferenceName() + \".prototype\", baseType);\n     }\n     setPrototype(baseType, propertyNode);\n+  }\n+\n+  /**\n+   * Extends the TemplateTypeMap of the function's this type, based on the\n+   * specified type.\n+   * @param type\n+   */\n+  public void extendTemplateTypeMapBasedOn(ObjectType type) {\n+    typeOfThis.extendTemplateTypeMap(type.getTemplateTypeMap());\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"derived.inherits(base);\",\n         \"(new derived).constructor.prototype.bar\",\n         \"function (this:base, number): undefined\");\n+  }\n+\n+  public void testGoodExtends18() throws Exception {\n+    testTypes(\n+        CLOSURE_DEFS +\n+        \"/** @constructor\\n\" +\n+        \" * @template T */\\n\" +\n+        \"function C() {}\\n\" +\n+        \"/** @constructor\\n\" +\n+        \" * @extends {C.<string>} */\\n\" +\n+        \"function D() {};\\n\" +\n+        \"goog.inherits(D, C);\\n\" +\n+        \"(new D())\");\n+  }\n+\n+  public void testGoodExtends19() throws Exception {\n+    testTypes(\n+        CLOSURE_DEFS +\n+        \"/** @constructor */\\n\" +\n+        \"function C() {}\\n\" +\n+        \"\" +\n+        \"/** @interface\\n\" +\n+        \" * @template T */\\n\" +\n+        \"function D() {}\\n\" +\n+        \"/** @param {T} t */\\n\" +\n+        \"D.prototype.method;\\n\" +\n+        \"\" +\n+        \"/** @constructor\\n\" +\n+        \" * @template T\\n\" +\n+        \" * @extends {C}\\n\" +\n+        \" * @implements {D.<T>} */\\n\" +\n+        \"function E() {};\\n\" +\n+        \"goog.inherits(E, C);\\n\" +\n+        \"/** @override */\\n\" +\n+        \"E.prototype.method = function(t) {};\\n\" +\n+        \"\" +\n+        \"var e = /** @type {E.<string>} */ (new E());\\n\" +\n+        \"e.method(3);\",\n+        \"actual parameter 1 of E.prototype.method does not match formal \" +\n+        \"parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n   }\n \n   public void testBadExtends1() throws Exception {", "timestamp": 1372185660, "metainfo": ""}