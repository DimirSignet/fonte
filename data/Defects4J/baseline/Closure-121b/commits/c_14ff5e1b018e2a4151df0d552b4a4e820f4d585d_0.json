{"sha": "14ff5e1b018e2a4151df0d552b4a4e820f4d585d", "log": "Refactor VariableMap so it is immutable. This will make it safe to use an an input to the compiler.  R=nicksantos DELTA=49  (8 added, 9 deleted, 32 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5691   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n+++ b/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Maps;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n    * @return A mapping from original names to new names\n    */\n   VariableMap getFunctionMap() {\n-    return new VariableMap(renameMap);\n+    return new VariableMap(ImmutableMap.copyOf(renameMap));\n   }\n }\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n   }\n \n   public ImmutableMap<String, Long> getRuntimeRecord() {\n-    ImmutableMap.Builder<String, Long> builder =\n-        new ImmutableMap.Builder<String, Long>();\n+    ImmutableMap.Builder<String, Long> builder = ImmutableMap.builder();\n     for (Map.Entry<String, Stats> entry : summary.entrySet()) {\n       builder.put(entry.getKey(), entry.getValue().runtime);\n     }\n   }\n \n   public ImmutableMap<String, Integer> getCodeSizeRecord() {\n-    ImmutableMap.Builder<String, Integer> builder =\n-      new ImmutableMap.Builder<String, Integer>();\n+    ImmutableMap.Builder<String, Integer> builder = ImmutableMap.builder();\n     for (Map.Entry<String, Stats> entry : summary.entrySet()) {\n       builder.put(entry.getKey(), entry.getValue().diff);\n     }\n   }\n \n   public ImmutableMap<String, Integer> getZippedCodeSizeRecord() {\n-    ImmutableMap.Builder<String, Integer> builder =\n-      new ImmutableMap.Builder<String, Integer>();\n+    ImmutableMap.Builder<String, Integer> builder = ImmutableMap.builder();\n     for (Map.Entry<String, Stats> entry : summary.entrySet()) {\n       builder.put(entry.getKey(), entry.getValue().gzDiff);\n     }\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n    * @return A mapping from original names to new names\n    */\n   VariableMap getPropertyMap() {\n-    Map<String, String> map = new HashMap<String, String>();\n+    ImmutableMap.Builder<String, String> map = ImmutableMap.builder();\n     for (Property p : propertyMap.values()) {\n       if (p.newName != null) {\n         map.put(p.oldName, p.newName);\n       }\n     }\n-    return new VariableMap(map);\n+    return new VariableMap(map.build());\n   }\n \n   // -------------------------------------------------------------------------\n--- a/src/com/google/javascript/jscomp/RenamePrototypes.java\n+++ b/src/com/google/javascript/jscomp/RenamePrototypes.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n    * @return A mapping from original names to new names\n    */\n   VariableMap getPropertyMap() {\n-    Map<String, String> map = new HashMap<String, String>();\n+    ImmutableMap.Builder<String, String> map = ImmutableMap.builder();\n     for (Property p : properties.values()) {\n       if (p.newName != null) {\n         map.put(p.oldName, p.newName);\n       }\n     }\n-    return new VariableMap(map);\n+    return new VariableMap(map.build());\n   }\n }\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n    * Gets the variable map.\n    */\n   VariableMap getVariableMap() {\n-    return new VariableMap(renameMap);\n+    return new VariableMap(ImmutableMap.copyOf(renameMap));\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n import com.google.common.base.Predicate;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n \n   // Get the list of replaces as a VariableMap\n   VariableMap getStringMap() {\n-    Map<String, String> map = Maps.newHashMap();\n+    ImmutableMap.Builder<String, String> map = ImmutableMap.builder();\n     for (Result result : Iterables.filter(results.values(), USED_RESULTS)) {\n       map.put(result.replacement, result.original);\n     }\n \n-    VariableMap stringMap = new VariableMap(map);\n+    VariableMap stringMap = new VariableMap(map.build());\n     return stringMap;\n   }\n \n--- a/src/com/google/javascript/jscomp/VariableMap.java\n+++ b/src/com/google/javascript/jscomp/VariableMap.java\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Charsets;\n-import com.google.common.collect.Maps;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.io.ByteStreams;\n import com.google.common.io.CharStreams;\n import com.google.common.io.Files;\n public class VariableMap {\n \n   /** Maps original source name to new name */\n-  private final Map<String, String> map;\n+  private final ImmutableMap<String, String> map;\n \n   /** Maps new name to source name, lazily initialized */\n-  private Map<String, String> reverseMap = null;\n+  private ImmutableMap<String, String> reverseMap = null;\n \n   private static final char SEPARATOR = ':';\n \n   VariableMap(Map<String, String> map) {\n-    this.map = Collections.unmodifiableMap(map);\n+    this.map = ImmutableMap.copyOf(map);\n   }\n \n   /**\n    * if it's not found.\n    */\n   public String lookupSourceName(String newName) {\n-    if (reverseMap == null) {\n-      initReverseMap();\n-    }\n+    initReverseMap();\n     return reverseMap.get(newName);\n   }\n \n    */\n   private synchronized void initReverseMap() {\n     if (reverseMap == null) {\n-      Map<String, String> rm = new HashMap<String, String>();\n+      ImmutableMap.Builder<String, String> rm = ImmutableMap.builder();\n       for (Map.Entry<String, String> entry : map.entrySet()) {\n         rm.put(entry.getValue(), entry.getKey());\n       }\n-      reverseMap = Collections.unmodifiableMap(rm);\n+      reverseMap = rm.build();\n     }\n   }\n \n    * Returns an unmodifiable mapping from new names to original names.\n    */\n   public Map<String, String> getNewNameToOriginalNameMap() {\n-    if (reverseMap == null) {\n-      initReverseMap();\n-    }\n+    initReverseMap();\n     return reverseMap;\n   }\n \n       throw new RuntimeException(e);\n     }\n \n-    Map<String, String> map = new HashMap<String, String>();\n+    ImmutableMap.Builder<String, String> map = ImmutableMap.builder();\n \n     for (String line : lines) {\n       int pos = findIndexOfChar(line, SEPARATOR);\n           unescape(line.substring(0, pos)),\n           unescape(line.substring(pos + 1)));\n     }\n-    return new VariableMap(map);\n+    return new VariableMap(map.build());\n   }\n \n   private static String escape(String value) {\n    *   object.\n    */\n   public static VariableMap fromMap(Map<String, String> map) {\n-    return new VariableMap(Maps.newHashMap(map));\n+    return new VariableMap(map);\n   }\n \n   @VisibleForTesting\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n import com.google.javascript.rhino.Node;\n \n import java.util.*;\n   private String prefix = DEFAULT_PREFIX;\n \n   private VariableMap previouslyUsedMap =\n-      new VariableMap(new HashMap<String, String>());\n+      new VariableMap(ImmutableMap.<String, String>of());\n   private RenameVars renameVars;\n   private boolean withClosurePass = false;\n   private boolean localRenamingOnly = false;\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    previouslyUsedMap = new VariableMap(new HashMap<String, String>());\n+    previouslyUsedMap = new VariableMap(ImmutableMap.<String, String>of());\n     prefix = DEFAULT_PREFIX;\n     withClosurePass = false;\n     localRenamingOnly = false;\n   private VariableMap makeVariableMap(String... keyValPairs) {\n     Preconditions.checkArgument(keyValPairs.length % 2 == 0);\n \n-    Map<String, String> renameMap = new HashMap<String, String>();\n+    ImmutableMap.Builder<String, String> renameMap = ImmutableMap.builder();\n     for (int i = 0; i < keyValPairs.length; i += 2) {\n       renameMap.put(keyValPairs[i], keyValPairs[i + 1]);\n     }\n \n-    return new VariableMap(renameMap);\n+    return new VariableMap(renameMap.build());\n   }\n \n   private static void assertVariableMapsEqual(VariableMap a, VariableMap b) {\n--- a/test/com/google/javascript/jscomp/VariableMapTest.java\n+++ b/test/com/google/javascript/jscomp/VariableMapTest.java\n     cycleTest(ImmutableMap.of(\"AAA\", \"a:a\", \"BBB\", \"b:b\"));\n   }\n \n-  public void cycleTest(Map<String, String> map) throws ParseException {\n+  public void cycleTest(ImmutableMap<String, String> map)\n+      throws ParseException {\n     VariableMap in = new VariableMap(map);\n     String serialized = new String(in.toBytes(), Charsets.UTF_8);\n     VariableMap out = VariableMap.fromBytes(serialized.getBytes());", "timestamp": 1350925112, "metainfo": ""}