{"sha": "05920e53098c1e924113a5143b01bd8a9b7df980", "log": "No code changes! This is just some proofreading of the comments as I read some of the source files. Let me know if I butchered anything.  R=acleung DELTA=25  (0 added, 1 deleted, 24 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5909   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n \n   /**\n    * Abstract callback to visit a control flow graph node without going into\n-   * subtrees of the node that is also represented by another control flow graph\n-   * node.\n-   *\n-   * <p>For example, traversing an IF node as root will visit the two subtree\n+   * subtrees of the node that are also represented by other\n+   * control flow graph nodes.\n+   *\n+   * <p>For example, traversing an IF node as root will visit the two subtrees\n    * pointed by the {@link ControlFlowGraph.Branch#ON_TRUE} and\n-   * {@link ControlFlowGraph.Branch#ON_FALSE} edge.\n+   * {@link ControlFlowGraph.Branch#ON_FALSE} edges.\n    */\n   public abstract static class AbstractCfgNodeTraversalCallback implements\n       Callback {\n         return true;\n       case Token.FUNCTION:\n         // A function node represents the start of a function where the name\n-        // is bleed into the local scope and parameters has been assigned\n+        // bleeds into the local scope and parameters are assigned\n         // to the formal argument names. The node includes the name of the\n         // function and the LP list since we assume the whole set up process\n         // is atomic without change in control flow. The next change of\n-        // control is going into the function's body represent by the second\n+        // control is going into the function's body, represented by the second\n         // child.\n         return n != parent.getFirstChild().getNext();\n       case Token.WHILE:\n       case Token.DO:\n       case Token.IF:\n-        // Theses control structure is represented by its node that holds the\n+        // These control structures are represented by a node that holds the\n         // condition. Each of them is a branch node based on its condition.\n         return NodeUtil.getConditionExpression(parent) != n;\n \n       case Token.FOR:\n-        // The FOR(;;) node differs from other control structure in that\n-        // it has a initialization and a increment statement. Those\n-        // two statements have its corresponding CFG nodes to represent them.\n-        // The FOR node represents the condition check for each iteration.\n+        // The FOR(;;) node differs from other control structures in that\n+        // it has an initialization and an increment statement. Those\n+        // two statements have corresponding CFG nodes to represent them.\n+        // The FOR node only represents the condition check for each iteration.\n         // That way the following:\n         // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n         // var x = 0; while(x<10) {  x++; }\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n   }\n \n   /**\n-   * Tries to remove n if an unconditional branch node (break, continue or\n-   * return) if the target of n is the same as the the follow of n. That is, if\n-   * we remove n, the control flow remains the same. Also if n targets to\n+   * Tries to remove n if it is an unconditional branch node (break, continue,\n+   * or return) and the target of n is the same as the the follow of n.\n+   * That is, if removing n preserves the control flow. Also if n targets\n    * another unconditional branch, this function will recursively try to remove\n    * the target branch as well. The reason why we want to cascade this removal\n    * is because we only run this pass once. If we have code such as\n    *\n    * break -> break -> break\n    *\n-   * where all 3 break's are useless. The order of removal matters. When we\n+   * where all 3 breaks are useless, then the order of removal matters. When we\n    * first look at the first break, we see that it branches to the 2nd break.\n    * However, if we remove the last break, the 2nd break becomes useless and\n    * finally the first break becomes useless as well.\n   @SuppressWarnings(\"fallthrough\")\n   private Node tryRemoveUnconditionalBranching(Node n) {\n     /*\n-     * For each of the unconditional branching control flow node, check to see\n+     * For each unconditional branching control flow node, check to see\n      * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n      * the branching target. If it is, the branch node is safe to be removed.\n      *\n      * This is not as clever as MinimizeExitPoints because it doesn't do any\n      * if-else conversion but it handles more complicated switch statements\n-     * much nicer.\n+     * much more nicely.\n      */\n \n     // If n is null the target is the end of the function, nothing to do.\n       case Token.CONTINUE:\n \n         // We are looking for a control flow changing statement that always\n-        // branches to the same node. If removing it the control flow still\n-        // branches to that same node. It is safe to remove it.\n+        // branches to the same node. If after removing it control still\n+        // branches to the same node, it is safe to remove.\n         List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n         if (outEdges.size() == 1 &&\n             // If there is a next node, there is no chance this jump is useless.\n       return;\n     }\n \n-    // TODO(user): This is a problem with removeNoOpStatements. Everything\n-    // every expression in a FOR-IN header looks like side effect free on it's\n-    // own.\n+    // TODO(user): This is a problem with removeNoOpStatements.\n+    // Every expression in a FOR-IN header looks side effect free on its own.\n     if (NodeUtil.isForIn(parent)) {\n       return;\n     }\n     switch (n.getType()) {\n       // Removing an unreachable DO node is messy because it means we still have\n       // to execute one iteration. If the DO's body has breaks in the middle, it\n-      // can get even more trickier and code size might actually increase.\n+      // can get even more tricky and code size might actually increase.\n       case Token.DO:\n         return;\n \n       // The node var x is unreachable in the global scope.\n       // Before we remove the node, redeclareVarsInsideBranch\n       // would basically move var x to the beginning of File 2,\n-      // which resulted in zero change in the AST but triggered\n+      // which resulted in zero changes to the AST but triggered\n       // reportCodeChange().\n       // Instead, we should just ignore dead variable declarations.\n       return;", "timestamp": 1354318590, "metainfo": ""}