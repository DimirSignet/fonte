{"sha": "d7ccbafcd3fcd21f682a88ffa0eee441eee56930", "log": "fix a weird edge case compiler crash  R=johnlenz DELTA=18  (13 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4014   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n             String name = dest.getString();\n             Property prop = new AssignmentProperty(\n                 grandParent,\n-                t.getScope().getVar(root.getString()),\n+                maybeGetVar(t, root),\n                 t.getModule());\n             getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n             return true;\n           if (map.isObjectLit()) {\n             for (Node key = map.getFirstChild();\n                  key != null; key = key.getNext()) {\n-              // May be STRING, GET, or SET,\n+              // May be STRING, GETTER_DEF, or SETTER_DEF,\n               String name = key.getString();\n               Property prop = new LiteralProperty(\n                   key, key.getFirstChild(), map, n,\n-                  t.getScope().getVar(root.getString()),\n+                  maybeGetVar(t, root),\n                   t.getModule());\n               getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n             }\n           break;\n       }\n       return false;\n+    }\n+\n+    private Var maybeGetVar(NodeTraversal t, Node maybeName) {\n+      return maybeName.isName()\n+          ? t.getScope().getVar(maybeName.getString()) : null;\n     }\n \n     private void addGlobalUseOfSymbol(String name, JSModule module,\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n         // We should only move a property across modules if:\n         // 1) We can move it deeper in the module graph, and\n         // 2) it's a function, and\n-        // 3) it is not a get or a set, and\n+        // 3) it is not a GETTER_DEF or a SETTER_DEF, and\n         // 4) the class is available in the global scope.\n         //\n         // #1 should be obvious. #2 is more subtle. It's possible\n         // So if we move a prototype method into a deeper module, we must\n         // replace it with a stub function so that it preserves its original\n         // behavior.\n-        if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) {\n+        if (prop.getRootVar() == null || !prop.getRootVar().isGlobal()) {\n           continue;\n         }\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       final boolean late = false;\n       return new PeepholeOptimizationsPass(compiler,\n             new PeepholeSubstituteAlternateSyntax(late),\n-            new PeepholeReplaceKnownMethods(late),\n+            new PeepholeReplaceKnownMethods(),\n             new PeepholeRemoveDeadCode(),\n             new PeepholeFoldConstants(late),\n             new PeepholeCollectPropertyAssignments());\n             new StatementFusion(),\n             new PeepholeRemoveDeadCode(),\n             new PeepholeSubstituteAlternateSyntax(late),\n-            new PeepholeReplaceKnownMethods(late),\n+            new PeepholeReplaceKnownMethods(),\n             new PeepholeFoldConstants(late),\n             new ReorderConstantExpression());\n     }\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n import com.google.javascript.rhino.Node;\n import java.util.List;\n import java.util.Locale;\n-import java.util.regex.Pattern;\n \n /**\n  * Just to fold known methods when they are called with constants.\n \n   // The LOCALE independent \"locale\"\n   private static final Locale ROOT_LOCALE = new Locale(\"\");\n-  private final boolean late;\n-\n-  /**\n-   * @param late When late is true, this mean we are currently running after\n-   * most of the other optimizations. In this case we avoid changes that make\n-   * the code larger (but otherwise easier to analyze - such as using string\n-   * splitting).\n-   */\n-  PeepholeReplaceKnownMethods(boolean late) {\n-    this.late = late;\n-  }\n-  \n+\n   @Override\n   Node optimizeSubtree(Node subtree) {\n     if (subtree.isCall() ){\n \n     String functionNameString = functionName.getString();\n     Node firstArg = callTarget.getNext();\n-    if (functionNameString.equals(\"split\")) {\n-      subtree = tryFoldStringSplit(subtree, stringNode, firstArg);\n-    } else if (firstArg == null) {\n+    if (firstArg == null) {\n       if (functionNameString.equals(\"toLowerCase\")) {\n         subtree = tryFoldStringToLowerCase(subtree, stringNode);\n       } else if (functionNameString.equals(\"toUpperCase\")) {\n     reportCodeChange();\n     return resultNode;\n   }\n-  \n-  /**\n-   * Try to fold .split() calls on strings\n-   */\n-  private Node tryFoldStringSplit(Node n, Node stringNode, Node arg1) {\n-    if (late) {\n-      return n;\n-    }\n-    \n-    Preconditions.checkArgument(n.isCall());\n-    Preconditions.checkArgument(stringNode.isString());\n-\n-    String separator = null;\n-    String stringValue = stringNode.getString();\n-    int limit = stringValue.length();\n-\n-    if (arg1 != null) {\n-      if (arg1.isString()) {\n-        separator = arg1.getString();\n-      } else if (!arg1.isNull()) {\n-        return n;\n-      }\n-      \n-      Node arg2 = arg1.getNext();\n-      if (arg2 != null) {\n-        if (arg2.isNumber()) {\n-          limit = (int) arg2.getDouble();\n-          if (limit < 0) {\n-            return n;\n-          }\n-        } else {\n-          return n;\n-        }\n-      }\n-    }\n-    \n-    String[] stringArray;\n-    if (separator != null) {\n-      stringArray = stringValue.split(Pattern.quote(separator));\n-    } else {\n-      stringArray = new String[1];\n-      stringArray[0] = stringValue;\n-    }\n-    \n-    Node arrayOfStrings = IR.arraylit();\n-    for (int i = 0; i < limit && i < stringArray.length; i++) {\n-      arrayOfStrings.addChildToBack(\n-          IR.string(stringArray[i]).srcref(stringNode));\n-    }\n-    \n-    Node parent = n.getParent();\n-    parent.replaceChild(n, arrayOfStrings);\n-    reportCodeChange();\n-    return arrayOfStrings;\n- }\n }\n--- a/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n             \"})();\"));\n   }\n \n+  public void testPrototypeOfThisAssign() {\n+    testSame(\n+        createModuleChain(\n+            \"/** @constructor */\" +\n+            \"function F() {}\" +\n+            \"this.prototype.foo = function() {};\",\n+            \"(new F()).foo();\"));\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n  */\n public class PeepholeReplaceKnownMethodsTest extends CompilerTestCase {\n \n-  private boolean late = true;\n-  \n   public PeepholeReplaceKnownMethodsTest() {\n     super(\"\");\n   }\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler,\n-          new PeepholeReplaceKnownMethods(late));\n+          new PeepholeReplaceKnownMethods());\n     return peepholePass;\n   }\n \n     fold(\"x = '\\\\ud834\\udd1e'.charCodeAt(0)\", \"x = 55348\");\n     fold(\"x = '\\\\ud834\\udd1e'.charCodeAt(1)\", \"x = 56606\");\n   }\n-  \n-  public void testFoldStringSplit() {\n-    late = false;\n-    fold(\"x = 'abcde'.split()\", \"x = ['abcde']\");\n-    fold(\"x = 'abcde'.split(null)\", \"x = ['abcde']\");\n-    fold(\"x = 'a b c d e'.split(' ')\", \"x = ['a','b','c','d','e']\");\n-    fold(\"x = 'a b c d e'.split(' ', 0)\", \"x = []\");\n-    fold(\"x = 'abcde'.split('cd')\", \"x = ['ab','e']\");\n-    fold(\"x = 'a b c d e'.split(' ', 1)\", \"x = ['a']\");\n-    fold(\"x = 'a b c d e'.split(' ', 3)\", \"x = ['a','b','c']\");\n-    fold(\"x = 'a b c d e'.split(null, 1)\", \"x = ['a b c d e']\");\n-    foldSame(\"x = 'abcde'.split(/ /)\");\n-    foldSame(\"x = 'abcde'.split(' ', -1)\");\n-    \n-    late = true;\n-    foldSame(\"x = 'a b c d e'.split(' ')\");\n-  }\n \n   public void testJoinBug() {\n     fold(\"var x = [].join();\", \"var x = '';\");", "timestamp": 1324491775, "metainfo": ""}