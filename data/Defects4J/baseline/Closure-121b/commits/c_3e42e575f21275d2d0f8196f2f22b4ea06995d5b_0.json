{"sha": "3e42e575f21275d2d0f8196f2f22b4ea06995d5b", "log": "Make CommandLineRunner more extensible Fixes issue 353. Contributed by Ibrahim Chaehoi  Revision created by MOE tool push_codebase.  R=johnlenz DELTA=45  (30 added, 2 deleted, 13 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=679   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   /**\n    * An exception thrown when command-line flags are used incorrectly.\n    */\n-  protected static class FlagUsageException extends Exception {\n+  public static class FlagUsageException extends Exception {\n     private static final long serialVersionUID = 1L;\n \n-    FlagUsageException(String message) {\n+    public FlagUsageException(String message) {\n       super(message);\n     }\n   }\n \n   /**\n    * Creates inputs from a list of files.\n+   *\n+   * Can be overridden by subclasses who want to pull files from different\n+   * places.\n    *\n    * @param files A list of filenames\n    * @param allowStdIn Whether '-' is allowed appear as a filename to represent\n    *        stdin. If true, '-' is only allowed to appear once.\n    * @return An array of inputs\n    */\n-  private List<JSSourceFile> createInputs(List<String> files,\n+  protected List<JSSourceFile> createInputs(List<String> files,\n       boolean allowStdIn) throws FlagUsageException, IOException {\n     List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size());\n     boolean usingStdin = false;\n \n       // Parse module name.\n       String name = parts[0];\n-      if (!TokenStream.isJSIdentifier(name)) {\n-        throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\");\n-      }\n+      checkModuleName(name);\n       if (modulesByName.containsKey(name)) {\n-        throw new FlagUsageException(\"Duplicate module name: \" + name);\n-      }\n+              throw new FlagUsageException(\"Duplicate module name: \" + name);\n+          }\n       JSModule module = new JSModule(name);\n \n       // Parse module inputs.\n   }\n \n   /**\n+   * Validates the module name. Can be overridden by subclasses.\n+   * @param name The module name\n+   * @throws FlagUsageException if the validation fails\n+   */\n+  protected void checkModuleName(String name)\n+      throws FlagUsageException {\n+    if (!TokenStream.isJSIdentifier(name)) {\n+      throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\");\n+    }\n+  }\n+\n+  /**\n    * Parses module wrapper specifications.\n    *\n    * @param specs A list of module wrapper specifications, not null. The spec\n             compiler.getSourceMap().reset();\n           }\n \n-          writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(\n-              m.getName()), \"%s\");\n+          writeOutput(writer, compiler, compiler.toSource(m),\n+              moduleWrappers.get(m.getName()), \"%s\");\n \n           if (options.sourceMapOutputPath != null) {\n             compiler.getSourceMap().appendTo(mapOut, m.getName());\n    *\n    * 1) Single js output, single extra output: sub in jsOutputPath.\n    * 2) Multiple js output, single extra output: sub in the base module name.\n-   * 3) Multiple js output, multiple extra output: sub in the module output file.\n+   * 3) Multiple js output, multiple extra output: sub in the module output\n+   *    file.\n    *\n    * Passing a JSModule to this function automatically triggers case #3.\n    * Otherwise, we'll use strategy #1 or #2 based on the current output mode.\n   }\n \n   /**\n-   * Converts a file name into a Writer.\n+   * Converts a file name into a Writer taking in account the output charset.\n    * Returns null if the file name is null.\n    */\n   private Writer fileNameToOutputWriter(String fileName) throws IOException {\n     if (testMode) {\n       return new StringWriter();\n     }\n-    return streamToOutputWriter(new FileOutputStream(fileName));\n+\n+    return streamToOutputWriter(filenameToOutputStream(fileName));\n+  }\n+\n+  /**\n+   * Converts a file name into a Ouputstream.\n+   * Returns null if the file name is null.\n+   */\n+  protected OutputStream filenameToOutputStream(String fileName)\n+      throws IOException {\n+    if (fileName == null){\n+      return null;\n+    }\n+    return new FileOutputStream(fileName);\n   }\n \n   /**\n \n     if (functionInformationMapOutputPath != null) {\n       if (compiler.getFunctionalInformationMap() != null) {\n-        FileOutputStream file =\n-            new FileOutputStream(functionInformationMapOutputPath);\n+        OutputStream file =\n+            filenameToOutputStream(functionInformationMapOutputPath);\n         CodedOutputStream outputStream = CodedOutputStream.newInstance(file);\n         compiler.getFunctionalInformationMap().writeTo(outputStream);\n         outputStream.flush();\n     }\n \n     private TweakProcessing tweakProcessing = TweakProcessing.OFF;\n-    \n+\n     /**\n      * Sets the kind of processing to do for goog.tweak functions.\n      */", "timestamp": 1298665406, "metainfo": ""}