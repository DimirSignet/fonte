{"sha": "82d0521b5e282a7f36ea3d8ec6a3c0f50b8b8024", "log": "Sync rhino master branch from head. http://code.google.com/p/closure-compiler-rhino/ describes the merge history of this project in more detail  R=acleung   Revision created by MOE tool push_codebase. MOE_MIGRATION=4410   ", "commit": "\n--- a/lib/rhino/src/org/mozilla/javascript/BoundFunction.java\n+++ b/lib/rhino/src/org/mozilla/javascript/BoundFunction.java\n  * EcmaScript 5 spec, 15.3.4.5\n  */\n public class BoundFunction extends BaseFunction {\n+\n+  static final long serialVersionUID = 2118137342826470729L;\n+\n   private final Callable targetFunction;\n   private final Scriptable boundThis;\n   private final Object[] boundArgs;\n--- a/lib/rhino/src/org/mozilla/javascript/CompilerEnvirons.java\n+++ b/lib/rhino/src/org/mozilla/javascript/CompilerEnvirons.java\n      * instruction thresholds\n      */\n     public boolean isGenerateObserverCount() {\n-    \treturn generateObserverCount;\n-    }\n-\n-   /**\n+        return generateObserverCount;\n+    }\n+\n+    /**\n      * Turn on or off generation of code with callbacks to\n      * track the count of executed instructions.\n      * Currently only affects JVM byte code generation: this slows down the\n      * The {@link ErrorReporter} is set to an {@link ErrorCollector}.\n      */\n     public static CompilerEnvirons ideEnvirons() {\n-      CompilerEnvirons env = new CompilerEnvirons();\n-      env.setRecoverFromErrors(true);\n-      env.setRecordingComments(true);\n-      env.setStrictMode(true);\n-      env.setWarnTrailingComma(true);\n-      env.setLanguageVersion(170);\n-      env.setReservedKeywordAsIdentifier(true);\n-      env.setAllowKeywordAsObjectPropertyName(true);\n-      env.setIdeMode(true);\n-      env.setErrorReporter(new ErrorCollector());\n-      return env;\n+        CompilerEnvirons env = new CompilerEnvirons();\n+        env.setRecoverFromErrors(true);\n+        env.setRecordingComments(true);\n+        env.setStrictMode(true);\n+        env.setWarnTrailingComma(true);\n+        env.setLanguageVersion(170);\n+        env.setReservedKeywordAsIdentifier(true);\n+        env.setAllowKeywordAsObjectPropertyName(true);\n+        env.setIdeMode(true);\n+        env.setErrorReporter(new ErrorCollector());\n+        return env;\n     }\n \n     private ErrorReporter errorReporter;\n--- a/lib/rhino/src/org/mozilla/javascript/ConsString.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ConsString.java\n \n package org.mozilla.javascript;\n \n+import java.io.Serializable;\n+\n /**\n  * <p>This class represents a string composed of two components, each of which\n  * may be a <code>java.lang.String</code> or another ConsString.</p>\n  *\n  * <p>Both the name and the concept are borrowed from V8.</p>\n  */\n-public class ConsString implements CharSequence {\n+public class ConsString implements CharSequence, Serializable {\n+\n+    private static final long serialVersionUID = -8432806714471372570L;\n \n     private CharSequence s1, s2;\n     private final int length;\n         }\n     }\n \n+    // Replace with string representation when serializing\n+    private Object writeReplace() {\n+        return this.toString();\n+    }\n+    \n     public String toString() {\n         return depth == 0 ? (String)s1 : flatten();\n     }\n--- a/lib/rhino/src/org/mozilla/javascript/IRFactory.java\n+++ b/lib/rhino/src/org/mozilla/javascript/IRFactory.java\n  * Contributor(s):\n  *   Norris Boyd\n  *   Igor Bukanov\n+ *   Travis Ennis\n  *   Ethan Hugg\n  *   Bob Jervis\n  *   Terry Lucas\n               }\n           case Token.FUNCTION:\n               return transformFunction((FunctionNode)node);\n+          case Token.GENEXPR:\n+              return transformGenExpr((GeneratorExpression)node);\n           case Token.GETELEM:\n               return transformElementGet((ElementGet)node);\n           case Token.GETPROP:\n         return call;\n     }\n \n+    private Node transformGenExpr(GeneratorExpression node) {\n+        Node pn;\n+\n+        FunctionNode fn = new FunctionNode();\n+        fn.setSourceName(currentScriptOrFn.getNextTempName());\n+        fn.setIsGenerator();\n+        fn.setFunctionType(FunctionNode.FUNCTION_EXPRESSION);\n+        fn.setRequiresActivation();\n+\n+        int functionType = fn.getFunctionType();\n+        int start = decompiler.markFunctionStart(functionType);\n+        Node mexpr = decompileFunctionHeader(fn);\n+        int index = currentScriptOrFn.addFunction(fn);\n+\n+        PerFunctionVariables savedVars = new PerFunctionVariables(fn);\n+        try {\n+            // If we start needing to record much more codegen metadata during\n+            // function parsing, we should lump it all into a helper class.\n+            Node destructuring = (Node)fn.getProp(Node.DESTRUCTURING_PARAMS);\n+            fn.removeProp(Node.DESTRUCTURING_PARAMS);\n+\n+            int lineno = node.lineno;\n+            ++nestingOfFunction;  // only for body, not params\n+            Node body = genExprTransformHelper(node);\n+\n+            if (!fn.isExpressionClosure()) {\n+                decompiler.addToken(Token.RC);\n+            }\n+            fn.setEncodedSourceBounds(start, decompiler.markFunctionEnd(start));\n+\n+            if (functionType != FunctionNode.FUNCTION_EXPRESSION && !fn.isExpressionClosure()) {\n+                // Add EOL only if function is not part of expression\n+                // since it gets SEMI + EOL from Statement in that case\n+                decompiler.addToken(Token.EOL);\n+            }\n+\n+            if (destructuring != null) {\n+                body.addChildToFront(new Node(Token.EXPR_VOID,\n+                                              destructuring, lineno));\n+            }\n+\n+            int syntheticType = fn.getFunctionType();\n+            pn = initFunction(fn, index, body, syntheticType);\n+            if (mexpr != null) {\n+                pn = createAssignment(Token.ASSIGN, mexpr, pn);\n+                if (syntheticType != FunctionNode.FUNCTION_EXPRESSION) {\n+                    pn = createExprStatementNoReturn(pn, fn.getLineno());\n+                }\n+            }\n+        } finally {\n+            --nestingOfFunction;\n+            savedVars.restore();\n+        }\n+\n+        Node call = createCallOrNew(Token.CALL, pn);\n+        call.setLineno(node.getLineno());\n+        decompiler.addToken(Token.LP);\n+        decompiler.addToken(Token.RP);\n+        return call;\n+    }\n+\n+    private Node genExprTransformHelper(GeneratorExpression node) {\n+        decompiler.addToken(Token.LP);\n+        int lineno = node.getLineno();\n+        Node expr = transform(node.getResult());\n+\n+        List<GeneratorExpressionLoop> loops = node.getLoops();\n+        int numLoops = loops.size();\n+\n+        // Walk through loops, collecting and defining their iterator symbols.\n+        Node[] iterators = new Node[numLoops];\n+        Node[] iteratedObjs = new Node[numLoops];\n+\n+        for (int i = 0; i < numLoops; i++) {\n+            GeneratorExpressionLoop acl = loops.get(i);\n+            decompiler.addName(\" \");\n+            decompiler.addToken(Token.FOR);\n+            decompiler.addToken(Token.LP);\n+\n+            AstNode iter = acl.getIterator();\n+            String name = null;\n+            if (iter.getType() == Token.NAME) {\n+                name = iter.getString();\n+                decompiler.addName(name);\n+            } else {\n+                // destructuring assignment\n+                decompile(iter);\n+                name = currentScriptOrFn.getNextTempName();\n+                defineSymbol(Token.LP, name, false);\n+                expr = createBinary(Token.COMMA,\n+                                    createAssignment(Token.ASSIGN,\n+                                                     iter,\n+                                                     createName(name)),\n+                                    expr);\n+            }\n+            Node init = createName(name);\n+            // Define as a let since we want the scope of the variable to\n+            // be restricted to the array comprehension\n+            defineSymbol(Token.LET, name, false);\n+            iterators[i] = init;\n+\n+            decompiler.addToken(Token.IN);\n+            iteratedObjs[i] = transform(acl.getIteratedObject());\n+            decompiler.addToken(Token.RP);\n+        }\n+\n+        // generate code for tmpArray.push(body)\n+        Node yield = new Node(Token.YIELD, expr, node.getLineno());\n+\n+        Node body = new Node(Token.EXPR_VOID, yield, lineno);\n+\n+        if (node.getFilter() != null) {\n+            decompiler.addName(\" \");\n+            decompiler.addToken(Token.IF);\n+            decompiler.addToken(Token.LP);\n+            body = createIf(transform(node.getFilter()), body, null, lineno);\n+            decompiler.addToken(Token.RP);\n+        }\n+\n+        // Now walk loops in reverse to build up the body statement.\n+        int pushed = 0;\n+        try {\n+            for (int i = numLoops-1; i >= 0; i--) {\n+                GeneratorExpressionLoop acl = loops.get(i);\n+                Scope loop = createLoopNode(null,  // no label\n+                                            acl.getLineno());\n+                pushScope(loop);\n+                pushed++;\n+                body = createForIn(Token.LET,\n+                                   loop,\n+                                   iterators[i],\n+                                   iteratedObjs[i],\n+                                   body,\n+                                   acl.isForEach());\n+            }\n+        } finally {\n+            for (int i = 0; i < pushed; i++) {\n+                popScope();\n+            }\n+        }\n+\n+        decompiler.addToken(Token.RP);\n+\n+        return body;\n+    }\n+\n     private Node transformIf(IfStatement n) {\n         decompiler.addToken(Token.IF);\n         decompiler.addToken(Token.LP);\n     }\n \n     private Node transformReturn(ReturnStatement node) {\n-        if (Boolean.TRUE.equals(node.getProp(Node.EXPRESSION_CLOSURE_PROP))) {\n+        boolean expClosure = Boolean.TRUE.equals(node.getProp(Node.EXPRESSION_CLOSURE_PROP));\n+        if (expClosure) {\n             decompiler.addName(\" \");\n         } else {\n             decompiler.addToken(Token.RETURN);\n         }\n         AstNode rv = node.getReturnValue();\n         Node value = rv == null ? null : transform(rv);\n-        decompiler.addEOL(Token.SEMI);\n+        if (!expClosure) decompiler.addEOL(Token.SEMI);\n         return rv == null\n             ? new Node(Token.RETURN, node.getLineno())\n             : new Node(Token.RETURN, value, node.getLineno());\n                 Node ref = child.getFirstChild();\n                 child.removeChild(ref);\n                 n = new Node(Token.DEL_REF, ref);\n-            } else if (childType == Token.CALL) {\n+            } else {\n+                // Always evaluate delete operand, see ES5 11.4.1 & bug #726121\n                 n = new Node(nodeType, new Node(Token.TRUE), child);\n-            } else {\n-                n = new Node(Token.TRUE);\n             }\n             return n;\n           }\n           case Token.GETELEM:\n               decompileElementGet((ElementGet) node);\n               break;\n+          case Token.THIS:\n+              decompiler.addToken(node.getType());\n+              break;\n           default:\n               Kit.codeBug(\"unexpected token: \"\n                           + Token.typeToName(node.getType()));\n--- a/lib/rhino/src/org/mozilla/javascript/IdFunctionObject.java\n+++ b/lib/rhino/src/org/mozilla/javascript/IdFunctionObject.java\n \n     public final boolean hasTag(Object tag)\n     {\n-        return this.tag == tag;\n+        return tag == null ? this.tag == null : tag.equals(this.tag);\n     }\n \n     public final int methodId()\n--- a/lib/rhino/src/org/mozilla/javascript/InterfaceAdapter.java\n+++ b/lib/rhino/src/org/mozilla/javascript/InterfaceAdapter.java\n      * @return The glue object or null if <tt>cl</tt> is not interface or\n      *         has methods with different signatures.\n      */\n-    static Object create(Context cx, Class<?> cl, Callable function)\n+    static Object create(Context cx, Class<?> cl, ScriptableObject object)\n     {\n         if (!cl.isInterface()) throw new IllegalArgumentException();\n \n         ContextFactory cf = cx.getFactory();\n         if (adapter == null) {\n             Method[] methods = cl.getMethods();\n-            if (methods.length == 0) {\n-                throw Context.reportRuntimeError2(\n-                    \"msg.no.empty.interface.conversion\",\n-                    String.valueOf(function),\n-                    cl.getClass().getName());\n-            }\n-            boolean canCallFunction = false;\n-          canCallFunctionChecks: {\n-                Class<?>[] argTypes = methods[0].getParameterTypes();\n-                // check that the rest of methods has the same signature\n-                for (int i = 1; i != methods.length; ++i) {\n-                    Class<?>[] types2 = methods[i].getParameterTypes();\n-                    if (types2.length != argTypes.length) {\n-                        break canCallFunctionChecks;\n-                    }\n-                    for (int j = 0; j != argTypes.length; ++j) {\n-                        if (types2[j] != argTypes[j]) {\n-                            break canCallFunctionChecks;\n+            if ( object instanceof Callable) {\n+                // Check if interface can be implemented by a single function.\n+                // We allow this if the interface has only one method or multiple \n+                // methods with the same name (in which case they'd result in \n+                // the same function to be invoked anyway).\n+                int length = methods.length;\n+                if (length == 0) {\n+                    throw Context.reportRuntimeError1(\n+                        \"msg.no.empty.interface.conversion\", cl.getName());\n+                }\n+                if (length > 1) {\n+                    String methodName = methods[0].getName();\n+                    for (int i = 1; i < length; i++) {\n+                        if (!methodName.equals(methods[i].getName())) {\n+                            throw Context.reportRuntimeError1(\n+                                    \"msg.no.function.interface.conversion\",\n+                                    cl.getName());\n                         }\n                     }\n                 }\n-                canCallFunction= true;\n-            }\n-            if (!canCallFunction) {\n-                throw Context.reportRuntimeError2(\n-                    \"msg.no.function.interface.conversion\",\n-                    String.valueOf(function),\n-                    cl.getClass().getName());\n             }\n             adapter = new InterfaceAdapter(cf, cl);\n             cache.cacheInterfaceAdapter(cl, adapter);\n         }\n         return VMBridge.instance.newInterfaceProxy(\n-            adapter.proxyHelper, cf, adapter, function, topScope);\n+            adapter.proxyHelper, cf, adapter, object, topScope);\n     }\n \n     private InterfaceAdapter(ContextFactory cf, Class<?> cl)\n     public Object invoke(ContextFactory cf,\n                          final Object target,\n                          final Scriptable topScope,\n+                         final Object thisObject,\n                          final Method method,\n                          final Object[] args)\n     {\n         ContextAction action = new ContextAction() {\n                 public Object run(Context cx)\n                 {\n-                    return invokeImpl(cx, target, topScope, method, args);\n+                    return invokeImpl(cx, target, topScope, thisObject, method, args);\n                 }\n             };\n         return cf.call(action);\n     Object invokeImpl(Context cx,\n                       Object target,\n                       Scriptable topScope,\n+                      Object thisObject,\n                       Method method,\n                       Object[] args)\n     {\n-        int N = (args == null) ? 0 : args.length;\n-\n-        Callable function = (Callable)target;\n-        Scriptable thisObj = topScope;\n-        Object[] jsargs = new Object[N + 1];\n-        jsargs[N] = method.getName();\n-        if (N != 0) {\n-            WrapFactory wf = cx.getWrapFactory();\n-            for (int i = 0; i != N; ++i) {\n-                jsargs[i] = wf.wrap(cx, topScope, args[i], null);\n+        Callable function;\n+        if (target instanceof Callable) {\n+            function = (Callable)target;\n+        } else {\n+            Scriptable s = (Scriptable)target;\n+            String methodName = method.getName();\n+            Object value = ScriptableObject.getProperty(s, methodName);\n+            if (value == ScriptableObject.NOT_FOUND) {\n+                // We really should throw an error here, but for the sake of\n+                // compatibility with JavaAdapter we silently ignore undefined\n+                // methods.\n+                Context.reportWarning(ScriptRuntime.getMessage1(\n+                        \"msg.undefined.function.interface\", methodName));\n+                Class<?> resultType = method.getReturnType();\n+                if (resultType == Void.TYPE) {\n+                    return null;\n+                } else {\n+                    return Context.jsToJava(null, resultType);\n+                }\n+            }\n+            if (!(value instanceof Callable)) {\n+                throw Context.reportRuntimeError1(\n+                        \"msg.not.function.interface\",methodName);\n+            }\n+            function = (Callable)value;\n+        }\n+        WrapFactory wf = cx.getWrapFactory();\n+        if (args == null) {\n+            args = ScriptRuntime.emptyArgs;\n+        } else {\n+            for (int i = 0, N = args.length; i != N; ++i) {\n+                Object arg = args[i];\n+                // neutralize wrap factory java primitive wrap feature\n+                if (!(arg instanceof String || arg instanceof Number\n+                        || arg instanceof Boolean)) {\n+                    args[i] = wf.wrap(cx, topScope, arg, null);\n+                }\n             }\n         }\n+        Scriptable thisObj = wf.wrapAsJavaObject(cx, topScope, thisObject, null);\n \n-        Object result = function.call(cx, topScope, thisObj, jsargs);\n+        Object result = function.call(cx, topScope, thisObj, args);\n         Class<?> javaResultType = method.getReturnType();\n         if (javaResultType == Void.TYPE) {\n             result = null;\n--- a/lib/rhino/src/org/mozilla/javascript/JavaAdapter.java\n+++ b/lib/rhino/src/org/mozilla/javascript/JavaAdapter.java\n         return Context.jsToJava(result, c);\n     }\n \n-    public static Scriptable createAdapterWrapper(Scriptable obj,\n-                                                  Object adapter)\n+    public static Scriptable createAdapterWrapper(Scriptable obj, Object adapter)\n     {\n         Scriptable scope = ScriptableObject.getTopLevelScope(obj);\n         NativeJavaObject res = new NativeJavaObject(scope, adapter, null, true);\n             throw ScriptRuntime.typeError0(\"msg.adapter.zero.args\");\n         }\n \n-        Class<?> superClass = null;\n-        Class<?>[] intfs = new Class[N - 1];\n-        int interfaceCount = 0;\n-        for (int i = 0; i != N - 1; ++i) {\n-            Object arg = args[i];\n+        // Expected arguments:\n+        // Any number of NativeJavaClass objects representing the super-class\n+        // and/or interfaces to implement, followed by one NativeObject providing\n+        // the implementation, followed by any number of arguments to pass on\n+        // to the (super-class) constructor.\n+\n+        int classCount;\n+        for (classCount = 0; classCount < N - 1; classCount++) {\n+            Object arg = args[classCount];\n+            // We explicitly test for NativeObject here since checking for\n+            // instanceof ScriptableObject or !(instanceof NativeJavaClass)\n+            // would fail for a Java class that isn't found in the class path\n+            // as NativeJavaPackage extends ScriptableObject.\n+            if (arg instanceof NativeObject) {\n+                break;\n+            }\n             if (!(arg instanceof NativeJavaClass)) {\n                 throw ScriptRuntime.typeError2(\"msg.not.java.class.arg\",\n-                                               String.valueOf(i),\n+                                               String.valueOf(classCount),\n                                                ScriptRuntime.toString(arg));\n             }\n-            Class<?> c = ((NativeJavaClass) arg).getClassObject();\n+        }\n+        Class<?> superClass = null;\n+        Class<?>[] intfs = new Class[classCount];\n+        int interfaceCount = 0;\n+        for (int i = 0; i < classCount; ++i) {\n+            Class<?> c = ((NativeJavaClass) args[i]).getClassObject();\n             if (!c.isInterface()) {\n                 if (superClass != null) {\n                     throw ScriptRuntime.typeError2(\"msg.only.one.super\",\n             }\n         }\n \n-        if (superClass == null)\n+        if (superClass == null) {\n             superClass = ScriptRuntime.ObjectClass;\n-\n+        }\n+        \n         Class<?>[] interfaces = new Class[interfaceCount];\n         System.arraycopy(intfs, 0, interfaces, 0, interfaceCount);\n-        Scriptable obj = ScriptRuntime.toObject(cx, scope, args[N - 1]);\n-\n-        Class<?> adapterClass = getAdapterClass(scope, superClass, interfaces,\n-                                             obj);\n-\n-        Class<?>[] ctorParms = {\n-            ScriptRuntime.ContextFactoryClass,\n-            ScriptRuntime.ScriptableClass\n-        };\n-        Object[] ctorArgs = { cx.getFactory(), obj };\n+        // next argument is implementation, must be scriptable\n+        Scriptable obj = ScriptableObject.ensureScriptable(args[classCount]);\n+\n+        Class<?> adapterClass = getAdapterClass(scope, superClass, interfaces, obj);\n+        Object adapter;\n+        \n+        int argsCount = N - classCount - 1;\n         try {\n-            Object adapter = adapterClass.getConstructor(ctorParms).\n-                                 newInstance(ctorArgs);\n+            if (argsCount > 0) {\n+                // Arguments contain parameters for super-class constructor.\n+                // We use the generic Java method lookup logic to find and\n+                // invoke the right constructor.\n+                Object[] ctorArgs = new Object[argsCount + 2];\n+                ctorArgs[0] = obj;\n+                ctorArgs[1] = cx.getFactory();\n+                System.arraycopy(args, classCount + 1, ctorArgs, 2, argsCount);\n+                // TODO: cache class wrapper?\n+                NativeJavaClass classWrapper = new NativeJavaClass(scope, adapterClass);\n+                NativeJavaMethod ctors = classWrapper.members.ctors;\n+                int index = ctors.findCachedFunction(cx, ctorArgs);\n+                if (index < 0) {\n+                    String sig = NativeJavaMethod.scriptSignature(args);\n+                    throw Context.reportRuntimeError2(\n+                            \"msg.no.java.ctor\", adapterClass.getName(), sig);\n+                }\n+\n+                // Found the constructor, so try invoking it.\n+                adapter = NativeJavaClass.constructInternal(ctorArgs, ctors.methods[index]);\n+            } else {\n+                Class<?>[] ctorParms = {\n+                        ScriptRuntime.ScriptableClass,\n+                        ScriptRuntime.ContextFactoryClass\n+                };\n+                Object[] ctorArgs = { obj, cx.getFactory() };\n+                adapter = adapterClass.getConstructor(ctorParms).newInstance(ctorArgs);\n+            }\n+\n             Object self = getAdapterSelf(adapterClass, adapter);\n             // Return unwrapped JavaAdapter if it implements Scriptable\n             if (self instanceof Wrapper) {\n     }\n \n     private static Class<?> getAdapterClass(Scriptable scope, Class<?> superClass,\n-                                         Class<?>[] interfaces, Scriptable obj)\n+                                            Class<?>[] interfaces, Scriptable obj)\n     {\n         ClassCache cache = ClassCache.get(scope);\n         Map<JavaAdapterSignature,Class<?>> generated\n         sig = new JavaAdapterSignature(superClass, interfaces, names);\n         Class<?> adapterClass = generated.get(sig);\n         if (adapterClass == null) {\n-            String adapterName = \"adapter\"\n-                                 + cache.newClassSerialNumber();\n+            String adapterName = \"adapter\" + cache.newClassSerialNumber();\n             byte[] code = createAdapterCode(names, adapterName,\n                                             superClass, interfaces, null);\n \n         }\n \n         String superName = superClass.getName().replace('.', '/');\n-        generateCtor(cfw, adapterName, superName);\n+        Constructor<?>[] ctors = superClass.getConstructors();\n+        for (Constructor<?> ctor : ctors) {\n+            generateCtor(cfw, adapterName, superName, ctor);\n+        }\n         generateSerialCtor(cfw, adapterName, superName);\n-        if (scriptClassName != null)\n+        if (scriptClassName != null) {\n             generateEmptyCtor(cfw, adapterName, superName, scriptClassName);\n+        }\n \n         ObjToIntMap generatedOverrides = new ObjToIntMap();\n         ObjToIntMap generatedMethods = new ObjToIntMap();\n     }\n \n     private static void generateCtor(ClassFileWriter cfw, String adapterName,\n-                                     String superName)\n-    {\n-        cfw.startMethod(\"<init>\",\n-                        \"(Lorg/mozilla/javascript/ContextFactory;\"\n-                        +\"Lorg/mozilla/javascript/Scriptable;)V\",\n+                                     String superName, Constructor<?> superCtor)\n+    {\n+        short locals = 3; // this + factory + delegee\n+        Class<?>[] parameters = superCtor.getParameterTypes();\n+\n+        // Note that we swapped arguments in app-facing constructors to avoid\n+        // conflicting signatures with serial constructor defined below.\n+        if (parameters.length == 0) {\n+            cfw.startMethod(\"<init>\",\n+                        \"(Lorg/mozilla/javascript/Scriptable;\"\n+                        +\"Lorg/mozilla/javascript/ContextFactory;)V\",\n                         ClassFileWriter.ACC_PUBLIC);\n \n-        // Invoke base class constructor\n+            // Invoke base class constructor\n+            cfw.add(ByteCode.ALOAD_0);  // this\n+            cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, \"<init>\", \"()V\");\n+        } else {\n+            StringBuilder sig = new StringBuilder(\n+                    \"(Lorg/mozilla/javascript/Scriptable;\"\n+                    +\"Lorg/mozilla/javascript/ContextFactory;\");\n+            int marker = sig.length(); // lets us reuse buffer for super signature\n+            for (Class<?> c : parameters) {\n+                appendTypeString(sig, c);\n+            }\n+            sig.append(\")V\");\n+            cfw.startMethod(\"<init>\", sig.toString(), ClassFileWriter.ACC_PUBLIC);\n+\n+            // Invoke base class constructor\n+            cfw.add(ByteCode.ALOAD_0);  // this\n+            short paramOffset = 3;\n+            for (Class<?> parameter : parameters) {\n+                paramOffset += generatePushParam(cfw, paramOffset, parameter);\n+            }\n+            locals = paramOffset;\n+            sig.delete(1, marker);\n+            cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, \"<init>\", sig.toString());\n+        }\n+\n+        // Save parameter in instance variable \"delegee\"\n         cfw.add(ByteCode.ALOAD_0);  // this\n-        cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, \"<init>\", \"()V\");\n+        cfw.add(ByteCode.ALOAD_1);  // first arg: Scriptable delegee\n+        cfw.add(ByteCode.PUTFIELD, adapterName, \"delegee\",\n+                \"Lorg/mozilla/javascript/Scriptable;\");\n \n         // Save parameter in instance variable \"factory\"\n         cfw.add(ByteCode.ALOAD_0);  // this\n-        cfw.add(ByteCode.ALOAD_1);  // first arg: ContextFactory instance\n+        cfw.add(ByteCode.ALOAD_2);  // second arg: ContextFactory instance\n         cfw.add(ByteCode.PUTFIELD, adapterName, \"factory\",\n                 \"Lorg/mozilla/javascript/ContextFactory;\");\n \n-        // Save parameter in instance variable \"delegee\"\n-        cfw.add(ByteCode.ALOAD_0);  // this\n-        cfw.add(ByteCode.ALOAD_2);  // second arg: Scriptable delegee\n-        cfw.add(ByteCode.PUTFIELD, adapterName, \"delegee\",\n-                \"Lorg/mozilla/javascript/Scriptable;\");\n-\n         cfw.add(ByteCode.ALOAD_0);  // this for the following PUTFIELD for self\n         // create a wrapper object to be used as \"this\" in method calls\n-        cfw.add(ByteCode.ALOAD_2);  // the Scriptable delegee\n+        cfw.add(ByteCode.ALOAD_1);  // the Scriptable delegee\n         cfw.add(ByteCode.ALOAD_0);  // this\n         cfw.addInvoke(ByteCode.INVOKESTATIC,\n                       \"org/mozilla/javascript/JavaAdapter\",\n                 \"Lorg/mozilla/javascript/Scriptable;\");\n \n         cfw.add(ByteCode.RETURN);\n-        cfw.stopMethod((short)3); // 3: this + factory + delegee\n+        cfw.stopMethod(locals);\n     }\n \n     private static void generateSerialCtor(ClassFileWriter cfw,\n                 \"Lorg/mozilla/javascript/Scriptable;\");\n         // save self\n         cfw.add(ByteCode.ALOAD_0);  // this\n-        cfw.add(ByteCode.ALOAD_3);  // second arg: Scriptable self\n+        cfw.add(ByteCode.ALOAD_3);  // third arg: Scriptable self\n         cfw.add(ByteCode.PUTFIELD, adapterName, \"self\",\n                 \"Lorg/mozilla/javascript/Scriptable;\");\n \n                                        String methodName, Class<?>[] parms,\n                                        Class<?> returnType)\n     {\n-        StringBuffer sb = new StringBuffer();\n+        StringBuilder sb = new StringBuilder();\n         int paramsEnd = appendMethodSignature(parms, returnType, sb);\n         String methodSignature = sb.toString();\n         cfw.startMethod(methodName, methodSignature,\n \n         // push the rest of the parameters.\n         int paramOffset = 1;\n-        for (int i = 0; i < parms.length; i++) {\n-            paramOffset += generatePushParam(cfw, paramOffset, parms[i]);\n+        for (Class<?> parm : parms) {\n+            paramOffset += generatePushParam(cfw, paramOffset, parm);\n         }\n \n         // call the superclass implementation of the method.\n      */\n     private static String getMethodSignature(Method method, Class<?>[] argTypes)\n     {\n-        StringBuffer sb = new StringBuffer();\n+        StringBuilder sb = new StringBuilder();\n         appendMethodSignature(argTypes, method.getReturnType(), sb);\n         return sb.toString();\n     }\n \n     static int appendMethodSignature(Class<?>[] argTypes,\n                                      Class<?> returnType,\n-                                     StringBuffer sb)\n+                                     StringBuilder sb)\n     {\n         sb.append('(');\n         int firstLocal = 1 + argTypes.length; // includes this.\n-        for (int i = 0; i < argTypes.length; i++) {\n-            Class<?> type = argTypes[i];\n+        for (Class<?> type : argTypes) {\n             appendTypeString(sb, type);\n             if (type == Long.TYPE || type == Double.TYPE) {\n-                // adjust for duble slot\n+                // adjust for double slot\n                 ++firstLocal;\n             }\n         }\n         return firstLocal;\n     }\n \n-    private static StringBuffer appendTypeString(StringBuffer sb, Class<?> type)\n+    private static StringBuilder appendTypeString(StringBuilder sb, Class<?> type)\n     {\n         while (type.isArray()) {\n             sb.append('[');\n--- a/lib/rhino/src/org/mozilla/javascript/NativeArray.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeArray.java\n         try {\n             if (!iterating) {\n                 cx.iterating.put(thisObj, 0); // stop recursion.\n+                // make toSource print null and undefined values in recent versions\n+                boolean skipUndefinedAndNull = !toSource\n+                        || cx.getLanguageVersion() < Context.VERSION_1_5;\n                 for (i = 0; i < length; i++) {\n                     if (i > 0) result.append(separator);\n-                    Object elem = getElem(cx, thisObj, i);\n-                    if (elem == null || elem == Undefined.instance) {\n+                    Object elem = getRawElem(thisObj, i);\n+                    if (elem == NOT_FOUND || (skipUndefinedAndNull &&\n+                            (elem == null || elem == Undefined.instance))) {\n                         haslast = false;\n                         continue;\n                     }\n                         }\n \n                     } else {\n-                        if (toLocale)\n-                        {\n+                        if (toLocale) {\n                             Callable fun;\n                             Scriptable funThis;\n                             fun = ScriptRuntime.getPropFunctionAndThis(\n--- a/lib/rhino/src/org/mozilla/javascript/NativeFunction.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeFunction.java\n  */\n public abstract class NativeFunction extends BaseFunction\n {\n+\n+    static final long serialVersionUID = 8713897114082216401L;\n \n     public final void initScriptFunction(Context cx, Scriptable scope)\n     {\n--- a/lib/rhino/src/org/mozilla/javascript/NativeGenerator.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeGenerator.java\n     @Override\n     public String getClassName() {\n         return \"Generator\";\n-    }\n-\n-    /**\n-     * Close the generator if it is still open.\n-     */\n-    @Override\n-    protected void finalize() throws Throwable {\n-        if (savedState != null) {\n-            // This is a little tricky since we are most likely running in\n-            // a different thread. We need to get a Context to run this, and\n-            // we must call \"doTopCall\" since this will likely be the outermost\n-            // JavaScript frame on this thread.\n-            Context cx = Context.getCurrentContext();\n-            ContextFactory factory = cx != null ? cx.getFactory()\n-                                                : ContextFactory.getGlobal();\n-            factory.call(new CloseGeneratorAction(this));\n-        }\n     }\n \n     private static class CloseGeneratorAction implements ContextAction {\n--- a/lib/rhino/src/org/mozilla/javascript/NativeJSON.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeJSON.java\n         if (value.equals(Boolean.TRUE)) return \"true\";\n         if (value.equals(Boolean.FALSE)) return \"false\";\n \n-        if (value instanceof String) {\n-            return quote((String) value);\n+        if (value instanceof CharSequence) {\n+            return quote(value.toString());\n         }\n \n         if (value instanceof Number) {\n--- a/lib/rhino/src/org/mozilla/javascript/NativeJavaClass.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeJavaClass.java\n     protected void initMembers() {\n         Class<?> cl = (Class<?>)javaObject;\n         members = JavaMembers.lookupClass(parent, cl, cl, false);\n-        staticFieldAndMethods\n-            = members.getFieldAndMethodsObjects(this, cl, true);\n+        staticFieldAndMethods = members.getFieldAndMethodsObjects(this, cl, true);\n     }\n \n     @Override\n             // Found the constructor, so try invoking it.\n             return constructSpecific(cx, scope, args, ctors.methods[index]);\n         } else {\n+            if (args.length == 0) {\n+                throw Context.reportRuntimeError0(\"msg.adapter.zero.args\");\n+            }\n             Scriptable topLevel = ScriptableObject.getTopLevelScope(this);\n             String msg = \"\";\n             try {\n-                // trying to construct an interface; use JavaAdapter to\n-                // construct a new class on the fly that implements this\n-                // interface.\n+                // When running on Android create an InterfaceAdapter since our\n+                // bytecode generation won't work on Dalvik VM.\n+                if (\"Dalvik\".equals(System.getProperty(\"java.vm.name\"))\n+                        && classObject.isInterface()) {\n+                    Object obj = createInterfaceAdapter(classObject,\n+                            ScriptableObject.ensureScriptableObject(args[0]));\n+                    return cx.getWrapFactory().wrapAsJavaObject(cx, scope, obj, null);\n+                }\n+                // use JavaAdapter to construct a new class on the fly that\n+                // implements/extends this interface/abstract class.\n                 Object v = topLevel.get(\"JavaAdapter\", topLevel);\n                 if (v != NOT_FOUND) {\n                     Function f = (Function) v;\n     static Scriptable constructSpecific(Context cx, Scriptable scope,\n                                         Object[] args, MemberBox ctor)\n     {\n+        Object instance = constructInternal(args, ctor);\n+        // we need to force this to be wrapped, because construct _has_\n+        // to return a scriptable\n         Scriptable topLevel = ScriptableObject.getTopLevelScope(scope);\n+        return cx.getWrapFactory().wrapNewObject(cx, topLevel, instance);\n+    }\n+\n+    static Object constructInternal(Object[] args, MemberBox ctor)\n+    {\n         Class<?>[] argTypes = ctor.argTypes;\n \n         if (ctor.vararg) {\n             }\n         }\n \n-        Object instance = ctor.newInstance(args);\n-        // we need to force this to be wrapped, because construct _has_\n-        // to return a scriptable\n-        return cx.getWrapFactory().wrapNewObject(cx, topLevel, instance);\n+        return ctor.newInstance(args);\n     }\n \n     @Override\n--- a/lib/rhino/src/org/mozilla/javascript/NativeJavaObject.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeJavaObject.java\n                     // This is a native array conversion to a java array\n                     // Array conversions are all equal, and preferable to object\n                     // and string conversion, per LC3.\n-                    return 1;\n+                    return 2;\n                 }\n             }\n             else if (to == ScriptRuntime.ObjectClass) {\n-                return 2;\n+                return 3;\n             }\n             else if (to == ScriptRuntime.StringClass) {\n-                return 3;\n+                return 4;\n             }\n             else if (to == ScriptRuntime.DateClass) {\n                 if (fromObj instanceof NativeDate) {\n                 }\n             }\n             else if (to.isInterface()) {\n-                if (fromObj instanceof Function) {\n-                    // See comments in coerceType\n-                    if (to.getMethods().length == 1) {\n-                        return 1;\n-                    }\n-                }\n-                return 11;\n+                if (fromObj instanceof NativeObject || fromObj instanceof NativeFunction) {\n+                    // See comments in createInterfaceAdapter\n+                    return 1;\n+                }\n+                return 12;\n             }\n             else if (to.isPrimitive() && to != Boolean.TYPE) {\n-                return 3 + getSizeRank(to);\n+                return 4 + getSizeRank(to);\n             }\n             break;\n         }\n                 Object Result = Array.newInstance(arrayType, (int)length);\n                 for (int i = 0 ; i < length ; ++i) {\n                     try  {\n-                        Array.set(Result, i, coerceType(arrayType,\n-                                                        array.get(i, array)));\n+                        Array.set(Result, i, coerceTypeImpl(\n+                                arrayType, array.get(i, array)));\n                     }\n                     catch (EvaluatorException ee) {\n                         reportConversionError(value, type);\n                     return value;\n                 reportConversionError(value, type);\n             }\n-            else if (type.isInterface() && value instanceof Callable) {\n-                // Try to use function as implementation of Java interface.\n-                //\n-                // XXX: Currently only instances of ScriptableObject are\n-                // supported since the resulting interface proxies should\n-                // be reused next time conversion is made and generic\n-                // Callable has no storage for it. Weak references can\n-                // address it but for now use this restriction.\n-                if (value instanceof ScriptableObject) {\n-                    ScriptableObject so = (ScriptableObject)value;\n-                    Object key = Kit.makeHashKeyFromPair(\n-                        COERCED_INTERFACE_KEY, type);\n-                    Object old = so.getAssociatedValue(key);\n-                    if (old != null) {\n-                        // Function was already wrapped\n-                        return old;\n-                    }\n-                    Context cx = Context.getContext();\n-                    Object glue\n-                        = InterfaceAdapter.create(cx, type, (Callable)value);\n-                    // Store for later retrival\n-                    glue = so.associateValue(key, glue);\n-                    return glue;\n-                }\n-                reportConversionError(value, type);\n+            else if (type.isInterface() && (value instanceof NativeObject\n+                    || value instanceof NativeFunction)) {\n+                // Try to use function/object as implementation of Java interface.\n+                return createInterfaceAdapter(type, (ScriptableObject) value);\n             } else {\n                 reportConversionError(value, type);\n             }\n         }\n \n         return value;\n+    }\n+\n+    protected static Object createInterfaceAdapter(Class<?>type, ScriptableObject so) {\n+        // XXX: Currently only instances of ScriptableObject are\n+        // supported since the resulting interface proxies should\n+        // be reused next time conversion is made and generic\n+        // Callable has no storage for it. Weak references can\n+        // address it but for now use this restriction.\n+\n+        Object key = Kit.makeHashKeyFromPair(COERCED_INTERFACE_KEY, type);\n+        Object old = so.getAssociatedValue(key);\n+        if (old != null) {\n+            // Function was already wrapped\n+            return old;\n+        }\n+        Context cx = Context.getContext();\n+        Object glue = InterfaceAdapter.create(cx, type, so);\n+        // Store for later retrieval\n+        glue = so.associateValue(key, glue);\n+        return glue;\n     }\n \n     private static Object coerceToNumber(Class<?> type, Object value)\n--- a/lib/rhino/src/org/mozilla/javascript/NativeJavaPackage.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeJavaPackage.java\n \n package org.mozilla.javascript;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n import java.util.HashSet;\n import java.util.Set;\n \n         return toString();\n     }\n \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        this.classLoader = Context.getCurrentContext().getApplicationClassLoader();\n+    }\n+\n     @Override\n     public String toString() {\n         return \"[JavaPackage \" + packageName + \"]\";\n     }\n \n     private String packageName;\n-    private ClassLoader classLoader;\n+    private transient ClassLoader classLoader;\n     private Set<String> negativeCache = null;\n }\n--- a/lib/rhino/src/org/mozilla/javascript/NativeJavaTopPackage.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeJavaTopPackage.java\n         // We want to get a real alias, and not a distinct JavaPackage\n         // with the same packageName, so that we share classes and top\n         // that are underneath.\n-        String[] topNames = { \"java\", \"javax\", \"org\", \"com\", \"edu\", \"net\" };\n+        String[] topNames = ScriptRuntime.getTopPackageNames();\n         NativeJavaPackage[] topPackages = new NativeJavaPackage[topNames.length];\n         for (int i=0; i < topNames.length; i++) {\n             topPackages[i] = (NativeJavaPackage)top.get(topNames[i], top);\n--- a/lib/rhino/src/org/mozilla/javascript/NativeObject.java\n+++ b/lib/rhino/src/org/mozilla/javascript/NativeObject.java\n               {\n                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n                 ScriptableObject obj = ensureScriptableObject(arg);\n-                return obj.isExtensible();\n+                return Boolean.valueOf(obj.isExtensible());\n               }\n           case ConstructorId_preventExtensions:\n               {\n                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n                 ScriptableObject obj = ensureScriptableObject(arg);\n \n-                if (obj.isExtensible()) return false;\n+                if (obj.isExtensible()) return Boolean.FALSE;\n \n                 for (Object name: obj.getAllIds()) {\n                   Object configurable = obj.getOwnPropertyDescriptor(cx, name).get(\"configurable\");\n                   if (Boolean.TRUE.equals(configurable))\n-                    return false;\n-                }\n-\n-                return true;\n+                    return Boolean.FALSE;\n+                }\n+\n+                return Boolean.TRUE;\n               }\n           case ConstructorId_isFrozen:\n               {\n                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n                 ScriptableObject obj = ensureScriptableObject(arg);\n \n-                if (obj.isExtensible()) return false;\n+                if (obj.isExtensible()) return Boolean.FALSE;\n \n                 for (Object name: obj.getAllIds()) {\n                   ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n                   if (Boolean.TRUE.equals(desc.get(\"configurable\")))\n-                    return false;\n+                    return Boolean.FALSE;\n                   if (isDataDescriptor(desc) && Boolean.TRUE.equals(desc.get(\"writable\")))\n-                    return false;\n-                }\n-\n-                return true;\n+                    return Boolean.FALSE;\n+                }\n+\n+                return Boolean.TRUE;\n               }\n           case ConstructorId_seal:\n               {\n                 for (Object name: obj.getAllIds()) {\n                   ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n                   if (Boolean.TRUE.equals(desc.get(\"configurable\"))) {\n-                    desc.put(\"configurable\", desc, false);\n+                    desc.put(\"configurable\", desc, Boolean.FALSE);\n                     obj.defineOwnProperty(cx, name, desc, false);\n                   }\n                 }\n                 for (Object name: obj.getAllIds()) {\n                   ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n                   if (isDataDescriptor(desc) && Boolean.TRUE.equals(desc.get(\"writable\")))\n-                    desc.put(\"writable\", desc, false);\n+                    desc.put(\"writable\", desc, Boolean.FALSE);\n                   if (Boolean.TRUE.equals(desc.get(\"configurable\")))\n-                    desc.put(\"configurable\", desc, false);\n+                    desc.put(\"configurable\", desc, Boolean.FALSE);\n                   obj.defineOwnProperty(cx, name, desc, false);\n                 }\n                 obj.preventExtensions();\n--- a/lib/rhino/src/org/mozilla/javascript/Parser.java\n+++ b/lib/rhino/src/org/mozilla/javascript/Parser.java\n  *\n  * Contributor(s):\n  *   Mike Ang\n+ *   Norris Boyd\n  *   Igor Bukanov\n  *   Yuh-Ruey Chen\n+ *   Travis Ennis\n  *   Ethan Hugg\n  *   Bob Jervis\n  *   Terry Lucas\n  *   Mike McCabe\n  *   Milen Nankov\n- *   Norris Boyd\n+ *   Hannes Wallnoefer\n  *   Steve Yegge\n  *\n  * Alternatively, the contents of this file may be used under the terms of\n     private AstNode parseFunctionBody()\n         throws IOException\n     {\n+        boolean isExpressionClosure = false;\n         if (!matchToken(Token.LC)) {\n             if (compilerEnv.getLanguageVersion() < Context.VERSION_1_8) {\n                 reportError(\"msg.no.brace.body\");\n-            }\n-            return parseFunctionBodyExpr();\n+            } else {\n+                isExpressionClosure = true;\n+            }\n         }\n         ++nestingOfFunction;\n         int pos = ts.tokenBeg;\n \n         pn.setLineno(ts.lineno);\n         try {\n-            bodyLoop: for (;;) {\n-                AstNode n;\n-                int tt = peekToken();\n-                switch (tt) {\n-                  case Token.ERROR:\n-                  case Token.EOF:\n-                  case Token.RC:\n-                    break bodyLoop;\n-\n-                  case Token.FUNCTION:\n-                    consumeToken();\n-                    n = function(FunctionNode.FUNCTION_STATEMENT);\n-                    break;\n-                  default:\n-                    n = statement();\n-                    if (inDirectivePrologue) {\n-                        String directive = getDirective(n);\n-                        if (directive == null) {\n-                            inDirectivePrologue = false;\n-                        } else if (directive.equals(\"use strict\")) {\n-                            inUseStrictDirective = true;\n-                        }\n+            if (isExpressionClosure) {\n+                ReturnStatement n = new ReturnStatement(ts.lineno);\n+                n.setReturnValue(assignExpr());\n+                // expression closure flag is required on both nodes\n+                n.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);\n+                pn.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);\n+                pn.addStatement(n);\n+            } else {\n+                bodyLoop: for (;;) {\n+                    AstNode n;\n+                    int tt = peekToken();\n+                    switch (tt) {\n+                        case Token.ERROR:\n+                        case Token.EOF:\n+                        case Token.RC:\n+                            break bodyLoop;\n+\n+                        case Token.FUNCTION:\n+                            consumeToken();\n+                            n = function(FunctionNode.FUNCTION_STATEMENT);\n+                            break;\n+                        default:\n+                            n = statement();\n+                            if (inDirectivePrologue) {\n+                                String directive = getDirective(n);\n+                                if (directive == null) {\n+                                    inDirectivePrologue = false;\n+                                } else if (directive.equals(\"use strict\")) {\n+                                    inUseStrictDirective = true;\n+                                }\n+                            }\n+                            break;\n                     }\n-                    break;\n+                    pn.addStatement(n);\n                 }\n-                pn.addStatement(n);\n             }\n         } catch (ParserException e) {\n             // Ignore it\n \n         int end = ts.tokenEnd;\n         getAndResetJsDoc();\n-        if (mustMatchToken(Token.RC, \"msg.no.brace.after.body\"))\n+        if (!isExpressionClosure && mustMatchToken(Token.RC, \"msg.no.brace.after.body\"))\n             end = ts.tokenEnd;\n         pn.setLength(end - pos);\n         return pn;\n         return null;\n     }\n \n-    private void parseFunctionParams(FunctionNode fnNode)\n+    private void  parseFunctionParams(FunctionNode fnNode)\n         throws IOException\n     {\n         if (matchToken(Token.RP)) {\n         }\n     }\n \n-\n-    private AstNode parseFunctionBodyExpr()\n-        throws IOException\n-    {\n-        ++nestingOfFunction;\n-        int lineno = ts.getLineno();\n-        ReturnStatement n = new ReturnStatement(lineno);\n-        n.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);\n-        try {\n-            n.setReturnValue(assignExpr());\n-        } finally {\n-            --nestingOfFunction;\n-        }\n-        return n;\n-    }\n-\n     private FunctionNode function(int type)\n         throws IOException\n     {\n                 if (compilerEnv.isStrictMode() && !pn.hasSideEffects()) {\n                     int beg = pn.getPosition();\n                     beg = Math.max(beg, lineBeginningFor(beg));\n-                    addStrictWarning(pn instanceof EmptyExpression\n+                    addStrictWarning(pn instanceof EmptyStatement\n                                      ? \"msg.extra.trailing.semi\"\n                                      : \"msg.no.side.effects\",\n                                      \"\", beg, nodeEnd(pn) - beg);\n         // We don't make error nodes explicitly part of the tree;\n         // they get added to the ErrorReporter.  May need to do\n         // something different here.\n-        return new EmptyExpression(pos, ts.tokenBeg - pos);\n+        return new EmptyStatement(pos, ts.tokenBeg - pos);\n     }\n \n     private AstNode statementHelper()\n           case Token.VAR:\n               consumeToken();\n               int lineno = ts.lineno;\n-              pn = variables(currentToken, ts.tokenBeg);\n+              pn = variables(currentToken, ts.tokenBeg, true);\n               pn.setLineno(lineno);\n               break;\n \n           case Token.SEMI:\n               consumeToken();\n               pos = ts.tokenBeg;\n-              pn = new EmptyExpression(pos, ts.tokenEnd - pos);\n+              pn = new EmptyStatement(pos, ts.tokenEnd - pos);\n               pn.setLineno(ts.lineno);\n               return pn;\n \n                 init.setLineno(ts.lineno);\n             } else if (tt == Token.VAR || tt == Token.LET) {\n                 consumeToken();\n-                init = variables(tt, ts.tokenBeg);\n+                init = variables(tt, ts.tokenBeg, false);\n             } else {\n                 init = expr();\n                 markDestructuring(init);\n         if (peekToken() == Token.LP) {\n             pn = let(true, pos);\n         } else {\n-            pn = variables(Token.LET, pos);  // else, e.g.: let x=6, y=7;\n+            pn = variables(Token.LET, pos, true);  // else, e.g.: let x=6, y=7;\n         }\n         pn.setLineno(lineno);\n         return pn;\n      * token in the first variable declaration.\n      * @return the parsed variable list\n      */\n-    private VariableDeclaration variables(int declType, int pos)\n+    private VariableDeclaration variables(int declType, int pos, boolean isStatement)\n         throws IOException\n     {\n         int end;\n                 break;\n         }\n         pn.setLength(end - pos);\n+        pn.setIsStatement(isStatement);\n         return pn;\n     }\n \n             pn.setLp(ts.tokenBeg - pos);\n         pushScope(pn);\n         try {\n-            VariableDeclaration vars = variables(Token.LET, ts.tokenBeg);\n+            VariableDeclaration vars = variables(Token.LET, ts.tokenBeg, isStatement);\n             pn.setVariables(vars);\n             if (mustMatchToken(Token.RP, \"msg.no.paren.let\")) {\n                 pn.setRp(ts.tokenBeg - pos);\n         inForInit = false;\n         try {\n             do {\n-                if (peekToken() == Token.YIELD)\n+                if (peekToken() == Token.YIELD) {\n                     reportError(\"msg.yield.parenthesized\");\n-                result.add(assignExpr());\n+                }\n+                AstNode en = assignExpr();\n+                if (peekToken() == Token.FOR) {\n+                    try {\n+                        result.add(generatorExpression(en, 0, true));\n+                    }\n+                    catch(IOException ex) {\n+                        // #TODO\n+                    }\n+                }\n+                else {\n+                    result.add(en);\n+                }\n             } while (matchToken(Token.COMMA));\n         } finally {\n             inForInit = wasInForInit;\n         try {\n             Comment jsdocNode = getAndResetJsDoc();\n             int lineno = ts.lineno;\n+            int begin = ts.tokenBeg;\n             AstNode e = expr();\n+            if (peekToken() == Token.FOR) {\n+                return generatorExpression(e, begin);\n+            }\n             ParenthesizedExpression pn = new ParenthesizedExpression(e);\n             if (jsdocNode == null) {\n                 jsdocNode = getAndResetJsDoc();\n                 return arrayComprehension(elements.get(0), pos);\n             } else if (tt == Token.EOF) {\n                 reportError(\"msg.no.bracket.arg\");\n+                break;\n             } else {\n                 if (!after_lb_or_comma) {\n                     reportError(\"msg.no.bracket.arg\");\n     private static final int PROP_ENTRY = 1;\n     private static final int GET_ENTRY  = 2;\n     private static final int SET_ENTRY  = 4;\n+\n+    private AstNode generatorExpression(AstNode result, int pos)\n+        throws IOException\n+    {\n+        return generatorExpression(result, pos, false);\n+    }\n+\n+    private AstNode generatorExpression(AstNode result, int pos, boolean inFunctionParams)\n+        throws IOException\n+    {\n+\n+        List<GeneratorExpressionLoop> loops =\n+                new ArrayList<GeneratorExpressionLoop>();\n+        while (peekToken() == Token.FOR) {\n+            loops.add(generatorExpressionLoop());\n+        }\n+        int ifPos = -1;\n+        ConditionData data = null;\n+        if (peekToken() == Token.IF) {\n+            consumeToken();\n+            ifPos = ts.tokenBeg - pos;\n+            data = condition();\n+        }\n+        if(!inFunctionParams) {\n+            mustMatchToken(Token.RP, \"msg.no.paren.let\");\n+        }\n+        GeneratorExpression pn = new GeneratorExpression(pos, ts.tokenEnd - pos);\n+        pn.setResult(result);\n+        pn.setLoops(loops);\n+        if (data != null) {\n+            pn.setIfPosition(ifPos);\n+            pn.setFilter(data.condition);\n+            pn.setFilterLp(data.lp - pos);\n+            pn.setFilterRp(data.rp - pos);\n+        }\n+        return pn;\n+    }\n+\n+    private GeneratorExpressionLoop generatorExpressionLoop()\n+        throws IOException\n+    {\n+        if (nextToken() != Token.FOR) codeBug();\n+        int pos = ts.tokenBeg;\n+        int lp = -1, rp = -1, inPos = -1;\n+        GeneratorExpressionLoop pn = new GeneratorExpressionLoop(pos);\n+\n+        pushScope(pn);\n+        try {\n+            if (mustMatchToken(Token.LP, \"msg.no.paren.for\")) {\n+                lp = ts.tokenBeg - pos;\n+            }\n+\n+            AstNode iter = null;\n+            switch (peekToken()) {\n+              case Token.LB:\n+              case Token.LC:\n+                  // handle destructuring assignment\n+                  iter = destructuringPrimaryExpr();\n+                  markDestructuring(iter);\n+                  break;\n+              case Token.NAME:\n+                  consumeToken();\n+                  iter = createNameNode();\n+                  break;\n+              default:\n+                  reportError(\"msg.bad.var\");\n+            }\n+\n+            // Define as a let since we want the scope of the variable to\n+            // be restricted to the array comprehension\n+            if (iter.getType() == Token.NAME) {\n+                defineSymbol(Token.LET, ts.getString(), true);\n+            }\n+\n+            if (mustMatchToken(Token.IN, \"msg.in.after.for.name\"))\n+                inPos = ts.tokenBeg - pos;\n+            AstNode obj = expr();\n+            if (mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\"))\n+                rp = ts.tokenBeg - pos;\n+\n+            pn.setLength(ts.tokenEnd - pos);\n+            pn.setIterator(iter);\n+            pn.setIteratedObject(obj);\n+            pn.setInPosition(inPos);\n+            pn.setParens(lp, rp);\n+            return pn;\n+        } finally {\n+            popScope();\n+        }\n+    }\n \n     private ObjectLiteral objectLiteral()\n         throws IOException\n               break;\n           case Token.GETPROP:\n           case Token.GETELEM:\n+              switch (variableType) {\n+                  case Token.CONST:\n+                  case Token.LET:\n+                  case Token.VAR:\n+                      reportError(\"msg.bad.assign.left\");\n+              }\n               comma.addChildToBack(simpleAssignment(left, createName(tempName)));\n               break;\n           default:\n--- a/lib/rhino/src/org/mozilla/javascript/Ref.java\n+++ b/lib/rhino/src/org/mozilla/javascript/Ref.java\n  */\n public abstract class Ref implements Serializable\n {\n+    \n+    static final long serialVersionUID = 4044540354730911424L;\n+    \n     public boolean has(Context cx)\n     {\n         return true;\n--- a/lib/rhino/src/org/mozilla/javascript/RhinoException.java\n+++ b/lib/rhino/src/org/mozilla/javascript/RhinoException.java\n         useMozillaStackStyle = flag;\n     }\n \n+    static final long serialVersionUID = 1883500631321581169L;\n+    \n     private static boolean useMozillaStackStyle = false;\n \n     private String sourceName;\n--- a/lib/rhino/src/org/mozilla/javascript/ScriptRuntime.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ScriptRuntime.java\n     public static BaseFunction typeErrorThrower() {\n       if (THROW_TYPE_ERROR == null) {\n         BaseFunction thrower = new BaseFunction() {\n+          static final long serialVersionUID = -5891740962154902286L;\n+\n           @Override\n           public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {\n             throw typeError0(\"msg.op.not.allowed\");\n     public static final Class<Scriptable> ScriptableClass =\n         Scriptable.class;\n \n-    private static final String[] lazilyNames = {\n-        \"RegExp\",        \"org.mozilla.javascript.regexp.NativeRegExp\",\n-        \"Packages\",      \"org.mozilla.javascript.NativeJavaTopPackage\",\n-        \"java\",          \"org.mozilla.javascript.NativeJavaTopPackage\",\n-        \"javax\",         \"org.mozilla.javascript.NativeJavaTopPackage\",\n-        \"org\",           \"org.mozilla.javascript.NativeJavaTopPackage\",\n-        \"com\",           \"org.mozilla.javascript.NativeJavaTopPackage\",\n-        \"edu\",           \"org.mozilla.javascript.NativeJavaTopPackage\",\n-        \"net\",           \"org.mozilla.javascript.NativeJavaTopPackage\",\n-        \"getClass\",      \"org.mozilla.javascript.NativeJavaTopPackage\",\n-        \"JavaAdapter\",   \"org.mozilla.javascript.JavaAdapter\",\n-        \"JavaImporter\",  \"org.mozilla.javascript.ImporterTopLevel\",\n-        \"Continuation\",  \"org.mozilla.javascript.NativeContinuation\",\n-        //\tTODO\tGrotesque hack using literal string (xml) just to minimize\n-\t\t//\t\t\tchanges for now\n-        \"XML\",           \"(xml)\",\n-        \"XMLList\",       \"(xml)\",\n-        \"Namespace\",     \"(xml)\",\n-        \"QName\",         \"(xml)\",\n-    };\n-\n     // Locale object used to request locale-neutral operations.\n     public static Locale ROOT_LOCALE = new Locale(\"\");\n \n         boolean withXml = cx.hasFeature(Context.FEATURE_E4X) &&\n                           cx.getE4xImplementationFactory() != null;\n \n-        for (int i = 0; i != lazilyNames.length; i += 2) {\n-            String topProperty = lazilyNames[i];\n-            String className = lazilyNames[i + 1];\n-            if (!withXml && className.equals(\"(xml)\")) {\n-                continue;\n-            } else if (withXml && className.equals(\"(xml)\")) {\n-\t\t\t\tclassName = cx.getE4xImplementationFactory().\n-                               getImplementationClassName();\n-\t\t\t}\n-            new LazilyLoadedCtor(scope, topProperty, className, sealed, true);\n+        // define lazy-loaded properties using their class name\n+        new LazilyLoadedCtor(scope, \"RegExp\",\n+                \"org.mozilla.javascript.regexp.NativeRegExp\", sealed, true);\n+        new LazilyLoadedCtor(scope, \"Packages\",\n+                \"org.mozilla.javascript.NativeJavaTopPackage\", sealed, true);\n+        new LazilyLoadedCtor(scope, \"getClass\",\n+                \"org.mozilla.javascript.NativeJavaTopPackage\", sealed, true);\n+        new LazilyLoadedCtor(scope, \"JavaAdapter\",\n+                \"org.mozilla.javascript.JavaAdapter\", sealed, true);\n+        new LazilyLoadedCtor(scope, \"JavaImporter\",\n+                \"org.mozilla.javascript.ImporterTopLevel\", sealed, true);\n+        new LazilyLoadedCtor(scope, \"Continuation\",\n+                \"org.mozilla.javascript.NativeContinuation\", sealed, true);\n+\n+        for (String packageName : getTopPackageNames()) {\n+            new LazilyLoadedCtor(scope, packageName,\n+                    \"org.mozilla.javascript.NativeJavaTopPackage\", sealed, true);\n+        }\n+\n+        if (withXml) {\n+            String xmlImpl = cx.getE4xImplementationFactory().getImplementationClassName();\n+            new LazilyLoadedCtor(scope, \"XML\", xmlImpl, sealed, true);\n+            new LazilyLoadedCtor(scope, \"XMLList\", xmlImpl, sealed, true);\n+            new LazilyLoadedCtor(scope, \"Namespace\", xmlImpl, sealed, true);\n+            new LazilyLoadedCtor(scope, \"QName\", xmlImpl, sealed, true);\n         }\n \n         if (scope instanceof TopLevel) {\n         }\n \n         return scope;\n+    }\n+\n+    static String[] getTopPackageNames() {\n+        // Include \"android\" top package if running on Android\n+        return \"Dalvik\".equals(System.getProperty(\"java.vm.name\")) ?\n+            new String[] { \"java\", \"javax\", \"org\", \"com\", \"edu\", \"net\", \"android\" } :\n+            new String[] { \"java\", \"javax\", \"org\", \"com\", \"edu\", \"net\" };\n     }\n \n     public static ScriptableObject getLibraryScopeOrNull(Scriptable scope)\n             if (c == '-') {\n                 if (len > 1) {\n                     c = str.charAt(1);\n+                    if (c == '0') return -1L; // \"-0\" is not an index\n                     i = 1;\n                     negate = true;\n                 }\n     public static boolean in(Object a, Object b, Context cx)\n     {\n         if (!(b instanceof Scriptable)) {\n-            throw typeError0(\"msg.instanceof.not.object\");\n+            throw typeError0(\"msg.in.not.object\");\n         }\n \n         return hasObjectElem((Scriptable)b, a, cx);\n--- a/lib/rhino/src/org/mozilla/javascript/ScriptStackElement.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ScriptStackElement.java\n  * @since 1.7R3\n  */\n public final class ScriptStackElement implements Serializable {\n+\n+    static final long serialVersionUID = -6416688260860477449L;\n \n     public final String fileName;\n     public final String functionName;\n--- a/lib/rhino/src/org/mozilla/javascript/ScriptableObject.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ScriptableObject.java\n                                                   ConstProperties\n {\n \n+    static final long serialVersionUID = 2829861078851942586L;\n+\n     /**\n      * The empty property attribute.\n      *\n         return !isDataDescriptor(desc) && !isAccessorDescriptor(desc);\n     }\n \n-    protected Scriptable ensureScriptable(Object arg) {\n+    protected static Scriptable ensureScriptable(Object arg) {\n         if ( !(arg instanceof Scriptable) )\n             throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n         return (Scriptable) arg;\n     }\n \n-    protected ScriptableObject ensureScriptableObject(Object arg) {\n+    protected static ScriptableObject ensureScriptableObject(Object arg) {\n         if ( !(arg instanceof ScriptableObject) )\n             throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n         return (ScriptableObject) arg;\n--- a/lib/rhino/src/org/mozilla/javascript/Token.java\n+++ b/lib/rhino/src/org/mozilla/javascript/Token.java\n         WITHEXPR       = 159,\n         DEBUGGER       = 160,\n         COMMENT        = 161,\n-        LAST_TOKEN     = 162;\n+        GENEXPR        = 162,\n+        LAST_TOKEN     = 163;\n \n     /**\n      * Returns a name for the token.  If Rhino is compiled with certain\n           case LETEXPR:         return \"LETEXPR\";\n           case DEBUGGER:        return \"DEBUGGER\";\n           case COMMENT:         return \"COMMENT\";\n+          case GENEXPR:         return \"GENEXPR\";\n         }\n \n         // Token without name\n--- a/lib/rhino/src/org/mozilla/javascript/ast/ArrayComprehensionLoop.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/ArrayComprehensionLoop.java\n     public ArrayComprehensionLoop(int pos, int len) {\n         super(pos, len);\n     }\n-\n+    \n     /**\n      * Returns {@code null} for loop body\n      * @return loop body (always {@code null} for this node type)\n--- a/lib/rhino/src/org/mozilla/javascript/ast/AstNode.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/AstNode.java\n         operatorNames.put(Token.ASSIGN_DIV, \"/=\");\n         operatorNames.put(Token.ASSIGN_MOD, \"%=\");\n         operatorNames.put(Token.ASSIGN_BITXOR, \"^=\");\n+        operatorNames.put(Token.VOID, \"void\");\n     }\n \n     public static class PositionComparator implements Comparator<AstNode>, Serializable {\n             sb.append(item.toSource(0));\n             if (count++ < max-1) {\n                 sb.append(\", \");\n+            } else if (item instanceof EmptyExpression) {\n+                sb.append(\",\");\n             }\n         }\n     }\n--- /dev/null\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/EmptyStatement.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Steve Yegge\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ * AST node for an empty statement.  Node type is {@link Token#EMPTY}.<p>\n+ *\n+ */\n+public class EmptyStatement extends AstNode {\n+\n+    {\n+        type = Token.EMPTY;\n+    }\n+\n+    public EmptyStatement() {\n+    }\n+\n+    public EmptyStatement(int pos) {\n+        super(pos);\n+    }\n+\n+    public EmptyStatement(int pos, int len) {\n+        super(pos, len);\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(makeIndent(depth)).append(\";\\n\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node.  There are no children.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        v.visit(this);\n+    }\n+}\n--- a/lib/rhino/src/org/mozilla/javascript/ast/FunctionNode.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/FunctionNode.java\n             sb.append(\") \");\n         }\n         if (isExpressionClosure) {\n-            sb.append(\" \");\n-            sb.append(getBody().toSource(0));\n+            AstNode body = getBody();\n+            if (body.getLastChild() instanceof ReturnStatement) {\n+                // omit \"return\" keyword, just print the expression\n+                body = ((ReturnStatement) body.getLastChild()).getReturnValue();\n+                sb.append(body.toSource(0));\n+                if (functionType == FUNCTION_STATEMENT) {\n+                    sb.append(\";\");\n+                }\n+            } else {\n+                // should never happen\n+                sb.append(\" \");\n+                sb.append(body.toSource(0));\n+            }\n         } else {\n             sb.append(getBody().toSource(depth).trim());\n         }\n--- /dev/null\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/GeneratorExpression.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Travis Ennis\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.mozilla.javascript.Token;\n+\n+/**\n+ */\n+public class GeneratorExpression extends Scope {\n+    \n+    private AstNode result;\n+    private List<GeneratorExpressionLoop> loops =\n+        new ArrayList<GeneratorExpressionLoop>();\n+    private AstNode filter;\n+    private int ifPosition = -1;\n+    private int lp = -1;\n+    private int rp = -1;\n+    \n+    {\n+        type = Token.GENEXPR;\n+    }\n+\n+    public GeneratorExpression() {\n+    }\n+\n+    public GeneratorExpression(int pos) {\n+        super(pos);\n+    }\n+\n+    public GeneratorExpression(int pos, int len) {\n+        super(pos, len);\n+    }\n+    \n+    /**\n+     * Returns result expression node (just after opening bracket)\n+     */\n+    public AstNode getResult() {\n+        return result;\n+    }\n+\n+    /**\n+     * Sets result expression, and sets its parent to this node.\n+     * @throws IllegalArgumentException if result is {@code null}\n+     */\n+    public void setResult(AstNode result) {\n+        assertNotNull(result);\n+        this.result = result;\n+        result.setParent(this);\n+    }\n+\n+    /**\n+     * Returns loop list\n+     */\n+    public List<GeneratorExpressionLoop> getLoops() {\n+        return loops;\n+    }\n+\n+    /**\n+     * Sets loop list\n+     * @throws IllegalArgumentException if loops is {@code null}\n+     */\n+    public void setLoops(List<GeneratorExpressionLoop> loops) {\n+        assertNotNull(loops);\n+        this.loops.clear();\n+        for (GeneratorExpressionLoop acl : loops) {\n+            addLoop(acl);\n+        }\n+    }\n+\n+    /**\n+     * Adds a child loop node, and sets its parent to this node.\n+     * @throws IllegalArgumentException if acl is {@code null}\n+     */\n+    public void addLoop(GeneratorExpressionLoop acl) {\n+        assertNotNull(acl);\n+        loops.add(acl);\n+        acl.setParent(this);\n+    }\n+    \n+    /**\n+     * Returns filter expression, or {@code null} if not present\n+     */\n+    public AstNode getFilter() {\n+        return filter;\n+    }\n+\n+    /**\n+     * Sets filter expression, and sets its parent to this node.\n+     * Can be {@code null}.\n+     */\n+    public void setFilter(AstNode filter) {\n+        this.filter = filter;\n+        if (filter != null)\n+            filter.setParent(this);\n+    }\n+\n+    /**\n+     * Returns position of 'if' keyword, -1 if not present\n+     */\n+    public int getIfPosition() {\n+        return ifPosition;\n+    }\n+\n+    /**\n+     * Sets position of 'if' keyword\n+     */\n+    public void setIfPosition(int ifPosition) {\n+        this.ifPosition = ifPosition;\n+    }\n+\n+    /**\n+     * Returns filter left paren position, or -1 if no filter\n+     */\n+    public int getFilterLp() {\n+        return lp;\n+    }\n+\n+    /**\n+     * Sets filter left paren position, or -1 if no filter\n+     */\n+    public void setFilterLp(int lp) {\n+        this.lp = lp;\n+    }\n+\n+    /**\n+     * Returns filter right paren position, or -1 if no filter\n+     */\n+    public int getFilterRp() {\n+        return rp;\n+    }\n+\n+    /**\n+     * Sets filter right paren position, or -1 if no filter\n+     */\n+    public void setFilterRp(int rp) {\n+        this.rp = rp;\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        StringBuilder sb = new StringBuilder(250);\n+        sb.append(\"(\");\n+        sb.append(result.toSource(0));\n+        for (GeneratorExpressionLoop loop : loops) {\n+            sb.append(loop.toSource(0));\n+        }\n+        if (filter != null) {\n+            sb.append(\" if (\");\n+            sb.append(filter.toSource(0));\n+            sb.append(\")\");\n+        }\n+        sb.append(\")\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Visits this node, the result expression, the loops, and the optional\n+     * filter.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (!v.visit(this)) {\n+            return;\n+        }\n+        result.visit(v);\n+        for (GeneratorExpressionLoop loop : loops) {\n+            loop.visit(v);\n+        }\n+        if (filter != null) {\n+            filter.visit(v);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/GeneratorExpressionLoop.java\n+/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Travis Ennis\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package org.mozilla.javascript.ast;\n+\n+/**\n+ */\n+public class GeneratorExpressionLoop extends ForInLoop {\n+    \n+    public GeneratorExpressionLoop() {\n+    }\n+\n+    public GeneratorExpressionLoop(int pos) {\n+        super(pos);\n+    }\n+\n+    public GeneratorExpressionLoop(int pos, int len) {\n+        super(pos, len);\n+    }\n+    \n+    /**\n+     * Returns whether the loop is a for-each loop\n+     */\n+    @Override\n+    public boolean isForEach() {\n+        return false;\n+    }\n+\n+    /**\n+     * Sets whether the loop is a for-each loop\n+     */\n+    @Override\n+    public void setIsForEach(boolean isForEach) {\n+        throw new UnsupportedOperationException(\"this node type does not support for each\");\n+    }\n+\n+    @Override\n+    public String toSource(int depth) {\n+        return makeIndent(depth)\n+                + \" for \"\n+                + (isForEach()?\"each \":\"\")\n+                + \"(\"\n+                + iterator.toSource(0)\n+                + \" in \"\n+                + iteratedObject.toSource(0)\n+                + \")\";\n+    }\n+\n+    /**\n+     * Visits the iterator expression and the iterated object expression.\n+     * There is no body-expression for this loop type.\n+     */\n+    @Override\n+    public void visit(NodeVisitor v) {\n+        if (v.visit(this)) {\n+            iterator.visit(v);\n+            iteratedObject.visit(v);\n+        }\n+    }\n+}\n--- a/lib/rhino/src/org/mozilla/javascript/ast/KeywordLiteral.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/KeywordLiteral.java\n             sb.append(\"false\");\n             break;\n         case Token.DEBUGGER:\n-            sb.append(\"debugger\");\n+            sb.append(\"debugger;\\n\");\n             break;\n         default:\n             throw new IllegalStateException(\"Invalid keyword literal type: \"\n--- a/lib/rhino/src/org/mozilla/javascript/ast/UnaryExpression.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/UnaryExpression.java\n     public String toSource(int depth) {\n         StringBuilder sb = new StringBuilder();\n         sb.append(makeIndent(depth));\n+        int type = getType();\n         if (!isPostfix) {\n-            sb.append(operatorToString(getType()));\n-            if (getType() == Token.TYPEOF\n-                || getType() == Token.DELPROP) {\n+            sb.append(operatorToString(type));\n+            if (type == Token.TYPEOF || type == Token.DELPROP || type == Token.VOID) {\n                 sb.append(\" \");\n             }\n         }\n         sb.append(operand.toSource());\n         if (isPostfix) {\n-            sb.append(operatorToString(getType()));\n+            sb.append(operatorToString(type));\n         }\n         return sb.toString();\n     }\n--- a/lib/rhino/src/org/mozilla/javascript/ast/VariableDeclaration.java\n+++ b/lib/rhino/src/org/mozilla/javascript/ast/VariableDeclaration.java\n  * For {@code let} declarations, the node position coincides with the\n  * first {@link VariableInitializer} child.<p>\n  *\n- * A standalone variable declaration in a statement context is wrapped with an\n- * {@link ExpressionStatement}.\n+ * A standalone variable declaration in a statement context returns {@code true}\n+ * from its {@link #isStatement()} method.\n  */\n public class VariableDeclaration extends AstNode {\n \n-    private List<VariableInitializer> variables\n-        = new ArrayList<VariableInitializer>();\n+    private List<VariableInitializer> variables = new ArrayList<VariableInitializer>();\n+    private boolean isStatement;\n \n     {\n         type = Token.VAR;\n         return type == Token.LET;\n     }\n \n+    /**\n+     * Returns true if this node represents a statement.\n+     */\n+    public boolean isStatement() {\n+        return isStatement;\n+    }\n+\n+    /**\n+     * Set or unset the statement flag.\n+     */\n+    public void setIsStatement(boolean isStatement) {\n+        this.isStatement = isStatement;\n+    }\n+\n     private String declTypeName() {\n         return Token.typeToName(type).toLowerCase();\n     }\n         sb.append(declTypeName());\n         sb.append(\" \");\n         printList(variables, sb);\n-        if (!(getParent() instanceof Loop)) {\n+        if (isStatement()) {\n             sb.append(\";\\n\");\n         }\n         return sb.toString();\n--- a/lib/rhino/src/org/mozilla/javascript/jdk13/VMBridge_jdk13.java\n+++ b/lib/rhino/src/org/mozilla/javascript/jdk13/VMBridge_jdk13.java\n                                      Method method,\n                                      Object[] args)\n                 {\n-                    return adapter.invoke(cf, target, topScope, method, args);\n+                    // In addition to methods declared in the interface, proxies\n+                    // also route some java.lang.Object methods through the\n+                    // invocation handler.\n+                    if (method.getDeclaringClass() == Object.class) {\n+                        String methodName = method.getName();\n+                        if (methodName.equals(\"equals\")) {\n+                            Object other = args[0];\n+                            // Note: we could compare a proxy and its wrapped function\n+                            // as equal here but that would break symmetry of equal().\n+                            // The reason == suffices here is that proxies are cached\n+                            // in ScriptableObject (see NativeJavaObject.coerceType())\n+                            return Boolean.valueOf(proxy == other);\n+                        }\n+                        if (methodName.equals(\"hashCode\")) {\n+                            return Integer.valueOf(target.hashCode());\n+                        }\n+                        if (methodName.equals(\"toString\")) {\n+                            return \"Proxy[\" + target.toString() + \"]\";\n+                        }\n+                    }\n+                    return adapter.invoke(cf, target, topScope, proxy, method, args);\n                 }\n             };\n         Object proxy;\n         try {\n-            proxy = c.newInstance(new Object[] { handler });\n+            proxy = c.newInstance(handler);\n         } catch (InvocationTargetException ex) {\n             throw Context.throwAsScriptRuntimeEx(ex);\n         } catch (IllegalAccessException ex) {\n-            // Shouls not happen\n+            // Should not happen\n             throw Kit.initCause(new IllegalStateException(), ex);\n         } catch (InstantiationException ex) {\n-            // Shouls not happen\n+            // Should not happen\n             throw Kit.initCause(new IllegalStateException(), ex);\n         }\n         return proxy;\n--- a/lib/rhino/src/org/mozilla/javascript/json/JsonParser.java\n+++ b/lib/rhino/src/org/mozilla/javascript/json/JsonParser.java\n     }\n \n     public static class ParseException extends Exception {\n+\n+        static final long serialVersionUID = 4804542791749920772L;\n+\n         ParseException(String message) {\n             super(message);\n         }\n--- a/lib/rhino/src/org/mozilla/javascript/xml/XMLObject.java\n+++ b/lib/rhino/src/org/mozilla/javascript/xml/XMLObject.java\n  */\n public abstract class XMLObject extends IdScriptableObject\n {\n+    \n+    static final long serialVersionUID = 8455156490438576500L;\n+    \n     public XMLObject()\n     {\n     }\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug482203Test.java\n+package org.mozilla.javascript.tests;\n+\n+import java.io.InputStreamReader;\n+\n+import junit.framework.TestCase;\n+\n+import org.mozilla.javascript.Callable;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Script;\n+import org.mozilla.javascript.Scriptable;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+public class Bug482203Test extends TestCase {\n+    \n+    public void testJsApi() throws Exception {\n+        Context cx = Context.enter();\n+        try {\n+            cx.setOptimizationLevel(-1);\n+            Script script = cx.compileReader(new InputStreamReader(\n+                    Bug482203Test.class.getResourceAsStream(\"Bug482203.js\")),\n+                    \"\", 1, null);\n+            Scriptable scope = cx.initStandardObjects();\n+            script.exec(cx, scope);\n+            int counter = 0;\n+            for(;;)\n+            {\n+                Object cont = ScriptableObject.getProperty(scope, \"c\");\n+                if(cont == null)\n+                {\n+                    break;\n+                }\n+                counter++;\n+                ((Callable)cont).call(cx, scope, scope, new Object[] { null });\n+            }\n+            assertEquals(counter, 5);\n+            assertEquals(Double.valueOf(3), ScriptableObject.getProperty(scope, \"result\"));\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+    \n+    public void testJavaApi() throws Exception {\n+        Context cx = Context.enter();\n+        try {\n+            cx.setOptimizationLevel(-1);\n+            Script script = cx.compileReader(new InputStreamReader(\n+                    Bug482203Test.class.getResourceAsStream(\"Bug482203.js\")),\n+                    \"\", 1, null);\n+            Scriptable scope = cx.initStandardObjects();\n+            cx.executeScriptWithContinuations(script, scope);\n+            int counter = 0;\n+            for(;;)\n+            {\n+                Object cont = ScriptableObject.getProperty(scope, \"c\");\n+                if(cont == null)\n+                {\n+                    break;\n+                }\n+                counter++;\n+                cx.resumeContinuation(cont, scope, null);\n+            }\n+            assertEquals(counter, 5);\n+            assertEquals(Double.valueOf(3), ScriptableObject.getProperty(scope, \"result\"));\n+        } finally {\n+        \tContext.exit();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug491621Test.java\n+package org.mozilla.javascript.tests;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mozilla.javascript.CompilerEnvirons;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.Parser;\n+import org.mozilla.javascript.ast.AstRoot;\n+\n+/**\n+ */\n+public class Bug491621Test {\n+\n+    /**\n+     * Asserts that the value returned by {@link AstRoot#toSource()} after\n+     * the given input source was parsed equals the specified expected output source.\n+     *\n+     * @param source the JavaScript source to be parsed\n+     * @param expectedOutput the JavaScript source that is expected to be\n+     *                       returned by {@link AstRoot#toSource()}\n+     */\n+    private void assertSource(String source, String expectedOutput)\n+    {\n+        CompilerEnvirons env = new CompilerEnvirons();\n+        env.setLanguageVersion(Context.VERSION_1_7);\n+        Parser parser = new Parser(env);\n+        AstRoot root = parser.parse(source, null, 0);\n+        Assert.assertEquals(expectedOutput, root.toSource());\n+    }\n+\n+    /**\n+     * Tests that var declaration AST nodes is properly decompiled.\n+     */\n+    @Test\n+    public void testVarDeclarationToSource()\n+    {\n+        assertSource(\"var x=0;x++;\",\n+                \"var x = 0;\\nx++;\\n\");\n+        assertSource(\"for(var i=0;i<10;i++)x[i]=i;a++;\",\n+                \"for (var i = 0; i < 10; i++) \\n  x[i] = i;\\na++;\\n\");\n+        assertSource(\"var a;if(true)a=1;\",\n+                \"var a;\\nif (true) \\na = 1;\\n\");\n+        assertSource(\"switch(x){case 1:var y;z++}\",\n+                \"switch (x) {\\n  case 1:\\n    var y;\\n    z++;\\n}\\n\");\n+        assertSource(\"for(var p in o)s+=o[p]\",\n+                \"for (var p in o) \\n  s += o[p];\\n\");\n+        assertSource(\"if(c)var a=0;else a=1\",\n+                \"if (c) \\nvar a = 0; else a = 1;\\n\");\n+        assertSource(\"for(var i=0;i<10;i++)var x=i;x++;\",\n+                \"for (var i = 0; i < 10; i++) \\n  var x = i;\\nx++;\\n\");\n+        assertSource(\"function f(){var i=2;for(var j=0;j<i;++j)print(j);}\",\n+                \"function f() {\\n  var i = 2;\\n  for (var j = 0; j < i; ++j) \\n    print(j);\\n}\\n\");\n+    }\n+\n+    /**\n+     * Tests that let declaration AST nodes are properly decompiled.\n+     */\n+    @Test\n+    public void testLetDeclarationToSource()\n+    {\n+        assertSource(\"let x=0;x++;\",\n+                \"let x = 0;\\nx++;\\n\");\n+        assertSource(\"for(let i=0;i<10;i++)x[i]=i;a++;\",\n+                \"for (let i = 0; i < 10; i++) \\n  x[i] = i;\\na++;\\n\");\n+        assertSource(\"let a;if(true)a=1;\",\n+                \"let a;\\nif (true) \\na = 1;\\n\");\n+        assertSource(\"switch(x){case 1:let y;z++}\",\n+                \"switch (x) {\\n  case 1:\\n    let y;\\n    z++;\\n}\\n\");\n+        assertSource(\"for(let p in o)s+=o[p]\",\n+                \"for (let p in o) \\n  s += o[p];\\n\");\n+        assertSource(\"if(c)let a=0;else a=1\",\n+                \"if (c) \\nlet a = 0; else a = 1;\\n\");\n+        assertSource(\"for(let i=0;i<10;i++){let x=i;}x++;\",\n+                \"for (let i = 0; i < 10; i++) \\n  {\\n    let x = i;\\n  }\\nx++;\\n\");\n+        assertSource(\"function f(){let i=2;for(let j=0;j<i;++j)print(j);}\",\n+                \"function f() {\\n  let i = 2;\\n  for (let j = 0; j < i; ++j) \\n    print(j);\\n}\\n\");\n+    }\n+\n+    /**\n+     * Tests that const declaration AST nodes are properly decompiled.\n+     */\n+    @Test\n+    public void testConstDeclarationToSource()\n+    {\n+        assertSource(\"const x=0;x++;\",\n+                \"const x = 0;\\nx++;\\n\");\n+        assertSource(\"const a;if(true)a=1;\",\n+                \"const a;\\nif (true) \\na = 1;\\n\");\n+        assertSource(\"switch(x){case 1:const y;z++}\",\n+                \"switch (x) {\\n  case 1:\\n    const y;\\n    z++;\\n}\\n\");\n+        assertSource(\"if(c)const a=0;else a=1\",\n+                \"if (c) \\nconst a = 0; else a = 1;\\n\");\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug496585Test.java\n+package org.mozilla.javascript.tests;\n+\n+import org.junit.Assert;\n+import org.mozilla.javascript.Function;\n+import org.mozilla.javascript.ContextFactory;\n+import org.mozilla.javascript.ContextAction;\n+import org.mozilla.javascript.Context;\n+import org.junit.Test;\n+\n+public class Bug496585Test {\n+    public String method(String one, Function function) {\n+        return \"string+function\";\n+    }\n+\n+    public String method(String... strings) {\n+        return \"string[]\";\n+    }\n+\n+    @Test\n+    public void callOverloadedFunction() {\n+        new ContextFactory().call(new ContextAction() {\n+            public Object run(Context cx) {\n+                cx.getWrapFactory().setJavaPrimitiveWrap(false);\n+                Assert.assertEquals(\"string[]\", cx.evaluateString(\n+                        cx.initStandardObjects(),\n+                        \"new org.mozilla.javascript.tests.Bug496585Test().method('one', 'two', 'three')\",\n+                        \"<test>\", 1, null));\n+                Assert.assertEquals(\"string+function\", cx.evaluateString(\n+                    cx.initStandardObjects(),\n+                    \"new org.mozilla.javascript.tests.Bug496585Test().method('one', function() {})\",\n+                    \"<test>\", 1, null));\n+                return null;\n+            }\n+        });\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug687669Test.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mozilla.javascript.CompilerEnvirons;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Parser;\n+import org.mozilla.javascript.ScriptableObject;\n+import org.mozilla.javascript.Undefined;\n+import org.mozilla.javascript.ast.AstRoot;\n+\n+/**\n+ *\n+ */\n+public class Bug687669Test {\n+    private Context cx;\n+    private ScriptableObject scope;\n+\n+    @Before\n+    public void setUp() {\n+        cx = Context.enter();\n+        cx.setLanguageVersion(Context.VERSION_1_8);\n+        scope = cx.initStandardObjects();\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Context.exit();\n+    }\n+\n+    private Object eval(CharSequence cs) {\n+        return cx.evaluateString(scope, cs.toString(), \"<eval>\", 1, null);\n+    }\n+\n+    private AstRoot parse(CharSequence cs) {\n+        CompilerEnvirons compilerEnv = new CompilerEnvirons();\n+        compilerEnv.initFromContext(cx);\n+        ErrorReporter compilationErrorReporter = compilerEnv.getErrorReporter();\n+        Parser p = new Parser(compilerEnv, compilationErrorReporter);\n+        return p.parse(cs.toString(), \"<eval>\", 1);\n+    }\n+\n+    private String toSource(CharSequence cs) {\n+        return parse(cs).toSource();\n+    }\n+\n+    @Test\n+    public void testEval() {\n+        // test EmptyStatement node doesn't infer with return values (in\n+        // contrast to wrapping EmptyExpression into an ExpressionStatement)\n+        assertEquals(1d, eval(\"1;;;;\"));\n+        assertEquals(Undefined.instance, eval(\"(function(){1;;;;})()\"));\n+        assertEquals(1d, eval(\"(function(){return 1;;;;})()\"));\n+    }\n+\n+    @Test\n+    public void testToSource() {\n+        assertEquals(\"L1:\\n  ;\\n\", toSource(\"L1:;\"));\n+        assertEquals(\"L1:\\n  ;\\na = 1;\\n\", toSource(\"L1:; a=1;\"));\n+\n+        assertEquals(\"if (1) \\n;\\n\", toSource(\"if(1);\"));\n+        assertEquals(\"if (1) \\n;\\na = 1;\\n\", toSource(\"if(1); a=1;\"));\n+\n+        assertEquals(\"if (1) \\na = 1;\\n\", toSource(\"if(1)a=1;\"));\n+        assertEquals(\"if (1) \\na = 1;\\na = 1;\\n\", toSource(\"if(1)a=1; a=1;\"));\n+\n+        assertEquals(\"if (1) \\n;\\n;\\n;\\n;\\n\", toSource(\"if(1);;;;\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug688018Test.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mozilla.javascript.CompilerEnvirons;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Parser;\n+import org.mozilla.javascript.ast.AstRoot;\n+\n+/**\n+ *\n+ */\n+public class Bug688018Test {\n+    private Context cx;\n+\n+    @Before\n+    public void setUp() {\n+        cx = Context.enter();\n+        cx.setLanguageVersion(Context.VERSION_1_8);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Context.exit();\n+    }\n+\n+    private AstRoot parse(CharSequence cs) {\n+        CompilerEnvirons compilerEnv = new CompilerEnvirons();\n+        compilerEnv.initFromContext(cx);\n+        ErrorReporter compilationErrorReporter = compilerEnv.getErrorReporter();\n+        Parser p = new Parser(compilerEnv, compilationErrorReporter);\n+        return p.parse(cs.toString(), \"<eval>\", 1);\n+    }\n+\n+    private String toSource(CharSequence cs) {\n+        return parse(cs).toSource();\n+    }\n+\n+    @Test\n+    public void testToSource() {\n+        assertEquals(\"void 0;\\n\", toSource(\"void 0;\"));\n+        assertEquals(\"void 1;\\n\", toSource(\"void 1;\"));\n+        assertEquals(\"void 'hello';\\n\", toSource(\"void 'hello';\"));\n+        assertEquals(\"void fn();\\n\", toSource(\"void fn();\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug688021Test.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mozilla.javascript.CompilerEnvirons;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Parser;\n+import org.mozilla.javascript.ast.AstRoot;\n+\n+/**\n+ *\n+ */\n+public class Bug688021Test {\n+    private Context cx;\n+\n+    @Before\n+    public void setUp() {\n+        cx = Context.enter();\n+        cx.setLanguageVersion(Context.VERSION_1_8);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Context.exit();\n+    }\n+\n+    private AstRoot parse(CharSequence cs) {\n+        CompilerEnvirons compilerEnv = new CompilerEnvirons();\n+        compilerEnv.initFromContext(cx);\n+        ErrorReporter compilationErrorReporter = compilerEnv.getErrorReporter();\n+        Parser p = new Parser(compilerEnv, compilationErrorReporter);\n+        return p.parse(cs.toString(), \"<eval>\", 1);\n+    }\n+\n+    private String toSource(CharSequence cs) {\n+        return parse(cs).toSource();\n+    }\n+\n+    @Test\n+    public void testToSource() {\n+        assertEquals(\"debugger;\\n\", toSource(\"debugger\"));\n+        assertEquals(\"debugger;\\n\", toSource(\"debugger;\"));\n+        assertEquals(\"debugger;\\n\", toSource(\"debugger;\\n\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug689308Test.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mozilla.javascript.CompilerEnvirons;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Parser;\n+import org.mozilla.javascript.ast.AstRoot;\n+\n+/**\n+ *\n+ */\n+public class Bug689308Test {\n+    private Context cx;\n+\n+    @Before\n+    public void setUp() {\n+        cx = Context.enter();\n+        cx.setLanguageVersion(Context.VERSION_1_8);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Context.exit();\n+    }\n+\n+    private AstRoot parse(CharSequence cs) {\n+        CompilerEnvirons compilerEnv = new CompilerEnvirons();\n+        compilerEnv.initFromContext(cx);\n+        ErrorReporter compilationErrorReporter = compilerEnv.getErrorReporter();\n+        Parser p = new Parser(compilerEnv, compilationErrorReporter);\n+        return p.parse(cs.toString(), \"<eval>\", 1);\n+    }\n+\n+    private String toSource(CharSequence cs) {\n+        return parse(cs).toSource();\n+    }\n+\n+    @Test\n+    public void testToSourceArray() {\n+        assertEquals(\"[];\\n\", toSource(\"[]\"));\n+        assertEquals(\"[,];\\n\", toSource(\"[,]\"));\n+        assertEquals(\"[, ,];\\n\", toSource(\"[,,]\"));\n+        assertEquals(\"[, , ,];\\n\", toSource(\"[,,,]\"));\n+\n+        assertEquals(\"[1];\\n\", toSource(\"[1]\"));\n+        assertEquals(\"[1];\\n\", toSource(\"[1,]\"));\n+        assertEquals(\"[, 1];\\n\", toSource(\"[,1]\"));\n+        assertEquals(\"[1, 1];\\n\", toSource(\"[1,1]\"));\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug689314Test.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mozilla.javascript.CompilerEnvirons;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Parser;\n+import org.mozilla.javascript.ast.AstRoot;\n+\n+/**\n+ *\n+ */\n+public class Bug689314Test {\n+    private Context cx;\n+\n+    @Before\n+    public void setUp() {\n+        cx = Context.enter();\n+        cx.setLanguageVersion(Context.VERSION_1_8);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Context.exit();\n+    }\n+\n+    private AstRoot parse(CharSequence cs) {\n+        CompilerEnvirons compilerEnv = new CompilerEnvirons();\n+        compilerEnv.initFromContext(cx);\n+        ErrorReporter compilationErrorReporter = compilerEnv.getErrorReporter();\n+        Parser p = new Parser(compilerEnv, compilationErrorReporter);\n+        return p.parse(cs.toString(), \"<eval>\", 1);\n+    }\n+\n+    private String toSource(CharSequence cs) {\n+        return parse(cs).toSource();\n+    }\n+\n+    @Test\n+    public void testToSourceFunctionStatement() {\n+        assertEquals(\"function F() 1 + 2;\\n\", toSource(\"function F() 1+2\"));\n+        assertEquals(\"function F() {\\n  return 1 + 2;\\n}\\n\",\n+                toSource(\"function F() {return 1+2}\"));\n+    }\n+\n+    @Test\n+    public void testToSourceFunctionExpression() {\n+        assertEquals(\"var x = function() 1 + 2;\\n\",\n+                toSource(\"var x = function () 1+2\"));\n+        assertEquals(\"var x = function() {\\n  return 1 + 2;\\n};\\n\",\n+                toSource(\"var x = function () {return 1+2}\"));\n+        assertEquals(\"var x = function F() 1 + 2;\\n\",\n+                toSource(\"var x = function F() 1+2\"));\n+        assertEquals(\"var x = function F() {\\n  return 1 + 2;\\n};\\n\",\n+                toSource(\"var x = function F() {return 1+2}\"));\n+    }\n+}\n--- /dev/null\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/Bug714204Test.java\n+/**\n+ *\n+ */\n+package org.mozilla.javascript.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mozilla.javascript.Context;\n+import org.mozilla.javascript.EvaluatorException;\n+import org.mozilla.javascript.Script;\n+import org.mozilla.javascript.ScriptableObject;\n+\n+/**\n+ *\n+ */\n+public class Bug714204Test {\n+    private Context cx;\n+    private ScriptableObject scope;\n+\n+    @Before\n+    public void setUp() {\n+        cx = Context.enter();\n+        scope = cx.initStandardObjects();\n+        cx.setLanguageVersion(170);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        Context.exit();\n+    }\n+\n+    @Test\n+    public void test_assign_this() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"function F() {\\n\");\n+        sb.append(\"  [this.x] = arguments;\\n\");\n+        sb.append(\"}\\n\");\n+        sb.append(\"var f = new F('a');\\n\");\n+        sb.append(\"(f.x == 'a')\\n\");\n+        Script script = cx.compileString(sb.toString(), \"<eval>\", 1, null);\n+        Object result = script.exec(cx, scope);\n+        assertEquals(Boolean.TRUE, result);\n+    }\n+\n+    @Test(expected = EvaluatorException.class)\n+    public void test_var_this() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"function F() {\\n\");\n+        sb.append(\"  var [this.x] = arguments;\\n\");\n+        sb.append(\"}\\n\");\n+        cx.compileString(sb.toString(), \"<eval>\", 1, null);\n+    }\n+\n+    @Test(expected = EvaluatorException.class)\n+    public void test_let_this() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"function F() {\\n\");\n+        sb.append(\"  let [this.x] = arguments;\\n\");\n+        sb.append(\"}\\n\");\n+        cx.compileString(sb.toString(), \"<eval>\", 1, null);\n+    }\n+\n+    @Test(expected = EvaluatorException.class)\n+    public void test_const_this() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"function F() {\\n\");\n+        sb.append(\"  const [this.x] = arguments;\\n\");\n+        sb.append(\"}\\n\");\n+        cx.compileString(sb.toString(), \"<eval>\", 1, null);\n+    }\n+\n+    @Test(expected = EvaluatorException.class)\n+    public void test_args_this() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"function F([this.x]) {\\n\");\n+        sb.append(\"}\\n\");\n+        cx.compileString(sb.toString(), \"<eval>\", 1, null);\n+    }\n+}\n--- a/lib/rhino/testsrc/org/mozilla/javascript/tests/ContinuationsApiTest.java\n+++ b/lib/rhino/testsrc/org/mozilla/javascript/tests/ContinuationsApiTest.java\n \n import junit.framework.TestCase;\n \n+import org.mozilla.javascript.ConsString;\n import org.mozilla.javascript.Context;\n import org.mozilla.javascript.Script;\n import org.mozilla.javascript.Function;\n import org.mozilla.javascript.WrappedException;\n import org.mozilla.javascript.serialize.ScriptableInputStream;\n import org.mozilla.javascript.serialize.ScriptableOutputStream;\n+\n \n /**\n  * Test of new API functions for running and resuming scripts containing\n         try {\n             ContinuationPending pending = cx.captureContinuation();\n             pending.setApplicationState(2*a);\n+            throw pending;\n+        } finally {\n+            Context.exit();\n+        }\n+    }\n+    public String h() {\n+        Context cx = Context.enter();\n+        try {\n+            ContinuationPending pending = cx.captureContinuation();\n+            pending.setApplicationState(\"2*3\");\n             throw pending;\n         } finally {\n             Context.exit();\n           Context.exit();\n       }\n   }\n+\n+  public void testContinuationsPrototypesAndSerialization() throws IOException, ClassNotFoundException {\n+\n+      byte[] serializedData = null;\n+\n+      {\n+          Scriptable globalScope;\n+          Context cx = Context.enter();\n+          try {\n+              globalScope = cx.initStandardObjects();\n+              cx.setOptimizationLevel(-1); // must use interpreter mode\n+              globalScope.put(\"myObject\", globalScope, Context.javaToJS(new MyClass(), globalScope));\n+          } finally {\n+              Context.exit();\n+          }\n+\n+          cx = Context.enter();\n+          try {\n+              cx.setOptimizationLevel(-1); // must use interpreter mode\n+              cx.evaluateString(\n+                      globalScope,\n+                      \"function f(a) { Number.prototype.blargh = function() {return 'foo';}; var k = myObject.f(a); var t = []; return new Number(8).blargh(); }\",\n+                      \"function test source\", 1, null);\n+              Function f = (Function) globalScope.get(\"f\", globalScope);\n+              Object[] args = { 7 };\n+              cx.callFunctionWithContinuations(f, globalScope, args);\n+              fail(\"Should throw ContinuationPending\");\n+          } catch (ContinuationPending pending) {\n+              // serialize\n+              ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+              ObjectOutputStream sos = new ObjectOutputStream(baos);\n+              sos.writeObject(globalScope);\n+              sos.writeObject(pending.getContinuation());\n+              sos.close();\n+              baos.close();\n+              serializedData = baos.toByteArray();\n+          } finally {\n+              Context.exit();\n+          }\n+      }\n+\n+      {\n+          try {\n+              Context cx = Context.enter();\n+\n+              Scriptable globalScope;\n+\n+              // deserialize\n+              ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);\n+              ObjectInputStream sis = new ObjectInputStream(bais);\n+              globalScope = (Scriptable) sis.readObject();\n+              Object continuation = sis.readObject();\n+              sis.close();\n+              bais.close();\n+\n+              Object result = cx.resumeContinuation(continuation, globalScope, 8);\n+              assertEquals(\"foo\", result);\n+          } finally {\n+              Context.exit();\n+          }\n+      }\n+\n+  }\n+\n+  public void testContinuationsInlineFunctionsSerialization() throws IOException, ClassNotFoundException {\n+\n+      Scriptable globalScope;\n+      Context cx = Context.enter();\n+      try {\n+          globalScope = cx.initStandardObjects();\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          globalScope.put(\"myObject\", globalScope, Context.javaToJS(new MyClass(), globalScope));\n+      } finally {\n+          Context.exit();\n+      }\n+\n+      cx = Context.enter();\n+      try {\n+          cx.setOptimizationLevel(-1); // must use interpreter mode\n+          cx.evaluateString(globalScope, \"function f(a) { var k = eval(myObject.h()); var t = []; return k; }\",\n+                  \"function test source\", 1, null);\n+          Function f = (Function) globalScope.get(\"f\", globalScope);\n+          Object[] args = { 7 };\n+          cx.callFunctionWithContinuations(f, globalScope, args);\n+          fail(\"Should throw ContinuationPending\");\n+      } catch (ContinuationPending pending) {\n+          // serialize\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+          ScriptableOutputStream sos = new ScriptableOutputStream(baos, globalScope);\n+          sos.writeObject(globalScope);\n+          sos.writeObject(pending.getContinuation());\n+          sos.close();\n+          baos.close();\n+          byte[] serializedData = baos.toByteArray();\n+\n+          // deserialize\n+          ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);\n+          ScriptableInputStream sis = new ScriptableInputStream(bais, globalScope);\n+          globalScope = (Scriptable) sis.readObject();\n+          Object continuation = sis.readObject();\n+          sis.close();\n+          bais.close();\n+\n+          Object result = cx.resumeContinuation(continuation, globalScope, \"2+3\");\n+          assertEquals(5, ((Number) result).intValue());\n+      } finally {\n+          Context.exit();\n+      }\n+  }\n+\n+  public void testConsStringSerialization() throws IOException, ClassNotFoundException {\n+\n+      ConsString r1 = new ConsString(\"foo\", \"bar\");\n+\n+      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+      ObjectOutputStream oos = new ObjectOutputStream(baos);\n+\n+      oos.writeObject(r1);\n+\n+      oos.flush();\n+\n+      ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+\n+      ObjectInputStream ois = new ObjectInputStream(bais);\n+\n+      CharSequence r2 = (CharSequence) ois.readObject();\n+\n+      assertEquals(\"still the same at the other end\", r1.toString(), r2.toString());\n+\n+  }\n+\n }\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n import com.google.javascript.rhino.head.ast.DoLoop;\n import com.google.javascript.rhino.head.ast.ElementGet;\n import com.google.javascript.rhino.head.ast.EmptyExpression;\n+import com.google.javascript.rhino.head.ast.EmptyStatement;\n import com.google.javascript.rhino.head.ast.ExpressionStatement;\n import com.google.javascript.rhino.head.ast.ForInLoop;\n import com.google.javascript.rhino.head.ast.ForLoop;\n   private final ErrorReporter errorReporter;\n   private final TransformDispatcher transformDispatcher;\n \n-  // non-static for thread safety\n-  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n-\n-  private static final Set<String> ES5_RESERVED_KEYWORDS =\n+  private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\");\n+\n+  private static final ImmutableSet<String> ES5_RESERVED_KEYWORDS =\n       ImmutableSet.of(\n           // From Section 7.6.1.2\n           \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\");\n-  private static final Set<String> ES5_STRICT_RESERVED_KEYWORDS =\n+  private static final ImmutableSet<String> ES5_STRICT_RESERVED_KEYWORDS =\n       ImmutableSet.of(\n           // From Section 7.6.1.2\n           \"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\",\n \n     @Override\n     Node processEmptyExpression(EmptyExpression exprNode) {\n+      Node node = newNode(Token.EMPTY);\n+      return node;\n+    }\n+\n+    @Override\n+    Node processEmptyStatement(EmptyStatement exprNode) {\n       Node node = newNode(Token.EMPTY);\n       return node;\n     }\n--- a/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java\n+++ b/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java\n import com.google.javascript.rhino.head.ast.DoLoop;\n import com.google.javascript.rhino.head.ast.ElementGet;\n import com.google.javascript.rhino.head.ast.EmptyExpression;\n+import com.google.javascript.rhino.head.ast.EmptyStatement;\n import com.google.javascript.rhino.head.ast.ExpressionStatement;\n import com.google.javascript.rhino.head.ast.ForInLoop;\n import com.google.javascript.rhino.head.ast.ForLoop;\n   abstract T processDoLoop(DoLoop loopNode);\n   abstract T processElementGet(ElementGet getNode);\n   abstract T processEmptyExpression(EmptyExpression exprNode);\n+  abstract T processEmptyStatement(EmptyStatement exprNode);\n   abstract T processExpressionStatement(ExpressionStatement statementNode);\n   abstract T processForInLoop(ForInLoop loopNode);\n   abstract T processForLoop(ForLoop loopNode);\n       case Token.DO:\n         return processDoLoop((DoLoop) node);\n       case Token.EMPTY:\n-        return processEmptyExpression((EmptyExpression) node);\n+        return (node instanceof EmptyExpression) ?\n+            processEmptyExpression((EmptyExpression) node) :\n+            processEmptyStatement((EmptyStatement) node);\n       case Token.EXPR_RESULT:\n       case Token.EXPR_VOID:\n         if (node instanceof ExpressionStatement) {\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     options.ideMode = true;\n     DiagnosticType[] warnings = new DiagnosticType[]{\n         RhinoErrorReporter.PARSE_ERROR,\n-        RhinoErrorReporter.PARSE_ERROR,\n-        RhinoErrorReporter.PARSE_ERROR,\n         RhinoErrorReporter.PARSE_ERROR};\n     test(options,\n         new String[] { \"var foo = {bar: function(e) }\" },\n       for (JSError err : compiler.getWarnings()) {\n         msg += \"Warning:\" + err.toString() + \"\\n\";\n       }\n-      assertEquals(\"Unexpected warnings or errors.\\n \"+ msg,\n+      assertEquals(\"Unexpected warnings or errors.\\n \" + msg,\n         expected, actual);\n     }\n   }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n \n   public void testGeneratorsForbidden() {\n     parseError(\"var i = (x for (x in obj));\",\n-        \"missing ) in parenthetical\");\n+        \"Unsupported syntax: GENEXPR\");\n   }\n \n   public void testGettersForbidden1() {\n         \"missing { before function body\",\n         \"syntax error\",\n         \"missing ; before statement\",\n+        \"missing ; before statement\",\n+        \"missing } after function body\",\n         \"Unsupported syntax: ERROR\",\n         \"Unsupported syntax: ERROR\");\n     parseError(\"var x = function a.b() {}\",\n         \"syntax error\",\n         \"missing ; before statement\",\n         \"missing ; before statement\",\n+        \"missing } after function body\",\n         \"Unsupported syntax: ERROR\",\n         \"Unsupported syntax: ERROR\");\n   }", "timestamp": 1332530510, "metainfo": ""}