{"sha": "9b0cdf5103dc9211cf138389d901d056b86c7292", "log": "fix up jsdoc refs to primitive types  R=jschorr DELTA=55  (44 added, 1 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3245   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n   void fillJSDocInfo(\n       AbstractCompiler compiler, Node externs, Node root) {\n     NodeTraversal.traverseRoots(\n-        compiler, Lists.newArrayList(externs, root), new JSDocInfoCollector());\n+        compiler, Lists.newArrayList(externs, root),\n+        new JSDocInfoCollector(compiler.getTypeRegistry()));\n   }\n \n   private void createPropertyScopeFor(Symbol s) {\n   /** Collects references to types in JSDocInfo. */\n   private class JSDocInfoCollector\n       extends NodeTraversal.AbstractPostOrderCallback {\n+    private final JSTypeRegistry registry;\n+\n+    private JSDocInfoCollector(JSTypeRegistry registry) {\n+      this.registry = registry;\n+    }\n+\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getJSDocInfo() != null) {\n         // Find references in the JSDocInfo.\n     public void visitTypeNode(SymbolScope scope, Node n) {\n       if (n.getType() == Token.STRING) {\n         Symbol symbol = scope.getSlot(n.getString());\n+        if (symbol == null) {\n+          // If we can't find this type, it might be a reference to a\n+          // primitive type (like {string}). Autobox it to check.\n+          JSType type = registry.getType(n.getString());\n+          JSType autobox = type == null ? null : type.autoboxesTo();\n+          symbol = autobox == null ? null : getOnlySymbolForType(autobox);\n+        }\n         if (symbol != null) {\n           symbol.defineReferenceAt(n);\n         }\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n   }\n \n   private Node newStringNode(String s, int lineno, int charno) {\n-    return Node.newString(s, lineno, charno).clonePropsFrom(templateNode);\n+    Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);\n+    n.setLength(s.length());\n+    return n;\n   }\n \n   // This is similar to IRFactory.createTemplateNode to share common props\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n   private static class TypeVerifyingPass\n       implements CompilerPass, NodeTraversal.Callback {\n     private final Compiler compiler;\n-    private List<String> actualTypes = null;\n+    private List<Node> actualTypes = null;\n \n     public TypeVerifyingPass(Compiler compiler) {\n       this.compiler = compiler;\n         Collection<Node> typeNodes = info.getTypeNodes();\n         if (typeNodes.size() > 0) {\n           if (actualTypes != null) {\n-            List<String> expectedTypes = Lists.newArrayList();\n+            List<Node> expectedTypes = Lists.newArrayList();\n             for (Node typeNode : info.getTypeNodes()) {\n-              expectedTypes.add(typeNode.toStringTree());\n+              expectedTypes.add(typeNode);\n             }\n-            assertEquals(expectedTypes, actualTypes);\n+            assertEquals(\"Wrong number of jsdoc types\",\n+                expectedTypes.size(), actualTypes.size());\n+            for (int i = 0; i < expectedTypes.size(); i++) {\n+              assertNull(\n+                  expectedTypes.get(i).checkTreeEquals(actualTypes.get(i)));\n+            }\n           } else {\n             actualTypes = Lists.newArrayList();\n             for (Node typeNode : info.getTypeNodes()) {\n-              actualTypes.add(typeNode.toStringTree());\n+              actualTypes.add(typeNode);\n             }\n           }\n         }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n \n     assertEquals(1, refs.get(0).getNode().getLineno());\n     assertEquals(29, refs.get(0).getNode().getCharno());\n+    assertEquals(3, refs.get(0).getNode().getLength());\n \n     assertEquals(2, refs.get(1).getNode().getLineno());\n     assertEquals(11, refs.get(1).getNode().getCharno());\n \n     assertEquals(7, refs.get(4).getNode().getLineno());\n     assertEquals(13, refs.get(4).getNode().getCharno());\n+  }\n+\n+  public void testReferencesInJSDoc2() {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @param {string} x */ function f(x) {}\\n\");\n+    Symbol str = getGlobalVar(table, \"String\");\n+    assertNotNull(str);\n+\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(str));\n+\n+    // We're going to pick up a lot of references from the externs,\n+    // so it's not meaningful to check the number of references.\n+    // We really want to make sure that all the references are in the externs,\n+    // except the last one.\n+    assertTrue(refs.size() > 1);\n+\n+    int last = refs.size() - 1;\n+    for (int i = 0; i < refs.size(); i++) {\n+      Reference ref = refs.get(i);\n+      assertEquals(i != last, ref.getNode().isFromExterns());\n+    }\n   }\n \n   private Symbol getGlobalVar(SymbolTable table, String name) {", "timestamp": 1315869413, "metainfo": ""}