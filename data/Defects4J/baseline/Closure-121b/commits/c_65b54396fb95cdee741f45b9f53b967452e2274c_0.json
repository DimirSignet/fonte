{"sha": "65b54396fb95cdee741f45b9f53b967452e2274c", "log": "Makes subtype relations work with @implemented templatized types. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=45106345", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.TemplateType;\n \n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n           \"@this type of a function must be an object\\n\" +\n           \"Actual type: {0}\");\n \n+  static final DiagnosticType SAME_INTERFACE_MULTIPLE_IMPLEMENTS =\n+      DiagnosticType.warning(\n+          \"JSC_SAME_INTERFACE_MULTIPLE_IMPLEMENTS\",\n+          \"Cannot @implement the same interface more than once\\n\" +\n+          \"Repeated interface: {0}\");\n+\n   private class ExtendedTypeValidator implements Predicate<JSType> {\n     @Override\n     public boolean apply(JSType type) {\n       if (info.getImplementedInterfaceCount() > 0) {\n         if (isConstructor) {\n           implementedInterfaces = Lists.newArrayList();\n+          Set<JSType> baseInterfaces = new HashSet<JSType>();\n           for (JSTypeExpression t : info.getImplementedInterfaces()) {\n             JSType maybeInterType = t.evaluate(scope, typeRegistry);\n+\n             if (maybeInterType != null &&\n                 maybeInterType.setValidator(new ImplementedTypeValidator())) {\n+              // Disallow implementing the same base (not templatized) interface\n+              // type more than once.\n+              JSType baseInterface = maybeInterType;\n+              if (baseInterface.toMaybeTemplatizedType() != null) {\n+                baseInterface =\n+                    baseInterface.toMaybeTemplatizedType().getReferencedType();\n+              }\n+              if (baseInterfaces.contains(baseInterface)) {\n+                reportWarning(SAME_INTERFACE_MULTIPLE_IMPLEMENTS,\n+                              baseInterface.toString());\n+              } else {\n+                baseInterfaces.add(baseInterface);\n+              }\n+\n               implementedInterfaces.add((ObjectType) maybeInterType);\n             }\n           }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.TemplateType;\n import com.google.javascript.rhino.jstype.TemplateTypeMap;\n+import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer;\n import com.google.javascript.rhino.jstype.UnionType;\n \n import java.util.Collections;\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.TemplateTypeMap;\n+import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer;\n import com.google.javascript.rhino.jstype.UnknownType;\n \n import java.text.MessageFormat;\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n       // Records this type for each implemented interface.\n       for (ObjectType type : implementedInterfaces) {\n         registry.registerTypeImplementingInterface(this, type);\n+        typeOfThis.extendTemplateTypeMap(type.getTemplateTypeMap());\n       }\n       this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);\n     } else {\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n       return false;\n     }\n \n-    if (thisType.isTemplatizedType() && thatType.isTemplatizedType()) {\n-      JSType rawThisType = thisType.toMaybeTemplatizedType().getReferencedType();\n-      JSType rawThatType = thatType.toMaybeTemplatizedType().getReferencedType();\n-      if (!rawThisType.isSubtype(rawThatType)) {\n-        return false;\n-      }\n-\n-      TemplateTypeMap thisTypeParams = thisType.getTemplateTypeMap();\n-      TemplateTypeMap thatTypeParams = thatType.getTemplateTypeMap();\n-\n-      if (thisTypeParams.checkEquivalenceHelper(\n-          thatTypeParams, EquivalenceMethod.INVARIANT)) {\n-        return true;\n-      } else if (isExemptFromTemplateTypeInvariance(thatType)) {\n-        // Only array and object qualify and they are compatible if their\n-        // elmenet types are related.\n-        TemplateType key = thisType.registry.getObjectElementKey();\n-        JSType thisElement = thisTypeParams.getTemplateType(key);\n-        JSType thatElement = thatTypeParams.getTemplateType(key);\n-\n-        return thisElement.isSubtype(thatElement)\n-            || thatElement.isSubtype(thisElement);\n-      } else {\n-        return false;\n-      }\n-    }\n-\n+    // TemplateTypeMaps. This check only returns false if the TemplateTypeMaps\n+    // are not equivalent.\n+    TemplateTypeMap thisTypeParams = thisType.getTemplateTypeMap();\n+    TemplateTypeMap thatTypeParams = thatType.getTemplateTypeMap();\n+    boolean templateMatch = true;\n+    if (isExemptFromTemplateTypeInvariance(thatType)) {\n+      // Array and Object are exempt from template type invariance; their\n+      // template types maps are considered a match only if the ObjectElementKey\n+      // values are subtypes/supertypes of one another.\n+      TemplateType key = thisType.registry.getObjectElementKey();\n+      JSType thisElement = thisTypeParams.getTemplateType(key);\n+      JSType thatElement = thatTypeParams.getTemplateType(key);\n+\n+      templateMatch = thisElement.isSubtype(thatElement)\n+          || thatElement.isSubtype(thisElement);\n+    } else {\n+      templateMatch = thisTypeParams.checkEquivalenceHelper(\n+          thatTypeParams, EquivalenceMethod.INVARIANT);\n+    }\n+    if (!templateMatch) {\n+      return false;\n+    }\n+\n+    // Templatized types. The above check guarantees TemplateTypeMap\n+    // equivalence; check if the base type is a subtype.\n     if (thisType.isTemplatizedType()) {\n       return thisType.toMaybeTemplatizedType().getReferencedType().isSubtype(\n               thatType);\n--- a/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\n import com.google.common.collect.ImmutableList;\n \n import java.io.Serializable;\n+import java.util.Arrays;\n \n /**\n  * Manages a mapping from TemplateType to its resolved JSType. Provides utility\n  * @author izaakr@google.com (Izaak Rubin)\n  */\n public class TemplateTypeMap implements Serializable {\n+  // The TemplateType keys of the map.\n   private final ImmutableList<TemplateType> templateKeys;\n+  // The JSType values, which are index-aligned with their corresponding keys.\n+  // These values are left as specified in the TemplateTypeMap constructor; they\n+  // may refer to TemplateTypes that are keys in this TemplateTypeMap, requiring\n+  // iterative type resolution to find their true, resolved type.\n   private final ImmutableList<JSType> templateValues;\n+  // The JSType values, which are index-aligned with their corresponding keys.\n+  // These values have been iteratively type-resolved using this TemplateTypeMap\n+  // instance. These fully-resolved values are necessary for determining the\n+  // equivalence of two TemplateTypeMap instances.\n+  private final ImmutableList<JSType> resolvedTemplateValues;\n   final JSTypeRegistry registry;\n \n   TemplateTypeMap(JSTypeRegistry registry,\n     int nKeys = templateKeys.size();\n     this.templateValues = templateValues.size() > nKeys ?\n         templateValues.subList(0, nKeys) : templateValues;\n+\n+    // Iteratively resolve any JSType values that refer to the TemplateType keys\n+    // of this TemplateTypeMap.\n+    TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n+        registry, this);\n+    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n+    for (JSType templateValue : this.templateValues) {\n+      builder.add(templateValue.visit(replacer));\n+    }\n+    this.resolvedTemplateValues = builder.build();\n   }\n \n   /**\n    * template key; false otherwise.\n    */\n   public boolean hasTemplateType(TemplateType key) {\n-    return getTemplateTypeInternal(key) != null;\n+    return getTemplateTypeIndex(key) != -1;\n   }\n \n   /**\n    * JSType value is associated, returns UNKNOWN_TYPE.\n    */\n   public JSType getTemplateType(TemplateType key) {\n-    JSType templateType = getTemplateTypeInternal(key);\n-    return (templateType == null) ?\n-        registry.getNativeType(JSTypeNative.UNKNOWN_TYPE) : templateType;\n+    int index = getTemplateTypeIndex(key);\n+    return (index == -1) ? registry.getNativeType(JSTypeNative.UNKNOWN_TYPE) :\n+         templateValues.get(index);\n   }\n \n   public TemplateType getTemplateTypeKeyByName(String keyName) {\n   }\n \n   /**\n-   * Returns the JSType value associated with the specified template key. If no\n-   * JSType value is associated, returns null.\n-   */\n-  private JSType getTemplateTypeInternal(TemplateType key) {\n-    int index = 0;\n-    for (TemplateType item : templateKeys) {\n-      // Note: match by identity.\n-      if (item == key) {\n-        break;\n-      }\n-      index++;\n-    }\n-    if (index < 0 || index >= templateValues.size()) {\n-      return null;\n-    }\n-    return templateValues.get(index);\n+   * Returns the index of the JSType value associated with the specified\n+   * template key. If no JSType value is associated, returns -1.\n+   */\n+  private int getTemplateTypeIndex(TemplateType key) {\n+    int maxIndex = Math.min(templateKeys.size(), templateValues.size());\n+    for (int i = maxIndex - 1; i >= 0; i--) {\n+      if (templateKeys.get(i) == key) {\n+        return i;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private JSType getResolvedTemplateType(TemplateType key) {\n+    int index = getTemplateTypeIndex(key);\n+    return (index == -1) ? registry.getNativeType(JSTypeNative.UNKNOWN_TYPE) :\n+         resolvedTemplateValues.get(index);\n+  }\n+\n+  /**\n+   * An enum tracking the three different equivalence match states for a\n+   * template key-value pair.\n+   */\n+  private enum EquivalenceMatch {\n+    NO_KEY_MATCH, VALUE_MISMATCH, VALUE_MATCH\n   }\n \n   /**\n    */\n   public boolean checkEquivalenceHelper(\n       TemplateTypeMap that, EquivalenceMethod eqMethod) {\n-    int thisNumKeys = templateKeys.size();\n-    int thatNumKeys = that.getTemplateKeys().size();\n-\n-    for (int i = 0; i < Math.min(thisNumKeys, thatNumKeys); i++) {\n-      JSType thisTemplateType = getTemplateType(templateKeys.get(i));\n-      JSType thatTemplateType = that.getTemplateType(\n-          that.getTemplateKeys().get(i));\n-      if (!thisTemplateType.checkEquivalenceHelper(\n-          thatTemplateType, eqMethod)) {\n+    ImmutableList<TemplateType> thisKeys = getTemplateKeys();\n+    ImmutableList<TemplateType> thatKeys = that.getTemplateKeys();\n+\n+    EquivalenceMatch[] thatMatches = new EquivalenceMatch[thatKeys.size()];\n+    Arrays.fill(thatMatches, EquivalenceMatch.NO_KEY_MATCH);\n+\n+    for (int i = 0; i < thisKeys.size(); i++) {\n+      TemplateType thisKey = thisKeys.get(i);\n+      JSType thisType = getResolvedTemplateType(thisKey);\n+      EquivalenceMatch thisMatch = EquivalenceMatch.NO_KEY_MATCH;\n+\n+      for (int j = 0; j < thatKeys.size(); j++) {\n+        TemplateType thatKey = thatKeys.get(j);\n+        JSType thatType = that.getResolvedTemplateType(thatKey);\n+\n+        // Cross-compare every key-value pair in this TemplateTypeMap with\n+        // those in that TemplateTypeMap. Update the Equivalence match for both\n+        // key-value pairs involved.\n+        if (thisKey == thatKey) {\n+          EquivalenceMatch newMatchType = EquivalenceMatch.VALUE_MISMATCH;\n+          if (thisType.checkEquivalenceHelper(thatType, eqMethod)) {\n+            newMatchType = EquivalenceMatch.VALUE_MATCH;\n+          }\n+\n+          if (thisMatch != EquivalenceMatch.VALUE_MATCH) {\n+            thisMatch = newMatchType;\n+          }\n+          if (thatMatches[j] != EquivalenceMatch.VALUE_MATCH) {\n+            thatMatches[j] = newMatchType;\n+          }\n+        }\n+      }\n+\n+      if (failedEquivalenceCheck(thisMatch, eqMethod)) {\n         return false;\n       }\n     }\n \n-    return thisNumKeys == thatNumKeys ||\n-        eqMethod == EquivalenceMethod.INVARIANT;\n+    for (int i = 0; i < thatMatches.length; i++) {\n+      if (failedEquivalenceCheck(thatMatches[i], eqMethod)) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Determines if the specified EquivalenceMatch is considered a failing\n+   * condition for an equivalence check, given the EquivalenceMethod used for\n+   * the check.\n+   */\n+  private boolean failedEquivalenceCheck(\n+      EquivalenceMatch eqMatch, EquivalenceMethod eqMethod) {\n+    return eqMatch == EquivalenceMatch.VALUE_MISMATCH ||\n+        (eqMatch == EquivalenceMatch.NO_KEY_MATCH &&\n+         eqMethod != EquivalenceMethod.INVARIANT);\n   }\n \n   /**\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Bob Jervis\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ModificationVisitor;\n+import com.google.javascript.rhino.jstype.TemplateType;\n+import com.google.javascript.rhino.jstype.TemplateTypeMap;\n+\n+import java.util.ArrayDeque;\n+\n+/**\n+ * Uses a TemplateTypeMap to replace TemplateTypes with their associated JSType\n+ * values.\n+ *\n+ * @author izaakr@google.com (Izaak Rubin)\n+ */\n+public class TemplateTypeMapReplacer extends ModificationVisitor {\n+  private final TemplateTypeMap replacements;\n+  private ArrayDeque<TemplateType> visitedTypes;\n+\n+  public TemplateTypeMapReplacer(\n+      JSTypeRegistry registry, TemplateTypeMap replacements) {\n+    super(registry);\n+    this.replacements = replacements;\n+    this.visitedTypes = new ArrayDeque<TemplateType>();\n+  }\n+\n+  @Override\n+  public JSType caseTemplateType(TemplateType type) {\n+    if (replacements.hasTemplateKey(type)) {\n+      if (hasVisitedType(type)) {\n+        // If we have already encountered this TemplateType during replacement\n+        // (i.e. there is a reference loop), return the type itself.\n+        return type;\n+      } else {\n+        JSType replacement = replacements.getTemplateType(type);\n+\n+        visitedTypes.push(type);\n+        JSType visitedReplacement = replacement.visit(this);\n+        visitedTypes.pop();\n+\n+        return visitedReplacement;\n+      }\n+    } else {\n+      return type;\n+    }\n+  }\n+\n+  /**\n+   * Checks if the specified type has already been visited during the Visitor's\n+   * traversal of a JSType.\n+   */\n+  private boolean hasVisitedType(TemplateType type) {\n+    for (TemplateType visitedType : visitedTypes) {\n+      if (visitedType == type) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   public void testBadImplementsNonObjectType() throws Exception {\n     testTypes(\"/** @constructor \\n * @implements {string} */function S() {}\",\n         \"can only implement interfaces\");\n+  }\n+\n+  public void testBadImplementsDuplicateInterface1() throws Exception {\n+    // verify that the same base (not templatized) interface cannot be\n+    // @implemented more than once.\n+    testTypes(\n+        \"/** @interface \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"/** @constructor \\n\" +\n+        \" * @implements {Foo.<?>}\\n\" +\n+        \" * @implements {Foo}\\n\" +\n+        \" */\\n\" +\n+        \"function A() {}\\n\",\n+        \"Cannot @implement the same interface more than once\\n\" +\n+        \"Repeated interface: Foo\");\n+  }\n+\n+  public void testBadImplementsDuplicateInterface2() throws Exception {\n+    // verify that the same base (not templatized) interface cannot be\n+    // @implemented more than once.\n+    testTypes(\n+        \"/** @interface \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"/** @constructor \\n\" +\n+        \" * @implements {Foo.<string>}\\n\" +\n+        \" * @implements {Foo.<number>}\\n\" +\n+        \" */\\n\" +\n+        \"function A() {}\\n\",\n+        \"Cannot @implement the same interface more than once\\n\" +\n+        \"Repeated interface: Foo\");\n   }\n \n   public void testInterfaceAssignment1() throws Exception {\n         \"y = x;\");\n   }\n \n+  public void testTemplateType11() throws Exception {\n+    // verify that assignment/subtype relationships work when extending\n+    // templatized types.\n+    testTypes(\n+        \"/** @constructor \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"\" +\n+        \"/** @constructor \\n\" +\n+        \" * @extends {Foo.<string>}\\n\" +\n+        \" */\\n\" +\n+        \"function A() {}\\n\" +\n+        \"\" +\n+        \"/** @constructor \\n\" +\n+        \" * @extends {Foo.<number>}\\n\" +\n+        \" */\\n\" +\n+        \"function B() {}\\n\" +\n+        \"\" +\n+        \"/** @type {!Foo.<string>} */ var a = new A();\\n\" +\n+        \"/** @type {!Foo.<string>} */ var b = new B();\",\n+        \"initializing variable\\n\" +\n+        \"found   : B\\n\" +\n+        \"required: Foo.<string>\");\n+  }\n+\n+  public void testTemplateType12() throws Exception {\n+    // verify that assignment/subtype relationships work when implementing\n+    // templatized types.\n+    testTypes(\n+        \"/** @interface \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"\" +\n+        \"/** @constructor \\n\" +\n+        \" * @implements {Foo.<string>}\\n\" +\n+        \" */\\n\" +\n+        \"function A() {}\\n\" +\n+        \"\" +\n+        \"/** @constructor \\n\" +\n+        \" * @implements {Foo.<number>}\\n\" +\n+        \" */\\n\" +\n+        \"function B() {}\\n\" +\n+        \"\" +\n+        \"/** @type {!Foo.<string>} */ var a = new A();\\n\" +\n+        \"/** @type {!Foo.<string>} */ var b = new B();\",\n+        \"initializing variable\\n\" +\n+        \"found   : B\\n\" +\n+        \"required: Foo.<string>\");\n+  }\n+\n+  public void testTemplateType13() throws Exception {\n+    // verify that assignment/subtype relationships work when extending\n+    // templatized types.\n+    testTypes(\n+        \"/** @constructor \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"\" +\n+        \"/** @constructor \\n\" +\n+        \" * @template T\\n\" +\n+        \" * @extends {Foo.<T>}\\n\" +\n+        \" */\\n\" +\n+        \"function A() {}\\n\" +\n+        \"\" +\n+        \"var a1 = new A();\\n\" +\n+        \"var a2 = /** @type {!A.<string>} */ (new A());\\n\" +\n+        \"var a3 = /** @type {!A.<number>} */ (new A());\\n\" +\n+        \"/** @type {!Foo.<string>} */ var f1 = a1;\\n\" +\n+        \"/** @type {!Foo.<string>} */ var f2 = a2;\\n\" +\n+        \"/** @type {!Foo.<string>} */ var f3 = a3;\",\n+        \"initializing variable\\n\" +\n+        \"found   : A.<number>\\n\" +\n+        \"required: Foo.<string>\");\n+  }\n+\n+  public void testTemplateType14() throws Exception {\n+    // verify that assignment/subtype relationships work when implementing\n+    // templatized types.\n+    testTypes(\n+        \"/** @interface \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function Foo() {}\\n\" +\n+        \"\" +\n+        \"/** @constructor \\n\" +\n+        \" * @template T\\n\" +\n+        \" * @implements {Foo.<T>}\\n\" +\n+        \" */\\n\" +\n+        \"function A() {}\\n\" +\n+        \"\" +\n+        \"var a1 = new A();\\n\" +\n+        \"var a2 = /** @type {!A.<string>} */ (new A());\\n\" +\n+        \"var a3 = /** @type {!A.<number>} */ (new A());\\n\" +\n+        \"/** @type {!Foo.<string>} */ var f1 = a1;\\n\" +\n+        \"/** @type {!Foo.<string>} */ var f2 = a2;\\n\" +\n+        \"/** @type {!Foo.<string>} */ var f3 = a3;\",\n+        \"initializing variable\\n\" +\n+        \"found   : A.<number>\\n\" +\n+        \"required: Foo.<string>\");\n+  }\n+\n   public void disable_testBadTemplateType4() throws Exception {\n     // TODO(johnlenz): Add a check for useless of template types.\n     // Unless there are at least two references to a Template type in", "timestamp": 1365635905, "metainfo": ""}