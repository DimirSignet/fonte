{"sha": "d0f6017ead696c8bc68f01b167d9e9bb4b091921", "log": "- Always use isEquivalentTo to check type equality - When testing type equality, use the testing utilities  R=dimvar DELTA=231  (42 added, 8 deleted, 181 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5419   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     // properties where we've checked that it exists, or for properties on\n     // objects that aren't in this binary).\n     JSType propType = getJSType(n);\n-    if (propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n+    if (propType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n       childType = childType.autobox();\n       ObjectType objectType = ObjectType.cast(childType);\n       if (objectType != null) {\n         // much stricter, and so that we can use hasProperty (which is much\n         // faster in most cases).\n         if (!objectType.hasProperty(propName) ||\n-            objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n+            objectType.isEquivalentTo(\n+                typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n           if (objectType instanceof EnumType) {\n             report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n           } else {\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       FunctionType fnType = functionType.toMaybeFunctionType();\n       n.setJSType(fnType.getReturnType());\n       backwardsInferenceFromCallSite(n, fnType);\n-    } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) {\n+    } else if (functionType.isEquivalentTo(\n+        getNativeType(CHECKED_UNKNOWN_TYPE))) {\n       n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n     }\n \n \n     if (propertyType == null) {\n       return getNativeType(UNKNOWN_TYPE);\n-    } else if (propertyType.equals(unknownType) && isLocallyInferred) {\n+    } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {\n       // If the type has been checked in this scope,\n       // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n       return getNativeType(CHECKED_UNKNOWN_TYPE);\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n     FunctionType subCtor = subObject.getConstructor();\n     ObjectType declaredSuper =\n         subObject.getImplicitPrototype().getImplicitPrototype();\n-    if (!declaredSuper.equals(superObject)) {\n-      if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) {\n+    if (!declaredSuper.isEquivalentTo(superObject)) {\n+      if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {\n         registerMismatch(superObject, declaredSuper, report(\n             t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));\n       } else {\n         // tag, or if the original declaration was a stub.\n         if (!(allowDupe ||\n               var.getParentNode().isExprResult()) ||\n-            !newType.equals(varType)) {\n+            !newType.isEquivalentTo(varType)) {\n           report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n               variableName, newType.toString(), var.getInputName(),\n               String.valueOf(var.nameNode.getLineno()),\n     @Override public boolean equals(Object object) {\n       if (object instanceof TypeMismatch) {\n         TypeMismatch that = (TypeMismatch) object;\n-        return (that.typeA.equals(this.typeA) && that.typeB.equals(this.typeB))\n-            || (that.typeB.equals(this.typeA) && that.typeA.equals(this.typeB));\n+        return (that.typeA.isEquivalentTo(this.typeA)\n+                && that.typeB.isEquivalentTo(this.typeB))\n+            || (that.typeB.isEquivalentTo(this.typeA)\n+                && that.typeA.isEquivalentTo(this.typeB));\n       }\n       return false;\n     }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           // We don't want to look at empty function types.\n           !type.isEmptyType()) {\n         if ((fnType.isConstructor() || fnType.isInterface()) &&\n-            !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n+            !fnType.isEquivalentTo(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n           // Declare var.prototype in the scope chain.\n           FunctionType superClassCtor = fnType.getSuperClassConstructor();\n           ObjectType.Property prototypeSlot = fnType.getSlot(\"prototype\");\n               n, prototypeSlot.getType(), input,\n               /* declared iff there's an explicit supertype */\n               superClassCtor == null ||\n-              superClassCtor.getInstanceType().equals(\n+              superClassCtor.getInstanceType().isEquivalentTo(\n                   getNativeType(OBJECT_TYPE)));\n \n           // Make sure the variable is initialized to something if\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n       @Override\n       public JSType caseEnumElementType(EnumElementType enumElementType) {\n         JSType type = enumElementType.getPrimitiveType().visit(this);\n-        if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n+        if (type != null && enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n           return enumElementType;\n         } else {\n           return type;\n       @Override\n       public JSType caseEnumElementType(EnumElementType enumElementType) {\n         JSType type = enumElementType.getPrimitiveType().visit(this);\n-        if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n+        if (type != null &&\n+            enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n           return enumElementType;\n         } else {\n           return type;\n       // create a subtype of MyEnum restricted by string. In any case,\n       // this should catch the common case.\n       JSType type = enumElementType.getPrimitiveType().visit(this);\n-      if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n+      if (type != null &&\n+          enumElementType.getPrimitiveType().isEquivalentTo(type)) {\n         return enumElementType;\n       } else {\n         return type;\n--- a/src/com/google/javascript/rhino/testing/Asserts.java\n+++ b/src/com/google/javascript/rhino/testing/Asserts.java\n \n package com.google.javascript.rhino.testing;\n \n+import com.google.common.collect.Iterables;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.StaticScope;\n \n import junit.framework.Assert;\n+\n+import java.util.Iterator;\n \n /**\n  * Helper methods for making assertions about the validity of types.\n     JSType resolvedType = type.resolve(t, scope);\n     assertTypeEquals(\"JSType#resolve should not affect object equality\",\n         type, resolvedType);\n-    Assert.assertEquals(\"JSType#resolve should not affect hash codes\",\n-        type.hashCode(), resolvedType.hashCode());\n     return resolvedType;\n   }\n \n \n   public static void assertTypeEquals(String message, JSType a, JSType b) {\n     Assert.assertTrue(\n+        \"Both types must be null, or both must be non-null \" + a + \",\" + b,\n+        (a == null) == (b == null));\n+    if (a == null) {\n+      return;\n+    }\n+    Assert.assertTrue(\n         message +\n         (message.isEmpty() ? \"\" : \"\\n\") +\n         \"Expected: \" + a + \"\\n\" +\n         \"Expected: \" + b + \"\\n\" +\n         \"Actual  : \" + a,\n         b.isEquivalentTo(a));\n+  }\n+\n+  public static <T extends JSType, S extends JSType> void\n+      assertTypeCollectionEquals(Iterable<T> a, Iterable<S> b) {\n+    Assert.assertEquals(Iterables.size(a), Iterables.size(b));\n+    Iterator<T> aIterator = a.iterator();\n+    Iterator<S> bIterator = b.iterator();\n+    while (aIterator.hasNext()) {\n+      assertTypeEquals(aIterator.next(), bIterator.next());\n+    }\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.testing.Asserts;\n \n public class ClosureReverseAbstractInterpreterTest extends\n     CompilerTypeTestCase {\n         new ClosureReverseAbstractInterpreter(convention, registry);\n \n     // trueScope\n-    assertEquals(trueType,\n+    Asserts.assertTypeEquals(\n+        trueType,\n         rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, true)\n         .getSlot(\"a\").getType());\n \n     // falseScope\n-    assertEquals(falseType,\n+    Asserts.assertTypeEquals(\n+        falseType,\n         rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, false)\n         .getSlot(\"a\").getType());\n   }\n--- a/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n+++ b/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n \n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.rhino.testing.Asserts.assertTypeEquals;\n+\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.type.FlowScope;\n import com.google.javascript.rhino.Node;\n     FlowScope childB = localEntry.createChildFlowScope();\n     childB.inferSlotType(\"localB\", BOOLEAN_TYPE);\n \n-    assertEquals(STRING_TYPE, childAB.getSlot(\"localB\").getType());\n-    assertEquals(BOOLEAN_TYPE, childB.getSlot(\"localB\").getType());\n+    assertTypeEquals(STRING_TYPE, childAB.getSlot(\"localB\").getType());\n+    assertTypeEquals(BOOLEAN_TYPE, childB.getSlot(\"localB\").getType());\n     assertNull(childB.getSlot(\"localA\").getType());\n \n     FlowScope joined = join(childB, childAB);\n-    assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n         joined.getSlot(\"localB\").getType());\n     assertNull(joined.getSlot(\"localA\").getType());\n \n     joined = join(childAB, childB);\n-    assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n         joined.getSlot(\"localB\").getType());\n     assertNull(joined.getSlot(\"localA\").getType());\n \n     FlowScope childB = localEntry.createChildFlowScope();\n     childB.inferSlotType(\"globalB\", BOOLEAN_TYPE);\n \n-    assertEquals(STRING_TYPE, childA.getSlot(\"localA\").getType());\n-    assertEquals(BOOLEAN_TYPE, childB.getSlot(\"globalB\").getType());\n+    assertTypeEquals(STRING_TYPE, childA.getSlot(\"localA\").getType());\n+    assertTypeEquals(BOOLEAN_TYPE, childB.getSlot(\"globalB\").getType());\n     assertNull(childB.getSlot(\"localB\").getType());\n \n     FlowScope joined = join(childB, childA);\n-    assertEquals(STRING_TYPE, joined.getSlot(\"localA\").getType());\n-    assertEquals(BOOLEAN_TYPE, joined.getSlot(\"globalB\").getType());\n+    assertTypeEquals(STRING_TYPE, joined.getSlot(\"localA\").getType());\n+    assertTypeEquals(BOOLEAN_TYPE, joined.getSlot(\"globalB\").getType());\n \n     joined = join(childA, childB);\n-    assertEquals(STRING_TYPE, joined.getSlot(\"localA\").getType());\n-    assertEquals(BOOLEAN_TYPE, joined.getSlot(\"globalB\").getType());\n+    assertTypeEquals(STRING_TYPE, joined.getSlot(\"localA\").getType());\n+    assertTypeEquals(BOOLEAN_TYPE, joined.getSlot(\"globalB\").getType());\n \n     assertEquals(\"Join should be symmetric\",\n         join(childB, childA), join(childA, childB));\n     childA.inferSlotType(\"localD\", BOOLEAN_TYPE);\n \n     FlowScope joined = join(childB, childA);\n-    assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n         joined.getSlot(\"localC\").getType());\n-    assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n         joined.getSlot(\"localD\").getType());\n \n     joined = join(childA, childB);\n-    assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n         joined.getSlot(\"localC\").getType());\n-    assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n         joined.getSlot(\"localD\").getType());\n \n     assertEquals(\"Join should be symmetric\",\n   private void verifyLongChains(FlowScope chainA, FlowScope chainB) {\n     FlowScope joined = join(chainA, chainB);\n     for (int i = 0; i < LONG_CHAIN_LENGTH; i++) {\n-      assertEquals(\n+      assertTypeEquals(\n           i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE,\n           chainA.getSlot(\"local\" + i).getType());\n-      assertEquals(\n+      assertTypeEquals(\n           i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE,\n           chainB.getSlot(\"local\" + i).getType());\n \n       JSType joinedSlotType = joined.getSlot(\"local\" + i).getType();\n       if (i % 6 == 0) {\n-        assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), joinedSlotType);\n+        assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), joinedSlotType);\n       } else if (i % 2 == 0) {\n-        assertEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE),\n+        assertTypeEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE),\n             joinedSlotType);\n       } else if (i % 3 == 0) {\n-        assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+        assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n             joinedSlotType);\n       } else {\n-        assertEquals(BOOLEAN_TYPE, joinedSlotType);\n+        assertTypeEquals(BOOLEAN_TYPE, joinedSlotType);\n       }\n     }\n \n     childABC.inferSlotType(\"localA\", BOOLEAN_TYPE);\n \n     assertNull(childABC.findUniqueRefinedSlot(childABC));\n-    assertEquals(BOOLEAN_TYPE,\n+    assertTypeEquals(BOOLEAN_TYPE,\n         childABC.findUniqueRefinedSlot(childAB).getType());\n     assertNull(childABC.findUniqueRefinedSlot(childA));\n     assertNull(childABC.findUniqueRefinedSlot(localEntry));\n \n-    assertEquals(STRING_TYPE,\n+    assertTypeEquals(STRING_TYPE,\n         childAB.findUniqueRefinedSlot(childA).getType());\n-    assertEquals(STRING_TYPE,\n+    assertTypeEquals(STRING_TYPE,\n         childAB.findUniqueRefinedSlot(localEntry).getType());\n \n-    assertEquals(NUMBER_TYPE,\n+    assertTypeEquals(NUMBER_TYPE,\n         childA.findUniqueRefinedSlot(localEntry).getType());\n   }\n \n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.rhino.testing.Asserts.assertTypeEquals;\n+\n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.testing.Asserts;\n \n import java.util.Arrays;\n import java.util.List;\n         CodingConventions.getDefault()).createInitialScope(\n             new Node(Token.BLOCK));\n \n-    assertEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());\n-    assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());\n+    assertTypeEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n         s.getVar(\"Boolean\").getType());\n-    assertEquals(DATE_FUNCTION_TYPE, s.getVar(\"Date\").getType());\n-    assertEquals(ERROR_FUNCTION_TYPE, s.getVar(\"Error\").getType());\n-    assertEquals(EVAL_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(DATE_FUNCTION_TYPE, s.getVar(\"Date\").getType());\n+    assertTypeEquals(ERROR_FUNCTION_TYPE, s.getVar(\"Error\").getType());\n+    assertTypeEquals(EVAL_ERROR_FUNCTION_TYPE,\n         s.getVar(\"EvalError\").getType());\n-    assertEquals(NUMBER_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(NUMBER_OBJECT_FUNCTION_TYPE,\n         s.getVar(\"Number\").getType());\n-    assertEquals(OBJECT_FUNCTION_TYPE, s.getVar(\"Object\").getType());\n-    assertEquals(RANGE_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(OBJECT_FUNCTION_TYPE, s.getVar(\"Object\").getType());\n+    assertTypeEquals(RANGE_ERROR_FUNCTION_TYPE,\n         s.getVar(\"RangeError\").getType());\n-    assertEquals(REFERENCE_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(REFERENCE_ERROR_FUNCTION_TYPE,\n         s.getVar(\"ReferenceError\").getType());\n-    assertEquals(REGEXP_FUNCTION_TYPE, s.getVar(\"RegExp\").getType());\n-    assertEquals(STRING_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(REGEXP_FUNCTION_TYPE, s.getVar(\"RegExp\").getType());\n+    assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE,\n         s.getVar(\"String\").getType());\n-    assertEquals(SYNTAX_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(SYNTAX_ERROR_FUNCTION_TYPE,\n         s.getVar(\"SyntaxError\").getType());\n-    assertEquals(TYPE_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(TYPE_ERROR_FUNCTION_TYPE,\n         s.getVar(\"TypeError\").getType());\n-    assertEquals(URI_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(URI_ERROR_FUNCTION_TYPE,\n         s.getVar(\"URIError\").getType());\n   }\n \n     TypeCheckResult p =\n         parseAndTypeCheckWithScope(\"/** @type {(string,null)} */var a = null\");\n \n-    assertEquals(createUnionType(STRING_TYPE, NULL_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, NULL_TYPE),\n         p.scope.getVar(\"a\").getType());\n   }\n \n   public void testVar3() throws Exception {\n     TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = 3;\");\n \n-    assertEquals(NUMBER_TYPE, p.scope.getVar(\"a\").getType());\n+    assertTypeEquals(NUMBER_TYPE, p.scope.getVar(\"a\").getType());\n   }\n \n   public void testVar4() throws Exception {\n     TypeCheckResult p = parseAndTypeCheckWithScope(\n         \"var a = 3; a = 'string';\");\n \n-    assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n         p.scope.getVar(\"a\").getType());\n   }\n \n   public void testNumberNode() throws Exception {\n     Node n = typeCheck(Node.newNumber(0));\n \n-    assertEquals(NUMBER_TYPE, n.getJSType());\n+    assertTypeEquals(NUMBER_TYPE, n.getJSType());\n   }\n \n   public void testStringNode() throws Exception {\n     Node n = typeCheck(Node.newString(\"hello\"));\n \n-    assertEquals(STRING_TYPE, n.getJSType());\n+    assertTypeEquals(STRING_TYPE, n.getJSType());\n   }\n \n   public void testBooleanNodeTrue() throws Exception {\n     Node trueNode = typeCheck(new Node(Token.TRUE));\n \n-    assertEquals(BOOLEAN_TYPE, trueNode.getJSType());\n+    assertTypeEquals(BOOLEAN_TYPE, trueNode.getJSType());\n   }\n \n   public void testBooleanNodeFalse() throws Exception {\n     Node falseNode = typeCheck(new Node(Token.FALSE));\n \n-    assertEquals(BOOLEAN_TYPE, falseNode.getJSType());\n+    assertTypeEquals(BOOLEAN_TYPE, falseNode.getJSType());\n   }\n \n   public void testUndefinedNode() throws Exception {\n     p.addChildToBack(Node.newNumber(5));\n     typeCheck(p);\n \n-    assertEquals(VOID_TYPE, n.getJSType());\n+    assertTypeEquals(VOID_TYPE, n.getJSType());\n   }\n \n   public void testNumberAutoboxing() throws Exception {\n     TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = new Array();\");\n     Var a = p.scope.getVar(\"a\");\n \n-    assertEquals(ARRAY_TYPE, a.getType());\n+    assertTypeEquals(ARRAY_TYPE, a.getType());\n   }\n \n   public void testNew13() throws Exception {\n   }\n \n   public void testName1() throws Exception {\n-    assertEquals(VOID_TYPE, testNameNode(\"undefined\"));\n+    assertTypeEquals(VOID_TYPE, testNameNode(\"undefined\"));\n   }\n \n   public void testName2() throws Exception {\n-    assertEquals(OBJECT_FUNCTION_TYPE, testNameNode(\"Object\"));\n+    assertTypeEquals(OBJECT_FUNCTION_TYPE, testNameNode(\"Object\"));\n   }\n \n   public void testName3() throws Exception {\n-    assertEquals(ARRAY_FUNCTION_TYPE, testNameNode(\"Array\"));\n+    assertTypeEquals(ARRAY_FUNCTION_TYPE, testNameNode(\"Array\"));\n   }\n \n   public void testName4() throws Exception {\n-    assertEquals(DATE_FUNCTION_TYPE, testNameNode(\"Date\"));\n+    assertTypeEquals(DATE_FUNCTION_TYPE, testNameNode(\"Date\"));\n   }\n \n   public void testName5() throws Exception {\n-    assertEquals(REGEXP_FUNCTION_TYPE, testNameNode(\"RegExp\"));\n+    assertTypeEquals(REGEXP_FUNCTION_TYPE, testNameNode(\"RegExp\"));\n   }\n \n   /**\n         googFooGetprop2ObjectType.hasProperty(\"foo\"));\n     assertTrue(\"bar property not present on goog.foo type\",\n         googFooGetprop2ObjectType.hasProperty(\"bar\"));\n-    assertEquals(\"bar property on goog.foo type incorrectly inferred\",\n+    assertTypeEquals(\"bar property on goog.foo type incorrectly inferred\",\n         NUMBER_TYPE, googFooGetprop2ObjectType.getPropertyType(\"bar\"));\n   }\n \n \n     JSType functionAType = js1Node.getFirstChild().getJSType();\n     assertEquals(\"function (): undefined\", functionAType.toString());\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         U2U_FUNCTION_TYPE.getPropertyType(\"m2\"));\n   }\n \n \n   public void testValueTypeBuiltInPrototypePropertyType() throws Exception {\n     Node node = parseAndTypeCheck(\"\\\"x\\\".charAt(0)\");\n-    assertEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType());\n   }\n \n   public void testDeclareBuiltInConstructor() throws Exception {\n     Node node = parseAndTypeCheck(\n         \"/** @constructor */ var String = function(opt_str) {};\\n\" +\n         \"(new String(\\\"x\\\")).charAt(0)\");\n-    assertEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType());\n   }\n \n   public void testExtendBuiltInType1() throws Exception {\n         \"*/\\n\" +\n         \"String.prototype.substr = function(start, opt_length) {};\\n\";\n     Node n1 = parseAndTypeCheck(externs + \"(new String(\\\"x\\\")).substr(0,1);\");\n-    assertEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType());\n   }\n \n   public void testExtendBuiltInType2() throws Exception {\n         \"*/\\n\" +\n         \"String.prototype.substr = function(start, opt_length) {};\\n\";\n     Node n2 = parseAndTypeCheck(externs + \"\\\"x\\\".substr(0,1);\");\n-    assertEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType());\n   }\n \n   public void testExtendFunction1() throws Exception {\n         \"function() { return 1; };\\n\" +\n         \"(new Function()).f();\");\n     JSType type = n.getLastChild().getLastChild().getJSType();\n-    assertEquals(NUMBER_TYPE, type);\n+    assertTypeEquals(NUMBER_TYPE, type);\n   }\n \n   public void testExtendFunction2() throws Exception {\n         \"function() { return 1; };\\n\" +\n         \"(function() {}).f();\");\n     JSType type = n.getLastChild().getLastChild().getJSType();\n-    assertEquals(NUMBER_TYPE, type);\n+    assertTypeEquals(NUMBER_TYPE, type);\n   }\n \n   public void testInheritanceCheck1() throws Exception {\n     // value's type\n     ObjectType objectType =\n         (ObjectType) objectNode.getJSType();\n-    assertEquals(NUMBER_TYPE, objectType.getPropertyType(\"m1\"));\n-    assertEquals(STRING_TYPE, objectType.getPropertyType(\"m2\"));\n+    assertTypeEquals(NUMBER_TYPE, objectType.getPropertyType(\"m1\"));\n+    assertTypeEquals(STRING_TYPE, objectType.getPropertyType(\"m2\"));\n \n     // variable's type\n-    assertEquals(objectType, nameNode.getJSType());\n+    assertTypeEquals(objectType, nameNode.getJSType());\n   }\n \n   public void testObjectLiteralDeclaration1() throws Exception {\n     // ECMA-262 15.9.2: When Date is called as a function rather than as a\n     // constructor, it returns a string.\n     Node n = parseAndTypeCheck(\"Date()\");\n-    assertEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType());\n   }\n \n   // According to ECMA-262, Error & Array function calls are equivalent to\n \n   public void testCallErrorConstructorAsFunction() throws Exception {\n     Node n = parseAndTypeCheck(\"Error('x')\");\n-    assertEquals(ERROR_TYPE,\n+    assertTypeEquals(ERROR_TYPE,\n                  n.getFirstChild().getFirstChild().getJSType());\n   }\n \n   public void testCallArrayConstructorAsFunction() throws Exception {\n     Node n = parseAndTypeCheck(\"Array()\");\n-    assertEquals(ARRAY_TYPE,\n+    assertTypeEquals(ARRAY_TYPE,\n                  n.getFirstChild().getFirstChild().getJSType());\n   }\n \n     assertTrue(type instanceof ObjectType);\n     ObjectType objectType = (ObjectType) type;\n     assertFalse(objectType.hasProperty(\"x\"));\n-    assertEquals(\n+    Asserts.assertTypeCollectionEquals(\n         Lists.newArrayList(objectType),\n         registry.getTypesWithProperty(\"x\"));\n   }\n     Scope s = ns.scope;\n     JSType type = n.getLastChild().getLastChild().getJSType();\n     assertFalse(type.isUnknownType());\n-    assertEquals(type, OBJECT_TYPE);\n+    assertTypeEquals(type, OBJECT_TYPE);\n     assertTrue(type instanceof ObjectType);\n     ObjectType objectType = (ObjectType) type;\n     assertFalse(objectType.hasProperty(\"x\"));\n-    assertEquals(\n+    Asserts.assertTypeCollectionEquals(\n         Lists.newArrayList(OBJECT_TYPE),\n         registry.getTypesWithProperty(\"x\"));\n   }\n         + \"}\");\n \n     // check the type of afoo when referenced\n-    assertEquals(registry.createOptionalType(\n+    assertTypeEquals(registry.createOptionalType(\n             registry.createNullableType(registry.getType(\"Foo\"))),\n         n.getLastChild().getLastChild().getLastChild().getLastChild()\n         .getLastChild().getLastChild().getJSType());\n     assertTrue(\"Expected \" + objectType.getReferenceName() +\n         \" to have property \" +\n         propertyName, objectType.hasProperty(propertyName));\n-    assertEquals(\"Expected \" + objectType.getReferenceName() +\n+    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n         \"'s property \" +\n         propertyName + \" to have type \" + expectedType,\n         expectedType, objectType.getPropertyType(propertyName));\n--- a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n+++ b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n \n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.rhino.testing.Asserts.assertTypeEquals;\n+\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.type.FlowScope;\n import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n     // true outcome.\n     FlowScope informedTrue = interpreter.\n         getPreciserScopeKnowingConditionOutcome(condition, blind, true);\n-    assertEquals(STRING_TYPE, getVarType(informedTrue, \"a\"));\n+    assertTypeEquals(STRING_TYPE, getVarType(informedTrue, \"a\"));\n \n     // false outcome.\n     FlowScope informedFalse = interpreter.\n         getPreciserScopeKnowingConditionOutcome(condition, blind, false);\n-    assertEquals(createNullableType(STRING_TYPE),\n+    assertTypeEquals(createNullableType(STRING_TYPE),\n         getVarType(informedFalse, \"a\"));\n   }\n \n     // true outcome.\n     FlowScope informedTrue = interpreter.\n         getPreciserScopeKnowingConditionOutcome(condition, blind, true);\n-    assertEquals(createNullableType(STRING_TYPE),\n+    assertTypeEquals(createNullableType(STRING_TYPE),\n         getVarType(informedTrue, \"a\"));\n \n     // false outcome.\n     FlowScope informedFalse = interpreter.\n         getPreciserScopeKnowingConditionOutcome(condition, blind, false);\n-    assertEquals(STRING_TYPE, getVarType(informedFalse, \"a\"));\n+    assertTypeEquals(STRING_TYPE, getVarType(informedFalse, \"a\"));\n   }\n \n   /**\n     FlowScope informedTrue = interpreter.\n         getPreciserScopeKnowingConditionOutcome(condition, blind, true);\n     for (TypedName p : trueOutcome) {\n-      assertEquals(p.name, p.type, getVarType(informedTrue, p.name));\n+      assertTypeEquals(p.name, p.type, getVarType(informedTrue, p.name));\n     }\n \n     // false outcome.\n     FlowScope informedFalse = interpreter.\n         getPreciserScopeKnowingConditionOutcome(condition, blind, false);\n     for (TypedName p : falseOutcome) {\n-      assertEquals(p.type, getVarType(informedFalse, p.name));\n+      assertTypeEquals(p.type, getVarType(informedFalse, p.name));\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.rhino.testing.Asserts.assertTypeEquals;\n+\n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.testing.Asserts;\n \n import java.util.Arrays;\n import java.util.List;\n         CodingConventions.getDefault()).createInitialScope(\n             new Node(Token.BLOCK));\n \n-    assertEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());\n-    assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());\n+    assertTypeEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n         s.getVar(\"Boolean\").getType());\n-    assertEquals(DATE_FUNCTION_TYPE, s.getVar(\"Date\").getType());\n-    assertEquals(ERROR_FUNCTION_TYPE, s.getVar(\"Error\").getType());\n-    assertEquals(EVAL_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(DATE_FUNCTION_TYPE, s.getVar(\"Date\").getType());\n+    assertTypeEquals(ERROR_FUNCTION_TYPE, s.getVar(\"Error\").getType());\n+    assertTypeEquals(EVAL_ERROR_FUNCTION_TYPE,\n         s.getVar(\"EvalError\").getType());\n-    assertEquals(NUMBER_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(NUMBER_OBJECT_FUNCTION_TYPE,\n         s.getVar(\"Number\").getType());\n-    assertEquals(OBJECT_FUNCTION_TYPE, s.getVar(\"Object\").getType());\n-    assertEquals(RANGE_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(OBJECT_FUNCTION_TYPE, s.getVar(\"Object\").getType());\n+    assertTypeEquals(RANGE_ERROR_FUNCTION_TYPE,\n         s.getVar(\"RangeError\").getType());\n-    assertEquals(REFERENCE_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(REFERENCE_ERROR_FUNCTION_TYPE,\n         s.getVar(\"ReferenceError\").getType());\n-    assertEquals(REGEXP_FUNCTION_TYPE, s.getVar(\"RegExp\").getType());\n-    assertEquals(STRING_OBJECT_FUNCTION_TYPE,\n+    assertTypeEquals(REGEXP_FUNCTION_TYPE, s.getVar(\"RegExp\").getType());\n+    assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE,\n         s.getVar(\"String\").getType());\n-    assertEquals(SYNTAX_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(SYNTAX_ERROR_FUNCTION_TYPE,\n         s.getVar(\"SyntaxError\").getType());\n-    assertEquals(TYPE_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(TYPE_ERROR_FUNCTION_TYPE,\n         s.getVar(\"TypeError\").getType());\n-    assertEquals(URI_ERROR_FUNCTION_TYPE,\n+    assertTypeEquals(URI_ERROR_FUNCTION_TYPE,\n         s.getVar(\"URIError\").getType());\n   }\n \n     TypeCheckResult p =\n         parseAndTypeCheckWithScope(\"/** @type {(string,null)} */var a = null\");\n \n-    assertEquals(createUnionType(STRING_TYPE, NULL_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, NULL_TYPE),\n         p.scope.getVar(\"a\").getType());\n   }\n \n   public void testVar3() throws Exception {\n     TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = 3;\");\n \n-    assertEquals(NUMBER_TYPE, p.scope.getVar(\"a\").getType());\n+    assertTypeEquals(NUMBER_TYPE, p.scope.getVar(\"a\").getType());\n   }\n \n   public void testVar4() throws Exception {\n     TypeCheckResult p = parseAndTypeCheckWithScope(\n         \"var a = 3; a = 'string';\");\n \n-    assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n+    assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n         p.scope.getVar(\"a\").getType());\n   }\n \n   public void testNumberNode() throws Exception {\n     Node n = typeCheck(Node.newNumber(0));\n \n-    assertEquals(NUMBER_TYPE, n.getJSType());\n+    assertTypeEquals(NUMBER_TYPE, n.getJSType());\n   }\n \n   public void testStringNode() throws Exception {\n     Node n = typeCheck(Node.newString(\"hello\"));\n \n-    assertEquals(STRING_TYPE, n.getJSType());\n+    assertTypeEquals(STRING_TYPE, n.getJSType());\n   }\n \n   public void testBooleanNodeTrue() throws Exception {\n     Node trueNode = typeCheck(new Node(Token.TRUE));\n \n-    assertEquals(BOOLEAN_TYPE, trueNode.getJSType());\n+    assertTypeEquals(BOOLEAN_TYPE, trueNode.getJSType());\n   }\n \n   public void testBooleanNodeFalse() throws Exception {\n     Node falseNode = typeCheck(new Node(Token.FALSE));\n \n-    assertEquals(BOOLEAN_TYPE, falseNode.getJSType());\n+    assertTypeEquals(BOOLEAN_TYPE, falseNode.getJSType());\n   }\n \n   public void testUndefinedNode() throws Exception {\n     p.addChildToBack(Node.newNumber(5));\n     typeCheck(p);\n \n-    assertEquals(VOID_TYPE, n.getJSType());\n+    assertTypeEquals(VOID_TYPE, n.getJSType());\n   }\n \n   public void testNumberAutoboxing() throws Exception {\n     TypeCheckResult p = parseAndTypeCheckWithScope(\"var a = new Array();\");\n     Var a = p.scope.getVar(\"a\");\n \n-    assertEquals(ARRAY_TYPE, a.getType());\n+    assertTypeEquals(ARRAY_TYPE, a.getType());\n   }\n \n   public void testNew13() throws Exception {\n   }\n \n   public void testName1() throws Exception {\n-    assertEquals(VOID_TYPE, testNameNode(\"undefined\"));\n+    assertTypeEquals(VOID_TYPE, testNameNode(\"undefined\"));\n   }\n \n   public void testName2() throws Exception {\n-    assertEquals(OBJECT_FUNCTION_TYPE, testNameNode(\"Object\"));\n+    assertTypeEquals(OBJECT_FUNCTION_TYPE, testNameNode(\"Object\"));\n   }\n \n   public void testName3() throws Exception {\n-    assertEquals(ARRAY_FUNCTION_TYPE, testNameNode(\"Array\"));\n+    assertTypeEquals(ARRAY_FUNCTION_TYPE, testNameNode(\"Array\"));\n   }\n \n   public void testName4() throws Exception {\n-    assertEquals(DATE_FUNCTION_TYPE, testNameNode(\"Date\"));\n+    assertTypeEquals(DATE_FUNCTION_TYPE, testNameNode(\"Date\"));\n   }\n \n   public void testName5() throws Exception {\n-    assertEquals(REGEXP_FUNCTION_TYPE, testNameNode(\"RegExp\"));\n+    assertTypeEquals(REGEXP_FUNCTION_TYPE, testNameNode(\"RegExp\"));\n   }\n \n   /**\n         googFooGetprop2ObjectType.hasProperty(\"foo\"));\n     assertTrue(\"bar property not present on goog.foo type\",\n         googFooGetprop2ObjectType.hasProperty(\"bar\"));\n-    assertEquals(\"bar property on goog.foo type incorrectly inferred\",\n+    assertTypeEquals(\"bar property on goog.foo type incorrectly inferred\",\n         NUMBER_TYPE, googFooGetprop2ObjectType.getPropertyType(\"bar\"));\n   }\n \n \n     JSType functionAType = js1Node.getFirstChild().getJSType();\n     assertEquals(\"function (): undefined\", functionAType.toString());\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n-    assertEquals(UNKNOWN_TYPE,\n+    assertTypeEquals(UNKNOWN_TYPE,\n         U2U_FUNCTION_TYPE.getPropertyType(\"m2\"));\n   }\n \n \n   public void testValueTypeBuiltInPrototypePropertyType() throws Exception {\n     Node node = parseAndTypeCheck(\"\\\"x\\\".charAt(0)\");\n-    assertEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType());\n   }\n \n   public void testDeclareBuiltInConstructor() throws Exception {\n     Node node = parseAndTypeCheck(\n         \"/** @constructor */ var String = function(opt_str) {};\\n\" +\n         \"(new String(\\\"x\\\")).charAt(0)\");\n-    assertEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType());\n   }\n \n   public void testExtendBuiltInType1() throws Exception {\n         \"*/\\n\" +\n         \"String.prototype.substr = function(start, opt_length) {};\\n\";\n     Node n1 = parseAndTypeCheck(externs + \"(new String(\\\"x\\\")).substr(0,1);\");\n-    assertEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType());\n   }\n \n   public void testExtendBuiltInType2() throws Exception {\n         \"*/\\n\" +\n         \"String.prototype.substr = function(start, opt_length) {};\\n\";\n     Node n2 = parseAndTypeCheck(externs + \"\\\"x\\\".substr(0,1);\");\n-    assertEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType());\n   }\n \n   public void testExtendFunction1() throws Exception {\n         \"function() { return 1; };\\n\" +\n         \"(new Function()).f();\");\n     JSType type = n.getLastChild().getLastChild().getJSType();\n-    assertEquals(NUMBER_TYPE, type);\n+    assertTypeEquals(NUMBER_TYPE, type);\n   }\n \n   public void testExtendFunction2() throws Exception {\n         \"function() { return 1; };\\n\" +\n         \"(function() {}).f();\");\n     JSType type = n.getLastChild().getLastChild().getJSType();\n-    assertEquals(NUMBER_TYPE, type);\n+    assertTypeEquals(NUMBER_TYPE, type);\n   }\n \n   public void testInheritanceCheck1() throws Exception {\n     // value's type\n     ObjectType objectType =\n         (ObjectType) objectNode.getJSType();\n-    assertEquals(NUMBER_TYPE, objectType.getPropertyType(\"m1\"));\n-    assertEquals(STRING_TYPE, objectType.getPropertyType(\"m2\"));\n+    assertTypeEquals(NUMBER_TYPE, objectType.getPropertyType(\"m1\"));\n+    assertTypeEquals(STRING_TYPE, objectType.getPropertyType(\"m2\"));\n \n     // variable's type\n-    assertEquals(objectType, nameNode.getJSType());\n+    assertTypeEquals(objectType, nameNode.getJSType());\n   }\n \n   public void testObjectLiteralDeclaration1() throws Exception {\n     // ECMA-262 15.9.2: When Date is called as a function rather than as a\n     // constructor, it returns a string.\n     Node n = parseAndTypeCheck(\"Date()\");\n-    assertEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType());\n+    assertTypeEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType());\n   }\n \n   // According to ECMA-262, Error & Array function calls are equivalent to\n \n   public void testCallErrorConstructorAsFunction() throws Exception {\n     Node n = parseAndTypeCheck(\"Error('x')\");\n-    assertEquals(ERROR_TYPE,\n+    assertTypeEquals(ERROR_TYPE,\n                  n.getFirstChild().getFirstChild().getJSType());\n   }\n \n   public void testCallArrayConstructorAsFunction() throws Exception {\n     Node n = parseAndTypeCheck(\"Array()\");\n-    assertEquals(ARRAY_TYPE,\n+    assertTypeEquals(ARRAY_TYPE,\n                  n.getFirstChild().getFirstChild().getJSType());\n   }\n \n     assertTrue(type instanceof ObjectType);\n     ObjectType objectType = (ObjectType) type;\n     assertFalse(objectType.hasProperty(\"x\"));\n-    assertEquals(\n+    Asserts.assertTypeCollectionEquals(\n         Lists.newArrayList(objectType),\n         registry.getTypesWithProperty(\"x\"));\n   }\n     Scope s = ns.scope;\n     JSType type = n.getLastChild().getLastChild().getJSType();\n     assertFalse(type.isUnknownType());\n-    assertEquals(type, OBJECT_TYPE);\n+    assertTypeEquals(type, OBJECT_TYPE);\n     assertTrue(type instanceof ObjectType);\n     ObjectType objectType = (ObjectType) type;\n     assertFalse(objectType.hasProperty(\"x\"));\n-    assertEquals(\n+    Asserts.assertTypeCollectionEquals(\n         Lists.newArrayList(OBJECT_TYPE),\n         registry.getTypesWithProperty(\"x\"));\n   }\n \n   public void testDeclaredNativeTypeEquality() throws Exception {\n     Node n = parseAndTypeCheck(\"/** @constructor */ function Object() {};\");\n-    assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),\n+    assertTypeEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),\n                  n.getFirstChild().getJSType());\n   }\n \n   public void testUndefinedVar() throws Exception {\n     Node n = parseAndTypeCheck(\"var undefined;\");\n-    assertEquals(registry.getNativeType(JSTypeNative.VOID_TYPE),\n+    assertTypeEquals(registry.getNativeType(JSTypeNative.VOID_TYPE),\n                  n.getFirstChild().getFirstChild().getJSType());\n   }\n \n         + \"for (; (i + a) < b; ++i) {}}\");\n \n     // check the type of the add node for i + f\n-    assertEquals(registry.getNativeType(JSTypeNative.NUMBER_TYPE),\n+    assertTypeEquals(registry.getNativeType(JSTypeNative.NUMBER_TYPE),\n         n.getFirstChild().getLastChild().getLastChild().getFirstChild()\n         .getNext().getFirstChild().getJSType());\n   }\n         + \"}\");\n \n     // check the type of afoo when referenced\n-    assertEquals(registry.createNullableType(registry.getType(\"Foo\")),\n+    assertTypeEquals(registry.createNullableType(registry.getType(\"Foo\")),\n         n.getLastChild().getLastChild().getLastChild().getLastChild()\n         .getLastChild().getLastChild().getJSType());\n   }\n     assertTrue(\"Expected \" + objectType.getReferenceName() +\n         \" to have property \" +\n         propertyName, objectType.hasProperty(propertyName));\n-    assertEquals(\"Expected \" + objectType.getReferenceName() +\n+    assertTypeEquals(\"Expected \" + objectType.getReferenceName() +\n         \"'s property \" +\n         propertyName + \" to have type \" + expectedType,\n         expectedType, objectType.getPropertyType(propertyName));\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.testing.Asserts;\n \n import java.util.Deque;\n \n     testSame(\"function Foo() {}; Foo.bar;\");\n     ObjectType foo = (ObjectType) globalScope.getVar(\"Foo\").getType();\n     assertFalse(foo.hasProperty(\"bar\"));\n-    assertEquals(registry.getNativeType(UNKNOWN_TYPE),\n+    Asserts.assertTypeEquals(registry.getNativeType(UNKNOWN_TYPE),\n         foo.getPropertyType(\"bar\"));\n-    assertEquals(Lists.newArrayList(foo), registry.getTypesWithProperty(\"bar\"));\n+    Asserts.assertTypeCollectionEquals(\n+        Lists.newArrayList(foo), registry.getTypesWithProperty(\"bar\"));\n   }\n \n   public void testConstructorProperty() {\n \n     JSType fooBar = foo.getPropertyType(\"Bar\");\n     assertEquals(\"function (new:foo.Bar): undefined\", fooBar.toString());\n-    assertEquals(Lists.newArrayList(foo), registry.getTypesWithProperty(\"Bar\"));\n+    Asserts.assertTypeCollectionEquals(\n+        Lists.newArrayList(foo), registry.getTypesWithProperty(\"Bar\"));\n   }\n \n   public void testPrototypePropertyMethodWithoutAnnotation() {\n \n     JSType fooBar = foo.getPropertyType(\"Bar\");\n     assertEquals(\"enum{foo.Bar}\", fooBar.toString());\n-    assertEquals(Lists.newArrayList(foo), registry.getTypesWithProperty(\"Bar\"));\n+    Asserts.assertTypeCollectionEquals(\n+        Lists.newArrayList(foo), registry.getTypesWithProperty(\"Bar\"));\n   }\n \n   public void testInferredProperty1() {\n \n     assertEquals(\"Foo.<number>\",\n         registry.getType(\"FooAlias\").toString());\n-    assertEquals(registry.getType(\"FooAlias\"),\n+    Asserts.assertTypeEquals(registry.getType(\"FooAlias\"),\n         registry.getType(\"Foo\"));\n \n     ObjectType f = (ObjectType) findNameType(\"f\", globalScope);\n \n     assertEquals(\"goog.Foo.<number>\",\n         registry.getType(\"goog.FooAlias\").toString());\n-    assertEquals(registry.getType(\"goog.Foo\"),\n+    Asserts.assertTypeEquals(registry.getType(\"goog.Foo\"),\n         registry.getType(\"goog.FooAlias\"));\n   }\n \n         goog.getPropertyType(\"foo\").toString());\n     assertTrue(goog.isPropertyTypeDeclared(\"foo\"));\n \n-    assertEquals(globalScope.getVar(\"goog.foo\").getType(),\n+    Asserts.assertTypeEquals(globalScope.getVar(\"goog.foo\").getType(),\n         goog.getPropertyType(\"foo\"));\n   }\n \n         goog.getPropertyType(\"foo\").toString());\n     assertTrue(goog.isPropertyTypeDeclared(\"foo\"));\n \n-    assertEquals(lastLocalScope.getVar(\"goog.foo\").getType(),\n+    Asserts.assertTypeEquals(lastLocalScope.getVar(\"goog.foo\").getType(),\n         goog.getPropertyType(\"foo\"));\n   }\n \n     assertEquals(\n         getNativeObjectType(OBJECT_TYPE).getPropertiesCount() + 3,\n         instanceType.getPropertiesCount());\n-    assertEquals(getNativeType(NUMBER_TYPE),\n+    Asserts.assertTypeEquals(getNativeType(NUMBER_TYPE),\n         instanceType.getPropertyType(\"m1\"));\n-    assertEquals(getNativeType(BOOLEAN_TYPE),\n+    Asserts.assertTypeEquals(getNativeType(BOOLEAN_TYPE),\n         instanceType.getPropertyType(\"m2\"));\n-    assertEquals(getNativeType(STRING_TYPE),\n+    Asserts.assertTypeEquals(getNativeType(STRING_TYPE),\n         instanceType.getPropertyType(\"m3\"));\n \n     // Verify the prototype chain.\n     assertEquals(\"function (this:I): undefined\",\n         iPrototype.getPropertyType(\"baz\").toString());\n \n-    assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n+    Asserts.assertTypeEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n   }\n \n   public void testPropertiesOnInterface2() throws Exception {\n     ObjectType externInstance = ((FunctionType) e).getInstanceType();\n     assertTrue(externInstance.hasOwnProperty(\"one\"));\n     assertTrue(externInstance.isPropertyTypeDeclared(\"one\"));\n-    assertTypeEquals(\"function (): number\",\n-        externInstance.getPropertyType(\"one\"));\n+    assertEquals(\"function (): number\",\n+        externInstance.getPropertyType(\"one\").toString());\n \n     JSType n = globalScope.getVar(\"Normal\").getType();\n     ObjectType normalInstance = ((FunctionType) n).getInstanceType();\n \n     ObjectType obj = globalScope.getVar(\"Object\").getType().dereference();\n     assertTrue(obj.hasOwnProperty(\"one\"));\n-    assertTypeEquals(\"number\", obj.getPropertyType(\"one\"));\n+    assertEquals(\"number\", obj.getPropertyType(\"one\").toString());\n   }\n \n   public void testTypedStubsInExterns() {\n         (FunctionType) (globalScope.getVar(\"Window\").getType());\n     assertEquals(\"global this\", x.toString());\n     assertTrue(x.isSubtype(windowCtor.getInstanceType()));\n-    assertFalse(x.equals(windowCtor.getInstanceType()));\n+    assertFalse(x.isEquivalentTo(windowCtor.getInstanceType()));\n     assertTrue(x.hasProperty(\"alert\"));\n   }\n \n         (FunctionType) (globalScope.getVar(\"Window\").getType());\n     assertEquals(\"global this\", x.toString());\n     assertTrue(x.isSubtype(windowCtor.getInstanceType()));\n-    assertFalse(x.equals(windowCtor.getInstanceType()));\n+    assertFalse(x.isEquivalentTo(windowCtor.getInstanceType()));\n     assertTrue(x.hasProperty(\"alert\"));\n   }\n \n         \"/** @constructor */ var Foo = function() {};\" +\n         \"/** @constructor */ var FooAlias = Foo;\");\n     assertEquals(\"Foo\", registry.getType(\"FooAlias\").toString());\n-    assertEquals(registry.getType(\"Foo\"), registry.getType(\"FooAlias\"));\n+    Asserts.assertTypeEquals(registry.getType(\"Foo\"), registry.getType(\"FooAlias\"));\n   }\n \n   public void testNamespacedConstructorAlias() {\n         \"/** @constructor */ goog.Foo = function() {};\" +\n         \"/** @constructor */ goog.FooAlias = goog.Foo;\");\n     assertEquals(\"goog.Foo\", registry.getType(\"goog.FooAlias\").toString());\n-    assertEquals(registry.getType(\"goog.Foo\"),\n+    Asserts.assertTypeEquals(registry.getType(\"goog.Foo\"),\n         registry.getType(\"goog.FooAlias\"));\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     registry.declareType(\"typeA\", realA);\n     registry.declareType(\"typeB\", realB);\n \n-    assertEquals(a.hashCode(), realA.hashCode());\n     assertTypeEquals(a, realA);\n-    assertEquals(b.hashCode(), realB.hashCode());\n     assertTypeEquals(b, realB);\n \n     a.resolve(null, null);\n \n     assertTrue(a.isResolved());\n     assertTrue(b.isResolved());\n-    assertEquals(a.hashCode(), realA.hashCode());\n     assertTypeEquals(a, realA);\n-    assertEquals(b.hashCode(), realB.hashCode());\n     assertTypeEquals(b, realB);\n \n     JSType resolvedA = Asserts.assertValidResolve(a);\n     NamedType b = new NamedType(registry, \"typeA\", \"source\", 1, 0);\n     registry.forwardDeclareType(\"typeA\");\n \n-    assertEquals(a.hashCode(), b.hashCode());\n     assertTypeEquals(a, b);\n \n     a.resolve(null, EMPTY_SCOPE);\n     assertTrue(a.isResolved());\n     assertFalse(b.isResolved());\n \n-    assertEquals(a.hashCode(), b.hashCode());\n     assertTypeEquals(a, b);\n \n     assertFalse(a.isEquivalentTo(UNKNOWN_TYPE));\n--- a/test/com/google/javascript/rhino/jstype/UnionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/UnionTypeTest.java\n     UnionType stringOrNull =\n         (UnionType) createUnionType(STRING_OBJECT_TYPE, NULL_TYPE);\n \n-    assertEquals(nullOrString, stringOrNull);\n-    assertEquals(stringOrNull, nullOrString);\n+    Asserts.assertTypeEquals(nullOrString, stringOrNull);\n+    Asserts.assertTypeEquals(stringOrNull, nullOrString);\n \n     assertTypeCanAssignToItself(createUnionType(VOID_TYPE, NUMBER_TYPE));\n     assertTypeCanAssignToItself(\n     UnionType nullOrUnknown =\n         (UnionType) createUnionType(NULL_TYPE, unresolvedNamedType);\n     assertTrue(nullOrUnknown.isUnknownType());\n-    assertEquals(nullOrUnknown, NULL_TYPE.getLeastSupertype(nullOrUnknown));\n-    assertEquals(nullOrUnknown, nullOrUnknown.getLeastSupertype(NULL_TYPE));\n-    assertEquals(UNKNOWN_TYPE,\n+    Asserts.assertTypeEquals(nullOrUnknown, NULL_TYPE.getLeastSupertype(nullOrUnknown));\n+    Asserts.assertTypeEquals(nullOrUnknown, nullOrUnknown.getLeastSupertype(NULL_TYPE));\n+    Asserts.assertTypeEquals(UNKNOWN_TYPE,\n         NULL_TYPE.getGreatestSubtype(nullOrUnknown));\n-    assertEquals(UNKNOWN_TYPE,\n+    Asserts.assertTypeEquals(UNKNOWN_TYPE,\n         nullOrUnknown.getGreatestSubtype(NULL_TYPE));\n \n     assertTrue(NULL_TYPE.differsFrom(nullOrUnknown));\n     assertTrue(unresolvedNamedType.isSubtype(nullOrUnknown));\n     assertTrue(nullOrUnknown.isSubtype(NULL_TYPE));\n \n-    assertEquals(unresolvedNamedType,\n+    Asserts.assertTypeEquals(unresolvedNamedType,\n         nullOrUnknown.restrictByNotNullOrUndefined());\n \n     // findPropertyType\n-    assertEquals(NUMBER_TYPE, nullOrString.findPropertyType(\"length\"));\n+    Asserts.assertTypeEquals(NUMBER_TYPE, nullOrString.findPropertyType(\"length\"));\n     assertEquals(null, nullOrString.findPropertyType(\"lengthx\"));\n \n     Asserts.assertResolvesToSame(nullOrString);\n    * Tests {@link JSType#getGreatestSubtype(JSType)} on union types.\n    */\n   public void testGreatestSubtypeUnionTypes1() {\n-    assertEquals(NULL_TYPE, createNullableType(STRING_TYPE).getGreatestSubtype(\n+    Asserts.assertTypeEquals(NULL_TYPE, createNullableType(STRING_TYPE).getGreatestSubtype(\n             createNullableType(NUMBER_TYPE)));\n   }\n \n   public void testGreatestSubtypeUnionTypes2() {\n     UnionType evalUriError =\n         (UnionType) createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n-    assertEquals(evalUriError,\n+    Asserts.assertTypeEquals(evalUriError,\n         evalUriError.getGreatestSubtype(ERROR_TYPE));\n   }\n \n     // (null,undefined)\n     UnionType nullUndefined =\n         (UnionType) createUnionType(VOID_TYPE, NULL_TYPE);\n-    assertEquals(nullUndefined,\n+    Asserts.assertTypeEquals(nullUndefined,\n         nullUndefined.getGreatestSubtype(nullableOptionalNumber));\n-    assertEquals(nullUndefined,\n+    Asserts.assertTypeEquals(nullUndefined,\n         nullableOptionalNumber.getGreatestSubtype(nullUndefined));\n   }\n \n   public void testGreatestSubtypeUnionTypes4() throws Exception {\n     UnionType errUnion = (UnionType) createUnionType(\n         NULL_TYPE, EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n-    assertEquals(createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE),\n+    Asserts.assertTypeEquals(createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE),\n         errUnion.getGreatestSubtype(ERROR_TYPE));\n   }\n \n    */\n   public void testGreatestSubtypeUnionTypes5() throws Exception {\n     JSType errUnion = createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n-    assertEquals(NO_OBJECT_TYPE,\n+    Asserts.assertTypeEquals(NO_OBJECT_TYPE,\n         errUnion.getGreatestSubtype(STRING_OBJECT_TYPE));\n   }\n \n \n   public void testGetRestrictedUnion1() throws Exception {\n     UnionType numStr = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE);\n-    assertEquals(STRING_TYPE, numStr.getRestrictedUnion(NUMBER_TYPE));\n+    Asserts.assertTypeEquals(STRING_TYPE, numStr.getRestrictedUnion(NUMBER_TYPE));\n   }\n \n   public void testGetRestrictedUnion2() throws Exception {\n     UnionType numStr = (UnionType) createUnionType(\n         NULL_TYPE, EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n-    assertEquals(NULL_TYPE, numStr.getRestrictedUnion(ERROR_TYPE));\n+    Asserts.assertTypeEquals(NULL_TYPE, numStr.getRestrictedUnion(ERROR_TYPE));\n   }\n \n   public void testIsEquivalentTo() {", "timestamp": 1345663243, "metainfo": ""}