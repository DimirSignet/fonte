{"sha": "82bf0e24b242e0ee692ba1f28ec1f9ccbf8e4b54", "log": "Java-readability cleanup. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=48189762", "commit": "\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Lists;\n import java.util.zip.GZIPOutputStream;\n \n /**\n+ * A PerformanceTracker collects statistics about the runtime of each pass, and\n+ * how much a pass impacts the size of the compiled output, before and after\n+ * gzip.\n+ *\n  */\n public class PerformanceTracker {\n+\n+  private static final int DEFAULT_WHEN_SIZE_UNTRACKED = -1;\n \n   private final Node jsRoot;\n   private final boolean trackSize;\n   // if there is any.\n   private final RecentChange codeChange = new RecentChange();\n \n-  private int initCodeSize = -1;\n-  private int initGzCodeSize = -1;\n+  private int initCodeSize = DEFAULT_WHEN_SIZE_UNTRACKED;\n+  private int initGzCodeSize = DEFAULT_WHEN_SIZE_UNTRACKED;\n \n   private int runtime = 0;\n   private int runs = 0;\n   // They do not take into account preserved license blocks, newline padding,\n   // or pretty printing (if enabled), since they don't use CodePrinter.\n   // To get exact sizes, call compiler.toSource() for the final generated code.\n-  private int codeSize = -1;  // estimate\n-  private int gzCodeSize = -1;  // estimate\n-  private int diff = 0;  // estimate\n-  private int gzDiff = 0;  // estimate\n+  private int codeSize = DEFAULT_WHEN_SIZE_UNTRACKED;\n+  private int gzCodeSize = DEFAULT_WHEN_SIZE_UNTRACKED;\n+  private int diff = 0;\n+  private int gzDiff = 0;\n \n   private final Deque<Stats> currentPass = new ArrayDeque<Stats>();\n \n   private final Map<String, Stats> summary = Maps.newHashMap();\n \n   // To share with the rest of the program\n-  private ImmutableMap<String, Stats> summaryCopy = null;\n+  private ImmutableMap<String, Stats> summaryCopy;\n \n   /** Stats for each run of a compiler pass. */\n   private final List<Stats> log = Lists.newArrayList();\n-\n-  /** For each pass, keep track of the runtime, the size changes, etc */\n-  public static class Stats {\n-    Stats(String pass, boolean iot) {\n-      this.pass = pass;\n-      this.isOneTime = iot;\n-    }\n-    public final String pass;\n-    public final boolean isOneTime;\n-    public long runtime = 0;\n-    public int runs = 0;\n-    public int changes = 0;\n-    public int diff = 0;  // estimate\n-    public int gzDiff = 0;  // estimate\n-    public int size;  // estimate\n-    public int gzSize;  // estimate\n-  }\n \n   PerformanceTracker(Node jsRoot, TracerMode mode) {\n     this.jsRoot = jsRoot;\n \n       case OFF:\n       default:\n-        throw new UnsupportedOperationException();\n+        throw new IllegalArgumentException(\n+            \"PerformanceTracker can't work without tracer data.\");\n     }\n   }\n \n   }\n \n   void recordPassStart(String passName, boolean isOneTime) {\n+    Preconditions.checkState(summaryCopy == null);\n     currentPass.push(new Stats(passName, isOneTime));\n     codeChange.reset();\n   }\n \n   /**\n-   * Record that a pass has stopped.\n+   * Collects information about a pass P after P finishes running, eg, how much\n+   * time P took and what was its impact on code size.\n    *\n-   * @param passName Short name of the pass.\n-   * @param result Execution time.\n+   * @param passName short name of the pass\n+   * @param runtime execution time in milliseconds\n    */\n-  void recordPassStop(String passName, long result) {\n+  void recordPassStop(String passName, long runtime) {\n+    Preconditions.checkState(summaryCopy == null);\n     Stats logStats = currentPass.pop();\n-    if (!passName.equals(logStats.pass)) {\n-      throw new RuntimeException(passName + \" is not running.\");\n-    }\n+    Preconditions.checkState(passName.equals(logStats.pass));\n \n     // After parsing, initialize codeSize and gzCodeSize\n     if (passName.equals(Compiler.PARSING_PASS_NAME) && trackSize) {\n     }\n \n     // Update fields that aren't related to code size\n-    logStats.runtime = result;\n+    logStats.runtime = runtime;\n     logStats.runs = 1;\n-    summaryStats.runtime += result;\n+    summaryStats.runtime += runtime;\n     summaryStats.runs += 1;\n     if (codeChange.hasCodeChanged()) {\n       logStats.changes = 1;\n     return gzCodeSize;\n   }\n \n+  @VisibleForTesting\n+  int getChanges() {\n+    calcTotalStats();\n+    return changes;\n+  }\n+\n+  @VisibleForTesting\n+  int getLoopChanges() {\n+    calcTotalStats();\n+    return loopChanges;\n+  }\n+\n+  @VisibleForTesting\n+  int getRuns() {\n+    calcTotalStats();\n+    return runs;\n+  }\n+\n+  @VisibleForTesting\n+  int getLoopRuns() {\n+    calcTotalStats();\n+    return loopRuns;\n+  }\n+\n   public ImmutableMap<String, Stats> getStats() {\n     calcTotalStats();\n     return summaryCopy;\n-  }\n-\n-  class CmpEntries implements Comparator<Entry<String, Stats>> {\n-    @Override\n-    public int compare(Entry<String, Stats> e1, Entry<String, Stats> e2) {\n-      return (int) (e1.getValue().runtime - e2.getValue().runtime);\n-    }\n   }\n \n   private void calcTotalStats() {\n       gzDiff += stats.gzDiff;\n     }\n     Preconditions.checkState(!trackSize || initCodeSize == diff + codeSize);\n-    Preconditions.checkState(!trackGzSize ||\n-        initGzCodeSize == gzDiff + gzCodeSize);\n-  }\n-\n+    Preconditions.checkState(!trackGzSize\n+        || initGzCodeSize == gzDiff + gzCodeSize);\n+  }\n+\n+  /**\n+   * Prints a summary, which contains aggregate stats for all runs of each pass\n+   * and a log, which contains stats for each individual run.\n+   */\n   public void outputTracerReport(PrintStream pstr) {\n     JvmMetrics.maybeWriteJvmMetrics(pstr, \"verbose:pretty:all\");\n     OutputStreamWriter output = new OutputStreamWriter(pstr);\n     try {\n       calcTotalStats();\n \n-      ArrayList<Entry<String, Stats>> a = new ArrayList<Entry<String, Stats>>();\n+      ArrayList<Entry<String, Stats>> statEntries = Lists.newArrayList();\n       for (Entry<String, Stats> entry : summary.entrySet()) {\n-        a.add(entry);\n-      }\n-      Collections.sort(a, new CmpEntries());\n+        statEntries.add(entry);\n+      }\n+      Collections.sort(statEntries,\n+          new Comparator<Entry<String, Stats>>() {\n+            @Override\n+            public int compare(\n+                Entry<String, Stats> e1, Entry<String, Stats> e2) {\n+              return (int) (e1.getValue().runtime - e2.getValue().runtime);\n+            }\n+          });\n \n       output.write(\"Summary:\\n\" +\n           \"pass,runtime,runs,changingRuns,reduction,gzReduction\\n\");\n-      for (Entry<String, Stats> entry : a) {\n+      for (Entry<String, Stats> entry : statEntries) {\n         String key = entry.getKey();\n         Stats stats = entry.getValue();\n-        output.write(key + \",\" +\n-            String.valueOf(stats.runtime) + \",\" +\n-            String.valueOf(stats.runs) + \",\" +\n-            String.valueOf(stats.changes) + \",\" +\n-            String.valueOf(stats.diff) + \",\" +\n-            String.valueOf(stats.gzDiff) + \"\\n\");\n+        output.write(String.format(\"%s,%d,%d,%d,%d,%d\\n\", key, stats.runtime,\n+            stats.runs, stats.changes, stats.diff, stats.gzDiff));\n       }\n       output.write(\"\\nTOTAL:\" +\n           \"\\nRuntime(ms): \" + String.valueOf(runtime) +\n       output.write(\"Log:\\n\" +\n           \"pass,runtime,runs,changingRuns,reduction,gzReduction,size,gzSize\\n\");\n       for (Stats stats : log) {\n-        output.write(stats.pass + \",\" +\n-            String.valueOf(stats.runtime) + \",\" +\n-            String.valueOf(stats.runs) + \",\" +\n-            String.valueOf(stats.changes) + \",\" +\n-            String.valueOf(stats.diff) + \",\" +\n-            String.valueOf(stats.gzDiff) + \",\" +\n-            String.valueOf(stats.size) + \",\" +\n-            String.valueOf(stats.gzSize) + \"\\n\");\n+        output.write(String.format(\"%s,%d,%d,%d,%d,%d,%d,%d\\n\",\n+            stats.pass, stats.runtime, stats.runs, stats.changes,\n+            stats.diff, stats.gzDiff, stats.size, stats.gzSize));\n       }\n       output.write(\"\\n\");\n       output.close();\n     } catch (IOException e) {\n-      e.printStackTrace();\n+      throw new RuntimeException(\"Failed to write statistics to output.\", e);\n     }\n   }\n \n   /**\n-   * Purely use to get a code size estimate and not generate any code at all.\n+   * A Stats object contains statistics about a pass run, such as running time,\n+   * size changes, etc\n    */\n+  public static class Stats {\n+    Stats(String pass, boolean iot) {\n+      this.pass = pass;\n+      this.isOneTime = iot;\n+    }\n+    public final String pass;\n+    public final boolean isOneTime;\n+    public long runtime = 0;\n+    public int runs = 0;\n+    public int changes = 0;\n+    public int diff = 0;\n+    public int gzDiff = 0;\n+    public int size;\n+    public int gzSize;\n+  }\n+\n+  /** An object to get a gzsize estimate; it doesn't generate code. */\n   private final class CodeSizeEstimatePrinter extends CodeConsumer {\n     private int size = 0;\n     private char lastChar = '\\0';\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n import com.google.javascript.rhino.Node;\n \n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.logging.Logger;\n \n /**\n- * Optimizes the order of compiler passes.\n+ * An object that optimizes the order of compiler passes.\n+ *\n  * @author nicksantos@google.com (Nick Santos)\n  * @author dimvar@google.com (Dimitris Vardoulakis)\n  */\n class PhaseOptimizer implements CompilerPass {\n \n-  // NOTE(user): There used to be some code that tried various orderings of\n-  // loopable passes and picked the fastest one. This code became stale\n-  // gradually and I decided to remove it. It was also never tried after the\n-  // new pass scheduler was written. If we need to revisit this order in the\n-  // future, we should write new code to do it.\n-  @VisibleForTesting\n-  static final List<String> OPTIMAL_ORDER = ImmutableList.of(\n-     \"deadAssignmentsElimination\",\n-     \"inlineFunctions\",\n-     \"removeUnusedPrototypeProperties\",\n-     \"removeUnreachableCode\",\n-     \"removeUnusedVars\",\n-     \"minimizeExitPoints\",\n-     \"inlineVariables\",\n-     \"collapseObjectLiterals\",\n-     \"peepholeOptimizations\");\n-\n-  static final int MAX_LOOPS = 100;\n-  static final String OPTIMIZE_LOOP_ERROR =\n-      \"Fixed point loop exceeded the maximum number of iterations.\";\n-\n-  // Only used by Loop/process, but enum types can't be local\n-  enum State {\n-    RUN_PASSES_NOT_RUN_IN_PREV_ITER,\n-    RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER\n-  }\n-\n   private static final Logger logger =\n       Logger.getLogger(PhaseOptimizer.class.getName());\n-\n-  private final List<CompilerPass> passes = Lists.newArrayList();\n-\n   private final AbstractCompiler compiler;\n   private final PerformanceTracker tracker;\n+  private final List<CompilerPass> passes;\n   private boolean inLoop;\n-  private PassFactory sanityCheck = null;\n+  private PassFactory sanityCheck;\n   private boolean printAstHashcodes = false;\n \n   private double progress = 0.0;\n   private Map<Node, Node> mtoc; // Stands for \"main to clone\"\n \n   /**\n+   * When processing loopable passes in order, the PhaseOptimizer can be in one\n+   * of these two states.\n+   * <p>\n+   * This enum is used by Loop/process only, but enum types can't be local.\n+   */\n+  enum State {\n+    RUN_PASSES_NOT_RUN_IN_PREV_ITER,\n+    RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER\n+  }\n+\n+  // NOTE(user): There used to be some code that tried various orderings of\n+  // loopable passes and picked the fastest one. This code became stale\n+  // gradually and I decided to remove it. It was also never tried after the\n+  // new pass scheduler was written. If we need to revisit this order in the\n+  // future, we should write new code to do it.\n+  @VisibleForTesting\n+  static final List<String> OPTIMAL_ORDER = ImmutableList.of(\n+     \"deadAssignmentsElimination\",\n+     \"inlineFunctions\",\n+     \"removeUnusedPrototypeProperties\",\n+     \"removeUnreachableCode\",\n+     \"removeUnusedVars\",\n+     \"minimizeExitPoints\",\n+     \"inlineVariables\",\n+     \"collapseObjectLiterals\",\n+     \"peepholeOptimizations\");\n+\n+  static final int MAX_LOOPS = 100;\n+  static final String OPTIMIZE_LOOP_ERROR =\n+      \"Fixed point loop exceeded the maximum number of iterations.\";\n+\n+  /**\n    * @param compiler the compiler that owns/creates this.\n    * @param tracker an optional performance tracker\n    * @param progressRange the progress range for the process function or null\n-   * if progress should not be reported.\n-   */\n-  PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker,\n-      ProgressRange progressRange) {\n-    this.compiler = compiler;\n-    this.jsRoot = compiler.getJsRoot();\n+   *        if progress should not be reported.\n+   */\n+  PhaseOptimizer(\n+      AbstractCompiler comp, PerformanceTracker tracker, ProgressRange range) {\n+    this.compiler = comp;\n+    this.jsRoot = comp.getJsRoot();\n     this.tracker = tracker;\n-    this.progressRange = progressRange;\n+    this.passes = Lists.newArrayList();\n+    this.progressRange = range;\n     this.inLoop = false;\n     this.crossScopeReporting = false;\n     this.timestamp = this.lastChange = START_TIME;\n \n   /**\n    * Add the passes generated by the given factories to the compile sequence.\n-   *\n+   * <p>\n    * Automatically pulls multi-run passes into fixed point loops. If there\n    * are 1 or more multi-run passes in a row, they will run together in\n    * the same fixed point loop. The passes will run until they are finished\n    * making changes.\n-   *\n+   * <p>\n    * The PhaseOptimizer is free to tweak the order and frequency of multi-run\n    * passes in a fixed-point loop.\n    */\n         }\n         maybePrintAstHashcodes(name, root);\n         maybeSanityCheck(externs, root);\n-      } catch (Exception e) {\n+      } catch (IllegalStateException e) {\n         // TODO(johnlenz): Remove this once the normalization checks report\n         // errors instead of exceptions.\n         throw new RuntimeException(\"Sanity check failed for \" + name, e);\n     }\n   }\n \n-  /** {@code n} is either a function or the top-level node of the AST */\n   void setScope(Node n) {\n     // NodeTraversal causes setScope calls outside loops; ignore them.\n     if (inLoop) {\n+      // Find the top-level node in the scope.\n       currentScope = n.isFunction() ? n : getEnclosingScope(n);\n     }\n   }\n     timestamp++;\n   }\n \n-  // This method and the next one are used so that we don't falsely report the\n-  // current scope as changed when reportChangeToScope is called from Compiler.\n+  /**\n+   * Records that the currently-running pass may report cross-scope changes.\n+   * When this happens, we don't want to falsely report the current scope as\n+   * changed when reportChangeToScope is called from Compiler.\n+   */\n   void startCrossScopeReporting() {\n     crossScopeReporting = true;\n   }\n \n+  /** The currently-running pass won't report cross-scope changes. */\n   void endCrossScopeReporting() {\n     crossScopeReporting = false;\n   }\n \n+  /**\n+   * A change handler that marks scopes as changed when reportChange is called.\n+   */\n   private class ScopedChangeHandler implements CodeChangeHandler {\n     private int lastCodeChangeQuery;\n \n   }\n \n   /**\n-   * Runs a set of compiler passes until they reach a fixed point.\n-   *\n+   * A compound pass that contains atomic passes and runs them until they reach\n+   * a fixed point.\n+   * <p>\n    * Notice that this is a non-static class, because it includes the closure\n    * of PhaseOptimizer.\n    */\n+  @VisibleForTesting\n   class Loop implements CompilerPass {\n     private final List<NamedPass> myPasses = Lists.newArrayList();\n     private final Set<String> myNames = Sets.newHashSet();\n         lastRuns.put(pass, START_TIME);\n       }\n       // Contains a pass iff it made changes the last time it was run.\n-      Set<NamedPass> madeChanges = new HashSet<NamedPass>();\n+      Set<NamedPass> madeChanges = Sets.newHashSet();\n       // Contains a pass iff it was run during the last inner loop.\n-      Set<NamedPass> runInPrevIter = new HashSet<NamedPass>();\n-      State s = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;\n+      Set<NamedPass> runInPrevIter = Sets.newHashSet();\n+      State state = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;\n       boolean lastIterMadeChanges;\n       int count = 0;\n \n           }\n           lastIterMadeChanges = false;\n           for (NamedPass pass : myPasses) {\n-            if ((s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER &&\n-                !runInPrevIter.contains(pass)) ||\n-                (s == State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER &&\n-                    madeChanges.contains(pass))) {\n+            if ((state == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER\n+                    && !runInPrevIter.contains(pass))\n+                || (state == State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER\n+                        && madeChanges.contains(pass))) {\n               timestamp++;\n               currentPass = pass;\n               pass.process(externs, root);\n               runInPrevIter.remove(pass);\n             }\n           }\n-          if (s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER) {\n+\n+          if (state == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER) {\n             if (lastIterMadeChanges) {\n-              s = State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER;\n+              state = State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER;\n             } else {\n               return;\n             }\n-          } else if (!lastIterMadeChanges) {\n-            s = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;\n+          } else { // state == State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER\n+            if (!lastIterMadeChanges) {\n+              state = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;\n+            }\n           }\n         }\n       } finally {\n       // To do this, grab any passes we recognize, and move them to the end\n       // in an \"optimal\" order.\n       List<NamedPass> optimalPasses = Lists.newArrayList();\n-      for (String passName : OPTIMAL_ORDER) {\n-        for (NamedPass pass : myPasses) {\n-          if (pass.name.equals(passName)) {\n-            optimalPasses.add(pass);\n+      for (String passInOptimalOrder : OPTIMAL_ORDER) {\n+        for (NamedPass loopablePass : myPasses) {\n+          if (loopablePass.name.equals(passInOptimalOrder)) {\n+            optimalPasses.add(loopablePass);\n             break;\n           }\n         }\n     }\n   }\n \n+  /**\n+   * An object used when running many NamedPass loopable passes as a Loop pass,\n+   * to keep track of how far along we are.\n+   */\n   static class ProgressRange {\n     public final double initialValue;\n     public final double maxValue;\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n-import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.util.List;\n-import java.util.regex.Pattern;\n \n /**\n  * Tests for {@link PassFactory}.\n     test(options, original.toString(), \"var x = \" + numAdds + \";\");\n   }\n \n-  // Checks that the summary and the log in the output of PerformanceTracker\n-  // have the expected number of columns\n-  public void testPerfTracker() {\n-    ByteArrayOutputStream output = new ByteArrayOutputStream();\n-    PrintStream outstream = new PrintStream(output);\n-    Compiler compiler = new Compiler(outstream);\n-    CompilerOptions options = new CompilerOptions();\n-    List<SourceFile> inputs = Lists.newArrayList();\n-    List<SourceFile> externs = Lists.newArrayList();\n-\n-    options.setTracerMode(TracerMode.ALL);\n-    inputs.add(SourceFile.fromCode(\"foo\", \"function fun(){}\"));\n-    compiler.compile(externs, inputs, options);\n-    outstream.flush();\n-    outstream.close();\n-    Pattern p = Pattern.compile(\n-        \".*Summary:\\npass,runtime,runs,changingRuns,reduction,gzReduction\" +\n-        \".*TOTAL:\" +\n-        \"\\nRuntime\\\\(ms\\\\): [0-9]+\" +\n-        \"\\n#Runs: [0-9]+\" +\n-        \"\\n#Changing runs: [0-9]+\" +\n-        \"\\n#Loopable runs: [0-9]+\" +\n-        \"\\n#Changing loopable runs: [0-9]+\" +\n-        \"\\nEstimated Reduction\\\\(bytes\\\\): [0-9]+\" +\n-        \"\\nEstimated GzReduction\\\\(bytes\\\\): [0-9]+\" +\n-        \"\\nEstimated Size\\\\(bytes\\\\): [0-9]+\" +\n-        \"\\nEstimated GzSize\\\\(bytes\\\\): [0-9]+\" +\n-        \"\\n\\nLog:\\n\" +\n-        \"pass,runtime,runs,changingRuns,reduction,gzReduction,size,gzSize.*\",\n-        Pattern.DOTALL);\n-    assertTrue(p.matcher(output.toString()).matches());\n-  }\n-\n   // isEquivalentTo returns false for alpha-equivalent nodes\n   public void testIsEquivalentTo() {\n     String[] input1 = {\"function f(z) { return z; }\"};\n--- a/test/com/google/javascript/jscomp/MultiPassTest.java\n+++ b/test/com/google/javascript/jscomp/MultiPassTest.java\n import java.util.List;\n \n /**\n- */\n-\n-/**\n  * This file contains the only tests that use the infrastructure in\n  * CompilerTestCase to run multiple passes and do sanity checks. The other files\n  * that use CompilerTestCase unit test a single pass.\n+ *\n  */\n public class MultiPassTest extends CompilerTestCase {\n   private List<PassFactory> passes;\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    PhaseOptimizer po = new PhaseOptimizer(compiler, null, null);\n-    po.consume(passes);\n-    po.setSanityCheck(new PassFactory(\"sanityCheck\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          return new SanityCheck(compiler);\n-        }\n-      });\n-    compiler.setPhaseOptimizer(po);\n-    return po;\n+    PhaseOptimizer phaseopt = new PhaseOptimizer(compiler, null, null);\n+    phaseopt.consume(passes);\n+    phaseopt.setSanityCheck(\n+        new PassFactory(\"sanityCheck\", false) {\n+          @Override\n+          protected CompilerPass create(AbstractCompiler compiler) {\n+            return new SanityCheck(compiler);\n+          }\n+        });\n+    compiler.setPhaseOptimizer(phaseopt);\n+    return phaseopt;\n   }\n \n   public void testInlineVarsAndPeephole() {\n   }\n \n   private void addCollapseObjectLiterals() {\n-    passes.add(new PassFactory(\"collapseObjectLiterals\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          return new InlineObjectLiterals(\n-              compiler, compiler.getUniqueNameIdSupplier());\n-        }\n-      });\n+    passes.add(\n+        new PassFactory(\"collapseObjectLiterals\", false) {\n+          @Override\n+          protected CompilerPass create(AbstractCompiler compiler) {\n+            return new InlineObjectLiterals(\n+                compiler, compiler.getUniqueNameIdSupplier());\n+          }\n+        });\n   }\n \n   private void addDeadCodeElimination() {\n-    passes.add(new PassFactory(\"removeUnreachableCode\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          return new UnreachableCodeElimination(compiler, true);\n-        }\n-      });\n+    passes.add(\n+        new PassFactory(\"removeUnreachableCode\", false) {\n+          @Override\n+          protected CompilerPass create(AbstractCompiler compiler) {\n+            return new UnreachableCodeElimination(compiler, true);\n+          }\n+        });\n   }\n \n   private void addInlineFunctions() {\n-    passes.add(new PassFactory(\"inlineFunctions\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          return new InlineFunctions(compiler,\n-              compiler.getUniqueNameIdSupplier(), true, true, true, true, true);\n-        }\n-      });\n+    passes.add(\n+        new PassFactory(\"inlineFunctions\", false) {\n+          @Override\n+          protected CompilerPass create(AbstractCompiler compiler) {\n+            return new InlineFunctions(\n+                compiler, compiler.getUniqueNameIdSupplier(),\n+                true, true, true, true, true);\n+          }\n+        });\n   }\n \n   private void addInlineVariables() {\n-    passes.add(new PassFactory(\"inlineVariables\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          return new InlineVariables(compiler, InlineVariables.Mode.ALL, true);\n-        }\n-      });\n+    passes.add(\n+        new PassFactory(\"inlineVariables\", false) {\n+          @Override\n+          protected CompilerPass create(AbstractCompiler compiler) {\n+            return new InlineVariables(\n+                compiler, InlineVariables.Mode.ALL, true);\n+          }\n+        });\n   }\n \n   private void addPeephole() {\n-    passes.add(new PassFactory(\"peepholeOptimizations\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          final boolean late = false;\n-          return new PeepholeOptimizationsPass(compiler,\n-              new PeepholeMinimizeConditions(late),\n-              new PeepholeSubstituteAlternateSyntax(late),\n-              new PeepholeReplaceKnownMethods(late),\n-              new PeepholeRemoveDeadCode(),\n-              new PeepholeFoldConstants(late),\n-              new PeepholeCollectPropertyAssignments());\n-        }\n-      });\n+    passes.add(\n+        new PassFactory(\"peepholeOptimizations\", false) {\n+          @Override\n+          protected CompilerPass create(AbstractCompiler compiler) {\n+            final boolean late = false;\n+            return new PeepholeOptimizationsPass(compiler,\n+                new PeepholeMinimizeConditions(late),\n+                new PeepholeSubstituteAlternateSyntax(late),\n+                new PeepholeReplaceKnownMethods(late),\n+                new PeepholeRemoveDeadCode(),\n+                new PeepholeFoldConstants(late),\n+                new PeepholeCollectPropertyAssignments());\n+          }\n+        });\n   }\n \n   private void addRemoveUnusedClassProperties() {\n-    passes.add(new PassFactory(\"removeUnusedClassProperties\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          return new RemoveUnusedClassProperties(compiler);\n-        }\n-      });\n+    passes.add(\n+        new PassFactory(\"removeUnusedClassProperties\", false) {\n+          @Override\n+          protected CompilerPass create(AbstractCompiler compiler) {\n+            return new RemoveUnusedClassProperties(compiler);\n+          }\n+        });\n   }\n \n   private void addRemoveUnusedVars() {\n-    passes.add(new PassFactory(\"removeUnusedVars\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          return new RemoveUnusedVars(compiler, false, false, false);\n-        }\n-      });\n+    passes.add(\n+        new PassFactory(\"removeUnusedVars\", false) {\n+          @Override\n+          protected CompilerPass create(AbstractCompiler compiler) {\n+            return new RemoveUnusedVars(compiler, false, false, false);\n+          }\n+        });\n   }\n }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PerformanceTrackerTest.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n+import com.google.javascript.jscomp.PerformanceTracker.Stats;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Unit tests for PerformanceTracker.\n+ *\n+ */\n+public class PerformanceTrackerTest extends TestCase {\n+  private Node emptyScript = new Node(Token.SCRIPT);\n+\n+  public void testStatsCalculation() {\n+    PerformanceTracker tracker =\n+        new PerformanceTracker(emptyScript, TracerMode.ALL);\n+    CodeChangeHandler handler = tracker.getCodeChangeHandler();\n+\n+    // It's sufficient for this test to assume that a single run of any pass\n+    // takes some fixed amount of time, say 5ms.\n+    int passRuntime = 5;\n+\n+    tracker.recordPassStart(\"noloopA\", true);\n+    handler.reportChange();\n+    tracker.recordPassStop(\"noloopA\", passRuntime);\n+\n+    tracker.recordPassStart(\"noloopB\", true);\n+    handler.reportChange();\n+    tracker.recordPassStop(\"noloopB\", passRuntime);\n+\n+    tracker.recordPassStart(\"loopA\", false);\n+    handler.reportChange();\n+    tracker.recordPassStop(\"loopA\", passRuntime);\n+\n+    tracker.recordPassStart(\"loopA\", false);\n+    tracker.recordPassStop(\"loopA\", passRuntime);\n+\n+    tracker.recordPassStart(\"noloopB\", true);\n+    handler.reportChange();\n+    tracker.recordPassStop(\"noloopB\", passRuntime);\n+\n+    tracker.recordPassStart(\"loopB\", false);\n+    tracker.recordPassStop(\"loopB\", passRuntime);\n+\n+    tracker.recordPassStart(\"noloopB\", true);\n+    tracker.recordPassStop(\"noloopB\", passRuntime);\n+\n+    int numRuns = tracker.getRuns();\n+\n+    assertEquals(numRuns, 7);\n+    assertEquals(tracker.getRuntime(), numRuns * passRuntime);\n+    assertEquals(tracker.getLoopRuns(), 3);\n+    assertEquals(tracker.getChanges(), 4); /* reportChange was called 4 times */\n+    assertEquals(tracker.getLoopChanges(), 1);\n+\n+    ImmutableMap<String, Stats> stats = tracker.getStats();\n+    Stats st = stats.get(\"noloopA\");\n+    assertEquals(st.runs, 1);\n+    assertEquals(st.runtime, passRuntime);\n+    assertEquals(st.changes, 1);\n+\n+    st = stats.get(\"noloopB\");\n+    assertEquals(st.runs, 3);\n+    assertEquals(st.runtime, 3 * passRuntime);\n+    assertEquals(st.changes, 2);\n+\n+    st = stats.get(\"loopA\");\n+    assertEquals(st.runs, 2);\n+    assertEquals(st.runtime, 2 * passRuntime);\n+    assertEquals(st.changes, 1);\n+\n+    st = stats.get(\"loopB\");\n+    assertEquals(st.runs, 1);\n+    assertEquals(st.runtime, passRuntime);\n+    assertEquals(st.changes, 0);\n+  }\n+\n+  public void testOutputFormat() {\n+    PerformanceTracker tracker =\n+        new PerformanceTracker(emptyScript, TracerMode.ALL);\n+    ByteArrayOutputStream output = new ByteArrayOutputStream();\n+    PrintStream outstream = new PrintStream(output);\n+    tracker.outputTracerReport(outstream);\n+    outstream.flush();\n+    outstream.close();\n+    Pattern p = Pattern.compile(\n+        \".*Summary:\\npass,runtime,runs,changingRuns,reduction,gzReduction\" +\n+        \".*TOTAL:\" +\n+        \"\\nRuntime\\\\(ms\\\\): [0-9]+\" +\n+        \"\\n#Runs: [0-9]+\" +\n+        \"\\n#Changing runs: [0-9]+\" +\n+        \"\\n#Loopable runs: [0-9]+\" +\n+        \"\\n#Changing loopable runs: [0-9]+\" +\n+        \"\\nEstimated Reduction\\\\(bytes\\\\): [0-9]+\" +\n+        \"\\nEstimated GzReduction\\\\(bytes\\\\): [0-9]+\" +\n+        \"\\nEstimated Size\\\\(bytes\\\\): -?[0-9]+\" +\n+        \"\\nEstimated GzSize\\\\(bytes\\\\): -?[0-9]+\" +\n+        \"\\n\\nLog:\\n\" +\n+        \"pass,runtime,runs,changingRuns,reduction,gzReduction,size,gzSize.*\",\n+        Pattern.DOTALL);\n+    String outputString = output.toString();\n+    assertTrue(\"Unexpected output from PerformanceTracker:\\n\" + outputString,\n+        p.matcher(outputString).matches());\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n     assertPasses(\"x\", \"x\", \"x\", \"x\");\n   }\n \n-  public void testLoop3() {\n+  public void testSchedulingOfLoopablePasses() {\n     Loop loop = optimizer.addFixedPointLoop();\n     addLoopedPass(loop, \"x\", 3);\n     addLoopedPass(loop, \"y\", 1);\n+    // The pass iterations can be grouped as: [x y] [x y] [x] [x] [y]\n     assertPasses(\"x\", \"y\", \"x\", \"y\", \"x\", \"x\", \"y\");\n   }\n \n       optimizer.process(null, dummyRoot);\n       fail(\"Expected RuntimeException\");\n     } catch (RuntimeException e) {\n-      assertTrue(e.getMessage().contains(PhaseOptimizer.OPTIMIZE_LOOP_ERROR));\n+      assertTrue(e.getMessage(),\n+          e.getMessage().contains(PhaseOptimizer.OPTIMIZE_LOOP_ERROR));\n     }\n   }\n \n-  public void testCombined() {\n+  public void testSchedulingOfAnyKindOfPasses1() {\n     addOneTimePass(\"a\");\n     Loop loop = optimizer.addFixedPointLoop();\n     addLoopedPass(loop, \"x\", 3);\n     assertPasses(\"a\", \"x\", \"y\", \"x\", \"y\", \"x\", \"x\", \"y\", \"z\");\n   }\n \n-  public void testConsumption1() {\n+  public void testSchedulingOfAnyKindOfPasses2() {\n     optimizer.consume(\n         Lists.newArrayList(\n             createPassFactory(\"a\", 0, true),\n             createPassFactory(\"d\", 1, false),\n             createPassFactory(\"e\", 1, true),\n             createPassFactory(\"f\", 0, true)));\n+    // The pass iterations can be grouped as:\n+    // [a] [b c d] [b c d] [c] [b d] [e] [f]\n     assertPasses(\"a\", \"b\", \"c\", \"d\", \"b\", \"c\", \"d\", \"c\", \"b\", \"d\", \"e\", \"f\");\n   }\n \n-  public void testConsumption2() {\n+  public void testSchedulingOfAnyKindOfPasses3() {\n     optimizer.consume(\n         Lists.newArrayList(\n             createPassFactory(\"a\", 2, false),\n     assertPasses(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\");\n   }\n \n-  public void testConsumption3() {\n+  public void testSchedulingOfAnyKindOfPasses4() {\n     optimizer.consume(\n         Lists.newArrayList(\n             createPassFactory(\"a\", 2, true),", "timestamp": 1371603288, "metainfo": ""}