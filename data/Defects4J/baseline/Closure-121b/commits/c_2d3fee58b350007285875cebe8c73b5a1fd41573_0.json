{"sha": "2d3fee58b350007285875cebe8c73b5a1fd41573", "log": "Change RescopeGlobalSymbols to not rewrite variables that do not cross JSModules.  Reduces code size and speeds up code.  The change tries to leave as much JS code intact as possible if i.e. none of the vars in a var statement have to rewritten, the code is left untouched.  As a followup it may be interesting to the rename-passes again after this pass and/or wrap each module in an immediately called function so that names can be reused. Both may show some benefits after GZIP. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46751454", "commit": "\n--- a/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n+++ b/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n  */\n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\n import com.google.javascript.rhino.IR;\n   private final AbstractCompiler compiler;\n   private final String globalSymbolNamespace;\n   private final boolean addExtern;\n+  private final Set<String> crossModuleNames = Sets.newHashSet();\n+\n+  @VisibleForTesting\n+  static boolean assumeCrossModuleNames = false;\n \n   RescopeGlobalSymbols(AbstractCompiler compiler, String globalSymbolNamespace,\n       boolean addExtern) {\n   RescopeGlobalSymbols(AbstractCompiler compiler,\n       String globalSymbolNamespace) {\n     this(compiler, globalSymbolNamespace, true);\n+  }\n+\n+  private boolean isCrossModuleName(String name) {\n+    return assumeCrossModuleNames || crossModuleNames.contains(name);\n   }\n \n   private void addExternForGlobalSymbolNamespace() {\n     }\n     // Rewrite all references to global symbols to properties of a\n     // single symbol by:\n-    // (If necessary the 3 traversals could be combined. They are left\n+    // (If necessary the 4 traversals could be combined. They are left\n     // separate for readability reasons.)\n     // 1. turning global named function statements into var assignments.\n     NodeTraversal.traverse(compiler, root,\n         new RewriteGlobalFunctionStatementsToVarAssignmentsCallback());\n-    // 2. rewriting all references to be property accesses of the single symbol.\n+    // 2. find global names than are used in more than one module. Those that\n+    //    are have to be rewritten.\n+    NodeTraversal.traverse(compiler, root, new FindCrossModuleNamesCallback());\n+    // 3. rewriting all references to be property accesses of the single symbol.\n     NodeTraversal.traverse(compiler, root, new RewriteScopeCallback());\n-    // 3. removing the var from every statement in global scope.\n+    // 4. removing the var from statements in global scope if the declared names\n+    //    have been rewritten in the previous pass.\n     NodeTraversal.traverse(compiler, root, new RemoveGlobalVarCallback());\n \n     // Extra pass which makes all extern global symbols reference window\n   }\n \n   /**\n+   * Find all global names that are used in more than one module. The following\n+   * compiler transformations can ignore the globals that are not.\n+   */\n+  private class FindCrossModuleNamesCallback extends\n+      AbstractPostOrderCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isName()) {\n+        String name = n.getString();\n+        if (\"\".equals(name) || crossModuleNames.contains(name)) {\n+          return;\n+        }\n+        Scope s = t.getScope();\n+        Scope.Var v = s.getVar(name);\n+        if (v == null || !v.isGlobal()) {\n+          return;\n+        }\n+        CompilerInput input = v.getInput();\n+        if (input == null) {\n+          // We know nothing. Assume name is used across modules.\n+          crossModuleNames.add(name);\n+          return;\n+        }\n+        // Compare the module where the variable is declared to the current\n+        // module. If they are different, the variable is used across modules.\n+        JSModule module = input.getModule();\n+        if (module != t.getModule()) {\n+          crossModuleNames.add(name);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n    * Visits each NAME token and checks whether it refers to a global variable.\n    * If yes, rewrites the name to be a property access on the\n    * \"globalSymbolNamespace\".\n       // add suffix to avoid shadowing the namespace. Also add a suffix\n       // if a name starts with the name of the globalSymbolNamespace and\n       // the suffix.\n-      if (!var.isExtern() && (name.equals(globalSymbolNamespace) ||\n+      if (!var.isExtern() && !var.isGlobal() &&\n+          (name.equals(globalSymbolNamespace) ||\n           name.indexOf(globalSymbolNamespace + DISAMBIGUATION_SUFFIX) == 0)) {\n         n.setString(name + DISAMBIGUATION_SUFFIX);\n         compiler.reportCodeChange();\n           nameNode.getParent().isCatch()) {\n         return;\n       }\n-      replaceSymbol(n, name);\n-    }\n-\n-    private void replaceSymbol(Node node, String name) {\n+      replaceSymbol(n, name, t.getInput());\n+    }\n+\n+    private void replaceSymbol(Node node, String name, CompilerInput input) {\n       Node parent = node.getParent();\n-      Node replacement = IR.getprop(\n-          IR.name(globalSymbolNamespace).srcref(node),\n-          IR.string(name).srcref(node));\n+      boolean isCrossModule = isCrossModuleName(name);\n+      if (!isCrossModule) {\n+        // When a non cross module name appears outside a var declaration we\n+        // never have to do anything.\n+        if (!parent.isVar()) {\n+          return;\n+        }\n+        // If it is a var declaration, but no cross module names are declared\n+        // we also don't have to do anything.\n+        boolean hasCrossModuleChildren = false;\n+        for (Node c : parent.children()) {\n+          // Var child is no longer a name means it was transformed already\n+          // which means there was a cross module name.\n+          if (!c.isName() || isCrossModuleName(c.getString())) {\n+            hasCrossModuleChildren = true;\n+            break;\n+          }\n+        }\n+        if (!hasCrossModuleChildren) {\n+          return;\n+        }\n+      }\n+      Node replacement = isCrossModule\n+          ? IR.getprop(\n+              IR.name(globalSymbolNamespace).srcref(node),\n+              IR.string(name).srcref(node))\n+          : IR.name(name).srcref(node);\n       replacement.srcref(node);\n       if (node.hasChildren()) {\n         // var declaration list: var a = 1, b = 2;\n         Node assign = IR.assign(replacement,\n             node.removeFirstChild());\n         parent.replaceChild(node, assign);\n-      } else {\n+      } else if (isCrossModule) {\n         parent.replaceChild(node, replacement);\n+      }\n+      // If we changed a non cross module name that was in a var declaration\n+      // we need to preserve that var declaration. Because it is global\n+      // anyway, we just put it at the beginning of the current input.\n+      // Example:\n+      // var crossModule = i++, notCrossModule = i++\n+      // becomes\n+      // var notCrossModule;_.crossModule = i++, notCrossModule = i++\n+      if (!isCrossModule && parent.isVar()) {\n+        input.getAstRoot(compiler).addChildToFront(\n+            IR.var(IR.name(name).srcref(node)).srcref(node));\n       }\n       compiler.reportCodeChange();\n     }\n       if (!n.isVar()) {\n         return;\n       }\n+\n       List<Node> commas = new ArrayList<Node>();\n       List<Node> interestingChildren = new ArrayList<Node>();\n       // Filter out declarations without assignments.\n       // As opposed to regular var nodes, there are always assignments\n       // because the previous traversal in RewriteScopeCallback creates\n       // them.\n+      boolean allName = true;\n       for (Node c : n.children()) {\n+        if (!c.isName()) {\n+          allName = false;\n+        }\n         if (c.isAssign() ||\n             parent.isFor()) {\n           interestingChildren.add(c);\n         }\n+      }\n+      // If every child of a var declares a name, it must stay in place.\n+      // This is the case if none of the declared variables cross module\n+      // boundaries.\n+      if (allName) {\n+        return;\n       }\n       for (Node c : interestingChildren) {\n         if (parent.isFor() && parent.getFirstChild() == n) {\n         return;\n       }\n       String name = n.getString();\n+      if (globalSymbolNamespace.equals(name) ||\n+          SPECIAL_EXTERNS.contains(name)) {\n+        return;\n+      }\n       Scope.Var var = t.getScope().getVar(name);\n-      if (name.length() > 0 && (var == null || var.isExtern()) &&\n-          !globalSymbolNamespace.equals(name) &&\n-          !SPECIAL_EXTERNS.contains(name)) {\n+      if (name.length() > 0 && (var == null || var.isExtern())) {\n         parent.replaceChild(n, IR.getprop(IR.name(WINDOW), IR.string(name))\n             .srcrefTree(n));\n         compiler.reportCodeChange();\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n  * @author nicksantos@google.com (Nick Santos)\n  */\n public class IntegrationTest extends IntegrationTestCase {\n+\n+  @Override public void setUp() {\n+    super.setUp();\n+    RescopeGlobalSymbols.assumeCrossModuleNames = true;\n+  }\n \n   private static final String CLOSURE_BOILERPLATE =\n       \"/** @define {boolean} */ var COMPILED = false; var goog = {};\" +\n--- a/test/com/google/javascript/jscomp/RescopeGlobalSymbolsTest.java\n+++ b/test/com/google/javascript/jscomp/RescopeGlobalSymbolsTest.java\n \n   @Override protected CompilerPass getProcessor(Compiler compiler) {\n     return new RescopeGlobalSymbols(compiler, namespace, false);\n+  }\n+\n+  @Override public void setUp() throws Exception {\n+    super.setUp();\n+    RescopeGlobalSymbols.assumeCrossModuleNames = true;\n   }\n \n   @Override\n     test(\"var a, b = 1;\", \"_.b = 1\");\n   }\n \n+  public void testVarDeclarations_allSameModule() {\n+    RescopeGlobalSymbols.assumeCrossModuleNames = false;\n+    testSame(\"var a = 1;\");\n+    testSame(\"var a = 1, b = 2, c = 3;\");\n+    testSame(\"var a = 'str', b = 1, c = { foo: 'bar' }, d = function() {};\");\n+    testSame(\"if(1){var x = 1;}\");\n+    testSame(\"var x;\");\n+    testSame(\"var a, b = 1;\");\n+  }\n+\n+  public void testVarDeclarations_acrossModules() {\n+    RescopeGlobalSymbols.assumeCrossModuleNames = false;\n+    test(createModules(\n+        \"var a = 1;\", \"a\"),\n+        new String[] {\"_.a = 1\", \"_.a\"});\n+    test(createModules(\n+        \"var a = 1, b = 2, c = 3;\", \"a;c;\"),\n+        new String[] {\"var b;_.a = 1; b = 2; _.c = 3;\", \"_.a;_.c\"});\n+    test(createModules(\n+        \"var a = 1, b = 2, c = 3;\", \"b;c;\"),\n+        new String[] {\"var a;a = 1; _.b = 2; _.c = 3;\", \"_.b;_.c\"});\n+    test(createModules(\n+        \"var a = 1, b = 2, c = 3;b;c;\", \"a;c;\"),\n+        new String[] {\"var b;_.a = 1; b = 2; _.c = 3;b;_.c\", \"_.a;_.c\"});\n+    test(createModules(\n+        \"var a, b = 1;\", \"b\"),\n+        new String[] {\"var a;_.b = 1;\", \"_.b\"});\n+  }\n+\n   public void testForLoops() {\n+    RescopeGlobalSymbols.assumeCrossModuleNames = false;\n+    test(createModules(\n+        \"for (var i = 0, c = 2; i < 1000; i++);\", \"c\"),\n+        new String[] {\"var i;for (i = 0, _.c = 2; i < 1000; i++);\", \"_.c\"});\n+    test(createModules(\n+        \"for (var i = 0, c = 2; i < 1000; i++);\", \"i\"),\n+        new String[] {\"var c;for (_.i = 0, c = 2; _.i < 1000; _.i++);\",\n+            \"_.i\"});\n+  }\n+\n+  public void testForLoops_acrossModules() {\n     test(\"for (var i = 0; i < 1000; i++);\",\n         \"for (_.i = 0; _.i < 1000; _.i++);\");\n     test(\"for (var i = 0, c = 2; i < 1000; i++);\",", "timestamp": 1368838206, "metainfo": ""}