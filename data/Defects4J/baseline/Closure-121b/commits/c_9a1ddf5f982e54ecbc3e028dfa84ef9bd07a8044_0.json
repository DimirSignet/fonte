{"sha": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044", "log": "Merge NodeTypeNormalizer and CodingConventionAnnotator into a single pass. (Nick)    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n   abstract boolean isTypeCheckingEnabled();\n \n   /**\n-   * Normalizes the types of AST nodes in the given tree.\n-   */\n-  abstract void normalizeNodeTypes(Node root);\n-\n-  /**\n-   * Annotates any nodes to which the coding convention applies so that passes\n+   * Normalizes the types of AST nodes in the given tree, and\n+   * annotates any nodes to which the coding convention applies so that passes\n    * can read the annotations instead of using the coding convention.\n    */\n-  abstract void annotateCodingConvention(Node root);\n+  abstract void prepareAst(Node root);\n \n   /**\n    * Acquires the symbol table.\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   }\n \n   @Override\n-  void normalizeNodeTypes(Node root) {\n-    Tracer tracer = newTracer(\"normalizeNodeTypes\");\n-\n-    // TODO(johnlenz): Merge the NodeTypeNormalizer into the AST creator\n-    // it doesn't need to be done separately.\n-    CompilerPass pass = new NodeTypeNormalizer();\n+  void prepareAst(Node root) {\n+    Tracer tracer = newTracer(\"prepareAst\");\n+    CompilerPass pass = new PrepareAst(this);\n     pass.process(null, root);\n-\n-    stopTracer(tracer, \"normalizeNodeTypes\");\n-  }\n-\n-  @Override\n-  void annotateCodingConvention(Node root) {\n-    Tracer tracer = newTracer(\"annotateCodingConvention\");\n-    CompilerPass pass = new CodingConventionAnnotator(this);\n-    pass.process(null, root);\n-    stopTracer(tracer, \"annotateCodingConvention\");\n+    stopTracer(tracer, \"prepareAst\");\n   }\n \n   void recordFunctionInformation() {\n--- a/src/com/google/javascript/jscomp/GenerateExports.java\n+++ b/src/com/google/javascript/jscomp/GenerateExports.java\n \n   private void annotate(Node node) {\n     NodeTraversal.traverse(\n-        compiler, node, new CodingConventionAnnotator(compiler));\n+        compiler, node, new PrepareAst.PrepareAnnotations(compiler));\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n       // There was a parse error or IOException, so use a dummy block.\n       root = new Node(Token.BLOCK);\n     } else {\n-      compiler.normalizeNodeTypes(root);\n-      compiler.annotateCodingConvention(root);\n+      compiler.prepareAst(root);\n     }\n \n     // Set the source name so that the compiler passes can track\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSTypeExpression;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Prepare the AST before we do any checks or optimizations on it.\n+ *\n+ * This pass must run. It should bring the AST into a consistent state,\n+ * and add annotations where necessary. It should not make any transformations\n+ * on the tree that would lose source information, since we need that source\n+ * information for checks.\n+ *\n+*\n+ */\n+class PrepareAst implements CompilerPass {\n+\n+  private final AbstractCompiler compiler;\n+  private final boolean assertOnChange;\n+\n+  PrepareAst(AbstractCompiler compiler) {\n+    this(compiler, false);\n+  }\n+\n+  PrepareAst(AbstractCompiler compiler, boolean forbidChanges) {\n+    this.compiler = compiler;\n+    this.assertOnChange = forbidChanges;\n+  }\n+\n+  private void reportChange() {\n+    if (assertOnChange) {\n+      Preconditions.checkState(false, \"normalizeNodeType constraints violated\");\n+    }\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    normalizeNodeTypes(root);\n+    if (externs != null) {\n+      NodeTraversal.traverse(\n+          compiler, externs, new PrepareAnnotations(compiler));\n+    }\n+    if (root != null) {\n+      NodeTraversal.traverse(\n+          compiler, root, new PrepareAnnotations(compiler));\n+    }\n+  }\n+\n+  /**\n+   * Covert EXPR_VOID to EXPR_RESULT to simplify the rest of the code.\n+   */\n+  private void normalizeNodeTypes(Node n) {\n+    if (n.getType() == Token.EXPR_VOID) {\n+      n.setType(Token.EXPR_RESULT);\n+      reportChange();\n+    }\n+\n+    // Remove unused properties to minimize differences between ASTs\n+    // produced by the two parsers.\n+    if (n.getType() == Token.FUNCTION) {\n+      Preconditions.checkState(n.getProp(Node.FUNCTION_PROP) == null);\n+    }\n+\n+    normalizeBlocks(n);\n+\n+    for (Node child = n.getFirstChild();\n+         child != null; child = child.getNext()) {\n+      // This pass is run during the CompilerTestCase validation, so this\n+      // parent pointer check serves as a more general check.\n+      Preconditions.checkState(child.getParent() == n);\n+\n+      normalizeNodeTypes(child);\n+    }\n+  }\n+\n+  /**\n+   * Add blocks to IF, WHILE, DO, etc.\n+   */\n+  private void normalizeBlocks(Node n) {\n+    if (NodeUtil.isControlStructure(n)\n+        && n.getType() != Token.LABEL\n+        && n.getType() != Token.SWITCH) {\n+      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+        if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n+            c.getType() != Token.BLOCK) {\n+          Node newBlock = new Node(Token.BLOCK);\n+          n.replaceChild(c, newBlock);\n+          if (c.getType() != Token.EMPTY) {\n+            newBlock.addChildrenToFront(c);\n+          } else {\n+            newBlock.setWasEmptyNode(true);\n+          }\n+          c = newBlock;\n+          reportChange();\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Normalize where annotations appear on the AST. Copies\n+   * around existing JSDoc annotations as well as internal annotations.\n+   */\n+  static class PrepareAnnotations\n+      extends NodeTraversal.AbstractPostOrderCallback {\n+\n+    private final AbstractCompiler compiler;\n+    private final CodingConvention convention;\n+\n+    PrepareAnnotations(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+      this.convention = compiler.getCodingConvention();\n+    }\n+\n+    /**\n+     *\n+     * In the AST that Rhino gives us, it needs to make a distinction\n+     * between jsdoc on the object literal node and jsdoc on the object literal\n+     * value. For example,\n+     * <pre>\n+     * var x = {\n+     *   / JSDOC /\n+     *   a: 'b',\n+     *   c: / JSDOC / 'd'\n+     * };\n+     * </pre>\n+     *\n+     * But in few narrow cases (in particular, function literals), it's\n+     * a lot easier for us if the doc is attached to the value.\n+     */\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      int nType = n.getType();\n+      switch (nType) {\n+        case Token.NAME:\n+        case Token.STRING:\n+          String nString = n.getString();\n+          if (nType == Token.NAME &&\n+              n.getParent().getType() == Token.CALL &&\n+              \"eval\".equals(nString)) {\n+            n.putBooleanProp(Node.DIRECT_EVAL, true);\n+          }\n+          if (convention.isConstant(nString)) {\n+            n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+          }\n+          break;\n+\n+        case Token.FUNCTION:\n+          JSDocInfo fnInfo = n.getJSDocInfo();\n+          if (fnInfo == null) {\n+            // Look for the info on other nodes.\n+            if (parent.getType() == Token.ASSIGN) {\n+              // on ASSIGNs\n+              fnInfo = parent.getJSDocInfo();\n+            } else if (parent.getType() == Token.NAME) {\n+              // on var NAME = function() { ... };\n+              fnInfo = parent.getParent().getJSDocInfo();\n+            }\n+          }\n+\n+          // Compute which function parameters are optional and\n+          // which are var_args.\n+          Node args = n.getFirstChild().getNext();\n+          for (Node arg = args.getFirstChild();\n+               arg != null;\n+               arg = arg.getNext()) {\n+            String argName = arg.getString();\n+            JSTypeExpression typeExpr = fnInfo == null ?\n+                null : fnInfo.getParameterType(argName);\n+\n+            if (convention.isOptionalParameter(arg) ||\n+                typeExpr != null && typeExpr.isOptionalArg()) {\n+              arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n+            }\n+            if (convention.isVarArgsParameter(arg) ||\n+                typeExpr != null && typeExpr.isVarArgs()) {\n+              arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n+            }\n+          }\n+          break;\n+\n+        case Token.OBJECTLIT:\n+          if (n.getType() == Token.OBJECTLIT) {\n+            for (Node key = n.getFirstChild();\n+                 key != null; key = key.getNext().getNext()) {\n+              Node value = key.getNext();\n+              if (key.getJSDocInfo() != null &&\n+                  key.getNext().getType() == Token.FUNCTION) {\n+                value.setJSDocInfo(key.getJSDocInfo());\n+              }\n+            }\n+          }\n+          break;\n+      }\n+\n+      // TODO(johnlenz): Determine if it is possible to simply use the javadoc\n+      // everywhere rather than use IS_DISPATCHER.\n+      /*\n+       * Translate dispatcher info into the property expected node.\n+       */\n+      if (n.getJSDocInfo() != null && n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() == Token.ASSIGN) {\n+          Node fnNode = n.getLastChild();\n+          Preconditions.checkState(fnNode.getType() == Token.FUNCTION);\n+          fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n+      }\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n     // TODO(johnlenz): Change these normalization checks Preconditions and\n     // Exceptions into Errors so that it is easier to find the root cause\n     // when there are cascading issues.\n-    new NodeTypeNormalizer(true).process(null, root);\n+    new PrepareAst(compiler, true).process(null, root);\n     Preconditions.checkState(!handler.hasCodeChanged(),\n         \"This should never fire, NodeTypeNormalizer should assert first.\");\n \n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n       Node normalizeCheckRootClone = root.cloneTree();\n       Node normalizeCheckExternsRootClone = root.getFirstChild();\n       Node normalizeCheckMainRootClone = root.getLastChild();\n-      new NodeTypeNormalizer().process(\n+      new PrepareAst(compiler).process(\n           normalizeCheckExternsRootClone, normalizeCheckMainRootClone);\n       String explanation =\n           normalizeCheckMainRootClone.checkTreeEquals(mainRoot);", "timestamp": 1267072642, "metainfo": ""}