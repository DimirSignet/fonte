{"sha": "ab120bcf30e949cfd832be2ebe7e7afc1396f640", "log": "Enforces stricter type checking on classes that implement or extend generic types. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46581565", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.TemplateTypeMap;\n+import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer;\n import com.google.javascript.rhino.jstype.TernaryValue;\n \n import java.util.HashMap;\n       // there is a superclass implementation\n       JSType superClassPropType =\n           superClass.getInstanceType().getPropertyType(propertyName);\n+      TemplateTypeMap ctorTypeMap =\n+          ctorType.getTypeOfThis().getTemplateTypeMap();\n+      if (!ctorTypeMap.isEmpty()) {\n+        superClassPropType = superClassPropType.visit(\n+            new TemplateTypeMapReplacer(typeRegistry, ctorTypeMap));\n+      }\n+\n       if (!propertyType.isSubtype(superClassPropType)) {\n         compiler.report(\n             t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.Property;\n import com.google.javascript.rhino.jstype.TemplateType;\n+import com.google.javascript.rhino.jstype.TemplateTypeMap;\n+import com.google.javascript.rhino.jstype.TemplateTypeMapReplacer;\n \n import java.util.Iterator;\n import java.util.List;\n             }\n           }\n \n+          ObjectType prototypeOwner = getPrototypeOwnerType(ownerType);\n+          TemplateTypeMap prototypeOwnerTypeMap = null;\n+          if (prototypeOwner != null &&\n+              prototypeOwner.getTypeOfThis() != null) {\n+              prototypeOwnerTypeMap =\n+                  prototypeOwner.getTypeOfThis().getTemplateTypeMap();\n+          }\n+\n           FunctionType overriddenType = null;\n           if (ownerType != null && propName != null) {\n-            overriddenType = findOverriddenFunction(ownerType, propName);\n-          }\n-\n-          ObjectType prototypeOwner = getPrototypeOwnerType(ownerType);\n+            overriddenType = findOverriddenFunction(\n+                ownerType, propName, prototypeOwnerTypeMap);\n+          }\n \n           FunctionTypeBuilder builder =\n               new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n      * Find the function that's being overridden on this type, if any.\n      */\n     private FunctionType findOverriddenFunction(\n-        ObjectType ownerType, String propName) {\n+        ObjectType ownerType, String propName, TemplateTypeMap typeMap) {\n+      FunctionType result = null;\n+\n       // First, check to see if the property is implemented\n       // on a superclass.\n       JSType propType = ownerType.getPropertyType(propName);\n       if (propType != null && propType.isFunctionType()) {\n-        return propType.toMaybeFunctionType();\n+        result =  propType.toMaybeFunctionType();\n       } else {\n         // If it's not, then check to see if it's implemented\n         // on an implemented interface.\n                  ownerType.getCtorImplementedInterfaces()) {\n           propType = iface.getPropertyType(propName);\n           if (propType != null && propType.isFunctionType()) {\n-            return propType.toMaybeFunctionType();\n-          }\n-        }\n-      }\n-\n-      return null;\n+            result = propType.toMaybeFunctionType();\n+            break;\n+          }\n+        }\n+      }\n+\n+      if (result != null && typeMap != null && !typeMap.isEmpty()) {\n+        result = result.visit(\n+            new TemplateTypeMapReplacer(typeRegistry, typeMap))\n+            .toMaybeFunctionType();\n+      }\n+\n+      return result;\n     }\n \n     /**\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n     for (ObjectType current = this;\n          current != null;\n          current = current.getImplicitPrototype()) {\n+      if (current.isTemplatizedType()) {\n+        current = current.toMaybeTemplatizedType().getReferencedType();\n+      }\n       if (current.isEquivalentTo(prototype)) {\n         return true;\n       }\n--- a/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\n   @Override\n   public JSType caseTemplateType(TemplateType type) {\n     if (replacements.hasTemplateKey(type)) {\n-      if (hasVisitedType(type)) {\n+      if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {\n         // If we have already encountered this TemplateType during replacement\n-        // (i.e. there is a reference loop), return the type itself.\n+        // (i.e. there is a reference loop), or there is no JSType substitution\n+        // for the TemplateType, return the TemplateType type itself.\n         return type;\n       } else {\n         JSType replacement = replacements.getTemplateType(type);\n--- a/src/com/google/javascript/rhino/jstype/TemplatizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplatizedType.java\n   private static final long serialVersionUID = 1L;\n \n   final ImmutableList<JSType> templateTypes;\n+  final TemplateTypeMapReplacer replacer;\n \n   TemplatizedType(\n       JSTypeRegistry registry, ObjectType objectType,\n       builder.add(getTemplateTypeMap().getTemplateType(filledTemplateKey));\n     }\n     this.templateTypes = builder.build();\n+\n+    replacer = new TemplateTypeMapReplacer(registry, getTemplateTypeMap());\n   }\n \n   @Override\n   @Override\n   public ImmutableList<JSType> getTemplateTypes() {\n     return templateTypes;\n+  }\n+\n+  @Override\n+  public JSType getPropertyType(String propertyName) {\n+    JSType result = super.getPropertyType(propertyName);\n+    return result == null ? null : result.visit(replacer);\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"required: number\");\n   }\n \n+  public void testOverriddenParams7() throws Exception {\n+    testTypes(\n+        \"/** @constructor\\n * @template T */ function Foo() {}\" +\n+        \"/** @param {T} x */\" +\n+        \"Foo.prototype.bar = function(x) { };\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo.<string>}\\n\" +\n+        \" */ function SubFoo() {}\" +\n+        \"/**\\n\" +\n+        \" * @param {number} x\\n\" +\n+        \" * @override\\n\" +\n+        \" */\" +\n+        \"SubFoo.prototype.bar = function(x) {};\",\n+        \"mismatch of the bar property type and the type of the \" +\n+        \"property it overrides from superclass Foo\\n\" +\n+        \"original: function (this:Foo, string): undefined\\n\" +\n+        \"override: function (this:SubFoo, number): undefined\");\n+  }\n+\n   public void testOverriddenReturn1() throws Exception {\n     testTypes(\n         \"/** @constructor */ function Foo() {}\" +\n         \"property it overrides from superclass Foo\\n\" +\n         \"original: function (this:Foo): (SubFoo|null)\\n\" +\n         \"override: function (this:SubFoo): (Foo|null)\");\n+  }\n+\n+  public void testOverriddenReturn3() throws Exception {\n+    testTypes(\n+        \"/** @constructor \\n * @template T */ function Foo() {}\" +\n+        \"/** @return {T} */ Foo.prototype.bar = \" +\n+        \"    function() { return null; };\" +\n+        \"/** @constructor \\n * @extends {Foo.<string>} */ function SubFoo() {}\" +\n+        \"/** @override */ SubFoo.prototype.bar = \" +\n+        \"    function() { return 3; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testOverriddenReturn4() throws Exception {\n+    testTypes(\n+        \"/** @constructor \\n * @template T */ function Foo() {}\" +\n+        \"/** @return {T} */ Foo.prototype.bar = \" +\n+        \"    function() { return null; };\" +\n+        \"/** @constructor \\n * @extends {Foo.<string>} */ function SubFoo() {}\" +\n+        \"/** @return {number}\\n * @override */ SubFoo.prototype.bar = \" +\n+        \"    function() { return 3; }\",\n+        \"mismatch of the bar property type and the type of the \" +\n+        \"property it overrides from superclass Foo\\n\" +\n+        \"original: function (this:Foo): string\\n\" +\n+        \"override: function (this:SubFoo): number\");\n   }\n \n   public void testThis1() throws Exception {\n         \"};\");\n   }\n \n+  public void testFunctionCall9() throws Exception {\n+    testTypes(\n+        \"/** @constructor\\n * @template T\\n **/ function Foo() {}\\n\" +\n+        \"/** @param {T} x */ Foo.prototype.bar = function(x) {}\\n\" +\n+        \"var foo = /** @type {Foo.<string>} */ (new Foo());\\n\" +\n+        \"foo.bar(3);\",\n+        \"actual parameter 1 of Foo.prototype.bar does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n   public void testFunctionBind1() throws Exception {\n     testTypes(\n         \"/** @type {function(string, number): boolean} */\" +\n         \"/** @constructor\\n @template V\\n @implements {B.<V>}\\n */function C() {};\" +\n         \"/** @return {V}\\n @override */C.prototype.foo = function() {};\" +\n         \"/** @return {V}\\n @override */C.prototype.bar = function() {};\");\n+  }\n+\n+  /**\n+   * Verify that using @override to declare the signature for an implementing\n+   * class works correctly when the interface is generic.\n+   */\n+  public void testInterfaceInheritanceCheck16() throws Exception {\n+    testTypes(\n+        \"/** @interface\\n @template T */function A() {};\" +\n+        \"/** @desc description\\n @return {T} */A.prototype.foo = function() {};\" +\n+        \"/** @desc description\\n @return {T} */A.prototype.bar = function() {};\" +\n+        \"/** @constructor\\n @implements {A.<string>} */function B() {};\" +\n+        \"/** @override */B.prototype.foo = function() { return 'string'};\" +\n+        \"/** @override */B.prototype.bar = function() { return 3 };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n   }\n \n   public void testInterfacePropertyNotImplemented() throws Exception {\n             \" super interfaces Int0 and Int4\"});\n   }\n \n+  public void testExtendedInterfacePropertiesCompatibility9() throws Exception {\n+    testTypes(\n+        \"/** @interface\\n * @template T */function Int0() {};\" +\n+        \"/** @interface\\n * @template T */function Int1() {};\" +\n+        \"/** @type {T} */\" +\n+        \"Int0.prototype.foo;\" +\n+        \"/** @type {T} */\" +\n+        \"Int1.prototype.foo;\" +\n+        \"/** @interface \\n @extends {Int0.<number>} \\n @extends {Int1.<string>} */\" +\n+        \"function Int2() {};\",\n+        \"Interface Int2 has a property foo with incompatible types in its \" +\n+        \"super interfaces Int0.<number> and Int1.<string>\");\n+  }\n+\n   public void testGenerics1() throws Exception {\n     String fnDecl = \"/** \\n\" +\n         \" * @param {T} x \\n\" +", "timestamp": 1368581570, "metainfo": ""}