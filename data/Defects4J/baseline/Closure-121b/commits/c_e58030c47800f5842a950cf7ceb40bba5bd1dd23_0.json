{"sha": "e58030c47800f5842a950cf7ceb40bba5bd1dd23", "log": "First crack at a new js indexer. Only about 10% of the tests pass, but that's 10 better than 0 woohoo!  R=acleung,stevey DELTA=1067  (523 added, 183 deleted, 361 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2897   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n   /** Checks global name usage. */\n   final PassFactory checkGlobalNames =\n-      new PassFactory(\"Check names\", true) {\n+      new PassFactory(\"checkGlobalNames\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     }\n     return false;\n   }\n+\n+  /** Find the best JSDoc for the given node. */\n+  static JSDocInfo getBestJSDocInfo(Node n) {\n+    JSDocInfo info = n.getJSDocInfo();\n+    if (info == null) {\n+      Node parent = n.getParent();\n+      if (parent == null) {\n+        return null;\n+      }\n+\n+      int parentType = parent.getType();\n+      if (parentType == Token.NAME) {\n+        info = parent.getJSDocInfo();\n+        if (info == null && parent.getParent().hasOneChild()) {\n+          info = parent.getParent().getJSDocInfo();\n+        }\n+      } else if (parentType == Token.ASSIGN) {\n+        info = parent.getJSDocInfo();\n+      } else if (isObjectLitKey(parent, parent.getParent())) {\n+        info = parent.getJSDocInfo();\n+      }\n+    }\n+    return info;\n+  }\n+\n+  /** Find the l-value that the given r-value is being assigned to. */\n+  static Node getBestLValue(Node n) {\n+    Node parent = n.getParent();\n+    int parentType = parent.getType();\n+    boolean isFunctionDeclaration = isFunctionDeclaration(n);\n+    if (isFunctionDeclaration) {\n+      return n.getFirstChild();\n+    } else if (parentType == Token.NAME) {\n+      return parent;\n+    } else if (parentType == Token.ASSIGN) {\n+      return parent.getFirstChild();\n+    } else if (isObjectLitKey(parent, parent.getParent())) {\n+      return parent;\n+    }\n+    return null;\n+  }\n+\n+  /** Get the name of the given l-value node. */\n+  static String getBestLValueName(@Nullable Node lValue) {\n+    if (lValue == null || lValue.getParent() == null) {\n+      return null;\n+    }\n+    if (isObjectLitKey(lValue, lValue.getParent())) {\n+      Node owner = getBestLValue(lValue.getParent());\n+      if (owner != null) {\n+        String ownerName = getBestLValueName(owner);\n+        if (ownerName != null) {\n+          return ownerName + \".\" + getObjectLitKeyName(lValue);\n+        }\n+      }\n+      return null;\n+    }\n+    return lValue.getQualifiedName();\n+  }\n }\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n   }\n \n   @Override\n-  public StaticScope<JSType> getScope(Symbol slot) {\n+  public SymbolScope getScope(Symbol slot) {\n     return slot.scope;\n+  }\n+\n+  /**\n+   * Gets the scope that contains the given node.\n+   * If {@code n} is a function name, we return the scope that contains the\n+   * function, not the function itself.\n+   */\n+  public SymbolScope getEnclosingScope(Node n) {\n+    Node current = n.getParent();\n+    if (n.getType() == Token.NAME &&\n+        n.getParent().getType() == Token.FUNCTION) {\n+      current = current.getParent();\n+    }\n+\n+    for (; current != null; current = current.getParent()) {\n+      if (scopes.containsKey(current)) {\n+        return scopes.get(current);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * All local scopes are associated with a function, and some functions\n+   * are associated with a symbol. Returns the symbol associated with the given\n+   * scope.\n+   */\n+  public Symbol getSymbolForScope(SymbolScope scope) {\n+    Node rootNode = scope.getRootNode();\n+    if (rootNode.getType() != Token.FUNCTION) {\n+      return null;\n+    }\n+\n+    String name = NodeUtil.getBestLValueName(\n+        NodeUtil.getBestLValue(rootNode));\n+    return name == null ? null : scope.getParentScope().getSlot(name);\n+  }\n+\n+  public String toDebugString() {\n+    StringBuilder builder = new StringBuilder();\n+    for (Symbol symbol : getAllSymbols()) {\n+      toDebugString(builder, symbol);\n+    }\n+    return builder.toString();\n+  }\n+\n+  private void toDebugString(StringBuilder builder, Symbol symbol) {\n+    SymbolScope scope = symbol.scope;\n+    if (scope.isGlobalScope()) {\n+      builder.append(\n+          String.format(\"'%s' : in global scope:\\n\", symbol.getName()));\n+    } else {\n+      builder.append(\n+          String.format(\"'%s' : in scope %s:%d\\n\",\n+              symbol.getName(),\n+              scope.getRootNode().getSourceFileName(),\n+              scope.getRootNode().getLineno()));\n+    }\n+\n+    int refCount = 0;\n+    for (Reference ref : getReferences(symbol)) {\n+      builder.append(\n+          String.format(\"  Ref %d: %s:%d\\n\",\n+              refCount,\n+              ref.getNode().getSourceFileName(),\n+              ref.getNode().getLineno()));\n+      refCount++;\n+    }\n   }\n \n   /**\n       }\n \n       Node declNode = decl.getNode();\n+      if (declNode == null || declNode.getStaticSourceFile() == null) {\n+        continue;\n+      }\n \n       Symbol mySymbol = symbols.get(declNode);\n       if (mySymbol == null) {\n       this.declaration = ref;\n       references.put(ref.getNode(), ref);\n     }\n+\n+    public boolean inGlobalScope() {\n+      return scope.isGlobalScope();\n+    }\n+\n+    public boolean inExterns() {\n+      Node n = getDeclarationNode();\n+      return n == null ? false : n.isFromExterns();\n+    }\n+\n+    public Node getDeclarationNode() {\n+      return declaration == null ? null : declaration.getNode();\n+    }\n+\n+    public String getSourceFileName() {\n+      Node n = getDeclarationNode();\n+      return n == null ? null : n.getSourceFileName();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      Node n = getDeclarationNode();\n+      int lineNo = n == null ? -1 : n.getLineno();\n+      return getName() + \"@\" + getSourceFileName() + \":\" + lineNo;\n+    }\n   }\n \n   public static final class Reference implements StaticReference<JSType> {\n     @Override\n     public StaticSourceFile getSourceFile() {\n       return node.getStaticSourceFile();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      String sourceName = node == null ? null : node.getSourceFileName();\n+      int lineNo = node == null ? -1 : node.getLineno();\n+      return node.getQualifiedName() + \"@\" + sourceName + \":\" + lineNo;\n     }\n   }\n \n     public JSType getTypeOfThis() {\n       return typeOfThis;\n     }\n+\n+    public boolean isGlobalScope() {\n+      return getParentScope() == null;\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n         }\n       }\n \n-      info = getBestJSDocInfo(objectLit);\n-      Node lValue = getBestLValue(objectLit);\n-      String lValueName = getBestLValueName(lValue);\n+      info = NodeUtil.getBestJSDocInfo(objectLit);\n+      Node lValue = NodeUtil.getBestLValue(objectLit);\n+      String lValueName = NodeUtil.getBestLValueName(lValue);\n       boolean createdEnumType = false;\n       if (info != null && info.hasEnumParameterType()) {\n         type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue);\n         if (keyType != null) {\n           // Try to declare this property in the current scope if it\n           // has an authoritative name.\n-          String qualifiedName = getBestLValueName(keyNode);\n+          String qualifiedName = NodeUtil.getBestLValueName(keyNode);\n           if (qualifiedName != null) {\n             defineSlot(keyNode, objLit, qualifiedName, keyType, false);\n           } else {\n \n       // Determine the name and JSDocInfo and lvalue for the function.\n       // Any of these may be null.\n-      Node lValue = getBestLValue(n);\n-      JSDocInfo info = getBestJSDocInfo(n);\n-      String functionName = getBestLValueName(lValue);\n+      Node lValue = NodeUtil.getBestLValue(n);\n+      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n+      String functionName = NodeUtil.getBestLValueName(lValue);\n       FunctionType functionType =\n           createFunctionTypeFromNodes(n, functionName, info, lValue);\n \n       }\n     } // end declareArguments\n   } // end LocalScopeBuilder\n-\n-\n-  /** Find the best JSDoc for the given node. */\n-  static JSDocInfo getBestJSDocInfo(Node n) {\n-    JSDocInfo info = n.getJSDocInfo();\n-    if (info == null) {\n-      Node parent = n.getParent();\n-      int parentType = parent.getType();\n-      if (parentType == Token.NAME) {\n-        info = parent.getJSDocInfo();\n-        if (info == null && parent.getParent().hasOneChild()) {\n-          info = parent.getParent().getJSDocInfo();\n-        }\n-      } else if (parentType == Token.ASSIGN) {\n-        info = parent.getJSDocInfo();\n-      } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n-        info = parent.getJSDocInfo();\n-      }\n-    }\n-    return info;\n-  }\n-\n-  /** Find the l-value that the given r-value is being assigned to. */\n-  private static Node getBestLValue(Node n) {\n-    Node parent = n.getParent();\n-    int parentType = parent.getType();\n-    boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n);\n-    if (isFunctionDeclaration) {\n-      return n.getFirstChild();\n-    } else if (parentType == Token.NAME) {\n-      return parent;\n-    } else if (parentType == Token.ASSIGN) {\n-      return parent.getFirstChild();\n-    } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n-      return parent;\n-    }\n-    return null;\n-  }\n-\n-  /** Get the name of the given l-value node. */\n-  private static String getBestLValueName(@Nullable Node lValue) {\n-    if (lValue == null || lValue.getParent() == null) {\n-      return null;\n-    }\n-    if (NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n-      Node owner = getBestLValue(lValue.getParent());\n-      if (owner != null) {\n-        String ownerName = getBestLValueName(owner);\n-        if (ownerName != null) {\n-          return ownerName + \".\" + NodeUtil.getObjectLitKeyName(lValue);\n-        }\n-      }\n-      return null;\n-    }\n-    return lValue.getQualifiedName();\n-  }\n }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       i--;\n     }\n     return n;\n+  }\n+\n+  public int getIndexOfChild(Node child) {\n+    Node n = first;\n+    int i = 0;\n+    while (n != null) {\n+      if (child == n) {\n+        return i;\n+      }\n+\n+      n = n.next;\n+      i++;\n+    }\n+    return -1;\n   }\n \n   public Node getLastSibling() {\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.SymbolTable.Reference;\n import com.google.javascript.jscomp.SymbolTable.Symbol;\n+import com.google.javascript.jscomp.SymbolTable.SymbolScope;\n import com.google.javascript.rhino.Token;\n \n import junit.framework.TestCase;\n  * @author nicksantos@google.com (Nick Santos)\n  */\n public class SymbolTableTest extends TestCase {\n+\n+  private static final String EXTERNS = CompilerTypeTestCase.DEFAULT_EXTERNS +\n+      \"\\nfunction customExternFn(customExternArg) {}\";\n \n   public void testGlobalVar() throws Exception {\n     SymbolTable table = createSymbolTable(\n     assertEquals(1, Iterables.size(table.getReferences(googDomHelper)));\n   }\n \n+  public void testGlobalVarInExterns() throws Exception {\n+    SymbolTable table = createSymbolTable(\"customExternFn(1);\");\n+    Symbol fn = getGlobalVar(table, \"customExternFn\");\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(fn));\n+    assertEquals(2, refs.size());\n+\n+    SymbolScope scope = table.getEnclosingScope(refs.get(0).getNode());\n+    assertTrue(scope.isGlobalScope());\n+    assertNull(table.getSymbolForScope(scope));\n+  }\n+\n+  public void testLocalVarInExterns() throws Exception {\n+    SymbolTable table = createSymbolTable(\"\");\n+    Symbol arg = getLocalVar(table, \"customExternArg\");\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(arg));\n+    assertEquals(1, refs.size());\n+\n+    Symbol fn = getGlobalVar(table, \"customExternFn\");\n+    SymbolScope scope = table.getEnclosingScope(refs.get(0).getNode());\n+    assertFalse(scope.isGlobalScope());\n+    assertEquals(fn, table.getSymbolForScope(scope));\n+  }\n+\n   private Symbol getGlobalVar(SymbolTable table, String name) {\n     for (Symbol symbol : table.getAllSymbols()) {\n       if (symbol.getName().equals(name) &&\n     List<JSSourceFile> inputs = Lists.newArrayList(\n         JSSourceFile.fromCode(\"in1\", input));\n     List<JSSourceFile> externs = Lists.newArrayList(\n-        JSSourceFile.fromCode(\n-            \"externs1\", CompilerTypeTestCase.DEFAULT_EXTERNS));\n+        JSSourceFile.fromCode(\"externs1\", EXTERNS));\n     CompilerOptions options = new CompilerOptions();\n     CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(\n         options);\n--- a/test/com/google/javascript/rhino/NodeTest.java\n+++ b/test/com/google/javascript/rhino/NodeTest.java\n     assertTrue(nodeClone.getBooleanProp(Node.IS_DISPATCHER));\n   }\n \n+  public void testGetIndexOfChild() {\n+    Node assign = getNode(\"b = c\");\n+    assertEquals(2, assign.getChildCount());\n+\n+    Node firstChild = assign.getFirstChild();\n+    Node secondChild = firstChild.getNext();\n+    assertNotNull(secondChild);\n+\n+    assertEquals(0, assign.getIndexOfChild(firstChild));\n+    assertEquals(1, assign.getIndexOfChild(secondChild));\n+    assertEquals(-1, assign.getIndexOfChild(assign));\n+  }\n+\n   private static Node getNode(String js) {\n     Node root = parse(\"var a=(\" + js + \");\");\n     Node expr = root.getFirstChild();", "timestamp": 1312473378, "metainfo": ""}