{"sha": "8ffc76e13d5fc16e1bcb0e0d5dc4d08926899d49", "log": "Make static methods static ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=45935883", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n+  private static boolean isFoldableExpressBlock(Node n) {\n     if (n.isBlock()) {\n       if (n.hasOneChild()) {\n         Node maybeExpr = n.getFirstChild();\n   /**\n    * @return The expression node.\n    */\n-  private Node getBlockExpression(Node n) {\n+  private static Node getBlockExpression(Node n) {\n     Preconditions.checkState(isFoldableExpressBlock(n));\n     return n.getFirstChild();\n   }\n    * @return Whether the node is a block with a single statement that is\n    *     an return with or without an expression.\n    */\n-  private boolean isReturnBlock(Node n) {\n+  private static boolean isReturnBlock(Node n) {\n     if (n.isBlock()) {\n       if (n.hasOneChild()) {\n         Node first = n.getFirstChild();\n    * @return Whether the node is a block with a single statement that is\n    *     an return.\n    */\n-  private boolean isReturnExpressBlock(Node n) {\n+  private static boolean isReturnExpressBlock(Node n) {\n     if (n.isBlock()) {\n       if (n.hasOneChild()) {\n         Node first = n.getFirstChild();\n   /**\n    * @return Whether the node is a single return statement.\n    */\n-  private boolean isReturnExpression(Node n) {\n+  private static boolean isReturnExpression(Node n) {\n     if (n.isReturn()) {\n       return n.hasOneChild();\n     }\n   /**\n    * @return The expression that is part of the return.\n    */\n-  private Node getBlockReturnExpression(Node n) {\n+  private static Node getBlockReturnExpression(Node n) {\n     Preconditions.checkState(isReturnExpressBlock(n));\n     return n.getFirstChild().getFirstChild();\n   }\n    * @return Whether the node is a block with a single statement that is\n    *     a VAR declaration of a single variable.\n    */\n-  private boolean isVarBlock(Node n) {\n+  private static boolean isVarBlock(Node n) {\n     if (n.isBlock()) {\n       if (n.hasOneChild()) {\n         Node first = n.getFirstChild();\n   /**\n    * @return The var node.\n    */\n-  private Node getBlockVar(Node n) {\n+  private static Node getBlockVar(Node n) {\n     Preconditions.checkState(isVarBlock(n));\n     return n.getFirstChild();\n   }\n    * a 'dangling else' if an 'else' token following the statement\n    * would be considered by the parser to be part of the statement.\n    */\n-  private boolean consumesDanglingElse(Node n) {\n+  private static boolean consumesDanglingElse(Node n) {\n     while (true) {\n       switch (n.getType()) {\n         case Token.IF:\n   /**\n    * Whether the node type has lower precedence than \"precedence\"\n    */\n-  private boolean isLowerPrecedence(Node n, final int precedence) {\n+  private static boolean isLowerPrecedence(Node n, final int precedence) {\n     return NodeUtil.precedence(n.getType()) < precedence;\n   }\n \n   /**\n    * Whether the node type has higher precedence than \"precedence\"\n    */\n-  private boolean isHigherPrecedence(Node n, final int precedence) {\n+  private static boolean isHigherPrecedence(Node n, final int precedence) {\n     return NodeUtil.precedence(n.getType()) > precedence;\n   }\n   /**\n    * Does the expression contain a property assignment?\n    */\n-  private boolean isPropertyAssignmentInExpression(Node n) {\n+  private static boolean isPropertyAssignmentInExpression(Node n) {\n     Predicate<Node> isPropertyAssignmentInExpressionPredicate =\n         new Predicate<Node>() {\n       @Override\n    * at least two. The remaining case may be unsafe since Array(number)\n    * actually reserves memory for an empty array which contains number elements.\n    */\n-  private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n+  private static FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n     FoldArrayAction action = FoldArrayAction.NOT_SAFE_TO_FOLD;\n \n     if (arg == null) {\n    * @param strings The strings that must be separated.\n    * @return a delimiter string or null\n    */\n-  private String pickDelimiter(String[] strings) {\n+  private static String pickDelimiter(String[] strings) {\n     boolean allLength1 = true;\n     for (String s : strings) {\n       if (s.length() != 1) {", "timestamp": 1367882253, "metainfo": ""}