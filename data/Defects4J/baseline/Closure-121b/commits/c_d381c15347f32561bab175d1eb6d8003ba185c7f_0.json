{"sha": "d381c15347f32561bab175d1eb6d8003ba185c7f", "log": "Index Object.prototype and Function.prototype when checking global names.  R=johnlenz DELTA=66  (54 added, 2 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5010   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.GlobalNamespace.Name;\n import com.google.javascript.jscomp.GlobalNamespace.Ref;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n \n+import java.util.Set;\n+\n /**\n  * Checks references to undefined properties of global variables.\n  *\n   private final CheckLevel level;\n \n   private GlobalNamespace namespace = null;\n+  private final Set<String> objectPrototypeProps = Sets.newHashSet();\n+  private final Set<String> functionPrototypeProps = Sets.newHashSet();\n \n   // Warnings\n   static final DiagnosticType UNDEFINED_NAME_WARNING = DiagnosticType.warning(\n    * can be re-used for multiple check passes. Returns this for easy chaining.\n    */\n   CheckGlobalNames injectNamespace(GlobalNamespace namespace) {\n+    Preconditions.checkArgument(namespace.hasExternsRoot());\n     this.namespace = namespace;\n     return this;\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n-    // TODO(nicksantos): Let CollapseProperties and CheckGlobalNames\n-    // share a namespace.\n     if (namespace == null) {\n-      namespace = new GlobalNamespace(compiler, root);\n-    }\n+      namespace = new GlobalNamespace(compiler, externs, root);\n+    }\n+\n+    // Find prototype properties that will affect our analysis.\n+    Preconditions.checkState(namespace.hasExternsRoot());\n+    findPrototypeProps(\"Object\", objectPrototypeProps);\n+    findPrototypeProps(\"Function\", functionPrototypeProps);\n \n     for (Name name : namespace.getNameForest()) {\n+      // Skip extern names. Externs are often not runnable as real code,\n+      // and will do things like:\n+      // var x;\n+      // x.method;\n+      // which this check forbids.\n+      if (name.inExterns) {\n+        continue;\n+      }\n+\n       checkDescendantNames(name, name.globalSets + name.localSets > 0);\n+    }\n+  }\n+\n+  private void findPrototypeProps(String type, Set<String> props) {\n+    Name slot = namespace.getSlot(type);\n+    if (slot != null) {\n+      for (Ref ref : slot.getRefs()) {\n+        if (ref.type == Ref.Type.PROTOTYPE_GET) {\n+          Node fullName = ref.getNode().getParent().getParent();\n+          if (fullName.isGetProp()) {\n+            props.add(fullName.getLastChild().getString());\n+          }\n+        }\n+      }\n     }\n   }\n \n    * Checks whether the given name is a property, and whether that property\n    * must be initialized with its full qualified name.\n    */\n-  private static boolean propertyMustBeInitializedByFullName(Name name) {\n+  private boolean propertyMustBeInitializedByFullName(Name name) {\n     // If an object literal in the global namespace is never aliased,\n     // then all of its properties must be defined using its full qualified\n     // name. This implies that its properties must all be in the global\n     // The same is not true for FUNCTION and OTHER types, because their\n     // implicit prototypes have properties that are not captured by the global\n     // namespace.\n+    //\n+    // This comment will be fixed in a subsequent cl.\n     return name.parent != null && name.parent.aliasingGets == 0 &&\n-        name.parent.type == Name.Type.OBJECTLIT;\n+        name.parent.type == Name.Type.OBJECTLIT &&\n+        !objectPrototypeProps.contains(name.getBaseName());\n   }\n }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n           // Create a global namespace for analysis by check passes.\n           // Note that this class does all heavy computation lazily,\n           // so it's OK to create it here.\n-          namespaceForChecks = new GlobalNamespace(compiler, jsRoot);\n+          namespaceForChecks = new GlobalNamespace(compiler, externs, jsRoot);\n           new CheckGlobalNames(compiler, options.checkGlobalNamesLevel)\n               .injectNamespace(namespaceForChecks).process(externs, jsRoot);\n         }\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n     this.root = root;\n   }\n \n+  boolean hasExternsRoot() {\n+    return externsRoot != null;\n+  }\n+\n   @Override\n   public Node getRootNode() {\n     return root.getParent();\n   }\n \n   @Override\n-  public StaticSlot<JSType> getSlot(String name) {\n+  public Name getSlot(String name) {\n     return getOwnSlot(name);\n   }\n \n   @Override\n-  public StaticSlot<JSType> getOwnSlot(String name) {\n+  public Name getOwnSlot(String name) {\n+    ensureGenerated();\n     return nameMap.get(name);\n   }\n \n     int totalGets = 0;\n     int callGets = 0;\n     int deleteProps = 0;\n-    boolean inExterns;\n+    final boolean inExterns;\n \n     JSDocInfo docInfo = null;\n \n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n   private boolean injectNamespace = false;\n \n   public CheckGlobalNamesTest() {\n-    super(\"function alert() {}\");\n+    super(\"function alert() {}\" +\n+          \"/** @constructor */ function Object(){}\" +\n+          \"Object.prototype.hasOwnProperty = function() {};\");\n   }\n \n   @Override\n         @Override\n         public void process(Node externs, Node js) {\n           checkGlobalNames.injectNamespace(\n-              new GlobalNamespace(compiler, js))\n+              new GlobalNamespace(compiler, externs, js))\n               .process(externs, js);\n         }\n       };\n         \"  case (x.y = {}): break;\" +\n         \"}\", NAME_DEFINED_LATE_WARNING);\n   }\n+\n+  public void testObjectPrototypeProperties() {\n+    testSame(\"var x = {}; var y = x.hasOwnProperty('z');\");\n+  }\n+\n+  public void testCustomObjectPrototypeProperties() {\n+    testSame(\"Object.prototype.seal = function() {};\" +\n+        \"var x = {}; x.seal();\");\n+  }\n }", "timestamp": 1339631741, "metainfo": ""}