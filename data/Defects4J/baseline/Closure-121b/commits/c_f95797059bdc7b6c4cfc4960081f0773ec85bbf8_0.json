{"sha": "f95797059bdc7b6c4cfc4960081f0773ec85bbf8", "log": "Clean up some record keeping of comments.  This doesn't appear to have helped the parsing speed at all.  R=nicksantos DELTA=134  (45 added, 66 deleted, 23 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=266012   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC;\n \n-import com.google.common.collect.LinkedHashMultimap;\n-import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n-import java.util.Collection;\n-import java.util.Iterator;\n import java.util.Set;\n \n /**\n   // non-static for thread safety\n   private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n \n-  // Nodes with JSDoc comments, indexed by the text of the JSDoc comment.\n-  //\n-  // It's likely that two or more nodes in the same file may have the same\n-  // jsdoc comment. In general, that's ok.\n-  //\n-  // There's one edge case where this might cause problems. If two JSDoc\n-  // comments have the same text, and the first JSDoc comment is not attached\n-  // to a node, then the second node will get the first JSDoc comment\n-  // instead of the second. When this happens, it probably won't cause any\n-  // problems. The two JSDoc comments will be exactly the same, except for\n-  // their line numbers. Their line numbers will only be exposed for\n-  // type name resolution warnings.\n-  //\n-  // TODO(nicksantos): Change rhino to put the whole Comment object\n-  // on the Node.\n-  private final Multimap<String, NodeWithJsDoc> nodesWithJsDoc =\n-      LinkedHashMultimap.create();\n+  // @license text gets appended onto the fileLevelJsDocBuilder as found,\n+  // and stored in JSDocInfo for placeholder node.\n+  Node rootNodeJsDocHolder = new Node(Token.SCRIPT);\n+  Node.FileLevelJsDocBuilder fileLevelJsDocBuilder =\n+      rootNodeJsDocHolder.getJsDocBuilderForNode();\n+  JSDocInfo fileOverviewInfo = null;\n \n   // Use a template node for properties set on all nodes to minimize the\n   // memory footprint associated with these.\n     IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n         config, errorReporter);\n     Node irNode = irFactory.transform(node);\n-    // @license text gets appended onto the fileLevelJsDocBuilder as found,\n-    // and stored straight into the JSDocInfo for the root node.\n-    Node.FileLevelJsDocBuilder fileLevelJsDocBuilder =\n-        irNode.getJsDocBuilderForNode();\n-    // fileOverviewInfo stores the last bit of fileoverview data we saw.\n-    // We only permit one, so throwing away extras is fair.\n-    // The fileOverviewInfo gets passed into parseJSDocInfo so that\n-    // it can detect when multiple @fileoverviews exist in the same file.\n-    JSDocInfo fileOverviewInfo = null;\n+\n     if (node.getComments() != null) {\n       for (Comment comment : node.getComments()) {\n-        if (comment.getCommentType() == JSDOC) {\n-          JsDocInfoParser jsDocParser =\n-              irFactory.createJsDocInfoParser(comment.getValue(),\n-                  comment.getLineno(), comment.getAbsolutePosition(),\n-                  fileLevelJsDocBuilder, fileOverviewInfo);\n-          if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n-            fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n-          } else {\n-            JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n-            if (info != null) {\n-              irFactory.attachJsDoc(comment, info);\n-            }\n-          }\n+        if (comment.getCommentType() == JSDOC && !comment.isParsed()) {\n+          irFactory.handlePossibleFileOverviewJsDoc(comment);\n         }\n       }\n-\n-      // Only after we've seen all @fileoverview entries, attach the\n-      // last one to the root node, and copy the found license strings\n-      // to that node.\n-      if (fileOverviewInfo != null) {\n-        if ((irNode.getJSDocInfo() != null) &&\n-            (irNode.getJSDocInfo().getLicense() != null)) {\n-          fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n-        }\n-        irNode.setJSDocInfo(fileOverviewInfo);\n-      }\n-    }\n+    }\n+\n+    irFactory.setFileOverviewJsDoc(irNode);\n+\n     return irNode;\n+  }\n+\n+  private void setFileOverviewJsDoc(Node irNode) {\n+    // Only after we've seen all @fileoverview entries, attach the\n+    // last one to the root node, and copy the found license strings\n+    // to that node.\n+    irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo());\n+    if (fileOverviewInfo != null) {\n+      if ((irNode.getJSDocInfo() != null) &&\n+          (irNode.getJSDocInfo().getLicense() != null)) {\n+        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n+      }\n+      irNode.setJSDocInfo(fileOverviewInfo);\n+    }\n   }\n \n   private Node transformBlock(AstNode node) {\n     return irNode;\n   }\n \n+  /**\n+   * @return true if the jsDocParser represents a fileoverview.\n+   */\n+  private boolean handlePossibleFileOverviewJsDoc(\n+      JsDocInfoParser jsDocParser) {\n+    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n+      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private void handlePossibleFileOverviewJsDoc(Comment comment) {\n+    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n+    comment.setParsed(true);\n+    handlePossibleFileOverviewJsDoc(jsDocParser);\n+  }\n+\n+  private JSDocInfo handleJsDoc(AstNode node) {\n+    Comment comment = node.getJsDocNode();\n+    if (comment != null) {\n+      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n+      comment.setParsed(true);\n+      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n+        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n+      }\n+    }\n+    return null;\n+  }\n+\n   private Node transform(AstNode node) {\n-    String jsDoc = node.getJsDoc();\n-    NodeWithJsDoc nodeWithJsDoc = null;\n-    if (jsDoc != null) {\n-      nodeWithJsDoc = new NodeWithJsDoc();\n-      nodesWithJsDoc.put(jsDoc, nodeWithJsDoc);\n-    }\n-\n+    JSDocInfo jsDocInfo = handleJsDoc(node);\n     Node irNode = justTransform(node);\n-    if (nodeWithJsDoc != null) {\n-      nodeWithJsDoc.node = irNode;\n+    if (jsDocInfo != null) {\n+      irNode.setJSDocInfo(jsDocInfo);\n     }\n \n     // If we have a named function, set the position to that of the name.\n    * Used both for handling individual JSDoc comments and for handling\n    * file-level JSDoc comments (@fileoverview and @license).\n    *\n-   * @param comment The JsDoc comment to parse.\n-   * @param lineno The line number of the node this comment is attached to.\n-   * @param fileLevelJsDocBuilder The builder for file-level JSDocInfo.\n-   * @param fileOverviewInfo The current @fileoverview JSDocInfo, so that the\n-   *     parser may warn if another @fileoverview is found. May be null.\n+   * @param node The JsDoc Comment node to parse.\n    * @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or\n    *     normal jsdoc, or no jsdoc (if the method parses to the wrong level).\n    */\n-  private JsDocInfoParser createJsDocInfoParser(\n-      String comment, int lineno, int position,\n-      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder,\n-      JSDocInfo fileOverviewInfo) {\n+  private JsDocInfoParser createJsDocInfoParser(Comment node) {\n+    String comment = node.getValue();\n+    int lineno = node.getLineno();\n+    int position = node.getAbsolutePosition();\n+\n     // The JsDocInfoParser expects the comment without the initial '/**'.\n     int numOpeningChars = 3;\n     JsDocInfoParser jsdocParser =\n     jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n     jsdocParser.parse();\n     return jsdocParser;\n-  }\n-\n-  /** Attach JSDocInfo to a node, if we can find one. */\n-  private void attachJsDoc(Comment comment, JSDocInfo info) {\n-    Collection<NodeWithJsDoc> candidates =\n-        nodesWithJsDoc.get(comment.getValue());\n-    if (candidates.isEmpty()) {\n-      return;\n-    }\n-\n-    Iterator<NodeWithJsDoc> candidateIter = candidates.iterator();\n-    Node node = candidateIter.next().node;\n-    candidateIter.remove();\n-    node.setJSDocInfo(info);\n   }\n \n   private int position2charno(int position) {", "timestamp": 1285618874, "metainfo": ""}