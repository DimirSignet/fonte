{"sha": "48cccf202b6cd853409e169d98918462f91301a8", "log": "Allow multiple output_manifest flags, for backwards compatibility  R=zhuyi DELTA=54  (21 added, 13 deleted, 20 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2278   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   }\n \n   /** Expansion function for the manifest. */\n-  @VisibleForTesting\n-  String expandManifest(JSModule forModule) {\n-    if (Strings.isEmpty(config.outputManifest)) {\n-      return null;\n-    }\n-    return expandCommandLinePath(config.outputManifest, forModule);\n+  private String expandManifest(JSModule forModule, String manifestName) {\n+    return expandCommandLinePath(manifestName, forModule);\n   }\n \n   /**\n    * Returns true if and only if a manifest should be generated for each\n    * module, as opposed to one unified manifest.\n    */\n-  private boolean shouldGenerateManifestPerModule() {\n+  private boolean shouldGenerateManifestPerModule(String outputManifest) {\n     return !config.module.isEmpty()\n-        && config.outputManifest != null\n-        && config.outputManifest.contains(\"%outname%\");\n+        && outputManifest != null\n+        && outputManifest.contains(\"%outname%\");\n   }\n \n   /**\n    * manage_closure_dependencies, if requested.\n    */\n   private void outputManifest() throws IOException {\n-    String outputManifest = config.outputManifest;\n-    if (Strings.isEmpty(outputManifest)) {\n+    List<String> outputManifests = config.outputManifests;\n+    if (outputManifests.isEmpty()) {\n       return;\n     }\n \n-    JSModuleGraph graph = compiler.getModuleGraph();\n-    if (shouldGenerateManifestPerModule()) {\n-      // Generate per-module manifests.\n-      Iterable<JSModule> modules = graph.getAllModules();\n-      for (JSModule module : modules) {\n-        Writer out = fileNameToOutputWriter(expandManifest(module));\n-        printManifestTo(module.getInputs(), out);\n+    for (String outputManifest : outputManifests) {\n+      if (outputManifest.isEmpty()) {\n+        continue;\n+      }\n+\n+      JSModuleGraph graph = compiler.getModuleGraph();\n+      if (shouldGenerateManifestPerModule(outputManifest)) {\n+        // Generate per-module manifests.\n+        Iterable<JSModule> modules = graph.getAllModules();\n+        for (JSModule module : modules) {\n+          Writer out = fileNameToOutputWriter(\n+              expandManifest(module, outputManifest));\n+          printManifestTo(module.getInputs(), out);\n+          out.close();\n+        }\n+      } else {\n+        // Generate a single file manifest.\n+        Writer out = fileNameToOutputWriter(\n+            expandManifest(null, outputManifest));\n+        if (graph == null) {\n+          printManifestTo(compiler.getInputsInOrder(), out);\n+        } else {\n+          printModuleGraphManifestTo(graph, out);\n+        }\n         out.close();\n       }\n-    } else {\n-      // Generate a single file manifest.\n-      Writer out = fileNameToOutputWriter(expandManifest(null));\n-      if (graph == null) {\n-        printManifestTo(compiler.getInputsInOrder(), out);\n-      } else {\n-        printModuleGraphManifestTo(graph, out);\n-      }\n-      out.close();\n     }\n   }\n \n       return this;\n     }\n \n-    private String outputManifest = \"\";\n+    private List<String> outputManifests = ImmutableList.of();\n \n     /**\n      * Sets whether to print an output manifest file.\n      */\n-    CommandLineConfig setOutputManifest(String outputManifest) {\n-      this.outputManifest = outputManifest;\n+    CommandLineConfig setOutputManifest(List<String> outputManifests) {\n+      this.outputManifests = outputManifests;\n       return this;\n     }\n \n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n           .setCharset(flags.charset)\n           .setManageClosureDependencies(flags.manage_closure_dependencies)\n           .setClosureEntryPoints(flags.closure_entry_point)\n-          .setOutputManifest(flags.output_manifest)\n+          .setOutputManifest(ImmutableList.of(flags.output_manifest))\n           .setAcceptConstKeyword(flags.accept_const_keyword)\n           .setLanguageIn(flags.language_in);\n     }", "timestamp": 1308074038, "metainfo": ""}