{"sha": "465282f1ca28a208b06c47b55fd292d4631c55da", "log": "Change on 2010/06/22 by nicksantos          Inferred return types.          Fixes issue 143.         I eventually decided that it was wrong for the subtype's method         to affect the supertype's method, since this will make incremental         compilation a lot harder in the long run.          R=moedinger         DELTA=481  (313 added, 38 deleted, 130 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=34007   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Iterables;\n   private final Scope scope;\n \n   private JSType returnType = null;\n+  private boolean returnTypeInferred = false;\n   private List<ObjectType> implementedInterfaces = null;\n   private ObjectType baseType = null;\n   private ObjectType thisType = null;\n    */\n   FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n     returnType = info != null && info.hasReturnType() ?\n-        info.getReturnType().evaluate(scope, typeRegistry) :\n-        typeRegistry.getNativeType(UNKNOWN_TYPE);\n+        info.getReturnType().evaluate(scope, typeRegistry) : null;\n     if (templateTypeName != null &&\n+        returnType != null &&\n         returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n+    }\n+    return this;\n+  }\n+\n+  /**\n+   * If we haven't found a return value yet, try to look at the \"return\"\n+   * statements in the function.\n+   */\n+  FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) {\n+    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {\n+      return this;\n+    }\n+    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);\n+    if (returnType == null) {\n+      boolean hasNonEmptyReturns = false;\n+      List<Node> worklist = Lists.newArrayList(functionBlock);\n+      while (!worklist.isEmpty()) {\n+        Node current = worklist.remove(worklist.size() - 1);\n+        int cType = current.getType();\n+        if (cType == Token.RETURN && current.getFirstChild() != null ||\n+            cType == Token.THROW) {\n+          hasNonEmptyReturns = true;\n+          break;\n+        } else if (NodeUtil.isStatementBlock(current) ||\n+            NodeUtil.isControlStructure(current)) {\n+          for (Node child = current.getFirstChild();\n+               child != null; child = child.getNext()) {\n+            worklist.add(child);\n+          }\n+        }\n+      }\n+\n+      if (!hasNonEmptyReturns) {\n+        returnType = typeRegistry.getNativeType(VOID_TYPE);\n+        returnTypeInferred = true;\n+      }\n     }\n     return this;\n   }\n    * Builds the function type, and puts it in the registry.\n    */\n   FunctionType buildAndRegister() {\n-    if (returnType == null || parametersNode == null) {\n+    if (returnType == null) {\n+      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n+    }\n+\n+    if (parametersNode == null) {\n       throw new IllegalStateException(\n           \"All Function types must have params and a return type\");\n     }\n           .withName(fnName)\n           .withSourceNode(sourceNode)\n           .withParamsNode(parametersNode)\n-          .withReturnType(returnType)\n+          .withReturnType(returnType, returnTypeInferred)\n           .withTypeOfThis(thisType)\n           .withTemplateName(templateTypeName)\n           .build();\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n         String functionName = name.getString();\n         FunctionType functionType =\n             getFunctionType(functionName, value, info, null);\n-        defineSlot(name, var, functionType);\n+        if (functionType.isReturnTypeInferred() &&\n+            scope.isLocal()) {\n+          defineSlot(name, var, null);\n+        } else {\n+          defineSlot(name, var, functionType);\n+        }\n       } else {\n         // variable's type\n         JSType type = null;\n       Node fnRoot = isFnLiteral ? rValue : null;\n       Node parametersNode = isFnLiteral ?\n           rValue.getFirstChild().getNext() : null;\n+      Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n \n       if (functionType == null && info != null && info.hasType()) {\n         JSType type = info.getType().evaluate(scope, typeRegistry);\n               ObjectType ownerType = ObjectType.cast(var.getType());\n               FunctionType propType = null;\n               if (ownerType != null) {\n-                propType = findOverriddenFunction(\n-                    ownerType, lvalueNode.getLastChild().getString());\n+                String propName = lvalueNode.getLastChild().getString();\n+                propType = findOverriddenFunction(ownerType, propName);\n               }\n \n               if (propType != null) {\n                     .setSourceNode(fnRoot)\n                     .inferFromOverriddenFunction(propType, parametersNode)\n                     .inferThisType(info, owner)\n+                    .inferReturnStatements(fnBlock)\n                     .buildAndRegister();\n               }\n             }\n             .inferInheritance(info)\n             .inferThisType(info, owner)\n             .inferParameterTypes(parametersNode, info)\n+            .inferReturnStatements(fnBlock)\n             .buildAndRegister();\n       }\n \n--- a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n     return this;\n   }\n \n+  /** Set the return type and whether it's inferred. */\n+  public FunctionBuilder withReturnType(JSType returnType, boolean inferred) {\n+    this.returnType = returnType;\n+    this.inferredReturnType = inferred;\n+    return this;\n+  }\n+\n   /** Sets an inferred return type. */\n   public FunctionBuilder withInferredReturnType(JSType returnType) {\n     this.returnType = returnType;\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n           JSType newReturnType = leastSuper ?\n               call.returnType.getLeastSupertype(other.call.returnType) :\n               call.returnType.getGreatestSubtype(other.call.returnType);\n-          return new FunctionType(\n-              registry, null, null,\n-              new ArrowType(\n-                  registry, call.parameters, newReturnType,\n-                  call.returnTypeInferred ||\n-                  other.call.returnTypeInferred),\n-              typeOfThis, null, false, false);\n+          return cloneWithNewReturnType(\n+              newReturnType,\n+              call.returnTypeInferred || other.call.returnTypeInferred);\n         }\n       }\n \n     return leastSuper ?\n         super.getLeastSupertype(that) :\n         super.getGreatestSubtype(that);\n+  }\n+\n+  FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n+    return new FunctionType(\n+        registry, null, source,\n+        new ArrowType(\n+            registry, call.parameters, newReturnType, inferred),\n+        typeOfThis, null, false, false);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n     String js = \"\"\n         + \"/** @constructor */ function Foo(){};\\n\"\n         + \"/** @return Bar */\\n\"\n-        + \"Foo.prototype.fun = function() { new Bar };\\n\"\n+        + \"Foo.prototype.fun = function() { return new Bar(); };\\n\"\n         + \"/** @constructor */ function Bar(){};\\n\"\n         + \"Bar.prototype.bazz;\\n\"\n         + \"(new Foo).fun().bazz();\";\n     String output = \"\"\n         + \"function Foo(){};\\n\"\n-        + \"Foo.prototype.a = function() { new Bar };\\n\"\n+        + \"Foo.prototype.a = function() { return new Bar(); };\\n\"\n         + \"function Bar(){};\\n\"\n         + \"Bar.prototype.a;\\n\"\n         + \"(new Foo).a().a();\";\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n   }\n \n   public void testTypeAnnotations() {\n-    assertTypeAnnotations(\"/** @constructor */ function Foo(){}\",\n-        \"/**\\n * @constructor\\n */\\nfunction Foo() {\\n}\\n\");\n+    assertTypeAnnotations(\n+        \"/** @constructor */ function Foo(){}\",\n+        \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n+        + \"function Foo() {\\n}\\n\");\n   }\n \n   public void testTypeAnnotationsAssign() {\n     assertTypeAnnotations(\"/** @constructor */ var Foo = function(){}\",\n-        \"/**\\n * @constructor\\n */\\nvar Foo = function() {\\n}\");\n+        \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n+        + \"var Foo = function() {\\n}\");\n   }\n \n   public void testTypeAnnotationsNamespace() {\n     assertTypeAnnotations(\"var a = {};\"\n         + \"/** @constructor */ a.Foo = function(){}\",\n-        \"var a = {};\\n/**\\n * @constructor\\n */\\na.Foo = function() {\\n}\");\n+        \"var a = {};\\n\"\n+        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n+        + \"a.Foo = function() {\\n}\");\n   }\n \n   public void testTypeAnnotationsMemberSubclass() {\n     assertTypeAnnotations(\"var a = {};\"\n         + \"/** @constructor */ a.Foo = function(){};\"\n         + \"/** @constructor \\n @extends {a.Foo} */ a.Bar = function(){}\",\n-        \"var a = {};\\n/**\\n * @constructor\\n */\\na.Foo = function() {\\n};\\n\"\n-        + \"/**\\n * @extends {a.Foo}\\n * @constructor\\n */\\n\"\n+        \"var a = {};\\n\"\n+        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n+        + \"a.Foo = function() {\\n};\\n\"\n+        + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n+        + \" * @constructor\\n */\\n\"\n         + \"a.Bar = function() {\\n}\");\n   }\n \n     assertTypeAnnotations(\"var a = {};\"\n         + \"/** @interface */ a.Foo = function(){};\"\n         + \"/** @interface \\n @extends {a.Foo} */ a.Bar = function(){}\",\n-        \"var a = {};\\n/**\\n * @interface\\n */\\na.Foo = function() {\\n};\\n\"\n-        + \"/**\\n * @extends {a.Foo}\\n * @interface\\n */\\n\"\n+        \"var a = {};\\n\"\n+        + \"/**\\n * @interface\\n */\\n\"\n+        + \"a.Foo = function() {\\n};\\n\"\n+        + \"/**\\n * @extends {a.Foo}\\n\"\n+        + \" * @interface\\n */\\n\"\n         + \"a.Bar = function() {\\n}\");\n   }\n \n         + \"/** @constructor */ a.Foo = function(){}\"\n         + \"/** @param {string} foo\\n\"\n         + \"  * @return {number} */\\n\"\n-        + \"a.Foo.prototype.foo = function(foo) {};\"\n+        + \"a.Foo.prototype.foo = function(foo) { return 3; };\"\n         + \"/** @type {string|undefined} */\"\n         + \"a.Foo.prototype.bar = '';\",\n         \"var a = {};\\n\"\n-        + \"/**\\n * @constructor\\n */\\na.Foo = function() {\\n};\\n\"\n+        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n+        + \"a.Foo = function() {\\n};\\n\"\n         + \"/**\\n\"\n         + \" * @param {string} foo\\n\"\n         + \" * @return {number}\\n\"\n         + \" */\\n\"\n-        + \"a.Foo.prototype.foo = function(foo) {\\n};\\n\"\n+        + \"a.Foo.prototype.foo = function(foo) {\\n  return 3\\n};\\n\"\n         + \"/** @type {string} */\\n\"\n         + \"a.Foo.prototype.bar = \\\"\\\"\");\n   }\n         + \" * @implements {a.I} \\n @implements {a.I2}\\n\"\n         + \"*/ a.Bar = function(){}\",\n         \"var a = {};\\n\"\n-        + \"/**\\n * @constructor\\n */\\na.Foo = function() {\\n};\\n\"\n-        + \"/**\\n * @interface\\n */\\na.I = function() {\\n};\\n\"\n-        + \"/**\\n * @interface\\n */\\na.I2 = function() {\\n};\\n\"\n-        + \"/**\\n * @extends {a.Foo}\\n * @implements {a.I}\\n\"\n+        + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n+        + \"a.Foo = function() {\\n};\\n\"\n+        + \"/**\\n * @interface\\n */\\n\"\n+        + \"a.I = function() {\\n};\\n\"\n+        + \"/**\\n * @interface\\n */\\n\"\n+        + \"a.I2 = function() {\\n};\\n\"\n+        + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n+        + \" * @implements {a.I}\\n\"\n         + \" * @implements {a.I2}\\n * @constructor\\n */\\n\"\n         + \"a.Bar = function() {\\n}\");\n   }\n         \"a.Foo = function(){}\",\n         \"var a = {};\\n\" +\n         \"/**\\n\" +\n+        \" * @return {undefined}\\n\" +\n         \" * @constructor\\n\" +\n         \" * @javadispatch\\n\" +\n         \" */\\n\" +\n \n         \"var a = {};\\n\" +\n         \"/**\\n\" +\n+        \" * @return {undefined}\\n\" +\n         \" * @constructor\\n\" +\n         \" */\\n\" +\n         \"a.Foo = function() {\\n\" +\n         \"};\\n\" +\n         \"/**\\n\" +\n+        \" * @return {undefined}\\n\" +\n         \" * @javadispatch\\n\" +\n         \" */\\n\" +\n         \"a.Foo.prototype.foo = function() {\\n\" +\n         \"var a = function(x) {}\",\n         \"/**\\n\" +\n         \" * @param {*} x\\n\" +\n+        \" * @return {undefined}\\n\" +\n         \" */\\n\" + \n         \"var a = function(x) {\\n}\");\n   }\n         \"var a = function(x) {}\",\n         \"/**\\n\" +\n         \" * @param {string=} x\\n\" +\n+        \" * @return {undefined}\\n\" +\n         \" */\\n\" +\n         \"var a = function(x) {\\n}\");\n   }\n         \"var a = function(x) {}\",\n         \"/**\\n\" +\n         \" * @param {...string} x\\n\" +\n+        \" * @return {undefined}\\n\" +\n         \" */\\n\" +\n         \"var a = function(x) {\\n}\");\n   }\n         \"var x = function() {\\n/**\\n * @constructor\\n */\\nfunction t1() {}\\n\" +\n         \" /**\\n * @constructor\\n */\\nfunction t2() {}\\n\" +\n         \" t1.prototype = t2.prototype}\",\n-        \"/**\\n */\\nvar x = function() {\\n\" +\n-        \"  /**\\n * @constructor\\n */\\nfunction t1() {\\n  }\\n\" +\n-        \"  /**\\n * @constructor\\n */\\nfunction t2() {\\n  }\\n\" +\n+        \"/**\\n * @return {undefined}\\n */\\nvar x = function() {\\n\" +\n+        \"  /**\\n * @return {undefined}\\n * @constructor\\n */\\n\" +\n+        \"function t1() {\\n  }\\n\" +\n+        \"  /**\\n * @return {undefined}\\n * @constructor\\n */\\n\" +\n+        \"function t2() {\\n  }\\n\" +\n         \"  t1.prototype = t2.prototype\\n}\"\n     );\n   }\n--- a/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n         \"CALL JSCompiler_StaticMethods_baz = null\");\n \n     static final List<String> EXPECTED_TYPE_CHECKING_ON = ImmutableList.of(\n-        \"FUNCTION a = function (this:a): ?\",\n+        \"FUNCTION a = function (this:a): undefined\",\n         \"NAME JSCompiler_StaticMethods_foo$self = a\",\n         \"FUNCTION JSCompiler_StaticMethods_foo = function (a): number\",\n         \"NAME JSCompiler_StaticMethods_bar$self = a\",\n         \"FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number\",\n-        \"FUNCTION JSCompiler_StaticMethods_baz = function (a): ?\",\n+        \"FUNCTION JSCompiler_StaticMethods_baz = function (a): undefined\",\n         \"NEW a = a\",\n         \"CALL JSCompiler_StaticMethods_foo = number\",\n         \"CALL JSCompiler_StaticMethods_bar = number\",\n-        \"CALL JSCompiler_StaticMethods_baz = ?\");\n+        \"CALL JSCompiler_StaticMethods_baz = undefined\");\n \n     private RewritePrototypeMethodTestInput() {}\n   }\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n     String output = \"\"\n         + \"function Foo(){}\"\n         + \"function Bar(){}\"\n-        + \"Foo.function__this_Foo____$a = 0;\"\n-        + \"Bar.function__this_Bar____$a = 0;\";\n+        + \"Foo.function__this_Foo___undefined$a = 0;\"\n+        + \"Bar.function__this_Bar___undefined$a = 0;\";\n \n     testSets(false, js, output,\n-        \"{a=[[function (this:Bar): ?], [function (this:Foo): ?]]}\");\n+        \"{a=[[function (this:Bar): undefined],\" +\n+        \" [function (this:Foo): undefined]]}\");\n   }\n \n   public void testSupertypeWithSameField() {\n     String js = \"\"\n         + \"/** @constructor */ var Foo = function() {};\\n\"\n         + \"/** @constructor */ var Bar = function() {};\\n\"\n-        + \"function fun() {}\\n\"\n+        + \"/** @return {?} */ function fun() {}\\n\"\n         + \"Foo.prototype.a = fun();\\n\"\n         + \"fun().a;\\n\"\n         + \"Bar.prototype.a = 0;\";\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n                     \" * @param {*} d\\n\" +\n                     \" * @param {*} e\\n\" +\n                     \" * @param {*} f\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"var foobar = function(d, e, f) {\\n}\");\n   }\n                     \" * @param {*} d\\n\" +\n                     \" * @param {*} e\\n\" +\n                     \" * @param {*} f\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"var foobar = function(d, e, f) {\\n}\");\n   }\n                     \" * @param {*} d\\n\" +\n                     \" * @param {*} e\\n\" +\n                     \" * @param {*} f\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"a.b.cprop = function(d, e, f) {\\n}\");\n   }\n                     \"var a = {};\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {*} p1\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"a.b = function(p1) {\\n};\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {*} d\\n\" +\n                     \" * @param {*} e\\n\" +\n                     \" * @param {*} f\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"a.b.c = function(d, e, f) {\\n};\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {*} g\\n\" +\n                     \" * @param {*} h\\n\" +\n                     \" * @param {*} i\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"a.b.prototype.c = function(g, h, i) {\\n}\");\n   }\n                     \" * @param {*} d\\n\" +\n                     \" * @param {*} e\\n\" +\n                     \" * @param {*} f\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"hello.b.c = function(d, e, f) {\\n};\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {*} g\\n\" +\n                     \" * @param {*} h\\n\" +\n                     \" * @param {*} i\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"hello.b.prototype.c = function(g, h, i) {\\n}\");\n   }\n \n                     \"/**\\n\" +\n                     \" * @param {*} p1\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"var prefix = function(p1) {\\n};\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {*} d\\n\" +\n                     \" * @param {*} e\\n\" +\n                     \" * @param {*} f\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n                     \"prefix.c = function(d, e, f) {\\n}\");\n   }\n                     \"};\" +\n                     \"goog.exportSymbol('externalName', internalName)\",\n                     \"/**\\n\" +\n+                    \" * @return {undefined}\\n\" +\n                     \" * @constructor\\n\" +\n                     \" */\\n\" + \n                     \"var externalName = function() {\\n}\");\n         \"goog.exportSymbol('Foo', Foo);\\n\" +\n         \"goog.exportProperty(Foo.prototype, 'm', Foo.prototype.m);\",\n         \"/**\\n\" +\n+        \" * @return {undefined}\\n\" +\n         \" * @constructor\\n\" +\n         \" */\\n\" +\n         \"var Foo = function() {\\n};\\n\" +\n--- a/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n+++ b/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n   public void testNativeCtor() {\n     testSame(\n         \"/** Object. \\n * @param {*} x \\n * @constructor */ \" +\n-        \"function Object(x) {};\" +\n+        \"function Object(x) {};\",\n         \"var x = new Object();\" +\n-        \"/** Another object. */ var y = new Object();\");\n+        \"/** Another object. */ var y = new Object();\", null);\n     assertEquals(\n         \"Object.\",\n         findGlobalNameType(\"x\").getJSDocInfo().getBlockDescription());\n   public void testStructuralFunctions() {\n     testSame(\n         \"/** Object. \\n * @param {*} x \\n * @constructor */ \" +\n-        \"function Object(x) {};\" +\n+        \"function Object(x) {};\",\n         \"/** Function. \\n * @param {*} x */ \" +\n         \"function fn(x) {};\" +\n         \"var goog = {};\" +\n         \"/** Another object. \\n * @type {Object} */ goog.x = new Object();\" +\n-        \"/** Another function. \\n * @param {number} x */ goog.y = fn;\");\n+        \"/** Another function. \\n * @param {number} x */ goog.y = fn;\", null);\n     assertEquals(\n         \"(Object|null)\",\n         globalScope.getVar(\"goog.x\").getType().toString());\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n   public void testInstanceof5() throws Exception {\n     // No warning for unknown types.\n-    testTypes(\"function foo(){\" +\n+    testTypes(\"/** @return {?} */ function foo(){\" +\n         \"if (foo() instanceof Object)return;}\");\n   }\n \n     assertFalse(p.scope.isDeclared(\"b\", false));\n \n     // checking that a has the correct assigned type\n-    assertEquals(\"function (): ?\", p.scope.getVar(\"a\").getType().toString());\n+    assertEquals(\"function (): undefined\",\n+        p.scope.getVar(\"a\").getType().toString());\n   }\n \n   public void testScoping11() throws Exception {\n   public void testFunctionInference1() throws Exception {\n     testFunctionType(\n         \"function f(a) {}\",\n-        \"function (?): ?\");\n+        \"function (?): undefined\");\n   }\n \n   public void testFunctionInference2() throws Exception {\n     testFunctionType(\n         \"function f(a,b) {}\",\n-        \"function (?, ?): ?\");\n+        \"function (?, ?): undefined\");\n   }\n \n   public void testFunctionInference3() throws Exception {\n     testFunctionType(\n         \"function f(var_args) {}\",\n-        \"function (...[?]): ?\");\n+        \"function (...[?]): undefined\");\n   }\n \n   public void testFunctionInference4() throws Exception {\n     testFunctionType(\n         \"function f(a,b,c,var_args) {}\",\n-        \"function (?, ?, ?, ...[?]): ?\");\n+        \"function (?, ?, ?, ...[?]): undefined\");\n   }\n \n   public void testFunctionInference5() throws Exception {\n   public void testFunctionInference7() throws Exception {\n     testFunctionType(\n         \"/** @this Date */function f(a,b,c,var_args) {}\",\n-        \"function (this:Date, ?, ?, ?, ...[?]): ?\");\n+        \"function (this:Date, ?, ?, ?, ...[?]): undefined\");\n   }\n \n   public void testFunctionInference8() throws Exception {\n     testFunctionType(\n         \"function f() {}\",\n-        \"function (): ?\");\n+        \"function (): undefined\");\n   }\n \n   public void testFunctionInference9() throws Exception {\n     testFunctionType(\n         \"var f = function() {};\",\n-        \"function (): ?\");\n+        \"function (): undefined\");\n   }\n \n   public void testFunctionInference10() throws Exception {\n         \"var goog = {};\" +\n         \"goog.f = function(){};\",\n         \"goog.f\",\n-        \"function (): ?\");\n+        \"function (): undefined\");\n   }\n \n   public void testFunctionInference13() throws Exception {\n         \"/** @constructor */ goog.Foo = function(){};\" +\n         \"/** @param {!goog.Foo} f */function eatFoo(f){};\",\n         \"eatFoo\",\n-        \"function (goog.Foo): ?\");\n+        \"function (goog.Foo): undefined\");\n   }\n \n   public void testFunctionInference14() throws Exception {\n         \"/** @constructor */ function f() {};\" +\n         \"f.prototype.foo = function(){};\",\n         \"f.prototype.foo\",\n-        \"function (this:f): ?\");\n+        \"function (this:f): undefined\");\n   }\n \n   public void testFunctionInference16() throws Exception {\n         \"/** @constructor */ function f() {};\" +\n         \"f.prototype.foo = function(){};\",\n         \"(new f).foo\",\n-        \"function (this:f): ?\");\n+        \"function (this:f): undefined\");\n   }\n \n   public void testFunctionInference17() throws Exception {\n         \"var goog = goog || {};\" +\n         \"/** @param {number} x */ goog.foo = function(x) {};\" +\n         \"/** @param {number} x */ goog.foo = function(x) {};\",\n-        \"variable goog.foo redefined with type function (number): ?, \" +\n-        \"original definition at [testcode]:1 with type function (number): ?\");\n+        \"variable goog.foo redefined with type function (number): undefined, \" +\n+        \"original definition at [testcode]:1 \" +\n+        \"with type function (number): undefined\");\n   }\n \n   public void testDuplicateStaticMethodDecl2() throws Exception {\n         \"goog.foo = function(x) {};\" +\n         \"/** @return {undefined} */ goog.foo = function(x) {};\",\n         \"variable goog.foo redefined with type function (?): undefined, \" +\n-        \"original definition at [testcode]:1 with type function (?): ?\");\n+        \"original definition at [testcode]:1 with type \" +\n+        \"function (?): undefined\");\n   }\n \n   public void testDuplicateStaticPropertyDecl1() throws Exception {\n         \"/** @constructor */ function f() {};\" +\n         \"f.prototype.foo = f.prototype.bar = function(){};\";\n     testFunctionType(nestedAssignOfFooAndBar, \"(new f).bar\",\n-        \"function (this:f): ?\");\n+        \"function (this:f): undefined\");\n   }\n \n   /**\n   public void testTypeRedefinition() throws Exception {\n     testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n         + \"/** @constructor */ a.A = function() {}\",\n-        \"variable a.A redefined with type function (this:a.A): ?, \" +\n+        \"variable a.A redefined with type function (this:a.A): undefined, \" +\n         \"original definition at [testcode]:1 with type enum{a.A}\");\n   }\n \n         \"/** @extends {base}\\n * @constructor */function derived() {}\\n\" +\n         \"derived.inherits(base);\",\n         \"(new derived).constructor\",\n-        \"function (this:derived): ?\");\n+        \"function (this:derived): undefined\");\n   }\n \n   public void testGoodExtends8() throws Exception {\n     // verifying the type assigned to anonymous functions assigned variables\n     Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").scope;\n     JSType type = s.getVar(\"a\").getType();\n-    assertEquals(\"function (): ?\", type.toString());\n+    assertEquals(\"function (): undefined\", type.toString());\n \n     // verifying the bug example\n     testTypes(\"function nullFunction() {};\" +\n     testTypes(\n         \"/** @constructor */ function Foo() {}\" +\n         \"Foo();\",\n-        \"Constructor function (this:Foo): ? should be called \" +\n+        \"Constructor function (this:Foo): undefined should be called \" +\n         \"with the \\\"new\\\" keyword\");\n   }\n \n         \"A.prototype = {m1: 5, m2: true}\");\n \n     JSType functionAType = js1Node.getFirstChild().getJSType();\n-    assertEquals(\"function (): ?\", functionAType.toString());\n+    assertEquals(\"function (): undefined\", functionAType.toString());\n     assertEquals(UNKNOWN_TYPE,\n         U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n     assertEquals(UNKNOWN_TYPE,\n   public void testInheritanceCheck9_1() throws Exception {\n     testTypes(\n         \"/** @constructor */function Super() {};\" +\n-        \"Super.prototype.foo = function() {};\" +\n+        \"Super.prototype.foo = function() { return 3; };\" +\n         \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n         \"/** @override\\n @return number */Sub.prototype.foo =\\n\" +\n         \"function() { return 1; };\");\n   public void testInheritanceCheck10_1() throws Exception {\n     testTypes(\n         \"/** @constructor */function Root() {};\" +\n-        \"Root.prototype.foo = function() {};\" +\n+        \"Root.prototype.foo = function() { return 4; };\" +\n         \"/** @constructor\\n @extends {Root} */function Super() {};\" +\n         \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n         \"/** @override\\n @return number */Sub.prototype.foo =\\n\" +\n         \"function(bar) {};\",\n         \"mismatch of the foo property type and the type of the property it \" +\n         \"overrides from superclass Super\\n\" +\n-        \"original: function (this:Super, number): ?\\n\" +\n-        \"override: function (this:Sub, string): ?\");\n+        \"original: function (this:Super, number): undefined\\n\" +\n+        \"override: function (this:Sub, string): undefined\");\n   }\n \n   public void testInheritanceCheck12() throws Exception {\n         \"function(bar) {};\",\n         \"mismatch of the foo property type and the type of the property it \" +\n         \"overrides from interface Super\\n\" +\n-        \"original: function (this:Super, number): ?\\n\" +\n-        \"override: function (this:Sub, string): ?\");\n+        \"original: function (this:Super, number): undefined\\n\" +\n+        \"override: function (this:Sub, string): undefined\");\n   }\n \n   public void testInterfaceInheritanceCheck8() throws Exception {\n     testTypes(\"/** @interface */ function T() {};\\n\" +\n         \"/** @type {number} */T.prototype.x = function() { };\",\n         \"assignment to property x of T.prototype\\n\" +\n-        \"found   : function (): ?\\n\" +\n+        \"found   : function (): undefined\\n\" +\n         \"required: number\");\n   }\n \n   public void testDfa12() throws Exception {\n     testTypes(\"/** @param {string} x \\n * @constructor \\n */\" +\n         \"var Bar = function(x) {};\" +\n-        \"/** @param {string} x */ function g(x) {}\" +\n+        \"/** @param {string} x */ function g(x) { return true; }\" +\n         \"/** @param {string|number} opt_x */ \" +\n         \"function f(opt_x) { \" +\n         \"  if (opt_x) { new Bar(g(opt_x) && 'x'); }\" +\n         \"/** @type {number} */ goog.Bar = goog.typedef\",\n         \"variable goog.Bar redefined with type number, \" +\n         \"original definition at [testcode]:1 \" +\n-        \"with type function (this:goog.Bar): ?\");\n+        \"with type function (this:goog.Bar): undefined\");\n   }\n \n   public void testOldTypeDef1() throws Exception {\n         \"/** @typedef {number} */ goog.Bar;\",\n         \"variable goog.Bar redefined with type None, \" +\n         \"original definition at [testcode]:1 \" +\n-        \"with type function (this:goog.Bar): ?\");\n+        \"with type function (this:goog.Bar): undefined\");\n   }\n \n   public void testTypeDef1() throws Exception {\n \n     assertTrue(p.scope.getVar(\"Foo\").getType() instanceof FunctionType);\n     FunctionType fooType = (FunctionType) p.scope.getVar(\"Foo\").getType();\n-    assertEquals(\"function (this:Foo, number): ?\",\n+    assertEquals(\"function (this:Foo, number): undefined\",\n                  fooType.getPrototype().getPropertyType(\"bar\").toString());\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n   public void testInstanceof5() throws Exception {\n     // No warning for unknown types.\n-    testTypes(\"function foo(){\" +\n+    testTypes(\"/** @return {?} */ function foo(){\" +\n         \"if (foo() instanceof Object)return;}\");\n   }\n \n     assertFalse(p.scope.isDeclared(\"b\", false));\n \n     // checking that a has the correct assigned type\n-    assertEquals(\"function (): ?\", p.scope.getVar(\"a\").getType().toString());\n+    assertEquals(\"function (): undefined\",\n+        p.scope.getVar(\"a\").getType().toString());\n   }\n \n   public void testScoping11() throws Exception {\n   public void testFunctionInference1() throws Exception {\n     testFunctionType(\n         \"function f(a) {}\",\n-        \"function (?): ?\");\n+        \"function (?): undefined\");\n   }\n \n   public void testFunctionInference2() throws Exception {\n     testFunctionType(\n         \"function f(a,b) {}\",\n-        \"function (?, ?): ?\");\n+        \"function (?, ?): undefined\");\n   }\n \n   public void testFunctionInference3() throws Exception {\n     testFunctionType(\n         \"function f(var_args) {}\",\n-        \"function (...[?]): ?\");\n+        \"function (...[?]): undefined\");\n   }\n \n   public void testFunctionInference4() throws Exception {\n     testFunctionType(\n         \"function f(a,b,c,var_args) {}\",\n-        \"function (?, ?, ?, ...[?]): ?\");\n+        \"function (?, ?, ?, ...[?]): undefined\");\n   }\n \n   public void testFunctionInference5() throws Exception {\n   public void testFunctionInference7() throws Exception {\n     testFunctionType(\n         \"/** @this Date */function f(a,b,c,var_args) {}\",\n-        \"function (this:Date, ?, ?, ?, ...[?]): ?\");\n+        \"function (this:Date, ?, ?, ?, ...[?]): undefined\");\n   }\n \n   public void testFunctionInference8() throws Exception {\n     testFunctionType(\n         \"function f() {}\",\n-        \"function (): ?\");\n+        \"function (): undefined\");\n   }\n \n   public void testFunctionInference9() throws Exception {\n     testFunctionType(\n         \"var f = function() {};\",\n-        \"function (): ?\");\n+        \"function (): undefined\");\n   }\n \n   public void testFunctionInference10() throws Exception {\n         \"var goog = {};\" +\n         \"goog.f = function(){};\",\n         \"goog.f\",\n-        \"function (): ?\");\n+        \"function (): undefined\");\n   }\n \n   public void testFunctionInference13() throws Exception {\n         \"/** @constructor */ goog.Foo = function(){};\" +\n         \"/** @param {!goog.Foo} f */function eatFoo(f){};\",\n         \"eatFoo\",\n-        \"function (goog.Foo): ?\");\n+        \"function (goog.Foo): undefined\");\n   }\n \n   public void testFunctionInference14() throws Exception {\n         \"/** @constructor */ function f() {};\" +\n         \"f.prototype.foo = function(){};\",\n         \"f.prototype.foo\",\n-        \"function (this:f): ?\");\n+        \"function (this:f): undefined\");\n   }\n \n   public void testFunctionInference16() throws Exception {\n         \"/** @constructor */ function f() {};\" +\n         \"f.prototype.foo = function(){};\",\n         \"(new f).foo\",\n-        \"function (this:f): ?\");\n+        \"function (this:f): undefined\");\n   }\n \n   public void testFunctionInference17() throws Exception {\n         \"var goog = goog || {};\" +\n         \"/** @param {number} x */ goog.foo = function(x) {};\" +\n         \"/** @param {number} x */ goog.foo = function(x) {};\",\n-        \"variable goog.foo redefined with type function (number): ?, \" +\n-        \"original definition at [testcode]:1 with type function (number): ?\");\n+        \"variable goog.foo redefined with type function (number): undefined, \" +\n+        \"original definition at [testcode]:1 with type function (number): undefined\");\n   }\n \n   public void testDuplicateStaticMethodDecl2() throws Exception {\n         \"goog.foo = function(x) {};\" +\n         \"/** @return {undefined} */ goog.foo = function(x) {};\",\n         \"variable goog.foo redefined with type function (?): undefined, \" +\n-        \"original definition at [testcode]:1 with type function (?): ?\");\n+        \"original definition at [testcode]:1 with type \" +\n+        \"function (?): undefined\");\n   }\n \n   public void testDuplicateStaticPropertyDecl1() throws Exception {\n         \"/** @constructor */ function f() {};\" +\n         \"f.prototype.foo = f.prototype.bar = function(){};\";\n     testFunctionType(nestedAssignOfFooAndBar, \"(new f).bar\",\n-        \"function (this:f): ?\");\n+        \"function (this:f): undefined\");\n   }\n \n   /**\n   public void testTypeRedefinition() throws Exception {\n     testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n         + \"/** @constructor */ a.A = function() {}\",\n-        \"variable a.A redefined with type function (this:a.A): ?, \" +\n+        \"variable a.A redefined with type function (this:a.A): undefined, \" +\n         \"original definition at [testcode]:1 with type enum{a.A}\");\n   }\n \n         \"/** @extends {base}\\n * @constructor */function derived() {}\\n\" +\n         \"derived.inherits(base);\",\n         \"(new derived).constructor\",\n-        \"function (this:derived): ?\");\n+        \"function (this:derived): undefined\");\n   }\n \n   public void testGoodExtends8() throws Exception {\n         \"required: B\");\n   }\n \n+  public void testInferredReturn1() throws Exception {\n+    testTypes(\n+        \"function f() {} /** @param {number} x */ function g(x) {}\" +\n+        \"g(f());\",\n+        \"actual parameter 1 of g does not match formal parameter\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testInferredReturn2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() {}; \" +\n+        \"/** @param {number} x */ function g(x) {}\" +\n+        \"g((new Foo()).bar());\",\n+        \"actual parameter 1 of g does not match formal parameter\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testInferredReturn3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() {}; \" +\n+        \"/** @constructor \\n * @extends {Foo} */ function SubFoo() {}\" +\n+        \"/** @return {number} \\n * @override  */ \" +\n+        \"SubFoo.prototype.bar = function() { return 3; }; \",\n+        \"mismatch of the bar property type and the type of the property \" +\n+        \"it overrides from superclass Foo\\n\" +\n+        \"original: function (this:Foo): undefined\\n\" +\n+        \"override: function (this:SubFoo): number\");\n+  }\n+\n+  public void testInferredReturn4() throws Exception {\n+    // By design, this throws a warning. if you want global x to be\n+    // defined to some other type of function, then you need to declare it\n+    // as a greater type.\n+    testTypes(\n+        \"var x = function() {};\" +\n+        \"x = /** @type {function(): number} */ (function() { return 3; });\",\n+        \"assignment\\n\" +\n+        \"found   : function (): number\\n\" +\n+        \"required: function (): undefined\");\n+  }\n+\n+  public void testInferredReturn5() throws Exception {\n+    // If x is local, then the function type is not declared.\n+    testTypes(\n+        \"/** @return {string} */\" +\n+        \"function f() {\" +\n+        \"  var x = function() {};\" +\n+        \"  x = /** @type {function(): number} */ (function() { return 3; });\" +\n+        \"  return x();\" +\n+        \"}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testInferredReturn6() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */\" +\n+        \"function f() {\" +\n+        \"  var x = function() {};\" +\n+        \"  if (f()) \" +\n+        \"    x = /** @type {function(): number} */ \" +\n+        \"        (function() { return 3; });\" +\n+        \"  return x();\" +\n+        \"}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|undefined)\\n\" +\n+        \"required: string\");\n+  }\n+\n   public void testThis1() throws Exception {\n     testTypes(\"var goog = {};\" +\n         \"/** @constructor */goog.A = function(){};\" +\n     // verifying the type assigned to function expressions assigned variables\n     Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").scope;\n     JSType type = s.getVar(\"a\").getType();\n-    assertEquals(\"function (): ?\", type.toString());\n+    assertEquals(\"function (): undefined\", type.toString());\n \n     // verifying the bug example\n     testTypes(\"function nullFunction() {};\" +\n     testTypes(\n         \"/** @constructor */ function Foo() {}\" +\n         \"Foo();\",\n-        \"Constructor function (this:Foo): ? should be called \" +\n+        \"Constructor function (this:Foo): undefined should be called \" +\n         \"with the \\\"new\\\" keyword\");\n   }\n \n         \"A.prototype = {m1: 5, m2: true}\");\n \n     JSType functionAType = js1Node.getFirstChild().getJSType();\n-    assertEquals(\"function (): ?\", functionAType.toString());\n+    assertEquals(\"function (): undefined\", functionAType.toString());\n     assertEquals(UNKNOWN_TYPE,\n         U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n     assertEquals(UNKNOWN_TYPE,\n   public void testInheritanceCheck9_1() throws Exception {\n     testTypes(\n         \"/** @constructor */function Super() {};\" +\n-        \"Super.prototype.foo = function() {};\" +\n+        \"Super.prototype.foo = function() { return 3; };\" +\n         \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n         \"/** @override\\n @return number */Sub.prototype.foo =\\n\" +\n         \"function() { return 1; };\");\n   public void testInheritanceCheck10_1() throws Exception {\n     testTypes(\n         \"/** @constructor */function Root() {};\" +\n-        \"Root.prototype.foo = function() {};\" +\n+        \"Root.prototype.foo = function() { return 3; };\" +\n         \"/** @constructor\\n @extends {Root} */function Super() {};\" +\n         \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n         \"/** @override\\n @return number */Sub.prototype.foo =\\n\" +\n         \"function(bar) {};\",\n         \"mismatch of the foo property type and the type of the property it \" +\n         \"overrides from superclass Super\\n\" +\n-        \"original: function (this:Super, number): ?\\n\" +\n-        \"override: function (this:Sub, string): ?\");\n+        \"original: function (this:Super, number): undefined\\n\" +\n+        \"override: function (this:Sub, string): undefined\");\n   }\n \n   public void testInheritanceCheck12() throws Exception {\n         \"function(bar) {};\",\n         \"mismatch of the foo property type and the type of the property it \" +\n         \"overrides from interface Super\\n\" +\n-        \"original: function (this:Super, number): ?\\n\" +\n-        \"override: function (this:Sub, string): ?\");\n+        \"original: function (this:Super, number): undefined\\n\" +\n+        \"override: function (this:Sub, string): undefined\");\n   }\n \n   public void testInterfaceInheritanceCheck8() throws Exception {\n     testTypes(\"/** @interface */ function T() {};\\n\" +\n         \"/** @type {number} */T.prototype.x = function() { };\",\n         \"assignment to property x of T.prototype\\n\" +\n-        \"found   : function (): ?\\n\" +\n+        \"found   : function (): undefined\\n\" +\n         \"required: number\");\n   }\n \n   public void testDfa12() throws Exception {\n     testTypes(\"/** @param {string} x \\n * @constructor \\n */\" +\n         \"var Bar = function(x) {};\" +\n-        \"/** @param {string} x */ function g(x) {}\" +\n+        \"/** @param {string} x */ function g(x) { return true; }\" +\n         \"/** @param {string|number} opt_x */ \" +\n         \"function f(opt_x) { \" +\n         \"  if (opt_x) { new Bar(g(opt_x) && 'x'); }\" +\n         \"/** @type {number} */ goog.Bar = goog.typedef\",\n         \"variable goog.Bar redefined with type number, \" +\n         \"original definition at [testcode]:1 \" +\n-        \"with type function (this:goog.Bar): ?\");\n+        \"with type function (this:goog.Bar): undefined\");\n   }\n \n   public void testOldTypeDef1() throws Exception {\n         \"/** @typedef {number} */ goog.Bar;\",\n         \"variable goog.Bar redefined with type None, \" +\n         \"original definition at [testcode]:1 \" +\n-        \"with type function (this:goog.Bar): ?\");\n+        \"with type function (this:goog.Bar): undefined\");\n   }\n \n   public void testTypeDef1() throws Exception {\n \n     assertTrue(p.scope.getVar(\"Foo\").getType() instanceof FunctionType);\n     FunctionType fooType = (FunctionType) p.scope.getVar(\"Foo\").getType();\n-    assertEquals(\"function (this:Foo, number): ?\",\n+    assertEquals(\"function (this:Foo, number): undefined\",\n                  fooType.getPrototype().getPropertyType(\"bar\").toString());\n   }\n \n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n \n     JSType fooBar = foo.getPropertyType(\"Bar\");\n-    assertEquals(\"function (this:foo.Bar): ?\", fooBar.toString());\n+    assertEquals(\"function (this:foo.Bar): undefined\", fooBar.toString());\n     assertEquals(Sets.newHashSet(foo), registry.getTypesWithProperty(\"Bar\"));\n   }\n \n     ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n     assertEquals(\"Window\", x.toString());\n     assertTrue(x.getImplicitPrototype().hasOwnProperty(\"alert\"));\n-    assertEquals(\"function (this:Window, ?): ?\",\n+    assertEquals(\"function (this:Window, ?): undefined\",\n         x.getPropertyType(\"alert\").toString());\n     assertTrue(x.isPropertyTypeDeclared(\"alert\"));\n \n     ObjectType y = (ObjectType) findNameType(\"y\", globalScope);\n-    assertEquals(\"function (this:Window, ?): ?\",\n+    assertEquals(\"function (this:Window, ?): undefined\",\n         y.getPropertyType(\"alert\").toString());\n   }\n \n     assertTrue(iPrototype.isFunctionPrototypeType());\n \n     assertEquals(\"number\", iPrototype.getPropertyType(\"bar\").toString());\n-    assertEquals(\"function (this:I): ?\",\n+    assertEquals(\"function (this:I): undefined\",\n         iPrototype.getPropertyType(\"baz\").toString());\n \n     assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n   public void testPropertyInExterns3() {\n     testSame(\n         \"/** @constructor \\n * @param {*} x */ function Object(x) {}\" +\n-        \"/** @type {number} */ Object.one;\", null);\n+        \"/** @type {number} */ Object.one;\", \"\", null);\n \n     ObjectType obj = globalScope.getVar(\"Object\").getType().dereference();\n     assertTrue(obj.hasOwnProperty(\"one\"));\n     ObjectType ctor = (ObjectType) (findNameType(\"goog.Foo\", globalScope));\n     assertNotNull(ctor);\n     assertTrue(ctor.isConstructor());\n-    assertEquals(\"function (this:goog.Foo): ?\", ctor.toString());\n+    assertEquals(\"function (this:goog.Foo): undefined\", ctor.toString());\n   }\n \n   public void testForLoopIntegration() {\n         findNameType(\"x\", globalScope).toString());\n   }\n \n+  public void testReturnTypeInference1() {\n+    testSame(\"function f() {}\");\n+    assertEquals(\n+        \"function (): undefined\",\n+        findNameType(\"f\", globalScope).toString());\n+  }\n+\n+  public void testReturnTypeInference2() {\n+    testSame(\"/** @return {?} */ function f() {}\");\n+    assertEquals(\n+        \"function (): ?\",\n+        findNameType(\"f\", globalScope).toString());\n+  }\n+\n+  public void testReturnTypeInference3() {\n+    testSame(\"function f() {x: return 3;}\");\n+    assertEquals(\n+        \"function (): ?\",\n+        findNameType(\"f\", globalScope).toString());\n+  }\n+\n+  public void testReturnTypeInference4() {\n+    testSame(\"function f() { throw Error(); }\");\n+    assertEquals(\n+        \"function (): ?\",\n+        findNameType(\"f\", globalScope).toString());\n+  }\n+\n+  public void testReturnTypeInference5() {\n+    testSame(\"function f() { if (true) { return 1; } }\");\n+    assertEquals(\n+        \"function (): ?\",\n+        findNameType(\"f\", globalScope).toString());\n+  }\n+\n   private JSType findNameType(String name, Scope scope) {\n     Node root = scope.getRootNode();\n     Deque<Node> queue = Lists.newLinkedList();", "timestamp": 1277252377, "metainfo": ""}