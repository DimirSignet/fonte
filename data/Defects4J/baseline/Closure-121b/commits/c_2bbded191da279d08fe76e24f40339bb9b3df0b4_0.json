{"sha": "2bbded191da279d08fe76e24f40339bb9b3df0b4", "log": "Simplify a bunch of the subclassing around types and property maps, and more clearly document the few places where we generate properties lazily.  R=dimvar DELTA=398  (86 added, 282 deleted, 30 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5947   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.Node;\n \n-import java.util.Set;\n-\n /**\n  * The type of individual elements of an enum type\n  * (see {@link EnumType}).\n     this.name = name;\n   }\n \n-  @Override\n-  public Property getSlot(String name) {\n-    if (primitiveObjectType != null) {\n-      return primitiveObjectType.getSlot(name);\n-    }\n-    return null;\n+  @Override public PropertyMap getPropertyMap() {\n+    return primitiveObjectType == null\n+        ? PropertyMap.immutableEmptyMap()\n+        : primitiveObjectType.getPropertyMap();\n   }\n \n   @Override\n   }\n \n   @Override\n-  public boolean isPropertyTypeDeclared(String propertyName) {\n-    return primitiveObjectType == null ?\n-        false : primitiveObjectType.isPropertyTypeDeclared(propertyName);\n-  }\n-\n-  @Override\n-  public boolean isPropertyTypeInferred(String propertyName) {\n-    return primitiveObjectType == null ?\n-        false : primitiveObjectType.isPropertyTypeInferred(propertyName);\n-  }\n-\n-  @Override\n   public ObjectType getImplicitPrototype() {\n     return null;\n   }\n \n   @Override\n-  public int getPropertiesCount() {\n-    return primitiveObjectType == null ?\n-        0 : primitiveObjectType.getPropertiesCount();\n-  }\n-\n-  @Override\n-  void collectPropertyNames(Set<String> props) {\n-    if (primitiveObjectType != null) {\n-      primitiveObjectType.collectPropertyNames(props);\n-    }\n-  }\n-\n-  @Override\n   public JSType findPropertyType(String propertyName) {\n     return primitiveType.findPropertyType(propertyName);\n-  }\n-\n-  @Override\n-  public JSType getPropertyType(String propertyName) {\n-    return primitiveObjectType == null ?\n-        getNativeType(JSTypeNative.UNKNOWN_TYPE) :\n-        primitiveObjectType.getPropertyType(propertyName);\n-  }\n-\n-  @Override\n-  public boolean hasProperty(String propertyName) {\n-    return primitiveObjectType == null ?\n-        false :\n-        primitiveObjectType.hasProperty(propertyName);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n   }\n \n   @Override\n-  public int getPropertiesCount() {\n-    // Should never be called, returning the biggest number to highlight the\n-    // 'unifying' role of this type.\n-    return Integer.MAX_VALUE;\n-  }\n-\n-  @Override\n-  public JSType getPropertyType(String propertyName) {\n-    // Return the least type to be a proper subtype of all other objects.\n-    return getNativeType(JSTypeNative.NO_TYPE);\n-  }\n-\n-  @Override\n-  public boolean hasProperty(String propertyName) {\n-    // has all properties, since it is any object\n-    return true;\n-  }\n-\n-  @Override\n   boolean defineProperty(String propertyName, JSType type,\n       boolean inferred, Node propertyNode) {\n     // nothing, all properties are defined\n   }\n \n   @Override\n-  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n-    return null;\n-  }\n-\n-  @Override\n   public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n     // Do nothing, specific properties do not have JSDocInfo.\n-  }\n-\n-  @Override\n-  public boolean isPropertyTypeInferred(String propertyName) {\n-    return false;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/NoResolvedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoResolvedType.java\n   }\n \n   @Override\n-  public JSType getPropertyType(String propertyName) {\n-    return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n-  }\n-\n-  @Override\n   public boolean isSubtype(JSType that) {\n     if (JSType.isSubtypeHelper(this, that)) {\n       return true;\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    * Returns the property map that manages the set of properties for an object.\n    */\n   PropertyMap getPropertyMap() {\n-    return null;\n-  }\n-\n-  @Override\n-  public abstract Property getSlot(String name);\n+    return PropertyMap.immutableEmptyMap();\n+  }\n+\n+  /**\n+   * Default getSlot implementation. This gets overridden by FunctionType\n+   * for lazily-resolved prototypes.\n+   */\n+  @Override\n+  public Property getSlot(String name) {\n+    return getPropertyMap().getSlot(name);\n+  }\n \n   @Override\n   public Property getOwnSlot(String name) {\n-    if (hasOwnProperty(name)) {\n-      return getSlot(name);\n-    }\n-    return null;\n+    return getPropertyMap().getOwnProperty(name);\n   }\n \n   @Override\n    * @return the {@code Node} corresponding to the property or null.\n    */\n   public Node getPropertyNode(String propertyName) {\n-    return null;\n+    Property p = getSlot(propertyName);\n+    return p == null ? null : p.getNode();\n   }\n \n   /**\n    * Gets the docInfo on the specified property on this type.  This should not\n-   * be done implemented recursively, as you generally need to know exactly on\n+   * be implemented recursively, as you generally need to know exactly on\n    * which type in the prototype chain the JSDocInfo exists.\n    */\n   public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n-    return null;\n+    Property p = getOwnSlot(propertyName);\n+    return p == null ? null : p.getJSDocInfo();\n   }\n \n   /**\n    * underlying object does not have this property, the Unknown type is\n    * returned to indicate that no information is available on this property.\n    *\n+   * This gets overridden by FunctionType for lazily-resolved call() and\n+   * bind() functions.\n+   *\n    * @return the property's type or {@link UnknownType}. This method never\n    *         returns {@code null}.\n    */\n-  public abstract JSType getPropertyType(String propertyName);\n+  public JSType getPropertyType(String propertyName) {\n+    StaticSlot<JSType> slot = getSlot(propertyName);\n+    if (slot == null) {\n+      if (isNoResolvedType() || isCheckedUnknownType()) {\n+        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n+      } else if (isEmptyType()) {\n+        return getNativeType(JSTypeNative.NO_TYPE);\n+      }\n+      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+    }\n+    return slot.getType();\n+  }\n+\n+  @Override\n+  public boolean hasProperty(String propertyName) {\n+    // Unknown types have all properties.\n+    return isEmptyType() || isUnknownType() || getSlot(propertyName) != null;\n+  }\n \n   /**\n    * Checks whether the property whose name is given is present directly on\n    * the object.  Returns false even if it is declared on a supertype.\n    */\n   public boolean hasOwnProperty(String propertyName) {\n-    return hasProperty(propertyName);\n-  }\n-\n-  /** Returns the names of all the properties directly on this type. */\n+    return getOwnSlot(propertyName) != null;\n+  }\n+\n+  /**\n+   * Returns the names of all the properties directly on this type.\n+   *\n+   * Overridden by FunctionType to add \"prototype\".\n+   */\n   public Set<String> getOwnPropertyNames() {\n-    return ImmutableSet.of();\n+    return getPropertyMap().getOwnPropertyNames();\n   }\n \n   /**\n    * Checks whether the property's type is inferred.\n    */\n-  public abstract boolean isPropertyTypeInferred(String propertyName);\n+  public boolean isPropertyTypeInferred(String propertyName) {\n+    StaticSlot<JSType> slot = getSlot(propertyName);\n+    return slot == null ? false : slot.isTypeInferred();\n+  }\n \n   /**\n    * Checks whether the property's type is declared.\n    */\n-  public abstract boolean isPropertyTypeDeclared(String propertyName);\n+  public boolean isPropertyTypeDeclared(String propertyName) {\n+    StaticSlot<JSType> slot = getSlot(propertyName);\n+    return slot == null ? false : !slot.isTypeInferred();\n+  }\n \n   /**\n    * Whether the given property is declared on this object.\n    */\n-  boolean hasOwnDeclaredProperty(String name) {\n+  final boolean hasOwnDeclaredProperty(String name) {\n     return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n   }\n \n   /** Checks whether the property was defined in the externs. */\n   public boolean isPropertyInExterns(String propertyName) {\n-    return false;\n+    Property p = getSlot(propertyName);\n+    return p == null ? false : p.isFromExterns();\n   }\n \n   /**\n    * Gets the number of properties of this object.\n    */\n-  public abstract int getPropertiesCount();\n+  public int getPropertiesCount() {\n+    return getPropertyMap().getPropertiesCount();\n+  }\n \n   /**\n    * Returns a list of properties defined or inferred on this type and any of\n   /**\n    * Adds any properties defined on this type or its supertypes to the set.\n    */\n-  abstract void collectPropertyNames(Set<String> props);\n+  final void collectPropertyNames(Set<String> props) {\n+    getPropertyMap().collectPropertyNames(props);\n+  }\n \n   @Override\n   public <T> T visit(Visitor<T> visitor) {\n--- a/src/com/google/javascript/rhino/jstype/PropertyMap.java\n+++ b/src/com/google/javascript/rhino/jstype/PropertyMap.java\n \n import com.google.common.base.Function;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n  * @author nicksantos@google.com (Nick Santos)\n  */\n class PropertyMap implements Serializable {\n+  private static final long serialVersionUID = 1L;\n+\n+  private static final PropertyMap EMPTY_MAP = new PropertyMap(\n+      ImmutableMap.<String, Property>of());\n+\n   private static final Function<ObjectType, PropertyMap> PROP_MAP_FROM_TYPE =\n       new Function<ObjectType, PropertyMap>() {\n     @Override public PropertyMap apply(ObjectType t) {\n   private final Map<String, Property> properties;\n \n   PropertyMap() {\n-    this.properties = Maps.newTreeMap();\n+    this(Maps.<String, Property>newTreeMap());\n+  }\n+\n+  private PropertyMap(Map<String, Property> underlyingMap) {\n+    this.properties = underlyingMap;\n+  }\n+\n+  static PropertyMap immutableEmptyMap() {\n+    return EMPTY_MAP;\n   }\n \n   void setParentSource(ObjectType ownerType) {\n-    this.parentSource = ownerType;\n+    if (this != EMPTY_MAP) {\n+      this.parentSource = ownerType;\n+    }\n   }\n \n   /** Returns the direct parent of this property map. */\n   PropertyMap getPrimaryParent() {\n+    if (parentSource == null) {\n+      return null;\n+    }\n     ObjectType iProto = parentSource.getImplicitPrototype();\n     return iProto == null ? null : iProto.getPropertyMap();\n   }\n    * need multiple inheritance.\n    */\n   Iterable<PropertyMap> getSecondaryParents() {\n+    if (parentSource == null) {\n+      return ImmutableList.of();\n+    }\n     Iterable<ObjectType> extendedInterfaces =\n         parentSource.getCtorExtendedInterfaces();\n \n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n   }\n \n   @Override\n-  public Property getSlot(String name) {\n-    return properties.getSlot(name);\n-  }\n-\n-  /**\n-   * Gets the number of properties of this object.\n-   */\n-  @Override\n-  public int getPropertiesCount() {\n-    return properties.getPropertiesCount();\n-  }\n-\n-  @Override\n-  public boolean hasProperty(String propertyName) {\n-    // Unknown types have all properties.\n-    return isUnknownType() || getSlot(propertyName) != null;\n-  }\n-\n-  @Override\n-  public boolean hasOwnProperty(String propertyName) {\n-    return properties.hasOwnProperty(propertyName);\n-  }\n-\n-  @Override\n-  public Set<String> getOwnPropertyNames() {\n-    return properties.getOwnPropertyNames();\n-  }\n-\n-  @Override\n-  public boolean isPropertyTypeDeclared(String property) {\n-    StaticSlot<JSType> slot = getSlot(property);\n-    if (slot == null) {\n-      return false;\n-    }\n-    return !slot.isTypeInferred();\n-  }\n-\n-  @Override\n-  void collectPropertyNames(Set<String> props) {\n-    properties.collectPropertyNames(props);\n-  }\n-\n-  @Override\n-  public boolean isPropertyTypeInferred(String property) {\n-    StaticSlot<JSType> slot = getSlot(property);\n-    if (slot == null) {\n-      return false;\n-    }\n-    return slot.isTypeInferred();\n-  }\n-\n-  @Override\n-  public JSType getPropertyType(String property) {\n-    StaticSlot<JSType> slot = getSlot(property);\n-    if (slot == null) {\n-      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n-    }\n-    return slot.getType();\n-  }\n-\n-  @Override\n-  public boolean isPropertyInExterns(String propertyName) {\n-    Property p = getSlot(propertyName);\n-    if (p != null) {\n-      return p.isFromExterns();\n-    }\n-    return false;\n-  }\n-\n-  @Override\n   boolean defineProperty(String name, JSType type, boolean inferred,\n       Node propertyNode) {\n     if (hasOwnDeclaredProperty(name)) {\n   @Override\n   public boolean removeProperty(String name) {\n     return properties.removeProperty(name);\n-  }\n-\n-  @Override\n-  public Node getPropertyNode(String propertyName) {\n-    Property p = getSlot(propertyName);\n-    if (p != null) {\n-      return p.getNode();\n-    }\n-    return null;\n-  }\n-\n-  @Override\n-  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n-    Property p = properties.getOwnProperty(propertyName);\n-    if (p != null) {\n-      return p.getJSDocInfo();\n-    }\n-    return null;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n \n package com.google.javascript.rhino.jstype;\n \n-import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n \n import java.util.Collections;\n-import java.util.Set;\n \n /**\n  * An object type which uses composition to delegate all calls.\n   @Override\n   PropertyMap getPropertyMap() {\n     return referencedObjType == null\n-        ? null : referencedObjType.getPropertyMap();\n-  }\n-\n-  @Override\n-  public Property getSlot(String name) {\n-    if (referencedObjType != null) {\n-      return referencedObjType.getSlot(name);\n-    }\n-    return null;\n+        ? PropertyMap.immutableEmptyMap() : referencedObjType.getPropertyMap();\n   }\n \n   JSType getReferencedTypeInternal() {\n   }\n \n   @Override\n-  public boolean isPropertyTypeDeclared(String propertyName) {\n-    return referencedObjType == null ? false :\n-        referencedObjType.isPropertyTypeDeclared(propertyName);\n-  }\n-\n-  @Override\n-  public Node getPropertyNode(String propertyName) {\n-    return referencedObjType == null ? null :\n-        referencedObjType.getPropertyNode(propertyName);\n-  }\n-\n-  @Override\n-  public boolean isPropertyTypeInferred(String propertyName) {\n-    return referencedObjType == null ? false :\n-        referencedObjType.isPropertyTypeInferred(propertyName);\n-  }\n-\n-  @Override\n-  public boolean isPropertyInExterns(String propertyName) {\n-    return referencedObjType == null ? false :\n-        referencedObjType.isPropertyInExterns(propertyName);\n-  }\n-\n-  @Override\n-  public int getPropertiesCount() {\n-    return referencedObjType == null ? 0 :\n-        referencedObjType.getPropertiesCount();\n-  }\n-\n-  @Override\n-  protected void collectPropertyNames(Set<String> props) {\n-    if (referencedObjType != null) {\n-      referencedObjType.collectPropertyNames(props);\n-    }\n-  }\n-\n-  @Override\n   public JSType findPropertyType(String propertyName) {\n     return referencedType.findPropertyType(propertyName);\n-  }\n-\n-  @Override\n-  public JSType getPropertyType(String propertyName) {\n-    return referencedObjType == null ?\n-        getNativeType(JSTypeNative.UNKNOWN_TYPE) :\n-        referencedObjType.getPropertyType(propertyName);\n   }\n \n   @Override\n   }\n \n   @Override\n-  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n-    return referencedObjType == null ? null :\n-        referencedObjType.getOwnPropertyJSDocInfo(propertyName);\n-  }\n-\n-  @Override\n   public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n     if (referencedObjType != null) {\n       referencedObjType.setPropertyJSDocInfo(propertyName, info);\n   }\n \n   @Override\n-  public boolean hasProperty(String propertyName) {\n-    return referencedObjType == null ? false :\n-        referencedObjType.hasProperty(propertyName);\n-  }\n-\n-  @Override\n-  public boolean hasOwnProperty(String propertyName) {\n-    return referencedObjType == null ? false :\n-        referencedObjType.hasOwnProperty(propertyName);\n-  }\n-\n-  @Override\n-  public Set<String> getOwnPropertyNames() {\n-    return referencedObjType == null ? ImmutableSet.<String>of() :\n-        referencedObjType.getOwnPropertyNames();\n-  }\n-\n-  @Override\n   public FunctionType getConstructor() {\n     return referencedObjType == null ? null :\n         referencedObjType.getConstructor();\n--- a/src/com/google/javascript/rhino/jstype/UnknownType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnknownType.java\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.Node;\n \n-import java.util.Set;\n-\n /**\n  * The {@code Unknown} type.\n  */\n   UnknownType(JSTypeRegistry registry, boolean isChecked) {\n     super(registry);\n     this.isChecked = isChecked;\n-  }\n-\n-  @Override\n-  public Property getSlot(String name) {\n-    return null;\n   }\n \n   @Override\n   }\n \n   @Override\n-  public int getPropertiesCount() {\n-    return Integer.MAX_VALUE;\n-  }\n-\n-  @Override\n-  void collectPropertyNames(Set<String> props) {\n-  }\n-\n-  @Override\n-  public JSType getPropertyType(String propertyName) {\n-    return this;\n-  }\n-\n-  @Override\n-  public boolean hasProperty(String propertyName) {\n-    return true;\n-  }\n-\n-  @Override\n   public FunctionType getConstructor() {\n     return null;\n   }\n   }\n \n   @Override\n-  public boolean isPropertyTypeDeclared(String propertyName) {\n-    return false;\n-  }\n-\n-  @Override\n-  public boolean isPropertyTypeInferred(String propertyName) {\n-    return false;\n-  }\n-\n-  @Override\n   public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n     return BooleanLiteralSet.BOTH;\n   }\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n   protected JSType BOOLEAN_OBJECT_FUNCTION_TYPE;\n   protected ObjectType BOOLEAN_OBJECT_TYPE;\n   protected JSType BOOLEAN_TYPE;\n-  protected JSType CHECKED_UNKNOWN_TYPE;\n+  protected ObjectType CHECKED_UNKNOWN_TYPE;\n   protected JSType DATE_FUNCTION_TYPE;\n   protected ObjectType DATE_TYPE;\n   protected JSType ERROR_FUNCTION_TYPE;\n     BOOLEAN_TYPE =\n         registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);\n     CHECKED_UNKNOWN_TYPE =\n-        registry.getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n+        registry.getNativeObjectType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n     DATE_FUNCTION_TYPE =\n         registry.getNativeType(JSTypeNative.DATE_FUNCTION_TYPE);\n     DATE_TYPE =\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n \n     Asserts.assertResolvesToSame(UNKNOWN_TYPE);\n     assertFalse(UNKNOWN_TYPE.isNominalConstructor());\n+\n+    assertEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getPropertyType(\"abc\"));\n+  }\n+\n+  /**\n+   * Tests the behavior of the checked unknown type.\n+   */\n+  public void testCheckedUnknownType() throws Exception {\n+    // isPropertyType*\n+    assertPropertyTypeUnknown(CHECKED_UNKNOWN_TYPE, \"XXX\");\n+\n+    // toString\n+    assertEquals(\"??\", CHECKED_UNKNOWN_TYPE.toString());\n+    assertTrue(CHECKED_UNKNOWN_TYPE.hasDisplayName());\n+    assertEquals(\"Unknown\", CHECKED_UNKNOWN_TYPE.getDisplayName());\n+\n+    Asserts.assertResolvesToSame(CHECKED_UNKNOWN_TYPE);\n+    assertFalse(CHECKED_UNKNOWN_TYPE.isNominalConstructor());\n+\n+    assertEquals(CHECKED_UNKNOWN_TYPE,\n+        CHECKED_UNKNOWN_TYPE.getPropertyType(\"abc\"));\n   }\n \n   /**", "timestamp": 1355159276, "metainfo": ""}