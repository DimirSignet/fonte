{"sha": "c457c16118205e764d350d5947c0a5ae34083b74", "log": "Fixed formatting.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n \n /**\n  * <p>Operates on classes without using reflection.</p>\n- * <p/>\n- * <p>This class handles invalid <code>null</code> inputs as best it can. Each method documents its behaviour in more\n- * detail.</p>\n+ *\n+ * <p>This class handles invalid <code>null</code> inputs as best it can.\n+ * Each method documents its behaviour in more detail.</p>\n  *\n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @author Norm Deane\n  * @author Alban Peignier\n+ * @since 2.0\n  * @version $Id$\n- * @since 2.0\n  */\n-public class ClassUtils\n-{\n+public class ClassUtils {\n+\n     /**\n      * <p>The package separator character: <code>'&#x2e;' == {@value}</code>.</p>\n      */\n     public static final char PACKAGE_SEPARATOR_CHAR = '.';\n+\n     /**\n      * <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n      */\n-    public static final String PACKAGE_SEPARATOR = String.valueOf( PACKAGE_SEPARATOR_CHAR );\n+    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n+\n     /**\n      * <p>The inner class separator character: <code>'$' == {@value}</code>.</p>\n      */\n     public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n+\n     /**\n      * <p>The inner class separator String: <code>\"$\"</code>.</p>\n      */\n-    public static final String INNER_CLASS_SEPARATOR = String.valueOf( INNER_CLASS_SEPARATOR_CHAR );\n+    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);\n+\n     /**\n      * Maps primitive <code>Class</code>es to their corresponding wrapper <code>Class</code>.\n      */\n-    private static Map primitiveWrapperMap = new HashMap();\n-\n-    static\n-    {\n-        primitiveWrapperMap.put( Boolean.TYPE, Boolean.class );\n-        primitiveWrapperMap.put( Byte.TYPE, Byte.class );\n-        primitiveWrapperMap.put( Character.TYPE, Character.class );\n-        primitiveWrapperMap.put( Short.TYPE, Short.class );\n-        primitiveWrapperMap.put( Integer.TYPE, Integer.class );\n-        primitiveWrapperMap.put( Long.TYPE, Long.class );\n-        primitiveWrapperMap.put( Double.TYPE, Double.class );\n-        primitiveWrapperMap.put( Float.TYPE, Float.class );\n-        primitiveWrapperMap.put( Void.TYPE, Void.TYPE );\n+    private static Map  primitiveWrapperMap = new HashMap();\n+    static {\n+         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n+         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n+         primitiveWrapperMap.put(Character.TYPE, Character.class);\n+         primitiveWrapperMap.put(Short.TYPE, Short.class);\n+         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n+         primitiveWrapperMap.put(Long.TYPE, Long.class);\n+         primitiveWrapperMap.put(Double.TYPE, Double.class);\n+         primitiveWrapperMap.put(Float.TYPE, Float.class);\n+         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n     }\n \n     /**\n      * Maps a primitive class name to its corresponding abbreviation used in array class names.\n      */\n     private static Map abbreviationMap = new HashMap();\n-\n-    static\n-    {\n+    static {\n         abbreviationMap.put( \"int\", \"I\" );\n         abbreviationMap.put( \"boolean\", \"Z\" );\n         abbreviationMap.put( \"float\", \"F\" );\n     }\n \n     /**\n-     * <p>ClassUtils instances should NOT be constructed in standard programming. Instead, the class should be used as\n+     * <p>ClassUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n      * <code>ClassUtils.getShortClassName(cls)</code>.</p>\n-     * <p/>\n-     * <p>This constructor is public to permit tools that require a JavaBean instance to operate.</p>\n-     */\n-    public ClassUtils()\n-    {\n-        super();\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public ClassUtils() {\n+      super();\n     }\n \n     // Short class name\n     // ----------------------------------------------------------------------\n-\n     /**\n      * <p>Gets the class name minus the package name for an <code>Object</code>.</p>\n      *\n-     * @param object      the class to get the short name for, may be null\n-     * @param valueIfNull the value to return if null\n+     * @param object  the class to get the short name for, may be null\n+     * @param valueIfNull  the value to return if null\n      * @return the class name of the object without the package name, or the null value\n      */\n-    public static String getShortClassName( Object object, String valueIfNull )\n-    {\n-        if( object == null )\n-        {\n+    public static String getShortClassName(Object object, String valueIfNull) {\n+        if (object == null) {\n             return valueIfNull;\n         }\n-        return getShortClassName( object.getClass().getName() );\n+        return getShortClassName(object.getClass().getName());\n     }\n \n     /**\n      * <p>Gets the class name minus the package name from a <code>Class</code>.</p>\n      *\n-     * @param cls the class to get the short name for.\n+     * @param cls  the class to get the short name for.\n      * @return the class name without the package name or an empty string\n      */\n-    public static String getShortClassName( Class cls )\n-    {\n-        if( cls == null )\n-        {\n+    public static String getShortClassName(Class cls) {\n+        if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getShortClassName( cls.getName() );\n+        return getShortClassName(cls.getName());\n     }\n \n     /**\n      * <p>Gets the class name minus the package name from a String.</p>\n-     * <p/>\n+     *\n      * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n      *\n-     * @param className the className to get the short name for\n+     * @param className  the className to get the short name for\n      * @return the class name of the class without the package name or an empty string\n      */\n-    public static String getShortClassName( String className )\n-    {\n-        if( className == null )\n-        {\n+    public static String getShortClassName(String className) {\n+        if (className == null) {\n             return StringUtils.EMPTY;\n         }\n-        if( className.length() == 0 )\n-        {\n+        if (className.length() == 0) {\n             return StringUtils.EMPTY;\n         }\n         char[] chars = className.toCharArray();\n         int lastDot = 0;\n-        for( int i = 0; i < chars.length; i++ )\n-        {\n-            if( chars[i] == PACKAGE_SEPARATOR_CHAR )\n-            {\n+        for (int i = 0; i < chars.length; i++) {\n+            if (chars[i] == PACKAGE_SEPARATOR_CHAR) {\n                 lastDot = i + 1;\n-            }\n-            else if( chars[i] == INNER_CLASS_SEPARATOR_CHAR )\n-            {  // handle inner classes\n+            } else if (chars[i] == INNER_CLASS_SEPARATOR_CHAR) {  // handle inner classes\n                 chars[i] = PACKAGE_SEPARATOR_CHAR;\n             }\n         }\n-        return new String( chars, lastDot, chars.length - lastDot );\n+        return new String(chars, lastDot, chars.length - lastDot);\n     }\n \n     // Package name\n     // ----------------------------------------------------------------------\n-\n     /**\n      * <p>Gets the package name of an <code>Object</code>.</p>\n      *\n-     * @param object      the class to get the package name for, may be null\n-     * @param valueIfNull the value to return if null\n+     * @param object  the class to get the package name for, may be null\n+     * @param valueIfNull  the value to return if null\n      * @return the package name of the object, or the null value\n      */\n-    public static String getPackageName( Object object, String valueIfNull )\n-    {\n-        if( object == null )\n-        {\n+    public static String getPackageName(Object object, String valueIfNull) {\n+        if (object == null) {\n             return valueIfNull;\n         }\n-        return getPackageName( object.getClass().getName() );\n+        return getPackageName(object.getClass().getName());\n     }\n \n     /**\n      * <p>Gets the package name of a <code>Class</code>.</p>\n      *\n-     * @param cls the class to get the package name for, may be <code>null</code>.\n+     * @param cls  the class to get the package name for, may be <code>null</code>.\n      * @return the package name or an empty string\n      */\n-    public static String getPackageName( Class cls )\n-    {\n-        if( cls == null )\n-        {\n+    public static String getPackageName(Class cls) {\n+        if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getPackageName( cls.getName() );\n+        return getPackageName(cls.getName());\n     }\n \n     /**\n      * <p>Gets the package name from a <code>String</code>.</p>\n-     * <p/>\n-     * <p>The string passed in is assumed to be a class name - it is not checked.</p> <p>If the class is unpackaged,\n-     * return an empty string.</p>\n-     *\n-     * @param className the className to get the package name for, may be <code>null</code>\n+     *\n+     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n+     * <p>If the class is unpackaged, return an empty string.</p>\n+     *\n+     * @param className  the className to get the package name for, may be <code>null</code>\n      * @return the package name or an empty string\n      */\n-    public static String getPackageName( String className )\n-    {\n-        if( className == null )\n-        {\n+    public static String getPackageName(String className) {\n+        if (className == null) {\n             return StringUtils.EMPTY;\n         }\n-        int i = className.lastIndexOf( PACKAGE_SEPARATOR_CHAR );\n-        if( i == -1 )\n-        {\n+        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+        if (i == -1) {\n             return StringUtils.EMPTY;\n         }\n-        return className.substring( 0, i );\n+        return className.substring(0, i);\n     }\n \n     // Superclasses/Superinterfaces\n     // ----------------------------------------------------------------------\n-\n     /**\n      * <p>Gets a <code>List</code> of superclasses for the given class.</p>\n      *\n-     * @param cls the class to look up, may be <code>null</code>\n-     * @return the <code>List</code> of superclasses in order going up from this one <code>null</code> if null input\n-     */\n-    public static List getAllSuperclasses( Class cls )\n-    {\n-        if( cls == null )\n-        {\n+     * @param cls  the class to look up, may be <code>null</code>\n+     * @return the <code>List</code> of superclasses in order going up from this one\n+     *  <code>null</code> if null input\n+     */\n+    public static List getAllSuperclasses(Class cls) {\n+        if (cls == null) {\n             return null;\n         }\n         List classes = new ArrayList();\n         Class superclass = cls.getSuperclass();\n-        while( superclass != null )\n-        {\n-            classes.add( superclass );\n+        while (superclass != null) {\n+            classes.add(superclass);\n             superclass = superclass.getSuperclass();\n         }\n         return classes;\n     }\n \n     /**\n-     * <p>Gets a <code>List</code> of all interfaces implemented by the given class and its superclasses.</p>\n-     * <p/>\n-     * <p>The order is determined by looking through each interface in turn as declared in the source file and following\n-     * its hierarchy up. Then each superclass is considered in the same way. Later duplicates are ignored, so the order\n-     * is maintained.</p>\n-     *\n-     * @param cls the class to look up, may be <code>null</code>\n-     * @return the <code>List</code> of interfaces in order, <code>null</code> if null input\n-     */\n-    public static List getAllInterfaces( Class cls )\n-    {\n-        if( cls == null )\n-        {\n+     * <p>Gets a <code>List</code> of all interfaces implemented by the given\n+     * class and its superclasses.</p>\n+     *\n+     * <p>The order is determined by looking through each interface in turn as\n+     * declared in the source file and following its hierarchy up. Then each\n+     * superclass is considered in the same way. Later duplicates are ignored,\n+     * so the order is maintained.</p>\n+     *\n+     * @param cls  the class to look up, may be <code>null</code>\n+     * @return the <code>List</code> of interfaces in order,\n+     *  <code>null</code> if null input\n+     */\n+    public static List getAllInterfaces(Class cls) {\n+        if (cls == null) {\n             return null;\n         }\n         List list = new ArrayList();\n-        while( cls != null )\n-        {\n+        while (cls != null) {\n             Class[] interfaces = cls.getInterfaces();\n-            for( int i = 0; i < interfaces.length; i++ )\n-            {\n-                if( list.contains( interfaces[i] ) == false )\n-                {\n-                    list.add( interfaces[i] );\n+            for (int i = 0; i < interfaces.length; i++) {\n+                if (list.contains(interfaces[i]) == false) {\n+                    list.add(interfaces[i]);\n                 }\n-                List superInterfaces = getAllInterfaces( interfaces[i] );\n-                for( Iterator it = superInterfaces.iterator(); it.hasNext(); )\n-                {\n-                    Class intface = ( Class ) it.next();\n-                    if( list.contains( intface ) == false )\n-                    {\n-                        list.add( intface );\n+                List superInterfaces = getAllInterfaces(interfaces[i]);\n+                for (Iterator it = superInterfaces.iterator(); it.hasNext();) {\n+                    Class intface = (Class) it.next();\n+                    if (list.contains(intface) == false) {\n+                        list.add(intface);\n                     }\n                 }\n             }\n \n     // Convert list\n     // ----------------------------------------------------------------------\n-\n     /**\n      * <p>Given a <code>List</code> of class names, this method converts them into classes.</p>\n-     * <p/>\n-     * <p>A new <code>List</code> is returned. If the class name cannot be found, <code>null</code> is stored in the\n-     * <code>List</code>. If the class name in the <code>List</code> is <code>null</code>, <code>null</code> is stored\n-     * in the output <code>List</code>.</p>\n-     *\n-     * @param classNames the classNames to change\n-     * @return a <code>List</code> of Class objects corresponding to the class names, <code>null</code> if null input\n+     *\n+     * <p>A new <code>List</code> is returned. If the class name cannot be found, <code>null</code>\n+     * is stored in the <code>List</code>. If the class name in the <code>List</code> is\n+     * <code>null</code>, <code>null</code> is stored in the output <code>List</code>.</p>\n+     *\n+     * @param classNames  the classNames to change\n+     * @return a <code>List</code> of Class objects corresponding to the class names,\n+     *  <code>null</code> if null input\n      * @throws ClassCastException if classNames contains a non String entry\n      */\n-    public static List convertClassNamesToClasses( List classNames )\n-    {\n-        if( classNames == null )\n-        {\n+    public static List convertClassNamesToClasses(List classNames) {\n+        if (classNames == null) {\n             return null;\n         }\n-        List classes = new ArrayList( classNames.size() );\n-        for( Iterator it = classNames.iterator(); it.hasNext(); )\n-        {\n-            String className = ( String ) it.next();\n-            try\n-            {\n-                classes.add( Class.forName( className ) );\n-            }\n-            catch( Exception ex )\n-            {\n-                classes.add( null );\n+        List classes = new ArrayList(classNames.size());\n+        for (Iterator it = classNames.iterator(); it.hasNext();) {\n+            String className = (String) it.next();\n+            try {\n+                classes.add(Class.forName(className));\n+            } catch (Exception ex) {\n+                classes.add(null);\n             }\n         }\n         return classes;\n     }\n \n     /**\n-     * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts them into class names.</p>\n-     * <p/>\n-     * <p>A new <code>List</code> is returned. <code>null</code> objects will be copied into the returned list as\n-     * <code>null</code>.</p>\n-     *\n-     * @param classes the classes to change\n-     * @return a <code>List</code> of class names corresponding to the Class objects, <code>null</code> if null input\n+     * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts\n+     * them into class names.</p>\n+     *\n+     * <p>A new <code>List</code> is returned. <code>null</code> objects will be copied into\n+     * the returned list as <code>null</code>.</p>\n+     *\n+     * @param classes  the classes to change\n+     * @return a <code>List</code> of class names corresponding to the Class objects,\n+     *  <code>null</code> if null input\n      * @throws ClassCastException if <code>classes</code> contains a non-<code>Class</code> entry\n      */\n-    public static List convertClassesToClassNames( List classes )\n-    {\n-        if( classes == null )\n-        {\n+    public static List convertClassesToClassNames(List classes) {\n+        if (classes == null) {\n             return null;\n         }\n-        List classNames = new ArrayList( classes.size() );\n-        for( Iterator it = classes.iterator(); it.hasNext(); )\n-        {\n-            Class cls = ( Class ) it.next();\n-            if( cls == null )\n-            {\n-                classNames.add( null );\n-            }\n-            else\n-            {\n-                classNames.add( cls.getName() );\n+        List classNames = new ArrayList(classes.size());\n+        for (Iterator it = classes.iterator(); it.hasNext();) {\n+            Class cls = (Class) it.next();\n+            if (cls == null) {\n+                classNames.add(null);\n+            } else {\n+                classNames.add(cls.getName());\n             }\n         }\n         return classNames;\n \n     // Is assignable\n     // ----------------------------------------------------------------------\n-\n     /**\n      * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n-     * <p/>\n-     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in the input arrays. It\n-     * can be used to check if a set of arguments (the first parameter) are suitably compatible with a set of method\n-     * parameter types (the second parameter).</p>\n-     * <p/>\n-     * <p>Unlike the {@link Class#isAssignableFrom(Class)} method, this method takes into account widenings of primitive\n-     * classes and <code>null</code>s.</p>\n-     * <p/>\n-     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>, <code>float</code> or\n-     * <code>double</code>. This method returns the correct result for these cases.</p>\n-     * <p/>\n-     * <p><code>Null</code> may be assigned to any reference type. This method will return <code>true</code> if\n-     * <code>null</code> is passed in and the toClass is non-primitive.</p>\n-     * <p/>\n-     * <p>Specifically, this method tests whether the type represented by the specified <code>Class</code> parameter can\n-     * be converted to the type represented by this <code>Class</code> object via an identity conversion widening\n-     * primitive or widening reference conversion. See <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java\n-     * Language Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n-     *\n-     * @param classArray   the array of Classes to check, may be <code>null</code>\n-     * @param toClassArray the array of Classes to try to assign into, may be <code>null</code>\n+     *\n+     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n+     * Class pair in the input arrays. It can be used to check if a set of arguments\n+     * (the first parameter) are suitably compatible with a set of method parameter types\n+     * (the second parameter).</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n+     * method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,\n+     * <code>float</code> or <code>double</code>. This method returns the correct\n+     * result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method will\n+     * return <code>true</code> if <code>null</code> is passed in and the toClass is\n+     * non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param classArray  the array of Classes to check, may be <code>null</code>\n+     * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n      * @return <code>true</code> if assignment possible\n      */\n-    public static boolean isAssignable( Class[] classArray, Class[] toClassArray )\n-    {\n-        if( ArrayUtils.isSameLength( classArray, toClassArray ) == false )\n-        {\n+    public static boolean isAssignable(Class[] classArray, Class[] toClassArray) {\n+        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n             return false;\n         }\n-        if( classArray == null )\n-        {\n+        if (classArray == null) {\n             classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        if( toClassArray == null )\n-        {\n+        if (toClassArray == null) {\n             toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        for( int i = 0; i < classArray.length; i++ )\n-        {\n-            if( isAssignable( classArray[i], toClassArray[i] ) == false )\n-            {\n+        for (int i = 0; i < classArray.length; i++) {\n+            if (isAssignable(classArray[i], toClassArray[i]) == false) {\n                 return false;\n             }\n         }\n     }\n \n     /**\n-     * <p>Checks if one <code>Class</code> can be assigned to a variable of another <code>Class</code>.</p>\n-     * <p/>\n-     * <p>Unlike the {@link Class#isAssignableFrom(Class)} method, this method takes into account widenings of primitive\n-     * classes and <code>null</code>s.</p>\n-     * <p/>\n-     * <p>Primitive widenings allow an int to be assigned to a long, float or double. This method returns the correct\n-     * result for these cases.</p>\n-     * <p/>\n-     * <p><code>Null</code> may be assigned to any reference type. This method will return <code>true</code> if\n-     * <code>null</code> is passed in and the toClass is non-primitive.</p>\n-     * <p/>\n-     * <p>Specifically, this method tests whether the type represented by the specified <code>Class</code> parameter can\n-     * be converted to the type represented by this <code>Class</code> object via an identity conversion widening\n-     * primitive or widening reference conversion. See <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java\n-     * Language Specification</a></em>, sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n-     *\n-     * @param cls     the Class to check, may be null\n-     * @param toClass the Class to try to assign into, returns false if null\n+     * <p>Checks if one <code>Class</code> can be assigned to a variable of\n+     * another <code>Class</code>.</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,\n+     * this method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a long, float or\n+     * double. This method returns the correct result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method\n+     * will return <code>true</code> if <code>null</code> is passed in and the\n+     * toClass is non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param cls  the Class to check, may be null\n+     * @param toClass  the Class to try to assign into, returns false if null\n      * @return <code>true</code> if assignment possible\n      */\n-    public static boolean isAssignable( Class cls, Class toClass )\n-    {\n-        if( toClass == null )\n-        {\n+    public static boolean isAssignable(Class cls, Class toClass) {\n+        if (toClass == null) {\n             return false;\n         }\n         // have to check for null, as isAssignableFrom doesn't\n-        if( cls == null )\n-        {\n-            return !( toClass.isPrimitive() );\n-        }\n-        if( cls.equals( toClass ) )\n-        {\n+        if (cls == null) {\n+            return !(toClass.isPrimitive());\n+        }\n+        if (cls.equals(toClass)) {\n             return true;\n         }\n-        if( cls.isPrimitive() )\n-        {\n-            if( toClass.isPrimitive() == false )\n-            {\n+        if (cls.isPrimitive()) {\n+            if (toClass.isPrimitive() == false) {\n                 return false;\n             }\n-            if( Integer.TYPE.equals( cls ) )\n-            {\n-                return Long.TYPE.equals( toClass )\n-                       || Float.TYPE.equals( toClass )\n-                       || Double.TYPE.equals( toClass );\n-            }\n-            if( Long.TYPE.equals( cls ) )\n-            {\n-                return Float.TYPE.equals( toClass )\n-                       || Double.TYPE.equals( toClass );\n-            }\n-            if( Boolean.TYPE.equals( cls ) )\n-            {\n+            if (Integer.TYPE.equals(cls)) {\n+                return Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Long.TYPE.equals(cls)) {\n+                return Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Boolean.TYPE.equals(cls)) {\n                 return false;\n             }\n-            if( Double.TYPE.equals( cls ) )\n-            {\n+            if (Double.TYPE.equals(cls)) {\n                 return false;\n             }\n-            if( Float.TYPE.equals( cls ) )\n-            {\n-                return Double.TYPE.equals( toClass );\n-            }\n-            if( Character.TYPE.equals( cls ) )\n-            {\n-                return Integer.TYPE.equals( toClass )\n-                       || Long.TYPE.equals( toClass )\n-                       || Float.TYPE.equals( toClass )\n-                       || Double.TYPE.equals( toClass );\n-            }\n-            if( Short.TYPE.equals( cls ) )\n-            {\n-                return Integer.TYPE.equals( toClass )\n-                       || Long.TYPE.equals( toClass )\n-                       || Float.TYPE.equals( toClass )\n-                       || Double.TYPE.equals( toClass );\n-            }\n-            if( Byte.TYPE.equals( cls ) )\n-            {\n-                return Short.TYPE.equals( toClass )\n-                       || Integer.TYPE.equals( toClass )\n-                       || Long.TYPE.equals( toClass )\n-                       || Float.TYPE.equals( toClass )\n-                       || Double.TYPE.equals( toClass );\n+            if (Float.TYPE.equals(cls)) {\n+                return Double.TYPE.equals(toClass);\n+            }\n+            if (Character.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Short.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Byte.TYPE.equals(cls)) {\n+                return Short.TYPE.equals(toClass)\n+                    || Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n             }\n             // should never get here\n             return false;\n         }\n-        return toClass.isAssignableFrom( cls );\n-    }\n-\n-    /**\n-     * <p>Converts the specified primitive Class object to its corresponding wrapper Class object.</p>\n-     * <p/>\n-     * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>, returning <code>Void.TYPE</code>.</p>\n-     *\n-     * @param cls the class to convert, may be null\n-     * @return the wrapper class for <code>cls</code> or <code>cls</code> if <code>cls</code> is not a primitive.\n-     *         <code>null</code> if null input.\n+        return toClass.isAssignableFrom(cls);\n+    }\n+\n+    /**\n+     * <p>Converts the specified primitive Class object to its corresponding\n+     * wrapper Class object.</p>\n+     *\n+     * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,\n+     * returning <code>Void.TYPE</code>.</p>\n+     *\n+     * @param cls  the class to convert, may be null\n+     * @return the wrapper class for <code>cls</code> or <code>cls</code> if\n+     * <code>cls</code> is not a primitive. <code>null</code> if null input.\n      * @since 2.1\n      */\n-    public static Class primitiveToWrapper( Class cls )\n-    {\n+    public static Class primitiveToWrapper(Class cls) {\n         Class convertedClass = cls;\n-        if( cls != null && cls.isPrimitive() )\n-        {\n-            convertedClass = ( Class ) primitiveWrapperMap.get( cls );\n+        if (cls != null && cls.isPrimitive()) {\n+            convertedClass = (Class) primitiveWrapperMap.get(cls);\n         }\n         return convertedClass;\n     }\n \n     /**\n-     * <p>Converts the specified array of primitive Class objects to an array of its corresponding wrapper Class\n-     * objects.</p>\n-     *\n-     * @param classes the class array to convert, may be null or empty\n-     * @return an array which contains for each given class, the wrapper class or the original class if class is not a\n-     *         primitive. <code>null</code> if null input. Empty array if an empty array passed in.\n+     * <p>Converts the specified array of primitive Class objects to an array of\n+     * its corresponding wrapper Class objects.</p>\n+     *\n+     * @param classes  the class array to convert, may be null or empty\n+     * @return an array which contains for each given class, the wrapper class or\n+     * the original class if class is not a primitive. <code>null</code> if null input.\n+     * Empty array if an empty array passed in.\n      * @since 2.1\n      */\n-    public static Class[] primitivesToWrappers( Class[] classes )\n-    {\n-        if( classes == null )\n-        {\n+    public static Class[] primitivesToWrappers(Class[] classes) {\n+        if (classes == null) {\n             return null;\n         }\n-        if( classes.length == 0 )\n-        {\n+\n+        if (classes.length == 0) {\n             return classes;\n         }\n+\n         Class[] convertedClasses = new Class[classes.length];\n-        for( int i = 0; i < classes.length; i++ )\n-        {\n+        for (int i=0; i < classes.length; i++) {\n             convertedClasses[i] = primitiveToWrapper( classes[i] );\n         }\n         return convertedClasses;\n \n     // Inner class\n     // ----------------------------------------------------------------------\n-\n     /**\n      * <p>Is the specified class an inner class or static nested class.</p>\n      *\n-     * @param cls the class to check, may be null\n-     * @return <code>true</code> if the class is an inner or static nested class, false if not or <code>null</code>\n-     */\n-    public static boolean isInnerClass( Class cls )\n-    {\n-        if( cls == null )\n-        {\n+     * @param cls  the class to check, may be null\n+     * @return <code>true</code> if the class is an inner or static nested class,\n+     *  false if not or <code>null</code>\n+     */\n+    public static boolean isInnerClass(Class cls) {\n+        if (cls == null) {\n             return false;\n         }\n-        return cls.getName().indexOf( INNER_CLASS_SEPARATOR_CHAR ) >= 0;\n+        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n     }\n \n     /**\n      * @throws ClassNotFoundException if the class is not found\n      */\n     public static Class getClass( ClassLoader classLoader, String className, boolean initialize )\n-            throws ClassNotFoundException\n-    {\n+            throws ClassNotFoundException {\n         Class clazz;\n-        if( abbreviationMap.containsKey( className ) )\n-        {\n+        if( abbreviationMap.containsKey( className ) ) {\n             clazz = Class.forName( \"[\" + abbreviationMap.get( className ), initialize, classLoader ).getComponentType();\n         }\n-        else\n-        {\n+        else {\n             clazz = Class.forName( toProperClassName( className ), initialize, classLoader );\n         }\n         return clazz;\n      * @return the class represented by <code>className</code> using the <code>classLoader</code>\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class getClass( ClassLoader classLoader, String className ) throws ClassNotFoundException\n-    {\n+    public static Class getClass( ClassLoader classLoader, String className ) throws ClassNotFoundException {\n         return getClass( classLoader, className, true );\n     }\n \n      * @return the class represented by <code>className</code> using the current thread's context class loader\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class getClass( String className ) throws ClassNotFoundException\n-    {\n+    public static Class getClass( String className ) throws ClassNotFoundException {\n         return getClass( Thread.currentThread().getContextClassLoader() == null ? ClassUtils.class.getClassLoader() :\n                          Thread.currentThread().getContextClassLoader(), className, true );\n     }\n      * @return the class represented by <code>className</code> using the current thread's context class loader\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class getClass( String className, boolean initialize ) throws ClassNotFoundException\n-    {\n+    public static Class getClass( String className, boolean initialize ) throws ClassNotFoundException {\n         return getClass( Thread.currentThread().getContextClassLoader() == null ? ClassUtils.class.getClassLoader() :\n                          Thread.currentThread().getContextClassLoader(), className, initialize );\n     }\n \n-    private static String toProperClassName( String className )\n-    {\n+    private static String toProperClassName( String className ) {\n         className = StringUtils.deleteWhitespace( className );\n-        if( className == null )\n-        {\n+        if( className == null ) {\n             throw new NullArgumentException( \"className\" );\n         }\n-        else if( className.endsWith( \"[]\" ) )\n-        {\n+        else if( className.endsWith( \"[]\" ) ) {\n             final StringBuffer classNameBuffer = new StringBuffer();\n-            while( className.endsWith( \"[]\" ) )\n-            {\n+            while( className.endsWith( \"[]\" ) ) {\n                 className = className.substring( 0, className.length() - 2 );\n                 classNameBuffer.append( \"[\" );\n             }\n             final String abbreviation = ( String ) abbreviationMap.get( className );\n-            if( abbreviation != null )\n-            {\n+            if( abbreviation != null ) {\n                 classNameBuffer.append( abbreviation );\n             }\n-            else\n-            {\n+            else {\n                 classNameBuffer.append( \"L\" ).append( className ).append( \";\" );\n             }\n             className = classNameBuffer.toString();", "timestamp": 1134959458, "metainfo": ""}