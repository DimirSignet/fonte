{"sha": "a2447673d9ca590a3ed967e7a30b1f9cd18e78d1", "log": "Committing a rewrite of StringEscapeUtils guts - LANG-505. Entities.java can now go away. Most of the code is in the new text.translate package. More work is needed, including what to actually define as 'ESCAPE_XML' etc, but it's now easy for someone to look at the source to EscapeUtils and UnescapeUtils and put their own ESCAPE_XML variable together, and with lots of reuse value.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n package org.apache.commons.lang;\n \n import java.io.IOException;\n-import java.io.StringWriter;\n import java.io.Writer;\n-import java.util.Locale;\n+\n+import org.apache.commons.lang.text.translate.EscapeUtils;\n+import org.apache.commons.lang.text.translate.UnescapeUtils;\n \n /**\n  * <p>Escapes and unescapes <code>String</code>s for\n  */\n public class StringEscapeUtils {\n \n-    private static final char CSV_DELIMITER = ',';\n-    private static final char CSV_QUOTE = '\"';\n-    private static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\n-    private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n-\n     /**\n      * <p><code>StringEscapeUtils</code> instances should NOT be constructed in\n      * standard programming.</p>\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n-        return escapeJavaStyleString(str, false, false);\n+        return EscapeUtils.ESCAPE_JAVA.translate(str);\n     }\n \n     /**\n      * @throws IOException if error occurs on underlying Writer\n      */\n     public static void escapeJava(Writer out, String str) throws IOException {\n-        escapeJavaStyleString(out, str, false, false);\n+        EscapeUtils.ESCAPE_JAVA.translate(str, out);\n     }\n \n     /**\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n-        return escapeJavaStyleString(str, true, true);\n+        return EscapeUtils.ESCAPE_ECMASCRIPT.translate(str);\n     }\n \n     /**\n      * @throws IOException if error occurs on underlying Writer\n      **/\n     public static void escapeJavaScript(Writer out, String str) throws IOException {\n-        escapeJavaStyleString(out, str, true, true);\n-    }\n-\n-    /**\n-     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n-     * \n-     * @param str String to escape values in, may be null\n-     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n-     * @param escapeForwardSlash TODO\n-     * @return the escaped string\n-     */\n-    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {\n-        if (str == null) {\n-            return null;\n-        }\n-        try {\n-            StringWriter writer = new StringWriter(str.length() * 2);\n-            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);\n-            return writer.toString();\n-        } catch (IOException ioe) {\n-            // this should never ever happen while writing to a StringWriter\n-            throw new UnhandledException(ioe);\n-        }\n-    }\n-\n-    /**\n-     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n-     * \n-     * @param out write to receieve the escaped string\n-     * @param str String to escape values in, may be null\n-     * @param escapeSingleQuote escapes single quotes if <code>true</code>\n-     * @param escapeForwardSlash TODO\n-     * @throws IOException if an IOException occurs\n-     */\n-    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n-            boolean escapeForwardSlash) throws IOException {\n-        if (out == null) {\n-            throw new IllegalArgumentException(\"The Writer must not be null\");\n-        }\n-        if (str == null) {\n-            return;\n-        }\n-        int sz;\n-        sz = str.length();\n-        for (int i = 0; i < sz; i++) {\n-            char ch = str.charAt(i);\n-\n-            // handle unicode\n-            if (ch > 0xfff) {\n-                out.write(\"\\\\u\" + hex(ch));\n-            } else if (ch > 0xff) {\n-                out.write(\"\\\\u0\" + hex(ch));\n-            } else if (ch > 0x7f) {\n-                out.write(\"\\\\u00\" + hex(ch));\n-            } else if (ch < 32) {\n-                switch (ch) {\n-                    case '\\b' :\n-                        out.write('\\\\');\n-                        out.write('b');\n-                        break;\n-                    case '\\n' :\n-                        out.write('\\\\');\n-                        out.write('n');\n-                        break;\n-                    case '\\t' :\n-                        out.write('\\\\');\n-                        out.write('t');\n-                        break;\n-                    case '\\f' :\n-                        out.write('\\\\');\n-                        out.write('f');\n-                        break;\n-                    case '\\r' :\n-                        out.write('\\\\');\n-                        out.write('r');\n-                        break;\n-                    default :\n-                        if (ch > 0xf) {\n-                            out.write(\"\\\\u00\" + hex(ch));\n-                        } else {\n-                            out.write(\"\\\\u000\" + hex(ch));\n-                        }\n-                        break;\n-                }\n-            } else {\n-                switch (ch) {\n-                    case '\\'' :\n-                        if (escapeSingleQuote) {\n-                            out.write('\\\\');\n-                        }\n-                        out.write('\\'');\n-                        break;\n-                    case '\"' :\n-                        out.write('\\\\');\n-                        out.write('\"');\n-                        break;\n-                    case '\\\\' :\n-                        out.write('\\\\');\n-                        out.write('\\\\');\n-                        break;\n-                    case '/' :\n-                        if (escapeForwardSlash) {\n-                            out.write('\\\\');\n-                        }\n-                        out.write('/');\n-                        break;\n-                    default :\n-                        out.write(ch);\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * <p>Returns an upper case hexadecimal <code>String</code> for the given\n-     * character.</p>\n-     * \n-     * @param ch The character to convert.\n-     * @return An upper case hexadecimal <code>String</code>\n-     */\n-    private static String hex(char ch) {\n-        return Integer.toHexString(ch).toUpperCase(Locale.ENGLISH);\n+        EscapeUtils.ESCAPE_ECMASCRIPT.translate(str, out);\n     }\n \n     /**\n      * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n      */\n     public static String unescapeJava(String str) {\n-        if (str == null) {\n-            return null;\n-        }\n-        try {\n-            StringWriter writer = new StringWriter(str.length());\n-            unescapeJava(writer, str);\n-            return writer.toString();\n-        } catch (IOException ioe) {\n-            // this should never ever happen while writing to a StringWriter\n-            throw new UnhandledException(ioe);\n-        }\n+        return UnescapeUtils.UNESCAPE_JAVA.translate(str);\n     }\n \n     /**\n      * @throws IOException if error occurs on underlying Writer\n      */\n     public static void unescapeJava(Writer out, String str) throws IOException {\n-        if (out == null) {\n-            throw new IllegalArgumentException(\"The Writer must not be null\");\n-        }\n-        if (str == null) {\n-            return;\n-        }\n-        int sz = str.length();\n-        StringBuffer unicode = new StringBuffer(4);\n-        boolean hadSlash = false;\n-        boolean inUnicode = false;\n-        for (int i = 0; i < sz; i++) {\n-            char ch = str.charAt(i);\n-            if (inUnicode) {\n-                // if in unicode, then we're reading unicode\n-                // values in somehow\n-                unicode.append(ch);\n-                if (unicode.length() == 4) {\n-                    // unicode now contains the four hex digits\n-                    // which represents our unicode character\n-                    try {\n-                        int value = Integer.parseInt(unicode.toString(), 16);\n-                        out.write((char) value);\n-                        unicode.setLength(0);\n-                        inUnicode = false;\n-                        hadSlash = false;\n-                    } catch (NumberFormatException nfe) {\n-                        throw new UnhandledException(\"Unable to parse unicode value: \" + unicode, nfe);\n-                    }\n-                }\n-                continue;\n-            }\n-            if (hadSlash) {\n-                // handle an escaped value\n-                hadSlash = false;\n-                switch (ch) {\n-                    case '\\\\':\n-                        out.write('\\\\');\n-                        break;\n-                    case '\\'':\n-                        out.write('\\'');\n-                        break;\n-                    case '\\\"':\n-                        out.write('\"');\n-                        break;\n-                    case 'r':\n-                        out.write('\\r');\n-                        break;\n-                    case 'f':\n-                        out.write('\\f');\n-                        break;\n-                    case 't':\n-                        out.write('\\t');\n-                        break;\n-                    case 'n':\n-                        out.write('\\n');\n-                        break;\n-                    case 'b':\n-                        out.write('\\b');\n-                        break;\n-                    case 'u':\n-                        {\n-                            // uh-oh, we're in unicode country....\n-                            inUnicode = true;\n-                            break;\n-                        }\n-                    default :\n-                        out.write(ch);\n-                        break;\n-                }\n-                continue;\n-            } else if (ch == '\\\\') {\n-                hadSlash = true;\n-                continue;\n-            }\n-            out.write(ch);\n-        }\n-        if (hadSlash) {\n-            // then we're in the weird case of a \\ at the end of the\n-            // string, let's output it anyway.\n-            out.write('\\\\');\n-        }\n+        UnescapeUtils.UNESCAPE_JAVA.translate(str, out);\n     }\n \n     /**\n      * @return A new unescaped <code>String</code>, <code>null</code> if null string input\n      */\n     public static String unescapeJavaScript(String str) {\n-        return unescapeJava(str);\n+        return UnescapeUtils.UNESCAPE_ECMASCRIPT.translate(str);\n     }\n \n     /**\n      * @throws IOException if error occurs on underlying Writer\n      */\n     public static void unescapeJavaScript(Writer out, String str) throws IOException {\n-        unescapeJava(out, str);\n+        UnescapeUtils.UNESCAPE_ECMASCRIPT.translate(str, out);\n     }\n \n     // HTML and XML\n      * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n      */\n     public static String escapeHtml(String str) {\n-        if (str == null) {\n-            return null;\n-        }\n-        try {\n-            StringWriter writer = new StringWriter ((int)(str.length() * 1.5));\n-            escapeHtml(writer, str);\n-            return writer.toString();\n-        } catch (IOException ioe) {\n-            //should be impossible\n-            throw new UnhandledException(ioe);\n-        }\n+        return EscapeUtils.ESCAPE_HTML4.translate(str);\n     }\n \n     /**\n      * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n      */\n     public static void escapeHtml(Writer writer, String string) throws IOException {\n-        if (writer == null ) {\n-            throw new IllegalArgumentException (\"The Writer must not be null.\");\n-        }\n-        if (string == null) {\n-            return;\n-        }\n-        Entities.HTML40.escape(writer, string);\n+        EscapeUtils.ESCAPE_HTML4.translate(string, writer);\n     }\n \n     //-----------------------------------------------------------------------\n      * @see #escapeHtml(Writer, String)\n      */\n     public static String unescapeHtml(String str) {\n-        if (str == null) {\n-            return null;\n-        }\n-        try {\n-            StringWriter writer = new StringWriter ((int)(str.length() * 1.5));\n-            unescapeHtml(writer, str);\n-            return writer.toString();\n-        } catch (IOException ioe) {\n-            //should be impossible\n-            throw new UnhandledException(ioe);\n-        }\n+        return UnescapeUtils.UNESCAPE_HTML4.translate(str);\n     }\n \n     /**\n      * @see #escapeHtml(String)\n      */\n     public static void unescapeHtml(Writer writer, String string) throws IOException {\n-        if (writer == null ) {\n-            throw new IllegalArgumentException (\"The Writer must not be null.\");\n-        }\n-        if (string == null) {\n-            return;\n-        }\n-        Entities.HTML40.unescape(writer, string);\n+        UnescapeUtils.UNESCAPE_HTML4.translate(string, writer);\n     }\n \n     //-----------------------------------------------------------------------\n      * @see #unescapeXml(java.lang.String)\n      */\n     public static void escapeXml(Writer writer, String str) throws IOException {\n-        if (writer == null ) {\n-            throw new IllegalArgumentException (\"The Writer must not be null.\");\n-        }\n-        if (str == null) {\n-            return;\n-        }\n-        Entities.XML.escape(writer, str);\n+        EscapeUtils.ESCAPE_XML.translate(str, writer);\n     }\n \n     /**\n      * @see #unescapeXml(java.lang.String)\n      */\n     public static String escapeXml(String str) {\n-        if (str == null) {\n-            return null;\n-        }\n-        return Entities.XML.escape(str);\n+        return EscapeUtils.ESCAPE_XML.translate(str);\n     }\n \n     //-----------------------------------------------------------------------\n      * @see #escapeXml(String)\n      */\n     public static void unescapeXml(Writer writer, String str) throws IOException {\n-        if (writer == null ) {\n-            throw new IllegalArgumentException (\"The Writer must not be null.\");\n-        }\n-        if (str == null) {\n-            return;\n-        }\n-        Entities.XML.unescape(writer, str);\n+        UnescapeUtils.UNESCAPE_XML.translate(str, writer);\n     }\n \n     /**\n      * @see #escapeXml(String)\n      */\n     public static String unescapeXml(String str) {\n-        if (str == null) {\n-            return null;\n-        }\n-        return Entities.XML.unescape(str);\n+        return UnescapeUtils.UNESCAPE_XML.translate(str);\n     }\n \n     //-----------------------------------------------------------------------\n      * @since 2.4\n      */\n     public static String escapeCsv(String str) {\n-        if (StringUtils.containsNone(str, CSV_SEARCH_CHARS)) {\n-            return str;\n-        }\n-        try {\n-            StringWriter writer = new StringWriter();\n-            escapeCsv(writer, str);\n-            return writer.toString();\n-        } catch (IOException ioe) {\n-            // this should never ever happen while writing to a StringWriter\n-            throw new UnhandledException(ioe);\n-        }\n+        return EscapeUtils.ESCAPE_CSV.translate(str);\n     }\n \n     /**\n      * @since 2.4\n      */\n     public static void escapeCsv(Writer out, String str) throws IOException {\n-        if (StringUtils.containsNone(str, CSV_SEARCH_CHARS)) {\n-            if (str != null) {\n-                out.write(str);\n-            }\n-            return;\n-        }\n-        out.write(CSV_QUOTE);\n-        for (int i = 0; i < str.length(); i++) {\n-            char c = str.charAt(i);\n-            if (c == CSV_QUOTE) {\n-                out.write(CSV_QUOTE); // escape double quote\n-            }\n-            out.write(c);\n-        }\n-        out.write(CSV_QUOTE);\n+        EscapeUtils.ESCAPE_CSV.translate(str, out);\n     }\n \n     /**\n      * @since 2.4\n      */\n     public static String unescapeCsv(String str) {\n-        if (str == null) {\n-            return null;\n-        }\n-        try {\n-            StringWriter writer = new StringWriter();\n-            unescapeCsv(writer, str);\n-            return writer.toString();\n-        } catch (IOException ioe) {\n-            // this should never ever happen while writing to a StringWriter\n-            throw new UnhandledException(ioe);\n-        }\n+        return UnescapeUtils.UNESCAPE_CSV.translate(str);\n     }\n \n     /**\n      * @since 2.4\n      */\n     public static void unescapeCsv(Writer out, String str) throws IOException {\n-        if (str == null) {\n-            return;\n-        }\n-        if (str.length() < 2) {\n-            out.write(str);\n-            return;\n-        }\n-        if ( str.charAt(0) != CSV_QUOTE || str.charAt(str.length() - 1) != CSV_QUOTE ) {\n-            out.write(str);\n-            return;\n-        }\n-\n-        // strip quotes\n-        String quoteless = str.substring(1, str.length() - 1);\n-\n-        if ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n-            // deal with escaped quotes; ie) \"\"\n-            str = StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR);\n-        }\n-\n-        out.write(str);\n+        UnescapeUtils.UNESCAPE_CSV.translate(str, out);\n     }\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/AggregateTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Executes a sequence of translators one after the other. Execution ends whenever \n+ * the first translator consumes codepoints from the input. \n+ * @since 3.0\n+ */\n+public class AggregateTranslator extends CharSequenceTranslator {\n+\n+    private CharSequenceTranslator[] translators;\n+\n+    /**\n+     * Specify the translators to be used at creation time. \n+     */\n+    public AggregateTranslator(CharSequenceTranslator... translators) {\n+        this.translators = translators;\n+    }\n+\n+    /**\n+     * The first translator to consume codepoints from the input is the 'winner'. \n+     * Execution stops with the number of consumed codepoints being returned. \n+     * {@inheritDoc}\n+     */\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        for (CharSequenceTranslator translator : translators) {\n+            int consumed = translator.translate(input, index, out);\n+            if(consumed != 0) {\n+                return consumed;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/CharSequenceTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.io.StringWriter;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang.UnhandledException;\n+\n+/**\n+ * An API for translating text. \n+ * Its core use is to escape and unescape text. Because escaping and unescaping \n+ * is completely contextual, the API does not present two separate signatures. \n+ * @since 3.0\n+ */\n+public abstract class CharSequenceTranslator {\n+\n+    /**\n+     * Translate a set of codepoints, represented by an int index into a CharSequence, \n+     * into another set of codepoints. The number of codepoints consumed must be returned, \n+     * and the only IOExceptions thrown must be from interacting with the Writer so that \n+     * the top level API may reliable ignore StringWriter IOExceptions. \n+     *\n+     * @param input CharSequence that is being translated\n+     * @param index int representing the current point of translation\n+     * @param out Writer to translate the text to\n+     * @return int count of codepoints consumed\n+     */\n+    public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n+\n+    /**\n+     * Helper for non-Writer usage. \n+     * @param input CharSequence to be translated\n+     * @return String output of translation\n+     */\n+    public final String translate(CharSequence input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        try {\n+            StringWriter writer = new StringWriter(input.length() * 2);  // TODO: Make the 2 part of the API???\n+            translate(input, writer);\n+            return writer.toString();\n+        } catch (IOException ioe) {\n+            // this should never ever happen while writing to a StringWriter\n+            throw new UnhandledException(ioe);\n+        }\n+    }\n+\n+    // TODO: Point to CsvEscaper as a way to 'override'?\n+    /**\n+     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n+     * tightly coupled with the abstract method of this class. \n+     *\n+     * @param input CharSequence that is being translated\n+     * @param out Writer to translate the text to\n+     * @throws IOException if and only if the Writer produces an IOException\n+     */\n+    public final void translate(CharSequence input, Writer out) throws IOException {\n+        if (out == null) {\n+            throw new IllegalArgumentException(\"The Writer must not be null\");\n+        }\n+        if (input == null) {\n+            return;\n+        }\n+        int sz = Character.codePointCount(input, 0, input.length());\n+        for (int i = 0; i < sz; i++) {\n+\n+            // consumed is the number of codepoints consumed\n+            int consumed = translate(input, i, out);\n+\n+            if(consumed == 0) { \n+                out.write( Character.toChars( Character.codePointAt(input, i) ) );\n+            } else {\n+                // contract with translators is that they have to understand codepoints and they just took care of a surrogate pair\n+                for(int j=0; j<consumed; j++) {\n+                    if(i < sz - 2) {\n+                        i += Character.charCount( Character.codePointAt(input, i) );\n+                    } else {\n+                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things\n+                        i++;\n+                    }\n+                }\n+                // for loop will increment 1 anyway, so remove 1 to account for that\n+                i--;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns an upper case hexadecimal <code>String</code> for the given\n+     * character.</p>\n+     *\n+     * @param codepoint The codepoint to convert.\n+     * @return An upper case hexadecimal <code>String</code>\n+     */\n+    public static String hex(int codepoint) {\n+        return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/CodePointTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Helper subclass to CharSequenceTranslator to allow for translations that \n+ * will replace up to one character at a time.\n+ * @since 3.0\n+ */\n+public abstract class CodePointTranslator extends CharSequenceTranslator {\n+\n+    /**\n+     * Implementation of translate that maps onto the abstract translate(int, Writer) method. \n+     * {@inheritDoc}\n+     */\n+    public final int translate(CharSequence input, int index, Writer out) throws IOException {\n+        int codepoint = Character.codePointAt(input, index);\n+        boolean consumed = translate(codepoint, out);\n+        if(consumed) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Translate the specified codepoint into another. \n+     * \n+     * @param codepoint int character input to translate\n+     * @param out Writer to optionally push the translated output to\n+     * @return boolean as to whether translation occurred or not\n+     */\n+    public abstract boolean translate(int codepoint, Writer out) throws IOException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/EntityArrays.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+/**\n+ * Package private class holding varius entity data for HTML and XML.\n+ * All arrays are of length [*][2].\n+ *\n+ * @since 3.0\n+ */\n+class EntityArrays {\n+\n+    static final String[][] ISO8859_1_ESCAPE = {\n+        {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n+        {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark\n+        {\"\\u00A2\", \"&cent;\"}, // cent sign\n+        {\"\\u00A3\", \"&pound;\"}, // pound sign\n+        {\"\\u00A4\", \"&curren;\"}, // currency sign\n+        {\"\\u00A5\", \"&yen;\"}, // yen sign = yuan sign\n+        {\"\\u00A6\", \"&brvbar;\"}, // broken bar = broken vertical bar\n+        {\"\\u00A7\", \"&sect;\"}, // section sign\n+        {\"\\u00A8\", \"&uml;\"}, // diaeresis = spacing diaeresis\n+        {\"\\u00A9\", \"&copy;\"}, //  - copyright sign\n+        {\"\\u00AA\", \"&ordf;\"}, // feminine ordinal indicator\n+        {\"\\u00AB\", \"&laquo;\"}, // left-pointing double angle quotation mark = left pointing guillemet\n+        {\"\\u00AC\", \"&not;\"}, // not sign\n+        {\"\\u00AD\", \"&shy;\"}, // soft hyphen = discretionary hyphen\n+        {\"\\u00AE\", \"&reg;\"}, //  - registered trademark sign\n+        {\"\\u00AF\", \"&macr;\"}, // macron = spacing macron = overline = APL overbar\n+        {\"\\u00B0\", \"&deg;\"}, // degree sign\n+        {\"\\u00B1\", \"&plusmn;\"}, // plus-minus sign = plus-or-minus sign\n+        {\"\\u00B2\", \"&sup2;\"}, // superscript two = superscript digit two = squared\n+        {\"\\u00B3\", \"&sup3;\"}, // superscript three = superscript digit three = cubed\n+        {\"\\u00B4\", \"&acute;\"}, // acute accent = spacing acute\n+        {\"\\u00B5\", \"&micro;\"}, // micro sign\n+        {\"\\u00B6\", \"&para;\"}, // pilcrow sign = paragraph sign\n+        {\"\\u00B7\", \"&middot;\"}, // middle dot = Georgian comma = Greek middle dot\n+        {\"\\u00B8\", \"&cedil;\"}, // cedilla = spacing cedilla\n+        {\"\\u00B9\", \"&sup1;\"}, // superscript one = superscript digit one\n+        {\"\\u00BA\", \"&ordm;\"}, // masculine ordinal indicator\n+        {\"\\u00BB\", \"&raquo;\"}, // right-pointing double angle quotation mark = right pointing guillemet\n+        {\"\\u00BC\", \"&frac14;\"}, // vulgar fraction one quarter = fraction one quarter\n+        {\"\\u00BD\", \"&frac12;\"}, // vulgar fraction one half = fraction one half\n+        {\"\\u00BE\", \"&frac34;\"}, // vulgar fraction three quarters = fraction three quarters\n+        {\"\\u00BF\", \"&iquest;\"}, // inverted question mark = turned question mark\n+        {\"\\u00C0\", \"&Agrave;\"}, //  - uppercase A, grave accent\n+        {\"\\u00C1\", \"&Aacute;\"}, //  - uppercase A, acute accent\n+        {\"\\u00C2\", \"&Acirc;\"}, //  - uppercase A, circumflex accent\n+        {\"\\u00C3\", \"&Atilde;\"}, //  - uppercase A, tilde\n+        {\"\\u00C4\", \"&Auml;\"}, //  - uppercase A, umlaut\n+        {\"\\u00C5\", \"&Aring;\"}, //  - uppercase A, ring\n+        {\"\\u00C6\", \"&AElig;\"}, //  - uppercase AE\n+        {\"\\u00C7\", \"&Ccedil;\"}, //  - uppercase C, cedilla\n+        {\"\\u00C8\", \"&Egrave;\"}, //  - uppercase E, grave accent\n+        {\"\\u00C9\", \"&Eacute;\"}, //  - uppercase E, acute accent\n+        {\"\\u00CB\", \"&Ecirc;\"}, //  - uppercase E, circumflex accent\n+        {\"\\u00CC\", \"&Euml;\"}, //  - uppercase E, umlaut\n+        {\"\\u00CD\", \"&Igrave;\"}, //  - uppercase I, grave accent\n+        {\"\\u00CE\", \"&Iacute;\"}, //  - uppercase I, acute accent\n+        {\"\\u00CF\", \"&Icirc;\"}, //  - uppercase I, circumflex accent\n+        {\"\\u00D0\", \"&Iuml;\"}, //  - uppercase I, umlaut\n+        {\"\\u00D1\", \"&ETH;\"}, //  - uppercase Eth, Icelandic\n+        {\"\\u00D2\", \"&Ntilde;\"}, //  - uppercase N, tilde\n+        {\"\\u00D3\", \"&Ograve;\"}, //  - uppercase O, grave accent\n+        {\"\\u00D4\", \"&Oacute;\"}, //  - uppercase O, acute accent\n+        {\"\\u00D5\", \"&Ocirc;\"}, //  - uppercase O, circumflex accent\n+        {\"\\u00D6\", \"&Otilde;\"}, //  - uppercase O, tilde\n+        {\"\\u00D7\", \"&Ouml;\"}, //  - uppercase O, umlaut\n+        {\"\\u00D8\", \"&times;\"}, // multiplication sign\n+        {\"\\u00D9\", \"&Oslash;\"}, //  - uppercase O, slash\n+        {\"\\u00DA\", \"&Ugrave;\"}, //  - uppercase U, grave accent\n+        {\"\\u00DB\", \"&Uacute;\"}, //  - uppercase U, acute accent\n+        {\"\\u00DC\", \"&Ucirc;\"}, //  - uppercase U, circumflex accent\n+        {\"\\u00DD\", \"&Uuml;\"}, //  - uppercase U, umlaut\n+        {\"\\u00DE\", \"&Yacute;\"}, //  - uppercase Y, acute accent\n+        {\"\\u00DF\", \"&THORN;\"}, //  - uppercase THORN, Icelandic\n+        {\"\\u00E0\", \"&szlig;\"}, //  - lowercase sharps, German\n+        {\"\\u00E1\", \"&agrave;\"}, //  - lowercase a, grave accent\n+        {\"\\u00E2\", \"&aacute;\"}, //  - lowercase a, acute accent\n+        {\"\\u00E3\", \"&acirc;\"}, //  - lowercase a, circumflex accent\n+        {\"\\u00E4\", \"&atilde;\"}, //  - lowercase a, tilde\n+        {\"\\u00E5\", \"&auml;\"}, //  - lowercase a, umlaut\n+        {\"\\u00E5\", \"&aring;\"}, //  - lowercase a, ring\n+        {\"\\u00E6\", \"&aelig;\"}, //  - lowercase ae\n+        {\"\\u00E7\", \"&ccedil;\"}, //  - lowercase c, cedilla\n+        {\"\\u00E8\", \"&egrave;\"}, //  - lowercase e, grave accent\n+        {\"\\u00E9\", \"&eacute;\"}, //  - lowercase e, acute accent\n+        {\"\\u00EA\", \"&ecirc;\"}, //  - lowercase e, circumflex accent\n+        {\"\\u00EB\", \"&euml;\"}, //  - lowercase e, umlaut\n+        {\"\\u00EC\", \"&igrave;\"}, //  - lowercase i, grave accent\n+        {\"\\u00ED\", \"&iacute;\"}, //  - lowercase i, acute accent\n+        {\"\\u00EE\", \"&icirc;\"}, //  - lowercase i, circumflex accent\n+        {\"\\u00EF\", \"&iuml;\"}, //  - lowercase i, umlaut\n+        {\"\\u00F0\", \"&eth;\"}, //  - lowercase eth, Icelandic\n+        {\"\\u00F1\", \"&ntilde;\"}, //  - lowercase n, tilde\n+        {\"\\u00F3\", \"&ograve;\"}, //  - lowercase o, grave accent\n+        {\"\\u00F3\", \"&oacute;\"}, //  - lowercase o, acute accent\n+        {\"\\u00F4\", \"&ocirc;\"}, //  - lowercase o, circumflex accent\n+        {\"\\u00F5\", \"&otilde;\"}, //  - lowercase o, tilde\n+        {\"\\u00F6\", \"&ouml;\"}, //  - lowercase o, umlaut\n+        {\"\\u00F7\", \"&divide;\"}, // division sign\n+        {\"\\u00F8\", \"&oslash;\"}, //  - lowercase o, slash\n+        {\"\\u00F9\", \"&ugrave;\"}, //  - lowercase u, grave accent\n+        {\"\\u00FA\", \"&uacute;\"}, //  - lowercase u, acute accent\n+        {\"\\u00FB\", \"&ucirc;\"}, //  - lowercase u, circumflex accent\n+        {\"\\u00FC\", \"&uuml;\"}, //  - lowercase u, umlaut\n+        {\"\\u00FD\", \"&yacute;\"}, //  - lowercase y, acute accent\n+        {\"\\u00FE\", \"&thorn;\"}, //  - lowercase thorn, Icelandic\n+        {\"\\u00FF\", \"&yuml;\"}, //  - lowercase y, umlaut\n+    };\n+\n+    static final String[][] ISO8859_1_UNESCAPE = invert(ISO8859_1_ESCAPE);\n+\n+    // http://www.w3.org/TR/REC-html40/sgml/entities.html\n+    static final String[][] HTML40_EXTENDED_ESCAPE = {\n+        // <!-- Latin Extended-B -->\n+        {\"\\u0192\", \"&fnof;\"}, // latin small f with hook = function= florin, U+0192 ISOtech -->\n+        // <!-- Greek -->\n+        {\"\\u0391\", \"&Alpha;\"}, // greek capital letter alpha, U+0391 -->\n+        {\"\\u0392\", \"&Beta;\"}, // greek capital letter beta, U+0392 -->\n+        {\"\\u0393\", \"&Gamma;\"}, // greek capital letter gamma,U+0393 ISOgrk3 -->\n+        {\"\\u0394\", \"&Delta;\"}, // greek capital letter delta,U+0394 ISOgrk3 -->\n+        {\"\\u0395\", \"&Epsilon;\"}, // greek capital letter epsilon, U+0395 -->\n+        {\"\\u0396\", \"&Zeta;\"}, // greek capital letter zeta, U+0396 -->\n+        {\"\\u0397\", \"&Eta;\"}, // greek capital letter eta, U+0397 -->\n+        {\"\\u0398\", \"&Theta;\"}, // greek capital letter theta,U+0398 ISOgrk3 -->\n+        {\"\\u0399\", \"&Iota;\"}, // greek capital letter iota, U+0399 -->\n+        {\"\\u039A\", \"&Kappa;\"}, // greek capital letter kappa, U+039A -->\n+        {\"\\u039B\", \"&Lambda;\"}, // greek capital letter lambda,U+039B ISOgrk3 -->\n+        {\"\\u039C\", \"&Mu;\"}, // greek capital letter mu, U+039C -->\n+        {\"\\u039D\", \"&Nu;\"}, // greek capital letter nu, U+039D -->\n+        {\"\\u039E\", \"&Xi;\"}, // greek capital letter xi, U+039E ISOgrk3 -->\n+        {\"\\u039F\", \"&Omicron;\"}, // greek capital letter omicron, U+039F -->\n+        {\"\\u03A0\", \"&Pi;\"}, // greek capital letter pi, U+03A0 ISOgrk3 -->\n+        {\"\\u03A1\", \"&Rho;\"}, // greek capital letter rho, U+03A1 -->\n+        // <!-- there is no Sigmaf, and no U+03A2 character either -->\n+        {\"\\u03A3\", \"&Sigma;\"}, // greek capital letter sigma,U+03A3 ISOgrk3 -->\n+        {\"\\u03A4\", \"&Tau;\"}, // greek capital letter tau, U+03A4 -->\n+        {\"\\u03A5\", \"&Upsilon;\"}, // greek capital letter upsilon,U+03A5 ISOgrk3 -->\n+        {\"\\u03A6\", \"&Phi;\"}, // greek capital letter phi,U+03A6 ISOgrk3 -->\n+        {\"\\u03A7\", \"&Chi;\"}, // greek capital letter chi, U+03A7 -->\n+        {\"\\u03A8\", \"&Psi;\"}, // greek capital letter psi,U+03A8 ISOgrk3 -->\n+        {\"\\u03A9\", \"&Omega;\"}, // greek capital letter omega,U+03A9 ISOgrk3 -->\n+        {\"\\u03B1\", \"&alpha;\"}, // greek small letter alpha,U+03B1 ISOgrk3 -->\n+        {\"\\u03B2\", \"&beta;\"}, // greek small letter beta, U+03B2 ISOgrk3 -->\n+        {\"\\u03B3\", \"&gamma;\"}, // greek small letter gamma,U+03B3 ISOgrk3 -->\n+        {\"\\u03B4\", \"&delta;\"}, // greek small letter delta,U+03B4 ISOgrk3 -->\n+        {\"\\u03B5\", \"&epsilon;\"}, // greek small letter epsilon,U+03B5 ISOgrk3 -->\n+        {\"\\u03B6\", \"&zeta;\"}, // greek small letter zeta, U+03B6 ISOgrk3 -->\n+        {\"\\u03B7\", \"&eta;\"}, // greek small letter eta, U+03B7 ISOgrk3 -->\n+        {\"\\u03B8\", \"&theta;\"}, // greek small letter theta,U+03B8 ISOgrk3 -->\n+        {\"\\u03B9\", \"&iota;\"}, // greek small letter iota, U+03B9 ISOgrk3 -->\n+        {\"\\u03BA\", \"&kappa;\"}, // greek small letter kappa,U+03BA ISOgrk3 -->\n+        {\"\\u03BB\", \"&lambda;\"}, // greek small letter lambda,U+03BB ISOgrk3 -->\n+        {\"\\u03BC\", \"&mu;\"}, // greek small letter mu, U+03BC ISOgrk3 -->\n+        {\"\\u03BD\", \"&nu;\"}, // greek small letter nu, U+03BD ISOgrk3 -->\n+        {\"\\u03BE\", \"&xi;\"}, // greek small letter xi, U+03BE ISOgrk3 -->\n+        {\"\\u03BF\", \"&omicron;\"}, // greek small letter omicron, U+03BF NEW -->\n+        {\"\\u03C0\", \"&pi;\"}, // greek small letter pi, U+03C0 ISOgrk3 -->\n+        {\"\\u03C1\", \"&rho;\"}, // greek small letter rho, U+03C1 ISOgrk3 -->\n+        {\"\\u03C2\", \"&sigmaf;\"}, // greek small letter final sigma,U+03C2 ISOgrk3 -->\n+        {\"\\u03C3\", \"&sigma;\"}, // greek small letter sigma,U+03C3 ISOgrk3 -->\n+        {\"\\u03C4\", \"&tau;\"}, // greek small letter tau, U+03C4 ISOgrk3 -->\n+        {\"\\u03C5\", \"&upsilon;\"}, // greek small letter upsilon,U+03C5 ISOgrk3 -->\n+        {\"\\u03C6\", \"&phi;\"}, // greek small letter phi, U+03C6 ISOgrk3 -->\n+        {\"\\u03C7\", \"&chi;\"}, // greek small letter chi, U+03C7 ISOgrk3 -->\n+        {\"\\u03C8\", \"&psi;\"}, // greek small letter psi, U+03C8 ISOgrk3 -->\n+        {\"\\u03C9\", \"&omega;\"}, // greek small letter omega,U+03C9 ISOgrk3 -->\n+        {\"\\u03D1\", \"&thetasym;\"}, // greek small letter theta symbol,U+03D1 NEW -->\n+        {\"\\u03D2\", \"&upsih;\"}, // greek upsilon with hook symbol,U+03D2 NEW -->\n+        {\"\\u03D6\", \"&piv;\"}, // greek pi symbol, U+03D6 ISOgrk3 -->\n+        // <!-- General Punctuation -->\n+        {\"\\u2022\", \"&bull;\"}, // bullet = black small circle,U+2022 ISOpub -->\n+        // <!-- bullet is NOT the same as bullet operator, U+2219 -->\n+        {\"\\u2026\", \"&hellip;\"}, // horizontal ellipsis = three dot leader,U+2026 ISOpub -->\n+        {\"\\u2032\", \"&prime;\"}, // prime = minutes = feet, U+2032 ISOtech -->\n+        {\"\\u2033\", \"&Prime;\"}, // double prime = seconds = inches,U+2033 ISOtech -->\n+        {\"\\u203E\", \"&oline;\"}, // overline = spacing overscore,U+203E NEW -->\n+        {\"\\u2044\", \"&frasl;\"}, // fraction slash, U+2044 NEW -->\n+        // <!-- Letterlike Symbols -->\n+        {\"\\u2118\", \"&weierp;\"}, // script capital P = power set= Weierstrass p, U+2118 ISOamso -->\n+        {\"\\u2111\", \"&image;\"}, // blackletter capital I = imaginary part,U+2111 ISOamso -->\n+        {\"\\u211C\", \"&real;\"}, // blackletter capital R = real part symbol,U+211C ISOamso -->\n+        {\"\\u2122\", \"&trade;\"}, // trade mark sign, U+2122 ISOnum -->\n+        {\"\\u2135\", \"&alefsym;\"}, // alef symbol = first transfinite cardinal,U+2135 NEW -->\n+        // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the\n+        // same glyph could be used to depict both characters -->\n+        // <!-- Arrows -->\n+        {\"\\u2190\", \"&larr;\"}, // leftwards arrow, U+2190 ISOnum -->\n+        {\"\\u2191\", \"&uarr;\"}, // upwards arrow, U+2191 ISOnum-->\n+        {\"\\u2192\", \"&rarr;\"}, // rightwards arrow, U+2192 ISOnum -->\n+        {\"\\u2193\", \"&darr;\"}, // downwards arrow, U+2193 ISOnum -->\n+        {\"\\u2194\", \"&harr;\"}, // left right arrow, U+2194 ISOamsa -->\n+        {\"\\u21B5\", \"&crarr;\"}, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->\n+        {\"\\u21D0\", \"&lArr;\"}, // leftwards double arrow, U+21D0 ISOtech -->\n+        // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'\n+        // arrow but also does not have any other character for that function.\n+        // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->\n+        {\"\\u21D1\", \"&uArr;\"}, // upwards double arrow, U+21D1 ISOamsa -->\n+        {\"\\u21D2\", \"&rArr;\"}, // rightwards double arrow,U+21D2 ISOtech -->\n+        // <!-- ISO 10646 does not say this is the 'implies' character but does not\n+        // have another character with this function so ?rArr can be used for\n+        // 'implies' as ISOtech suggests -->\n+        {\"\\u21D3\", \"&dArr;\"}, // downwards double arrow, U+21D3 ISOamsa -->\n+        {\"\\u21D4\", \"&hArr;\"}, // left right double arrow,U+21D4 ISOamsa -->\n+        // <!-- Mathematical Operators -->\n+        {\"\\u2200\", \"&forall;\"}, // for all, U+2200 ISOtech -->\n+        {\"\\u2202\", \"&part;\"}, // partial differential, U+2202 ISOtech -->\n+        {\"\\u2203\", \"&exist;\"}, // there exists, U+2203 ISOtech -->\n+        {\"\\u2205\", \"&empty;\"}, // empty set = null set = diameter,U+2205 ISOamso -->\n+        {\"\\u2207\", \"&nabla;\"}, // nabla = backward difference,U+2207 ISOtech -->\n+        {\"\\u2208\", \"&isin;\"}, // element of, U+2208 ISOtech -->\n+        {\"\\u2209\", \"&notin;\"}, // not an element of, U+2209 ISOtech -->\n+        {\"\\u220B\", \"&ni;\"}, // contains as member, U+220B ISOtech -->\n+        // <!-- should there be a more memorable name than 'ni'? -->\n+        {\"\\u220F\", \"&prod;\"}, // n-ary product = product sign,U+220F ISOamsb -->\n+        // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'\n+        // though the same glyph might be used for both -->\n+        {\"\\u2211\", \"&sum;\"}, // n-ary summation, U+2211 ISOamsb -->\n+        // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'\n+        // though the same glyph might be used for both -->\n+        {\"\\u2122\", \"&minus;\"}, // minus sign, U+2212 ISOtech -->\n+        {\"\\u2217\", \"&lowast;\"}, // asterisk operator, U+2217 ISOtech -->\n+        {\"\\u221A\", \"&radic;\"}, // square root = radical sign,U+221A ISOtech -->\n+        {\"\\u221D\", \"&prop;\"}, // proportional to, U+221D ISOtech -->\n+        {\"\\u221E\", \"&infin;\"}, // infinity, U+221E ISOtech -->\n+        {\"\\u2220\", \"&ang;\"}, // angle, U+2220 ISOamso -->\n+        {\"\\u2227\", \"&and;\"}, // logical and = wedge, U+2227 ISOtech -->\n+        {\"\\u2228\", \"&or;\"}, // logical or = vee, U+2228 ISOtech -->\n+        {\"\\u2229\", \"&cap;\"}, // intersection = cap, U+2229 ISOtech -->\n+        {\"\\u222A\", \"&cup;\"}, // union = cup, U+222A ISOtech -->\n+        {\"\\u222B\", \"&int;\"}, // integral, U+222B ISOtech -->\n+        {\"\\u2234\", \"&there4;\"}, // therefore, U+2234 ISOtech -->\n+        {\"\\u223C\", \"&sim;\"}, // tilde operator = varies with = similar to,U+223C ISOtech -->\n+        // <!-- tilde operator is NOT the same character as the tilde, U+007E,although\n+        // the same glyph might be used to represent both -->\n+        {\"\\u2245\", \"&cong;\"}, // approximately equal to, U+2245 ISOtech -->\n+        {\"\\u2248\", \"&asymp;\"}, // almost equal to = asymptotic to,U+2248 ISOamsr -->\n+        {\"\\u2260\", \"&ne;\"}, // not equal to, U+2260 ISOtech -->\n+        {\"\\u2261\", \"&equiv;\"}, // identical to, U+2261 ISOtech -->\n+        {\"\\u2264\", \"&le;\"}, // less-than or equal to, U+2264 ISOtech -->\n+        {\"\\u2265\", \"&ge;\"}, // greater-than or equal to,U+2265 ISOtech -->\n+        {\"\\u2282\", \"&sub;\"}, // subset of, U+2282 ISOtech -->\n+        {\"\\u2283\", \"&sup;\"}, // superset of, U+2283 ISOtech -->\n+        // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the\n+        // Symbol font encoding and is not included. Should it be, for symmetry?\n+        // It is in ISOamsn --> <!ENTITY nsub\", \"8836\"},\n+        // not a subset of, U+2284 ISOamsn -->\n+        {\"\\u2286\", \"&sube;\"}, // subset of or equal to, U+2286 ISOtech -->\n+        {\"\\u2287\", \"&supe;\"}, // superset of or equal to,U+2287 ISOtech -->\n+        {\"\\u2295\", \"&oplus;\"}, // circled plus = direct sum,U+2295 ISOamsb -->\n+        {\"\\u2297\", \"&otimes;\"}, // circled times = vector product,U+2297 ISOamsb -->\n+        {\"\\u22A5\", \"&perp;\"}, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->\n+        {\"\\u22C5\", \"&sdot;\"}, // dot operator, U+22C5 ISOamsb -->\n+        // <!-- dot operator is NOT the same character as U+00B7 middle dot -->\n+        // <!-- Miscellaneous Technical -->\n+        {\"\\u2308\", \"&lceil;\"}, // left ceiling = apl upstile,U+2308 ISOamsc -->\n+        {\"\\u2309\", \"&rceil;\"}, // right ceiling, U+2309 ISOamsc -->\n+        {\"\\u230A\", \"&lfloor;\"}, // left floor = apl downstile,U+230A ISOamsc -->\n+        {\"\\u230B\", \"&rfloor;\"}, // right floor, U+230B ISOamsc -->\n+        {\"\\u2329\", \"&lang;\"}, // left-pointing angle bracket = bra,U+2329 ISOtech -->\n+        // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation\n+        // mark' -->\n+        {\"\\u232A\", \"&rang;\"}, // right-pointing angle bracket = ket,U+232A ISOtech -->\n+        // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A\n+        // 'single right-pointing angle quotation mark' -->\n+        // <!-- Geometric Shapes -->\n+        {\"\\u25CA\", \"&loz;\"}, // lozenge, U+25CA ISOpub -->\n+        // <!-- Miscellaneous Symbols -->\n+        {\"\\u2660\", \"&spades;\"}, // black spade suit, U+2660 ISOpub -->\n+        // <!-- black here seems to mean filled as opposed to hollow -->\n+        {\"\\u2663\", \"&clubs;\"}, // black club suit = shamrock,U+2663 ISOpub -->\n+        {\"\\u2665\", \"&hearts;\"}, // black heart suit = valentine,U+2665 ISOpub -->\n+        {\"\\u2666\", \"&diams;\"}, // black diamond suit, U+2666 ISOpub -->\n+\n+        // <!-- Latin Extended-A -->\n+        {\"\\u0152\", \"&OElig;\"}, // -- latin capital ligature OE,U+0152 ISOlat2 -->\n+        {\"\\u0153\", \"&oelig;\"}, // -- latin small ligature oe, U+0153 ISOlat2 -->\n+        // <!-- ligature is a misnomer, this is a separate character in some languages -->\n+        {\"\\u0160\", \"&Scaron;\"}, // -- latin capital letter S with caron,U+0160 ISOlat2 -->\n+        {\"\\u0161\", \"&scaron;\"}, // -- latin small letter s with caron,U+0161 ISOlat2 -->\n+        {\"\\u0178\", \"&Yuml;\"}, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->\n+        // <!-- Spacing Modifier Letters -->\n+        {\"\\u02C6\", \"&circ;\"}, // -- modifier letter circumflex accent,U+02C6 ISOpub -->\n+        {\"\\u02DC\", \"&tilde;\"}, // small tilde, U+02DC ISOdia -->\n+        // <!-- General Punctuation -->\n+        {\"\\u2002\", \"&ensp;\"}, // en space, U+2002 ISOpub -->\n+        {\"\\u2003\", \"&emsp;\"}, // em space, U+2003 ISOpub -->\n+        {\"\\u2009\", \"&thinsp;\"}, // thin space, U+2009 ISOpub -->\n+        {\"\\u200C\", \"&zwnj;\"}, // zero width non-joiner,U+200C NEW RFC 2070 -->\n+        {\"\\u200D\", \"&zwj;\"}, // zero width joiner, U+200D NEW RFC 2070 -->\n+        {\"\\u200E\", \"&lrm;\"}, // left-to-right mark, U+200E NEW RFC 2070 -->\n+        {\"\\u200F\", \"&rlm;\"}, // right-to-left mark, U+200F NEW RFC 2070 -->\n+        {\"\\u2013\", \"&ndash;\"}, // en dash, U+2013 ISOpub -->\n+        {\"\\u2014\", \"&mdash;\"}, // em dash, U+2014 ISOpub -->\n+        {\"\\u2018\", \"&lsquo;\"}, // left single quotation mark,U+2018 ISOnum -->\n+        {\"\\u2019\", \"&rsquo;\"}, // right single quotation mark,U+2019 ISOnum -->\n+        {\"\\u201A\", \"&sbquo;\"}, // single low-9 quotation mark, U+201A NEW -->\n+        {\"\\u201C\", \"&ldquo;\"}, // left double quotation mark,U+201C ISOnum -->\n+        {\"\\u201D\", \"&rdquo;\"}, // right double quotation mark,U+201D ISOnum -->\n+        {\"\\u201E\", \"&bdquo;\"}, // double low-9 quotation mark, U+201E NEW -->\n+        {\"\\u2020\", \"&dagger;\"}, // dagger, U+2020 ISOpub -->\n+        {\"\\u2021\", \"&Dagger;\"}, // double dagger, U+2021 ISOpub -->\n+        {\"\\u2030\", \"&permil;\"}, // per mille sign, U+2030 ISOtech -->\n+        {\"\\u2039\", \"&lsaquo;\"}, // single left-pointing angle quotation mark,U+2039 ISO proposed -->\n+        // <!-- lsaquo is proposed but not yet ISO standardized -->\n+        {\"\\u203A\", \"&rsaquo;\"}, // single right-pointing angle quotation mark,U+203A ISO proposed -->\n+        // <!-- rsaquo is proposed but not yet ISO standardized -->\n+        {\"\\u20AC\", \"&euro;\"}, // -- euro sign, U+20AC NEW -->\n+    };\n+\n+    static final String[][] HTML40_EXTENDED_UNESCAPE = invert(HTML40_EXTENDED_ESCAPE);\n+\n+    static final String[][] BASIC_ESCAPE = {\n+        {\"\\\"\", \"&quot;\"}, // \" - double-quote\n+        {\"&\", \"&amp;\"},   // & - ampersand\n+        {\"<\", \"&lt;\"},    // < - less-than\n+        {\">\", \"&gt;\"},    // > - greater-than\n+    };\n+\n+    static final String[][] BASIC_UNESCAPE = invert(BASIC_ESCAPE);\n+\n+    static final String[][] APOS_ESCAPE = {\n+        {\"'\", \"&apos;\"}, // XML apostrophe\n+    };\n+\n+    static final String[][] APOS_UNESCAPE = invert(APOS_ESCAPE);\n+\n+    /**\n+     * Used to invert an escape array into an unescape array\n+     * @param array String[][] to be inverted\n+     * @return String[][] inverted array\n+     */\n+    static String[][] invert(String[][] array) {\n+        String[][] newarray = new String[array.length][2];\n+        for(int i = 0; i<array.length; i++) {\n+            newarray[i][0] = array[i][1];\n+            newarray[i][1] = array[i][0];\n+        }\n+        return newarray;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/EscapeLowAsciiAsUnicode.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Escapes ASCII under 32 to Unicode, except for the following \n+ * special values, '\\b \\n \\t \\f \\r', which are escaped to their \n+ * Java types.\n+ * @since 3.0\n+ */\n+// TODO: Is this not the combination of a LookupTranslator for the 5 \n+// TODO: special values, followed by a UnicodeEscaper?\n+// TODO: It means passing a numerical range to the UnicodeEscaper \n+// TOOD: to make it only hit < 32.\n+public class EscapeLowAsciiAsUnicode extends UnicodeEscaper {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean translate(int ch, Writer out) throws IOException {\n+        if (ch < 32) {\n+            switch (ch) {\n+                case '\\b' :\n+                    out.write('\\\\');\n+                    out.write('b');\n+                    break;\n+                case '\\n' :\n+                    out.write('\\\\');\n+                    out.write('n');\n+                    break;\n+                case '\\t' :\n+                    out.write('\\\\');\n+                    out.write('t');\n+                    break;\n+                case '\\f' :\n+                    out.write('\\\\');\n+                    out.write('f');\n+                    break;\n+                case '\\r' :\n+                    out.write('\\\\');\n+                    out.write('r');\n+                    break;\n+                default :\n+                    super.translate(ch, out);\n+                    break;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/EscapeNonAsciiAsNumericEntity.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translates codepoints greater than ASCII 127 to their numerical \n+ * XML entity.\n+ * @since 3.0\n+ */\n+public class EscapeNonAsciiAsNumericEntity extends CodePointTranslator {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean translate(int codepoint, Writer out) throws IOException {\n+        // TODO: if (codepoint > 0xffff) {\n+        if (codepoint > 0x7f) {\n+            out.write(\"&#\");\n+            out.write(Integer.toString(codepoint, 10));\n+            out.write(';');\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/EscapeNonAsciiAsUnicode.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translates codepoints greater than ASCII 127 to the unicode.\n+ * @since 3.0\n+ */\n+public class EscapeNonAsciiAsUnicode extends UnicodeEscaper {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean translate(int codepoint, Writer out) throws IOException {\n+        // if (codepoint > 0xffff) {\n+        // TODO: Figure out what to do. Output as two unicodes?\n+        //       Does this make this a Java-specific output class?\n+\n+        if (codepoint > 0x7f) {\n+            super.translate(codepoint, out);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/EscapeUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+// CsvEscaper\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.CharUtils;\n+\n+/**\n+ * Helper class defining various standard language escape functions. \n+ * @since 3.0\n+ */\n+public class EscapeUtils {\n+\n+    public static final CharSequenceTranslator ESCAPE_JAVA = \n+        new AggregateTranslator(\n+            new LookupTranslator(\n+                      new String[][] { \n+                            {\"\\\"\", \"\\\\\\\"\"},\n+                            {\"\\\\\", \"\\\\\\\\\"}\n+                      }),\n+            new EscapeLowAsciiAsUnicode(),\n+            new EscapeNonAsciiAsUnicode()\n+        );\n+                \n+    public static final CharSequenceTranslator ESCAPE_ECMASCRIPT = \n+        new AggregateTranslator(\n+            new LookupTranslator(\n+                      new String[][] { \n+                            {\"'\", \"\\\\'\"},\n+                            {\"\\\"\", \"\\\\\\\"\"},\n+                            {\"\\\\\", \"\\\\\\\\\"},\n+                            {\"/\", \"\\\\/\"}\n+                      }),\n+            new EscapeLowAsciiAsUnicode(),\n+            new EscapeNonAsciiAsUnicode()\n+        );\n+            \n+    public static final CharSequenceTranslator ESCAPE_XML = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE),\n+            new LookupTranslator(EntityArrays.APOS_ESCAPE),\n+            new EscapeNonAsciiAsNumericEntity()\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_HTML3 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE),\n+            new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE),\n+            new EscapeNonAsciiAsNumericEntity()\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_HTML4 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE),\n+            new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE),\n+            new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE),\n+            new EscapeNonAsciiAsNumericEntity()\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n+\n+    // TODO: Create a parent class - 'SinglePassTranslator' ?\n+    // TODO: It would handle the index checking, and length returning, and \n+    // TODO: could also have an optimization check method.\n+    static class CsvEscaper extends CharSequenceTranslator {\n+\n+        private static final char CSV_DELIMITER = ',';\n+        private static final char CSV_QUOTE = '\"';\n+        private static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\n+        private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n+\n+        // TODO: Replace with a RegexTranslator. That should consume the number of characters the regex uses up?\n+        public int translate(CharSequence input, int index, Writer out) throws IOException {\n+\n+            if(index != 0) {\n+                throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n+            }\n+\n+            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n+                out.write(input.toString());\n+            } else {\n+                out.write(CSV_QUOTE);\n+                out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n+                out.write(CSV_QUOTE);\n+            }\n+            return input.length();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/LookupTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translates a value using a lookup table. \n+ * @since 3.0\n+ */\n+public class LookupTranslator extends CharSequenceTranslator {\n+\n+    protected CharSequence[][] lookup;\n+\n+    /**\n+     * Define the lookup table to be used in translation\n+     *\n+     * @param CharSequence[][] Lookup table of size [*][2]\n+     */\n+    public LookupTranslator(CharSequence[][] lookup) {\n+        this.lookup = lookup;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        CharSequence subsequence = input.subSequence(index, input.length());\n+        for(CharSequence[] seq : lookup) {\n+            if( subsequence.toString().startsWith(seq[0].toString()) ) {\n+                out.write(seq[1].toString());\n+                return seq[0].length();\n+            }\n+        }\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/NumericEntityUnescaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translate XML numeric entities of the form &#[xX]?\\d+; to \n+ * the specific codepoint. \n+ * @since 3.0\n+ */\n+public class NumericEntityUnescaper extends CharSequenceTranslator {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        // TODO: Protect from ArrayIndexOutOfBounds\n+        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n+            int start = index + 2;\n+            boolean isHex = false;\n+\n+            char firstChar = input.charAt(start);\n+            if(firstChar == 'x' || firstChar == 'X') {\n+                start++;\n+                isHex = true;\n+            }\n+\n+            int end = start;\n+            while(input.charAt(end) != ';') {\n+                end++;\n+            }\n+\n+            int entityValue;\n+            try {\n+                if(isHex) {\n+                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n+                } else {\n+                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n+                }\n+            } catch(NumberFormatException nfe) {\n+                return 0;\n+            }\n+\n+            // TODO: if(entityValue > 0xFFFF) {\n+            out.write(entityValue);\n+            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n+        }\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/UnescapeUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+// CsvUnescaper\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.CharUtils;\n+\n+/**\n+ * Helper class defining various standard language unescape functions. \n+ * @since 3.0\n+ */\n+public class UnescapeUtils {\n+\n+    // throw \"illegal character: \\92\" as an Exception if a \\ on the end of the Java (as per the compiler)?\n+    public static final CharSequenceTranslator UNESCAPE_JAVA = \n+        new AggregateTranslator(\n+            new UnicodeUnescaper(),\n+            new LookupTranslator(\n+                      new String[][] { \n+                            {\"\\\\\\\\\", \"\\\\\"},\n+                            {\"\\\\\\\"\", \"\\\"\"},\n+                            {\"\\\\'\", \"'\"},\n+                            {\"\\\\r\", \"\\r\"},\n+                            {\"\\\\f\", \"\\f\"},\n+                            {\"\\\\t\", \"\\t\"},\n+                            {\"\\\\n\", \"\\n\"},\n+                            {\"\\\\b\", \"\\b\"},\n+                            {\"\\\\\", \"\"}\n+                      })\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_ECMASCRIPT = UNESCAPE_JAVA;\n+\n+    public static final CharSequenceTranslator UNESCAPE_HTML4 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_UNESCAPE),\n+            new LookupTranslator(EntityArrays.ISO8859_1_UNESCAPE),\n+            new LookupTranslator(EntityArrays.HTML40_EXTENDED_UNESCAPE),\n+            new NumericEntityUnescaper()\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_XML = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_UNESCAPE),\n+            new LookupTranslator(EntityArrays.APOS_UNESCAPE),\n+            new NumericEntityUnescaper()\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n+\n+    static class CsvUnescaper extends CharSequenceTranslator {\n+\n+        private static final char CSV_DELIMITER = ',';\n+        private static final char CSV_QUOTE = '\"';\n+        private static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\n+        private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n+\n+        // TODO: Replace with a RegexTranslator. That should consume the number of characters the regex uses up?\n+        public int translate(CharSequence input, int index, Writer out) throws IOException {\n+\n+            if(index != 0) {\n+                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n+            }\n+\n+            if ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\n+                out.write(input.toString());\n+                return input.length();\n+            }\n+\n+            // strip quotes\n+            String quoteless = input.subSequence(1, input.length() - 1).toString();\n+\n+            if ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n+                // deal with escaped quotes; ie) \"\"\n+                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n+            } else {\n+                out.write(input.toString());\n+            }\n+            return input.length();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/UnicodeEscaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translates codepoints to their unicode escape value. \n+ * @since 3.0\n+ */\n+public class UnicodeEscaper extends CodePointTranslator {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean translate(int codepoint, Writer out) throws IOException {\n+        if (codepoint > 0xffff) {\n+            // TODO: Figure out what to do. Output as two unicodes?\n+            //       Does this make this a Java-specific output class?\n+            out.write(\"\\\\u\" + hex(codepoint));\n+        } else if (codepoint > 0xfff) {\n+            out.write(\"\\\\u\" + hex(codepoint));\n+        } else if (codepoint > 0xff) {\n+            out.write(\"\\\\u0\" + hex(codepoint));\n+        } else if (codepoint > 0xf) {\n+            out.write(\"\\\\u00\" + hex(codepoint));\n+        } else {\n+            out.write(\"\\\\u000\" + hex(codepoint));\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/translate/UnicodeUnescaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.apache.commons.lang.UnhandledException;\n+\n+/**\n+ * Translates escaped unicode values of the form \\\\u+\\d\\d\\d\\d back to \n+ * unicode.\n+ * @since 3.0\n+ */\n+public class UnicodeUnescaper extends CharSequenceTranslator {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        if(input.charAt(index) == '\\\\') {\n+            if( (index + 1 < input.length()) && input.charAt(index + 1) == 'u') {\n+                // consume optional additional 'u' chars\n+                int i=2;\n+                while( (index + i < input.length()) && input.charAt(index + i) == 'u') {\n+                    i++;\n+                }\n+\n+                if( (index + i + 4 <= input.length()) ) {\n+                    // Get 4 hex digits\n+                    CharSequence unicode = input.subSequence(index + i, index + i + 4);\n+\n+                    try {\n+                        int value = Integer.parseInt(unicode.toString(), 16);\n+                        out.write((char) value);\n+                    } catch (NumberFormatException nfe) {\n+                        throw new UnhandledException(\"Unable to parse unicode value: \" + unicode, nfe);\n+                    }\n+                    return i + 4;\n+                } else {\n+                    throw new IllegalArgumentException(\"Less than 4 hex digits in unicode value: '\" + \n+                                                       input.subSequence(index, input.length()) +\n+                                                       \"' due to end of CharSequence\");\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+}\n--- a/src/test/org/apache/commons/lang/LangTestSuite.java\n+++ b/src/test/org/apache/commons/lang/LangTestSuite.java\n         suite.addTest(CharSetUtilsTest.suite());\n         suite.addTest(CharUtilsTest.suite());\n         suite.addTest(ClassUtilsTest.suite());\n-        suite.addTest(EntitiesTest.suite());\n         suite.addTest(EnumUtilsTest.suite());\n         suite.addTest(IllegalClassExceptionTest.suite());\n         suite.addTest(IncompleteArgumentExceptionTest.suite());\n--- a/src/test/org/apache/commons/lang/StringEscapeUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/StringEscapeUtilsTest.java\n         assertUnescapeJava(\"\\ntest\\b\", \"\\\\ntest\\\\b\");\n         assertUnescapeJava(\"\\u123425foo\\ntest\\b\", \"\\\\u123425foo\\\\ntest\\\\b\");\n         assertUnescapeJava(\"'\\foo\\teste\\r\", \"\\\\'\\\\foo\\\\teste\\\\r\");\n-        assertUnescapeJava(\"\\\\\", \"\\\\\");\n+        assertUnescapeJava(\"\", \"\\\\\");\n         //foo\n         assertUnescapeJava(\"lowercase unicode\", \"\\uABCDx\", \"\\\\uabcdx\");\n         assertUnescapeJava(\"uppercase unicode\", \"\\uABCDx\", \"\\\\uABCDx\");", "timestamp": 1245737750, "metainfo": ""}