{"sha": "bcbaa2be25f5c56453e9176648cd931031242e03", "log": "Killing the lang sandbox component   ", "commit": "\n--- /dev/null\n+++ b/src/pending/CalendarUtils.java\n+// package org.apache.commons.lang;\n+\n+/*\n+ * Copyright 2002,2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import java.text.*;\n+import java.util.*;\n+\n+/**\n+ * A suite of utilities surrounding the use of the Calendar and Date object.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ */\n+public class CalendarUtils {\n+\n+    /**\n+     * This is half a month, so this represents whether a date is in the top\n+     * or bottom half of the month.\n+     */\n+    public final static int SEMI_MONTH = 1001;\n+\n+    private static final int[][] fields = {\n+            {Calendar.MILLISECOND},\n+            {Calendar.SECOND},\n+            {Calendar.MINUTE},\n+            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n+            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */},\n+            {Calendar.MONTH, CalendarUtils.SEMI_MONTH},\n+            {Calendar.YEAR},\n+            {Calendar.ERA}};\n+\n+    private static DateFormat[] dateFormats = {\n+        //3/31/92 10:00:07 PST\n+        new SimpleDateFormat(\"M/dd/yy h:mm:ss z\"),\n+        //January 23, 1987 10:05pm\n+        new SimpleDateFormat(\"MMM d, yyyy h:mm a\"),\n+        //22:00 GMT\n+        new SimpleDateFormat(\"h:mm z\")};\n+\n+    /**\n+     * A week range, starting on Sunday.\n+     */\n+    public final static int RANGE_WEEK_SUNDAY = 1;\n+\n+    /**\n+     * A week range, starting on Monday.\n+     */\n+    public final static int RANGE_WEEK_MONDAY = 2;\n+\n+    /**\n+     * A week range, starting on the day focused.\n+     */\n+    public final static int RANGE_WEEK_RELATIVE = 3;\n+\n+    /**\n+     * A week range, centered around the day focused.\n+     */\n+    public final static int RANGE_WEEK_CENTER = 4;\n+\n+    /**\n+     * A month range, the week starting on Sunday.\n+     */\n+    public final static int RANGE_MONTH_SUNDAY = 5;\n+\n+    /**\n+     * A month range, the week starting on Monday.\n+     */\n+    public final static int RANGE_MONTH_MONDAY = 6;\n+\n+    /**\n+     * See the other round method.  Works with a Date object.\n+     */\n+    public static Date round(Date val, int field) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(val);\n+        modify(gval, field, true);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Round this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return 28 Mar\n+     * 2002 14:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 April 2002 0:00:00.000.\n+     */\n+    public static Calendar round(Calendar val, int field) {\n+        Calendar rounded = (Calendar) val.clone();\n+        modify(rounded, field, true);\n+        return rounded;\n+    }\n+\n+    /**\n+     * See the other round method.  Works with an Object, trying to\n+     * use it as either a Date or Calendar.\n+     */\n+    public static Date round(Object val, int field) {\n+        if (val instanceof Date) {\n+            return round((Date) val, field);\n+        } else if (val instanceof Calendar) {\n+            return round((Calendar) val, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not round \" + val);\n+        }\n+    }\n+\n+    /**\n+     * See the other trunc method.  Works with a Date.\n+     */\n+    public static Date trunc(Date val, int field) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(val);\n+        modify(gval, field, false);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Truncate this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 Mar 2002 0:00:00.000.\n+     */\n+    public static Calendar trunc(Calendar val, int field) {\n+        Calendar truncated = (Calendar) val.clone();\n+        modify(truncated, field, false);\n+        return truncated;\n+    }\n+\n+    /**\n+     * See the other trunc method.  Works with an Object, trying to\n+     * use it as either a Date or Calendar.\n+     */\n+    public static Date trunc(Object val, int field) {\n+        if (val instanceof Date) {\n+            return trunc((Date) val, field);\n+        } else if (val instanceof Calendar) {\n+            return trunc((Calendar) val, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not trunc \" + val);\n+        }\n+    }\n+\n+    private static void modify(Calendar val, int field, boolean round) {\n+        boolean roundUp = false;\n+        for (int i = 0; i < fields.length; i++) {\n+            for (int j = 0; j < fields[i].length; j++) {\n+                if (fields[i][j] == field) {\n+                    //This is our field... we stop looping\n+                    if (round && roundUp) {\n+                        if (field == CalendarUtils.SEMI_MONTH) {\n+                            //This is a special case that's hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) == 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(fields[i][0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset = 0;\n+            boolean offsetSet = false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case CalendarUtils.SEMI_MONTH:\n+                    if (fields[i][0] == Calendar.DATE) {\n+                        //If we're going to drop the DATE field's value,\n+                        //  we want to do this our own way.\n+                        //We need to subtrace 1 since the date has a minimum of 1\n+                        offset = val.get(Calendar.DATE) - 1;\n+                        //If we're above 15 days adjustment, that means we're in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset >= 15) {\n+                            offset -= 15;\n+                        }\n+                        //Record whether we're in the top or bottom half of that range\n+                        roundUp = offset > 7;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (fields[i][0] == Calendar.HOUR) {\n+                        //If we're going to drop the HOUR field's value,\n+                        //  we want to do this our own way.\n+                        offset = val.get(Calendar.HOUR);\n+                        if (offset >= 12) {\n+                            offset -= 12;\n+                        }\n+                        roundUp = offset > 6;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                int min = val.getActualMinimum(fields[i][0]);\n+                int max = val.getActualMaximum(fields[i][0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset = val.get(fields[i][0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp = offset > ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            val.add(fields[i][0], -offset);\n+        }\n+        throw new RuntimeException(\"We do not support that field.\");\n+\n+    }\n+\n+    /**\n+     * Parses strings the way that CVS supports it... very human readable\n+     */\n+    public static Calendar parse(String original) {\n+        return parse(original, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Parses strings the way that CVS supports it... very human readable\n+     */\n+    public static Calendar parse(String original, Locale locale) {\n+        //Get the symbol names\n+        DateFormatSymbols symbols = new DateFormatSymbols(locale);\n+\n+        //Prep the string to parse\n+        String value = original.toLowerCase().trim();\n+\n+        //Get the current date/time\n+        Calendar now = Calendar.getInstance();\n+        if (value.endsWith(\" ago\")) {\n+            //If this was a date that was \"ago\" the current time...\n+            //Strip out the ' ago' part\n+            value = value.substring(0, value.length() - 4);\n+\n+            //Split the value and unit\n+            int start = value.indexOf(\" \");\n+            if (start < 0) {\n+                throw new RuntimeException(\"Could not find space in between value and unit\");\n+            }\n+            String unit = value.substring(start + 1);\n+            value = value.substring(0, start);\n+            //We support \"a week\", so we need to parse the value as \"a\"\n+            int val = 0;\n+            if (value.equals(\"a\") || value.equals(\"an\")) {\n+                val = 1;\n+            } else {\n+                val = Integer.parseInt(value);\n+            }\n+\n+            //Determine the unit\n+            if (unit.equals(\"milliseconds\") || unit.equals(\"millisecond\")) {\n+                now.add(Calendar.MILLISECOND, -val);\n+            } else if (unit.equals(\"seconds\") || unit.equals(\"second\")) {\n+                now.add(Calendar.SECOND, -val);\n+            } else if (unit.equals(\"minutes\") || unit.equals(\"minute\")) {\n+                now.add(Calendar.MINUTE, -val);\n+            } else if (unit.equals(\"hours\") || unit.equals(\"hour\")) {\n+                now.add(Calendar.HOUR, -val);\n+            } else if (unit.equals(\"days\") || unit.equals(\"day\")) {\n+                now.add(Calendar.DATE, -val);\n+            } else if (unit.equals(\"weeks\") || unit.equals(\"week\")) {\n+                now.add(Calendar.DATE, -val * 7);\n+            } else if (unit.equals(\"fortnights\") || unit.equals(\"fortnight\")) {\n+                now.add(Calendar.DATE, -val * 14);\n+            } else if (unit.equals(\"months\") || unit.equals(\"month\")) {\n+                now.add(Calendar.MONTH, -val);\n+            } else if (unit.equals(\"years\") || unit.equals(\"year\")) {\n+                now.add(Calendar.YEAR, -val);\n+            } else {\n+                throw new RuntimeException(\"We do not understand that many units ago\");\n+            }\n+            return now;\n+        } else if (value.startsWith(\"last \")) {\n+            //If this was the last time a certain field was met\n+            //Strip out the 'last ' part\n+            value = value.substring(5);\n+            //Get the current date/time\n+            String[] strings = symbols.getWeekdays();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after Sunday\n+                    int daysAgo = now.get(Calendar.DAY_OF_WEEK) - i;\n+                    if (daysAgo <= 0) {\n+                        daysAgo += 7;\n+                    }\n+                    now.add(Calendar.DATE, -daysAgo);\n+                    return now;\n+                }\n+            }\n+            strings = symbols.getMonths();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after January\n+                    int monthsAgo = now.get(Calendar.MONTH) - i;\n+                    if (monthsAgo <= 0) {\n+                        monthsAgo += 12;\n+                    }\n+                    now.add(Calendar.MONTH, -monthsAgo);\n+                    return now;\n+                }\n+            }\n+            if (value.equals(\"week\")) {\n+                now.add(Calendar.DATE, -7);\n+                return now;\n+            }\n+        } else if (value.equals(\"yesterday\")) {\n+            now.add(Calendar.DATE, -1);\n+            return now;\n+        } else if (value.equals(\"tomorrow\")) {\n+            now.add(Calendar.DATE, 1);\n+            return now;\n+        }\n+        //Try to parse the date a number of different ways\n+        for (int i = 0; i < dateFormats.length; i++) {\n+            try {\n+                Date datetime = dateFormats[i].parse(original);\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(datetime);\n+                return cal;\n+            } catch (ParseException pe) {\n+                //we ignore this and just keep trying\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Unable to parse '\" + original + \"'.\");\n+    }\n+\n+    /**\n+     * This constructs an Iterator that will start and stop over a date\n+     * range based on the focused date and the range style.  For instance,\n+     * passing Thursday, July 4, 2002 and a RANGE_MONTH_SUNDAY will return\n+     * an Iterator that starts with Sunday, June 30, 2002 and ends with\n+     * Saturday, August 3, 2002.\n+     */\n+    public static Iterator getCalendarIterator(Calendar focus, int rangeStyle) {\n+        Calendar start = null;\n+        Calendar end = null;\n+        int startCutoff = Calendar.SUNDAY;\n+        int endCutoff = Calendar.SATURDAY;\n+        switch (rangeStyle) {\n+            case RANGE_MONTH_SUNDAY:\n+            case RANGE_MONTH_MONDAY:\n+                //Set start to the first of the month\n+                start = trunc(focus, Calendar.MONTH);\n+                //Set end to the last of the month\n+                end = (Calendar) start.clone();\n+                end.add(Calendar.MONTH, 1);\n+                end.add(Calendar.DATE, -1);\n+                //Loop start back to the previous sunday or monday\n+                if (rangeStyle == RANGE_MONTH_MONDAY) {\n+                    startCutoff = Calendar.MONDAY;\n+                    endCutoff = Calendar.SUNDAY;\n+                }\n+                break;\n+            case RANGE_WEEK_SUNDAY:\n+            case RANGE_WEEK_MONDAY:\n+            case RANGE_WEEK_RELATIVE:\n+            case RANGE_WEEK_CENTER:\n+                //Set start and end to the current date\n+                start = trunc(focus, Calendar.DATE);\n+                end = trunc(focus, Calendar.DATE);\n+                switch (rangeStyle) {\n+                    case RANGE_WEEK_SUNDAY:\n+                        //already set by default\n+                        break;\n+                    case RANGE_WEEK_MONDAY:\n+                        startCutoff = Calendar.MONDAY;\n+                        endCutoff = Calendar.SUNDAY;\n+                        break;\n+                    case RANGE_WEEK_RELATIVE:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n+                        endCutoff = startCutoff - 1;\n+                        break;\n+                    case RANGE_WEEK_CENTER:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n+                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n+                        break;\n+                }\n+                break;\n+            default:\n+                throw new RuntimeException(\"The range style \" + rangeStyle + \" is not valid.\");\n+        }\n+        if (startCutoff < Calendar.SUNDAY) {\n+            startCutoff += 7;\n+        }\n+        if (endCutoff > Calendar.SATURDAY) {\n+            endCutoff -= 7;\n+        }\n+        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n+            start.add(Calendar.DATE, -1);\n+        }\n+        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n+            end.add(Calendar.DATE, 1);\n+        }\n+        final Calendar startFinal = start;\n+        final Calendar endFinal = end;\n+        Iterator it = new Iterator() {\n+            Calendar spot = null;\n+            {\n+                spot = startFinal;\n+                spot.add(Calendar.DATE, -1);\n+            }\n+\n+            public boolean hasNext() {\n+                return spot.before(endFinal);\n+            }\n+\n+            public Object next() {\n+                if (spot.equals(endFinal)) {\n+                    throw new NoSuchElementException();\n+                }\n+                spot.add(Calendar.DATE, 1);\n+                return spot.clone();\n+            }\n+\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        return it;\n+    }\n+\n+    /**\n+     * See the other getCalendarIterator.  Works with a Date.\n+     */\n+    public static Iterator getCalendarIterator(Date focus, int rangeStyle) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(focus);\n+        return getCalendarIterator(gval, rangeStyle);\n+    }\n+\n+    /**\n+     * See the other getCalendarIterator.  Works with an Object, trying\n+     * to use it as a Date or Calendar.\n+     */\n+    public static Iterator getCalendarIterator(Object focus, int rangeStyle) {\n+        if (focus instanceof Date) {\n+            return getCalendarIterator((Date) focus, rangeStyle);\n+        } else if (focus instanceof Calendar) {\n+            return getCalendarIterator((Calendar) focus, rangeStyle);\n+        } else {\n+            throw new ClassCastException(\"Could not iterate based on \" + focus);\n+        }\n+    }\n+\n+}", "timestamp": 1125271871, "metainfo": ""}