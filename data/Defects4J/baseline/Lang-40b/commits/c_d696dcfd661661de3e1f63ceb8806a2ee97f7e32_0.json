{"sha": "d696dcfd661661de3e1f63ceb8806a2ee97f7e32", "log": "Rename nd to end   ", "commit": "\n--- a/src/java/org/apache/commons/lang/Tokenizer.java\n+++ b/src/java/org/apache/commons/lang/Tokenizer.java\n  * @author Stephen Colebourne\n  * @author Gary D. Gregory\n  * @since 2.1\n- * @version $Id: Tokenizer.java,v 1.7 2004/08/28 09:14:21 scolebourne Exp $\n+ * @version $Id: Tokenizer.java,v 1.8 2004/08/28 09:21:05 scolebourne Exp $\n  */\n public class Tokenizer implements ListIterator, Cloneable {\n \n         // Loop until we've found the end of the quoted\n         // string or the end of the input\n         int cbufcnt = 0;\n-        int nd = start + 1;\n+        int end = start + 1;\n         boolean done = false;\n         boolean quoting = true;\n         int len = chars.length;\n \n-        while (nd < len && !done) {\n+        while (end < len && !done) {\n             // Quoting mode can occur several times throughout\n             // a given string, so must switch between quoting\n             // and non-quoting until we encounter a non-quoted\n                 // followed by a second quote.  If so, then we need\n                 // to actually put the quote character into the token\n                 // rather than end the token.\n-                if (quote.isMatch(chars[nd]) &&\n-                        nd + 1 < len &&\n-                        chars[nd + 1] == chars[nd]) {\n-                    cbuf[cbufcnt++] = chars[nd];\n-                    nd++;\n+                if (quote.isMatch(chars[end]) &&\n+                        end + 1 < len &&\n+                        chars[end + 1] == chars[end]) {\n+                    cbuf[cbufcnt++] = chars[end];\n+                    end++;\n                 }\n                 // End the quoting if we get to this condition\n-                else if (quote.isMatch(chars[nd])) {\n+                else if (quote.isMatch(chars[end])) {\n                     quoting = false;\n                 }\n                 // Otherwise, just put the character into the token\n                 else {\n-                    cbuf[cbufcnt++] = chars[nd];\n+                    cbuf[cbufcnt++] = chars[end];\n                 }\n-                nd++;\n+                end++;\n             }\n             // If we're not in quoting mode, if we encounter\n             // a delimiter, the token is ended.  If we encounter\n             // the character\n             else {\n                 // If we're\n-                if (delim.isMatch(chars[nd])) {\n+                if (delim.isMatch(chars[end])) {\n                     done = true;\n                 } else {\n-                    if (quote.isMatch(chars[nd])) {\n+                    if (quote.isMatch(chars[end])) {\n                         quoting = true;\n                     } else {\n-                        cbuf[cbufcnt++] = chars[nd];\n+                        cbuf[cbufcnt++] = chars[end];\n                     }\n-                    nd++;\n+                    end++;\n                 }\n             }\n         }\n \n         token.append(cbuf, 0, cbufcnt);\n \n-        return nd + 1;\n+        return end + 1;\n     }\n \n     /**\n         int len = chars.length;\n         // Skip ahead until we get to a delimiter character, or\n         // the end of the input\n-        int nd = start + 1;\n-        while (nd < len && !delim.isMatch(chars[nd])) {\n-            nd++;\n-        }\n-\n-        token.append(chars, start, Math.min(nd, len) - start);\n-\n-        return nd + 1;\n+        int end = start + 1;\n+        while (end < len && !delim.isMatch(chars[end])) {\n+            end++;\n+        }\n+\n+        token.append(chars, start, Math.min(end, len) - start);\n+\n+        return end + 1;\n     }\n \n     /**", "timestamp": 1093684865, "metainfo": ""}