{"sha": "2f94a814dc01ae392768afb8110b2b55169ed69f", "log": "Improve checkstyle report   ", "commit": "\n--- a/src/java/org/apache/commons/lang/SerializationException.java\n+++ b/src/java/org/apache/commons/lang/SerializationException.java\n  * error is wrapped within this one.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: SerializationException.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ * @version $Id: SerializationException.java,v 1.2 2002/08/31 11:11:03 scolebourne Exp $\n  */\n public class SerializationException extends NestableRuntimeException {\n \n      * Constructs a new <code>SerializationException</code> with specified\n      * detail message.\n      *\n-     * @param msg The error message.\n+     * @param msg  The error message.\n      */\n     public SerializationException(String msg) {\n         super(msg);\n      * Constructs a new <code>SerializationException</code> with specified\n      * nested <code>Throwable</code>.\n      *\n-     * @param nested The exception or error that caused this exception\n+     * @param cause  The exception or error that caused this exception\n      *               to be thrown.\n      */\n     public SerializationException(Throwable cause) {\n      * detail message and nested <code>Throwable</code>.\n      *\n      * @param msg    The error message.\n-     * @param nested The exception or error that caused this exception\n+     * @param cause  The exception or error that caused this exception\n      *               to be thrown.\n      */\n     public SerializationException(String msg, Throwable cause) {\n--- a/src/java/org/apache/commons/lang/SerializationUtils.java\n+++ b/src/java/org/apache/commons/lang/SerializationUtils.java\n  * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n  * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: SerializationUtils.java,v 1.1 2002/07/19 03:35:54 bayard Exp $\n+ * @version $Id: SerializationUtils.java,v 1.2 2002/08/31 11:09:45 scolebourne Exp $\n  */\n public class SerializationUtils {\n     \n      * @throws SerializationException (runtime) if the serialization fails\n      */\n     public static Object clone(Serializable object) {\n-        return deserialize( serialize(object) );\n+        return deserialize(serialize(object));\n     }\n     \n     /**\n      * Serializes an object to a byte array for storage/serialization.\n      *\n      * @param obj  the object to serialize to bytes\n-     * @return a byte[] with the converted Serializable.\n+     * @return a byte[] with the converted Serializable\n      * @throws SerializationException (runtime) if the serialization fails\n      */\n     public static byte[] serialize(Serializable obj) {\n      * a finally clause, and maybe also exception handling, in the\n      * application code.\n      *\n-     * @param objectData  the serialized object.\n+     * @param inputStream  the serialized object input stream\n      * @return the deserialized object\n      * @throws SerializationException (runtime) if the serialization fails\n      */\n     /**\n      * Deserializes a single object from an array of bytes.\n      *\n-     * @param objectData  the serialized object.\n+     * @param objectData  the serialized object\n      * @return the deserialized object\n      * @throws SerializationException (runtime) if the serialization fails\n      */\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n  * @author <a href=\"mailto:ed@apache.org\">Ed Korthof</a>\n  * @author <a href=\"mailto:rand_mcneely@yahoo.com>Rand McNeely</a>\n  * @author <a href=\"mailto:scolebourne@joda.org>Stephen Colebourne</a>\n- * @version $Id: StringUtils.java,v 1.8 2002/08/30 02:52:54 dlr Exp $\n+ * @version $Id: StringUtils.java,v 1.9 2002/08/31 11:07:08 scolebourne Exp $\n  */\n public class StringUtils {\n \n      * Deletes all whitespace from a String.\n      *\n      * @param str  String target to delete whitespace from\n+     * @return the text without whitespace\n      */\n     public static String deleteWhitespace(String str) {\n-        return CharSetUtils.delete(str, \" \\t\\r\\n\\b\" );\n+        return CharSetUtils.delete(str, \" \\t\\r\\n\\b\");\n     }\n \n     /**\n      * @param str  the string to parse\n      * @return an array of parsed Strings \n      */\n-    public static String[] split(String text) {\n-        return split(text, null, -1);\n+    public static String[] split(String str) {\n+        return split(str, null, -1);\n     }\n \n     /**\n      * list.  A zero or negative value implies no limit.\n      * @return an array of parsed Strings \n      */\n-    public static String[] split(String text, String separator, int max) {\n+    public static String[] split(String str, String separator, int max) {\n         StringTokenizer tok = null;\n         if (separator == null) {\n             // Null separator means we're using StringTokenizer's default\n             // delimiter, which comprises all whitespace characters.\n-            tok = new StringTokenizer(text);\n+            tok = new StringTokenizer(str);\n         } else {\n-            tok = new StringTokenizer(text, separator);\n+            tok = new StringTokenizer(str, separator);\n         }\n \n         int listSize = tok.countTokens();\n                 // In the situation where we hit the max yet have\n                 // tokens left over in our input, the last list\n                 // element gets all remaining text.\n-                StringBuffer buf = new StringBuffer((int) 1.2 * text.length() * (listSize - i) / listSize);\n+                StringBuffer buf = new StringBuffer((int) 1.2 * str.length() * (listSize - i) / listSize);\n                 while (tok.hasMoreTokens()) {\n                     buf.append(tok.nextToken());\n                     if (tok.hasMoreTokens()) {\n \n         StringBuffer buf = new StringBuffer(text.length());\n         int start = 0, end = 0;\n-        while ( (end = text.indexOf(repl, start)) != -1 ) {\n+        while ((end = text.indexOf(repl, start)) != -1) {\n             buf.append(text.substring(start, end)).append(with);\n             start = end + repl.length();\n \n      */\n     public static String overlayString(String text, String overlay, int start, int end) {\n         return new StringBuffer(start + overlay.length() + text.length() - end + 1)\n-\t\t\t.append(text.substring(0, start))\n-\t\t\t.append(overlay)\n-\t\t\t.append(text.substring(end))\n-\t\t\t.toString();\n+            .append(text.substring(0, start))\n+            .append(overlay)\n+            .append(text.substring(end))\n+            .toString();\n     }\n \n     // Centering\n     public static String chomp(String str, String sep) {\n         int idx = str.lastIndexOf(sep);\n         if (idx != -1) {\n-            return str.substring(0,idx);\n+            return str.substring(0, idx);\n         } else {\n             return str;\n         }\n      * If a \\r precedes it, then remove that too.\n      *\n      * @param str String to chop a newline from\n-     * @param String without newline on end\n      * @return String without newline\n      */\n     public static String chopNewline(String str) {\n-        int lastIdx = str.length()-1;\n+        int lastIdx = str.length() - 1;\n         char last = str.charAt(lastIdx);\n-        if(last == '\\n') {\n-            if(str.charAt(lastIdx-1) == '\\r') {\n-                lastIdx --;\n+        if (last == '\\n') {\n+            if (str.charAt(lastIdx - 1) == '\\r') {\n+                lastIdx--;\n             }\n         } else {\n             lastIdx++;\n         }\n-        return str.substring(0,lastIdx);\n+        return str.substring(0, lastIdx);\n     }\n \n \n      *\n      * @return String with escaped values\n      */\n-    // improved with code from  cybertiger@cyberiantiger.org\n-    // unicode from him, and defaul for < 32's.\n     public static String escape(String str) {\n+        // improved with code from  cybertiger@cyberiantiger.org\n+        // unicode from him, and defaul for < 32's.\n         int sz = str.length();\n-        StringBuffer buffer = new StringBuffer(2*sz);\n-        for(int i=0; i<sz; i++) {\n+        StringBuffer buffer = new StringBuffer(2 * sz);\n+        for (int i = 0; i < sz; i++) {\n             char ch = str.charAt(i);\n \n             // handle unicode\n-            if(ch > 0xfff) {\n-                buffer.append(\"\\\\u\"+Integer.toHexString(ch));\n-            } else \n-            if(ch > 0xff) {\n-                buffer.append(\"\\\\u0\"+Integer.toHexString(ch));\n-            } else \n-            if(ch > 0x7f) {\n-                buffer.append(\"\\\\u00\"+Integer.toHexString(ch));\n-            } else \n-            if(ch < 32) {\n-                switch(ch) {\n-                    case '\\b' : \n+            if (ch > 0xfff) {\n+                buffer.append(\"\\\\u\" + Integer.toHexString(ch));\n+            } else if (ch > 0xff) {\n+                buffer.append(\"\\\\u0\" + Integer.toHexString(ch));\n+            } else if (ch > 0x7f) {\n+                buffer.append(\"\\\\u00\" + Integer.toHexString(ch));\n+            } else if (ch < 32) {\n+                switch (ch) {\n+                    case '\\b' :\n                         buffer.append('\\\\');\n                         buffer.append('b');\n                         break;\n-                    case '\\n' : \n+                    case '\\n' :\n                         buffer.append('\\\\');\n                         buffer.append('n');\n                         break;\n-                    case '\\t' : \n+                    case '\\t' :\n                         buffer.append('\\\\');\n                         buffer.append('t');\n                         break;\n-                    case '\\f' : \n+                    case '\\f' :\n                         buffer.append('\\\\');\n                         buffer.append('f');\n                         break;\n-                    case '\\r' : \n+                    case '\\r' :\n                         buffer.append('\\\\');\n                         buffer.append('r');\n                         break;\n                     default :\n-                        if( ch > 0xf ) {\n-                            buffer.append(\"\\\\u00\"+Integer.toHexString(ch));\n+                        if (ch > 0xf) {\n+                            buffer.append(\"\\\\u00\" + Integer.toHexString(ch));\n                         } else {\n-                            buffer.append(\"\\\\u000\"+Integer.toHexString(ch));\n+                            buffer.append(\"\\\\u000\" + Integer.toHexString(ch));\n                         }\n                         break;\n                 }\n             } else {\n-                switch(ch) {\n-                    case '\\'' : \n+                switch (ch) {\n+                    case '\\'' :\n                         buffer.append('\\\\');\n                         buffer.append('\\'');\n                         break;\n-                    case '\"' : \n+                    case '\"' :\n                         buffer.append('\\\\');\n                         buffer.append('\"');\n                         break;\n-                    case '\\\\' : \n+                    case '\\\\' :\n                         buffer.append('\\\\');\n                         buffer.append('\\\\');\n                         break;\n      * \n      * @param str  String to repeat\n      * @param size  int number of times to repeat\n-     * @return String with repeated string\n+     * @return right padded String\n      */\n     public static String rightPad(String str, int size) {\n         return rightPad(str, size, \" \");\n      * @param str  String to pad out\n      * @param size  int size to pad to\n      * @param delim  String to pad with\n+     * @return right padded String\n      */\n     public static String rightPad(String str, int size, String delim) {\n         size = (size - str.length()) / delim.length();\n      *\n      * @param str  String to pad out\n      * @param size  int size to pad to\n+     * @return left padded String\n      */\n     public static String leftPad(String str, int size) {\n         return leftPad(str, size, \" \");\n      * @param str  String to pad out\n      * @param size  int size to pad to\n      * @param delim  String to pad with\n+     * @return left padded String\n      */\n     public static String leftPad(String str, int size, String delim) {\n         size = (size - str.length()) / delim.length();\n      * every String in the array.\n      * \n      * @param strs  the strings to remove a string from\n-     * @param delim  the string to remove at start and end\n+     * @param delimiter  the string to remove at start and end\n      * @return the stripped strings\n      */\n     public static String[] stripAll(String[] strs, String delimiter) {\n         char ch = 0;\n         char tmp = 0;\n \n-        for(int i=0; i<sz; i++) {\n+        for (int i = 0; i < sz; i++) {\n             ch = str.charAt(i);\n-            if(Character.isUpperCase(ch)) {\n+            if (Character.isUpperCase(ch)) {\n                 tmp = Character.toLowerCase(ch);\n-            } else\n-            if(Character.isTitleCase(ch)) {\n+            } else if (Character.isTitleCase(ch)) {\n                 tmp = Character.toLowerCase(ch);\n-            } else\n-            if(Character.isLowerCase(ch)) {\n-                if(whitespace) {\n+            } else if (Character.isLowerCase(ch)) {\n+                if (whitespace) {\n                     tmp = Character.toTitleCase(ch);\n                 } else {\n                     tmp = Character.toUpperCase(ch);\n         int sz = str.length();\n         StringBuffer buffer = new StringBuffer(sz);\n         boolean space = true;\n-        for(int i=0; i<sz; i++) {\n+        for (int i = 0; i < sz; i++) {\n             char ch = str.charAt(i);\n-            if(Character.isWhitespace(ch)) {\n+            if (Character.isWhitespace(ch)) {\n                 buffer.append(ch);\n                 space = true;\n-            } else\n-            if(space) {\n+            } else if (space) {\n                 buffer.append(Character.toTitleCase(ch));\n                 space = false;\n             } else {\n      * Null returns 0.\n      * \n      * @param str  the string to check\n+     * @param sub  the substring to count\n      * @return the number of occurances, 0 if the string is null\n      */\n     public static int countMatches(String str, String sub) {\n     /**\n      * Reverses an array. \n      * TAKEN FROM CollectionsUtils.\n+     * @param array  the array to reverse\n      */\n     private static void reverseArray(Object[] array) {\n         int i = 0;\n         try {\n             // And show the Error Screen.\n             ByteArrayOutputStream buf = new ByteArrayOutputStream();\n-            throwable.printStackTrace( new PrintWriter(buf, true) );\n+            throwable.printStackTrace(new PrintWriter(buf, true));\n             trace = buf.toString();\n             \n         } catch (Exception ex) {\n      *\n      * This implemmentation of the levenshtein distance algorithm \n      * is from http://www.merriampark.com/ld.htm\n+     * \n+     * @param s  the first String\n+     * @param t  the second String\n+     * @param result distance\n      */\n     public static int getLevenshteinDistance(String s, String t) {\n         int d[][]; // matrix\n         int cost; // cost\n \n         // Step 1\n-        n = s.length ();\n-        m = t.length ();\n+        n = s.length();\n+        m = t.length();\n         if (n == 0) {\n             return m;\n         }\n         if (m == 0) {\n             return n;\n         }\n-        d = new int[n+1][m+1];\n+        d = new int[n + 1][m + 1];\n \n         // Step 2\n         for (i = 0; i <= n; i++) {\n \n         // Step 3\n         for (i = 1; i <= n; i++) {\n-            s_i = s.charAt (i - 1);\n+            s_i = s.charAt(i - 1);\n \n             // Step 4\n             for (j = 1; j <= m; j++) {\n-                t_j = t.charAt (j - 1);\n+                t_j = t.charAt(j - 1);\n \n                 // Step 5\n                 if (s_i == t_j) {\n                 }\n \n                 // Step 6\n-                d[i][j] = NumberUtils.minimum(d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1] + cost);\n+                d[i][j] = NumberUtils.minimum(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n             }\n         }\n \n     }\n \n     /**\n-     * Convenient method to retrieve the full stacktrace from a given exception.     * @param t the exception to get the stacktrace from.\n+     * Convenient method to retrieve the full stacktrace from a given exception.\n+     * \n+     * @param t the exception to get the stacktrace from.\n      * @return the stacktrace from the given exception.\n      */\n     public static String getStackTrace(Throwable t) {", "timestamp": 1030792263, "metainfo": ""}