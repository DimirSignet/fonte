{"sha": "9de006cbece52cf94911112ae0a2ae900c4e9901", "log": "Layout action methods to match general lang formatting  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/VariableFormatter.java\n+++ b/src/java/org/apache/commons/lang/text/VariableFormatter.java\n         this.setEscapeCharacter(escape);\n     }\n \n-    /**\n-     * Creates a parser object for tokenizing the input data.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the occurrences of all variables in the given source array by\n+     * their current values.\n      * \n      * @param data\n-     *            the input data\n+     *            a character array with the source data\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] data) {\n+        return replace(data, 0, data == null ? 0 : data.length);\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source array by their\n+     * current values. Only the specified portion of the array will be processed.\n+     * \n+     * @param data\n+     *            a character array with the source data\n      * @param offset\n-     *            the offset in the source array\n+     *            the start offset; processing will start at this position\n      * @param length\n-     *            the length of the data to be processed\n-     * @return the parser\n-     */\n-    protected VariableParser createParser(char[] data, int offset, int length) {\n-        return new VariableParser(\n-                StrMatcher.stringMatcher(getVariablePrefix()),\n-                StrMatcher.stringMatcher(getVariableSuffix()),\n-                StrMatcher.stringMatcher(String.valueOf(getEscapeCharacter()) + getVariablePrefix()), offset, length);\n-    }\n-\n-    /**\n-     * Recursive handler for multiple levels of interpolation. This is the main interpolation method, which resolves the\n-     * values of all variable references contained in the passed in text.\n+     *            the length of the portion to be processed\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] data, int offset, int length) {\n+        Object result = doReplace(data, offset, length, null, null);\n+        return result == null ? null : result.toString();\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by\n+     * their current values.\n+     * \n+     * @param source\n+     *            the text to be interpolated; this can be an arbitrary object\n+     *            whose <code>toString()</code> method will be called\n+     * @return the result of the replace operation\n+     */\n+    public String replace(Object source) {\n+        Object result = replaceObject(source);\n+        return result == null ? null : result.toString();\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by\n+     * their current values. If the source consists only of a single variable\n+     * reference, this method directly returns the value of this variable\n+     * (which can be an arbitrary object). If the source contains multiple\n+     * variable references or static text, the return value will always be a\n+     * String with the concatenation of all these elements.\n+     * \n+     * @param source\n+     *            the text to be interpolated; this can be an arbitrary object\n+     *            whose <code>toString()</code> method will be called\n+     * @return the result of the replace operation\n+     */\n+    public Object replaceObject(Object source) {\n+        return doReplace(source, null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Recursive handler for multiple levels of interpolation. This is the main\n+     * interpolation method for interpolating objects. It is called for recursively\n+     * processing the values of resolved variables.\n+     * \n+     * @param obj\n+     *            the data to be interpolated (as object)\n+     * @param priorVariables\n+     *            keeps track of the replaced variables\n+     * @return the result of the interpolation process\n+     */\n+    private Object doReplace(Object obj, List priorVariables) {\n+        if (obj == null) {\n+            return null;\n+        }\n+        char[] data = obj.toString().toCharArray();\n+        return doReplace(data, 0, data.length, obj, priorVariables);\n+    }\n+\n+    /**\n+     * Recursive handler for multiple levels of interpolation. This is the main\n+     * interpolation method, which resolves the values of all variable references\n+     * contained in the passed in text.\n      * \n      * @param data\n      *            the text to be interpolated (as character array)\n     }\n \n     /**\n-     * Recursive handler for multiple levels of interpolation. This is the main interpolation method for interpolating\n-     * objects. It is called for recursively processing the values of resolved variables.\n-     * \n-     * @param obj\n-     *            the data to be interpolated (as object)\n-     * @param priorVariables\n-     *            keeps track of the replaced variables\n-     * @return the result of the interpolation process\n-     */\n-    private Object doReplace(Object obj, List priorVariables) {\n-        if (obj == null) {\n-            return null;\n-        }\n-        char[] data = obj.toString().toCharArray();\n-        return doReplace(data, 0, data.length, obj, priorVariables);\n-    }\n-\n+     * Gets the length from the parsed token.\n+     * \n+     * @param tok  the token\n+     * @return the length\n+     */\n     private int getLength(FieldPosition tok) {\n         return tok.getEndIndex() - tok.getBeginIndex();\n     }\n \n     /**\n-     * Replaces the occurrences of all variables in the given source array by their current values.\n+     * Creates a parser object for tokenizing the input data.\n      * \n      * @param data\n-     *            a character array with the source data\n-     * @return the result of the replace operation\n-     */\n-    public String replace(char[] data) {\n-        return replace(data, 0, data == null ? 0 : data.length);\n-    }\n-\n-    /**\n-     * Replaces the occurrences of all variables in the given source array by their current values. Only the specified\n-     * portion of the array will be processed.\n-     * \n-     * @param data\n-     *            a character array with the source data\n+     *            the input data\n      * @param offset\n-     *            the start offset; processing will start at this position\n+     *            the offset in the source array\n      * @param length\n-     *            the length of the portion to be processed\n-     * @return the result of the replace operation\n-     */\n-    public String replace(char[] data, int offset, int length) {\n-        Object result = doReplace(data, offset, length, null, null);\n-        return result == null ? null : result.toString();\n-    }\n-\n-    /**\n-     * Replaces the occurrences of all variables in the given source data by their current values.\n-     * \n-     * @param source\n-     *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n-     *            will be called\n-     * @return the result of the replace operation\n-     */\n-    public String replace(Object source) {\n-        Object result = replaceObject(source);\n-        return result == null ? null : result.toString();\n-    }\n-\n-    /**\n-     * Replaces the occurrences of all variables in the given source data by their current values. If the source\n-     * consists only of a single variable reference, this method directly returns the value of this variable (which can\n-     * be an arbitrary object). If the source contains multiple variable references or static text, the return value\n-     * will always be a String with the concatenation of all these elements.\n-     * \n-     * @param source\n-     *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n-     *            will be called\n-     * @return the result of the replace operation\n-     */\n-    public Object replaceObject(Object source) {\n-        return doReplace(source, null);\n-    }\n-\n-    /**\n-     * Resolves the specified variable. This method is called whenever a variable reference is detected in the source\n-     * text. It is passed the variable's name and must return the corresponding value. This implementation accesses the\n-     * value map using the variable's name as key. Derived classes may override this method to implement a different\n-     * strategy for resolving variables.\n+     *            the length of the data to be processed\n+     * @return the parser\n+     */\n+    protected VariableParser createParser(char[] data, int offset, int length) {\n+        return new VariableParser(\n+                StrMatcher.stringMatcher(getVariablePrefix()),\n+                StrMatcher.stringMatcher(getVariableSuffix()),\n+                StrMatcher.stringMatcher(String.valueOf(getEscapeCharacter()) + getVariablePrefix()), offset, length);\n+    }\n+\n+    /**\n+     * Resolves the specified variable. This method is called whenever a variable\n+     * reference is detected in the source text. It is passed the variable's name\n+     * and must return the corresponding value. This implementation accesses the\n+     * value map using the variable's name as key. Derived classes may override\n+     * this method to implement a different strategy for resolving variables.\n      * \n      * @param name\n      *            the name of the variable", "timestamp": 1152228660, "metainfo": ""}