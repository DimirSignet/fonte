{"sha": "5310e78952ca17521b7d5e83bfcefafa227187a5", "log": "LANG-410 - Ambiguous / confusing names in StringUtils replace* methods  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n      * StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   = \"zba\"\n      * </pre>\n      *\n-     * @see #replace(String text, String repl, String with, int max)\n+     * @see #replace(String text, String searchString, String replacement, int max)\n      * @param text  text to search and replace in, may be null\n-     * @param repl  the String to search for, may be null\n-     * @param with  the String to replace with, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace with, may be null\n      * @return the text with any replacements processed,\n      *  <code>null</code> if null String input\n      */\n-    public static String replaceOnce(String text, String repl, String with) {\n-        return replace(text, repl, with, 1);\n+    public static String replaceOnce(String text, String searchString, String replacement) {\n+        return replace(text, searchString, replacement, 1);\n     }\n \n     /**\n      * StringUtils.replace(\"aba\", \"a\", \"z\")   = \"zbz\"\n      * </pre>\n      *\n-     * @see #replace(String text, String repl, String with, int max)\n+     * @see #replace(String text, String searchString, String replacement, int max)\n      * @param text  text to search and replace in, may be null\n-     * @param repl  the String to search for, may be null\n-     * @param with  the String to replace with, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace it with, may be null\n      * @return the text with any replacements processed,\n      *  <code>null</code> if null String input\n      */\n-    public static String replace(String text, String repl, String with) {\n-        return replace(text, repl, with, -1);\n+    public static String replace(String text, String searchString, String replacement) {\n+        return replace(text, searchString, replacement, -1);\n     }\n \n     /**\n      * </pre>\n      *\n      * @param text  text to search and replace in, may be null\n-     * @param repl  the String to search for, may be null\n-     * @param with  the String to replace with, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace it with, may be null\n      * @param max  maximum number of values to replace, or <code>-1</code> if no maximum\n      * @return the text with any replacements processed,\n      *  <code>null</code> if null String input\n      */\n-    public static String replace(String text, String repl, String with, int max) {\n-        if (isEmpty(text) || isEmpty(repl) || with == null || max == 0) {\n+    public static String replace(String text, String searchString, String replacement, int max) {\n+        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n             return text;\n         }\n         int start = 0;\n-        int end = text.indexOf(repl, start);\n+        int end = text.indexOf(searchString, start);\n         if (end == -1) {\n             return text;\n         }\n-        int replLength = repl.length();\n-        int increase = with.length() - replLength;\n+        int replLength = searchString.length();\n+        int increase = replacement.length() - replLength;\n         increase = (increase < 0 ? 0 : increase);\n         increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n         StringBuffer buf = new StringBuffer(text.length() + increase);\n         while (end != -1) {\n-            buf.append(text.substring(start, end)).append(with);\n+            buf.append(text.substring(start, end)).append(replacement);\n             start = end + replLength;\n             if (--max == 0) {\n                 break;\n             }\n-            end = text.indexOf(repl, start);\n+            end = text.indexOf(searchString, start);\n         }\n         buf.append(text.substring(start));\n         return buf.toString();\n      * \n      * @param text\n      *            text to search and replace in, no-op if null\n-     * @param repl\n+     * @param searchList\n      *            the Strings to search for, no-op if null\n-     * @param with\n-     *            the Strings to replace with, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n      * @return the text with any replacements processed, <code>null</code> if\n      *         null String input\n      * @throws IndexOutOfBoundsException\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    public static String replaceEach(String text, String[] repl, String[] with) {\n-        return replaceEach(text, repl, with, false, 0);\n+    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n+        return replaceEach(text, searchList, replacementList, false, 0);\n     }\n \n     /**\n      * \n      * @param text\n      *            text to search and replace in, no-op if null\n-     * @param repl\n+     * @param searchList\n      *            the Strings to search for, no-op if null\n-     * @param with\n-     *            the Strings to replace with, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n      * @return the text with any replacements processed, <code>null</code> if\n      *         null String input\n      * @throws IllegalArgumentException\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    public static String replaceEachRepeatedly(String text, String[] repl, String[] with) {\n+    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n         // timeToLive should be 0 if not used or nothing to replace, else it's\n         // the length of the replace array\n-        int timeToLive = repl == null ? 0 : repl.length;\n-        return replaceEach(text, repl, with, true, timeToLive);\n+        int timeToLive = searchList == null ? 0 : searchList.length;\n+        return replaceEach(text, searchList, replacementList, true, timeToLive);\n     }\n \n     /**\n      * \n      * @param text\n      *            text to search and replace in, no-op if null\n-     * @param repl\n+     * @param searchList\n      *            the Strings to search for, no-op if null\n-     * @param with\n-     *            the Strings to replace with, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n+     * @param repeat if true, then replace repeatedly \n+     *       until there are no more possible replacements or timeToLive < 0\n      * @param timeToLive\n      *            if less than 0 then there is a circular reference and endless\n      *            loop\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n+    private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n \n         // mchyzer Performance note: This creates very few new objects (one major goal)\n         // let me know if there are performance requests, we can create a harness to measure\n \n-        if (text == null || text.length() == 0 || repl == null || repl.length == 0 || with == null || with.length == 0) {\n+        if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n             return text;\n         }\n \n             throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n         }\n \n-        int replLength = repl.length;\n-        int withLength = with.length;\n+        int searchLength = searchList.length;\n+        int replacementLength = replacementList.length;\n \n         // make sure lengths are ok, these need to be equal\n-        if (replLength != withLength) {\n+        if (searchLength != replacementLength) {\n             throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n-                + replLength\n+                + searchLength\n                 + \" vs \"\n-                + withLength);\n+                + replacementLength);\n         }\n \n         // keep track of which still have matches\n-        boolean[] noMoreMatchesForReplIndex = new boolean[replLength];\n+        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n \n         // index on index that the match was found\n         int textIndex = -1;\n \n         // index of replace array that will replace the search string found\n         // NOTE: logic duplicated below START\n-        for (int i = 0; i < replLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || repl[i] == null || repl[i].length() == 0 || with[i] == null) {\n+        for (int i = 0; i < searchLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n-            tempIndex = text.indexOf(repl[i]);\n+            tempIndex = text.indexOf(searchList[i]);\n \n             // see if we need to keep searching for this\n             if (tempIndex == -1) {\n         int increase = 0;\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n-        for (int i = 0; i < repl.length; i++) {\n-            int greater = with[i].length() - repl[i].length();\n+        for (int i = 0; i < searchList.length; i++) {\n+            int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }\n             for (int i = start; i < textIndex; i++) {\n                 buf.append(text.charAt(i));\n             }\n-            buf.append(with[replaceIndex]);\n-\n-            start = textIndex + repl[replaceIndex].length();\n+            buf.append(replacementList[replaceIndex]);\n+\n+            start = textIndex + searchList[replaceIndex].length();\n \n             textIndex = -1;\n             replaceIndex = -1;\n             tempIndex = -1;\n             // find the next earliest match\n             // NOTE: logic mostly duplicated above START\n-            for (int i = 0; i < replLength; i++) {\n-                if (noMoreMatchesForReplIndex[i] || repl[i] == null || repl[i].length() == 0 || with[i] == null) {\n+            for (int i = 0; i < searchLength; i++) {\n+                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                     continue;\n                 }\n-                tempIndex = text.indexOf(repl[i], start);\n+                tempIndex = text.indexOf(searchList[i], start);\n \n                 // see if we need to keep searching for this\n                 if (tempIndex == -1) {\n             return result;\n         }\n \n-        return replaceEach(result, repl, with, repeat, timeToLive - 1);\n+        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n     }\n \n     // Replace, character based", "timestamp": 1202935267, "metainfo": ""}