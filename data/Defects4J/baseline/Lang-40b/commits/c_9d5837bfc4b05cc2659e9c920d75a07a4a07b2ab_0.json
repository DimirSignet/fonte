{"sha": "9d5837bfc4b05cc2659e9c920d75a07a4a07b2ab", "log": "[LANG-362] checkstyle; javadoc; extended testing which necessitated some refactorings  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/ChoiceMetaFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ChoiceMetaFormat.java\n         super();\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer,\n-     *      java.text.FieldPosition)\n+    /**\n+     * {@inheritDoc}\n      */\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n             FieldPosition pos) {\n         throw new IllegalArgumentException(String.valueOf(obj));\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.text.Format#parseObject(java.lang.String,\n-     *      java.text.ParsePosition)\n+    /**\n+     * {@inheritDoc}\n      */\n     public Object parseObject(String source, ParsePosition pos) {\n         int start = pos.getIndex();\n--- a/src/java/org/apache/commons/lang/text/CompositeFormat.java\n+++ b/src/java/org/apache/commons/lang/text/CompositeFormat.java\n     }\n \n     /**\n-     * Uses the formatter Format instance. \n-     *\n+     * Uses the formatter Format instance.\n+     * \n+     * @param obj\n+     *            the object to format\n+     * @param toAppendTo\n+     *            the {@link StringBuffer} to append to\n+     * @param pos\n+     *            the FieldPosition to use (or ignore).\n+     * @return <code>toAppendTo</code>\n      * @see Format#format(Object, StringBuffer, FieldPosition)\n      */\n     public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n     }\n \n     /**\n-     * Uses the parser Format instance. \n-     *\n+     * Uses the parser Format instance.\n+     * \n+     * @param source\n+     *            the String source\n+     * @param pos\n+     *            the ParsePosition containing the position to parse from, will\n+     *            be updated according to parsing success (index) or failure\n+     *            (error index)\n+     * @return the parsed Object\n      * @see Format#parseObject(String, ParsePosition)\n      */\n     public Object parseObject(String source, ParsePosition pos) {\n--- a/src/java/org/apache/commons/lang/text/DateMetaFormat.java\n+++ b/src/java/org/apache/commons/lang/text/DateMetaFormat.java\n     /**\n      * Create a new DateMetaFormat.\n      * \n-     * @param locale\n+     * @param locale the Locale to use\n      */\n     public DateMetaFormat(Locale locale) {\n         super(locale);\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see org.apache.commons.lang.text.AbstractDateMetaFormat#createSubformatInstance(int)\n-     */\n+    /** {@inheritDoc} */\n     protected DateFormat createSubformatInstance(int style) {\n         return DateFormat.getDateInstance(style, getLocale());\n     }\n--- a/src/java/org/apache/commons/lang/text/DateMetaFormatSupport.java\n+++ b/src/java/org/apache/commons/lang/text/DateMetaFormatSupport.java\n \n /**\n  * date/time metaFormat support.\n+ * \n  * @see ExtendedMessageFormat\n  * @author Matt Benson\n  * @since 2.4\n     /**\n      * Create a new AbstractDateMetaFormat.\n      * \n-     * @param locale\n+     * @param locale Locale\n      */\n     public DateMetaFormatSupport(Locale locale) {\n         super();\n         this.locale = locale;\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer,\n-     *      java.text.FieldPosition)\n+    /**\n+     * {@inheritDoc}\n      */\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n             FieldPosition pos) {\n         throw new IllegalArgumentException(String.valueOf(obj));\n     }\n \n+    /**\n+     * Get the subformat name for the given object.\n+     * \n+     * @param subformat Object\n+     * @return subformat name.\n+     */\n     private String getSubformatName(Object subformat) {\n         initialize();\n         if (reverseSubformats.containsKey(subformat)) {\n         return null;\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.text.Format#parseObject(java.lang.String,\n-     *      java.text.ParsePosition)\n+    /**\n+     * {@inheritDoc}\n      */\n     public Object parseObject(String source, ParsePosition pos) {\n         int start = pos.getIndex();\n         return null;\n     }\n \n+    /**\n+     * Get the named subformat.\n+     * \n+     * @param subformat name\n+     * @return Format designated by <code>name</code>, if any\n+     */\n     private Format getSubformat(String subformat) {\n         initialize();\n         if (!styleMap.containsKey(subformat)) {\n     }\n \n     /**\n-     * Get the locale in use by this {@link DateMetaFormatSupport}.\n+     * Get the locale in use by this DateMetaFormatSupport.\n      * \n      * @return Locale\n      */\n         return locale;\n     }\n \n+    /**\n+     * Initialize this DateMetaFormatSupport.\n+     */\n     private synchronized void initialize() {\n         if (!initialized) {\n             styleMap = createStyleMap();\n      * Create a subformat for the given <code>DateFormat</code> style\n      * constant.\n      * \n-     * @param style\n+     * @param style DateFormat style constant\n      * @return a DateFormat instance.\n      */\n     protected abstract DateFormat createSubformatInstance(int style);\n      * Set whether this metaformat can parse date/time pattern formats in\n      * addition to named formats.\n      * \n-     * @param handlePatterns\n-     *            the boolean handlePatterns to set.\n+     * @param handlePatterns the boolean handlePatterns to set.\n      * @return <code>this</code> for fluent usage.\n      */\n     public DateMetaFormatSupport setHandlePatterns(boolean handlePatterns) {\n--- a/src/java/org/apache/commons/lang/text/DefaultMetaFormatFactory.java\n+++ b/src/java/org/apache/commons/lang/text/DefaultMetaFormatFactory.java\n  * \n  * @author Matt Benson\n  * @since 2.4\n- * @version $Id$\n+ * @version $Id: DefaultMetaFormatFactory.java 592077 2007-11-05 16:47:10Z\n+ *          mbenson $\n  */\n class DefaultMetaFormatFactory {\n \n     private static final String[] PATTERN_KEYS = new String[] { DATE_KEY,\n             TIME_KEY };\n \n+    /**\n+     * Ordered NameKeyedMetaFormat\n+     */\n     private static class OrderedNameKeyedMetaFormat extends NameKeyedMetaFormat {\n         private static final long serialVersionUID = -7688772075239431055L;\n \n         private List keys;\n \n+        /**\n+         * Construct a new OrderedNameKeyedMetaFormat.\n+         * \n+         * @param names String[]\n+         * @param formats Format[]\n+         */\n         private OrderedNameKeyedMetaFormat(String[] names, Format[] formats) {\n             super(createMap(names, formats));\n             this.keys = Arrays.asList(names);\n         }\n \n+        /**\n+         * Create a map from the specified key/value parameters.\n+         * \n+         * @param names keys\n+         * @param formats values\n+         * @return Map\n+         */\n         private static Map createMap(String[] names, Format[] formats) {\n             Validate.isTrue(ArrayUtils.isSameLength(names, formats));\n             HashMap result = new HashMap(names.length);\n             return result;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         protected Iterator iterateKeys() {\n             return keys.iterator();\n         }\n     /**\n      * Get a default metaformat for the specified Locale.\n      * \n-     * @param locale\n-     *            the Locale for the resulting Format instance.\n+     * @param locale the Locale for the resulting Format instance.\n      * @return Format\n      */\n     public static Format getFormat(final Locale locale) {\n                                 new TimeMetaFormat(locale) }) });\n     }\n \n+    /**\n+     * Get the default format supported by a given metaformat.\n+     * \n+     * @param metaformat Format to handle parsing.\n+     * @return the default format, if any.\n+     */\n     private static Format getDefaultFormat(Format metaformat) {\n         ParsePosition pos = new ParsePosition(0);\n         Object o = metaformat.parseObject(\"\", pos);\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n import java.util.ArrayList;\n import java.util.Locale;\n \n+import org.apache.commons.lang.StringUtils;\n import org.apache.commons.lang.Validate;\n \n /**\n  * Extends <code>MessageFormat</code> to allow pluggable/additional formatting\n  * options for embedded format elements; requires a \"meta-format\", i.e. a\n  * <code>Format</code> capable of parsing and formatting other\n- * <code>Format</code>s.\n+ * <code>Format</code>s. One shortcoming is that recursive choice formats do\n+ * not inherit knowledge of the extended formatters and are limited to those\n+ * available with <code>java.text.MessageFormat</code> (patches welcome).\n  * \n  * @author Matt Benson\n  * @since 2.4\n      * behavior identical to a <code>java.lang.MessageFormat</code> using\n      * <code>locale</code>.\n      * \n-     * @param locale\n-     *            the Locale for the resulting Format instance.\n+     * @param locale the Locale for the resulting Format instance.\n      * @return Format\n      */\n     public static Format createDefaultMetaFormat(Locale locale) {\n         return DefaultMetaFormatFactory.getFormat(locale);\n     }\n \n+    /**\n+     * Conceptual demarcation of methods to parse the pattern.\n+     */\n     private static class Parser {\n         private static final String ESCAPED_QUOTE = \"''\";\n         private static final char START_FMT = ',';\n         private static final char START_FE = '{';\n         private static final char QUOTE = '\\'';\n \n+        /**\n+         * Strip all formats from the pattern.\n+         * \n+         * @param pattern String to strip\n+         * @return stripped pattern\n+         */\n         private String stripFormats(String pattern) {\n             StringBuffer sb = new StringBuffer(pattern.length());\n             ParsePosition pos = new ParsePosition(0);\n             return sb.toString();\n         }\n \n+        /**\n+         * Insert formats back into the pattern for toPattern() support.\n+         * \n+         * @param pattern source\n+         * @param formats the Formats to insert\n+         * @param metaFormat Format to format the Formats\n+         * @return full pattern\n+         */\n         private String insertFormats(String pattern, Format[] formats,\n                 Format metaFormat) {\n             if (formats == null || formats.length == 0) {\n                     sb.append(START_FE).append(\n                             readArgumentIndex(pattern, next(pos)));\n                     if (formats[fe] != null) {\n-                        sb.append(START_FMT).append(\n-                                metaFormat.format(formats[fe]));\n+                        String formatName = metaFormat.format(formats[fe]);\n+                        if (StringUtils.isNotEmpty(formatName)) {\n+                            sb.append(START_FMT).append(formatName);\n+                        }\n                     }\n                     break;\n                 default:\n             return sb.toString();\n         }\n \n+        /**\n+         * Parse the formats from the given pattern.\n+         * \n+         * @param pattern String to parse\n+         * @param metaFormat Format to parse the Formats\n+         * @return array of parsed Formats\n+         */\n         private Format[] parseFormats(String pattern, Format metaFormat) {\n             ArrayList result = new ArrayList();\n             ParsePosition pos = new ParsePosition(0);\n                     readArgumentIndex(pattern, next(pos));\n                     if (pattern.charAt(pos.getIndex()) == START_FMT) {\n                         seekNonWs(pattern, next(pos));\n-                        result.add(metaFormat.parseObject(pattern, pos));\n-                    }\n+                    }\n+                    result.add(metaFormat.parseObject(pattern, pos));\n                     seekNonWs(pattern, pos);\n                     if (pattern.charAt(pos.getIndex()) != END_FE) {\n                         throw new IllegalArgumentException(\n             return (Format[]) result.toArray(new Format[result.size()]);\n         }\n \n+        /**\n+         * Consume whitespace from the current parse position.\n+         * \n+         * @param pattern String to read\n+         * @param pos current position\n+         */\n         private void seekNonWs(String pattern, ParsePosition pos) {\n             int len = 0;\n             char[] buffer = pattern.toCharArray();\n             } while (len > 0 && pos.getIndex() < pattern.length());\n         }\n \n+        /**\n+         * Convenience method to advance parse position by 1\n+         * \n+         * @param pos ParsePosition\n+         * @return <code>pos</code>\n+         */\n         private ParsePosition next(ParsePosition pos) {\n             pos.setIndex(pos.getIndex() + 1);\n             return pos;\n         }\n \n+        /**\n+         * Read the argument index from the current format element\n+         * \n+         * @param pattern pattern to parse\n+         * @param pos current parse position\n+         * @return argument index as string\n+         */\n         private String readArgumentIndex(String pattern, ParsePosition pos) {\n             int start = pos.getIndex();\n             for (; pos.getIndex() < pattern.length(); next(pos)) {\n                     \"Unterminated format element at position \" + start);\n         }\n \n+        /**\n+         * Consume a quoted string, adding it to <code>appendTo</code> if\n+         * specified.\n+         * \n+         * @param pattern pattern to parse\n+         * @param pos current parse position\n+         * @param appendTo optional StringBuffer to append\n+         * @param escapingOn whether to process escaped quotes\n+         * @return <code>appendTo</code>\n+         */\n         private StringBuffer appendQuotedString(String pattern,\n                 ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n             int start = pos.getIndex();\n             for (int i = pos.getIndex(); i < pattern.length(); i++) {\n                 if (escapingOn\n                         && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n-                    appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n-                            QUOTE);\n+                    appendTo.append(c, lastHold, pos.getIndex() - lastHold)\n+                            .append(QUOTE);\n                     pos.setIndex(i + ESCAPED_QUOTE.length());\n                     lastHold = pos.getIndex();\n                     continue;\n                     \"Unterminated quoted string at position \" + start);\n         }\n \n+        /**\n+         * Consume quoted string only\n+         * \n+         * @param pattern pattern to parse\n+         * @param pos current parse position\n+         * @param escapingOn whether to process escaped quotes\n+         */\n         private void getQuotedString(String pattern, ParsePosition pos,\n                 boolean escapingOn) {\n             appendQuotedString(pattern, pos, null, escapingOn);\n         }\n \n+        /**\n+         * Consume the entire format found at the current position.\n+         * \n+         * @param pattern string to parse\n+         * @param pos current parse position\n+         */\n         private void eatFormat(String pattern, ParsePosition pos) {\n             int start = pos.getIndex();\n             int depth = 1;\n     private String strippedPattern;\n \n     /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern String\n+     * @param metaFormat Format\n+     * @throws IllegalArgumentException if <code>metaFormat</code> is\n+     *             <code>null</code> or in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Format metaFormat) {\n+        this(pattern, Locale.getDefault(), metaFormat);\n+    }\n+\n+    /**\n      * Create a new ExtendedMessageFormat.\n      * \n-     * @param pattern\n-     * @param metaFormat\n-     * @throws IllegalArgumentException\n-     *             if <code>metaFormat</code> is <code>null</code> or in\n-     *             case of a bad pattern.\n-     */\n-    public ExtendedMessageFormat(String pattern, Format metaFormat) {\n+     * @param pattern String\n+     * @param locale Locale\n+     * @param metaFormat Format\n+     * @throws IllegalArgumentException if <code>metaFormat</code> is\n+     *             <code>null</code> or in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale,\n+            Format metaFormat) {\n         /*\n          * We have to do some acrobatics here: the call to the super constructor\n          * will invoke applyPattern(), but we don't want to apply the pattern\n          * our (final) applyPattern implementation, and re-call at the end of\n          * this constructor.\n          */\n-        super(pattern);\n+        super(pattern, locale);\n         setMetaFormat(metaFormat);\n         applyPattern(pattern);\n     }\n     /**\n      * Apply the specified pattern.\n      * \n-     * @param pattern\n-     *            pattern String\n+     * @param pattern String\n      */\n     public final void applyPattern(String pattern) {\n         if (metaFormat == null) {\n     }\n \n     /**\n-     * Pre-execution hook that allows subclasses to customize the behavior of\n-     * the final applyPattern implementation.\n-     * \n-     * @param pattern\n+     * Pre-execution hook by means of which a subclass can customize the\n+     * behavior of the final applyPattern implementation.\n+     * \n+     * @param pattern String\n      */\n     protected void applyPatternPre(String pattern) {\n         // noop\n     }\n \n     /**\n-     * Post-execution hook that allows subclasses to customize the behavior of\n-     * the final applyPattern implementation.\n-     * \n-     * @param pattern\n+     * Post-execution hook by means of which a subclass can customize the\n+     * behavior of the final applyPattern implementation.\n+     * \n+     * @param pattern String\n      */\n     protected void applyPatternPost(String pattern) {\n         // noop\n      * Set the meta-format. Has no effect until a subsequent call to\n      * {@link #applyPattern(String)}.\n      * \n-     * @param metaFormat\n-     *            the Format metaFormat to set.\n+     * @param metaFormat the Format metaFormat to set.\n      */\n     public synchronized void setMetaFormat(Format metaFormat) {\n         Validate.notNull(metaFormat, \"metaFormat is null\");\n--- a/src/java/org/apache/commons/lang/text/MetaFormatSupport.java\n+++ b/src/java/org/apache/commons/lang/text/MetaFormatSupport.java\n import java.util.Map;\n \n /**\n- * metaFormat support.\n+ * Support class for implementing Formats that parse/format other Formats, with\n+ * specific support for interoperability with ExtendedMessageFormat.\n  * \n  * @see ExtendedMessageFormat\n  * @author Matt Benson\n     /**\n      * Invert the specified Map.\n      * \n-     * @param map\n-     *            the Map to invert.\n+     * @param map the Map to invert.\n      * @return a new Map instance.\n-     * @throws NullPointerException\n-     *             if <code>map</code> is <code>null</code>.\n+     * @throws NullPointerException if <code>map</code> is <code>null</code>.\n      */\n     protected Map invert(Map map) {\n         Map result = new HashMap(map.size());\n     /**\n      * Find the end of the subformat.\n      * \n-     * @param source\n-     * @param pos\n+     * @param source String\n+     * @param pos current parse position\n      */\n     protected void seekFormatElementEnd(String source, ParsePosition pos) {\n         int depth = 1;\n     /**\n      * Advance the parse index by 1.\n      * \n-     * @param pos\n-     *            the ParsePosition to advance.\n+     * @param pos the ParsePosition to advance.\n      * @return <code>pos</code>\n      */\n     protected ParsePosition next(ParsePosition pos) {\n      * occurs <code>pos.getErrorIndex()</code> will contain a value >= zero,\n      * indicating the index at which the parse error occurred.\n      * \n-     * @param source\n-     *            String to parse\n-     * @param pos\n-     *            ParsePosition marking index into <code>source</code>\n+     * @param source String to parse\n+     * @param pos ParsePosition marking index into <code>source</code>\n      * @return Object parsed\n      */\n     public abstract Object parseObject(String source, ParsePosition pos);\n      * Format the specified object, appending to the given StringBuffer, and\n      * optionally respecting the specified FieldPosition.\n      * \n-     * @param obj\n-     *            the object to format\n-     * @param toAppendTo\n-     *            the StringBuffer to which the formatted object should be\n-     *            appended\n-     * @param pos\n-     *            FieldPosition associated with <code>obj</code>\n+     * @param obj the object to format\n+     * @param toAppendTo the StringBuffer to which the formatted object should\n+     *            be appended\n+     * @param pos FieldPosition associated with <code>obj</code>\n      * @return <code>toAppendTo</code>\n-     * @throws NullPointerException\n-     *             if <code>toAppendTo</code> or <code>pos</code> is\n-     *             <code>null</code>\n-     * @throws IllegalArgumentException\n-     *             if unable to format <code>obj</code>\n+     * @throws NullPointerException if <code>toAppendTo</code> or\n+     *             <code>pos</code> is <code>null</code>\n+     * @throws IllegalArgumentException if unable to format <code>obj</code>\n      */\n     public abstract StringBuffer format(Object obj, StringBuffer toAppendTo,\n             FieldPosition pos);\n--- a/src/java/org/apache/commons/lang/text/MultiFormat.java\n+++ b/src/java/org/apache/commons/lang/text/MultiFormat.java\n         /**\n          * Add a delegate format.\n          * \n-         * @param delegate\n+         * @param delegate Format\n          * @return the builder\n          */\n         public Builder add(Format delegate) {\n     /**\n      * Create a new MultiFormat.\n      * \n-     * @param delegates\n+     * @param delegates Formats\n      */\n     public MultiFormat(Format[] delegates) {\n         setDelegates(delegates);\n     }\n \n-    /*\n-     * (non-Javadoc)\n+    /**\n+     * Format <code>obj</code>; append to <code>toAppendTo</code>.\n      * \n-     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer,\n-     *      java.text.FieldPosition)\n+     * @param obj Object to format\n+     * @param toAppendTo StringBuffer to append to\n+     * @param pos FieldPosition\n+     * @return <code>toAppendTo</code>\n      */\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n             FieldPosition pos) {\n                 + obj);\n     }\n \n-    /*\n-     * (non-Javadoc)\n+    /**\n+     * Parse an object by trying each delegate.\n      * \n-     * @see java.text.Format#parseObject(java.lang.String,\n-     *      java.text.ParsePosition)\n+     * @param source string\n+     * @param pos current parse position\n+     * @return value returned from first delegate that does not encounter an\n+     *         error.\n      */\n     public Object parseObject(String source, ParsePosition pos) {\n         int start = pos.getIndex();\n     /**\n      * Set the delegates.\n      * \n-     * @param delegates\n-     *            the Format[] delegates to set.\n+     * @param delegates the Format[] delegates to set.\n      */\n     public void setDelegates(Format[] delegates) {\n         Validate.noNullElements(delegates,\n         return delegates;\n     }\n \n+    /**\n+     * Validate and return our delegates.\n+     * \n+     * @return delegate Formats, not null\n+     */\n     private Format[] getValidDelegates() {\n         Format[] result = getDelegates();\n         Validate.notEmpty(result, \"No delegate Formats configured\");\n--- a/src/java/org/apache/commons/lang/text/NameKeyedMetaFormat.java\n+++ b/src/java/org/apache/commons/lang/text/NameKeyedMetaFormat.java\n         /**\n          * Add the specified format with the specified string key.\n          * \n-         * @param key\n-         * @param format\n+         * @param key String\n+         * @param format Format\n          * @return Builder reference to this object\n          */\n         public Builder put(String key, Format format) {\n \n     /**\n      * Create a new NameKeyedMetaFormat.\n+     * \n+     * @param keyedFormats String->Format map.\n      */\n     public NameKeyedMetaFormat(Map keyedFormats) {\n         this.keyedFormats = keyedFormats;\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see org.apache.commons.lang.text.MetaFormatSupport#format(java.lang.Object,\n-     *      java.lang.StringBuffer, java.text.FieldPosition)\n+    /**\n+     * {@inheritDoc}\n      */\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n             FieldPosition pos) {\n         throw new IllegalArgumentException(\"Cannot format \" + obj);\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see org.apache.commons.lang.text.MetaFormatSupport#parseObject(java.lang.String,\n-     *      java.text.ParsePosition)\n+    /**\n+     * {@inheritDoc}\n      */\n     public Object parseObject(String source, ParsePosition pos) {\n         int start = pos.getIndex();\n--- a/src/java/org/apache/commons/lang/text/NumberMetaFormat.java\n+++ b/src/java/org/apache/commons/lang/text/NumberMetaFormat.java\n     /**\n      * Create a new NumberMetaFormat.\n      * \n-     * @param locale\n+     * @param locale Locale\n      */\n     public NumberMetaFormat(Locale locale) {\n         super();\n         this.locale = locale;\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see org.apache.commons.lang.text.AbstractMetaFormat#format(java.lang.Object,\n-     *      java.lang.StringBuffer, java.text.FieldPosition)\n+    /**\n+     * {@inheritDoc}\n      */\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n             FieldPosition pos) {\n         throw new IllegalArgumentException();\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.text.Format#parseObject(java.lang.String,\n-     *      java.text.ParsePosition)\n+    /**\n+     * {@inheritDoc}\n      */\n     public Object parseObject(String source, ParsePosition pos) {\n         int start = pos.getIndex();\n         return locale;\n     }\n \n+    /**\n+     * Initialize this NumberMetaFormat.\n+     */\n     private synchronized void initialize() {\n         if (subformats == null) {\n             subformats = new HashMap();\n--- a/src/java/org/apache/commons/lang/text/TimeMetaFormat.java\n+++ b/src/java/org/apache/commons/lang/text/TimeMetaFormat.java\n     /**\n      * Create a new NumberMetaFormat.\n      * \n-     * @param locale\n+     * @param locale Locale\n      */\n     public TimeMetaFormat(Locale locale) {\n         super(locale);\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see org.apache.commons.lang.text.AbstractDateMetaFormat#createSubformatInstance(int)\n-     */\n+    /** {@inheritDoc} */\n     protected DateFormat createSubformatInstance(int style) {\n         return DateFormat.getTimeInstance(style, getLocale());\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see org.apache.commons.lang.text.AbstractDateMetaFormat#createReverseStyleMap()\n-     */\n+    /** {@inheritDoc} */\n     protected Map createInverseStyleMap() {\n         Map invertMe = createStyleMap();\n         invertMe.remove(DEFAULT);\n-        invertMe.remove(FULL);\n+        DateFormat longDf = DateFormat.getTimeInstance(DateFormat.LONG,\n+                getLocale());\n+        DateFormat fullDf = DateFormat.getTimeInstance(DateFormat.FULL,\n+                getLocale());\n+        if (fullDf.equals(longDf)) {\n+            invertMe.remove(FULL);\n+        }\n         return invert(invertMe);\n     }\n }\n--- a/src/test/org/apache/commons/lang/text/AbstractMessageFormatTest.java\n+++ b/src/test/org/apache/commons/lang/text/AbstractMessageFormatTest.java\n  */\n package org.apache.commons.lang.text;\n \n+import java.text.ChoiceFormat;\n import java.text.DateFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.FieldPosition;\n+import java.text.Format;\n import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.text.SimpleDateFormat;\n import java.util.Calendar;\n import java.util.GregorianCalendar;\n+import java.util.Locale;\n \n import junit.framework.TestCase;\n \n  * @version $Id$\n  */\n public abstract class AbstractMessageFormatTest extends TestCase {\n-    protected static final Object[] NUMBERS = { new Double(0.1),\n+    protected static final Double[] NUMBERS = { new Double(0.1),\n             new Double(1.1), new Double(2.1) };\n \n     protected static final Object[] DATES = {\n             new GregorianCalendar(1970, Calendar.MARCH, 03, 18, 45, 50)\n                     .getTime() };\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see junit.framework.TestCase#setUp()\n+    protected Locale locale;\n+\n+    /**\n+     * {@inheritDoc}\n      */\n     protected void setUp() throws Exception {\n         super.setUp();\n-\t// tests depend on Locale.US\n-        java.util.Locale.setDefault(java.util.Locale.US);\n-    }\n-\n-    protected abstract MessageFormat createMessageFormat(String pattern);\n+        this.locale = getLocale();\n+    }\n+\n+    /**\n+     * Create a MessageFormat.\n+     * @param pattern\n+     * @param locale\n+     * @return\n+     */\n+    protected abstract MessageFormat createMessageFormat(String pattern,\n+            Locale locale);\n+\n+    /**\n+     * Get the Locale to use.\n+     * @return\n+     */\n+    protected abstract Locale getLocale();\n \n     protected void doAssertions(String expected, String pattern, Object[] args) {\n         doAssertions(expected, pattern, args, pattern);\n \n     protected void doAssertions(String expected, String pattern, Object[] args,\n             String toPattern) {\n-        MessageFormat f = createMessageFormat(pattern);\n+        MessageFormat f = createMessageFormat(pattern, locale);\n         assertEquals(expected, f.format(args));\n         assertEquals(toPattern, f.toPattern());\n     }\n \n-    public void testPlain() {\n+    protected void doAssertions(Format format, Object[] args) {\n+        doAssertions(format, args, null);\n+    }\n+\n+    protected void doAssertions(Format format, Object[] args, String formatName) {\n+        doAssertions(format, args, formatName, null);\n+    }\n+\n+    protected void doAssertions(Format format, Object[] args,\n+            String formatName, String decodeFormatName) {\n+        StringBuffer pattern = new StringBuffer();\n+        StringBuffer expected = new StringBuffer();\n+        StringBuffer decodePattern = new StringBuffer();\n+        for (int i = 0; i < args.length; i++) {\n+            pattern.append(i).append(\": {\").append(i);\n+            if (formatName != null) {\n+                pattern.append(',').append(formatName);\n+            }\n+            pattern.append(\"}; \");\n+            expected.append(i).append(\": \");\n+            if (format != null) {\n+                format.format(args[i], expected, new FieldPosition(0));\n+            } else {\n+                expected.append(String.valueOf(args[i]));\n+            }\n+            expected.append(\"; \");\n+            decodePattern.append(i).append(\": {\").append(i);\n+            if (decodeFormatName != null || formatName != null) {\n+                decodePattern.append(',').append(\n+                        decodeFormatName == null ? formatName\n+                                : decodeFormatName);\n+            }\n+            decodePattern.append(\"}; \");\n+        }\n+        doAssertions(expected.toString(), pattern.toString(), args,\n+                decodePattern.toString());\n+    }\n+\n+    public void testNoFormatElements() {\n         StringBuffer pattern = new StringBuffer();\n         for (int i = 0; i < NUMBERS.length; i++) {\n             if (i > 0) {\n                 pattern.append(\"; \");\n             }\n-            pattern.append(\"Object \").append(i).append(\": \").append(NUMBERS[i]);\n+            pattern.append(i).append(\": \").append(NUMBERS[i]);\n         }\n         String p = pattern.toString();\n-        doAssertions(p, p, NUMBERS);\n-    }\n-\n-    public void testSimple() {\n-        doAssertions(\"Object 0: 0.1; Object 1: 1.1; Object 2: 2.1\",\n-                \"Object 0: {0}; Object 1: {1}; Object 2: {2}\", NUMBERS);\n+        doAssertions(p, p, null);\n+    }\n+\n+    public void testSimpleStrings() {\n+        doAssertions(null, new Object[] { \"foo\", \"bar\", \"baz\"}, null);\n+    }\n+\n+    public void testSimpleNumbers() {\n+        doAssertions(NumberFormat.getInstance(locale), NUMBERS, null);\n+    }\n+\n+    public void testSimpleDates() {\n+        doAssertions(DateFormat.getDateTimeInstance(DateFormat.SHORT,\n+                DateFormat.SHORT, locale), DATES, null);\n     }\n \n     public void testNumber() {\n-        doAssertions(\n-                \"Number 0: 0.1; Number 1: 1.1; Number 2: 2.1\",\n-                \"Number 0: {0,number}; Number 1: {1,number}; Number 2: {2,number}\",\n-                NUMBERS);\n+        doAssertions(NumberFormat.getInstance(locale), NUMBERS, \"number\");\n     }\n \n     public void testNumberLooseFormatting() {\n-        doAssertions(\n-                \"Number 0: 0.1; Number 1: 1.1; Number 2: 2.1\",\n-                \"Number 0: {0, number }; Number 1: {1, number }; Number 2: {2, number }\",\n-                NUMBERS,\n-                \"Number 0: {0,number}; Number 1: {1,number}; Number 2: {2,number}\");\n+        doAssertions(NumberFormat.getInstance(locale), NUMBERS, \" number \",\n+                \"number\");\n     }\n \n     public void testInteger() {\n-        doAssertions(\n-                \"Number 0: 0; Number 1: 1; Number 2: 2\",\n-                \"Number 0: {0,number,integer}; Number 1: {1,number,integer}; Number 2: {2,number,integer}\",\n-                NUMBERS);\n+        doAssertions(NumberFormat.getIntegerInstance(locale), NUMBERS,\n+                \"number,integer\");\n     }\n \n     public void testIntegerLooseFormatting() {\n-        doAssertions(\n-                \"Number 0: 0; Number 1: 1; Number 2: 2\",\n-                \"Number 0: {0, number , integer }; Number 1: {1, number , integer }; Number 2: {2, number , integer }\",\n-                NUMBERS,\n-                \"Number 0: {0,number,integer}; Number 1: {1,number,integer}; Number 2: {2,number,integer}\");\n+        doAssertions(NumberFormat.getIntegerInstance(locale), NUMBERS,\n+                \" number , integer \", \"number,integer\");\n     }\n \n     public void testCurrency() {\n-        doAssertions(\n-                \"Number 0: $0.10; Number 1: $1.10; Number 2: $2.10\",\n-                \"Number 0: {0,number,currency}; Number 1: {1,number,currency}; Number 2: {2,number,currency}\",\n-                NUMBERS);\n+        doAssertions(NumberFormat.getCurrencyInstance(locale), NUMBERS,\n+                \"number,currency\");\n     }\n \n     public void testPercent() {\n-        doAssertions(\n-                \"Number 0: 10%; Number 1: 110%; Number 2: 210%\",\n-                \"Number 0: {0,number,percent}; Number 1: {1,number,percent}; Number 2: {2,number,percent}\",\n-                NUMBERS);\n+        doAssertions(NumberFormat.getPercentInstance(locale), NUMBERS,\n+                \"number,percent\");\n     }\n \n     public void testNumberPattern() {\n-        doAssertions(\n-                \"Number 0: 000.100; Number 1: 001.100; Number 2: 002.100\",\n-                \"Number 0: {0,number,#000.000}; Number 1: {1,number,#000.000}; Number 2: {2,number,#000.000}\",\n-                NUMBERS);\n+        doAssertions(new DecimalFormat(\"#000.000\", new DecimalFormatSymbols(\n+                locale)), NUMBERS, \"number,#000.000\");\n     }\n \n     public void testDate() {\n-        doAssertions(\n-                \"Date 0: Jan 1, 1970; Date 1: Feb 2, 1970; Date 2: Mar 3, 1970\",\n-                \"Date 0: {0,date}; Date 1: {1,date}; Date 2: {2,date}\", DATES);\n+        doAssertions(DateFormat.getDateInstance(DateFormat.DEFAULT, locale),\n+                DATES, \"date\");\n     }\n \n     public void testDateLooseFormatting() {\n-        doAssertions(\n-                \"Date 0: Jan 1, 1970; Date 1: Feb 2, 1970; Date 2: Mar 3, 1970\",\n-                \"Date 0: {0, date }; Date 1: {1, date }; Date 2: {2,  date  }\",\n-                DATES, \"Date 0: {0,date}; Date 1: {1,date}; Date 2: {2,date}\");\n+        doAssertions(DateFormat.getDateInstance(DateFormat.DEFAULT, locale),\n+                DATES, \" date \", \"date\");\n     }\n \n     public void testShortDate() {\n-        doAssertions(\n-                \"Date 0: 1/1/70; Date 1: 2/2/70; Date 2: 3/3/70\",\n-                \"Date 0: {0,date,short}; Date 1: {1,date,short}; Date 2: {2,date,short}\",\n-                DATES);\n+        DateFormat shortDf = DateFormat.getDateInstance(DateFormat.SHORT, locale);\n+        DateFormat defaultDf = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);\n+        doAssertions(shortDf, DATES, \"date,short\",\n+                shortDf.equals(defaultDf) ? \"date\" : \"date,short\");\n     }\n \n     public void testShortDateLooseFormatting() {\n-        doAssertions(\n-                \"Date 0: 1/1/70; Date 1: 2/2/70; Date 2: 3/3/70\",\n-                \"Date 0: {0, date , short }; Date 1: {1,  date  , short }; Date 2: {2, date ,  short  }\",\n-                DATES,\n-                \"Date 0: {0,date,short}; Date 1: {1,date,short}; Date 2: {2,date,short}\");\n+        DateFormat shortDf = DateFormat.getDateInstance(DateFormat.SHORT, locale);\n+        DateFormat defaultDf = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);\n+        doAssertions(shortDf, DATES, \" date , short \",\n+                shortDf.equals(defaultDf) ? \"date\" : \"date,short\");\n     }\n \n     public void testMediumDate() {\n-        doAssertions(\n-                \"Date 0: Jan 1, 1970; Date 1: Feb 2, 1970; Date 2: Mar 3, 1970\",\n-                \"Date 0: {0,date,medium}; Date 1: {1,date,medium}; Date 2: {2,date,medium}\",\n-                DATES, \"Date 0: {0,date}; Date 1: {1,date}; Date 2: {2,date}\");\n+        doAssertions(DateFormat.getDateInstance(DateFormat.MEDIUM, locale),\n+                DATES, \"date,medium\", \"date\");\n     }\n \n     public void testLongDate() {\n-        doAssertions(\n-                \"Date 0: January 1, 1970; Date 1: February 2, 1970; Date 2: March 3, 1970\",\n-                \"Date 0: {0,date,long}; Date 1: {1,date,long}; Date 2: {2,date,long}\",\n-                DATES);\n+        DateFormat longDf = DateFormat.getDateInstance(DateFormat.LONG, locale);\n+        DateFormat defaultDf = DateFormat.getDateInstance(DateFormat.DEFAULT,\n+                locale);\n+        doAssertions(longDf, DATES, \"date,long\",\n+                longDf.equals(defaultDf) ? \"date\" : \"date,long\");\n     }\n \n     public void testFullDate() {\n-        doAssertions(\n-                \"Date 0: Thursday, January 1, 1970; Date 1: Monday, February 2, 1970; Date 2: Tuesday, March 3, 1970\",\n-                \"Date 0: {0,date,full}; Date 1: {1,date,full}; Date 2: {2,date,full}\",\n-                DATES);\n+        DateFormat fullDf = DateFormat.getDateInstance(DateFormat.FULL, locale);\n+        DateFormat longDf = DateFormat.getDateInstance(DateFormat.LONG, locale);\n+        doAssertions(fullDf, DATES, \"date,full\",\n+                fullDf.equals(longDf) ? \"date,long\" : \"date,full\");\n     }\n \n     public void testDatePattern() {\n-        doAssertions(\n-                \"Date 0: AD1970.1; Date 1: AD1970.33; Date 2: AD1970.62\",\n-                \"Date 0: {0,date,Gyyyy.D}; Date 1: {1,date,Gyyyy.D}; Date 2: {2,date,Gyyyy.D}\",\n-                DATES);\n+        doAssertions(new SimpleDateFormat(\"Gyyyy.D\", locale), DATES,\n+                \"date,Gyyyy.D\");\n     }\n \n     public void testTime() {\n-        doAssertions(\n-                \"Time 0: 12:15:20 AM; Time 1: 12:30:35 PM; Time 2: 6:45:50 PM\",\n-                \"Time 0: {0,time}; Time 1: {1,time}; Time 2: {2,time}\", DATES);\n+        doAssertions(DateFormat.getTimeInstance(DateFormat.DEFAULT, locale),\n+                DATES, \"time\");\n     }\n \n     public void testShortTime() {\n-        doAssertions(\n-                \"Time 0: 12:15 AM; Time 1: 12:30 PM; Time 2: 6:45 PM\",\n-                \"Time 0: {0,time,short}; Time 1: {1,time,short}; Time 2: {2,time,short}\",\n-                DATES);\n+        doAssertions(DateFormat.getTimeInstance(DateFormat.SHORT, locale),\n+                DATES, \"time,short\");\n     }\n \n     public void testMediumTime() {\n-        doAssertions(\n-                \"Time 0: 12:15:20 AM; Time 1: 12:30:35 PM; Time 2: 6:45:50 PM\",\n-                \"Time 0: {0,time,medium}; Time 1: {1,time,medium}; Time 2: {2,time,medium}\",\n-                DATES, \"Time 0: {0,time}; Time 1: {1,time}; Time 2: {2,time}\");\n+        doAssertions(DateFormat.getTimeInstance(DateFormat.MEDIUM, locale),\n+                DATES, \"time,medium\", \"time\");\n     }\n \n     public void testLongTime() {\n-        DateFormat df = DateFormat.getTimeInstance(DateFormat.LONG);\n-        StringBuffer expected = new StringBuffer();\n-        for (int i = 0; i < DATES.length; i++) {\n+        doAssertions(DateFormat.getTimeInstance(DateFormat.LONG, locale),\n+                DATES, \"time,long\");\n+    }\n+\n+    public void testFullTime() {\n+        DateFormat fullDf = DateFormat.getTimeInstance(DateFormat.FULL, locale);\n+        DateFormat longDf = DateFormat.getTimeInstance(DateFormat.LONG, locale);\n+        doAssertions(fullDf, DATES, \"time,full\",\n+                fullDf.equals(longDf) ? \"time,long\" : \"time,full\");\n+    }\n+\n+    public void testTimePattern() {\n+        doAssertions(new SimpleDateFormat(\"aHms\", locale), DATES, \"date,aHms\");\n+    }\n+\n+    public void testChoice() {\n+        doAssertions(new ChoiceFormat(\"0.0#x|1.0#y|2.0#z\"), NUMBERS,\n+                \"choice,0.0#x|1.0#y|2.0#z\");\n+    }\n+\n+    public void testChoiceLooseFormatting() {\n+        doAssertions(new ChoiceFormat(\"0.0#x |1.0#y |2.0#z \"), NUMBERS,\n+                \"choice,0.0#x |1.0#y |2.0#z \");\n+    }\n+\n+    public void testChoiceRecursive() {\n+        NumberFormat nf = NumberFormat.getInstance(locale);\n+        StringBuffer choice = new StringBuffer();\n+        StringBuffer format = new StringBuffer(\"choice,\");\n+        for (int i = 0; i < NUMBERS.length; i++) {\n+            Double d = new Double(Math.floor(NUMBERS[i].doubleValue()));\n             if (i > 0) {\n-                expected.append(\"; \");\n-            }\n-            expected.append(\"Time \").append(i).append(\": \").append(\n-                    df.format(DATES[i]));\n+                choice.append('|');\n+                format.append('|');\n+            }\n+            choice.append(d).append('#').append(\n+                    nf.format(NUMBERS[i].doubleValue()));\n+            format.append(d).append('#').append('{').append(i).append('}');\n         }\n-        doAssertions(\n-                expected.toString(),\n-                \"Time 0: {0,time,long}; Time 1: {1,time,long}; Time 2: {2,time,long}\",\n-                DATES);\n-    }\n-\n-    public void testFullTime() {\n-        DateFormat df = DateFormat.getTimeInstance(DateFormat.FULL);\n-        StringBuffer expected = new StringBuffer();\n-        for (int i = 0; i < DATES.length; i++) {\n-            if (i > 0) {\n-                expected.append(\"; \");\n-            }\n-            expected.append(\"Time \").append(i).append(\": \").append(\n-                    df.format(DATES[i]));\n-        }\n-        doAssertions(\n-                expected.toString(),\n-                \"Time 0: {0,time,full}; Time 1: {1,time,full}; Time 2: {2,time,full}\",\n-                DATES,\n-                \"Time 0: {0,time,long}; Time 1: {1,time,long}; Time 2: {2,time,long}\");\n-    }\n-\n-    public void testTimePattern() {\n-        doAssertions(\n-                \"Time 0: AM01520; Time 1: PM123035; Time 2: PM184550\",\n-                \"Time 0: {0,time,aHms}; Time 1: {1,time,aHms}; Time 2: {2,time,aHms}\",\n-                DATES,\n-                \"Time 0: {0,date,aHms}; Time 1: {1,date,aHms}; Time 2: {2,date,aHms}\");\n-    }\n-\n-    public void testChoice() {\n-        String choice = \"0.0#x|1.0#y|2.0#z\";\n-        StringBuffer pattern = new StringBuffer();\n-        for (int i = 0; i < 3; i++) {\n-            if (i > 0) {\n-                pattern.append(\"; \");\n-            }\n-            pattern.append(\"Choice \").append(i).append(\": {\").append(i).append(\n-                    \",choice,\").append(choice).append(\"}\");\n-        }\n-        doAssertions(\"Choice 0: x; Choice 1: y; Choice 2: z\", pattern\n-                .toString(), NUMBERS);\n-    }\n-\n-    public void testChoiceLooseFormatting() {\n-        String choice = \"0.0#x |1.0#y |2.0#z \";\n-        StringBuffer pattern = new StringBuffer();\n-        for (int i = 0; i < 3; i++) {\n-            if (i > 0) {\n-                pattern.append(\"; \");\n-            }\n-            pattern.append(\"Choice \").append(i).append(\": {\").append(i).append(\n-                    \",choice,\").append(choice).append(\"}\");\n-        }\n-        doAssertions(\"Choice 0: x ; Choice 1: y ; Choice 2: z \", pattern\n-                .toString(), NUMBERS);\n-    }\n-\n-    public void testChoiceRecursive() {\n-        String choice = \"0.0#{0}|1.0#{1}|2.0#{2}\";\n-        StringBuffer pattern = new StringBuffer();\n-        for (int i = 0; i < 3; i++) {\n-            if (i > 0) {\n-                pattern.append(\"; \");\n-            }\n-            pattern.append(\"Choice \").append(i).append(\": {\").append(i).append(\n-                    \",choice,\").append(choice).append(\"}\");\n-        }\n-        doAssertions(\"Choice 0: 0.1; Choice 1: 1.1; Choice 2: 2.1\", pattern\n-                .toString(), NUMBERS);\n+        doAssertions(new ChoiceFormat(choice.toString()), NUMBERS, format\n+                .toString());\n     }\n }\n--- a/src/test/org/apache/commons/lang/text/ExtendedMessageFormatBaselineTest.java\n+++ b/src/test/org/apache/commons/lang/text/ExtendedMessageFormatBaselineTest.java\n import java.util.Locale;\n \n /**\n- * Baseline tests for {@link ExtendedMessageFormat}\n+ * Baseline tests for ExtendedMessageFormat\n  * \n  * @author Matt Benson\n  * @since 2.4\n  * @version $Id$\n  */\n-public class ExtendedMessageFormatBaselineTest extends AbstractMessageFormatTest {\n+public abstract class ExtendedMessageFormatBaselineTest extends\n+        AbstractMessageFormatTest {\n \n-    /*\n-     * (non-Javadoc)\n+    /**\n+     * Tests for <code>Locale.US</code>\n      * \n-     * @see org.apache.commons.lang.text.AbstractMessageFormatTest#createMessageFormat(java.lang.String)\n+     * @author mbenson\n      */\n-    protected MessageFormat createMessageFormat(String pattern) {\n-        return new ExtendedMessageFormat(pattern, ExtendedMessageFormat.createDefaultMetaFormat(Locale.US));\n+    public static class US extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.US;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.UK</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class UK extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.UK;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.GERMANY</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class DE extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.GERMANY;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.ITALY</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class IT extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.ITALY;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.JAPAN</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class JP extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.JAPAN;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.CHINA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class CN extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.CHINA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.CANADA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class CA extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.CANADA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.FRANCE</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class FR extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.FRANCE;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.KOREA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class KR extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.KOREA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.TAIWAN</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class TW extends ExtendedMessageFormatBaselineTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.TAIWAN;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    protected MessageFormat createMessageFormat(String pattern, Locale locale) {\n+        return new ExtendedMessageFormat(pattern, locale, ExtendedMessageFormat\n+                .createDefaultMetaFormat(locale));\n     }\n \n }\n--- a/src/test/org/apache/commons/lang/text/MessageFormatExtensionTest.java\n+++ b/src/test/org/apache/commons/lang/text/MessageFormatExtensionTest.java\n  */\n package org.apache.commons.lang.text;\n \n+import java.text.DateFormat;\n import java.text.FieldPosition;\n import java.text.Format;\n import java.text.MessageFormat;\n import java.text.ParsePosition;\n import java.util.Calendar;\n+import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.Locale;\n \n  * @since 2.4\n  * @version $Id$\n  */\n-public class MessageFormatExtensionTest extends AbstractMessageFormatTest {\n+public abstract class MessageFormatExtensionTest extends\n+        AbstractMessageFormatTest {\n+    /**\n+     * Tests for <code>Locale.US</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class US extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.US;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.UK</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class UK extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.UK;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.GERMANY</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class DE extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.GERMANY;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.ITALY</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class IT extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.ITALY;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.JAPAN</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class JP extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.JAPAN;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.CHINA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class CN extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.CHINA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.CANADA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class CA extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.CANADA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.FRANCE</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class FR extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.FRANCE;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.KOREA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class KR extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.KOREA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.TAIWAN</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class TW extends MessageFormatExtensionTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.TAIWAN;\n+        }\n+    }\n \n     static class ProperNameCapitalizationFormat extends Format {\n         private static final long serialVersionUID = -6081911520622186866L;\n         private static final StrMatcher MATCH = StrMatcher\n                 .charSetMatcher(\" ,.\");\n \n-        /*\n-         * (non-Javadoc)\n-         * \n-         * @see java.text.Format#format(java.lang.Object,\n-         *      java.lang.StringBuffer, java.text.FieldPosition)\n+        /**\n+         * {@inheritDoc}\n          */\n         public StringBuffer format(Object obj, StringBuffer toAppendTo,\n                 FieldPosition fpos) {\n-            char[] buffer = String.valueOf(obj).toCharArray();\n+            if (!(obj instanceof String)) {\n+                throw new IllegalArgumentException();\n+            }\n+            char[] buffer = ((String) obj).toCharArray();\n             ParsePosition pos = new ParsePosition(0);\n             while (pos.getIndex() < buffer.length) {\n                 char c = buffer[pos.getIndex()];\n         }\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see org.apache.commons.lang.text.AbstractMessageFormatTest#createMessageFormat(java.lang.String)\n-     */\n-    protected MessageFormat createMessageFormat(String pattern) {\n-        return new ExtendedMessageFormat(pattern, new MultiFormat.Builder()\n-                .add(ExtendedMessageFormat.createDefaultMetaFormat(Locale.US)).add(\n+    /**\n+     * {@inheritDoc}\n+     */\n+    protected MessageFormat createMessageFormat(String pattern, Locale locale) {\n+        return new ExtendedMessageFormat(pattern, locale,\n+                new MultiFormat.Builder().add(\n                         new NameKeyedMetaFormat.Builder().put(\"properName\",\n                                 new ProperNameCapitalizationFormat())\n-                                .toNameKeyedMetaFormat()).toMultiFormat());\n+                                .toNameKeyedMetaFormat()).add(\n+                        ExtendedMessageFormat.createDefaultMetaFormat(locale))\n+                        .toMultiFormat());\n     }\n \n     public void testProperName() {\n     }\n \n     public void testMixed() {\n-        doAssertions(\"John Q. Public was born on Thursday, January 1, 1970.\",\n-                \"{0,properName} was born on {1,date,full}.\", new Object[] {\n+        StringBuffer expected = new StringBuffer(\"John Q. Public was born on \");\n+        Date dob = new GregorianCalendar(1970, Calendar.JANUARY, 01, 0, 15, 20)\n+                .getTime();\n+        DateFormat longDf = DateFormat.getDateInstance(DateFormat.LONG, locale);\n+        longDf.format(dob, expected, new FieldPosition(0));\n+        expected.append('.');\n+        String pattern = \"{0,properName} was born on {1,date,long}.\";\n+        StringBuffer toPattern = new StringBuffer(pattern);\n+        if (longDf.equals(DateFormat.getDateInstance(DateFormat.DEFAULT, locale))) {\n+            int idx = pattern.indexOf(\",long\");\n+            toPattern.delete(idx, idx + \",long\".length());\n+        }\n+        doAssertions(expected.toString(),\n+                pattern, new Object[] {\n                         \"john q. public\",\n                         new GregorianCalendar(1970, Calendar.JANUARY, 01, 0,\n-                                15, 20).getTime() });\n-    }\n+                                15, 20).getTime() }, toPattern.toString());\n+    }\n+\n }\n--- a/src/test/org/apache/commons/lang/text/MessageFormatTest.java\n+++ b/src/test/org/apache/commons/lang/text/MessageFormatTest.java\n  * @since 2.4\n  * @version $Id$\n  */\n-public class MessageFormatTest extends AbstractMessageFormatTest {\n-    /*\n-     * (non-Javadoc)\n+public abstract class MessageFormatTest extends AbstractMessageFormatTest {\n+\n+    /**\n+     * Tests for <code>Locale.US</code>\n      * \n-     * @see org.apache.commons.lang.text.AbstractMessageFormatTest#createMessageFormat(java.lang.String)\n+     * @author mbenson\n      */\n-    protected MessageFormat createMessageFormat(String pattern) {\n-        return new MessageFormat(pattern, Locale.US);\n+    public static class US extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.US;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.UK</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class UK extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.UK;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.GERMANY</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class DE extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.GERMANY;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.ITALY</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class IT extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.ITALY;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.JAPAN</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class JP extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.JAPAN;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.CHINA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class CN extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.CHINA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.CANADA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class CA extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.CANADA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.FRANCE</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class FR extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.FRANCE;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.KOREA</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class KR extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.KOREA;\n+        }\n+    }\n+\n+    /**\n+     * Tests for <code>Locale.TAIWAN</code>\n+     * \n+     * @author mbenson\n+     */\n+    public static class TW extends MessageFormatTest {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected Locale getLocale() {\n+            return Locale.TAIWAN;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    protected MessageFormat createMessageFormat(String pattern, Locale locale) {\n+        return new MessageFormat(pattern, locale);\n     }\n }\n--- a/src/test/org/apache/commons/lang/text/TextTestSuite.java\n+++ b/src/test/org/apache/commons/lang/text/TextTestSuite.java\n         suite.addTest(StrSubstitutorTest.suite());\n         suite.addTest(StrTokenizerTest.suite());\n         suite.addTestSuite(MultiFormatTest.class);\n-        suite.addTestSuite(MessageFormatTest.class);\n-        suite.addTestSuite(ExtendedMessageFormatBaselineTest.class);\n-        suite.addTestSuite(MessageFormatExtensionTest.class);\n+        suite.addTestSuite(MessageFormatTest.US.class);\n+        suite.addTestSuite(MessageFormatTest.UK.class);\n+        suite.addTestSuite(MessageFormatTest.DE.class);\n+        suite.addTestSuite(MessageFormatTest.IT.class);\n+        suite.addTestSuite(MessageFormatTest.JP.class);\n+        suite.addTestSuite(MessageFormatTest.CA.class);\n+        suite.addTestSuite(MessageFormatTest.CN.class);\n+        suite.addTestSuite(MessageFormatTest.FR.class);\n+        suite.addTestSuite(MessageFormatTest.KR.class);\n+        suite.addTestSuite(MessageFormatTest.TW.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.US.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.UK.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.DE.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.IT.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.JP.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.CA.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.CN.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.FR.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.KR.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.TW.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.US.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.UK.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.DE.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.IT.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.JP.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.CA.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.CN.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.FR.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.KR.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.TW.class);\n         return suite;\n     }\n ", "timestamp": 1196184455, "metainfo": ""}