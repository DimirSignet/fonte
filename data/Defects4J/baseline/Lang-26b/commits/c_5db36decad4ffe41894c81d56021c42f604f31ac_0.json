{"sha": "5db36decad4ffe41894c81d56021c42f604f31ac", "log": "Javadoc fixes and a refactoring to use StringUtils.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/enum/Enum.java\n+++ b/src/java/org/apache/commons/lang/enum/Enum.java\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import org.apache.commons.lang.StringUtils;\n /**\n- * Abstract superclass for type-safe enums.\n- * <p>\n- * One feature of the C programming language lacking in Java is enumerations. The\n+ * <p>Abstract superclass for type-safe enums.</p>\n+ *\n+ * <p>One feature of the C programming language lacking in Java is enumerations. The\n  * C implementation based on ints was poor and open to abuse. The original Java\n  * recommendation and most of the JDK also uses int constants. It has been recognised\n  * however that a more robust type-safe class-based solution can be designed. This\n- * class follows the basic Java type-safe enumeration pattern.\n- * <p>\n- * <em>NOTE:</em>Due to the way in which Java ClassLoaders work, comparing Enum objects\n+ * class follows the basic Java type-safe enumeration pattern.</p>\n+ *\n+ * <p><em>NOTE:</em>Due to the way in which Java ClassLoaders work, comparing Enum objects\n  * should always be done using the equals() method, not ==. The equals() method will\n- * try == first so in most cases the effect is the same.\n+ * try == first so in most cases the effect is the same.</p>\n  * \n  * <h4>Simple Enums</h4>\n- * To use this class, it must be subclassed. For example:\n+ *\n+ * <p>To use this class, it must be subclassed. For example:</p>\n  *\n  * <pre>\n  * public final class ColorEnum extends Enum {\n  *   }\n  * }\n  * </pre>\n- * <p>\n- * As shown, each enum has a name. This can be accessed using <code>getName</code>.\n- * <p>\n- * The <code>getEnum</code> and <code>iterator</code> methods are recommended. \n+ *\n+ * <p>As shown, each enum has a name. This can be accessed using <code>getName</code>.</p>\n+ *\n+ * <p>The <code>getEnum</code> and <code>iterator</code> methods are recommended.\n  * Unfortunately, Java restrictions require these to be coded as shown in each subclass.\n- * An alternative choice is to use the {@link EnumUtils} class.\n+ * An alternative choice is to use the {@link EnumUtils} class.</p>\n  * \n  * <h4>Subclassed Enums</h4>\n- * A hierarchy of Enum classes can be built. In this case, the superclass is \n+ * <p>A hierarchy of Enum classes can be built. In this case, the superclass is\n  * unaffected by the addition of subclasses (as per normal Java). The subclasses\n- * may add additional Enum constants <i>of the type of the superclass</i>. The\n+ * may add additional Enum constants <em>of the type of the superclass</em>. The\n  * query methods on the subclass will return all of the Enum constants from the\n- * superclass and subclass.\n+ * superclass and subclass.</p>\n  *\n  * <pre>\n  * public class ExtraColorEnum extends ColorEnum {\n  *   }\n  * }\n  * </pre>\n- * \n- * This example will return RED, GREEN, BLUE, YELLOW from the List and iterator \n+ *\n+ * <p>This example will return RED, GREEN, BLUE, YELLOW from the List and iterator\n  * methods in that order. The RED, GREEN and BLUE instances will be the same (==) \n  * as those from the superclass ColorEnum. Note that YELLOW is declared as a\n- * ColorEnum and not an ExtraColorEnum.\n+ * ColorEnum and not an ExtraColorEnum.</p>\n  * \n  * <h4>Functional Enums</h4>\n- * The enums can have functionality by using anonymous inner classes\n- * [Effective Java, Bloch01]:\n+ *\n+ * <p>The enums can have functionality by using anonymous inner classes\n+ * [Effective Java, Bloch01]:</p>\n  * \n  * <pre>\n  * public abstract class OperationEnum extends Enum {\n  *   }\n  * }\n  * </pre>\n- * <p>\n- * <em>NOTE:</em> This class originated in the Jakarta Avalon project.\n- * </p>\n+ *\n+ * <p><em>NOTE:</em> This class originated in the Jakarta Avalon project.</p>\n  *\n  * @author Stephen Colebourne\n  * @author Chris Webb\n  * @author Mike Bowler\n  * @since 1.0\n- * @version $Id: Enum.java,v 1.10 2003/02/06 20:13:07 scolebourne Exp $\n+ * @version $Id: Enum.java,v 1.11 2003/07/14 22:20:20 bayard Exp $\n  */\n public abstract class Enum implements Comparable, Serializable {\n     // After discussion, the default size for HashMaps is used, as the\n     // sizing algorithm changes across the JDK versions\n     \n     /**\n-     * An empty map, as JDK1.2 didn't have an empty map\n+     * An empty <code>Map</code>, as JDK1.2 didn't have an empty map.\n      */\n     private static final Map EMPTY_MAP = Collections.unmodifiableMap(new HashMap(0));\n     /**\n-     * Map, key of class name, value of Entry.\n+     * <code>Map</code>, key of class name, value of <code>Entry</code>.\n      */\n     private static final Map cEnumClasses = new HashMap();\n     /**\n     private final String iName;\n \n     /**\n-     * Enable the iterator to retain the source code order\n+     * <p>Enable the iterator to retain the source code order.</p>\n      */\n     private static class Entry {\n-        /** Map of Enum name to Enum */\n+        /**\n+         * Map of Enum name to Enum.\n+         */\n         final Map map = new HashMap();\n-        /** List of Enums in source code order */\n+        /**\n+         * List of Enums in source code order.\n+         */\n         final List list = new ArrayList(25);\n \n         /**\n-         * Restrictive constructor\n+         * <p>Restrictive constructor.</p>\n          */\n         private Entry() {\n         }\n     }\n \n     /**\n-     * Constructor to add a new named item to the enumeration.\n+     * <p>Constructor to add a new named item to the enumeration.</p>\n      *\n      * @param name  the name of the enum object\n-     * @throws IllegalArgumentException if the name is null or a blank string\n+     * @throws IllegalArgumentException if the name is <code>null</code>\n+     *  or a blank string\n      */\n     protected Enum(String name) {\n         super();\n-        if (name == null || name.length() == 0) {\n+\n+        if (StringUtils.isEmpty(name)) {\n             throw new IllegalArgumentException(\"The Enum name must not be empty or null\");\n         }\n         iName = name;\n     }\n \n     /**\n-     * Handle the deserialization of the class to ensure that multiple\n-     * copies are not wastefully created, or illegal enum types created.\n+     * <p>Handle the deserialization of the class to ensure that multiple\n+     * copies are not wastefully created, or illegal enum types created.</p>\n+     *\n      * @return the resolved object\n      */\n     protected Object readResolve() {\n     //--------------------------------------------------------------------------------\n \n     /**\n-     * Gets an Enum object by class and name.\n-     * \n-     * @param enumClass  the class of the Enum to get, must not be null\n-     * @param name  the name of the Enum to get, may be null\n+     * <p>Gets an <code>Enum</code> object by class and name.</p>\n+     * \n+     * @param enumClass  the class of the Enum to get, must not\n+     *  be <code>null</code>\n+     * @param name  the name of the <code>Enum</code> to get,\n+     *  may be <code>null</code>\n      * @return the enum object, or null if the enum does not exist\n-     * @throws IllegalArgumentException if the enum class is null\n+     * @throws IllegalArgumentException if the enum class\n+     *  is <code>null</code>\n      */\n     protected static Enum getEnum(Class enumClass, String name) {\n         Entry entry = getEntry(enumClass);\n     }\n \n     /**\n-     * Gets the Map of Enum objects by name using the Enum class.\n-     * If the requested class has no enum objects an empty Map is returned.\n-     * \n-     * @param enumClass  the class of the Enum to get, must not be null\n+     * <p>Gets the <code>Map</code> of <code>Enum</code> objects by\n+     * name using the <code>Enum</code> class.</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>Map</code> is returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n      * @return the enum object Map\n-     * @throws IllegalArgumentException if the enum class is null\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n      * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n      */\n     protected static Map getEnumMap(Class enumClass) {\n     }\n \n     /**\n-     * Gets the List of Enum objects using the Enum class.\n-     * The list is in the order that the objects were created (source code order).\n-     * If the requested class has no enum objects an empty List is returned.\n-     * \n-     * @param enumClass  the class of the Enum to get, must not be null\n+     * <p>Gets the <code>List</code> of <code>Enum</code> objects using the\n+     * <code>Enum</code> class.</p>\n+     *\n+     * <p>The list is in the order that the objects were created (source code order).\n+     * If the requested class has no enum objects an empty <code>List</code> is\n+     * returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n      * @return the enum object Map\n-     * @throws IllegalArgumentException if the enum class is null\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n      * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n      */\n     protected static List getEnumList(Class enumClass) {\n     }\n \n     /**\n-     * Gets an iterator over the Enum objects in an Enum class.\n-     * The iterator is in the order that the objects were created (source code order).\n-     * If the requested class has no enum objects an empty Iterator is returned.\n-     * \n-     * @param enumClass  the class of the Enum to get, must not be null\n+     * <p>Gets an <code>Iterator</code> over the <code>Enum</code> objects in\n+     * an <code>Enum</code> class.</p>\n+     *\n+     * <p>The <code>Iterator</code> is in the order that the objects were\n+     * created (source code order). If the requested class has no enum\n+     * objects an empty <code>Iterator</code> is returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n      * @return an iterator of the Enum objects\n-     * @throws IllegalArgumentException if the enum class is null\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n      * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n      */\n     protected static Iterator iterator(Class enumClass) {\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets an entry from the map of Enums.\n-     * \n-     * @param enumClass  the class of the Enum to get\n+     * <p>Gets an <code>Entry</code> from the map of Enums.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n      * @return the enum entry\n      */\n     private static Entry getEntry(Class enumClass) {\n     }\n     \n     /**\n-     * Creates an entry for storing the Enums.\n-     * This accounts for subclassed Enums.\n-     * \n-     * @param enumClass  the class of the Enum to get\n+     * <p>Creates an <code>Entry</code> for storing the Enums.</p>\n+     *\n+     * <p>This accounts for subclassed Enums.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n      * @return the enum entry\n      */\n     private static Entry createEntry(Class enumClass) {\n     }\n     \n     /**\n-     * Convert a class to the actual common enum class.\n-     * This accounts for anonymous inner classes.\n+     * <p>Convert a class to the actual common enum class.</p>\n+     *\n+     * <p>This accounts for anonymous inner classes.</p>\n      * \n      * @param cls  the class to get the name for\n      * @return the class name\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Retrieve the name of this Enum item, set in the constructor.\n+     * <p>Retrieve the name of this Enum item, set in the constructor.</p>\n      * \n      * @return the <code>String</code> name of this Enum item\n      */\n     }\n \n     /**\n-     * Tests for equality. Two Enum objects are considered equal\n+     * <p>Tests for equality.</p>\n+     *\n+     * <p>Two Enum objects are considered equal\n      * if they have the same class names and the same names.\n-     * Identity is tested for first, so this method usually runs fast.\n+     * Identity is tested for first, so this method usually runs fast.</p>\n      *\n      * @param other  the other object to compare for equality\n-     * @return true if the Enums are equal\n+     * @return <code>true</code> if the Enums are equal\n      */\n     public final boolean equals(Object other) {\n         if (other == this) {\n     }\n \n     /**\n-     * Returns a suitable hashCode for the enumeration.\n+     * <p>Returns a suitable hashCode for the enumeration.</p>\n      *\n      * @return a hashcode based on the name\n      */\n     }\n \n     /**\n-     * Tests for order. The default ordering is alphabetic by name, but this\n-     * can be overridden by subclasses.\n+     * <p>Tests for order.</p>\n+     *\n+     * <p>The default ordering is alphabetic by name, but this\n+     * can be overridden by subclasses.</p>\n      * \n      * @see java.lang.Comparable#compareTo(Object)\n      * @param other  the other object to compare to\n-     * @return -ve if this is less than the other object, +ve if greater than, 0 of equal\n+     * @return -ve if this is less than the other object, +ve if greater\n+     *  than, <code>0</code> of equal\n      * @throws ClassCastException if other is not an Enum\n-     * @throws NullPointerException if other is null\n+     * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n         return iName.compareTo(((Enum) other).iName);\n     }\n \n     /**\n-     * Human readable description of this Enum item. For use when debugging.\n+     * <p>Human readable description of this Enum item.</p>\n+     *\n+     * <p>For use when debugging.</p>\n      * \n      * @return String in the form <code>type[name]</code>, for example:\n      * <code>Color[Red]</code>. Note that the package name is stripped from\n--- a/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n+++ b/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n import java.util.LinkedList;\n import java.util.List;\n import java.util.StringTokenizer;\n-\n import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.StringUtils;\n import org.apache.commons.lang.SystemUtils;\n \n /**\n  * @author Stephen Colebourne\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @since 1.0\n- * @version $Id: ExceptionUtils.java,v 1.24 2003/05/31 17:16:11 ggregory Exp $\n+ * @version $Id: ExceptionUtils.java,v 1.25 2003/07/14 22:22:46 bayard Exp $\n  */\n public class ExceptionUtils {\n     \n     /**\n-     * Used when printing stack frames to denote the start of a\n-     * wrapped exception.  Package private for accessibility by test\n-     * suite.\n+     * <p>Used when printing stack frames to denote the start of a\n+     * wrapped exception.</p>\n+     *\n+     * <p>Package private for accessibility by test suite.</p>\n      */\n     static final String WRAPPED_MARKER = \" [wrapped] \";\n \n     /**\n-     * The names of methods commonly used to access a wrapped\n-     * exception.\n+     * <p>The names of methods commonly used to access a wrapped\n+     * exception.</p>\n      */\n     protected static String[] CAUSE_METHOD_NAMES = {\n         \"getCause\",\n     };\n \n     /**\n-     * Constructs a new <code>ExceptionUtils</code>. Protected to\n-     * discourage instantiation.\n+     * <p>Constructs a new <code>ExceptionUtils</code>. Protected to\n+     * discourage instantiation.</p>\n      */\n     protected ExceptionUtils() {\n     }\n      * <p>Adds to the list of method names used in the search for <code>Throwable</code>\n      * objects.</p>\n      * \n-     * @param methodName  the methodName to add to the list, null and empty strings are ignored\n+     * @param methodName  the methodName to add to the list, <code>null</code>\n+     *  and empty strings are ignored\n      */\n     public static void addCauseMethodName(String methodName) {\n-        if (methodName != null && methodName.length() > 0) {\n+      if(StringUtils.isNotEmpty(methodName)) {\n             List list = new ArrayList(Arrays.asList(CAUSE_METHOD_NAMES));\n             list.add(methodName);\n             CAUSE_METHOD_NAMES = (String[]) list.toArray(new String[list.size()]);\n      * <code>Throwable</code> object. This will pick up most wrapping exceptions,\n      * including those from JDK 1.4, and\n      * {@link org.apache.commons.lang.exception.NestableException NestableException}.\n-     * The method names can be added to using {@link #addCauseMethodName(String)}.\n-     * The default list searched for are:</p>\n+     * The method names can be added to using {@link #addCauseMethodName(String)}.</p>\n+     *\n+     * <p>The default list searched for are:</p>\n      * <ul>\n-     * <li><code>getCause()</code>\n-     * <li><code>getNextException()</code>\n-     * <li><code>getTargetException()</code>\n-     * <li><code>getException()</code>\n-     * <li><code>getSourceException()</code>\n-     * <li><code>getRootCause()</code>\n-     * <li><code>getCausedByException()</code>\n-     * <li><code>getNested()</code>\n+     *  <li><code>getCause()</code></li>\n+     *  <li><code>getNextException()</code></li>\n+     *  <li><code>getTargetException()</code></li>\n+     *  <li><code>getException()</code></li>\n+     *  <li><code>getSourceException()</code></li>\n+     *  <li><code>getRootCause()</code></li>\n+     *  <li><code>getCausedByException()</code></li>\n+     *  <li><code>getNested()</code></li>\n      * </ul>\n      * \n      * <p>In the absence of any such method, the object is inspected for a\n      *\n      * @param throwable The exception to introspect for a cause.\n      * @return The cause of the <code>Throwable</code>.\n-     * @throws NullPointerException if the throwable is null\n+     * @throws NullPointerException if the throwable is <code>null</code>\n      */\n     public static Throwable getCause(Throwable throwable) {\n         return getCause(throwable, CAUSE_METHOD_NAMES);\n      *\n      * @param throwable The exception to introspect for a cause.\n      * @return The cause of the <code>Throwable</code>.\n-     * @throws NullPointerException if the method names array is null or contains null\n-     * @throws NullPointerException if the throwable is null\n+     * @throws NullPointerException if the method names array is <code>null</code>\n+     *  or contains <code>null</code>\n+     * @throws NullPointerException if the throwable is <code>null</code>\n      */\n     public static Throwable getCause(Throwable throwable, String[] methodNames) {\n         Throwable cause = getCauseUsingWellKnownTypes(throwable);\n      * @param throwable  the exception to examine\n      * @param methodName  the name of the method to find and invoke\n      * @return The wrapped exception, or <code>null</code> if not\n-     * found.\n+     *  found.\n      */\n     private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {\n         Method method = null;\n      * @param throwable  the exception to examine\n      * @param fieldName  the name of the attribute to examine\n      * @return The wrapped exception, or <code>null</code> if not\n-     * found.\n+     *  found.\n      */\n     private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {\n         Field field = null;\n     }\n \n     /**\n-     * Prints a compact stack trace for the root cause of a throwable.\n-     * The compact stack trace starts with the root cause and prints\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n      * stack frames up to the place where it was caught and wrapped.\n      * Then it prints the wrapped exception and continues with stack frames\n-     * until the wrapper exception is caught and wrapped again, etc.\n-     * <p>\n-     * The method is equivalent to t.printStackTrace() for throwables\n-     * that don't have nested causes.\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The method is equivalent to t.printStackTrace() for throwables\n+     * that don't have nested causes.</p>\n      */\n     public static void printRootCauseStackTrace(Throwable t, PrintStream stream) {\n         String trace[] = getRootCauseStackTrace(t);\n     }\n \n     /**\n-     * Equivalent to <code>printRootCauseStackTrace(t, System.err);</code>\n+     * <p>Equivalent to <code>printRootCauseStackTrace(t, System.err);</code></p>\n      * \n      * @see #printRootCauseStackTrace(Throwable,PrintWriter)\n      */\n     }\n \n     /**\n-     * Same as {@link #printRootCauseStackTrace(Throwable,java.io.PrintStream)}, except it takes\n-     * a PrintWriter as an argument.\n+     * <p>Same as {@link #printRootCauseStackTrace(Throwable,java.io.PrintStream)},\n+     * except it takes a <code>PrintWriter</code> as an argument.</p>\n      */\n     public static void printRootCauseStackTrace(Throwable t, PrintWriter writer) {\n         String trace[] = getRootCauseStackTrace(t);\n     }\n \n     /**\n-     * Creates a compact stack trace for the root cause of the supplied \n-     * <code>Throwable</code>.\n+     * <p>Creates a compact stack trace for the root cause of the supplied\n+     * <code>Throwable</code>.</p>\n      */\n     public static String[] getRootCauseStackTrace(Throwable t) {\n         Throwable throwables[] = getThrowables(t);\n     }\n \n     /**\n-     * Removes common frames from the cause trace given the two stack traces.\n-     * \n-     * @param causeFrames   stack trace of a cause throwable\n+     * <p>Removes common frames from the cause trace given the two stack traces.</p>\n+     * \n+     * @param causeFrames  stack trace of a cause throwable\n      * @param wrapperFrames stack trace of a wrapper throwable \n      */\n     public static void removeCommonFrames(List causeFrames, List wrapperFrames) {\n     }\n \n     /**\n-     * A convenient way of extracting the stack trace from an\n-     * exception.\n+     * <p>A convenient way of extracting the stack trace from an\n+     * exception.</p>\n      *\n      * @param t The <code>Throwable</code>.\n      * @return The stack trace as generated by the exception's\n-     * <code>printStackTrace(PrintWriter)</code> method.\n+     *  <code>printStackTrace(PrintWriter)</code> method.\n      */\n     public static String getStackTrace(Throwable t) {\n         StringWriter sw = new StringWriter();\n     }\n \n     /**\n-     * A way to get the entire nested stack-trace of an throwable.\n+     * <p>A way to get the entire nested stack-trace of an throwable.</p>\n      *\n      * @param t The <code>Throwable</code>.\n      * @return The nested stack trace, with the root cause first.\n     }\n \n     /**\n-     * Returns whether a <code>Throwable </code> is considered nested or not.\n-     *\n-     * @param t The <code>Throwable</code>.\n-     * @return boolean true/false\n+     * <p>Returns whether a <code>Throwable</code> is considered nested\n+     * or not.</p>\n+     *\n+     * @param throwable  The <code>Throwable</code>.\n+     * @return boolean <code>true</code> if nested otherwise <code>false</code>\n      */\n     public static boolean isNestedThrowable(Throwable throwable) {\n         if(throwable == null) {\n     }\n \n     /**\n-     * Captures the stack trace associated with the specified\n+     * <p>Captures the stack trace associated with the specified\n      * <code>Throwable</code> object, decomposing it into a list of\n-     * stack frames.\n+     * stack frames.</p>\n      *\n      * @param t The <code>Throwable</code>.\n      * @return  An array of strings describing each stack frame.\n     }\n \n     /**\n-     * Functionality shared between the\n+     * <p>Functionality shared between the\n      * <code>getStackFrames(Throwable)</code> methods of this and the\n      * {@link org.apache.commons.lang.exception.NestableDelegate}\n-     * classes.\n+     * classes.</p>\n      */\n     static String[] getStackFrames(String stackTrace) {\n         String linebreak = SystemUtils.LINE_SEPARATOR;\n     }\n \n     /**\n-     * Produces a List of stack frames - the message is not included.\n-     * This works in most cases - it will only fail if the exception message\n-     * contains a line that starts with:  \"   at\".\n+     * <p>Produces a <code>List</code> of stack frames - the message\n+     * is not included.</p>\n+     *\n+     * <p>This works in most cases - it will only fail if the exception\n+     * message contains a line that starts with:\n+     * <code>&quot;&nbsp;&nbsp;&nbsp;at&quot;.</code></p>\n      * \n      * @param t is any throwable\n      * @return List of stack frames\n     }\n     \n     /**\n-     * Checks if the Throwable class has a <code>getCause</code> method.\n+     * <p>Checks if the Throwable class has a <code>getCause</code> method.</p>\n      */\n     public static boolean isThrowableNested() {\n         return (getCauseMethod != null);", "timestamp": 1058221366, "metainfo": ""}