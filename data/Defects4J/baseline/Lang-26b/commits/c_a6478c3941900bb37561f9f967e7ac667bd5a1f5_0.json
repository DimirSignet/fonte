{"sha": "a6478c3941900bb37561f9f967e7ac667bd5a1f5", "log": "HashCodeBuilder throws java.lang.StackOverflowError when an object contains a cycle. https://issues.apache.org/jira/browse/LANG-279  ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.lang.builder;\n \n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n-import java.util.Collection;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n \n /**\n- * <p>Assists in implementing {@link Object#hashCode()} methods.</p>\n- *\n- * <p> This class enables a good <code>hashCode</code> method to be built for any class. It\n- * follows the rules laid out in the book\n- * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\n- * by Joshua Bloch. Writing a good <code>hashCode</code> method is actually quite\n- * difficult. This class aims to simplify the process.</p>\n- *\n- * <p>All relevant fields from the object should be included in the\n- * <code>hashCode</code> method. Derived fields may be excluded. In general, any\n- * field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n- * method.</p>\n- *\n- * <p>To use this class write code as follows:</p>\n+ * <p>\n+ * Assists in implementing {@link Object#hashCode()} methods.\n+ * </p>\n+ * \n+ * <p>\n+ * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\n+ * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\n+ * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\n+ * </p>\n+ * \n+ * <p>\n+ * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\n+ * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n+ * method.\n+ * </p>\n+ * \n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ * \n  * <pre>\n  * public class Person {\n  *   String name;\n  *   }\n  * }\n  * </pre>\n- *\n- * <p>If required, the superclass <code>hashCode()</code> can be added\n- * using {@link #appendSuper}.</p>\n- *\n- * <p>Alternatively, there is a method that uses reflection to determine\n- * the fields to test. Because these fields are usually private, the method,\n- * <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code> to\n- * change the visibility of the fields. This will fail under a security manager,\n- * unless the appropriate permissions are set up correctly. It is also slower\n- * than testing explicitly.</p>\n- *\n- * <p>A typical invocation for this method would look like:</p>\n+ * \n+ * <p>\n+ * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\n+ * </p>\n+ * \n+ * <p>\n+ * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\n+ * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\n+ * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\n+ * are set up correctly. It is also slower than testing explicitly.\n+ * </p>\n+ * \n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * \n  * <pre>\n  * public int hashCode() {\n  *   return HashCodeBuilder.reflectionHashCode(this);\n  * }\n  * </pre>\n- *\n+ * \n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @author Pete Gieser\n  * @version $Id$\n  */\n public class HashCodeBuilder {\n-\n-    /**\n-     * Constant to use in building the hashCode.\n-     */\n-    private final int iConstant;\n-    /**\n-     * Running total of the hashCode.\n-     */\n-    private int iTotal = 0;\n-\n-    /**\n-     * <p>Uses two hard coded choices for the constants\n-     * needed to build a <code>hashCode</code>.</p>\n-     */\n-    public HashCodeBuilder() {\n-        iConstant = 37;\n-        iTotal = 17;\n-    }\n-\n-    /**\n-     * <p>Two randomly chosen, non-zero, odd numbers must be passed in.\n-     * Ideally these should be different for each class, however this is\n-     * not vital.</p>\n-     *\n-     * <p>Prime numbers are preferred, especially for the multiplier.</p>\n-     *\n-     * @param initialNonZeroOddNumber  a non-zero, odd number used as the initial value\n-     * @param multiplierNonZeroOddNumber  a non-zero, odd number used as the multiplier\n-     * @throws IllegalArgumentException if the number is zero or even\n-     */\n-    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n-        if (initialNonZeroOddNumber == 0) {\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n-        }\n-        if (initialNonZeroOddNumber % 2 == 0) {\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n-        }\n-        if (multiplierNonZeroOddNumber == 0) {\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n-        }\n-        if (multiplierNonZeroOddNumber % 2 == 0) {\n-            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n-        }\n-        iConstant = multiplierNonZeroOddNumber;\n-        iTotal = initialNonZeroOddNumber;\n-    }\n-\n-    //-------------------------------------------------------------------------\n-\n-    /**\n-     * <p>This method uses reflection to build a valid hash code.</p>\n-     *\n-     * <p>This constructor uses two hard coded choices for the constants\n-     * needed to build a hash code.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is\n-     * also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>Transient members will be not be used, as they are likely derived\n-     * fields, and not part of the value of the <code>Object</code>.</p>\n-     *\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n-     *\n-     * @param object  the Object to create a <code>hashCode</code> for\n+    /**\n+     * <p>\n+     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     * \n+     * @since 2.3\n+     */\n+    private static ThreadLocal registry = new ThreadLocal() {\n+        protected synchronized Object initialValue() {\n+            // The HashSet implementation is not synchronized,\n+            // which is just what we need here.\n+            return new HashSet();\n+        }\n+    };\n+\n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the reflection methods in the current thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n+     * @since 2.3\n+     */\n+    static Set getRegistry() {\n+        return (Set) registry.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     * @since 2.3\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getRegistry().contains(toIdentityHashCodeInteger(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the object to append details of\n+     * @param clazz\n+     *            the class to append details of\n+     * @param builder\n+     *            the builder to append to\n+     * @param useTransients\n+     *            whether to use transient fields\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     */\n+    private static void reflectionAppend(Object object, Class clazz, HashCodeBuilder builder, boolean useTransients,\n+            String[] excludeFields) {\n+        if (isRegistered(object)) {\n+            return;\n+        }\n+        try {\n+            register(object);\n+            Field[] fields = clazz.getDeclaredFields();\n+            List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n+            AccessibleObject.setAccessible(fields, true);\n+            for (int i = 0; i < fields.length; i++) {\n+                Field field = fields[i];\n+                if (!excludedFieldList.contains(field.getName())\n+                    && (field.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n+                    && (!Modifier.isStatic(field.getModifiers()))) {\n+                    try {\n+                        Object fieldValue = field.get(object);\n+                        builder.append(fieldValue);\n+                    } catch (IllegalAccessException e) {\n+                        // this can't happen. Would get a Security exception instead\n+                        // throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(object);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n      * @return int hash code\n-     * @throws IllegalArgumentException if the object is <code>null</code>\n-     */\n-    public static int reflectionHashCode(Object object) {\n-        return reflectionHashCode(17, 37, object, false, null, null);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a valid hash code.</p>\n-     *\n-     * <p>This constructor uses two hard coded choices for the constants\n-     * needed to build a hash code.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is\n-     * also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>Transient members will be not be used, as they are likely derived\n-     * fields, and not part of the value of the <code>Object</code>.</p>\n-     *\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n-     *\n-     * @param object  the Object to create a <code>hashCode</code> for\n-     * @param excludeFields  Collection of String field names to exclude from use in calculation of hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n      * @return int hash code\n-     * @throws IllegalArgumentException if the object is <code>null</code>\n-     */\n-    public static int reflectionHashCode(Object object, Collection /*String*/ excludeFields) {\n-        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a valid hash code.</p>\n-     *\n-     * <p>This constructor uses two hard coded choices for the constants\n-     * needed to build a hash code.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is\n-     * also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>Transient members will be not be used, as they are likely derived\n-     * fields, and not part of the value of the <code>Object</code>.</p>\n-     *\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n-     *\n-     * @param object  the Object to create a <code>hashCode</code> for\n-     * @param excludeFields  array of field names to exclude from use in calculation of hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n+            boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null,\n+                null);\n+    }\n+\n+    /**\n+     * Calls {@link #reflectionHashCode(int, int, Object, boolean, Class, String[])} with excludeFields set to\n+     * <code>null</code>.\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n      * @return int hash code\n-     * @throws IllegalArgumentException if the object is <code>null</code>\n-     */\n-    public static int reflectionHashCode(Object object, String[] excludeFields) {\n-        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a valid hash code.</p>\n-     *\n-     * <p>This constructor uses two hard coded choices for the constants needed\n-     * to build a hash code.</p>\n-     *\n-     * <p> It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is\n-     * also not as efficient as testing explicitly.</p>\n-     *\n-     * <P>If the TestTransients parameter is set to <code>true</code>, transient\n-     * members will be tested, otherwise they are ignored, as they are likely\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\n-     *\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n-     *\n-     * @param object  the Object to create a <code>hashCode</code> for\n-     * @param testTransients  whether to include transient fields\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n+            boolean testTransients, Class reflectUpToClass) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients,\n+                reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be included up to and including the specified\n+     * superclass. A null superclass is treated as java.lang.Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n      * @return int hash code\n-     * @throws IllegalArgumentException if the object is <code>null</code>\n-     */\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\n-        return reflectionHashCode(17, 37, object, testTransients, null, null);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a valid hash code.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is\n-     * also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>Transient members will be not be used, as they are likely derived\n-     * fields, and not part of the value of the <code>Object</code>.</p>\n-     *\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n-     *\n-     * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n-     * these should be different for each class, however this is not vital.\n-     * Prime numbers are preferred, especially for the multiplier.</p>\n-     *\n-     * @param initialNonZeroOddNumber  a non-zero, odd number used as the initial value\n-     * @param multiplierNonZeroOddNumber  a non-zero, odd number used as the multiplier\n-     * @param object  the Object to create a <code>hashCode</code> for\n-     * @return int hash code\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n-     * @throws IllegalArgumentException if the number is zero or even\n-     */\n-    public static int reflectionHashCode(\n-            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a valid hash code.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is also\n-     * not as efficient as testing explicitly.</p>\n-     *\n-     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n-     * members will be tested, otherwise they are ignored, as they are likely\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\n-     *\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n-     *\n-     * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n-     * these should be different for each class, however this is not vital.\n-     * Prime numbers are preferred, especially for the multiplier.</p>\n-     *\n-     * @param initialNonZeroOddNumber  a non-zero, odd number used as the initial value\n-     * @param multiplierNonZeroOddNumber  a non-zero, odd number used as the multiplier\n-     * @param object  the Object to create a <code>hashCode</code> for\n-     * @param testTransients  whether to include transient fields\n-     * @return int hash code\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n-     * @throws IllegalArgumentException if the number is zero or even\n-     */\n-    public static int reflectionHashCode(\n-            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n-            Object object, boolean testTransients) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, \n-                                  object, testTransients, null, null\n-                                 );\n-    }\n-            \n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n-                                         Object object, boolean testTransients, Class reflectUpToClass) \n-    {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, \n-                                  testTransients, reflectUpToClass, null);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a valid hash code.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is also\n-     * not as efficient as testing explicitly.</p>\n-     *\n-     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n-     * members will be tested, otherwise they are ignored, as they are likely\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be included\n-     * up to and including the specified superclass. A null superclass is treated\n-     * as java.lang.Object.</p>\n-     *\n-     * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n-     * these should be different for each class, however this is not vital.\n-     * Prime numbers are preferred, especially for the multiplier.</p>\n-     *\n-     * @param initialNonZeroOddNumber  a non-zero, odd number used as the initial value\n-     * @param multiplierNonZeroOddNumber  a non-zero, odd number used as the multiplier\n-     * @param object  the Object to create a <code>hashCode</code> for\n-     * @param testTransients  whether to include transient fields\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n-     *  may be <code>null</code>\n-     * @param excludeFields  array of field names to exclude from use in calculation of hash code\n-     * @return int hash code\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n-     * @throws IllegalArgumentException if the number is zero or even\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n      * @since 2.0\n      */\n-    public static int reflectionHashCode(\n-        int initialNonZeroOddNumber,\n-        int multiplierNonZeroOddNumber,\n-        Object object,\n-        boolean testTransients,\n-        Class reflectUpToClass,\n-        String[] excludeFields) {\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n+            boolean testTransients, Class reflectUpToClass, String[] excludeFields) {\n \n         if (object == null) {\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n     }\n \n     /**\n-     * <p>Appends the fields and values defined by the given object of the\n-     * given <code>Class</code>.</p>\n-     * \n-     * @param object  the object to append details of\n-     * @param clazz  the class to append details of\n-     * @param builder  the builder to append to\n-     * @param useTransients  whether to use transient fields\n-     * @param excludeFields  Collection of String field names to exclude from use in calculation of hash code\n-     */\n-    private static void reflectionAppend(\n-            Object object, \n-            Class clazz, \n-            HashCodeBuilder builder, \n-            boolean useTransients,\n-            String[] excludeFields) {\n-        Field[] fields = clazz.getDeclaredFields();\n-        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i = 0; i < fields.length; i++) {\n-            Field f = fields[i];\n-            if (!excludedFieldList.contains(f.getName())\n-                && (f.getName().indexOf('$') == -1)\n-                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                && (!Modifier.isStatic(f.getModifiers()))) {\n-                try {\n-                    builder.append(f.get(object));\n-                } catch (IllegalAccessException e) {\n-                    //this can't happen. Would get a Security exception instead\n-                    //throw a runtime exception in case the impossible happens.\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n-                }\n-            }\n-        }\n-    }\n-\n-    //-------------------------------------------------------------------------\n-\n-    /**\n-     * <p>Adds the result of super.hashCode() to this builder.</p>\n-     *\n-     * @param superHashCode  the result of calling <code>super.hashCode()</code>\n-     * @return this HashCodeBuilder, used to chain calls.\n-     * @since 2.0\n-     */\n-    public HashCodeBuilder appendSuper(int superHashCode) {\n-        iTotal = iTotal * iConstant + superHashCode;\n-        return this;\n-    }\n-\n-    //-------------------------------------------------------------------------\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for an <code>Object</code>.</p>\n-     *\n-     * @param object  the Object to add to the <code>hashCode</code>\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object) {\n+        return reflectionHashCode(17, 37, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <P>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, Collection /* String */excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, String[] excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to register.\n+     */\n+    static void register(Object value) {\n+        getRegistry().add(toIdentityHashCodeInteger(value));\n+    }\n+\n+    /**\n+     * Returns an Integer for the given object's default hash code.\n+     * \n+     * @see System#identityHashCode(Object)\n+     * @param value\n+     *            object for which the hashCode is to be calculated\n+     * @return Default int hash code\n+     */\n+    private static Integer toIdentityHashCodeInteger(Object value) {\n+        return new Integer(System.identityHashCode(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * \n+     * @param value\n+     *            The object to unregister.\n+     * @since 2.3\n+     */\n+    static void unregister(Object value) {\n+        getRegistry().remove(toIdentityHashCodeInteger(value));\n+    }\n+\n+    /**\n+     * Constant to use in building the hashCode.\n+     */\n+    private final int iConstant;\n+\n+    /**\n+     * Running total of the hashCode.\n+     */\n+    private int iTotal = 0;\n+\n+    /**\n+     * <p>\n+     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\n+     * </p>\n+     */\n+    public HashCodeBuilder() {\n+        iConstant = 37;\n+        iTotal = 17;\n+    }\n+\n+    /**\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital.\n+     * </p>\n+     * \n+     * <p>\n+     * Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code>.\n+     * </p>\n+     * <p>\n+     * This adds <code>iConstant * 1</code> to the <code>hashCode</code> and not a <code>1231</code> or\n+     * <code>1237</code> as done in java.lang.Boolean. This is in accordance with the <quote>Effective Java</quote>\n+     * design.\n+     * </p>\n+     * \n+     * @param value\n+     *            the boolean to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the byte to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the char to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the double to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double value) {\n+        return append(Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the float to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the int to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the long to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to add to the <code>hashCode</code>\n      * @return this\n      */\n     public HashCodeBuilder append(Object object) {\n \n         } else {\n             if (object.getClass().isArray() == false) {\n-                //the simple case, not an array, just the element\n+                // the simple case, not an array, just the element\n                 iTotal = iTotal * iConstant + object.hashCode();\n \n             } else {\n-                //'Switch' on type of array, to dispatch to the correct handler\n+                // 'Switch' on type of array, to dispatch to the correct handler\n                 // This handles multi dimensional arrays\n                 if (object instanceof long[]) {\n                     append((long[]) object);\n     }\n \n     /**\n-     * <p>Append a <code>hashCode</code> for a <code>long</code>.</p>\n-     *\n-     * @param value  the long to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(long value) {\n-        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for an <code>int</code>.</p>\n-     *\n-     * @param value  the int to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(int value) {\n-        iTotal = iTotal * iConstant + value;\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>short</code>.</p>\n-     *\n-     * @param value  the short to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(short value) {\n-        iTotal = iTotal * iConstant + value;\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>char</code>.</p>\n-     *\n-     * @param value  the char to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(char value) {\n-        iTotal = iTotal * iConstant + value;\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>byte</code>.</p>\n-     *\n-     * @param value  the byte to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(byte value) {\n-        iTotal = iTotal * iConstant + value;\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>double</code>.</p>\n-     *\n-     * @param value  the double to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(double value) {\n-        return append(Double.doubleToLongBits(value));\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>float</code>.</p>\n-     *\n-     * @param value  the float to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(float value) {\n-        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>boolean</code>.</p>\n-     * <p>This adds <code>iConstant * 1</code> to the <code>hashCode</code>\n-     * and not a <code>1231</code> or <code>1237</code> as done in java.lang.Boolean. \n-     * This is in accordance with the <quote>Effective Java</quote> design. </p>\n-     *\n-     * @param value  the boolean to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(boolean value) {\n-        iTotal = iTotal * iConstant + (value ? 0 : 1);\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for an <code>Object</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n     public HashCodeBuilder append(Object[] array) {\n     }\n \n     /**\n-     * <p>Append a <code>hashCode</code> for a <code>long</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(long[] array) {\n-        if (array == null) {\n-            iTotal = iTotal * iConstant;\n-        } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for an <code>int</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(int[] array) {\n-        if (array == null) {\n-            iTotal = iTotal * iConstant;\n-        } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>short</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the short to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n     public HashCodeBuilder append(short[] array) {\n     }\n \n     /**\n-     * <p>Append a <code>hashCode</code> for a <code>char</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(char[] array) {\n-        if (array == null) {\n-            iTotal = iTotal * iConstant;\n-        } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>byte</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(byte[] array) {\n-        if (array == null) {\n-            iTotal = iTotal * iConstant;\n-        } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>double</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(double[] array) {\n-        if (array == null) {\n-            iTotal = iTotal * iConstant;\n-        } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>float</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(float[] array) {\n-        if (array == null) {\n-            iTotal = iTotal * iConstant;\n-        } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Append a <code>hashCode</code> for a <code>boolean</code> array.</p>\n-     *\n-     * @param array  the array to add to the <code>hashCode</code>\n-     * @return this\n-     */\n-    public HashCodeBuilder append(boolean[] array) {\n-        if (array == null) {\n-            iTotal = iTotal * iConstant;\n-        } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Return the computed <code>hashCode</code>.</p>\n-     *\n+     * <p>\n+     * Adds the result of super.hashCode() to this builder.\n+     * </p>\n+     * \n+     * @param superHashCode\n+     *            the result of calling <code>super.hashCode()</code>\n+     * @return this HashCodeBuilder, used to chain calls.\n+     * @since 2.0\n+     */\n+    public HashCodeBuilder appendSuper(int superHashCode) {\n+        iTotal = iTotal * iConstant + superHashCode;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the computed <code>hashCode</code>.\n+     * </p>\n+     * \n      * @return <code>hashCode</code> based on the fields appended\n      */\n     public int toHashCode() {\n--- a/src/test/org/apache/commons/lang/builder/HashCodeBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/HashCodeBuilderTest.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.lang.builder;\n \n import org.apache.commons.lang.builder.ToStringBuilderTest.ReflectionTestCycleA;\n \n /**\n  * Unit tests {@link org.apache.commons.lang.builder.HashCodeBuilder}.\n- *\n+ * \n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @version $Id$\n  */\n             return HashCodeBuilder.reflectionHashCode(this);\n         }\n     }\n-    \n+\n     public HashCodeBuilderTest(String name) {\n         super(name);\n     }\n         super.tearDown();\n     }\n \n-    //-----------------------------------------------------------------------\n+    // -----------------------------------------------------------------------\n \n     public void testConstructorEx1() {\n         try {\n             new HashCodeBuilder(0, 0);\n-            \n+\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n     public void testConstructorEx2() {\n         try {\n             new HashCodeBuilder(2, 2);\n-            \n+\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n \n     static class TestObject {\n         private int a;\n+\n         public TestObject(int a) {\n             this.a = a;\n         }\n+\n         public boolean equals(Object o) {\n             if (o == this) {\n                 return true;\n \n     static class TestSubObject extends TestObject {\n         private int b;\n+\n         transient private int t;\n+\n         public TestSubObject() {\n             super(0);\n         }\n+\n         public TestSubObject(int a, int b, int t) {\n             super(a);\n             this.b = b;\n             this.t = t;\n         }\n+\n         public boolean equals(Object o) {\n             if (o == this) {\n                 return true;\n     public void testReflectionHierarchyHashCode() {\n         assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0)));\n         assertEquals(17 * 37 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0), true));\n-        assertEquals((17 * 37 + 7890) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0)));\n-        assertEquals(((17 * 37 + 7890) * 37 + 0) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0), true));\n+        assertEquals((17 * 37 + 7890) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890,\n+                0)));\n+        assertEquals(((17 * 37 + 7890) * 37 + 0) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(\n+                123456, 7890, 0), true));\n     }\n \n     public void testReflectionHierarchyHashCodeEx1() {\n     public void testSuper() {\n         Object obj = new Object();\n         assertEquals(17 * 37 + (19 * 41 + obj.hashCode()), new HashCodeBuilder(17, 37).appendSuper(\n-            new HashCodeBuilder(19, 41).append(obj).toHashCode()\n-        ).toHashCode());\n+                new HashCodeBuilder(19, 41).append(obj).toHashCode()).toHashCode());\n     }\n \n     public void testObject() {\n \n     public void testLong() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode());\n-        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append((long) 123456789L).toHashCode());\n+        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append(\n+                (long) 123456789L).toHashCode());\n     }\n \n     public void testInt() {\n     public void testObjectArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());\n         Object[] obj = new Object[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = new Object();\n         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = new Object();\n-        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj)\n+                .toHashCode());\n     }\n \n     public void testObjectArrayAsObject() {\n         Object[] obj = new Object[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = new Object();\n         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = new Object();\n-        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(\n+                (Object) obj).toHashCode());\n     }\n \n     public void testLongArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());\n         long[] obj = new long[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5L;\n         int h1 = (int) (5L ^ (5L >> 32));\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6L;\n         int h2 = (int) (6L ^ (6L >> 32));\n-        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testLongArrayAsObject() {\n         long[] obj = new long[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5L;\n         int h1 = (int) (5L ^ (5L >> 32));\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6L;\n         int h2 = (int) (6L ^ (6L >> 32));\n-        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testIntArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());\n         int[] obj = new int[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6;\n-        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testIntArrayAsObject() {\n         int[] obj = new int[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6;\n-        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testShortArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());\n         short[] obj = new short[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (short) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = (short) 6;\n-        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testShortArrayAsObject() {\n         short[] obj = new short[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (short) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = (short) 6;\n-        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testCharArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());\n         char[] obj = new char[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (char) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = (char) 6;\n-        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testCharArrayAsObject() {\n         char[] obj = new char[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (char) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = (char) 6;\n-        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testByteArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());\n         byte[] obj = new byte[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (byte) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = (byte) 6;\n-        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testByteArrayAsObject() {\n         byte[] obj = new byte[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (byte) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = (byte) 6;\n-        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testDoubleArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());\n         double[] obj = new double[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5.4d;\n         long l1 = Double.doubleToLongBits(5.4d);\n         int h1 = (int) (l1 ^ (l1 >> 32));\n         obj[1] = 6.3d;\n         long l2 = Double.doubleToLongBits(6.3d);\n         int h2 = (int) (l2 ^ (l2 >> 32));\n-        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testDoubleArrayAsObject() {\n         double[] obj = new double[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5.4d;\n         long l1 = Double.doubleToLongBits(5.4d);\n         int h1 = (int) (l1 ^ (l1 >> 32));\n         obj[1] = 6.3d;\n         long l2 = Double.doubleToLongBits(6.3d);\n         int h2 = (int) (l2 ^ (l2 >> 32));\n-        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testFloatArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());\n         float[] obj = new float[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5.4f;\n         int h1 = Float.floatToIntBits(5.4f);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6.3f;\n         int h2 = Float.floatToIntBits(6.3f);\n-        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testFloatArrayAsObject() {\n         float[] obj = new float[2];\n-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5.4f;\n         int h1 = Float.floatToIntBits(5.4f);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6.3f;\n         int h2 = Float.floatToIntBits(6.3f);\n-        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testBooleanArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());\n         boolean[] obj = new boolean[2];\n-        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = true;\n         assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = false;\n-        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testBooleanArrayAsObject() {\n         boolean[] obj = new boolean[2];\n-        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = true;\n         assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = false;\n-        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testBooleanMultiArray() {\n         obj[0][0] = true;\n         assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = new boolean[1];\n-        assertEquals( (((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals((((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     public void testReflectionHashCodeExcludeFields() throws Exception {\n         assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x));\n \n         assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, (String[]) null));\n-        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {}));\n-        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {\"xxx\"}));\n-\n-        assertEquals(((17 * 37 + 1) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {\"two\"}));\n-        assertEquals(((17 * 37 + 1) * 37 + 2), HashCodeBuilder.reflectionHashCode(x, new String[] {\"three\"}));\n-\n-        assertEquals((17 * 37 + 1), HashCodeBuilder.reflectionHashCode(x, new String[] {\"two\", \"three\"}));\n-\n-        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[] {\"one\", \"two\", \"three\"}));\n-        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[] {\"one\", \"two\", \"three\", \"xxx\"}));\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{}));\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{\"xxx\"}));\n+\n+        assertEquals(((17 * 37 + 1) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{\"two\"}));\n+        assertEquals(((17 * 37 + 1) * 37 + 2), HashCodeBuilder.reflectionHashCode(x, new String[]{\"three\"}));\n+\n+        assertEquals((17 * 37 + 1), HashCodeBuilder.reflectionHashCode(x, new String[]{\"two\", \"three\"}));\n+\n+        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[]{\"one\", \"two\", \"three\"}));\n+        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[]{\"one\", \"two\", \"three\", \"xxx\"}));\n     }\n \n     static class TestObjectWithMultipleFields {\n         private int one = 0;\n+\n         private int two = 0;\n+\n         private int three = 0;\n \n         public TestObjectWithMultipleFields(int one, int two, int three) {\n             this.three = three;\n         }\n     }\n-    \n+\n     /**\n      * Test Objects pointing to each other.\n      */\n         // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n         // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n \n-        // a.hashCode();\n-        // b.hashCode();\n+        a.hashCode();\n+        b.hashCode();\n     }\n \n }", "timestamp": 1158703091, "metainfo": ""}