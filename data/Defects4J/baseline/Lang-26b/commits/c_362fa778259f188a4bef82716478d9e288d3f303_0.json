{"sha": "362fa778259f188a4bef82716478d9e288d3f303", "log": "Performance improvement. Switching from looping through a doubled array to using a Map. This probably costs more for simple cases like Java/EcmaScript/Xml, but makes up for it in the Html case. This gets performance of the testUnescapeHexCharsHtml method back down to near the same region as the original code  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/translate/LookupTranslator.java\n+++ b/src/java/org/apache/commons/lang/text/translate/LookupTranslator.java\n \n import java.io.IOException;\n import java.io.Writer;\n+import java.util.HashMap;\n \n /**\n  * Translates a value using a lookup table. \n  * @since 3.0\n  */\n+// TODO: Replace with a RegexLookup? Performance test.\n public class LookupTranslator extends CharSequenceTranslator {\n \n-    protected CharSequence[][] lookup;\n+    private HashMap<CharSequence, CharSequence> lookupMap;\n+    private int shortest = Integer.MAX_VALUE;\n+    private int longest = 0;\n \n     /**\n      * Define the lookup table to be used in translation\n      * @param CharSequence[][] Lookup table of size [*][2]\n      */\n     public LookupTranslator(CharSequence[][] lookup) {\n-        this.lookup = lookup;\n+        lookupMap = new HashMap<CharSequence, CharSequence>();\n+        for(CharSequence[] seq : lookup) {\n+            this.lookupMap.put(seq[0], seq[1]);\n+            int sz = seq[0].length();\n+            if(sz < shortest) {\n+                shortest = sz;\n+            }\n+            if(sz > longest) {\n+                longest = sz;\n+            }\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public int translate(CharSequence input, int index, Writer out) throws IOException {\n-        CharSequence subsequence = input.subSequence(index, input.length());\n-        for(CharSequence[] seq : lookup) {\n-            if( subsequence.toString().startsWith(seq[0].toString()) ) {\n-                out.write(seq[1].toString());\n-                return seq[0].length();\n+        int max = longest;\n+        if(index + longest > input.length()) {\n+            max = input.length() - index;\n+        }\n+        // descend so as to get a greedy algorithm\n+        for(int i=max; i >= shortest; i--) {\n+            CharSequence subSeq = input.subSequence(index, index + i);\n+            CharSequence result = lookupMap.get(subSeq);\n+            if(result != null) {\n+                out.write(result.toString());\n+                return i;\n             }\n         }\n         return 0;", "timestamp": 1246340859, "metainfo": ""}