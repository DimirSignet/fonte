{"sha": "b857309126b0922c1695cb514d07c9e493afcedc", "log": "remove pre Java 5 workaround  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/reflect/MemberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MemberUtils.java\n \n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Member;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n \n-import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.ClassUtils;\n-import org.apache.commons.lang3.SystemUtils;\n \n /**\n  * Contains common code for working with Methods/Constructors, extracted and\n- * refactored from <code>MethodUtils</code> when it was imported from Commons BeanUtils.\n+ * refactored from <code>MethodUtils</code> when it was imported from Commons\n+ * BeanUtils.\n  *\n  * @author Apache Software Foundation\n  * @author Steve Cohen\n \n     private static final int ACCESS_TEST = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;\n \n-    private static final Method IS_SYNTHETIC;\n-    static {\n-        Method isSynthetic = null;\n-        if (SystemUtils.isJavaVersionAtLeast(1.5f)) {\n-            // cannot call synthetic methods:\n-            try {\n-                isSynthetic = Member.class.getMethod(\"isSynthetic\",\n-                        ArrayUtils.EMPTY_CLASS_ARRAY);\n-            } catch (Exception e) {\n-            }\n-        }\n-        IS_SYNTHETIC = isSynthetic;\n-    }\n-\n     /** Array of primitive number types ordered by \"promotability\" */\n-    private static final Class<?>[] ORDERED_PRIMITIVE_TYPES = { Byte.TYPE,\n-            Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE,\n-            Double.TYPE };\n+    private static final Class<?>[] ORDERED_PRIMITIVE_TYPES = { Byte.TYPE, Short.TYPE,\n+            Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE };\n \n     /**\n      * XXX Default access superclass workaround\n      *\n-     * When a public class has a default access superclass with public\n-     * members, these members are accessible. Calling them from\n-     * compiled code works fine. Unfortunately, on some JVMs, using reflection to invoke these\n-     * members seems to (wrongly) to prevent access even when the\n-     * modifer is public. Calling setAccessible(true) solves the problem\n-     * but will only work from sufficiently privileged code. Better\n-     * workarounds would be gratefully accepted.\n+     * When a public class has a default access superclass with public members,\n+     * these members are accessible. Calling them from compiled code works fine.\n+     * Unfortunately, on some JVMs, using reflection to invoke these members\n+     * seems to (wrongly) to prevent access even when the modifer is public.\n+     * Calling setAccessible(true) solves the problem but will only work from\n+     * sufficiently privileged code. Better workarounds would be gratefully\n+     * accepted.\n      * @param o the AccessibleObject to set as accessible\n      */\n     static void setAccessibleWorkaround(AccessibleObject o) {\n             return;\n         }\n         Member m = (Member) o;\n-        if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n+        if (Modifier.isPublic(m.getModifiers())\n+                && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n             try {\n                 o.setAccessible(true);\n             } catch (SecurityException e) {\n      * @return true if <code>m</code> is accessible\n      */\n     static boolean isAccessible(Member m) {\n-        return m != null && Modifier.isPublic(m.getModifiers())\n-                && !isSynthetic(m);\n-    }\n-\n-    /**\n-     * Try to learn whether a given member, on JDK >= 1.5, is synthetic.\n-     * @param m Member to check\n-     * @return true if <code>m</code> was introduced by the compiler.\n-     */\n-    static boolean isSynthetic(Member m) {\n-        if (IS_SYNTHETIC != null) {\n-            try {\n-                return ((Boolean) IS_SYNTHETIC.invoke(m, (Object[]) null)).booleanValue();\n-            } catch (Exception e) {\n-            }\n-        }\n-        return false;\n+        return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();\n     }\n \n     /**\n      * Compare the relative fitness of two sets of parameter types in terms of\n      * matching a third set of runtime parameter types, such that a list ordered\n-     * by the results of the comparison would return the best match first (least).\n+     * by the results of the comparison would return the best match first\n+     * (least).\n      *\n      * @param left the \"left\" parameter set\n      * @param right the \"right\" parameter set\n-     * @param actual the runtime parameter types to match against <code>left</code>/<code>right</code>\n+     * @param actual the runtime parameter types to match against\n+     * <code>left</code>/<code>right</code>\n      * @return int consistent with <code>compare</code> semantics\n      */\n     static int compareParameterTypes(Class<?>[] left, Class<?>[] right, Class<?>[] actual) {\n     }\n \n     /**\n-     * Returns the sum of the object transformation cost for each class in the source\n-     * argument list.\n+     * Returns the sum of the object transformation cost for each class in the\n+     * source argument list.\n      * @param srcArgs The source arguments\n      * @param destArgs The destination arguments\n      * @return The total transformation cost\n      */\n-    private static float getTotalTransformationCost(Class<?>[] srcArgs,\n-            Class<?>[] destArgs) {\n+    private static float getTotalTransformationCost(Class<?>[] srcArgs, Class<?>[] destArgs) {\n         float totalCost = 0.0f;\n         for (int i = 0; i < srcArgs.length; i++) {\n             Class<?> srcClass, destClass;\n     }\n \n     /**\n-     * Gets the number of steps required needed to turn the source class into the \n-     * destination class. This represents the number of steps in the object hierarchy \n-     * graph.\n+     * Gets the number of steps required needed to turn the source class into\n+     * the destination class. This represents the number of steps in the object\n+     * hierarchy graph.\n      * @param srcClass The source class\n      * @param destClass The destination class\n      * @return The cost of transforming an object\n      */\n-    private static float getObjectTransformationCost(Class<?> srcClass,\n-            Class<?> destClass) {\n+    private static float getObjectTransformationCost(Class<?> srcClass, Class<?> destClass) {\n         if (destClass.isPrimitive()) {\n             return getPrimitivePromotionCost(srcClass, destClass);\n         }\n         float cost = 0.0f;\n         while (destClass != null && !destClass.equals(srcClass)) {\n-            if (destClass.isInterface()\n-                    && ClassUtils.isAssignable(srcClass, destClass)) {\n+            if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) {\n                 // slight penalty for interface match.\n                 // we still want an exact match to override an interface match,\n                 // but\n     }\n \n     /**\n-     * Get the number of steps required to promote a primitive number to another type.\n+     * Get the number of steps required to promote a primitive number to another\n+     * type.\n      * @param srcClass the (primitive) source class\n      * @param destClass the (primitive) destination class\n      * @return The cost of promoting the primitive\n      */\n-    private static float getPrimitivePromotionCost(final Class<?> srcClass,\n-            final Class<?> destClass) {\n+    private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) {\n         float cost = 0.0f;\n         Class<?> cls = srcClass;\n         if (!cls.isPrimitive()) {", "timestamp": 1265143176, "metainfo": ""}