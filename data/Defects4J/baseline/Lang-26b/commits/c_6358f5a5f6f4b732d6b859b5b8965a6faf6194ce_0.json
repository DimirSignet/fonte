{"sha": "6358f5a5f6f4b732d6b859b5b8965a6faf6194ce", "log": "Fix for LANG-272 - Minor JavaDoc changes to clean up checkstyle issues  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n      *\n      * @param writer  the writer receiving the unescaped string, not null\n      * @param str  the <code>String</code> to escape, may be null\n-     * @return a new escaped <code>String</code>, <code>null</code> if null string input\n      * @throws IllegalArgumentException if the writer is null\n      * @throws IOException if there is a problem writing\n      * @see #unescapeXml(java.lang.String)\n      *\n      * @param writer  the writer receiving the unescaped string, not null\n      * @param str  the <code>String</code> to unescape, may be null\n-     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n      * @throws IllegalArgumentException if the writer is null\n      * @throws IOException if there is a problem writing\n      * @see #escapeXml(String)\n--- a/src/java/org/apache/commons/lang/enum/Enum.java\n+++ b/src/java/org/apache/commons/lang/enum/Enum.java\n         return iName.compareTo(((Enum) other).iName);\n     }\n \n+    /**\n+     * <p>Use reflection to return an objects class name.</p>\n+     *\n+     * @param other The object to determine the class name for\n+     * @return The class name\n+     */\n     private String getNameInOtherClassLoader(Object other) {\n         try {\n             Method mth = other.getClass().getMethod(\"getName\", null);\n--- a/src/java/org/apache/commons/lang/enums/Enum.java\n+++ b/src/java/org/apache/commons/lang/enums/Enum.java\n         return iName.compareTo(((Enum) other).iName);\n     }\n \n+    /**\n+     * <p>Use reflection to return an objects class name.</p>\n+     *\n+     * @param other The object to determine the class name for\n+     * @return The class name\n+     */\n     private String getNameInOtherClassLoader(Object other) {\n         try {\n             Method mth = other.getClass().getMethod(\"getName\", null);\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n         /** The last mark position. */\n         private int mark;\n \n+        /** {@inheritDoc} */\n         StrBuilderReader() {\n             super();\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void close() {\n             // do nothing\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public int read() {\n             if (ready() == false) {\n                 return -1;\n             return charAt(pos++);\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public int read(char b[], int off, int len) {\n             if (off < 0 || len < 0 || off > b.length ||\n                     (off + len) > b.length || (off + len) < 0) {\n             return len;\n         }\n \n+        /** {@inheritDoc} */\n         public long skip(long n) {\n             if (pos + n > size()) {\n                 n = size() - pos;\n             return n;\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public boolean ready() {\n             return pos < size();\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public boolean markSupported() {\n             return true;\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void mark(int readAheadLimit) {\n             mark = pos;\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void reset() {\n             pos = mark;\n         }\n      * Inner class to allow StrBuilder to operate as a writer.\n      */\n     class StrBuilderWriter extends Writer {\n+\n+        /** {@inheritDoc} */\n         StrBuilderWriter() {\n             super();\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void close() {\n             // do nothing\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void flush() {\n             // do nothing\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void write(int c) {\n             StrBuilder.this.append((char) c);\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void write(char[] cbuf) {\n             StrBuilder.this.append(cbuf);\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void write(char[] cbuf, int off, int len) {\n             StrBuilder.this.append(cbuf, off, len);\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void write(String str) {\n             StrBuilder.this.append(str);\n         }\n \n-        /** @inheritdoc */\n+        /** {@inheritDoc} */\n         public void write(String str, int off, int len) {\n             StrBuilder.this.append(str, off, len);\n         }\n--- a/src/java/org/apache/commons/lang/text/VariableFormatter.java\n+++ b/src/java/org/apache/commons/lang/text/VariableFormatter.java\n             return newToken(VariableParser.TEXT_TOKEN, aStartIndex, aLength);\n         }\n \n+        /**\n+         * Creates a new token of the specified type.\n+         * \n+         * @param type\n+         *            The token type\n+         * @param beginIndex\n+         *            The token starting index\n+         * @param length\n+         *            The token length\n+         * @return a new token\n+         */\n         private static FieldPosition newToken(int type, int beginIndex, int length) {\n             FieldPosition fp = new FieldPosition(type);\n             fp.setBeginIndex(beginIndex);\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n          * Returns a hashcode for the token equal to the \n          * hashcode for the token's value. Thus 'TT' and 'TTTT' \n          * will have the same hashcode. \n+         *\n+         * @return The hashcode for the token\n          */\n         public int hashCode() {\n             return this.value.hashCode();", "timestamp": 1152530637, "metainfo": ""}