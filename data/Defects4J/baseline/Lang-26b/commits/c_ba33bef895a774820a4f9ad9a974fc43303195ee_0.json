{"sha": "ba33bef895a774820a4f9ad9a974fc43303195ee", "log": "Changing eol-style to native.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.lang3.event;\n-\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Proxy;\n-import java.util.List;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-/**\n- * An EventListenerSupport object can be used to manage a list of event listeners of a particular type.\n- * <p/>\n- * To use this class, suppose you want to support ActionEvents.  You would do:\n- * <pre>\n- * public class MyActionEventSource\n- * {\n- *   private EventListenerSupport<ActionListener> actionListeners = EventListenerSupport.create(ActionListener.class);\n- * <p/>\n- *   public void someMethodThatFiresAction()\n- *   {\n- *     ActionEvent e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"somethingCool\");\n- *     actionListeners.getProxy().actionPerformed(e);\n- *   }\n- * }\n- * </pre>\n- *\n- * @param <L> The event listener type\n- */\n-public class EventListenerSupport<L>\n-{\n-    private final List<L> listeners;\n-    private final L proxy;\n-\n-    /**\n-     * Creates an EventListenerSupport object which supports the specified listener type.\n-     *\n-     * @param listenerType the listener type\n-     * @return an EventListenerSupport object which supports the specified listener type\n-     */\n-    public static <T> EventListenerSupport<T> create(Class<T> listenerType)\n-    {\n-        return new EventListenerSupport<T>(listenerType);\n-    }\n-\n-    /**\n-     * Creates an EventListenerSupport object which supports the provided listener interface.\n-     *\n-     * @param listenerInterface the listener interface\n-     */\n-    public EventListenerSupport(Class<L> listenerInterface)\n-    {\n-        this(listenerInterface, Thread.currentThread().getContextClassLoader());\n-    }\n-\n-    /**\n-     * Creates an EventListenerSupport object which supports the provided listener interface using the specified\n-     * class loader to create the JDK dynamic proxy.\n-     *\n-     * @param listenerInterface the listener interface\n-     * @param classLoader       the class loader\n-     */\n-    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader)\n-    {\n-        listeners = new CopyOnWriteArrayList<L>();\n-        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[]{listenerInterface},\n-                new ProxyInvocationHandler()));\n-    }\n-\n-    /**\n-     * Returns a proxy object which can be used to call listener methods on all of the registered event listeners.\n-     *\n-     * @return a proxy object which can be used to call listener methods on all of the registered event listeners\n-     */\n-    public L fire()\n-    {\n-        return proxy;\n-    }\n-\n-//**********************************************************************************************************************\n-// Other Methods\n-//**********************************************************************************************************************\n-\n-    /**\n-     * Registers an event listener.\n-     *\n-     * @param listener the event listener\n-     */\n-    public void addListener(L listener)\n-    {\n-        listeners.add(0, listener);\n-    }\n-\n-    /**\n-     * Returns the number of registered listeners.\n-     *\n-     * @return the number of registered listeners\n-     */\n-    public int getListenerCount()\n-    {\n-        return listeners.size();\n-    }\n-\n-    /**\n-     * Unregisters an event listener.\n-     *\n-     * @param listener the event listener\n-     */\n-    public void removeListener(L listener)\n-    {\n-        listeners.remove(listener);\n-    }\n-\n-    /**\n-     * An invocation handler used to dispatch the event(s) to all the listeners.\n-     */\n-    private class ProxyInvocationHandler implements InvocationHandler\n-    {\n-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n-        {\n-            for (int i = listeners.size() - 1; i >= 0; --i)\n-            {\n-                method.invoke(listeners.get(i), args);\n-            }\n-            return null;\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.event;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+/**\n+ * An EventListenerSupport object can be used to manage a list of event listeners of a particular type.\n+ * <p/>\n+ * To use this class, suppose you want to support ActionEvents.  You would do:\n+ * <pre>\n+ * public class MyActionEventSource\n+ * {\n+ *   private EventListenerSupport<ActionListener> actionListeners = EventListenerSupport.create(ActionListener.class);\n+ * <p/>\n+ *   public void someMethodThatFiresAction()\n+ *   {\n+ *     ActionEvent e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"somethingCool\");\n+ *     actionListeners.getProxy().actionPerformed(e);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * @param <L> The event listener type\n+ */\n+public class EventListenerSupport<L>\n+{\n+    private final List<L> listeners;\n+    private final L proxy;\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the specified listener type.\n+     *\n+     * @param listenerType the listener type\n+     * @return an EventListenerSupport object which supports the specified listener type\n+     */\n+    public static <T> EventListenerSupport<T> create(Class<T> listenerType)\n+    {\n+        return new EventListenerSupport<T>(listenerType);\n+    }\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the provided listener interface.\n+     *\n+     * @param listenerInterface the listener interface\n+     */\n+    public EventListenerSupport(Class<L> listenerInterface)\n+    {\n+        this(listenerInterface, Thread.currentThread().getContextClassLoader());\n+    }\n+\n+    /**\n+     * Creates an EventListenerSupport object which supports the provided listener interface using the specified\n+     * class loader to create the JDK dynamic proxy.\n+     *\n+     * @param listenerInterface the listener interface\n+     * @param classLoader       the class loader\n+     */\n+    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader)\n+    {\n+        listeners = new CopyOnWriteArrayList<L>();\n+        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[]{listenerInterface},\n+                new ProxyInvocationHandler()));\n+    }\n+\n+    /**\n+     * Returns a proxy object which can be used to call listener methods on all of the registered event listeners.\n+     *\n+     * @return a proxy object which can be used to call listener methods on all of the registered event listeners\n+     */\n+    public L fire()\n+    {\n+        return proxy;\n+    }\n+\n+//**********************************************************************************************************************\n+// Other Methods\n+//**********************************************************************************************************************\n+\n+    /**\n+     * Registers an event listener.\n+     *\n+     * @param listener the event listener\n+     */\n+    public void addListener(L listener)\n+    {\n+        listeners.add(0, listener);\n+    }\n+\n+    /**\n+     * Returns the number of registered listeners.\n+     *\n+     * @return the number of registered listeners\n+     */\n+    public int getListenerCount()\n+    {\n+        return listeners.size();\n+    }\n+\n+    /**\n+     * Unregisters an event listener.\n+     *\n+     * @param listener the event listener\n+     */\n+    public void removeListener(L listener)\n+    {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * An invocation handler used to dispatch the event(s) to all the listeners.\n+     */\n+    private class ProxyInvocationHandler implements InvocationHandler\n+    {\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n+        {\n+            for (int i = listeners.size() - 1; i >= 0; --i)\n+            {\n+                method.invoke(listeners.get(i), args);\n+            }\n+            return null;\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.lang3.event;\n-\n-import org.apache.commons.lang3.reflect.MethodUtils;\n-\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Proxy;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-public class EventUtils\n-{\n-    public static <L> void addEventListener(Object eventSource, Class<L> listenerType, L listener)\n-    {\n-        try\n-        {\n-            MethodUtils.invokeMethod(eventSource, \"add\" + listenerType.getSimpleName(), listener);\n-        }\n-        catch (NoSuchMethodException e)\n-        {\n-            throw new IllegalArgumentException(\"Class \" + eventSource.getClass() + \" does not have an accesible add\" + listenerType.getSimpleName() + \" method which takes a parameter of type \" + listenerType.getClass().getName() + \".\");\n-        }\n-        catch (IllegalAccessException e)\n-        {\n-            throw new IllegalArgumentException(\"Class \" + eventSource.getClass() + \" does not have an accesible add\" + listenerType.getSimpleName () + \" method which takes a parameter of type \" + listenerType.getClass().getName() + \".\");\n-        }\n-        catch (InvocationTargetException e)\n-        {\n-            throw new RuntimeException(\"Unable to add listener.\", e.getCause());\n-        }\n-    }\n-\n-    /**\n-     * Binds an event listener to a specific method on a specific object.\n-     *\n-     * @param target       the target object\n-     * @param methodName   the name of the method to be called\n-     * @param eventSource  the object which is generating events (JButton, JList, etc.)\n-     * @param listenerType the listener interface (ActionListener.class, SelectionListener.class, etc.)\n-     * @param eventTypes   the event types (method names) from the listener interface (if none specified, all will be\n-     *                     supported)\n-     */\n-    public static void bindEventsToMethod(Object target, String methodName, Object eventSource, Class listenerType, String... eventTypes)\n-    {\n-        final Object listener = Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes));\n-        addEventListener(eventSource, listenerType, listener);\n-    }\n-\n-    private static class EventBindingInvocationHandler implements InvocationHandler\n-    {\n-        private final Object target;\n-        private final String methodName;\n-        private final Set<String> eventTypes;\n-\n-        public EventBindingInvocationHandler(final Object target, final String methodName, String[] eventTypes)\n-        {\n-            this.target = target;\n-            this.methodName = methodName;\n-            this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes));\n-        }\n-\n-        public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable\n-        {\n-            if ( eventTypes.isEmpty() || eventTypes.contains(method.getName()))\n-            {\n-                if (hasMatchingParametersMethod(method))\n-                {\n-                    return MethodUtils.invokeMethod(target, methodName, parameters);\n-                }\n-                else\n-                {\n-                    return MethodUtils.invokeMethod(target, methodName, new Object[]{});\n-                }\n-            }\n-            return null;\n-        }\n-\n-        private boolean hasMatchingParametersMethod(final Method method)\n-        {\n-            return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null;\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.event;\n+\n+import org.apache.commons.lang3.reflect.MethodUtils;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class EventUtils\n+{\n+    public static <L> void addEventListener(Object eventSource, Class<L> listenerType, L listener)\n+    {\n+        try\n+        {\n+            MethodUtils.invokeMethod(eventSource, \"add\" + listenerType.getSimpleName(), listener);\n+        }\n+        catch (NoSuchMethodException e)\n+        {\n+            throw new IllegalArgumentException(\"Class \" + eventSource.getClass() + \" does not have an accesible add\" + listenerType.getSimpleName() + \" method which takes a parameter of type \" + listenerType.getClass().getName() + \".\");\n+        }\n+        catch (IllegalAccessException e)\n+        {\n+            throw new IllegalArgumentException(\"Class \" + eventSource.getClass() + \" does not have an accesible add\" + listenerType.getSimpleName () + \" method which takes a parameter of type \" + listenerType.getClass().getName() + \".\");\n+        }\n+        catch (InvocationTargetException e)\n+        {\n+            throw new RuntimeException(\"Unable to add listener.\", e.getCause());\n+        }\n+    }\n+\n+    /**\n+     * Binds an event listener to a specific method on a specific object.\n+     *\n+     * @param target       the target object\n+     * @param methodName   the name of the method to be called\n+     * @param eventSource  the object which is generating events (JButton, JList, etc.)\n+     * @param listenerType the listener interface (ActionListener.class, SelectionListener.class, etc.)\n+     * @param eventTypes   the event types (method names) from the listener interface (if none specified, all will be\n+     *                     supported)\n+     */\n+    public static void bindEventsToMethod(Object target, String methodName, Object eventSource, Class listenerType, String... eventTypes)\n+    {\n+        final Object listener = Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes));\n+        addEventListener(eventSource, listenerType, listener);\n+    }\n+\n+    private static class EventBindingInvocationHandler implements InvocationHandler\n+    {\n+        private final Object target;\n+        private final String methodName;\n+        private final Set<String> eventTypes;\n+\n+        public EventBindingInvocationHandler(final Object target, final String methodName, String[] eventTypes)\n+        {\n+            this.target = target;\n+            this.methodName = methodName;\n+            this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes));\n+        }\n+\n+        public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable\n+        {\n+            if ( eventTypes.isEmpty() || eventTypes.contains(method.getName()))\n+            {\n+                if (hasMatchingParametersMethod(method))\n+                {\n+                    return MethodUtils.invokeMethod(target, methodName, parameters);\n+                }\n+                else\n+                {\n+                    return MethodUtils.invokeMethod(target, methodName, new Object[]{});\n+                }\n+            }\n+            return null;\n+        }\n+\n+        private boolean hasMatchingParametersMethod(final Method method)\n+        {\n+            return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null;\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.lang3.event;\n-\n-import junit.framework.TestCase;\n-\n-import java.awt.event.ActionEvent;\n-import java.awt.event.ActionListener;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class EventListenerSupportTest extends TestCase\n-{\n-    public void testEventDispatchOrder()\n-    {\n-        EventListenerSupport<ActionListener> listenerSupport = EventListenerSupport.create(ActionListener.class);\n-        final List<ActionListener> calledListeners = new ArrayList<ActionListener>();\n-\n-        final ActionListener listener1 = createListener(calledListeners);\n-        final ActionListener listener2 = createListener(calledListeners);\n-        listenerSupport.addListener(listener1);\n-        listenerSupport.addListener(listener2);\n-        listenerSupport.fire().actionPerformed(new ActionEvent(\"Hello\", 0, \"Hello\"));\n-        assertEquals(calledListeners.size(), 2);\n-        assertSame(calledListeners.get(0), listener1);\n-        assertSame(calledListeners.get(1), listener2);\n-    }\n-\n-    public void testRemoveListenerDuringEvent()\n-    {\n-        final EventListenerSupport<ActionListener> listenerSupport = EventListenerSupport.create(ActionListener.class);\n-        for (int i = 0; i < 10; ++i)\n-        {\n-            addDeregisterListener(listenerSupport);\n-        }\n-        assertEquals(listenerSupport.getListenerCount(), 10);\n-        listenerSupport.fire().actionPerformed(new ActionEvent(\"Hello\", 0, \"Hello\"));\n-        assertEquals(listenerSupport.getListenerCount(), 0);\n-    }\n-\n-    private void addDeregisterListener(final EventListenerSupport<ActionListener> listenerSupport)\n-    {\n-        listenerSupport.addListener(new ActionListener()\n-        {\n-            public void actionPerformed(ActionEvent e)\n-            {\n-                listenerSupport.removeListener(this);\n-            }\n-        });\n-    }\n-\n-    private ActionListener createListener(final List<ActionListener> calledListeners)\n-    {\n-        return new ActionListener()\n-        {\n-            public void actionPerformed(ActionEvent e)\n-            {\n-                calledListeners.add(this);\n-            }\n-        };\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.event;\n+\n+import junit.framework.TestCase;\n+\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class EventListenerSupportTest extends TestCase\n+{\n+    public void testEventDispatchOrder()\n+    {\n+        EventListenerSupport<ActionListener> listenerSupport = EventListenerSupport.create(ActionListener.class);\n+        final List<ActionListener> calledListeners = new ArrayList<ActionListener>();\n+\n+        final ActionListener listener1 = createListener(calledListeners);\n+        final ActionListener listener2 = createListener(calledListeners);\n+        listenerSupport.addListener(listener1);\n+        listenerSupport.addListener(listener2);\n+        listenerSupport.fire().actionPerformed(new ActionEvent(\"Hello\", 0, \"Hello\"));\n+        assertEquals(calledListeners.size(), 2);\n+        assertSame(calledListeners.get(0), listener1);\n+        assertSame(calledListeners.get(1), listener2);\n+    }\n+\n+    public void testRemoveListenerDuringEvent()\n+    {\n+        final EventListenerSupport<ActionListener> listenerSupport = EventListenerSupport.create(ActionListener.class);\n+        for (int i = 0; i < 10; ++i)\n+        {\n+            addDeregisterListener(listenerSupport);\n+        }\n+        assertEquals(listenerSupport.getListenerCount(), 10);\n+        listenerSupport.fire().actionPerformed(new ActionEvent(\"Hello\", 0, \"Hello\"));\n+        assertEquals(listenerSupport.getListenerCount(), 0);\n+    }\n+\n+    private void addDeregisterListener(final EventListenerSupport<ActionListener> listenerSupport)\n+    {\n+        listenerSupport.addListener(new ActionListener()\n+        {\n+            public void actionPerformed(ActionEvent e)\n+            {\n+                listenerSupport.removeListener(this);\n+            }\n+        });\n+    }\n+\n+    private ActionListener createListener(final List<ActionListener> calledListeners)\n+    {\n+        return new ActionListener()\n+        {\n+            public void actionPerformed(ActionEvent e)\n+            {\n+                calledListeners.add(this);\n+            }\n+        };\n+    }\n+}\n--- a/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.lang3.event;\n-\n-import junit.framework.TestCase;\n-\n-import java.beans.PropertyChangeEvent;\n-import java.beans.PropertyChangeListener;\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Proxy;\n-import java.util.Map;\n-import java.util.TreeMap;\n-\n-public class EventUtilsTest extends TestCase\n-{\n-    public void testAddEventListener()\n-    {\n-        final PropertyChangeSource src = new PropertyChangeSource();\n-        EventCountingInvociationHandler handler = new EventCountingInvociationHandler();\n-        PropertyChangeListener listener = handler.createListener(PropertyChangeListener.class);\n-        assertEquals(0, handler.getEventCount(\"propertyChange\"));\n-        EventUtils.addEventListener(src, PropertyChangeListener.class, listener);\n-        assertEquals(0, handler.getEventCount(\"propertyChange\"));\n-        src.setProperty(\"newValue\");\n-        assertEquals(1, handler.getEventCount(\"propertyChange\"));\n-    }\n-\n-    public void testBindEventsToMethod()\n-    {\n-        final PropertyChangeSource src = new PropertyChangeSource();\n-        final EventCounter counter = new EventCounter();\n-        EventUtils.bindEventsToMethod(counter, \"eventOccurred\", src, PropertyChangeListener.class);\n-        assertEquals(0, counter.getCount());\n-        src.setProperty(\"newValue\");\n-        assertEquals(1, counter.getCount());\n-    }\n-\n-    public static class EventCounter\n-    {\n-        private int count;\n-\n-        public void eventOccurred()\n-        {\n-            count++;\n-        }\n-\n-        public int getCount()\n-        {\n-            return count;\n-        }\n-    }\n-\n-    private static class EventCountingInvociationHandler implements InvocationHandler\n-    {\n-        private Map<String, Integer> eventCounts = new TreeMap<String, Integer>();\n-\n-        public <L> L createListener(Class<L> listenerType)\n-        {\n-            return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n-                    new Class[]{listenerType},\n-                    this));\n-        }\n-\n-        public int getEventCount(String eventName)\n-        {\n-            Integer count = eventCounts.get(eventName);\n-            return count == null ? 0 : count;\n-        }\n-\n-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n-        {\n-            Integer count = eventCounts.get(method.getName());\n-            if (count == null)\n-            {\n-                eventCounts.put(method.getName(), 1);\n-            }\n-            else\n-            {\n-                eventCounts.put(method.getName(), count + 1);\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class PropertyChangeSource\n-    {\n-        private EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class);\n-\n-        private String property;\n-\n-        public void setProperty(String property)\n-        {\n-            String oldValue = this.property;\n-            this.property = property;\n-            listeners.fire().propertyChange(new PropertyChangeEvent(this, \"property\", \"oldValue\", property));\n-        }\n-\n-        public void addPropertyChangeListener(PropertyChangeListener listener)\n-        {\n-            listeners.addListener(listener);\n-        }\n-\n-        public void removePropertyChangeListener(PropertyChangeListener listener)\n-        {\n-            listeners.removeListener(listener);\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.event;\n+\n+import junit.framework.TestCase;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+public class EventUtilsTest extends TestCase\n+{\n+    public void testAddEventListener()\n+    {\n+        final PropertyChangeSource src = new PropertyChangeSource();\n+        EventCountingInvociationHandler handler = new EventCountingInvociationHandler();\n+        PropertyChangeListener listener = handler.createListener(PropertyChangeListener.class);\n+        assertEquals(0, handler.getEventCount(\"propertyChange\"));\n+        EventUtils.addEventListener(src, PropertyChangeListener.class, listener);\n+        assertEquals(0, handler.getEventCount(\"propertyChange\"));\n+        src.setProperty(\"newValue\");\n+        assertEquals(1, handler.getEventCount(\"propertyChange\"));\n+    }\n+\n+    public void testBindEventsToMethod()\n+    {\n+        final PropertyChangeSource src = new PropertyChangeSource();\n+        final EventCounter counter = new EventCounter();\n+        EventUtils.bindEventsToMethod(counter, \"eventOccurred\", src, PropertyChangeListener.class);\n+        assertEquals(0, counter.getCount());\n+        src.setProperty(\"newValue\");\n+        assertEquals(1, counter.getCount());\n+    }\n+\n+    public static class EventCounter\n+    {\n+        private int count;\n+\n+        public void eventOccurred()\n+        {\n+            count++;\n+        }\n+\n+        public int getCount()\n+        {\n+            return count;\n+        }\n+    }\n+\n+    private static class EventCountingInvociationHandler implements InvocationHandler\n+    {\n+        private Map<String, Integer> eventCounts = new TreeMap<String, Integer>();\n+\n+        public <L> L createListener(Class<L> listenerType)\n+        {\n+            return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n+                    new Class[]{listenerType},\n+                    this));\n+        }\n+\n+        public int getEventCount(String eventName)\n+        {\n+            Integer count = eventCounts.get(eventName);\n+            return count == null ? 0 : count;\n+        }\n+\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n+        {\n+            Integer count = eventCounts.get(method.getName());\n+            if (count == null)\n+            {\n+                eventCounts.put(method.getName(), 1);\n+            }\n+            else\n+            {\n+                eventCounts.put(method.getName(), count + 1);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static class PropertyChangeSource\n+    {\n+        private EventListenerSupport<PropertyChangeListener> listeners = EventListenerSupport.create(PropertyChangeListener.class);\n+\n+        private String property;\n+\n+        public void setProperty(String property)\n+        {\n+            String oldValue = this.property;\n+            this.property = property;\n+            listeners.fire().propertyChange(new PropertyChangeEvent(this, \"property\", \"oldValue\", property));\n+        }\n+\n+        public void addPropertyChangeListener(PropertyChangeListener listener)\n+        {\n+            listeners.addListener(listener);\n+        }\n+\n+        public void removePropertyChangeListener(PropertyChangeListener listener)\n+        {\n+            listeners.removeListener(listener);\n+        }\n+    }\n+}", "timestamp": 1279799882, "metainfo": ""}