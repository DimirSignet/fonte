{"sha": "dcbb82d1f822dc0cafd0097032c3cb01578c500c", "log": "Tidy javadoc  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/VariableFormatter.java\n+++ b/src/java/org/apache/commons/lang/text/VariableFormatter.java\n     }\n \n     /**\n-     * Creates a new instance of <code>VariableFormat</code> and initializes it. Uses a default escaping character.\n+     * Creates a new instance of <code>VariableFormat</code> and initializes it.\n+     * Uses a default escaping character.\n      * \n      * @param valueMap\n      *            the map with the variables' values\n     }\n \n     /**\n-     * Creates a new instance of <code>VariableFormat</code> and initializes it. Uses defaults for variable prefix and\n-     * suffix and the escaping character.\n+     * Creates a new instance of <code>VariableFormat</code> and initializes it.\n+     * Uses defaults for variable prefix and suffix and the escaping character.\n      * \n      * @param valueMap\n      *            the map with the variables' values\n     }\n \n     /**\n-     * Sets the escape character. If this character is placed before a variable reference in the source text, this\n-     * variable will be ignored.\n+     * Sets the escape character. If this character is placed before a\n+     * variable reference in the source text, this variable will be ignored.\n      * \n      * @param escapeCharacter\n      *            the escape character (0 for disabling escaping)\n     }\n \n     /**\n-     * Replaces the occurrences of all variables in the given source data by their current values. If the source\n-     * consists only of a single variable reference, this method directly returns the value of this variable (which can\n-     * be an arbitrary object). If the source contains multiple variable references or static text, the return value\n-     * will always be a String with the concatenation of all these elements.\n+     * Replaces the occurrences of all variables in the given source data by\n+     * their current values. If the source consists only of a single variable\n+     * reference, this method directly returns the value of this variable\n+     * (which can be an arbitrary object). If the source contains multiple\n+     * variable references or static text, the return value will always be a\n+     * String with the concatenation of all these elements.\n      * \n      * @param source\n      *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n     }\n \n     /**\n-     * Replaces the occurrences of all variables in the given source data by their current values.\n+     * Replaces the occurrences of all variables in the given source data by\n+     * their current values.\n      * \n      * @param source\n      *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n     }\n \n     /**\n-     * Replaces the occurrences of all variables in the given source data by their current values obtained from the\n-     * passed in map.\n+     * Replaces the occurrences of all variables in the given source data by\n+     * their current values obtained from the passed in map.\n      * \n      * @param valueMap\n      *            the map with the values\n     }\n \n     /**\n-     * Replaces the occurrences of all variables in the given source data by their current values obtained from the\n-     * passed in map. This method allows to specifiy a custom variable prefix and suffix\n+     * Replaces the occurrences of all variables in the given source data by\n+     * their current values obtained from the passed in map. This method\n+     * allows to specifiy a custom variable prefix and suffix\n      * \n      * @param valueMap\n      *            the map with the values\n     }\n \n     /**\n-     * Replaces all variables in the given source data with values obtained from system properties.\n+     * Replaces all variables in the given source data with values obtained\n+     * from system properties.\n      * \n      * @param source\n      *            the source text\n     }\n \n     /**\n-     * Checks if the variable reference found at the specified position is escaped and if this is the case, where the\n-     * escaped text starts.\n+     * Checks if the variable reference found at the specified position is\n+     * escaped and if this is the case, where the escaped text starts.\n      * \n      * @param text\n      *            the text to be processed\n     }\n \n     /**\n-     * Unescapes an escaped variable reference. This method is called if <code>escaped()</code> has determined an\n-     * escaped variable reference. Its purpose is to remove any escaping characters and to add the resulting text into\n-     * the target buffer. This implementation will remove the first escape character. So if the default values are used,\n+     * Unescapes an escaped variable reference. This method is called if\n+     * <code>escaped()</code> has determined an escaped variable reference.\n+     * Its purpose is to remove any escaping characters and to add the\n+     * resulting text into the target buffer. This implementation will remove\n+     * the first escape character. So if the default values are used,\n      * a text portion of <code>$${myvar}</code> will become <code>${myvar}</code>,\n-     * <code>$$$${var with dollars}</code> will result in <code>$$${var with dollars}</code>. Text between the\n-     * first variable start token and the last unescaped variable end token can contain variable references and will be\n+     * <code>$$$${var with dollars}</code> will result in <code>$$${var with\n+     * dollars}</code>. Text between the first variable start token and the last\n+     * unescaped variable end token can contain variable references and will be\n      * recursively replaced. So constructs of the following form can be built:\n-     * <code>Variable $${${varName$}} is incorrect!</code> (note how the first &quot;}&quot; character is escaped, so\n-     * that the second &quot;}&quot; marks the end of this construct.\n+     * <code>Variable $${${varName$}} is incorrect!</code> (note how the first\n+     * &quot;}&quot; character is escaped, so that the second &quot;}&quot;\n+     * marks the end of this construct.\n      * \n      * @param buf\n      *            the target buffer\n     }\n \n     /**\n-     * Searches for a variable end token in the given string from the specified start position.\n+     * Searches for a variable end token in the given string from the\n+     * specified start position.\n      * \n      * @param text\n      *            the text to search\n     }\n \n     /**\n-     * Resolves the specified variable. This method is called whenever a variable reference is detected in the source\n-     * text. It is passed the variable's name and must return the corresponding value. This implementation accesses the\n-     * value map using the variable's name as key. Derived classes may overload this method to implement a different\n+     * Resolves the specified variable. This method is called whenever a\n+     * variable reference is detected in the source text. It is passed the\n+     * variable's name and must return the corresponding value.\n+     * This implementation accesses the value map using the variable's name\n+     * as key. Derived classes may override this method to implement a different\n      * strategy for resolving variables.\n      * \n      * @param name\n     }\n \n     /**\n-     * Recursive handler for multple levels of interpolation. This is the main interpolation method, which resolves the\n-     * values of all variable references contained in the passed in text.\n+     * Recursive handler for multple levels of interpolation. This is the main\n+     * interpolation method, which resolves the values of all variable\n+     * references contained in the passed in text.\n      * \n      * @param base\n      *            string with the ${key} variables\n         result.append(base.substring(prec + getVariableSuffix().length(), base.length()));\n         return (objResult != null && objLen > 0 && objLen == result.length()) ? objResult : result.toString();\n     }\n+\n }", "timestamp": 1120689351, "metainfo": ""}