{"sha": "412c9606904180148afe5e108600704be1b1959c", "log": "Tagging 2.2-rc1  ", "commit": "\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/ArrayUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Array;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n+import org.apache.commons.lang.builder.ToStringStyle;\n+\n+/**\n+ * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n+ * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n+ * \n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code>\n+ * array input. However, an Object array that contains a <code>null</code>\n+ * element may throw an exception. Each method documents its behaviour.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @author Moritz Petersen\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @author Nikolay Metchev\n+ * @author Matthew Hawthorne\n+ * @author Tim O'Brien\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n+ * @author Maarten Coene\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ArrayUtils {\n+\n+    /**\n+     * An empty immutable <code>Object</code> array.\n+     */\n+    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n+    /**\n+     * An empty immutable <code>Class</code> array.\n+     */\n+    public static final Class[] EMPTY_CLASS_ARRAY = new Class[0];\n+    /**\n+     * An empty immutable <code>String</code> array.\n+     */\n+    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n+    /**\n+     * An empty immutable <code>long</code> array.\n+     */\n+    public static final long[] EMPTY_LONG_ARRAY = new long[0];\n+    /**\n+     * An empty immutable <code>Long</code> array.\n+     */\n+    public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n+    /**\n+     * An empty immutable <code>int</code> array.\n+     */\n+    public static final int[] EMPTY_INT_ARRAY = new int[0];\n+    /**\n+     * An empty immutable <code>Integer</code> array.\n+     */\n+    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n+    /**\n+     * An empty immutable <code>short</code> array.\n+     */\n+    public static final short[] EMPTY_SHORT_ARRAY = new short[0];\n+    /**\n+     * An empty immutable <code>Short</code> array.\n+     */\n+    public static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n+    /**\n+     * An empty immutable <code>byte</code> array.\n+     */\n+    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+    /**\n+     * An empty immutable <code>Byte</code> array.\n+     */\n+    public static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n+    /**\n+     * An empty immutable <code>double</code> array.\n+     */\n+    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n+    /**\n+     * An empty immutable <code>Double</code> array.\n+     */\n+    public static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n+    /**\n+     * An empty immutable <code>float</code> array.\n+     */\n+    public static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n+    /**\n+     * An empty immutable <code>Float</code> array.\n+     */\n+    public static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n+    /**\n+     * An empty immutable <code>boolean</code> array.\n+     */\n+    public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n+    /**\n+     * An empty immutable <code>Boolean</code> array.\n+     */\n+    public static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n+    /**\n+     * An empty immutable <code>char</code> array.\n+     */\n+    public static final char[] EMPTY_CHAR_ARRAY = new char[0];\n+    /**\n+     * An empty immutable <code>Character</code> array.\n+     */\n+    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n+\n+    /**\n+     * The index value when an element is not found in a list or array: <code>-1</code>.\n+     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n+     * various method from {@link java.util.List}.\n+     */\n+    public static final int INDEX_NOT_FOUND = -1;\n+\n+    /**\n+     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public ArrayUtils() {\n+      super();\n+    }\n+    \n+    // Basic methods handling multi-dimensional arrays\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Outputs an array as a String, treating <code>null</code> as an empty array.</p>\n+     *\n+     * <p>Multi-dimensional arrays are handled correctly, including\n+     * multi-dimensional primitive arrays.</p>\n+     *\n+     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>\n+     * \n+     * @param array  the array to get a toString for, may be <code>null</code>\n+     * @return a String representation of the array, '{}' if null array input\n+     */\n+    public static String toString(Object array) {\n+        return toString(array, \"{}\");\n+    }\n+\n+    /**\n+     * <p>Outputs an array as a String handling <code>null</code>s.</p>\n+     *\n+     * <p>Multi-dimensional arrays are handled correctly, including\n+     * multi-dimensional primitive arrays.</p>\n+     *\n+     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>\n+     * \n+     * @param array  the array to get a toString for, may be <code>null</code>\n+     * @param stringIfNull  the String to return if the array is <code>null</code>\n+     * @return a String representation of the array\n+     */    \n+    public static String toString(Object array, String stringIfNull) {\n+        if (array == null) {\n+            return stringIfNull;\n+        }\n+        return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();\n+    }\n+\n+    /**\n+     * <p>Get a hashCode for an array handling multi-dimensional arrays correctly.</p>\n+     * \n+     * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>\n+     * \n+     * @param array  the array to get a hashCode for, may be <code>null</code>\n+     * @return a hashCode for the array, zero if null array input\n+     */\n+    public static int hashCode(Object array) {\n+        return new HashCodeBuilder().append(array).toHashCode();\n+    }\n+\n+    /**\n+     * <p>Compares two arrays, using equals(), handling multi-dimensional arrays\n+     * correctly.</p>\n+     * \n+     * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>\n+     * \n+     * @param array1  the left hand array to compare, may be <code>null</code>\n+     * @param array2  the right hand array to compare, may be <code>null</code>\n+     * @return <code>true</code> if the arrays are equal\n+     */\n+    public static boolean isEquals(Object array1, Object array2) {\n+        return new EqualsBuilder().append(array1, array2).isEquals();\n+    }\n+\n+    // To map\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the given array into a {@link java.util.Map}. Each element of the array\n+     * must be either a {@link java.util.Map.Entry} or an Array, containing at least two\n+     * elements, where the first element is used as key and the second as\n+     * value.</p>\n+     *\n+     * <p>This method can be used to initialize:</p>\n+     * <pre>\n+     * // Create a Map mapping colors.\n+     * Map colorMap = MapUtils.toMap(new String[][] {{\n+     *     {\"RED\", \"#FF0000\"},\n+     *     {\"GREEN\", \"#00FF00\"},\n+     *     {\"BLUE\", \"#0000FF\"}});\n+     * </pre>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  an array whose elements are either a {@link java.util.Map.Entry} or\n+     *  an Array containing at least two elements, may be <code>null</code>\n+     * @return a <code>Map</code> that was created from the array\n+     * @throws IllegalArgumentException  if one element of this Array is\n+     *  itself an Array containing less then two elements\n+     * @throws IllegalArgumentException  if the array contains elements other\n+     *  than {@link java.util.Map.Entry} and an Array\n+     */\n+    public static Map toMap(Object[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        final Map map = new HashMap((int) (array.length * 1.5));\n+        for (int i = 0; i < array.length; i++) {\n+            Object object = array[i];\n+            if (object instanceof Map.Entry) {\n+                Map.Entry entry = (Map.Entry) object;\n+                map.put(entry.getKey(), entry.getValue());\n+            } else if (object instanceof Object[]) {\n+                Object[] entry = (Object[]) object;\n+                if (entry.length < 2) {\n+                    throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n+                        + object\n+                        + \"', has a length less than 2\");\n+                }\n+                map.put(entry[0], entry[1]);\n+            } else {\n+                throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n+                        + object\n+                        + \"', is neither of type Map.Entry nor an Array\");\n+            }\n+        }\n+        return map;\n+    }\n+\n+    // Clone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Shallow clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>The objects in the array are not cloned, thus there is no special\n+     * handling for multi-dimensional arrays.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to shallow clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static Object[] clone(Object[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (Object[]) array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static long[] clone(long[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (long[]) array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static int[] clone(int[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (int[]) array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static short[] clone(short[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (short[]) array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static char[] clone(char[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (char[]) array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static byte[] clone(byte[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (byte[]) array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static double[] clone(double[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (double[]) array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static float[] clone(float[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (float[]) array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static boolean[] clone(boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return (boolean[]) array.clone();\n+    }\n+\n+    // Subarrays\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Produces a new array containing the elements between\n+     * the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * <p>The component type of the subarray is always the same as\n+     * that of the input array. Thus, if the input is an array of type\n+     * <code>Date</code>, the following usage is envisaged:</p>\n+     *\n+     * <pre>\n+     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n+     * </pre>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        Class type = array.getClass().getComponentType();\n+        if (newSize <= 0) {\n+            return (Object[]) Array.newInstance(type, 0);\n+        }\n+        Object[] subarray = (Object[]) Array.newInstance(type, newSize);\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>long</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+\n+        long[] subarray = new long[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>int</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+\n+        int[] subarray = new int[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>short</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+\n+        short[] subarray = new short[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>char</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+\n+        char[] subarray = new char[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>byte</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+\n+        byte[] subarray = new byte[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>double</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+\n+        double[] subarray = new double[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>float</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+\n+        float[] subarray = new float[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>boolean</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+\n+        boolean[] subarray = new boolean[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    // Is same length\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.\n+     *\n+     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */    \n+    public static boolean isSameLength(Object[] array1, Object[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(long[] array1, long[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(int[] array1, int[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(short[] array1, short[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(char[] array1, char[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(byte[] array1, byte[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(double[] array1, double[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(float[] array1, float[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     * \n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(boolean[] array1, boolean[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the length of the specified array.\n+     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.getLength(null)            = 0\n+     * ArrayUtils.getLength([])              = 0\n+     * ArrayUtils.getLength([null])          = 1\n+     * ArrayUtils.getLength([true, false])   = 2\n+     * ArrayUtils.getLength([1, 2, 3])       = 3\n+     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n+     * </pre>\n+     *\n+     * @param array  the array to retrieve the length from, may be null\n+     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n+     * @throws IllegalArgumentException if the object arguement is not an array.\n+     * @since 2.1\n+     */\n+    public static int getLength(Object array) {\n+        if (array == null) {\n+            return 0;\n+        }\n+        return Array.getLength(array);\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same type taking into account\n+     * multi-dimensional arrays.</p>\n+     * \n+     * @param array1 the first array, must not be <code>null</code>\n+     * @param array2 the second array, must not be <code>null</code>\n+     * @return <code>true</code> if type of arrays matches\n+     * @throws IllegalArgumentException if either array is <code>null</code>\n+     */    \n+    public static boolean isSameType(Object array1, Object array2) {\n+        if (array1 == null || array2 == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        }\n+        return array1.getClass().getName().equals(array2.getClass().getName());\n+    }\n+\n+    // Reverse\n+    //-----------------------------------------------------------------------\n+    /** \n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>There is no special handling for multi-dimensional arrays.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(Object[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        Object tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     * \n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(long[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        long tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     * \n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(int[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        int tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     * \n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(short[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        short tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     * \n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(char[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        char tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     * \n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(byte[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        byte tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     * \n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(double[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        double tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     * \n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(float[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        float tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     * \n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(boolean[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        boolean tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    // IndexOf search\n+    // ----------------------------------------------------------------------\n+    \n+    // Object IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given object in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @return the index of the object within the array, \n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(Object[] array, Object objectToFind) {\n+        return indexOf(array, objectToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given object in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the object within the array starting at the index,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(Object[] array, Object objectToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        if (objectToFind == null) {\n+            for (int i = startIndex; i < array.length; i++) {\n+                if (array[i] == null) {\n+                    return i;\n+                }\n+            }\n+        } else {\n+            for (int i = startIndex; i < array.length; i++) {\n+                if (objectToFind.equals(array[i])) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given object within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @return the last index of the object within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(Object[] array, Object objectToFind) {\n+        return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n+     * the array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the object within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        if (objectToFind == null) {\n+            for (int i = startIndex; i >= 0; i--) {\n+                if (array[i] == null) {\n+                    return i;\n+                }\n+            }\n+        } else {\n+            for (int i = startIndex; i >= 0; i--) {\n+                if (objectToFind.equals(array[i])) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the object is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param objectToFind  the object to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(Object[] array, Object objectToFind) {\n+        return indexOf(array, objectToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // long IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(long[] array, long valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(long[] array, long valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(long[] array, long valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(long[] array, long valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // int IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(int[] array, int valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(int[] array, int valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(int[] array, int valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(int[] array, int valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // short IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(short[] array, short valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(short[] array, short valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(short[] array, short valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the \n+     * array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(short[] array, short valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // char IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int indexOf(char[] array, char valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int indexOf(char[] array, char valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int lastIndexOf(char[] array, char valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     * @since 2.1\n+     */\n+    public static boolean contains(char[] array, char valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // byte IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(byte[] array, byte valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(byte[] array, byte valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(byte[] array, byte valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the \n+     * array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(byte[] array, byte valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // double IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value within a given tolerance in the array.\n+     * This method will return the index of the first value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, double tolerance) {\n+        return indexOf(array, valueToFind, 0, tolerance);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.\n+     * This method will return the index of the first value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        double min = valueToFind - tolerance;\n+        double max = valueToFind + tolerance;\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (array[i] >= min && array[i] <= max) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within a given tolerance in the array.\n+     * This method will return the index of the last value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the \n+     * array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.\n+     * This method will return the index of the last value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the \n+     * array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @param tolerance  search for value within plus/minus this amount\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        double min = valueToFind - tolerance;\n+        double max = valueToFind + tolerance;\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (array[i] >= min && array[i] <= max) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(double[] array, double valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if a value falling within the given tolerance is in the\n+     * given array.  If the array contains a value within the inclusive range \n+     * defined by (value - tolerance) to (value + tolerance).</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array\n+     * is passed in.</p>\n+     *\n+     * @param array  the array to search\n+     * @param valueToFind  the value to find\n+     * @param tolerance  the array contains the tolerance of the search\n+     * @return true if value falling within tolerance is in array\n+     */\n+    public static boolean contains(double[] array, double valueToFind, double tolerance) {\n+        return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;\n+    }\n+\n+    // float IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(float[] array, float valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(float[] array, float valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(float[] array, float valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the \n+     * array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(float[] array, float valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // boolean IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(boolean[] array, boolean valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     * \n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n+     *  array input\n+     */\n+    public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if \n+     * <code>null</code> array input.</p>\n+     * \n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(boolean[] array, boolean valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than \n+     * the array length will search from the end of the array.</p>\n+     * \n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     * \n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(boolean[] array, boolean valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // Primitive/Object array converters\n+    // ----------------------------------------------------------------------\n+\n+    // Character array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Characters to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Character</code> array, may be <code>null</code>\n+     * @return a <code>char</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static char[] toPrimitive(Character[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+        final char[] result = new char[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].charValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Character</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>char</code> array, <code>null</code> if null array input\n+     */\n+    public static char[] toPrimitive(Character[] array, char valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+        final char[] result = new char[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Character b = array[i];\n+            result[i] = (b == null ? valueForNull : b.charValue());\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * <p>Converts an array of primitive chars to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array a <code>char</code> array\n+     * @return a <code>Character</code> array, <code>null</code> if null array input\n+     */\n+    public static Character[] toObject(char[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHARACTER_OBJECT_ARRAY;\n+        }\n+        final Character[] result = new Character[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = new Character(array[i]);\n+        }\n+        return result;\n+     }    \n+    \n+    // Long array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Longs to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Long</code> array, may be <code>null</code>\n+     * @return a <code>long</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static long[] toPrimitive(Long[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+        final long[] result = new long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].longValue();\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Long</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>long</code> array, <code>null</code> if null array input\n+     */\n+    public static long[] toPrimitive(Long[] array, long valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+        final long[] result = new long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Long b = array[i];\n+            result[i] = (b == null ? valueForNull : b.longValue());\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * <p>Converts an array of primitive longs to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>long</code> array\n+     * @return a <code>Long</code> array, <code>null</code> if null array input\n+     */\n+    public static Long[] toObject(long[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_OBJECT_ARRAY;\n+        }\n+        final Long[] result = new Long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = new Long(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Int array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Integers to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Integer</code> array, may be <code>null</code>\n+     * @return an <code>int</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static int[] toPrimitive(Integer[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+        final int[] result = new int[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].intValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Integer</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return an <code>int</code> array, <code>null</code> if null array input\n+     */\n+    public static int[] toPrimitive(Integer[] array, int valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+        final int[] result = new int[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Integer b = array[i];\n+            result[i] = (b == null ? valueForNull : b.intValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive ints to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  an <code>int</code> array\n+     * @return an <code>Integer</code> array, <code>null</code> if null array input\n+     */\n+    public static Integer[] toObject(int[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INTEGER_OBJECT_ARRAY;\n+        }\n+        final Integer[] result = new Integer[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = new Integer(array[i]);\n+        }\n+        return result;\n+    }\n+    \n+    // Short array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Shorts to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Short</code> array, may be <code>null</code>\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static short[] toPrimitive(Short[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+        final short[] result = new short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].shortValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Short</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     */\n+    public static short[] toPrimitive(Short[] array, short valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+        final short[] result = new short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Short b = array[i];\n+            result[i] = (b == null ? valueForNull : b.shortValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive shorts to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>short</code> array\n+     * @return a <code>Short</code> array, <code>null</code> if null array input\n+     */\n+    public static Short[] toObject(short[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_OBJECT_ARRAY;\n+        }\n+        final Short[] result = new Short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = new Short(array[i]);\n+        }\n+        return result;\n+    }    \n+\n+    // Byte array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Bytes to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Byte</code> array, may be <code>null</code>\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static byte[] toPrimitive(Byte[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        final byte[] result = new byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].byteValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Byte</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     */\n+    public static byte[] toPrimitive(Byte[] array, byte valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        final byte[] result = new byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Byte b = array[i];\n+            result[i] = (b == null ? valueForNull : b.byteValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive bytes to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>byte</code> array\n+     * @return a <code>Byte</code> array, <code>null</code> if null array input\n+     */\n+    public static Byte[] toObject(byte[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_OBJECT_ARRAY;\n+        }\n+        final Byte[] result = new Byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = new Byte(array[i]);\n+        }\n+        return result;\n+    }  \n+    \n+    // Double array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Doubles to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Double</code> array, may be <code>null</code>\n+     * @return a <code>double</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static double[] toPrimitive(Double[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+        final double[] result = new double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].doubleValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Double</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>double</code> array, <code>null</code> if null array input\n+     */\n+    public static double[] toPrimitive(Double[] array, double valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+        final double[] result = new double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Double b = array[i];\n+            result[i] = (b == null ? valueForNull : b.doubleValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive doubles to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>double</code> array\n+     * @return a <code>Double</code> array, <code>null</code> if null array input\n+     */\n+    public static Double[] toObject(double[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_OBJECT_ARRAY;\n+        }\n+        final Double[] result = new Double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = new Double(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    //   Float array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Floats to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Float</code> array, may be <code>null</code>\n+     * @return a <code>float</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static float[] toPrimitive(Float[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+        final float[] result = new float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].floatValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Float</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>float</code> array, <code>null</code> if null array input\n+     */\n+    public static float[] toPrimitive(Float[] array, float valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+        final float[] result = new float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Float b = array[i];\n+            result[i] = (b == null ? valueForNull : b.floatValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive floats to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>float</code> array\n+     * @return a <code>Float</code> array, <code>null</code> if null array input\n+     */\n+    public static Float[] toObject(float[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_OBJECT_ARRAY;\n+        }\n+        final Float[] result = new Float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = new Float(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Boolean array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Booleans to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n+     * @return a <code>boolean</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static boolean[] toPrimitive(Boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+        final boolean[] result = new boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].booleanValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n+     * \n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>boolean</code> array, <code>null</code> if null array input\n+     */\n+    public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+        final boolean[] result = new boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Boolean b = array[i];\n+            result[i] = (b == null ? valueForNull : b.booleanValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive booleans to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     * \n+     * @param array  a <code>boolean</code> array\n+     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n+     */\n+    public static Boolean[] toObject(boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_OBJECT_ARRAY;\n+        }\n+        final Boolean[] result = new Boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);\n+        }\n+        return result;\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(Object[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(long[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(int[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(short[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(char[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(byte[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(double[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(float[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(boolean[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(null, null)     = null\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * ArrayUtils.addAll([null], [null]) = [null, null]\n+     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n+     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n+     * @return The new array, <code>null</code> if <code>null</code> array inputs. \n+     *      The type of the new array is the type of the first array.\n+     * @since 2.1\n+     */\n+    public static Object[] addAll(Object[] array1, Object[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        Object[] joinedArray = (Object[]) Array.newInstance(array1.getClass().getComponentType(),\n+                                                            array1.length + array2.length);\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new boolean[] array.\n+     * @since 2.1\n+     */\n+    public static boolean[] addAll(boolean[] array1, boolean[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        boolean[] joinedArray = new boolean[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new char[] array.\n+     * @since 2.1\n+     */\n+    public static char[] addAll(char[] array1, char[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        char[] joinedArray = new char[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new byte[] array.\n+     * @since 2.1\n+     */\n+    public static byte[] addAll(byte[] array1, byte[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        byte[] joinedArray = new byte[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new short[] array.\n+     * @since 2.1\n+     */\n+    public static short[] addAll(short[] array1, short[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        short[] joinedArray = new short[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new int[] array.\n+     * @since 2.1\n+     */\n+    public static int[] addAll(int[] array1, int[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        int[] joinedArray = new int[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new long[] array.\n+     * @since 2.1\n+     */\n+    public static long[] addAll(long[] array1, long[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        long[] joinedArray = new long[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new float[] array.\n+     * @since 2.1\n+     */\n+    public static float[] addAll(float[] array1, float[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        float[] joinedArray = new float[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new double[] array.\n+     * @since 2.1\n+     */\n+    public static double[] addAll(double[] array1, double[] array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        double[] joinedArray = new double[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, null)      = [null]\n+     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n+     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n+     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n+     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     * \n+     * @param array  the array to \"add\" the element to, may be <code>null</code>\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static Object[] add(Object[] array, Object element) {\n+        Class type = (array != null ? array.getClass() : (element != null ? element.getClass() : Object.class));\n+        Object[] newArray = (Object[]) copyArrayGrow1(array, type);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, true)          = [true]\n+     * ArrayUtils.add([true], false)       = [true, false]\n+     * ArrayUtils.add([true, false], true) = [true, false, true]\n+     * </pre>\n+     * \n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static boolean[] add(boolean[] array, boolean element) {\n+        boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static byte[] add(byte[] array, byte element) {\n+        byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, '0')       = ['0']\n+     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n+     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n+     * </pre>\n+     * \n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static char[] add(char[] array, char element) {\n+        char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static double[] add(double[] array, double element) {\n+        double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static float[] add(float[] array, float element) {\n+        float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static int[] add(int[] array, int element) {\n+        int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static long[] add(long[] array, long element) {\n+        long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of \n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static short[] add(short[] array, short element) {\n+        short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+    \n+    /**\n+     * Returns a copy of the given array of size 1 greater than the argument. \n+     * The last value of the array is left to the default value.\n+     * \n+     * @param array The array to copy, must not be <code>null</code>.\n+     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a \n+     * size 1 array of this type.\n+     * @return A new copy of the array of size 1 greater than the input.\n+     */    \n+    private static Object copyArrayGrow1(Object array, Class newArrayComponentType) {\n+        if (array != null) {\n+            int arrayLength = Array.getLength(array);\n+            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n+            System.arraycopy(array, 0, newArray, 0, arrayLength);\n+            return newArray;\n+        }\n+        return Array.newInstance(newArrayComponentType, 1);\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0, null)      = [null]\n+     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n+     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n+     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n+     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static Object[] add(Object[] array, int index, Object element) {\n+        Class clss = null;\n+        if(array != null) {\n+            clss = array.getClass().getComponentType();\n+        } else\n+        if(element != null) {\n+            clss = element.getClass();\n+        } else {\n+            return new Object[] { null };\n+        }\n+        return (Object[]) add( array, index, element, clss );\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0, true)          = [true]\n+     * ArrayUtils.add([true], 0, false)       = [false, true]\n+     * ArrayUtils.add([false], 1, true)       = [false, true]\n+     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static boolean[] add(boolean[] array, int index, boolean element) {\n+        return (boolean[]) add( array, index, BooleanUtils.toBooleanObject(element), Boolean.TYPE );\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add(null, 0, 'a')            = ['a']\n+     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n+     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n+     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n+     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static char[] add(char[] array, int index, char element) {\n+        return (char[]) add( array, index, new Character(element), Character.TYPE );\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n+     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static byte[] add(byte[] array, int index, byte element) {\n+        return (byte[]) add( array, index, new Byte(element), Byte.TYPE );\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n+     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static short[] add(short[] array, int index, short element) {\n+        return (short[]) add( array, index, new Short(element), Short.TYPE );\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n+     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static int[] add(int[] array, int index, int element) {\n+        return (int[]) add( array, index, new Integer(element), Integer.TYPE );\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n+     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n+     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n+     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static long[] add(long[] array, int index, long element) {\n+        return (long[]) add( array, index, new Long(element), Long.TYPE );\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n+     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n+     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n+     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static float[] add(float[] array, int index, float element) {\n+        return (float[]) add( array, index, new Float(element), Float.TYPE );\n+    }\n+    \n+    /**\n+     * <p>Inserts the specified element at the specified position in the array. \n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     * \n+     * <pre>\n+     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n+     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n+     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n+     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n+     * </pre>\n+     * \n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index > array.length).\n+     */\n+    public static double[] add(double[] array, int index, double element) {\n+        return (double[]) add( array, index, new Double(element), Double.TYPE );\n+    }\n+    \n+    /**\n+     * Underlying implementation of add(array, index, element) methods. \n+     * The last parameter is the class, which may not equal element.getClass \n+     * for primitives.\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @param clss the type of the element being added\n+     * @return A new array containing the existing elements and the new element\n+     */\n+    private static Object add(Object array, int index, Object element, Class clss) {\n+        if (array == null) {\n+            if (index != 0) {\n+                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n+            }\n+            Object joinedArray = Array.newInstance(clss, 1);\n+            Array.set(joinedArray, 0, element);\n+            return joinedArray;\n+        }\n+        int length = Array.getLength(array);\n+        if (index > length || index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+        }\n+        Object result = Array.newInstance(clss, length + 1);\n+        System.arraycopy(array, 0, result, 0, index);\n+        Array.set(result, index, element);\n+        if (index < length) {\n+            System.arraycopy(array, index, result, index + 1, length - index);\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([\"a\"], 0)           = []\n+     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n+     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n+     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static Object[] remove(Object[] array, int index) {\n+        return (Object[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, \"a\")            = null\n+     * ArrayUtils.removeElement([], \"a\")              = []\n+     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n+     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n+     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static Object[] removeElement(Object[] array, Object element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([true], 0)              = []\n+     * ArrayUtils.remove([true, false], 0)       = [false]\n+     * ArrayUtils.remove([true, false], 1)       = [true]\n+     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static boolean[] remove(boolean[] array, int index) {\n+        return (boolean[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, true)                = null\n+     * ArrayUtils.removeElement([], true)                  = []\n+     * ArrayUtils.removeElement([true], false)             = [true]\n+     * ArrayUtils.removeElement([true, false], false)      = [true]\n+     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static boolean[] removeElement(boolean[] array, boolean element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)          = []\n+     * ArrayUtils.remove([1, 0], 0)       = [0]\n+     * ArrayUtils.remove([1, 0], 1)       = [1]\n+     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static byte[] remove(byte[] array, int index) {\n+        return (byte[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)        = null\n+     * ArrayUtils.removeElement([], 1)          = []\n+     * ArrayUtils.removeElement([1], 0)         = [1]\n+     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n+     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static byte[] removeElement(byte[] array, byte element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove(['a'], 0)           = []\n+     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n+     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n+     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static char[] remove(char[] array, int index) {\n+        return (char[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 'a')            = null\n+     * ArrayUtils.removeElement([], 'a')              = []\n+     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n+     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n+     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static char[] removeElement(char[] array, char element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1.1], 0)           = []\n+     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n+     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n+     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static double[] remove(double[] array, int index) {\n+        return (double[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1.1)            = null\n+     * ArrayUtils.removeElement([], 1.1)              = []\n+     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n+     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n+     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static double[] removeElement(double[] array, double element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1.1], 0)           = []\n+     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n+     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n+     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static float[] remove(float[] array, int index) {\n+        return (float[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1.1)            = null\n+     * ArrayUtils.removeElement([], 1.1)              = []\n+     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n+     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n+     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static float[] removeElement(float[] array, float element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static int[] remove(int[] array, int index) {\n+        return (int[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static int[] removeElement(int[] array, int element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static long[] remove(long[] array, int index) {\n+        return (long[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static long[] removeElement(long[] array, long element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static short[] remove(short[] array, int index) {\n+        return (short[]) remove((Object) array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left \n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     * \n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static short[] removeElement(short[] array, short element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        } \n+        return remove(array, index);\n+    }\n+    \n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component \n+     * type of the returned array is always the same as that of the input \n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     * \n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range \n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    private static Object remove(Object array, int index) {\n+        int length = getLength(array);\n+        if (index < 0 || index >= length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+        }\n+        \n+        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n+        System.arraycopy(array, 0, result, 0, index);\n+        if (index < length - 1) {\n+            System.arraycopy(array, index + 1, result, index, length - index - 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/BitField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Operations on bit-mapped fields.</p>\n+ *\n+ * @author Apache Jakarta POI\n+ * @author Scott Sanders (sanders at apache dot org)\n+ * @author Marc Johnson (mjohnson at apache dot org)\n+ * @author Andrew C. Oliver (acoliver at apache dot org)\n+ * @author Stephen Colebourne\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class BitField {\n+    \n+    private final int _mask;\n+    private final int _shift_count;\n+\n+    /**\n+     * <p>Creates a BitField instance.</p>\n+     *\n+     * @param mask the mask specifying which bits apply to this\n+     *  BitField. Bits that are set in this mask are the bits\n+     *  that this BitField operates on\n+     */\n+    public BitField(int mask) {\n+        _mask = mask;\n+        int count = 0;\n+        int bit_pattern = mask;\n+\n+        if (bit_pattern != 0) {\n+            while ((bit_pattern & 1) == 0) {\n+                count++;\n+                bit_pattern >>= 1;\n+            }\n+        }\n+        _shift_count = count;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, appropriately\n+     * shifted right.</p>\n+     *\n+     * <p>Many users of a BitField will want to treat the specified\n+     * bits as an int value, and will not want to be aware that the\n+     * value is stored as a BitField (and so shifted left so many\n+     * bits).</p>\n+     *\n+     * @see #setValue(int,int)\n+     * @param holder the int data containing the bits we're interested\n+     *  in\n+     * @return the selected bits, shifted right appropriately\n+     */\n+    public int getValue(int holder) {\n+        return getRawValue(holder) >> _shift_count;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, appropriately\n+     * shifted right, as a short.</p>\n+     *\n+     * <p>Many users of a BitField will want to treat the specified\n+     * bits as an int value, and will not want to be aware that the\n+     * value is stored as a BitField (and so shifted left so many\n+     * bits).</p>\n+     *\n+     * @see #setShortValue(short,short)\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the selected bits, shifted right appropriately\n+     */\n+    public short getShortValue(short holder) {\n+        return (short) getValue(holder);\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, unshifted.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the selected bits\n+     */\n+    public int getRawValue(int holder) {\n+        return holder & _mask;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, unshifted.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the selected bits\n+     */\n+    public short getShortRawValue(short holder) {\n+        return (short) getRawValue(holder);\n+    }\n+\n+    /**\n+     * <p>Returns whether the field is set or not.</p>\n+     *\n+     * <p>This is most commonly used for a single-bit field, which is\n+     * often used to represent a boolean value; the results of using\n+     * it for a multi-bit field is to determine whether *any* of its\n+     * bits are set.</p>\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *  in\n+     * @return <code>true</code> if any of the bits are set,\n+     *  else <code>false</code>\n+     */\n+    public boolean isSet(int holder) {\n+        return (holder & _mask) != 0;\n+    }\n+\n+    /**\n+     * <p>Returns whether all of the bits are set or not.</p>\n+     *\n+     * <p>This is a stricter test than {@link #isSet(int)},\n+     * in that all of the bits in a multi-bit set must be set\n+     * for this method to return <code>true</code>.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return <code>true</code> if all of the bits are set,\n+     *  else <code>false</code>\n+     */\n+    public boolean isAllSet(int holder) {\n+        return (holder & _mask) == _mask;\n+    }\n+\n+    /**\n+     * <p>Replaces the bits with new values.</p>\n+     *\n+     * @see #getValue(int)\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @param value the new value for the specified bits\n+     * @return the value of holder with the bits from the value\n+     *  parameter replacing the old bits\n+     */\n+    public int setValue(int holder, int value) {\n+        return (holder & ~_mask) | ((value << _shift_count) & _mask);\n+    }\n+\n+    /**\n+     * <p>Replaces the bits with new values.</p>\n+     *\n+     * @see #getShortValue(short)\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @param value the new value for the specified bits\n+     * @return the value of holder with the bits from the value\n+     *  parameter replacing the old bits\n+     */\n+    public short setShortValue(short holder, short value) {\n+        return (short) setValue(holder, value);\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public int clear(int holder) {\n+        return holder & ~_mask;\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public short clearShort(short holder) {\n+        return (short) clear(holder);\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     *\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public byte clearByte(byte holder) {\n+        return (byte) clear(holder);\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public int set(int holder) {\n+        return holder | _mask;\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public short setShort(short holder) {\n+        return (short) set(holder);\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     *\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public byte setByte(byte holder) {\n+        return (byte) set(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *         cleared\n+     */\n+    public int setBoolean(int holder, boolean flag) {\n+        return flag ? set(holder) : clear(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *  cleared\n+     */\n+    public short setShortBoolean(short holder, boolean flag) {\n+        return flag ? setShort(holder) : clearShort(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *  cleared\n+     */\n+    public byte setByteBoolean(byte holder, boolean flag) {\n+        return flag ? setByte(holder) : clearByte(holder);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/BooleanUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import org.apache.commons.lang.math.NumberUtils;\n+\n+/**\n+ * <p>Operations on boolean primitives and Boolean objects.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Stephen Colebourne\n+ * @author Matthew Hawthorne\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class BooleanUtils {\n+\n+    /**\n+     * <p><code>BooleanUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>BooleanUtils.toBooleanObject(true);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public BooleanUtils() {\n+      super();\n+    }\n+\n+    // Boolean utilities\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Negates the specified boolean.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.negate(Boolean.TRUE)  = Boolean.FALSE;\n+     *   BooleanUtils.negate(Boolean.FALSE) = Boolean.TRUE;\n+     *   BooleanUtils.negate(null)          = null;\n+     * </pre>\n+     * \n+     * @param bool  the Boolean to negate, may be null\n+     * @return the negated Boolean, or <code>null</code> if <code>null</code> input\n+     */\n+    public static Boolean negate(Boolean bool) {\n+        if (bool == null) {\n+            return null;\n+        }\n+        return (bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE);\n+    }\n+    \n+    // boolean Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Is a Boolean value <code>true</code>, handling <code>null</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isTrue(Boolean.TRUE)  = true\n+     *   BooleanUtils.isTrue(Boolean.FALSE) = false\n+     *   BooleanUtils.isTrue(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return <code>true</code> only if the input is non-null and true\n+     * @since 2.1\n+     */\n+    public static boolean isTrue(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+\n+    /**\n+     * <p>Is a Boolean value <code>false</code>, handling <code>null</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isFalse(Boolean.TRUE)  = false\n+     *   BooleanUtils.isFalse(Boolean.FALSE) = true\n+     *   BooleanUtils.isFalse(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return <code>true</code> only if the input is non-null and false\n+     * @since 2.1\n+     */\n+    public static boolean isFalse(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? false : true;\n+    }\n+\n+    /**\n+     * <p>Boolean factory that avoids creating new Boolean objecs all the time.</p>\n+     * \n+     * <p>This method was added to JDK1.4 but is available here for earlier JDKs.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(false) = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(true)  = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return Boolean.TRUE or Boolean.FALSE as appropriate\n+     */\n+    public static Boolean toBooleanObject(boolean bool) {\n+        return bool ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a boolean handling <code>null</code>\n+     * by returning <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(Boolean.TRUE)  = true\n+     *   BooleanUtils.toBoolean(Boolean.FALSE) = false\n+     *   BooleanUtils.toBoolean(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return <code>true</code> or <code>false</code>, \n+     *  <code>null</code> returns <code>false</code>\n+     */\n+    public static boolean toBoolean(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a boolean handling <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false) = true\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true) = false\n+     *   BooleanUtils.toBooleanDefaultIfNull(null, true)          = true\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @param valueIfNull  the boolean value to return if <code>null</code>\n+     * @return <code>true</code> or <code>false</code>\n+     */\n+    public static boolean toBooleanDefaultIfNull(Boolean bool, boolean valueIfNull) {\n+        if (bool == null) {\n+            return valueIfNull;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+    \n+    // Integer to Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an int to a boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0) = false\n+     *   BooleanUtils.toBoolean(1) = true\n+     *   BooleanUtils.toBoolean(2) = true\n+     * </pre>\n+     *\n+     * @param value  the int to convert\n+     * @return <code>true</code> if non-zero, <code>false</code>\n+     *  if zero\n+     */\n+    public static boolean toBoolean(int value) {\n+        return value == 0 ? false : true;\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a Boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0) = Boolean.FALSE\n+     *   BooleanUtils.toBoolean(1) = Boolean.TRUE\n+     *   BooleanUtils.toBoolean(2) = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param value  the int to convert\n+     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n+     *  <code>null</code> if <code>null</code>\n+     */\n+    public static Boolean toBooleanObject(int value) {\n+        return value == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a Boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <p><code>null</code> will be converted to <code>null</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(new Integer(0))    = Boolean.FALSE\n+     *   BooleanUtils.toBoolean(new Integer(1))    = Boolean.TRUE\n+     *   BooleanUtils.toBoolean(new Integer(null)) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n+     *  <code>null</code> if <code>null</code> input\n+     */\n+    public static Boolean toBooleanObject(Integer value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0, 1, 0) = false\n+     *   BooleanUtils.toBoolean(1, 1, 0) = true\n+     *   BooleanUtils.toBoolean(2, 1, 2) = false\n+     *   BooleanUtils.toBoolean(2, 2, 0) = true\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>\n+     * @param falseValue  the value to match for <code>false</code>\n+     * @return <code>true</code> or <code>false</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static boolean toBoolean(int value, int trueValue, int falseValue) {\n+        if (value == trueValue) {\n+            return true;\n+        } else if (value == falseValue) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(new Integer(0), new Integer(1), new Integer(0)) = false\n+     *   BooleanUtils.toBoolean(new Integer(1), new Integer(1), new Integer(0)) = true\n+     *   BooleanUtils.toBoolean(new Integer(2), new Integer(1), new Integer(2)) = false\n+     *   BooleanUtils.toBoolean(new Integer(2), new Integer(2), new Integer(0)) = true\n+     *   BooleanUtils.toBoolean(null, null, new Integer(0))                     = true\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to match for <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return <code>true</code> or <code>false</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static boolean toBoolean(Integer value, Integer trueValue, Integer falseValue) {\n+        if (value == null) {\n+            if (trueValue == null) {\n+                return true;\n+            } else if (falseValue == null) {\n+                return false;\n+            }\n+        } else if (value.equals(trueValue)) {\n+            return true;\n+        } else if (value.equals(falseValue)) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a Boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(0, 0, 2, 3) = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(2, 1, 2, 3) = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(3, 1, 2, 3) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>\n+     * @param falseValue  the value to match for <code>false</code>\n+     * @param nullValue  the value to to match for <code>null</code>\n+     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static Boolean toBooleanObject(int value, int trueValue, int falseValue, int nullValue) {\n+        if (value == trueValue) {\n+            return Boolean.TRUE;\n+        } else if (value == falseValue) {\n+            return Boolean.FALSE;\n+        } else if (value == nullValue) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a Boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(new Integer(0), new Integer(0), new Integer(2), new Integer(3)) = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(new Integer(2), new Integer(1), new Integer(2), new Integer(3)) = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(new Integer(3), new Integer(1), new Integer(2), new Integer(3)) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to match for <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullValue  the value to to match for <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static Boolean toBooleanObject(Integer value, Integer trueValue, Integer falseValue, Integer nullValue) {\n+        if (value == null) {\n+            if (trueValue == null) {\n+                return Boolean.TRUE;\n+            } else if (falseValue == null) {\n+                return Boolean.FALSE;\n+            } else if (nullValue == null) {\n+                return null;\n+            }\n+        } else if (value.equals(trueValue)) {\n+            return Boolean.TRUE;\n+        } else if (value.equals(falseValue)) {\n+            return Boolean.FALSE;\n+        } else if (value.equals(nullValue)) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n+    }\n+    \n+    // Boolean to Integer methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a boolean to an int using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toInteger(true)  = 1\n+     *   BooleanUtils.toInteger(false) = 0\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return one if <code>true</code>, zero if <code>false</code>\n+     */\n+    public static int toInteger(boolean bool) {\n+        return bool ? 1 : 0;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an Integer using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(true)  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(false) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return one if <code>true</code>, zero if <code>false</code>\n+     */\n+    public static Integer toIntegerObject(boolean bool) {\n+        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a Integer using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     *\n+     * <p><code>null</code> will be converted to <code>null</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(Boolean.TRUE)  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(Boolean.FALSE) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @return one if Boolean.TRUE, zero if Boolean.FALSE, <code>null</code> if <code>null</code>\n+     */\n+    public static Integer toIntegerObject(Boolean bool) {\n+        if (bool == null) {\n+            return null;\n+        }\n+        return bool.booleanValue() ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an int specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toInteger(true, 1, 0)  = 1\n+     *   BooleanUtils.toInteger(false, 1, 0) = 0\n+     * </pre>\n+     *\n+     * @param bool  the to convert\n+     * @param trueValue  the value to return if <code>true</code>\n+     * @param falseValue  the value to return if <code>false</code>\n+     * @return the appropriate value\n+     */\n+    public static int toInteger(boolean bool, int trueValue, int falseValue) {\n+        return bool ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to an int specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1\n+     *   BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0\n+     *   BooleanUtils.toInteger(null, 1, 0, 2)          = 2\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @param trueValue  the value to return if <code>true</code>\n+     * @param falseValue  the value to return if <code>false</code>\n+     * @param nullValue  the value to return if <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static int toInteger(Boolean bool, int trueValue, int falseValue, int nullValue) {\n+        if (bool == null) {\n+            return nullValue;\n+        }\n+        return bool.booleanValue() ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an Integer specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(true, new Integer(1), new Integer(0))  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(false, new Integer(1), new Integer(0)) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the to convert\n+     * @param trueValue  the value to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static Integer toIntegerObject(boolean bool, Integer trueValue, Integer falseValue) {\n+        return bool ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to an Integer specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(Boolean.TRUE, new Integer(1), new Integer(0), new Integer(2))  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(Boolean.FALSE, new Integer(1), new Integer(0), new Integer(2)) = new Integer(0)\n+     *   BooleanUtils.toIntegerObject(null, new Integer(1), new Integer(0), new Integer(2))          = new Integer(2)\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @param trueValue  the value to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullValue  the value to return if <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static Integer toIntegerObject(Boolean bool, Integer trueValue, Integer falseValue, Integer nullValue) {\n+        if (bool == null) {\n+            return nullValue;\n+        }\n+        return bool.booleanValue() ? trueValue : falseValue;\n+    }\n+    \n+    // String to Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a Boolean.</p>\n+     * \n+     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n+     * (case insensitive) will return <code>true</code>.\n+     * <code>'false'</code>, <code>'off'</code> or <code>'no'</code>\n+     * (case insensitive) will return <code>false</code>.\n+     * Otherwise, <code>null</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(null)    = null\n+     *   BooleanUtils.toBooleanObject(\"true\")  = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"false\") = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"on\")    = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"ON\")    = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"off\")   = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"oFf\")   = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"blue\")  = null\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @return the Boolean value of the string,\n+     *  <code>null</code> if no match or <code>null</code> input\n+     */\n+    public static Boolean toBooleanObject(String str) {\n+        if (\"true\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"false\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        } else if (\"on\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"off\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        } else if (\"yes\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"no\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        }\n+        // no match\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Converts a String to a Boolean throwing an exception if no match.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(\"true\", \"true\", \"false\", \"null\")  = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"false\", \"true\", \"false\", \"null\") = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"null\", \"true\", \"false\", \"null\")  = null\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @param trueString  the String to match for <code>true</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param falseString  the String to match for <code>false</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param nullString  the String to match for <code>null</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @return the Boolean value of the string,\n+     *  <code>null</code> if no match or <code>null</code> input\n+     */\n+    public static Boolean toBooleanObject(String str, String trueString, String falseString, String nullString) {\n+        if (str == null) {\n+            if (trueString == null) {\n+                return Boolean.TRUE;\n+            } else if (falseString == null) {\n+                return Boolean.FALSE;\n+            } else if (nullString == null) {\n+                return null;\n+            }\n+        } else if (str.equals(trueString)) {\n+            return Boolean.TRUE;\n+        } else if (str.equals(falseString)) {\n+            return Boolean.FALSE;\n+        } else if (str.equals(nullString)) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The String did not match any specified value\");\n+    }\n+\n+    // String to boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a boolean (optimised for performance).</p>\n+     * \n+     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n+     * (case insensitive) will return <code>true</code>. Otherwise,\n+     * <code>false</code> is returned.</p>\n+     * \n+     * <p>This method performs 4 times faster (JDK1.4) than\n+     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n+     * 'on' and 'yes' as true values.\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(null)    = false\n+     *   BooleanUtils.toBoolean(\"true\")  = true\n+     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n+     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n+     *   BooleanUtils.toBoolean(\"on\")    = true\n+     *   BooleanUtils.toBoolean(\"yes\")   = true\n+     *   BooleanUtils.toBoolean(\"false\") = false\n+     *   BooleanUtils.toBoolean(\"x gti\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @return the boolean value of the string, <code>false</code> if no match\n+     */\n+    public static boolean toBoolean(String str) {\n+        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n+        // Non interned 'true' matched 15 times slower.\n+        // \n+        // Optimisation provides same performance as before for interned 'true'.\n+        // Similar performance for null, 'false', and other strings not length 2/3/4.\n+        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n+        if (str == \"true\") {\n+            return true;\n+        }\n+        if (str == null) {\n+            return false;\n+        }\n+        switch (str.length()) {\n+            case 2: {\n+                char ch0 = str.charAt(0);\n+                char ch1 = str.charAt(1);\n+                return \n+                    (ch0 == 'o' || ch0 == 'O') &&\n+                    (ch1 == 'n' || ch1 == 'N');\n+            }\n+            case 3: {\n+                char ch = str.charAt(0);\n+                if (ch == 'y') {\n+                    return \n+                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                }\n+                if (ch == 'Y') {\n+                    return \n+                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n+                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n+                }\n+            }\n+            case 4: {\n+                char ch = str.charAt(0);\n+                if (ch == 't') {\n+                    return \n+                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n+                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n+                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n+                }\n+                if (ch == 'T') {\n+                    return \n+                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n+                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n+                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+    \n+//    public static void main(String[] args) {\n+//        long start = System.currentTimeMillis();\n+//        boolean flag = true;\n+//        int count = 0;\n+//        for (int i = 0; i < 100000000; i++) {\n+//            flag = toBoolean(\"YES\");\n+//        }\n+//        long end = System.currentTimeMillis();\n+//        System.out.println((end - start) + \" \" + flag + \" \" + count);\n+//    }\n+    \n+    /**\n+     * <p>Converts a String to a Boolean throwing an exception if no match found.</p>\n+     * \n+     * <p>null is returned if there is no match.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(\"true\", \"true\", \"false\")  = true\n+     *   BooleanUtils.toBoolean(\"false\", \"true\", \"false\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @param trueString  the String to match for <code>true</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param falseString  the String to match for <code>false</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @return the boolean value of the string\n+     * @throws IllegalArgumentException if the String doesn't match\n+     */\n+    public static boolean toBoolean(String str, String trueString, String falseString) {\n+        if (str == null) {\n+            if (trueString == null) {\n+                return true;\n+            } else if (falseString == null) {\n+                return false;\n+            }\n+        } else if (str.equals(trueString)) {\n+            return true;\n+        } else if (str.equals(falseString)) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The String did not match either specified value\");\n+    }\n+\n+    // Boolean to String methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'true'</code>,\n+     * <code>'false'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringTrueFalse(Boolean.TRUE)  = \"true\"\n+     *   BooleanUtils.toStringTrueFalse(Boolean.FALSE) = \"false\"\n+     *   BooleanUtils.toStringTrueFalse(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'true'</code>, <code>'false'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringTrueFalse(Boolean bool) {\n+        return toString(bool, \"true\", \"false\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'on'</code>,\n+     * <code>'off'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringOnOff(Boolean.TRUE)  = \"on\"\n+     *   BooleanUtils.toStringOnOff(Boolean.FALSE) = \"off\"\n+     *   BooleanUtils.toStringOnOff(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'on'</code>, <code>'off'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringOnOff(Boolean bool) {\n+        return toString(bool, \"on\", \"off\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'yes'</code>,\n+     * <code>'no'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringYesNo(Boolean.TRUE)  = \"yes\"\n+     *   BooleanUtils.toStringYesNo(Boolean.FALSE) = \"no\"\n+     *   BooleanUtils.toStringYesNo(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'yes'</code>, <code>'no'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringYesNo(Boolean bool) {\n+        return toString(bool, \"yes\", \"no\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning one of the input Strings.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toString(Boolean.TRUE, \"true\", \"false\", null)   = \"true\"\n+     *   BooleanUtils.toString(Boolean.FALSE, \"true\", \"false\", null)  = \"false\"\n+     *   BooleanUtils.toString(null, \"true\", \"false\", null)           = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @param trueString  the String to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseString  the String to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullString  the String to return if <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return one of the three input Strings\n+     */\n+    public static String toString(Boolean bool, String trueString, String falseString, String nullString) {\n+        if (bool == null) {\n+            return nullString;\n+        }\n+        return bool.booleanValue() ? trueString : falseString;\n+    }\n+    \n+    // boolean to String methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a boolean to a String returning <code>'true'</code>\n+     * or <code>'false'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringTrueFalse(true)   = \"true\"\n+     *   BooleanUtils.toStringTrueFalse(false)  = \"false\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'true'</code>, <code>'false'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringTrueFalse(boolean bool) {\n+        return toString(bool, \"true\", \"false\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning <code>'on'</code>\n+     * or <code>'off'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringOnOff(true)   = \"on\"\n+     *   BooleanUtils.toStringOnOff(false)  = \"off\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'on'</code>, <code>'off'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringOnOff(boolean bool) {\n+        return toString(bool, \"on\", \"off\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning <code>'yes'</code>\n+     * or <code>'no'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n+     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'yes'</code>, <code>'no'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringYesNo(boolean bool) {\n+        return toString(bool, \"yes\", \"no\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n+     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @param trueString  the String to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseString  the String to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return one of the two input Strings\n+     */\n+    public static String toString(boolean bool, String trueString, String falseString) {\n+        return bool ? trueString : falseString;\n+    }\n+    \n+    // xor methods\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Performs an xor on a set of booleans.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.xor(new boolean[] { true, true })   = false\n+     *   BooleanUtils.xor(new boolean[] { false, false }) = false\n+     *   BooleanUtils.xor(new boolean[] { true, false })  = true\n+     * </pre>\n+     *\n+     * @param array  an array of <code>boolean<code>s\n+     * @return <code>true</code> if the xor is successful.\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty.\n+     */\n+    public static boolean xor(boolean[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array is empty\");\n+        }\n+\n+        // Loops through array, comparing each item\n+        int trueCount = 0;\n+        for (int i = 0; i < array.length; i++) {\n+            // If item is true, and trueCount is < 1, increments count\n+            // Else, xor fails\n+            if (array[i]) {\n+                if (trueCount < 1) {\n+                    trueCount++;\n+                } else {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        // Returns true if there was exactly 1 true item\n+        return trueCount == 1;\n+    }\n+\n+    /**\n+     * <p>Performs an xor on an array of Booleans.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE })   = Boolean.FALSE\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) = Boolean.FALSE\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE })  = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param array  an array of <code>Boolean<code>s\n+     * @return <code>true</code> if the xor is successful.\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty.\n+     * @throws IllegalArgumentException if <code>array</code> contains a <code>null</code>\n+     */\n+    public static Boolean xor(Boolean[] array) {\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array is empty\");\n+        }\n+        boolean[] primitive = null;\n+        try {\n+            primitive = ArrayUtils.toPrimitive(array);\n+        } catch (NullPointerException ex) {\n+            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n+        }\n+        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/CharEncoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+/**\n+ * <p>\n+ * Character encoding names required of every implementation of the Java platform.\n+ * </p>\n+ * \n+ * <p>\n+ * According to <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+ * encoding names</a>:\n+ * <p>\n+ * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n+ * release documentation for your implementation to see if any other encodings are supported.</cite>\n+ * </p>\n+ * </p>\n+ * \n+ * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding\n+ *      names</a>\n+ * @author Apache Software Foundation\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class CharEncoding {\n+\n+    /**\n+     * <p>\n+     * ISO Latin Alphabet #1, also known as ISO-LATIN-1.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String ISO_8859_1 = \"ISO-8859-1\";\n+\n+    /**\n+     * <p>\n+     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String US_ASCII = \"US-ASCII\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either\n+     * order accepted on input, big-endian used on output).\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16 = \"UTF-16\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16BE = \"UTF-16BE\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16LE = \"UTF-16LE\";\n+\n+    /**\n+     * <p>\n+     * Eight-bit Unicode Transformation Format.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_8 = \"UTF-8\";\n+\n+    /**\n+     * <p>\n+     * Returns whether the named charset is supported.\n+     * </p>\n+     * <p>\n+     * This is similar to <a\n+     * href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html#isSupported(java.lang.String)\">\n+     * java.nio.charset.Charset.isSupported(String)</a>\n+     * </p>\n+     * \n+     * @param name\n+     *            the name of the requested charset; may be either a canonical name or an alias\n+     * @return <code>true</code> if, and only if, support for the named charset is available in the current Java\n+     *         virtual machine\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static boolean isSupported(String name) {\n+        if (name == null) {\n+            return false;\n+        }\n+        try {\n+            new String(ArrayUtils.EMPTY_BYTE_ARRAY, name);\n+        } catch (UnsupportedEncodingException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/CharRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>A contiguous range of characters, optionally negated.</p>\n+ * \n+ * <p>Instances are immutable.</p>\n+ *\n+ * @author Henri Yandell\n+ * @author Stephen Colebourne\n+ * @author Chris Feldhacker\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public final class CharRange implements Serializable {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0. \n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 8270183163158333422L;\n+    \n+    /** The first character, inclusive, in the range. */\n+    private final char start;\n+    /** The last character, inclusive, in the range. */\n+    private final char end;\n+    /** True if the range is everything except the characters specified. */\n+    private final boolean negated;\n+    \n+    /** Cached toString. */\n+    private transient String iToString;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a single character.</p>\n+     *\n+     * @param ch  only character in this range\n+     */\n+    public CharRange(char ch) {\n+        this(ch, ch, false);\n+    }\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a single character,\n+     * optionally negating the range.</p>\n+     *\n+     * <p>A negated range includes everything except the specified char.</p>\n+     *\n+     * @param ch  only character in this range\n+     * @param negated  true to express everything except the range\n+     */\n+    public CharRange(char ch, boolean negated) {\n+        this(ch, ch, negated);\n+    }\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a set of characters.</p>\n+     *\n+     * @param start  first character, inclusive, in this range\n+     * @param end  last character, inclusive, in this range\n+     */\n+    public CharRange(char start, char end) {\n+        this(start, end, false);\n+    }\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a set of characters,\n+     * optionally negating the range.</p>\n+     *\n+     * <p>A negated range includes everything except that defined by the\n+     * start and end characters.</p>\n+     * \n+     * <p>If start and end are in the wrong order, they are reversed.\n+     * Thus <code>a-e</code> is the same as <code>e-a</code>.</p>\n+     *\n+     * @param start  first character, inclusive, in this range\n+     * @param end  last character, inclusive, in this range\n+     * @param negated  true to express everything except the range\n+     */\n+    public CharRange(char start, char end, boolean negated) {\n+        super();\n+        if (start > end) {\n+            char temp = start;\n+            start = end;\n+            end = temp;\n+        }\n+        \n+        this.start = start;\n+        this.end = end;\n+        this.negated = negated;\n+    }\n+\n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the start character for this character range.</p>\n+     * \n+     * @return the start char (inclusive)\n+     */\n+    public char getStart() {\n+        return this.start;\n+    }\n+\n+    /**\n+     * <p>Gets the end character for this character range.</p>\n+     * \n+     * @return the end char (inclusive)\n+     */\n+    public char getEnd() {\n+        return this.end;\n+    }\n+\n+    /**\n+     * <p>Is this <code>CharRange</code> negated.</p>\n+     * \n+     * <p>A negated range includes everything except that defined by the\n+     * start and end characters.</p>\n+     *\n+     * @return <code>true</code> is negated\n+     */\n+    public boolean isNegated() {\n+        return negated;\n+    }\n+\n+    // Contains\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Is the character specified contained in this range.</p>\n+     *\n+     * @param ch  the character to check\n+     * @return <code>true</code> if this range contains the input character\n+     */\n+    public boolean contains(char ch) {\n+        return (ch >= start && ch <= end) != negated;\n+    }\n+\n+    /**\n+     * <p>Are all the characters of the passed in range contained in\n+     * this range.</p>\n+     *\n+     * @param range  the range to check against\n+     * @return <code>true</code> if this range entirely contains the input range\n+     * @throws IllegalArgumentException if <code>null</code> input\n+     */\n+    public boolean contains(CharRange range) {\n+        if (range == null) {\n+            throw new IllegalArgumentException(\"The Range must not be null\");\n+        }\n+        if (negated) {\n+            if (range.negated) {\n+                return start >= range.start && end <= range.end;\n+            } else {\n+                return range.end < start || range.start > end;\n+            }\n+        } else {\n+            if (range.negated) {\n+                return start == 0 && end == Character.MAX_VALUE;\n+            } else {\n+                return start <= range.start && end >= range.end;\n+            }\n+        }\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two CharRange objects, returning true if they represent\n+     * exactly the same range of characters defined in the same way.</p>\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof CharRange == false) {\n+            return false;\n+        }\n+        CharRange other = (CharRange) obj;\n+        return start == other.start && end == other.end && negated == other.negated;\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode compatible with the equals method.</p>\n+     * \n+     * @return a suitable hashCode\n+     */\n+    public int hashCode() {\n+        return 83 + start + 7 * end + (negated ? 1 : 0);\n+    }\n+    \n+    /**\n+     * <p>Gets a string representation of the character range.</p>\n+     * \n+     * @return string representation of this range\n+     */\n+    public String toString() {\n+        if (iToString == null) {\n+            StringBuffer buf = new StringBuffer(4);\n+            if (isNegated()) {\n+                buf.append('^');\n+            }\n+            buf.append(start);\n+            if (start != end) {\n+                buf.append('-');\n+                buf.append(end);\n+            }\n+            iToString = buf.toString();\n+        }\n+        return iToString;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/CharSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>A set of characters.</p>\n+ *\n+ * <p>Instances are immutable, but instances of subclasses may not be.</p>\n+ *\n+ * @author Henri Yandell\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CharSet implements Serializable {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0. \n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 5947847346149275958L;\n+\n+    /** \n+     * A CharSet defining no characters. \n+     * @since 2.0\n+     */\n+    public static final CharSet EMPTY = new CharSet((String) null);\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"a-zA-Z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA = new CharSet(\"a-zA-Z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"a-z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA_LOWER = new CharSet(\"a-z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"A-Z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA_UPPER = new CharSet(\"A-Z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"0-9\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_NUMERIC = new CharSet(\"0-9\");\n+\n+    /**\n+     * A Map of the common cases used in the factory.\n+     * Subclasses can add more common patterns if desired.\n+     * @since 2.0\n+     */\n+    protected static final Map COMMON = new HashMap();\n+    \n+    static {\n+        COMMON.put(null, EMPTY);\n+        COMMON.put(\"\", EMPTY);\n+        COMMON.put(\"a-zA-Z\", ASCII_ALPHA);\n+        COMMON.put(\"A-Za-z\", ASCII_ALPHA);\n+        COMMON.put(\"a-z\", ASCII_ALPHA_LOWER);\n+        COMMON.put(\"A-Z\", ASCII_ALPHA_UPPER);\n+        COMMON.put(\"0-9\", ASCII_NUMERIC);\n+    }\n+\n+    /** The set of CharRange objects. */\n+    private Set set = new HashSet();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Factory method to create a new CharSet using a special syntax.</p>\n+     *\n+     * <ul>\n+     *  <li><code>null</code> or empty string (\"\")\n+     * - set containing no characters</li>\n+     *  <li>Single character, such as \"a\"\n+     *  - set containing just that character</li>\n+     *  <li>Multi character, such as \"a-e\"\n+     *  - set containing characters from one character to the other</li>\n+     *  <li>Negated, such as \"^a\" or \"^a-e\"\n+     *  - set containing all characters except those defined</li>\n+     *  <li>Combinations, such as \"abe-g\"\n+     *  - set containing all the characters from the individual sets</li>\n+     * </ul>\n+     *\n+     * <p>The matching order is:</p>\n+     * <ol>\n+     *  <li>Negated multi character range, such as \"^a-e\"\n+     *  <li>Ordinary multi character range, such as \"a-e\"\n+     *  <li>Negated single character, such as \"^a\"\n+     *  <li>Ordinary single character, such as \"a\"\n+     * </ol>\n+     * <p>Matching works left to right. Once a match is found the\n+     * search starts again from the next character.</p>\n+     *\n+     * <p>If the same range is defined twice using the same syntax, only\n+     * one range will be kept.\n+     * Thus, \"a-ca-c\" creates only one range of \"a-c\".</p>\n+     *\n+     * <p>If the start and end of a range are in the wrong order,\n+     * they are reversed. Thus \"a-e\" is the same as \"e-a\".\n+     * As a result, \"a-ee-a\" would create only one range,\n+     * as the \"a-e\" and \"e-a\" are the same.</p>\n+     *\n+     * <p>The set of characters represented is the union of the specified ranges.</p>\n+     *\n+     * <p>All CharSet objects returned by this method will be immutable.</p>\n+     *\n+     * @param setStr  the String describing the set, may be null\n+     * @return a CharSet instance\n+     * @since 2.0\n+     */\n+    public static CharSet getInstance(String setStr) {\n+        Object set = COMMON.get(setStr);\n+        if (set != null) {\n+            return (CharSet) set;\n+        }\n+        return new CharSet(setStr);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Constructs a new CharSet using the set syntax.</p>\n+     *\n+     * @param setStr  the String describing the set, may be null\n+     * @since 2.0\n+     */\n+    protected CharSet(String setStr) {\n+        super();\n+        add(setStr);\n+    }\n+\n+    /**\n+     * <p>Constructs a new CharSet using the set syntax.\n+     * Each string is merged in with the set.</p>\n+     *\n+     * @param set  Strings to merge into the initial set\n+     * @throws NullPointerException if set is <code>null</code>\n+     */\n+    protected CharSet(String[] set) {\n+        super();\n+        int sz = set.length;\n+        for (int i = 0; i < sz; i++) {\n+            add(set[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Add a set definition string to the <code>CharSet</code>.</p>\n+     *\n+     * @param str  set definition string\n+     */\n+    protected void add(String str) {\n+        if (str == null) {\n+            return;\n+        }\n+\n+        int len = str.length();\n+        int pos = 0;\n+        while (pos < len) {\n+            int remainder = (len - pos);\n+            if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') {\n+                // negated range\n+                set.add(new CharRange(str.charAt(pos + 1), str.charAt(pos + 3), true));\n+                pos += 4;\n+            } else if (remainder >= 3 && str.charAt(pos + 1) == '-') {\n+                // range\n+                set.add(new CharRange(str.charAt(pos), str.charAt(pos + 2)));\n+                pos += 3;\n+            } else if (remainder >= 2 && str.charAt(pos) == '^') {\n+                // negated char\n+                set.add(new CharRange(str.charAt(pos + 1), true));\n+                pos += 2;\n+            } else {\n+                // char\n+                set.add(new CharRange(str.charAt(pos)));\n+                pos += 1;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the internal set as an array of CharRange objects.</p>\n+     *\n+     * @return an array of immutable CharRange objects\n+     * @since 2.0\n+     */\n+    public CharRange[] getCharRanges() {\n+        return (CharRange[]) set.toArray(new CharRange[set.size()]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Does the <code>CharSet</code> contain the specified\n+     * character <code>ch</code>.</p>\n+     *\n+     * @param ch  the character to check for\n+     * @return <code>true</code> if the set contains the characters\n+     */\n+    public boolean contains(char ch) {\n+        for (Iterator it = set.iterator(); it.hasNext();) {\n+            CharRange range = (CharRange) it.next();\n+            if (range.contains(ch)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two CharSet objects, returning true if they represent\n+     * exactly the same set of characters defined in the same way.</p>\n+     *\n+     * <p>The two sets <code>abc</code> and <code>a-c</code> are <i>not</i>\n+     * equal according to this method.</p>\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 2.0\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof CharSet == false) {\n+            return false;\n+        }\n+        CharSet other = (CharSet) obj;\n+        return set.equals(other.set);\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode compatible with the equals method.</p>\n+     *\n+     * @return a suitable hashCode\n+     * @since 2.0\n+     */\n+    public int hashCode() {\n+        return 89 + set.hashCode();\n+    }\n+\n+    /**\n+     * <p>Gets a string representation of the set.</p>\n+     *\n+     * @return string representation of the set\n+     */\n+    public String toString() {\n+        return set.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/CharSetUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Operations on <code>CharSet</code>s.</p>\n+ *\n+ * <p>This class handles <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @see CharSet\n+ * @author <a href=\"bayard@generationjava.com\">Henri Yandell</a>\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CharSetUtils {\n+\n+    /**\n+     * <p>CharSetUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>CharSetUtils.evaluateSet(null);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public CharSetUtils() {\n+      super();\n+    }\n+\n+    // Factory\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Creates a <code>CharSet</code> instance which allows a certain amount of\n+     * set logic to be performed.</p>\n+     * <p>The syntax is:</p>\n+     * <ul>\n+     *  <li>&quot;aeio&quot; which implies 'a','e',..</li>\n+     *  <li>&quot;^e&quot; implies not e.</li>\n+     *  <li>&quot;ej-m&quot; implies e,j-&gt;m. e,j,k,l,m.</li>\n+     * </ul>\n+     * \n+     * <pre>\n+     * CharSetUtils.evaluateSet(null)    = null\n+     * CharSetUtils.evaluateSet([])      = CharSet matching nothing\n+     * CharSetUtils.evaluateSet([\"a-e\"]) = CharSet matching a,b,c,d,e\n+     * </pre>\n+     *\n+     * @param set  the set, may be null\n+     * @return a CharSet instance, <code>null</code> if null input\n+     * @deprecated Use {@link CharSet#getInstance(String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static CharSet evaluateSet(String[] set) {\n+        if (set == null) {\n+            return null;\n+        }\n+        return new CharSet(set); \n+    }\n+\n+    // Squeeze\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Squeezes any repetitions of a character that is mentioned in the\n+     * supplied set.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.squeeze(null, *)        = null\n+     * CharSetUtils.squeeze(\"\", *)          = \"\"\n+     * CharSetUtils.squeeze(*, null)        = *\n+     * CharSetUtils.squeeze(*, \"\")          = *\n+     * CharSetUtils.squeeze(\"hello\", \"k-p\") = \"helo\"\n+     * CharSetUtils.squeeze(\"hello\", \"a-e\") = \"hello\"\n+     * </pre>\n+     *\n+     * @see #evaluateSet(java.lang.String[]) for set-syntax.\n+     * @param str  the string to squeeze, may be null\n+     * @param set  the character set to use for manipulation, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String squeeze(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return squeeze(str, strs);\n+    }\n+\n+    /**\n+     * <p>Squeezes any repetitions of a character that is mentioned in the\n+     * supplied set.</p>\n+     *\n+     * <p>An example is:</p>\n+     * <ul>\n+     *   <li>squeeze(&quot;hello&quot;, {&quot;el&quot;}) => &quot;helo&quot;</li>\n+     * </ul>\n+     * \n+     * @see #evaluateSet(java.lang.String[]) for set-syntax.\n+     * @param str  the string to squeeze, may be null\n+     * @param set  the character set to use for manipulation, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String squeeze(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        CharSet chars = evaluateSet(set);\n+        StringBuffer buffer = new StringBuffer(str.length());\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        char lastChar = ' ';\n+        char ch = ' ';\n+        for (int i = 0; i < sz; i++) {\n+            ch = chrs[i];\n+            if (chars.contains(ch)) {\n+                if ((ch == lastChar) && (i != 0)) {\n+                    continue;\n+                }\n+            }\n+            buffer.append(ch);\n+            lastChar = ch;\n+        }\n+        return buffer.toString();\n+    }\n+\n+    // Count\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and returns the number of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.count(null, *)        = 0\n+     * CharSetUtils.count(\"\", *)          = 0\n+     * CharSetUtils.count(*, null)        = 0\n+     * CharSetUtils.count(*, \"\")          = 0\n+     * CharSetUtils.count(\"hello\", \"k-p\") = 3\n+     * CharSetUtils.count(\"hello\", \"a-e\") = 1\n+     * </pre>\n+     *\n+     * @see #evaluateSet(java.lang.String[]) for set-syntax.\n+     * @param str  String to count characters in, may be null\n+     * @param set  String set of characters to count, may be null\n+     * @return character count, zero if null string input\n+     */\n+    public static int count(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return 0;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return count(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and returns the number of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>count(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;}) returns 2.</li>\n+     * </ul>\n+     *\n+     * @see #evaluateSet(java.lang.String[]) for set-syntax.\n+     * @param str  String to count characters in, may be null\n+     * @param set  String[] set of characters to count, may be null\n+     * @return character count, zero if null string input\n+     */\n+    public static int count(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return 0;\n+        }\n+        CharSet chars = evaluateSet(set);\n+        int count = 0;\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        for(int i=0; i<sz; i++) {\n+            if(chars.contains(chrs[i])) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    // Keep\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and keeps any of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.keep(null, *)        = null\n+     * CharSetUtils.keep(\"\", *)          = \"\"\n+     * CharSetUtils.keep(*, null)        = \"\"\n+     * CharSetUtils.keep(*, \"\")          = \"\"\n+     * CharSetUtils.keep(\"hello\", \"hl\")  = \"hll\"\n+     * CharSetUtils.keep(\"hello\", \"le\")  = \"ell\"\n+     * </pre>\n+     *\n+     * @see #evaluateSet(java.lang.String[]) for set-syntax.\n+     * @param str  String to keep characters from, may be null\n+     * @param set  String set of characters to keep, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String keep(String str, String set) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0 || StringUtils.isEmpty(set)) {\n+            return \"\";\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return keep(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and keeps any of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>keep(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;})\n+     *   returns &quot;eo&quot;</li>\n+     * </ul>\n+     *\n+     * @see #evaluateSet(java.lang.String[]) for set-syntax.\n+     * @param str  String to keep characters from, may be null\n+     * @param set  String[] set of characters to keep, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String keep(String str, String[] set) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0 || ArrayUtils.isEmpty(set)) {\n+            return \"\";\n+        }\n+        return modify(str, set, true);\n+    }\n+\n+    // Delete\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and deletes any of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.delete(null, *)        = null\n+     * CharSetUtils.delete(\"\", *)          = \"\"\n+     * CharSetUtils.delete(*, null)        = *\n+     * CharSetUtils.delete(*, \"\")          = *\n+     * CharSetUtils.delete(\"hello\", \"hl\")  = \"eo\"\n+     * CharSetUtils.delete(\"hello\", \"le\")  = \"ho\"\n+     * </pre>\n+     *\n+     * @see #evaluateSet(java.lang.String[]) for set-syntax.\n+     * @param str  String to delete characters from, may be null\n+     * @param set  String set of characters to delete, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String delete(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return delete(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and deletes any of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>delete(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;}) returns\n+     *   &quot;hll&quot;</li>\n+     * </ul>\n+     *\n+     * @see #evaluateSet(java.lang.String[]) for set-syntax.\n+     * @param str  String to delete characters from, may be null\n+     * @param set  String[] set of characters to delete, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String delete(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        return modify(str, set, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of delete and keep\n+     *\n+     * @param str String to modify characters within\n+     * @param set String[] set of characters to modify\n+     * @param expect whether to evaluate on match, or non-match\n+     * @return modified String\n+     */\n+    private static String modify(String str, String[] set, boolean expect) {\n+        CharSet chars = evaluateSet(set);\n+        StringBuffer buffer = new StringBuffer(str.length());\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        for(int i=0; i<sz; i++) {\n+            if(chars.contains(chrs[i]) == expect) {\n+                buffer.append(chrs[i]);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    // Translate\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Translate characters in a String.\n+     * This is a multi character search and replace routine.</p>\n+     *\n+     * <p>An example is:</p>\n+     * <ul>\n+     *   <li>translate(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;)\n+     *    =&gt; jelly</li>\n+     * </ul>\n+     *\n+     * <p>If the length of characters to search for is greater than the\n+     * length of characters to replace, then the last character is \n+     * used.</p>\n+     * \n+     * <pre>\n+     * CharSetUtils.translate(null, *, *) = null\n+     * CharSetUtils.translate(\"\", *, *)   = \"\"\n+     * </pre>\n+     *\n+     * @param str  String to replace characters in, may be null\n+     * @param searchChars   a set of characters to search for, must not be null\n+     * @param replaceChars  a set of characters to replace, must not be null or empty (&quot;&quot;)\n+     * @return translated String, <code>null</code> if null string input\n+     * @throws NullPointerException if <code>searchChars</code> or <code>replaceChars</code> \n+     *  is <code>null</code>\n+     * @throws ArrayIndexOutOfBoundsException if <code>replaceChars</code> is empty (&quot;&quot;)\n+     * @deprecated Use {@link StringUtils#replaceChars(String, String, String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     *  NOTE: StringUtils#replaceChars behaves differently when 'searchChars' is longer\n+     *  than 'replaceChars'. CharSetUtils#translate will use the last char of the replacement\n+     *  string whereas StringUtils#replaceChars will delete\n+     */\n+    public static String translate(String str, String searchChars, String replaceChars) {\n+        if (StringUtils.isEmpty(str)) {\n+            return str;\n+        }\n+        StringBuffer buffer = new StringBuffer(str.length());\n+        char[] chrs = str.toCharArray();\n+        char[] withChrs = replaceChars.toCharArray();\n+        int sz = chrs.length;\n+        int withMax = replaceChars.length() - 1;\n+        for(int i=0; i<sz; i++) {\n+            int idx = searchChars.indexOf(chrs[i]);\n+            if(idx != -1) {\n+                if(idx > withMax) {\n+                    idx = withMax;\n+                }\n+                buffer.append(withChrs[idx]);\n+            } else {\n+                buffer.append(chrs[i]);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/CharUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Operations on char primitives and Character objects.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Stephen Colebourne\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class CharUtils {\n+    \n+    private static final String CHAR_STRING = \n+        \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\" +\n+        \"\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\" +\n+        \"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\" +\n+        \"\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\" +\n+        \"\\u0020\\u0021\\\"\\u0023\\u0024\\u0025\\u0026\\u0027\" +\n+        \"\\u0028\\u0029\\u002a\\u002b\\u002c\\u002d\\u002e\\u002f\" +\n+        \"\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\" +\n+        \"\\u0038\\u0039\\u003a\\u003b\\u003c\\u003d\\u003e\\u003f\" +\n+        \"\\u0040\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\" +\n+        \"\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\" +\n+        \"\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\" +\n+        \"\\u0058\\u0059\\u005a\\u005b\\\\\\u005d\\u005e\\u005f\" +\n+        \"\\u0060\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\" +\n+        \"\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\" +\n+        \"\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\" +\n+        \"\\u0078\\u0079\\u007a\\u007b\\u007c\\u007d\\u007e\\u007f\";\n+    \n+    private static final String[] CHAR_STRING_ARRAY = new String[128];\n+    private static final Character[] CHAR_ARRAY = new Character[128];\n+    \n+    /**\n+     * <code>\\u000a</code> linefeed LF ('\\n').\n+     * \n+     * @see <a href=\"http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089\">JLF: Escape Sequences\n+     *      for Character and String Literals</a>\n+     * @since 2.2\n+     */\n+    public static final char LF = '\\n';\n+\n+    /**\n+     * <code>\\u000d</code> carriage return CR ('\\r').\n+     * \n+     * @see <a href=\"http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089\">JLF: Escape Sequences\n+     *      for Character and String Literals</a>\n+     * @since 2.2\n+     */\n+    public static final char CR = '\\r';\n+    \n+\n+    static {\n+        for (int i = 127; i >= 0; i--) {\n+            CHAR_STRING_ARRAY[i] = CHAR_STRING.substring(i, i + 1);\n+            CHAR_ARRAY[i] = new Character((char) i);\n+        }\n+    }\n+\n+    /**\n+     * <p><code>CharUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>CharUtils.toString('c');</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public CharUtils() {\n+      super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to a Character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same Character object each time.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toCharacterObject(' ')  = ' '\n+     *   CharUtils.toCharacterObject('A')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a Character of the specified character\n+     */\n+    public static Character toCharacterObject(char ch) {\n+        if (ch < CHAR_ARRAY.length) {\n+            return CHAR_ARRAY[ch];\n+        }\n+        return new Character(ch);\n+    }\n+    \n+    /**\n+     * <p>Converts the String to a Character using the first character, returning\n+     * null for empty Strings.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same Character object each time.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toCharacterObject(null) = null\n+     *   CharUtils.toCharacterObject(\"\")   = null\n+     *   CharUtils.toCharacterObject(\"A\")  = 'A'\n+     *   CharUtils.toCharacterObject(\"BA\") = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @return the Character value of the first letter of the String\n+     */\n+    public static Character toCharacterObject(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return null;\n+        }\n+        return toCharacterObject(str.charAt(0));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the Character to a char throwing an exception for <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null) = IllegalArgumentException\n+     *   CharUtils.toChar(' ')  = ' '\n+     *   CharUtils.toChar('A')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return the char value of the Character\n+     * @throws IllegalArgumentException if the Character is null\n+     */\n+    public static char toChar(Character ch) {\n+        if (ch == null) {\n+            throw new IllegalArgumentException(\"The Character must not be null\");\n+        }\n+        return ch.charValue();\n+    }\n+    \n+    /**\n+     * <p>Converts the Character to a char handling <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null, 'X') = 'X'\n+     *   CharUtils.toChar(' ', 'X')  = ' '\n+     *   CharUtils.toChar('A', 'X')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the value to use if the  Character is null\n+     * @return the char value of the Character or the default if null\n+     */\n+    public static char toChar(Character ch, char defaultValue) {\n+        if (ch == null) {\n+            return defaultValue;\n+        }\n+        return ch.charValue();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the String to a char using the first character, throwing\n+     * an exception on empty Strings.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null) = IllegalArgumentException\n+     *   CharUtils.toChar(\"\")   = IllegalArgumentException\n+     *   CharUtils.toChar(\"A\")  = 'A'\n+     *   CharUtils.toChar(\"BA\") = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @return the char value of the first letter of the String\n+     * @throws IllegalArgumentException if the String is empty\n+     */\n+    public static char toChar(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            throw new IllegalArgumentException(\"The String must not be empty\");\n+        }\n+        return str.charAt(0);\n+    }\n+    \n+    /**\n+     * <p>Converts the String to a char using the first character, defaulting\n+     * the value on empty Strings.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null, 'X') = 'X'\n+     *   CharUtils.toChar(\"\", 'X')   = 'X'\n+     *   CharUtils.toChar(\"A\", 'X')  = 'A'\n+     *   CharUtils.toChar(\"BA\", 'X') = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @param defaultValue  the value to use if the  Character is null\n+     * @return the char value of the first letter of the String or the default if null\n+     */\n+    public static char toChar(String str, char defaultValue) {\n+        if (StringUtils.isEmpty(str)) {\n+            return defaultValue;\n+        }\n+        return str.charAt(0);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue('3')  = 3\n+     *   CharUtils.toIntValue('A')  = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return the int value of the character\n+     * @throws IllegalArgumentException if the character is not ASCII numeric\n+     */\n+    public static int toIntValue(char ch) {\n+        if (isAsciiNumeric(ch) == false) {\n+            throw new IllegalArgumentException(\"The character \" + ch + \" is not in the range '0' - '9'\");\n+        }\n+        return ch - 48;\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue('3', -1)  = 3\n+     *   CharUtils.toIntValue('A', -1)  = -1\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the default value to use if the character is not numeric\n+     * @return the int value of the character\n+     */\n+    public static int toIntValue(char ch, int defaultValue) {\n+        if (isAsciiNumeric(ch) == false) {\n+            return defaultValue;\n+        }\n+        return ch - 48;\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue(null) = IllegalArgumentException\n+     *   CharUtils.toIntValue('3')  = 3\n+     *   CharUtils.toIntValue('A')  = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param ch  the character to convert, not null\n+     * @return the int value of the character\n+     * @throws IllegalArgumentException if the Character is not ASCII numeric or is null\n+     */\n+    public static int toIntValue(Character ch) {\n+        if (ch == null) {\n+            throw new IllegalArgumentException(\"The character must not be null\");\n+        }\n+        return toIntValue(ch.charValue());\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue(null, -1) = -1\n+     *   CharUtils.toIntValue('3', -1)  = 3\n+     *   CharUtils.toIntValue('A', -1)  = -1\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the default value to use if the character is not numeric\n+     * @return the int value of the character\n+     */\n+    public static int toIntValue(Character ch, int defaultValue) {\n+        if (ch == null) {\n+            return defaultValue;\n+        }\n+        return toIntValue(ch.charValue(), defaultValue);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to a String that contains the one character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same String object each time.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toString(' ')  = \" \"\n+     *   CharUtils.toString('A')  = \"A\"\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a String containing the one specified character\n+     */\n+    public static String toString(char ch) {\n+        if (ch < 128) {\n+            return CHAR_STRING_ARRAY[ch];\n+        }\n+        return new String(new char[] {ch});\n+    }\n+    \n+    /**\n+     * <p>Converts the character to a String that contains the one character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same String object each time.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toString(null) = null\n+     *   CharUtils.toString(' ')  = \" \"\n+     *   CharUtils.toString('A')  = \"A\"\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a String containing the one specified character\n+     */\n+    public static String toString(Character ch) {\n+        if (ch == null) {\n+            return null;\n+        }\n+        return toString(ch.charValue());\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Converts the string to the unicode format '\\u0020'.</p>\n+     * \n+     * <p>This format is the Java source code format.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.unicodeEscaped(' ') = \"\\u0020\"\n+     *   CharUtils.unicodeEscaped('A') = \"\\u0041\"\n+     * </pre>\n+     * \n+     * @param ch  the character to convert\n+     * @return the escaped unicode string\n+     */\n+    public static String unicodeEscaped(char ch) {\n+        if (ch < 0x10) {\n+            return \"\\\\u000\" + Integer.toHexString(ch);\n+        } else if (ch < 0x100) {\n+            return \"\\\\u00\" + Integer.toHexString(ch);\n+        } else if (ch < 0x1000) {\n+            return \"\\\\u0\" + Integer.toHexString(ch);\n+        }\n+        return \"\\\\u\" + Integer.toHexString(ch);\n+    }\n+    \n+    /**\n+     * <p>Converts the string to the unicode format '\\u0020'.</p>\n+     * \n+     * <p>This format is the Java source code format.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.unicodeEscaped(null) = null\n+     *   CharUtils.unicodeEscaped(' ')  = \"\\u0020\"\n+     *   CharUtils.unicodeEscaped('A')  = \"\\u0041\"\n+     * </pre>\n+     * \n+     * @param ch  the character to convert, may be null\n+     * @return the escaped unicode string, null if null input\n+     */\n+    public static String unicodeEscaped(Character ch) {\n+        if (ch == null) {\n+            return null;\n+        }\n+        return unicodeEscaped(ch.charValue());\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAscii('a')  = true\n+     *   CharUtils.isAscii('A')  = true\n+     *   CharUtils.isAscii('3')  = true\n+     *   CharUtils.isAscii('-')  = true\n+     *   CharUtils.isAscii('\\n') = true\n+     *   CharUtils.isAscii('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if less than 128\n+     */\n+    public static boolean isAscii(char ch) {\n+        return ch < 128;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit printable.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiPrintable('a')  = true\n+     *   CharUtils.isAsciiPrintable('A')  = true\n+     *   CharUtils.isAsciiPrintable('3')  = true\n+     *   CharUtils.isAsciiPrintable('-')  = true\n+     *   CharUtils.isAsciiPrintable('\\n') = false\n+     *   CharUtils.isAsciiPrintable('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 32 and 126 inclusive\n+     */\n+    public static boolean isAsciiPrintable(char ch) {\n+        return ch >= 32 && ch < 127;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit control.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiControl('a')  = false\n+     *   CharUtils.isAsciiControl('A')  = false\n+     *   CharUtils.isAsciiControl('3')  = false\n+     *   CharUtils.isAsciiControl('-')  = false\n+     *   CharUtils.isAsciiControl('\\n') = true\n+     *   CharUtils.isAsciiControl('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if less than 32 or equals 127\n+     */\n+    public static boolean isAsciiControl(char ch) {\n+        return ch < 32 || ch == 127;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlpha('a')  = true\n+     *   CharUtils.isAsciiAlpha('A')  = true\n+     *   CharUtils.isAsciiAlpha('3')  = false\n+     *   CharUtils.isAsciiAlpha('-')  = false\n+     *   CharUtils.isAsciiAlpha('\\n') = false\n+     *   CharUtils.isAsciiAlpha('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 65 and 90 or 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlpha(char ch) {\n+        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphaUpper('a')  = false\n+     *   CharUtils.isAsciiAlphaUpper('A')  = true\n+     *   CharUtils.isAsciiAlphaUpper('3')  = false\n+     *   CharUtils.isAsciiAlphaUpper('-')  = false\n+     *   CharUtils.isAsciiAlphaUpper('\\n') = false\n+     *   CharUtils.isAsciiAlphaUpper('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 65 and 90 inclusive\n+     */\n+    public static boolean isAsciiAlphaUpper(char ch) {\n+        return ch >= 'A' && ch <= 'Z';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic lower case.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphaLower('a')  = true\n+     *   CharUtils.isAsciiAlphaLower('A')  = false\n+     *   CharUtils.isAsciiAlphaLower('3')  = false\n+     *   CharUtils.isAsciiAlphaLower('-')  = false\n+     *   CharUtils.isAsciiAlphaLower('\\n') = false\n+     *   CharUtils.isAsciiAlphaLower('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlphaLower(char ch) {\n+        return ch >= 'a' && ch <= 'z';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit numeric.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiNumeric('a')  = false\n+     *   CharUtils.isAsciiNumeric('A')  = false\n+     *   CharUtils.isAsciiNumeric('3')  = true\n+     *   CharUtils.isAsciiNumeric('-')  = false\n+     *   CharUtils.isAsciiNumeric('\\n') = false\n+     *   CharUtils.isAsciiNumeric('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 48 and 57 inclusive\n+     */\n+    public static boolean isAsciiNumeric(char ch) {\n+        return ch >= '0' && ch <= '9';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit numeric.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphanumeric('a')  = true\n+     *   CharUtils.isAsciiAlphanumeric('A')  = true\n+     *   CharUtils.isAsciiAlphanumeric('3')  = true\n+     *   CharUtils.isAsciiAlphanumeric('-')  = false\n+     *   CharUtils.isAsciiAlphanumeric('\\n') = false\n+     *   CharUtils.isAsciiAlphanumeric('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 48 and 57 or 65 and 90 or 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlphanumeric(char ch) {\n+        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/ClassUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <p>Operates on classes without using reflection.</p>\n+ *\n+ * <p>This class handles invalid <code>null</code> inputs as best it can.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Norm Deane\n+ * @author Alban Peignier\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ClassUtils {\n+\n+    /**\n+     * <p>The package separator character: <code>'&#x2e;' == {@value}</code>.</p>\n+     */\n+    public static final char PACKAGE_SEPARATOR_CHAR = '.';\n+\n+    /**\n+     * <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n+     */\n+    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n+\n+    /**\n+     * <p>The inner class separator character: <code>'$' == {@value}</code>.</p>\n+     */\n+    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n+\n+    /**\n+     * <p>The inner class separator String: <code>\"$\"</code>.</p>\n+     */\n+    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);\n+\n+    /**\n+     * Maps primitive <code>Class</code>es to their corresponding wrapper <code>Class</code>.\n+     */\n+    private static Map  primitiveWrapperMap = new HashMap();\n+    static {\n+         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n+         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n+         primitiveWrapperMap.put(Character.TYPE, Character.class);\n+         primitiveWrapperMap.put(Short.TYPE, Short.class);\n+         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n+         primitiveWrapperMap.put(Long.TYPE, Long.class);\n+         primitiveWrapperMap.put(Double.TYPE, Double.class);\n+         primitiveWrapperMap.put(Float.TYPE, Float.class);\n+         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n+    }\n+\n+    /**\n+     * Maps a primitive class name to its corresponding abbreviation used in array class names.\n+     */\n+    private static Map abbreviationMap = new HashMap();\n+    static {\n+        abbreviationMap.put( \"int\", \"I\" );\n+        abbreviationMap.put( \"boolean\", \"Z\" );\n+        abbreviationMap.put( \"float\", \"F\" );\n+        abbreviationMap.put( \"long\", \"J\" );\n+        abbreviationMap.put( \"short\", \"S\" );\n+        abbreviationMap.put( \"byte\", \"B\" );\n+        abbreviationMap.put( \"double\", \"D\" );\n+        abbreviationMap.put( \"char\", \"C\" );\n+    }\n+\n+    /**\n+     * <p>ClassUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>ClassUtils.getShortClassName(cls)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public ClassUtils() {\n+      super();\n+    }\n+\n+    // Short class name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the class name minus the package name for an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the short name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the class name of the object without the package name, or the null value\n+     */\n+    public static String getShortClassName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getShortClassName(object.getClass().getName());\n+    }\n+\n+    /**\n+     * <p>Gets the class name minus the package name from a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the short name for.\n+     * @return the class name without the package name or an empty string\n+     */\n+    public static String getShortClassName(Class cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getShortClassName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the class name minus the package name from a String.</p>\n+     *\n+     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n+     *\n+     * @param className  the className to get the short name for\n+     * @return the class name of the class without the package name or an empty string\n+     */\n+    public static String getShortClassName(String className) {\n+        if (className == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        if (className.length() == 0) {\n+            return StringUtils.EMPTY;\n+        }\n+        char[] chars = className.toCharArray();\n+        int lastDot = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            if (chars[i] == PACKAGE_SEPARATOR_CHAR) {\n+                lastDot = i + 1;\n+            } else if (chars[i] == INNER_CLASS_SEPARATOR_CHAR) {  // handle inner classes\n+                chars[i] = PACKAGE_SEPARATOR_CHAR;\n+            }\n+        }\n+        return new String(chars, lastDot, chars.length - lastDot);\n+    }\n+\n+    // Package name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the package name of an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the package name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the package name of the object, or the null value\n+     */\n+    public static String getPackageName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getPackageName(object.getClass().getName());\n+    }\n+\n+    /**\n+     * <p>Gets the package name of a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the package name for, may be <code>null</code>.\n+     * @return the package name or an empty string\n+     */\n+    public static String getPackageName(Class cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getPackageName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the package name from a <code>String</code>.</p>\n+     *\n+     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n+     * <p>If the class is unpackaged, return an empty string.</p>\n+     *\n+     * @param className  the className to get the package name for, may be <code>null</code>\n+     * @return the package name or an empty string\n+     */\n+    public static String getPackageName(String className) {\n+        if (className == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+        if (i == -1) {\n+            return StringUtils.EMPTY;\n+        }\n+        return className.substring(0, i);\n+    }\n+\n+    // Superclasses/Superinterfaces\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a <code>List</code> of superclasses for the given class.</p>\n+     *\n+     * @param cls  the class to look up, may be <code>null</code>\n+     * @return the <code>List</code> of superclasses in order going up from this one\n+     *  <code>null</code> if null input\n+     */\n+    public static List getAllSuperclasses(Class cls) {\n+        if (cls == null) {\n+            return null;\n+        }\n+        List classes = new ArrayList();\n+        Class superclass = cls.getSuperclass();\n+        while (superclass != null) {\n+            classes.add(superclass);\n+            superclass = superclass.getSuperclass();\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * <p>Gets a <code>List</code> of all interfaces implemented by the given\n+     * class and its superclasses.</p>\n+     *\n+     * <p>The order is determined by looking through each interface in turn as\n+     * declared in the source file and following its hierarchy up. Then each\n+     * superclass is considered in the same way. Later duplicates are ignored,\n+     * so the order is maintained.</p>\n+     *\n+     * @param cls  the class to look up, may be <code>null</code>\n+     * @return the <code>List</code> of interfaces in order,\n+     *  <code>null</code> if null input\n+     */\n+    public static List getAllInterfaces(Class cls) {\n+        if (cls == null) {\n+            return null;\n+        }\n+        List list = new ArrayList();\n+        while (cls != null) {\n+            Class[] interfaces = cls.getInterfaces();\n+            for (int i = 0; i < interfaces.length; i++) {\n+                if (list.contains(interfaces[i]) == false) {\n+                    list.add(interfaces[i]);\n+                }\n+                List superInterfaces = getAllInterfaces(interfaces[i]);\n+                for (Iterator it = superInterfaces.iterator(); it.hasNext();) {\n+                    Class intface = (Class) it.next();\n+                    if (list.contains(intface) == false) {\n+                        list.add(intface);\n+                    }\n+                }\n+            }\n+            cls = cls.getSuperclass();\n+        }\n+        return list;\n+    }\n+\n+    // Convert list\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Given a <code>List</code> of class names, this method converts them into classes.</p>\n+     *\n+     * <p>A new <code>List</code> is returned. If the class name cannot be found, <code>null</code>\n+     * is stored in the <code>List</code>. If the class name in the <code>List</code> is\n+     * <code>null</code>, <code>null</code> is stored in the output <code>List</code>.</p>\n+     *\n+     * @param classNames  the classNames to change\n+     * @return a <code>List</code> of Class objects corresponding to the class names,\n+     *  <code>null</code> if null input\n+     * @throws ClassCastException if classNames contains a non String entry\n+     */\n+    public static List convertClassNamesToClasses(List classNames) {\n+        if (classNames == null) {\n+            return null;\n+        }\n+        List classes = new ArrayList(classNames.size());\n+        for (Iterator it = classNames.iterator(); it.hasNext();) {\n+            String className = (String) it.next();\n+            try {\n+                classes.add(Class.forName(className));\n+            } catch (Exception ex) {\n+                classes.add(null);\n+            }\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts\n+     * them into class names.</p>\n+     *\n+     * <p>A new <code>List</code> is returned. <code>null</code> objects will be copied into\n+     * the returned list as <code>null</code>.</p>\n+     *\n+     * @param classes  the classes to change\n+     * @return a <code>List</code> of class names corresponding to the Class objects,\n+     *  <code>null</code> if null input\n+     * @throws ClassCastException if <code>classes</code> contains a non-<code>Class</code> entry\n+     */\n+    public static List convertClassesToClassNames(List classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+        List classNames = new ArrayList(classes.size());\n+        for (Iterator it = classes.iterator(); it.hasNext();) {\n+            Class cls = (Class) it.next();\n+            if (cls == null) {\n+                classNames.add(null);\n+            } else {\n+                classNames.add(cls.getName());\n+            }\n+        }\n+        return classNames;\n+    }\n+\n+    // Is assignable\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n+     *\n+     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n+     * Class pair in the input arrays. It can be used to check if a set of arguments\n+     * (the first parameter) are suitably compatible with a set of method parameter types\n+     * (the second parameter).</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n+     * method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,\n+     * <code>float</code> or <code>double</code>. This method returns the correct\n+     * result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method will\n+     * return <code>true</code> if <code>null</code> is passed in and the toClass is\n+     * non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param classArray  the array of Classes to check, may be <code>null</code>\n+     * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n+     * @return <code>true</code> if assignment possible\n+     */\n+    public static boolean isAssignable(Class[] classArray, Class[] toClassArray) {\n+        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n+            return false;\n+        }\n+        if (classArray == null) {\n+            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (toClassArray == null) {\n+            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        for (int i = 0; i < classArray.length; i++) {\n+            if (isAssignable(classArray[i], toClassArray[i]) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if one <code>Class</code> can be assigned to a variable of\n+     * another <code>Class</code>.</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,\n+     * this method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a long, float or\n+     * double. This method returns the correct result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method\n+     * will return <code>true</code> if <code>null</code> is passed in and the\n+     * toClass is non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param cls  the Class to check, may be null\n+     * @param toClass  the Class to try to assign into, returns false if null\n+     * @return <code>true</code> if assignment possible\n+     */\n+    public static boolean isAssignable(Class cls, Class toClass) {\n+        if (toClass == null) {\n+            return false;\n+        }\n+        // have to check for null, as isAssignableFrom doesn't\n+        if (cls == null) {\n+            return !(toClass.isPrimitive());\n+        }\n+        if (cls.equals(toClass)) {\n+            return true;\n+        }\n+        if (cls.isPrimitive()) {\n+            if (toClass.isPrimitive() == false) {\n+                return false;\n+            }\n+            if (Integer.TYPE.equals(cls)) {\n+                return Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Long.TYPE.equals(cls)) {\n+                return Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Boolean.TYPE.equals(cls)) {\n+                return false;\n+            }\n+            if (Double.TYPE.equals(cls)) {\n+                return false;\n+            }\n+            if (Float.TYPE.equals(cls)) {\n+                return Double.TYPE.equals(toClass);\n+            }\n+            if (Character.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Short.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Byte.TYPE.equals(cls)) {\n+                return Short.TYPE.equals(toClass)\n+                    || Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            // should never get here\n+            return false;\n+        }\n+        return toClass.isAssignableFrom(cls);\n+    }\n+\n+    /**\n+     * <p>Converts the specified primitive Class object to its corresponding\n+     * wrapper Class object.</p>\n+     *\n+     * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,\n+     * returning <code>Void.TYPE</code>.</p>\n+     *\n+     * @param cls  the class to convert, may be null\n+     * @return the wrapper class for <code>cls</code> or <code>cls</code> if\n+     * <code>cls</code> is not a primitive. <code>null</code> if null input.\n+     * @since 2.1\n+     */\n+    public static Class primitiveToWrapper(Class cls) {\n+        Class convertedClass = cls;\n+        if (cls != null && cls.isPrimitive()) {\n+            convertedClass = (Class) primitiveWrapperMap.get(cls);\n+        }\n+        return convertedClass;\n+    }\n+\n+    /**\n+     * <p>Converts the specified array of primitive Class objects to an array of\n+     * its corresponding wrapper Class objects.</p>\n+     *\n+     * @param classes  the class array to convert, may be null or empty\n+     * @return an array which contains for each given class, the wrapper class or\n+     * the original class if class is not a primitive. <code>null</code> if null input.\n+     * Empty array if an empty array passed in.\n+     * @since 2.1\n+     */\n+    public static Class[] primitivesToWrappers(Class[] classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+\n+        if (classes.length == 0) {\n+            return classes;\n+        }\n+\n+        Class[] convertedClasses = new Class[classes.length];\n+        for (int i=0; i < classes.length; i++) {\n+            convertedClasses[i] = primitiveToWrapper( classes[i] );\n+        }\n+        return convertedClasses;\n+    }\n+\n+    // Inner class\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Is the specified class an inner class or static nested class.</p>\n+     *\n+     * @param cls  the class to check, may be null\n+     * @return <code>true</code> if the class is an inner or static nested class,\n+     *  false if not or <code>null</code>\n+     */\n+    public static boolean isInnerClass(Class cls) {\n+        if (cls == null) {\n+            return false;\n+        }\n+        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n+    }\n+\n+    // Class loading\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Returns the class represented by <code>className</code> using the\n+     * <code>classLoader</code>.  This implementation supports names like\n+     * \"<code>java.lang.String[]</code>\" as well as \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param classLoader  the class loader to use to load the class\n+     * @param className  the class name\n+     * @param initialize  whether the class must be initialized\n+     * @return the class represented by <code>className</code> using the <code>classLoader</code>\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class getClass(\n+            ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n+        Class clazz;\n+        if (abbreviationMap.containsKey(className)) {\n+            String clsName = \"[\" + abbreviationMap.get(className);\n+            clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n+        } else {\n+            clazz = Class.forName(toProperClassName(className), initialize, classLoader);\n+        }\n+        return clazz;\n+    }\n+\n+    /**\n+     * Returns the (initialized) class represented by <code>className</code>\n+     * using the <code>classLoader</code>.  This implementation supports names\n+     * like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param classLoader  the class loader to use to load the class\n+     * @param className  the class name\n+     * @return the class represented by <code>className</code> using the <code>classLoader</code>\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n+        return getClass(classLoader, className, true);\n+    }\n+\n+    /**\n+     * Returns the (initialized )class represented by <code>className</code>\n+     * using the current thread's context class loader. This implementation\n+     * supports names like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param className  the class name\n+     * @return the class represented by <code>className</code> using the current thread's context class loader\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class getClass(String className) throws ClassNotFoundException {\n+        return getClass(className, true);\n+    }\n+\n+    /**\n+     * Returns the class represented by <code>className</code> using the\n+     * current thread's context class loader. This implementation supports\n+     * names like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param className  the class name\n+     * @param initialize  whether the class must be initialized\n+     * @return the class represented by <code>className</code> using the current thread's context class loader\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class getClass(String className, boolean initialize) throws ClassNotFoundException {\n+        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n+        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n+        return getClass(loader, className, initialize );\n+    }\n+\n+    // Public method\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the desired Method much like <code>Class.getMethod</code>, however \n+     * it ensures that the returned Method is from a public class or interface and not \n+     * from an anonymous inner class. This means that the Method is invokable and \n+     * doesn't fall foul of Java bug \n+     * <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n+     *\n+     *  <code><pre>Set set = Collections.unmodifiableSet(...);\n+     *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n+     *  Object result = method.invoke(set, new Object[]);</pre></code>\n+     * </p>\n+     *\n+     * @param cls  the class to check, not null\n+     * @param methodName  the name of the method\n+     * @param parameterTypes  the list of parameters\n+     * @return the method\n+     * @throws NullPointerException if the class is null\n+     * @throws SecurityException if a a security violation occured\n+     * @throws NoSuchMethodException if the method is not found in the given class\n+     *  or if the metothod doen't conform with the requirements\n+     */\n+    public static Method getPublicMethod(Class cls, String methodName, Class parameterTypes[]) \n+            throws SecurityException, NoSuchMethodException {\n+        \n+        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n+        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n+            return declaredMethod;\n+        }\n+        \n+        List candidateClasses = new ArrayList();\n+        candidateClasses.addAll(getAllInterfaces(cls));\n+        candidateClasses.addAll(getAllSuperclasses(cls));\n+        \n+        for (Iterator it = candidateClasses.iterator(); it.hasNext(); ) {\n+            Class candidateClass = (Class) it.next();\n+            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n+                continue;\n+            }\n+            Method candidateMethod;\n+            try {\n+                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n+            } catch (NoSuchMethodException ex) {\n+                continue;\n+            }\n+            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n+                return candidateMethod;\n+            }\n+        }\n+        \n+        throw new NoSuchMethodException(\"Can't find a public method for \" +\n+                methodName + \" \" + ArrayUtils.toString(parameterTypes));\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Converts a class name to a JLS style class name.\n+     *\n+     * @param className  the class name\n+     * @return the converted name\n+     */\n+    private static String toProperClassName(String className) {\n+        className = StringUtils.deleteWhitespace(className);\n+        if (className == null) {\n+            throw new NullArgumentException(\"className\");\n+        } else if (className.endsWith(\"[]\")) {\n+            StringBuffer classNameBuffer = new StringBuffer();\n+            while (className.endsWith(\"[]\")) {\n+                className = className.substring(0, className.length() - 2);\n+                classNameBuffer.append(\"[\");\n+            }\n+            String abbreviation = (String) abbreviationMap.get(className);\n+            if (abbreviation != null) {\n+                classNameBuffer.append(abbreviation);\n+            } else {\n+                classNameBuffer.append(\"L\").append(className).append(\";\");\n+            }\n+            className = classNameBuffer.toString();\n+        }\n+        return className;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/Entities.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+/**\n+ * <p>Provides HTML and XML entity utilities.</p>\n+ *\n+ * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n+ * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n+ * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n+ * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n+ * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n+ *\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+class Entities {\n+\n+    private static final String[][] BASIC_ARRAY = {\n+        {\"quot\", \"34\"}, // \" - double-quote\n+        {\"amp\", \"38\"}, // & - ampersand\n+        {\"lt\", \"60\"}, // < - less-than\n+        {\"gt\", \"62\"}, // > - greater-than\n+    };\n+\n+    private static final String[][] APOS_ARRAY = {\n+        {\"apos\", \"39\"}, // XML apostrophe\n+    };\n+\n+    // package scoped for testing\n+    static final String[][] ISO8859_1_ARRAY = {\n+        {\"nbsp\", \"160\"}, // non-breaking space\n+        {\"iexcl\", \"161\"}, //inverted exclamation mark\n+        {\"cent\", \"162\"}, //cent sign\n+        {\"pound\", \"163\"}, //pound sign\n+        {\"curren\", \"164\"}, //currency sign\n+        {\"yen\", \"165\"}, //yen sign = yuan sign\n+        {\"brvbar\", \"166\"}, //broken bar = broken vertical bar\n+        {\"sect\", \"167\"}, //section sign\n+        {\"uml\", \"168\"}, //diaeresis = spacing diaeresis\n+        {\"copy\", \"169\"}, //  - copyright sign\n+        {\"ordf\", \"170\"}, //feminine ordinal indicator\n+        {\"laquo\", \"171\"}, //left-pointing double angle quotation mark = left pointing guillemet\n+        {\"not\", \"172\"}, //not sign\n+        {\"shy\", \"173\"}, //soft hyphen = discretionary hyphen\n+        {\"reg\", \"174\"}, //  - registered trademark sign\n+        {\"macr\", \"175\"}, //macron = spacing macron = overline = APL overbar\n+        {\"deg\", \"176\"}, //degree sign\n+        {\"plusmn\", \"177\"}, //plus-minus sign = plus-or-minus sign\n+        {\"sup2\", \"178\"}, //superscript two = superscript digit two = squared\n+        {\"sup3\", \"179\"}, //superscript three = superscript digit three = cubed\n+        {\"acute\", \"180\"}, //acute accent = spacing acute\n+        {\"micro\", \"181\"}, //micro sign\n+        {\"para\", \"182\"}, //pilcrow sign = paragraph sign\n+        {\"middot\", \"183\"}, //middle dot = Georgian comma = Greek middle dot\n+        {\"cedil\", \"184\"}, //cedilla = spacing cedilla\n+        {\"sup1\", \"185\"}, //superscript one = superscript digit one\n+        {\"ordm\", \"186\"}, //masculine ordinal indicator\n+        {\"raquo\", \"187\"}, //right-pointing double angle quotation mark = right pointing guillemet\n+        {\"frac14\", \"188\"}, //vulgar fraction one quarter = fraction one quarter\n+        {\"frac12\", \"189\"}, //vulgar fraction one half = fraction one half\n+        {\"frac34\", \"190\"}, //vulgar fraction three quarters = fraction three quarters\n+        {\"iquest\", \"191\"}, //inverted question mark = turned question mark\n+        {\"Agrave\", \"192\"}, //  - uppercase A, grave accent\n+        {\"Aacute\", \"193\"}, //  - uppercase A, acute accent\n+        {\"Acirc\", \"194\"}, //  - uppercase A, circumflex accent\n+        {\"Atilde\", \"195\"}, //  - uppercase A, tilde\n+        {\"Auml\", \"196\"}, //  - uppercase A, umlaut\n+        {\"Aring\", \"197\"}, //  - uppercase A, ring\n+        {\"AElig\", \"198\"}, //  - uppercase AE\n+        {\"Ccedil\", \"199\"}, //  - uppercase C, cedilla\n+        {\"Egrave\", \"200\"}, //  - uppercase E, grave accent\n+        {\"Eacute\", \"201\"}, //  - uppercase E, acute accent\n+        {\"Ecirc\", \"202\"}, //  - uppercase E, circumflex accent\n+        {\"Euml\", \"203\"}, //  - uppercase E, umlaut\n+        {\"Igrave\", \"204\"}, //  - uppercase I, grave accent\n+        {\"Iacute\", \"205\"}, //  - uppercase I, acute accent\n+        {\"Icirc\", \"206\"}, //  - uppercase I, circumflex accent\n+        {\"Iuml\", \"207\"}, //  - uppercase I, umlaut\n+        {\"ETH\", \"208\"}, //  - uppercase Eth, Icelandic\n+        {\"Ntilde\", \"209\"}, //  - uppercase N, tilde\n+        {\"Ograve\", \"210\"}, //  - uppercase O, grave accent\n+        {\"Oacute\", \"211\"}, //  - uppercase O, acute accent\n+        {\"Ocirc\", \"212\"}, //  - uppercase O, circumflex accent\n+        {\"Otilde\", \"213\"}, //  - uppercase O, tilde\n+        {\"Ouml\", \"214\"}, //  - uppercase O, umlaut\n+        {\"times\", \"215\"}, //multiplication sign\n+        {\"Oslash\", \"216\"}, //  - uppercase O, slash\n+        {\"Ugrave\", \"217\"}, //  - uppercase U, grave accent\n+        {\"Uacute\", \"218\"}, //  - uppercase U, acute accent\n+        {\"Ucirc\", \"219\"}, //  - uppercase U, circumflex accent\n+        {\"Uuml\", \"220\"}, //  - uppercase U, umlaut\n+        {\"Yacute\", \"221\"}, //  - uppercase Y, acute accent\n+        {\"THORN\", \"222\"}, //  - uppercase THORN, Icelandic\n+        {\"szlig\", \"223\"}, //  - lowercase sharps, German\n+        {\"agrave\", \"224\"}, //  - lowercase a, grave accent\n+        {\"aacute\", \"225\"}, //  - lowercase a, acute accent\n+        {\"acirc\", \"226\"}, //  - lowercase a, circumflex accent\n+        {\"atilde\", \"227\"}, //  - lowercase a, tilde\n+        {\"auml\", \"228\"}, //  - lowercase a, umlaut\n+        {\"aring\", \"229\"}, //  - lowercase a, ring\n+        {\"aelig\", \"230\"}, //  - lowercase ae\n+        {\"ccedil\", \"231\"}, //  - lowercase c, cedilla\n+        {\"egrave\", \"232\"}, //  - lowercase e, grave accent\n+        {\"eacute\", \"233\"}, //  - lowercase e, acute accent\n+        {\"ecirc\", \"234\"}, //  - lowercase e, circumflex accent\n+        {\"euml\", \"235\"}, //  - lowercase e, umlaut\n+        {\"igrave\", \"236\"}, //  - lowercase i, grave accent\n+        {\"iacute\", \"237\"}, //  - lowercase i, acute accent\n+        {\"icirc\", \"238\"}, //  - lowercase i, circumflex accent\n+        {\"iuml\", \"239\"}, //  - lowercase i, umlaut\n+        {\"eth\", \"240\"}, //  - lowercase eth, Icelandic\n+        {\"ntilde\", \"241\"}, //  - lowercase n, tilde\n+        {\"ograve\", \"242\"}, //  - lowercase o, grave accent\n+        {\"oacute\", \"243\"}, //  - lowercase o, acute accent\n+        {\"ocirc\", \"244\"}, //  - lowercase o, circumflex accent\n+        {\"otilde\", \"245\"}, //  - lowercase o, tilde\n+        {\"ouml\", \"246\"}, //  - lowercase o, umlaut\n+        {\"divide\", \"247\"}, // division sign\n+        {\"oslash\", \"248\"}, //  - lowercase o, slash\n+        {\"ugrave\", \"249\"}, //  - lowercase u, grave accent\n+        {\"uacute\", \"250\"}, //  - lowercase u, acute accent\n+        {\"ucirc\", \"251\"}, //  - lowercase u, circumflex accent\n+        {\"uuml\", \"252\"}, //  - lowercase u, umlaut\n+        {\"yacute\", \"253\"}, //  - lowercase y, acute accent\n+        {\"thorn\", \"254\"}, //  - lowercase thorn, Icelandic\n+        {\"yuml\", \"255\"}, //  - lowercase y, umlaut\n+    };\n+\n+    // http://www.w3.org/TR/REC-html40/sgml/entities.html\n+    // package scoped for testing\n+    static final String[][] HTML40_ARRAY = {\n+// <!-- Latin Extended-B -->\n+        {\"fnof\", \"402\"}, //latin small f with hook = function= florin, U+0192 ISOtech -->\n+// <!-- Greek -->\n+        {\"Alpha\", \"913\"}, //greek capital letter alpha, U+0391 -->\n+        {\"Beta\", \"914\"}, //greek capital letter beta, U+0392 -->\n+        {\"Gamma\", \"915\"}, //greek capital letter gamma,U+0393 ISOgrk3 -->\n+        {\"Delta\", \"916\"}, //greek capital letter delta,U+0394 ISOgrk3 -->\n+        {\"Epsilon\", \"917\"}, //greek capital letter epsilon, U+0395 -->\n+        {\"Zeta\", \"918\"}, //greek capital letter zeta, U+0396 -->\n+        {\"Eta\", \"919\"}, //greek capital letter eta, U+0397 -->\n+        {\"Theta\", \"920\"}, //greek capital letter theta,U+0398 ISOgrk3 -->\n+        {\"Iota\", \"921\"}, //greek capital letter iota, U+0399 -->\n+        {\"Kappa\", \"922\"}, //greek capital letter kappa, U+039A -->\n+        {\"Lambda\", \"923\"}, //greek capital letter lambda,U+039B ISOgrk3 -->\n+        {\"Mu\", \"924\"}, //greek capital letter mu, U+039C -->\n+        {\"Nu\", \"925\"}, //greek capital letter nu, U+039D -->\n+        {\"Xi\", \"926\"}, //greek capital letter xi, U+039E ISOgrk3 -->\n+        {\"Omicron\", \"927\"}, //greek capital letter omicron, U+039F -->\n+        {\"Pi\", \"928\"}, //greek capital letter pi, U+03A0 ISOgrk3 -->\n+        {\"Rho\", \"929\"}, //greek capital letter rho, U+03A1 -->\n+// <!-- there is no Sigmaf, and no U+03A2 character either -->\n+        {\"Sigma\", \"931\"}, //greek capital letter sigma,U+03A3 ISOgrk3 -->\n+        {\"Tau\", \"932\"}, //greek capital letter tau, U+03A4 -->\n+        {\"Upsilon\", \"933\"}, //greek capital letter upsilon,U+03A5 ISOgrk3 -->\n+        {\"Phi\", \"934\"}, //greek capital letter phi,U+03A6 ISOgrk3 -->\n+        {\"Chi\", \"935\"}, //greek capital letter chi, U+03A7 -->\n+        {\"Psi\", \"936\"}, //greek capital letter psi,U+03A8 ISOgrk3 -->\n+        {\"Omega\", \"937\"}, //greek capital letter omega,U+03A9 ISOgrk3 -->\n+        {\"alpha\", \"945\"}, //greek small letter alpha,U+03B1 ISOgrk3 -->\n+        {\"beta\", \"946\"}, //greek small letter beta, U+03B2 ISOgrk3 -->\n+        {\"gamma\", \"947\"}, //greek small letter gamma,U+03B3 ISOgrk3 -->\n+        {\"delta\", \"948\"}, //greek small letter delta,U+03B4 ISOgrk3 -->\n+        {\"epsilon\", \"949\"}, //greek small letter epsilon,U+03B5 ISOgrk3 -->\n+        {\"zeta\", \"950\"}, //greek small letter zeta, U+03B6 ISOgrk3 -->\n+        {\"eta\", \"951\"}, //greek small letter eta, U+03B7 ISOgrk3 -->\n+        {\"theta\", \"952\"}, //greek small letter theta,U+03B8 ISOgrk3 -->\n+        {\"iota\", \"953\"}, //greek small letter iota, U+03B9 ISOgrk3 -->\n+        {\"kappa\", \"954\"}, //greek small letter kappa,U+03BA ISOgrk3 -->\n+        {\"lambda\", \"955\"}, //greek small letter lambda,U+03BB ISOgrk3 -->\n+        {\"mu\", \"956\"}, //greek small letter mu, U+03BC ISOgrk3 -->\n+        {\"nu\", \"957\"}, //greek small letter nu, U+03BD ISOgrk3 -->\n+        {\"xi\", \"958\"}, //greek small letter xi, U+03BE ISOgrk3 -->\n+        {\"omicron\", \"959\"}, //greek small letter omicron, U+03BF NEW -->\n+        {\"pi\", \"960\"}, //greek small letter pi, U+03C0 ISOgrk3 -->\n+        {\"rho\", \"961\"}, //greek small letter rho, U+03C1 ISOgrk3 -->\n+        {\"sigmaf\", \"962\"}, //greek small letter final sigma,U+03C2 ISOgrk3 -->\n+        {\"sigma\", \"963\"}, //greek small letter sigma,U+03C3 ISOgrk3 -->\n+        {\"tau\", \"964\"}, //greek small letter tau, U+03C4 ISOgrk3 -->\n+        {\"upsilon\", \"965\"}, //greek small letter upsilon,U+03C5 ISOgrk3 -->\n+        {\"phi\", \"966\"}, //greek small letter phi, U+03C6 ISOgrk3 -->\n+        {\"chi\", \"967\"}, //greek small letter chi, U+03C7 ISOgrk3 -->\n+        {\"psi\", \"968\"}, //greek small letter psi, U+03C8 ISOgrk3 -->\n+        {\"omega\", \"969\"}, //greek small letter omega,U+03C9 ISOgrk3 -->\n+        {\"thetasym\", \"977\"}, //greek small letter theta symbol,U+03D1 NEW -->\n+        {\"upsih\", \"978\"}, //greek upsilon with hook symbol,U+03D2 NEW -->\n+        {\"piv\", \"982\"}, //greek pi symbol, U+03D6 ISOgrk3 -->\n+// <!-- General Punctuation -->\n+        {\"bull\", \"8226\"}, //bullet = black small circle,U+2022 ISOpub  -->\n+// <!-- bullet is NOT the same as bullet operator, U+2219 -->\n+        {\"hellip\", \"8230\"}, //horizontal ellipsis = three dot leader,U+2026 ISOpub  -->\n+        {\"prime\", \"8242\"}, //prime = minutes = feet, U+2032 ISOtech -->\n+        {\"Prime\", \"8243\"}, //double prime = seconds = inches,U+2033 ISOtech -->\n+        {\"oline\", \"8254\"}, //overline = spacing overscore,U+203E NEW -->\n+        {\"frasl\", \"8260\"}, //fraction slash, U+2044 NEW -->\n+// <!-- Letterlike Symbols -->\n+        {\"weierp\", \"8472\"}, //script capital P = power set= Weierstrass p, U+2118 ISOamso -->\n+        {\"image\", \"8465\"}, //blackletter capital I = imaginary part,U+2111 ISOamso -->\n+        {\"real\", \"8476\"}, //blackletter capital R = real part symbol,U+211C ISOamso -->\n+        {\"trade\", \"8482\"}, //trade mark sign, U+2122 ISOnum -->\n+        {\"alefsym\", \"8501\"}, //alef symbol = first transfinite cardinal,U+2135 NEW -->\n+// <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the \n+//      same glyph could be used to depict both characters -->\n+// <!-- Arrows -->\n+        {\"larr\", \"8592\"}, //leftwards arrow, U+2190 ISOnum -->\n+        {\"uarr\", \"8593\"}, //upwards arrow, U+2191 ISOnum-->\n+        {\"rarr\", \"8594\"}, //rightwards arrow, U+2192 ISOnum -->\n+        {\"darr\", \"8595\"}, //downwards arrow, U+2193 ISOnum -->\n+        {\"harr\", \"8596\"}, //left right arrow, U+2194 ISOamsa -->\n+        {\"crarr\", \"8629\"}, //downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->\n+        {\"lArr\", \"8656\"}, //leftwards double arrow, U+21D0 ISOtech -->\n+// <!-- ISO 10646 does not say that lArr is the same as the 'is implied by' \n+//      arrow but also does not have any other character for that function. \n+//      So ? lArr canbe used for 'is implied by' as ISOtech suggests -->\n+        {\"uArr\", \"8657\"}, //upwards double arrow, U+21D1 ISOamsa -->\n+        {\"rArr\", \"8658\"}, //rightwards double arrow,U+21D2 ISOtech -->\n+// <!-- ISO 10646 does not say this is the 'implies' character but does not\n+//      have another character with this function so ?rArr can be used for\n+//      'implies' as ISOtech suggests -->\n+        {\"dArr\", \"8659\"}, //downwards double arrow, U+21D3 ISOamsa -->\n+        {\"hArr\", \"8660\"}, //left right double arrow,U+21D4 ISOamsa -->\n+// <!-- Mathematical Operators -->\n+        {\"forall\", \"8704\"}, //for all, U+2200 ISOtech -->\n+        {\"part\", \"8706\"}, //partial differential, U+2202 ISOtech  -->\n+        {\"exist\", \"8707\"}, //there exists, U+2203 ISOtech -->\n+        {\"empty\", \"8709\"}, //empty set = null set = diameter,U+2205 ISOamso -->\n+        {\"nabla\", \"8711\"}, //nabla = backward difference,U+2207 ISOtech -->\n+        {\"isin\", \"8712\"}, //element of, U+2208 ISOtech -->\n+        {\"notin\", \"8713\"}, //not an element of, U+2209 ISOtech -->\n+        {\"ni\", \"8715\"}, //contains as member, U+220B ISOtech -->\n+// <!-- should there be a more memorable name than 'ni'? -->\n+        {\"prod\", \"8719\"}, //n-ary product = product sign,U+220F ISOamsb -->\n+// <!-- prod is NOT the same character as U+03A0 'greek capital letter pi' \n+//      though the same glyph might be used for both -->\n+        {\"sum\", \"8721\"}, //n-ary summation, U+2211 ISOamsb -->\n+// <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'\n+//      though the same glyph might be used for both -->\n+        {\"minus\", \"8722\"}, //minus sign, U+2212 ISOtech -->\n+        {\"lowast\", \"8727\"}, //asterisk operator, U+2217 ISOtech -->\n+        {\"radic\", \"8730\"}, //square root = radical sign,U+221A ISOtech -->\n+        {\"prop\", \"8733\"}, //proportional to, U+221D ISOtech -->\n+        {\"infin\", \"8734\"}, //infinity, U+221E ISOtech -->\n+        {\"ang\", \"8736\"}, //angle, U+2220 ISOamso -->\n+        {\"and\", \"8743\"}, //logical and = wedge, U+2227 ISOtech -->\n+        {\"or\", \"8744\"}, //logical or = vee, U+2228 ISOtech -->\n+        {\"cap\", \"8745\"}, //intersection = cap, U+2229 ISOtech -->\n+        {\"cup\", \"8746\"}, //union = cup, U+222A ISOtech -->\n+        {\"int\", \"8747\"}, //integral, U+222B ISOtech -->\n+        {\"there4\", \"8756\"}, //therefore, U+2234 ISOtech -->\n+        {\"sim\", \"8764\"}, //tilde operator = varies with = similar to,U+223C ISOtech -->\n+// <!-- tilde operator is NOT the same character as the tilde, U+007E,although\n+//      the same glyph might be used to represent both  -->\n+        {\"cong\", \"8773\"}, //approximately equal to, U+2245 ISOtech -->\n+        {\"asymp\", \"8776\"}, //almost equal to = asymptotic to,U+2248 ISOamsr -->\n+        {\"ne\", \"8800\"}, //not equal to, U+2260 ISOtech -->\n+        {\"equiv\", \"8801\"}, //identical to, U+2261 ISOtech -->\n+        {\"le\", \"8804\"}, //less-than or equal to, U+2264 ISOtech -->\n+        {\"ge\", \"8805\"}, //greater-than or equal to,U+2265 ISOtech -->\n+        {\"sub\", \"8834\"}, //subset of, U+2282 ISOtech -->\n+        {\"sup\", \"8835\"}, //superset of, U+2283 ISOtech -->\n+// <!-- note that nsup, 'not a superset of, U+2283' is not covered by the\n+//      Symbol font encoding and is not included. Should it be, for symmetry?\n+//      It is in ISOamsn  --> <!ENTITY nsub\", \"8836\"},  \n+//      not a subset of, U+2284 ISOamsn -->\n+        {\"sube\", \"8838\"}, //subset of or equal to, U+2286 ISOtech -->\n+        {\"supe\", \"8839\"}, //superset of or equal to,U+2287 ISOtech -->\n+        {\"oplus\", \"8853\"}, //circled plus = direct sum,U+2295 ISOamsb -->\n+        {\"otimes\", \"8855\"}, //circled times = vector product,U+2297 ISOamsb -->\n+        {\"perp\", \"8869\"}, //up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->\n+        {\"sdot\", \"8901\"}, //dot operator, U+22C5 ISOamsb -->\n+// <!-- dot operator is NOT the same character as U+00B7 middle dot -->\n+// <!-- Miscellaneous Technical -->\n+        {\"lceil\", \"8968\"}, //left ceiling = apl upstile,U+2308 ISOamsc  -->\n+        {\"rceil\", \"8969\"}, //right ceiling, U+2309 ISOamsc  -->\n+        {\"lfloor\", \"8970\"}, //left floor = apl downstile,U+230A ISOamsc  -->\n+        {\"rfloor\", \"8971\"}, //right floor, U+230B ISOamsc  -->\n+        {\"lang\", \"9001\"}, //left-pointing angle bracket = bra,U+2329 ISOtech -->\n+// <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation mark' -->\n+        {\"rang\", \"9002\"}, //right-pointing angle bracket = ket,U+232A ISOtech -->\n+// <!-- rang is NOT the same character as U+003E 'greater than' or U+203A \n+//      'single right-pointing angle quotation mark' -->\n+// <!-- Geometric Shapes -->\n+        {\"loz\", \"9674\"}, //lozenge, U+25CA ISOpub -->\n+// <!-- Miscellaneous Symbols -->\n+        {\"spades\", \"9824\"}, //black spade suit, U+2660 ISOpub -->\n+// <!-- black here seems to mean filled as opposed to hollow -->\n+        {\"clubs\", \"9827\"}, //black club suit = shamrock,U+2663 ISOpub -->\n+        {\"hearts\", \"9829\"}, //black heart suit = valentine,U+2665 ISOpub -->\n+        {\"diams\", \"9830\"}, //black diamond suit, U+2666 ISOpub -->\n+\n+// <!-- Latin Extended-A -->\n+        {\"OElig\", \"338\"}, //  -- latin capital ligature OE,U+0152 ISOlat2 -->\n+        {\"oelig\", \"339\"}, //  -- latin small ligature oe, U+0153 ISOlat2 -->\n+// <!-- ligature is a misnomer, this is a separate character in some languages -->\n+        {\"Scaron\", \"352\"}, //  -- latin capital letter S with caron,U+0160 ISOlat2 -->\n+        {\"scaron\", \"353\"}, //  -- latin small letter s with caron,U+0161 ISOlat2 -->\n+        {\"Yuml\", \"376\"}, //  -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->\n+// <!-- Spacing Modifier Letters -->\n+        {\"circ\", \"710\"}, //  -- modifier letter circumflex accent,U+02C6 ISOpub -->\n+        {\"tilde\", \"732\"}, //small tilde, U+02DC ISOdia -->\n+// <!-- General Punctuation -->\n+        {\"ensp\", \"8194\"}, //en space, U+2002 ISOpub -->\n+        {\"emsp\", \"8195\"}, //em space, U+2003 ISOpub -->\n+        {\"thinsp\", \"8201\"}, //thin space, U+2009 ISOpub -->\n+        {\"zwnj\", \"8204\"}, //zero width non-joiner,U+200C NEW RFC 2070 -->\n+        {\"zwj\", \"8205\"}, //zero width joiner, U+200D NEW RFC 2070 -->\n+        {\"lrm\", \"8206\"}, //left-to-right mark, U+200E NEW RFC 2070 -->\n+        {\"rlm\", \"8207\"}, //right-to-left mark, U+200F NEW RFC 2070 -->\n+        {\"ndash\", \"8211\"}, //en dash, U+2013 ISOpub -->\n+        {\"mdash\", \"8212\"}, //em dash, U+2014 ISOpub -->\n+        {\"lsquo\", \"8216\"}, //left single quotation mark,U+2018 ISOnum -->\n+        {\"rsquo\", \"8217\"}, //right single quotation mark,U+2019 ISOnum -->\n+        {\"sbquo\", \"8218\"}, //single low-9 quotation mark, U+201A NEW -->\n+        {\"ldquo\", \"8220\"}, //left double quotation mark,U+201C ISOnum -->\n+        {\"rdquo\", \"8221\"}, //right double quotation mark,U+201D ISOnum -->\n+        {\"bdquo\", \"8222\"}, //double low-9 quotation mark, U+201E NEW -->\n+        {\"dagger\", \"8224\"}, //dagger, U+2020 ISOpub -->\n+        {\"Dagger\", \"8225\"}, //double dagger, U+2021 ISOpub -->\n+        {\"permil\", \"8240\"}, //per mille sign, U+2030 ISOtech -->\n+        {\"lsaquo\", \"8249\"}, //single left-pointing angle quotation mark,U+2039 ISO proposed -->\n+// <!-- lsaquo is proposed but not yet ISO standardized -->\n+        {\"rsaquo\", \"8250\"}, //single right-pointing angle quotation mark,U+203A ISO proposed -->\n+// <!-- rsaquo is proposed but not yet ISO standardized -->\n+        {\"euro\", \"8364\"}, //  -- euro sign, U+20AC NEW -->\n+    };\n+\n+    /**\n+     * <p>The set of entities supported by standard XML.</p>\n+     */\n+    public static final Entities XML;\n+\n+    /**\n+     * <p>The set of entities supported by HTML 3.2.</p>\n+     */\n+    public static final Entities HTML32;\n+\n+    /**\n+     * <p>The set of entities supported by HTML 4.0.</p>\n+     */\n+    public static final Entities HTML40;\n+\n+    static {\n+        XML = new Entities();\n+        XML.addEntities(BASIC_ARRAY);\n+        XML.addEntities(APOS_ARRAY);\n+    }\n+\n+    static {\n+        HTML32 = new Entities();\n+        HTML32.addEntities(BASIC_ARRAY);\n+        HTML32.addEntities(ISO8859_1_ARRAY);\n+    }\n+\n+    static {\n+        HTML40 = new Entities();\n+        fillWithHtml40Entities(HTML40);\n+    }\n+\n+    /**\n+     * <p>Fills the specified entities instance with HTML 40 entities.</p>\n+     * \n+     * @param entities the instance to be filled.\n+     */\n+    static void fillWithHtml40Entities(Entities entities) {\n+        entities.addEntities(BASIC_ARRAY);\n+        entities.addEntities(ISO8859_1_ARRAY);\n+        entities.addEntities(HTML40_ARRAY);\n+    }\n+\n+    static interface EntityMap {\n+        /**\n+         * <p>Add an entry to this entity map.</p>\n+         * \n+         * @param name the entity name\n+         * @param value the entity value\n+         */\n+        void add(String name, int value);\n+\n+        /**\n+         * <p>Returns the name of the entity identified by the specified value.</p>\n+         * \n+         * @param value the value to locate\n+         * @return entity name associated with the specified value\n+         */\n+        String name(int value);\n+\n+        /**\n+         * <p>Returns the value of the entity identified by the specified name.</p>\n+         * \n+         * @param name the name to locate\n+         * @return entity value associated with the specified name\n+         */\n+        int value(String name);\n+    }\n+\n+    static class PrimitiveEntityMap implements EntityMap {\n+        private Map mapNameToValue = new HashMap();\n+        private IntHashMap mapValueToName = new IntHashMap();\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void add(String name, int value) {\n+            mapNameToValue.put(name, new Integer(value));\n+            mapValueToName.put(value, name);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public String name(int value) {\n+            return (String) mapValueToName.get(value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int value(String name) {\n+            Object value = mapNameToValue.get(name);\n+            if (value == null) {\n+                return -1;\n+            }\n+            return ((Integer) value).intValue();\n+        }\n+    }\n+\n+\n+    static abstract class MapIntMap implements Entities.EntityMap {\n+        protected Map mapNameToValue;\n+        protected Map mapValueToName;\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void add(String name, int value) {\n+            mapNameToValue.put(name, new Integer(value));\n+            mapValueToName.put(new Integer(value), name);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public String name(int value) {\n+            return (String) mapValueToName.get(new Integer(value));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int value(String name) {\n+            Object value = mapNameToValue.get(name);\n+            if (value == null) {\n+                return -1;\n+            }\n+            return ((Integer) value).intValue();\n+        }\n+    }\n+\n+    static class HashEntityMap extends MapIntMap {\n+        /**\n+         * Constructs a new instance of <code>HashEntityMap</code>.\n+         */\n+        public HashEntityMap() {\n+            mapNameToValue = new HashMap();\n+            mapValueToName = new HashMap();\n+        }\n+    }\n+\n+    static class TreeEntityMap extends MapIntMap {\n+      /**\n+       * Constructs a new instance of <code>TreeEntityMap</code>.\n+       */\n+        public TreeEntityMap() {\n+            mapNameToValue = new TreeMap();\n+            mapValueToName = new TreeMap();\n+        }\n+    }\n+\n+    static class LookupEntityMap extends PrimitiveEntityMap {\n+        private String[] lookupTable;\n+        private int LOOKUP_TABLE_SIZE = 256;\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public String name(int value) {\n+            if (value < LOOKUP_TABLE_SIZE) {\n+                return lookupTable()[value];\n+            }\n+            return super.name(value);\n+        }\n+\n+        /**\n+         * <p>Returns the lookup table for this entity map. The lookup table is created if it has not been \n+         * previously.</p>\n+         * \n+         * @return the lookup table\n+         */\n+        private String[] lookupTable() {\n+            if (lookupTable == null) {\n+                createLookupTable();\n+            }\n+            return lookupTable;\n+        }\n+\n+        /**\n+         * <p>Creates an entity lookup table of LOOKUP_TABLE_SIZE elements, initialized with entity names.</p>\n+         */\n+        private void createLookupTable() {\n+            lookupTable = new String[LOOKUP_TABLE_SIZE];\n+            for (int i = 0; i < LOOKUP_TABLE_SIZE; ++i) {\n+                lookupTable[i] = super.name(i);\n+            }\n+        }\n+    }\n+\n+    static class ArrayEntityMap implements EntityMap {\n+        protected int growBy = 100;\n+        protected int size = 0;\n+        protected String[] names;\n+        protected int[] values;\n+\n+        /**\n+         * Constructs a new instance of <code>ArrayEntityMap</code>.\n+         */\n+        public ArrayEntityMap() {\n+            names = new String[growBy];\n+            values = new int[growBy];\n+        }\n+\n+        /**\n+         * Constructs a new instance of <code>ArrayEntityMap</code>\n+         * specifying the size by which the array should grow.\n+         * \n+         * @param growBy array will be initialized to and will grow by this amount\n+         */\n+        public ArrayEntityMap(int growBy) {\n+            this.growBy = growBy;\n+            names = new String[growBy];\n+            values = new int[growBy];\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void add(String name, int value) {\n+            ensureCapacity(size + 1);\n+            names[size] = name;\n+            values[size] = value;\n+            size++;\n+        }\n+\n+        /**\n+         * Verifies the capacity of the entity array, adjusting the size if necessary.\n+         * \n+         * @param capacity size the array should be\n+         */\n+        protected void ensureCapacity(int capacity) {\n+            if (capacity > names.length) {\n+                int newSize = Math.max(capacity, size + growBy);\n+                String[] newNames = new String[newSize];\n+                System.arraycopy(names, 0, newNames, 0, size);\n+                names = newNames;\n+                int[] newValues = new int[newSize];\n+                System.arraycopy(values, 0, newValues, 0, size);\n+                values = newValues;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public String name(int value) {\n+            for (int i = 0; i < size; ++i) {\n+                if (values[i] == value) {\n+                    return names[i];\n+                }\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int value(String name) {\n+            for (int i = 0; i < size; ++i) {\n+                if (names[i].equals(name)) {\n+                    return values[i];\n+                }\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    static class BinaryEntityMap extends ArrayEntityMap {\n+\n+        /**\n+         * Constructs a new instance of <code>BinaryEntityMap</code>.\n+         */\n+        public BinaryEntityMap() {\n+          super();\n+        }\n+\n+        /**\n+         * Constructs a new instance of <code>ArrayEntityMap</code>\n+         * specifying the size by which the underlying array should grow.\n+         * \n+         * @param growBy array will be initialized to and will grow by this amount\n+         */\n+        public BinaryEntityMap(int growBy) {\n+            super(growBy);\n+        }\n+\n+        /**\n+         * Performs a binary search of the entity array for the specified key.\n+         * This method is based on code in {@link java.util.Arrays}.\n+         * \n+         * @param key the key to be found\n+         * @return the index of the entity array matching the specified key\n+         */\n+        private int binarySearch(int key) {\n+            int low = 0;\n+            int high = size - 1;\n+\n+            while (low <= high) {\n+                int mid = (low + high) >> 1;\n+                int midVal = values[mid];\n+\n+                if (midVal < key) {\n+                    low = mid + 1;\n+                } else if (midVal > key) {\n+                    high = mid - 1;\n+                } else {\n+                    return mid; // key found\n+                }\n+            }\n+            return -(low + 1);  // key not found.\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void add(String name, int value) {\n+            ensureCapacity(size + 1);\n+            int insertAt = binarySearch(value);\n+            if (insertAt > 0) {\n+                return;    // note: this means you can't insert the same value twice\n+            }\n+            insertAt = -(insertAt + 1);  // binarySearch returns it negative and off-by-one\n+            System.arraycopy(values, insertAt, values, insertAt + 1, size - insertAt);\n+            values[insertAt] = value;\n+            System.arraycopy(names, insertAt, names, insertAt + 1, size - insertAt);\n+            names[insertAt] = name;\n+            size++;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public String name(int value) {\n+            int index = binarySearch(value);\n+            if (index < 0) {\n+                return null;\n+            }\n+            return names[index];\n+        }\n+    }\n+\n+    // package scoped for testing\n+    EntityMap map = new Entities.LookupEntityMap();\n+\n+    /**\n+     * <p>Adds entities to this entity.</p>\n+     * \n+     * @param entityArray array of entities to be added\n+     */\n+    public void addEntities(String[][] entityArray) {\n+        for (int i = 0; i < entityArray.length; ++i) {\n+            addEntity(entityArray[i][0], Integer.parseInt(entityArray[i][1]));\n+        }\n+    }\n+\n+    /**\n+     * <p>Add an entity to this entity.</p>\n+     * \n+     * @param name name of the entity\n+     * @param value vale of the entity\n+     */\n+    public void addEntity(String name, int value) {\n+        map.add(name, value);\n+    }\n+\n+    /**\n+     * <p>Returns the name of the entity identified by the specified value.</p>\n+     * \n+     * @param value the value to locate\n+     * @return entity name associated with the specified value\n+     */\n+    public String entityName(int value) {\n+        return map.name(value);\n+    }\n+\n+    /**\n+     * <p>Returns the value of the entity identified by the specified name.</p>\n+     * \n+     * @param name the name to locate\n+     * @return entity value associated with the specified name\n+     */\n+    public int entityValue(String name) {\n+        return map.value(name);\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in a <code>String</code>.</p>\n+     *\n+     * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),\n+     * escape(&quot;\\u00A1&quot;) will return &quot;&amp;foo;&quot;</p>\n+     *\n+     * @param str The <code>String</code> to escape.\n+     * @return A new escaped <code>String</code>.\n+     */\n+    public String escape(String str) {\n+        //todo: rewrite to use a Writer\n+        StringBuffer buf = new StringBuffer(str.length() * 2);\n+        int i;\n+        for (i = 0; i < str.length(); ++i) {\n+            char ch = str.charAt(i);\n+            String entityName = this.entityName(ch);\n+            if (entityName == null) {\n+                if (ch > 0x7F) {\n+                    int intValue = ch;\n+                    buf.append(\"&#\");\n+                    buf.append(intValue);\n+                    buf.append(';');\n+                } else {\n+                    buf.append(ch);\n+                }\n+            } else {\n+                buf.append('&');\n+                buf.append(entityName);\n+                buf.append(';');\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in the <code>String</code> passed and writes the result\n+     * to the <code>Writer</code> passed. </p>\n+     * \n+     * @param writer The <code>Writer</code> to write the results of the escaping to.\n+     *                            Assumed to be a non-null value.\n+     * @param str The <code>String</code> to escape. Assumed to be a non-null value.\n+     * @throws IOException when <code>Writer</code> passed throws the exception from\n+     *                                       calls to the {@link Writer#write(int)} methods.\n+     *                                       \n+     * @see #escape(String)\n+     * @see Writer\n+     */\n+    public void escape(Writer writer, String str) throws IOException {\n+        int len = str.length();\n+        for (int i = 0; i < len; i++) {\n+            char c = str.charAt(i);\n+            String entityName = this.entityName(c);\n+            if (entityName == null) {\n+                if (c > 0x7F) {\n+                    writer.write(\"&#\");\n+                    writer.write(Integer.toString(c, 10));\n+                    writer.write(';');\n+                } else {\n+                    writer.write(c);\n+                }\n+            } else {\n+                writer.write('&');\n+                writer.write(entityName);\n+                writer.write(';');\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * <p>Unescapes the entities in a <code>String</code>.</p>\n+     *\n+     * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),\n+     * unescape(&quot;&amp;foo;&quot;) will return &quot;\\u00A1&quot;</p>\n+     *\n+     * @param str The <code>String</code> to escape.\n+     * @return A new escaped <code>String</code>.\n+     */\n+    public String unescape(String str) {\n+        StringBuffer buf = new StringBuffer(str.length());\n+        int i;\n+        for (i = 0; i < str.length(); ++i) {\n+            char ch = str.charAt(i);\n+            if (ch == '&') {\n+                int semi = str.indexOf(';', i + 1);\n+                if (semi == -1) {\n+                    buf.append(ch);\n+                    continue;\n+                }\n+                int amph = str.indexOf('&', i + 1);\n+                if( amph != -1 && amph < semi ) {\n+                    // Then the text looks like &...&...;\n+                    buf.append(ch);\n+                    continue;\n+                }\n+                String entityName = str.substring(i + 1, semi);\n+                int entityValue;\n+                if (entityName.length() == 0) {\n+                    entityValue = -1;\n+                } else if (entityName.charAt(0) == '#') {\n+                    if (entityName.length() == 1) {\n+                        entityValue = -1;\n+                    } else {\n+                        char charAt1 = entityName.charAt(1);\n+                        try {\n+                            if (charAt1 == 'x' || charAt1=='X') {\n+                                entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();\n+                            } else {\n+                                entityValue = Integer.parseInt(entityName.substring(1));\n+                            }\n+                        } catch (NumberFormatException ex) {\n+                            entityValue = -1;\n+                        }\n+                    }\n+                } else {\n+                    entityValue = this.entityValue(entityName);\n+                }\n+                if (entityValue == -1) {\n+                    buf.append('&');\n+                    buf.append(entityName);\n+                    buf.append(';');\n+                } else {\n+                    buf.append((char) (entityValue));\n+                }\n+                i = semi;\n+            } else {\n+                buf.append(ch);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Unescapes the escaped entities in the <code>String</code> passed and\n+     * writes the result to the <code>Writer</code> passed.</p>\n+     * \n+     * @param writer The <code>Writer</code> to write the results to; assumed to be non-null.\n+     * @param string The <code>String</code> to write the results to; assumed to be non-null.\n+     * @throws IOException when <code>Writer</code> passed throws the exception from\n+     *                                       calls to the {@link Writer#write(int)} methods.\n+     *                                       \n+     * @see #escape(String)\n+     * @see Writer\n+     */\n+    public void unescape(Writer writer, String string) throws IOException {\n+        int len = string.length();\n+        if (len == 0) {\n+            return;\n+        }\n+        for (int i = 0; i < len; i++) {\n+            char c = string.charAt(i);\n+            if (c == '&') {\n+                int nextIdx = i+1;\n+                int semiColonIdx = string.indexOf(';', nextIdx);\n+                if (semiColonIdx == -1) {\n+                    writer.write(c);\n+                    continue;\n+                }\n+                int amphersandIdx = string.indexOf('&', i + 1);\n+                if( amphersandIdx != -1 && amphersandIdx < semiColonIdx ) {\n+                    // Then the text looks like &...&...;\n+                    writer.write(c);\n+                    continue;\n+                }\n+                String entityContent = string.substring(nextIdx, semiColonIdx);\n+                int entityValue = -1;\n+                int entityContentLen = entityContent.length();\n+                if (entityContentLen > 0) {\n+                    if (entityContent.charAt(0) == '#') { //escaped value content is an integer (decimal or hexidecimal)\n+                        if (entityContentLen > 1) {  \n+                            char isHexChar = entityContent.charAt(1);\n+                            try {\n+                                switch (isHexChar) {\n+                                    case 'X' :\n+                                    case 'x' : {\n+                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);\n+                                    }\n+                                    default : {\n+                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\n+                                    }\n+                                }\n+                            } catch (NumberFormatException e) {\n+                                // ignore the escaped value content\n+                            }\n+                        }\n+                    } else { //escaped value content is an entity name\n+                        entityValue = this.entityValue(entityContent);\n+                    }\n+                }\n+                \n+                if (entityValue == -1) {\n+                    writer.write('&');\n+                    writer.write(entityContent);\n+                    writer.write(';');\n+                } else {\n+                    writer.write(entityValue);\n+                }\n+                i = semiColonIdx; //move index up to the semi-colon                \n+            } else {\n+                writer.write(c);\n+            }\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/IllegalClassException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Thrown when an object is an instance of an unexpected type (a class or interface).\n+ * This exception supplements the standard <code>IllegalArgumentException</code>\n+ * by providing a more semantically rich description of the problem.</p>\n+ * \n+ * <p><code>IllegalClassException</code> represents the case where a method takes\n+ * in a genericly typed parameter like Object (typically because it has to due to some\n+ * other interface it implements), but this implementation only actually accepts a specific\n+ * type, for example String. This exception would be used in place of\n+ * <code>IllegalArgumentException</code>, yet it still extends it.</p>\n+ * \n+ * <pre>\n+ * public void foo(Object obj) {\n+ *   if (obj instanceof String == false) {\n+ *     throw new IllegalClassException(String.class, obj);\n+ *   }\n+ *   // do something with the string\n+ * }\n+ * </pre>\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Gary Gregory\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class IllegalClassException extends IllegalArgumentException {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 8063272569377254819L;\n+\n+    /**\n+     * <p>Instantiates with the expected type, and actual object.</p>\n+     * \n+     * @param expected  the expected type\n+     * @param actual  the actual object\n+     * @since 2.1\n+     */\n+    public IllegalClassException(Class expected, Object actual) {\n+        super(\n+            \"Expected: \"\n+                + safeGetClassName(expected)\n+                + \", actual: \"\n+                + (actual == null ? \"null\" : actual.getClass().getName()));\n+    }\n+\n+    /**\n+     * <p>Instantiates with the expected and actual types.</p>\n+     * \n+     * @param expected  the expected type\n+     * @param actual  the actual type\n+     */\n+    public IllegalClassException(Class expected, Class actual) {\n+        super(\n+            \"Expected: \"\n+                + safeGetClassName(expected)\n+                + \", actual: \"\n+                + safeGetClassName(actual));\n+    }\n+\n+    /**\n+     * <p>Instantiates with the specified message.</p>\n+     * \n+     * @param message  the exception message\n+     */\n+    public IllegalClassException(String message) {\n+        super(message);\n+    }\n+\n+    /**\n+     * <p>Returns the class name or <code>null</code> if the class is\n+     * <code>null</code>.</p>\n+     * \n+     * @param cls  a <code>Class</code>\n+     * @return the name of <code>cls</code>, or <code>null</code> if if <code>cls</code> is <code>null</code>.\n+     */\n+    private static final String safeGetClassName(Class cls) {\n+        return cls == null ? null : cls.getName();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/IncompleteArgumentException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * <p>Thrown to indicate an incomplete argument to a method.\n+ * This exception supplements the standard <code>IllegalArgumentException</code>\n+ * by providing a more semantically rich description of the problem.</p>\n+ * \n+ * <p><code>IncompleteArgumentException</code> represents the case where a method takes\n+ * in a parameter that has a number of properties, some of which have not been set.\n+ * A case might be a search requirements bean that must have three properties set\n+ * in order for the method to run, but only one is actually set.\n+ * This exception would be used in place of\n+ * <code>IllegalArgumentException</code>, yet it still extends it.</p>\n+ * \n+ * <pre>\n+ * public void foo(PersonSearcher search) {\n+ *   if (search.getSurname() == null ||\n+ *       search.getForename() == null ||\n+ *       search.getSex() == null) {\n+ *     throw new IncompleteArgumentException(\"search\");\n+ *   }\n+ *   // do something with the searcher\n+ * }\n+ * </pre>\n+ * \n+ * @author Matthew Hawthorne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class IncompleteArgumentException extends IllegalArgumentException {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 4954193403612068178L;\n+\n+    /**\n+     * <p>Instantiates with the specified description.</p>\n+     * \n+     * @param argName  a description of the incomplete argument\n+     */\n+    public IncompleteArgumentException(String argName) {\n+        super(argName + \" is incomplete.\");\n+    }\n+\n+    /**\n+     * <p>Instantiates with the specified description.</p>\n+     * \n+     * @param argName  a description of the incomplete argument\n+     * @param items  an array describing the arguments missing\n+     */\n+    public IncompleteArgumentException(String argName, String[] items) {\n+        super(\n+            argName\n+                + \" is missing the following items: \"\n+                + safeArrayToString(items));\n+    }\n+\n+    /**\n+     * <p>Converts an array to a string without throwing an exception.</p>\n+     * \n+     * @param array  an array\n+     * @return the array as a string\n+     */\n+    private static final String safeArrayToString(Object[] array) {\n+        return array == null ? null : Arrays.asList(array).toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/IntHashMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * Note: originally released under the GNU LGPL v2.1, \n+ * but rereleased by the original author under the ASF license (above).\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>A hash map that uses primitive ints for the key rather than objects.</p>\n+ *\n+ * <p>Note that this class is for internal optimization purposes only, and may\n+ * not be supported in future releases of Jakarta Commons Lang.  Utilities of\n+ * this sort may be included in future releases of Jakarta Commons Collections.</p>\n+ *\n+ * @author Justin Couch\n+ * @author Alex Chaffee (alex@apache.org)\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Revision$\n+ * @see java.util.HashMap\n+ */\n+class IntHashMap {\n+\n+    /**\n+     * The hash table data.\n+     */\n+    private transient Entry table[];\n+\n+    /**\n+     * The total number of entries in the hash table.\n+     */\n+    private transient int count;\n+\n+    /**\n+     * The table is rehashed when its size exceeds this threshold.  (The\n+     * value of this field is (int)(capacity * loadFactor).)\n+     *\n+     * @serial\n+     */\n+    private int threshold;\n+\n+    /**\n+     * The load factor for the hashtable.\n+     *\n+     * @serial\n+     */\n+    private float loadFactor;\n+\n+    /**\n+     * <p>Innerclass that acts as a datastructure to create a new entry in the\n+     * table.</p>\n+     */\n+    private static class Entry {\n+        int hash;\n+        int key;\n+        Object value;\n+        Entry next;\n+\n+        /**\n+         * <p>Create a new entry with the given values.</p>\n+         *\n+         * @param hash The code used to hash the object with\n+         * @param key The key used to enter this in the table\n+         * @param value The value for this key\n+         * @param next A reference to the next entry in the table\n+         */\n+        protected Entry(int hash, int key, Object value, Entry next) {\n+            this.hash = hash;\n+            this.key = key;\n+            this.value = value;\n+            this.next = next;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new, empty hashtable with a default capacity and load\n+     * factor, which is <code>20</code> and <code>0.75</code> respectively.</p>\n+     */\n+    public IntHashMap() {\n+        this(20, 0.75f);\n+    }\n+\n+    /**\n+     * <p>Constructs a new, empty hashtable with the specified initial capacity\n+     * and default load factor, which is <code>0.75</code>.</p>\n+     *\n+     * @param  initialCapacity the initial capacity of the hashtable.\n+     * @throws IllegalArgumentException if the initial capacity is less\n+     *   than zero.\n+     */\n+    public IntHashMap(int initialCapacity) {\n+        this(initialCapacity, 0.75f);\n+    }\n+\n+    /**\n+     * <p>Constructs a new, empty hashtable with the specified initial\n+     * capacity and the specified load factor.</p>\n+     *\n+     * @param initialCapacity the initial capacity of the hashtable.\n+     * @param loadFactor the load factor of the hashtable.\n+     * @throws IllegalArgumentException  if the initial capacity is less\n+     *             than zero, or if the load factor is nonpositive.\n+     */\n+    public IntHashMap(int initialCapacity, float loadFactor) {\n+        super();\n+        if (initialCapacity < 0) {\n+            throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity);\n+        }\n+        if (loadFactor <= 0) {\n+            throw new IllegalArgumentException(\"Illegal Load: \" + loadFactor);\n+        }\n+        if (initialCapacity == 0) {\n+            initialCapacity = 1;\n+        }\n+\n+        this.loadFactor = loadFactor;\n+        table = new Entry[initialCapacity];\n+        threshold = (int) (initialCapacity * loadFactor);\n+    }\n+\n+    /**\n+     * <p>Returns the number of keys in this hashtable.</p>\n+     *\n+     * @return  the number of keys in this hashtable.\n+     */\n+    public int size() {\n+        return count;\n+    }\n+\n+    /**\n+     * <p>Tests if this hashtable maps no keys to values.</p>\n+     *\n+     * @return  <code>true</code> if this hashtable maps no keys to values;\n+     *          <code>false</code> otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return count == 0;\n+    }\n+\n+    /**\n+     * <p>Tests if some key maps into the specified value in this hashtable.\n+     * This operation is more expensive than the <code>containsKey</code>\n+     * method.</p>\n+     *\n+     * <p>Note that this method is identical in functionality to containsValue,\n+     * (which is part of the Map interface in the collections framework).</p>\n+     *\n+     * @param      value   a value to search for.\n+     * @return     <code>true</code> if and only if some key maps to the\n+     *             <code>value</code> argument in this hashtable as\n+     *             determined by the <tt>equals</tt> method;\n+     *             <code>false</code> otherwise.\n+     * @throws  NullPointerException  if the value is <code>null</code>.\n+     * @see        #containsKey(int)\n+     * @see        #containsValue(Object)\n+     * @see        java.util.Map\n+     */\n+    public boolean contains(Object value) {\n+        if (value == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        Entry tab[] = table;\n+        for (int i = tab.length; i-- > 0;) {\n+            for (Entry e = tab[i]; e != null; e = e.next) {\n+                if (e.value.equals(value)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if this HashMap maps one or more keys\n+     * to this value.</p>\n+     *\n+     * <p>Note that this method is identical in functionality to contains\n+     * (which predates the Map interface).</p>\n+     *\n+     * @param value value whose presence in this HashMap is to be tested.\n+     * @return boolean <code>true</code> if the value is contained\n+     * @see    java.util.Map\n+     * @since JDK1.2\n+     */\n+    public boolean containsValue(Object value) {\n+        return contains(value);\n+    }\n+\n+    /**\n+     * <p>Tests if the specified object is a key in this hashtable.</p>\n+     *\n+     * @param  key  possible key.\n+     * @return <code>true</code> if and only if the specified object is a\n+     *    key in this hashtable, as determined by the <tt>equals</tt>\n+     *    method; <code>false</code> otherwise.\n+     * @see #contains(Object)\n+     */\n+    public boolean containsKey(int key) {\n+        Entry tab[] = table;\n+        int hash = key;\n+        int index = (hash & 0x7FFFFFFF) % tab.length;\n+        for (Entry e = tab[index]; e != null; e = e.next) {\n+            if (e.hash == hash) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Returns the value to which the specified key is mapped in this map.</p>\n+     *\n+     * @param   key   a key in the hashtable.\n+     * @return  the value to which the key is mapped in this hashtable;\n+     *          <code>null</code> if the key is not mapped to any value in\n+     *          this hashtable.\n+     * @see     #put(int, Object)\n+     */\n+    public Object get(int key) {\n+        Entry tab[] = table;\n+        int hash = key;\n+        int index = (hash & 0x7FFFFFFF) % tab.length;\n+        for (Entry e = tab[index]; e != null; e = e.next) {\n+            if (e.hash == hash) {\n+                return e.value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Increases the capacity of and internally reorganizes this\n+     * hashtable, in order to accommodate and access its entries more\n+     * efficiently.</p>\n+     *\n+     * <p>This method is called automatically when the number of keys\n+     * in the hashtable exceeds this hashtable's capacity and load\n+     * factor.</p>\n+     */\n+    protected void rehash() {\n+        int oldCapacity = table.length;\n+        Entry oldMap[] = table;\n+\n+        int newCapacity = oldCapacity * 2 + 1;\n+        Entry newMap[] = new Entry[newCapacity];\n+\n+        threshold = (int) (newCapacity * loadFactor);\n+        table = newMap;\n+\n+        for (int i = oldCapacity; i-- > 0;) {\n+            for (Entry old = oldMap[i]; old != null;) {\n+                Entry e = old;\n+                old = old.next;\n+\n+                int index = (e.hash & 0x7FFFFFFF) % newCapacity;\n+                e.next = newMap[index];\n+                newMap[index] = e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Maps the specified <code>key</code> to the specified\n+     * <code>value</code> in this hashtable. The key cannot be\n+     * <code>null</code>. </p>\n+     *\n+     * <p>The value can be retrieved by calling the <code>get</code> method\n+     * with a key that is equal to the original key.</p>\n+     *\n+     * @param key     the hashtable key.\n+     * @param value   the value.\n+     * @return the previous value of the specified key in this hashtable,\n+     *         or <code>null</code> if it did not have one.\n+     * @throws  NullPointerException  if the key is <code>null</code>.\n+     * @see     #get(int)\n+     */\n+    public Object put(int key, Object value) {\n+        // Makes sure the key is not already in the hashtable.\n+        Entry tab[] = table;\n+        int hash = key;\n+        int index = (hash & 0x7FFFFFFF) % tab.length;\n+        for (Entry e = tab[index]; e != null; e = e.next) {\n+            if (e.hash == hash) {\n+                Object old = e.value;\n+                e.value = value;\n+                return old;\n+            }\n+        }\n+\n+        if (count >= threshold) {\n+            // Rehash the table if the threshold is exceeded\n+            rehash();\n+\n+            tab = table;\n+            index = (hash & 0x7FFFFFFF) % tab.length;\n+        }\n+\n+        // Creates the new entry.\n+        Entry e = new Entry(hash, key, value, tab[index]);\n+        tab[index] = e;\n+        count++;\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Removes the key (and its corresponding value) from this\n+     * hashtable.</p>\n+     *\n+     * <p>This method does nothing if the key is not present in the\n+     * hashtable.</p>\n+     *\n+     * @param   key   the key that needs to be removed.\n+     * @return  the value to which the key had been mapped in this hashtable,\n+     *          or <code>null</code> if the key did not have a mapping.\n+     */\n+    public Object remove(int key) {\n+        Entry tab[] = table;\n+        int hash = key;\n+        int index = (hash & 0x7FFFFFFF) % tab.length;\n+        for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next) {\n+            if (e.hash == hash) {\n+                if (prev != null) {\n+                    prev.next = e.next;\n+                } else {\n+                    tab[index] = e.next;\n+                }\n+                count--;\n+                Object oldValue = e.value;\n+                e.value = null;\n+                return oldValue;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Clears this hashtable so that it contains no keys.</p>\n+     */\n+    public synchronized void clear() {\n+        Entry tab[] = table;\n+        for (int index = tab.length; --index >= 0;) {\n+            tab[index] = null;\n+        }\n+        count = 0;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/LocaleUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>Operations to assist when working with a {@link Locale}.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class LocaleUtils {\n+\n+    /** Unmodifiable list of available locales. */\n+    private static final List cAvailableLocaleList;\n+    /** Unmodifiable set of available locales. */\n+    private static Set cAvailableLocaleSet;\n+    /** Unmodifiable map of language locales by country. */\n+    private static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n+    /** Unmodifiable map of country locales by language. */\n+    private static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\n+    static {\n+        List list = Arrays.asList(Locale.getAvailableLocales());\n+        cAvailableLocaleList = Collections.unmodifiableList(list);\n+    }\n+\n+    /**\n+     * <p><code>LocaleUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>LocaleUtils.toLocale(\"en_GB\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public LocaleUtils() {\n+      super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a Locale.</p>\n+     *\n+     * <p>This method takes the string format of a locale and creates the\n+     * locale object from it.</p>\n+     *\n+     * <pre>\n+     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n+     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n+     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n+     * </pre>\n+     *\n+     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n+     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n+     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n+     *\n+     * <p>This method validates the input strictly.\n+     * The language code must be lowercase.\n+     * The country code must be uppercase.\n+     * The separator must be an underscore.\n+     * The length must be correct.\n+     * </p>\n+     *\n+     * @param str  the locale String to convert, null returns null\n+     * @return a Locale, null if null input\n+     * @throws IllegalArgumentException if the string is an invalid format\n+     */\n+    public static Locale toLocale(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len != 2 && len != 5 && len < 7) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        char ch0 = str.charAt(0);\n+        char ch1 = str.charAt(1);\n+        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len == 2) {\n+            return new Locale(str, \"\");\n+        } else {\n+            if (str.charAt(2) != '_') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            char ch3 = str.charAt(3);\n+            char ch4 = str.charAt(4);\n+            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (len == 5) {\n+                return new Locale(str.substring(0, 2), str.substring(3, 5));\n+            } else {\n+                if (str.charAt(5) != '_') {\n+                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+                }\n+                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of locales to search through when performing\n+     * a locale search.</p>\n+     *\n+     * <pre>\n+     * localeLookupList(Locale(\"fr\",\"CA\",\"xxx\"))\n+     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\")]\n+     * </pre>\n+     *\n+     * @param locale  the locale to start from\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n+     */\n+    public static List localeLookupList(Locale locale) {\n+        return localeLookupList(locale, locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of locales to search through when performing\n+     * a locale search.</p>\n+     *\n+     * <pre>\n+     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n+     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\"]\n+     * </pre>\n+     *\n+     * <p>The result list begins with the most specific locale, then the\n+     * next more general and so on, finishing with the default locale.\n+     * The list will never contain the same locale twice.</p>\n+     *\n+     * @param locale  the locale to start from, null returns empty list\n+     * @param defaultLocale  the default locale to use if no other is found\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n+     */\n+    public static List localeLookupList(Locale locale, Locale defaultLocale) {\n+        List list = new ArrayList(4);\n+        if (locale != null) {\n+            list.add(locale);\n+            if (locale.getVariant().length() > 0) {\n+                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n+            }\n+            if (locale.getCountry().length() > 0) {\n+                list.add(new Locale(locale.getLanguage(), \"\"));\n+            }\n+            if (list.contains(defaultLocale) == false) {\n+                list.add(defaultLocale);\n+            }\n+        }\n+        return Collections.unmodifiableList(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable list of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable list of available locales\n+     */\n+    public static List availableLocaleList() {\n+        return cAvailableLocaleList;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable set of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable set of available locales\n+     */\n+    public static Set availableLocaleSet() {\n+        Set set = cAvailableLocaleSet;\n+        if (set == null) {\n+            set = new HashSet(availableLocaleList());\n+            set = Collections.unmodifiableSet(set);\n+            cAvailableLocaleSet = set;\n+        }\n+        return set;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the locale specified is in the list of available locales.</p>\n+     *\n+     * @param locale the Locale object to check if it is available\n+     * @return true if the locale is a known locale\n+     */\n+    public static boolean isAvailableLocale(Locale locale) {\n+        return cAvailableLocaleSet.contains(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of languages supported for a given country.</p>\n+     *\n+     * <p>This method takes a country code and searches to find the\n+     * languages available for that country. Variant locales are removed.</p>\n+     *\n+     * @param countryCode  the 2 letter country code, null returns empty\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List languagesByCountry(String countryCode) {\n+        List langs = (List) cLanguagesByCountry.get(countryCode);  //syncd\n+        if (langs == null) {\n+            if (countryCode != null) {\n+                langs = new ArrayList();\n+                List locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = (Locale) locales.get(i);\n+                    if (countryCode.equals(locale.getCountry()) &&\n+                            locale.getVariant().length() == 0) {\n+                        langs.add(locale);\n+                    }\n+                }\n+                langs = Collections.unmodifiableList(langs);\n+            } else {\n+                langs = Collections.EMPTY_LIST;\n+            }\n+            cLanguagesByCountry.put(countryCode, langs);  //syncd\n+        }\n+        return langs;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of countries supported for a given language.</p>\n+     * \n+     * <p>This method takes a language code and searches to find the\n+     * countries available for that language. Variant locales are removed.</p>\n+     *\n+     * @param languageCode  the 2 letter language code, null returns empty\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List countriesByLanguage(String languageCode) {\n+        List countries = (List) cCountriesByLanguage.get(languageCode);  //syncd\n+        if (countries == null) {\n+            if (languageCode != null) {\n+                countries = new ArrayList();\n+                List locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = (Locale) locales.get(i);\n+                    if (languageCode.equals(locale.getLanguage()) &&\n+                            locale.getCountry().length() != 0 &&\n+                            locale.getVariant().length() == 0) {\n+                        countries.add(locale);\n+                    }\n+                }\n+                countries = Collections.unmodifiableList(countries);\n+            } else {\n+                countries = Collections.EMPTY_LIST;\n+            }\n+            cCountriesByLanguage.put(languageCode, countries);  //syncd\n+        }\n+        return countries;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/NotImplementedException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+import org.apache.commons.lang.exception.Nestable;\n+import org.apache.commons.lang.exception.NestableDelegate;\n+\n+/**\n+ * <p>Thrown to indicate that a block of code has not been implemented.\n+ * This exception supplements <code>UnsupportedOperationException</code>\n+ * by providing a more semantically rich description of the problem.</p>\n+ * \n+ * <p><code>NotImplementedException</code> represents the case where the\n+ * author has yet to implement the logic at this point in the program.\n+ * This can act as an exception based TODO tag.\n+ * Because this logic might be within a catch block, this exception\n+ * suports exception chaining.</p>\n+ * \n+ * <pre>\n+ * public void foo() {\n+ *   try {\n+ *     // do something that throws an Exception\n+ *   } catch (Exception ex) {\n+ *     // don't know what to do here yet\n+ *     throw new NotImplementedException(\"TODO\", ex);\n+ *   }\n+ * }\n+ * </pre>\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class NotImplementedException\n+        extends UnsupportedOperationException implements Nestable {\n+\n+    private static final String DEFAULT_MESSAGE = \"Code is not implemented\";\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -6894122266938754088L;\n+\n+    /**\n+     * The exception helper to delegate nested exception handling to.\n+     */\n+    private NestableDelegate delegate = new NestableDelegate(this);\n+\n+    /**\n+     * Holds the reference to the exception or error that caused\n+     * this exception to be thrown.\n+     */\n+    private Throwable cause;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>NotImplementedException</code> with default message.\n+     * \n+     * @since 2.1\n+     */\n+    public NotImplementedException() {\n+        super(DEFAULT_MESSAGE);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NotImplementedException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public NotImplementedException(String msg) {\n+        super(msg == null ? DEFAULT_MESSAGE : msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NotImplementedException</code> with specified\n+     * nested <code>Throwable</code> and default message.\n+     *\n+     * @param cause  the exception that caused this exception to be thrown\n+     * @since 2.1\n+     */\n+    public NotImplementedException(Throwable cause) {\n+        super(DEFAULT_MESSAGE);\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * Constructs a new <code>NotImplementedException</code> with specified\n+     * detail message and nested <code>Throwable</code>.\n+     *\n+     * @param msg  the error message\n+     * @param cause  the exception that caused this exception to be thrown\n+     * @since 2.1\n+     */\n+    public NotImplementedException(String msg, Throwable cause) {\n+        super(msg == null ? DEFAULT_MESSAGE : msg);\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * Constructs a new <code>NotImplementedException</code> referencing the specified class.\n+     * \n+     * @param clazz\n+     *            the <code>Class</code> that has not implemented the method\n+     */\n+    public NotImplementedException(Class clazz) {\n+        super(clazz == null ? DEFAULT_MESSAGE : DEFAULT_MESSAGE + \" in \" + clazz);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Gets the root cause of this exception.\n+     * @return the root cause of this exception.\n+     * \n+     * @since 2.1\n+     */\n+    public Throwable getCause() {\n+        return cause;\n+    }\n+\n+    /**\n+     * Gets the combined the error message of this and any nested errors.\n+     *\n+     * @return the error message\n+     * @since 2.1\n+     */\n+    public String getMessage() {\n+        if (super.getMessage() != null) {\n+            return super.getMessage();\n+        } else if (cause != null) {\n+            return cause.toString();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Returns the error message of the <code>Throwable</code> in the chain\n+     * of <code>Throwable</code>s at the specified index, numbered from 0.\n+     *\n+     * @param index  the index of the <code>Throwable</code> in the chain\n+     * @return the error message, or null if the <code>Throwable</code> at the\n+     *  specified index in the chain does not contain a message\n+     * @throws IndexOutOfBoundsException if the <code>index</code> argument is\n+     *  negative or not less than the count of <code>Throwable</code>s in the chain\n+     * @since 2.1\n+     */\n+    public String getMessage(int index) {\n+        if (index == 0) {\n+            return super.getMessage();\n+        }\n+        return delegate.getMessage(index);\n+    }\n+\n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code> objects.\n+     * Each throwable returns a message, a null string is included in the array if\n+     * there is no message for a particular <code>Throwable</code>.\n+     *\n+     * @return the error messages\n+     * @since 2.1\n+     */\n+    public String[] getMessages() {\n+        return delegate.getMessages();\n+    }\n+\n+    /**\n+     * Returns the <code>Throwable</code> in the chain by index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the <code>Throwable</code>\n+     * @throws IndexOutOfBoundsException if the <code>index</code> argument is\n+     *  negative or not less than the count of <code>Throwable</code>s in the chain\n+     * @since 2.1\n+     */\n+    public Throwable getThrowable(int index) {\n+        return delegate.getThrowable(index);\n+    }\n+\n+    /**\n+     * Returns the number of nested <code>Throwable</code>s represented by\n+     * this <code>Nestable</code>, including this <code>Nestable</code>.\n+     *\n+     * @return the throwable count\n+     * @since 2.1\n+     */\n+    public int getThrowableCount() {\n+        return delegate.getThrowableCount();\n+    }\n+\n+    /**\n+     * Returns this <code>Nestable</code> and any nested <code>Throwable</code>s\n+     * in an array of <code>Throwable</code>s, one element for each\n+     * <code>Throwable</code>.\n+     *\n+     * @return the <code>Throwable</code>s\n+     * @since 2.1\n+     */\n+    public Throwable[] getThrowables() {\n+        return delegate.getThrowables();\n+    }\n+\n+    /**\n+     * Returns the index of the first occurrence of the specified type.\n+     * If there is no match, <code>-1</code> is returned.\n+     *\n+     * @param type  the type to search for\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     *  the type is not found\n+     * @since 2.1\n+     */\n+    public int indexOfThrowable(Class type) {\n+        return delegate.indexOfThrowable(type, 0);\n+    }\n+\n+    /**\n+     * Returns the index of the first occurrence of the specified type starting\n+     * from the specified index. If there is no match, <code>-1</code> is returned.\n+     *\n+     * @param type  the type to search for\n+     * @param fromIndex  the index of the starting position in the chain to be searched\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     *  the type is not found\n+     * @throws IndexOutOfBoundsException if the <code>fromIndex</code> argument\n+     *  is negative or not less than the count of <code>Throwable</code>s in the chain\n+     * @since 2.1\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex) {\n+        return delegate.indexOfThrowable(type, fromIndex);\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception.\n+     * Includes information from the exception, if any, which caused this exception.\n+     * \n+     * @since 2.1\n+     */\n+    public void printStackTrace() {\n+        delegate.printStackTrace();\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified stream.\n+     * Includes information from the exception, if any, which caused this exception.\n+     *\n+     * @param out  the stream to write to\n+     * @since 2.1\n+     */\n+    public void printStackTrace(PrintStream out) {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified writer.\n+     * Includes information from the exception, if any, which caused this exception.\n+     *\n+     * @param out  the writer to write to\n+     * @since 2.1\n+     */\n+    public void printStackTrace(PrintWriter out) {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * Prints the stack trace for this exception only (root cause not included)\n+     * using the specified writer.\n+     * \n+     * @param out  the writer to write to\n+     * @since 2.1\n+     */\n+    public final void printPartialStackTrace(PrintWriter out) {\n+        super.printStackTrace(out);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/NullArgumentException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Thrown to indicate that an argument was <code>null</code> and should\n+ * not have been.\n+ * This exception supplements the standard <code>IllegalArgumentException</code>\n+ * by providing a more semantically rich description of the problem.</p>\n+ * \n+ * <p><code>NullArgumentException</code> represents the case where a method takes\n+ * in a parameter that must not be <code>null</code>.\n+ * Some coding standards would use <code>NullPointerException</code> for this case,\n+ * others will use <code>IllegalArgumentException</code>.\n+ * Thus this exception would be used in place of\n+ * <code>IllegalArgumentException</code>, yet it still extends it.</p>\n+ * \n+ * <pre>\n+ * public void foo(String str) {\n+ *   if (str == null) {\n+ *     throw new NullArgumentException(\"str\");\n+ *   }\n+ *   // do something with the string\n+ * }\n+ * </pre>\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class NullArgumentException extends IllegalArgumentException {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1174360235354917591L;\n+\n+    /**\n+     * <p>Instantiates with the given argument name.</p>\n+     *\n+     * @param argName  the name of the argument that was <code>null</code>.\n+     */\n+    public NullArgumentException(String argName) {\n+        super((argName == null ? \"Argument\" : argName) + \" must not be null.\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/NumberRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Represents a range of {@link Number} objects.</p>\n+ * \n+ * <p>This class uses <code>double</code> comparisons. This means that it\n+ * is unsuitable for dealing with large <code>Long</code>, <code>BigDecimal</code>\n+ * or <code>BigInteger</code> numbers.</p>\n+ *\n+ * @author <a href=\"mailto:chrise@esha.com\">Christopher Elkins</a>\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @version $Revision$ $Date$\n+ * \n+ * @deprecated Use one of the Range classes in org.apache.commons.lang.math.\n+ *             Class will be removed in Commons Lang 3.0.\n+ * \n+ */\n+public final class NumberRange {\n+\n+    /* The minimum number in this range. */\n+    private final Number min;\n+\n+    /* The maximum number in this range. */\n+    private final Number max;\n+\n+\n+    /**\n+     * <p>Constructs a new <code>NumberRange</code> using\n+     * <code>number</code> as both the minimum and maximum in\n+     * this range.</p>\n+     *\n+     * @param num the number to use for this range\n+     * @throws NullPointerException if the number is <code>null</code>\n+     */\n+    public NumberRange(Number num) {\n+        if (num == null) {\n+            throw new NullPointerException(\"The number must not be null\");\n+        }\n+\n+        this.min = num;\n+        this.max = num;\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>NumberRange</code> with the specified\n+     * minimum and maximum numbers.</p>\n+     * \n+     * <p><em>If the maximum is less than the minimum, the range will be constructed\n+     * from the minimum value to the minimum value, not what you would expect!.</em></p>\n+     *\n+     * @param min the minimum number in this range\n+     * @param max the maximum number in this range\n+     * @throws NullPointerException if either the minimum or maximum number is\n+     *  <code>null</code>\n+     */\n+    public NumberRange(Number min, Number max) {\n+        if (min == null) {\n+            throw new NullPointerException(\"The minimum value must not be null\");\n+        } else if (max == null) {\n+            throw new NullPointerException(\"The maximum value must not be null\");\n+        }\n+\n+        if (max.doubleValue() < min.doubleValue()) {\n+            this.min = this.max = min;\n+        } else {\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns the minimum number in this range.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public Number getMinimum() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum number in this range.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public Number getMaximum() {\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>number</code> occurs within\n+     * this range using <code>double</code> comparison.</p>\n+     *\n+     * @param number the number to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range; otherwise, <code>false</code>\n+     */\n+    public boolean includesNumber(Number number) {\n+        if (number == null) {\n+            return false;\n+        } else {\n+            return !(min.doubleValue() > number.doubleValue()) &&\n+                !(max.doubleValue() < number.doubleValue());\n+        }\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range occurs entirely within this\n+     * range using <code>double</code> comparison.</p>\n+     *\n+     * @param range the range to test\n+     * @return <code>true</code> if the specified range occurs entirely within\n+     *  this range; otherwise, <code>false</code>\n+     */\n+    public boolean includesRange(NumberRange range) {\n+        if (range == null) {\n+            return false;\n+        } else {\n+            return includesNumber(range.min) && includesNumber(range.max);\n+        }\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range overlaps with this range\n+     * using <code>double</code> comparison.</p>\n+     *\n+     * @param range the range to test\n+     * @return <code>true</code> if the specified range overlaps with this\n+     *  range; otherwise, <code>false</code>\n+     */\n+    public boolean overlaps(NumberRange range) {\n+        if (range == null) {\n+            return false;\n+        } else {\n+            return range.includesNumber(min) || range.includesNumber(max) || \n+                includesRange(range);\n+        }\n+    }\n+\n+    /**\n+     * <p>Indicates whether some other <code>Object</code> is\n+     * &quot;equal&quot; to this one.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is the same as the obj\n+     *  argument; <code>false</code> otherwise\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        } else if (!(obj instanceof NumberRange)) {\n+            return false;\n+        } else {\n+            NumberRange range = (NumberRange)obj;\n+            return min.equals(range.min) && max.equals(range.max);\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns a hash code value for this object.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        int result = 17;\n+        result = 37 * result + min.hashCode();\n+        result = 37 * result + max.hashCode();\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Returns the string representation of this range.</p>\n+     *\n+     * <p>This string is the string representation of the minimum and\n+     * maximum numbers in the range, separated by a hyphen. If a number\n+     * is negative, then it is enclosed in parentheses.</p>\n+     *\n+     * @return the string representation of this range\n+     */\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer();\n+\n+        if (min.doubleValue() < 0) {\n+            sb.append('(')\n+                .append(min)\n+                .append(')');\n+        } else {\n+            sb.append(min);\n+        }\n+\n+        sb.append('-');\n+\n+        if (max.doubleValue() < 0) {\n+            sb.append('(')\n+                .append(max)\n+                .append(')');\n+        } else {\n+            sb.append(max);\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/NumberUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+/**\n+ * <p>Provides extra functionality for Java Number classes.</p>\n+ *\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Eric Pugh\n+ * @author Phil Steitz\n+ * @since 1.0\n+ * @version $Id$\n+ * \n+ * @deprecated Moved to org.apache.commons.lang.math.\n+ *             Class will be removed in Commons Lang 3.0.\n+ */\n+public final class NumberUtils {\n+    // DEPRECATED CLASS !!!\n+    \n+    /**\n+     * <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>NumberUtils.stringToInt(\"6\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public NumberUtils() {\n+      super();\n+    }\n+\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     * \n+     * @param str  the string to convert\n+     * @return the int represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     */\n+    public static int stringToInt(String str) {\n+        return stringToInt(str, 0);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning a\n+     * default value if the conversion fails.</p>\n+     * \n+     * @param str  the string to convert\n+     * @param defaultValue  the default value\n+     * @return the int represented by the string, or the default if conversion fails\n+     */\n+    public static int stringToInt(String str, int defaultValue) {\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    //--------------------------------------------------------------------\n+    \n+    // must handle Long, Float, Integer, Float, Short,\n+    //                  BigDecimal, BigInteger and Byte\n+    // useful methods:\n+    // Byte.decode(String)\n+    // Byte.valueOf(String,int radix)\n+    // Byte.valueOf(String)\n+    // Double.valueOf(String)\n+    // Float.valueOf(String)\n+    // new Float(String)\n+    // Integer.valueOf(String,int radix)\n+    // Integer.valueOf(String)\n+    // Integer.decode(String)\n+    // Integer.getInteger(String)\n+    // Integer.getInteger(String,int val)\n+    // Integer.getInteger(String,Integer val)\n+    // new Integer(String)\n+    // new Double(String)\n+    // new Byte(String)\n+    // new Long(String)\n+    // Long.getLong(String)\n+    // Long.getLong(String,int)\n+    // Long.getLong(String,Integer)\n+    // Long.valueOf(String,int)\n+    // Long.valueOf(String)\n+    // new Short(String)\n+    // Short.decode(String)\n+    // Short.valueOf(String,int)\n+    // Short.valueOf(String)\n+    // new BigDecimal(String)\n+    // new BigInteger(String)\n+    // new BigInteger(String,int radix)\n+    // Possible inputs:\n+    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n+    // plus minus everything. Prolly more. A lot are not separable.\n+\n+    /**\n+     * <p>Turns a string value into a java.lang.Number.</p>\n+     *\n+     * <p>First, the value is examined for a type qualifier on the end\n+     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n+     * trying to create successively larger types from the type specified\n+     * until one is found that can hold the value.</p>\n+     *\n+     * <p>If a type specifier is not found, it will check for a decimal point\n+     * and then try successively larger types from <code>Integer</code> to\n+     * <code>BigInteger</code> and from <code>Float</code> to\n+     * <code>BigDecimal</code>.</p>\n+     *\n+     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n+     * will be interpreted as a hexadecimal integer.  Values with leading\n+     * <code>0</code>'s will not be interpreted as octal.</p>\n+     *\n+     * @param val String containing a number\n+     * @return Number created from the string\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Number createNumber(String val) throws NumberFormatException {\n+        if (val == null) {\n+            return null;\n+        }\n+        if (val.length() == 0) {\n+            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+        }\n+        if (val.startsWith(\"--\")) {\n+            // this is protection for poorness in java.lang.BigDecimal.\n+            // it accepts this as a legal value, but it does not appear \n+            // to be in specification of class. OS X Java parses it to \n+            // a wrong value.\n+            return null;\n+        }\n+        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n+            return createInteger(val);\n+        }   \n+        char lastChar = val.charAt(val.length() - 1);\n+        String mant;\n+        String dec;\n+        String exp;\n+        int decPos = val.indexOf('.');\n+        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n+\n+        if (decPos > -1) {\n+\n+            if (expPos > -1) {\n+                if (expPos < decPos) {\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                }\n+                dec = val.substring(decPos + 1, expPos);\n+            } else {\n+                dec = val.substring(decPos + 1);\n+            }\n+            mant = val.substring(0, decPos);\n+        } else {\n+            if (expPos > -1) {\n+                mant = val.substring(0, expPos);\n+            } else {\n+                mant = val;\n+            }\n+            dec = null;\n+        }\n+        if (!Character.isDigit(lastChar)) {\n+            if (expPos > -1 && expPos < val.length() - 1) {\n+                exp = val.substring(expPos + 1, val.length() - 1);\n+            } else {\n+                exp = null;\n+            }\n+            //Requesting a specific type..\n+            String numeric = val.substring(0, val.length() - 1);\n+            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+            switch (lastChar) {\n+                case 'l' :\n+                case 'L' :\n+                    if (dec == null\n+                        && exp == null\n+                        && isDigits(numeric.substring(1))\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        try {\n+                            return createLong(numeric);\n+                        } catch (NumberFormatException nfe) {\n+                            //Too big for a long\n+                        }\n+                        return createBigInteger(numeric);\n+\n+                    }\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                case 'f' :\n+                case 'F' :\n+                    try {\n+                        Float f = NumberUtils.createFloat(numeric);\n+                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                            //If it's too big for a float or the float value = 0 and the string\n+                            //has non-zeros in it, then float does not have the precision we want\n+                            return f;\n+                        }\n+\n+                    } catch (NumberFormatException e) {\n+                        // ignore the bad number\n+                    }\n+                    //Fall through\n+                case 'd' :\n+                case 'D' :\n+                    try {\n+                        Double d = NumberUtils.createDouble(numeric);\n+                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n+                            return d;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // empty catch\n+                    }\n+                    try {\n+                        return createBigDecimal(numeric);\n+                    } catch (NumberFormatException e) {\n+                        // empty catch\n+                    }\n+                    //Fall through\n+                default :\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+\n+            }\n+        } else {\n+            //User doesn't have a preference on the return type, so let's start\n+            //small and go from there...\n+            if (expPos > -1 && expPos < val.length() - 1) {\n+                exp = val.substring(expPos + 1, val.length());\n+            } else {\n+                exp = null;\n+            }\n+            if (dec == null && exp == null) {\n+                //Must be an int,long,bigint\n+                try {\n+                    return createInteger(val);\n+                } catch (NumberFormatException nfe) {\n+                    // empty catch\n+                }\n+                try {\n+                    return createLong(val);\n+                } catch (NumberFormatException nfe) {\n+                    // empty catch\n+                }\n+                return createBigInteger(val);\n+\n+            } else {\n+                //Must be a float,double,BigDec\n+                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+                try {\n+                    Float f = createFloat(val);\n+                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                        return f;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // empty catch\n+                }\n+                try {\n+                    Double d = createDouble(val);\n+                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // empty catch\n+                }\n+\n+                return createBigDecimal(val);\n+\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>\n+     *\n+     * <p>Returns <code>true</code> if s is <code>null</code>.</p>\n+     * \n+     * @param s the String to check\n+     * @return if it is all zeros or <code>null</code>\n+     */\n+    private static boolean isAllZeros(String s) {\n+        if (s == null) {\n+            return true;\n+        }\n+        for (int i = s.length() - 1; i >= 0; i--) {\n+            if (s.charAt(i) != '0') {\n+                return false;\n+            }\n+        }\n+        return s.length() > 0;\n+    }\n+\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Float</code>.</p>\n+     * \n+     * @param val  a <code>String</code> to convert\n+     * @return converted <code>Float</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Float createFloat(String val) {\n+        return Float.valueOf(val);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Double</code>.</p>\n+     * \n+     * @param val  a <code>String</code> to convert\n+     * @return converted <code>Double</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Double createDouble(String val) {\n+        return Double.valueOf(val);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n+     * hex and octal notations.</p>\n+     * \n+     * @param val  a <code>String</code> to convert\n+     * @return converted <code>Integer</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Integer createInteger(String val) {\n+        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n+        return Integer.decode(val);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Long</code>.</p>\n+     * \n+     * @param val  a <code>String</code> to convert\n+     * @return converted <code>Long</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Long createLong(String val) {\n+        return Long.valueOf(val);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>BigInteger</code>.</p>\n+     * \n+     * @param val  a <code>String</code> to convert\n+     * @return converted <code>BigInteger</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigInteger createBigInteger(String val) {\n+        BigInteger bi = new BigInteger(val);\n+        return bi;\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n+     * \n+     * @param val  a <code>String</code> to convert\n+     * @return converted <code>BigDecimal</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigDecimal createBigDecimal(String val) {\n+        BigDecimal bd = new BigDecimal(val);\n+        return bd;\n+    }\n+\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the minimum of three <code>long</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static long minimum(long a, long b, long c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>int</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static int minimum(int a, int b, int c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>long</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static long maximum(long a, long b, long c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>int</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static int maximum(int a, int b, int c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Compares two <code>doubles</code> for order.</p>\n+     *\n+     * <p>This method is more comprehensive than the standard Java greater\n+     * than, less than and equals operators.</p>\n+     * <ul>\n+     *  <li>It returns <code>-1</code> if the first value is less than the second.\n+     *  <li>It returns <code>+1</code> if the first value is greater than the second.\n+     *  <li>It returns <code>0</code> if the values are equal.\n+     * </ul>\n+     *\n+     * <p>\n+     * The ordering is as follows, largest to smallest:\n+     * <ul>\n+     *  <li>NaN\n+     *  <li>Positive infinity\n+     *  <li>Maximum double\n+     *  <li>Normal positive numbers\n+     *  <li>+0.0\n+     *  <li>-0.0\n+     *  <li>Normal negative numbers\n+     *  <li>Minimum double (-Double.MAX_VALUE)\n+     *  <li>Negative infinity\n+     * </ul>\n+     * </p>\n+     *\n+     * <p>Comparing <code>NaN</code> with <code>NaN</code> will\n+     * return <code>0</code>.</p>\n+     * \n+     * @param lhs  the first <code>double</code>\n+     * @param rhs  the second <code>double</code>\n+     * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,\n+     *  <code>0</code> if equal to rhs\n+     */\n+    public static int compare(double lhs, double rhs) {\n+        if (lhs < rhs) {\n+            return -1;\n+        }\n+        if (lhs > rhs) {\n+            return +1;\n+        }\n+        // Need to compare bits to handle 0.0 == -0.0 being true\n+        // compare should put -0.0 < +0.0\n+        // Two NaNs are also == for compare purposes\n+        // where NaN == NaN is false\n+        long lhsBits = Double.doubleToLongBits(lhs);\n+        long rhsBits = Double.doubleToLongBits(rhs);\n+        if (lhsBits == rhsBits) {\n+            return 0;\n+        }\n+        // Something exotic! A comparison to NaN or 0.0 vs -0.0\n+        // Fortunately NaN's long is > than everything else\n+        // Also negzeros bits < poszero\n+        // NAN: 9221120237041090560\n+        // MAX: 9218868437227405311\n+        // NEGZERO: -9223372036854775808\n+        if (lhsBits < rhsBits) {\n+            return -1;\n+        } else {\n+            return +1;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Compares two floats for order.</p>\n+     *\n+     * <p>This method is more comprehensive than the standard Java greater than,\n+     * less than and equals operators.</p>\n+     * <ul>\n+     *  <li>It returns <code>-1</code> if the first value is less than the second.\n+     *  <li>It returns <code>+1</code> if the first value is greater than the second.\n+     *  <li>It returns <code>0</code> if the values are equal.\n+     * </ul>\n+     *\n+     * <p> The ordering is as follows, largest to smallest:\n+     * <ul>\n+     * <li>NaN\n+     * <li>Positive infinity\n+     * <li>Maximum float\n+     * <li>Normal positive numbers\n+     * <li>+0.0\n+     * <li>-0.0\n+     * <li>Normal negative numbers\n+     * <li>Minimum float (-Float.MAX_VALUE)\n+     * <li>Negative infinity\n+     * </ul>\n+     *\n+     * <p>Comparing <code>NaN</code> with <code>NaN</code> will return\n+     * <code>0</code>.</p>\n+     * \n+     * @param lhs  the first <code>float</code>\n+     * @param rhs  the second <code>float</code>\n+     * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,\n+     *  <code>0</code> if equal to rhs\n+     */\n+    public static int compare(float lhs, float rhs) {\n+        if (lhs < rhs) {\n+            return -1;\n+        }\n+        if (lhs > rhs) {\n+            return +1;\n+        }\n+        //Need to compare bits to handle 0.0 == -0.0 being true\n+        // compare should put -0.0 < +0.0\n+        // Two NaNs are also == for compare purposes\n+        // where NaN == NaN is false\n+        int lhsBits = Float.floatToIntBits(lhs);\n+        int rhsBits = Float.floatToIntBits(rhs);\n+        if (lhsBits == rhsBits) {\n+            return 0;\n+        }\n+        //Something exotic! A comparison to NaN or 0.0 vs -0.0\n+        //Fortunately NaN's int is > than everything else\n+        //Also negzeros bits < poszero\n+        //NAN: 2143289344\n+        //MAX: 2139095039\n+        //NEGZERO: -2147483648\n+        if (lhsBits < rhsBits) {\n+            return -1;\n+        } else {\n+            return +1;\n+        }\n+    }\n+    \n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Checks whether the <code>String</code> contains only\n+     * digit characters.</p>\n+     *\n+     * <p><code>Null</code> and empty String will return\n+     * <code>false</code>.</p>\n+     *\n+     * @param str  the <code>String</code> to check\n+     * @return <code>true</code> if str contains only unicode numeric\n+     */\n+    public static boolean isDigits(String str) {\n+        if ((str == null) || (str.length() == 0)) {\n+            return false;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            if (!Character.isDigit(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether the String a valid Java number.</p>\n+     *\n+     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n+     * qualifier, scientific notation and numbers marked with a type\n+     * qualifier (e.g. 123L).</p>\n+     *\n+     * <p><code>Null</code> and empty String will return\n+     * <code>false</code>.</p>\n+     *\n+     * @param str  the <code>String</code> to check\n+     * @return <code>true</code> if the string is a correctly formatted number\n+     */\n+    public static boolean isNumber(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return false;\n+        }\n+        char[] chars = str.toCharArray();\n+        int sz = chars.length;\n+        boolean hasExp = false;\n+        boolean hasDecPoint = false;\n+        boolean allowSigns = false;\n+        boolean foundDigit = false;\n+        // deal with any possible sign up front\n+        int start = (chars[0] == '-') ? 1 : 0;\n+        if (sz > start + 1) {\n+            if (chars[start] == '0' && chars[start + 1] == 'x') {\n+                int i = start + 2;\n+                if (i == sz) {\n+                    return false; // str == \"0x\"\n+                }\n+                // checking hex (it can't be anything else)\n+                for (; i < chars.length; i++) {\n+                    if ((chars[i] < '0' || chars[i] > '9')\n+                        && (chars[i] < 'a' || chars[i] > 'f')\n+                        && (chars[i] < 'A' || chars[i] > 'F')) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        sz--; // don't want to loop to the last char, check it afterwords\n+              // for type qualifiers\n+        int i = start;\n+        // loop to the next to last char or to the last char if we need another digit to\n+        // make a valid number (e.g. chars[0..5] = \"1234E\")\n+        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                foundDigit = true;\n+                allowSigns = false;\n+\n+            } else if (chars[i] == '.') {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent   \n+                    return false;\n+                }\n+                hasDecPoint = true;\n+            } else if (chars[i] == 'e' || chars[i] == 'E') {\n+                // we've already taken care of hex.\n+                if (hasExp) {\n+                    // two E's\n+                    return false;\n+                }\n+                if (!foundDigit) {\n+                    return false;\n+                }\n+                hasExp = true;\n+                allowSigns = true;\n+            } else if (chars[i] == '+' || chars[i] == '-') {\n+                if (!allowSigns) {\n+                    return false;\n+                }\n+                allowSigns = false;\n+                foundDigit = false; // we need a digit after the E\n+            } else {\n+                return false;\n+            }\n+            i++;\n+        }\n+        if (i < chars.length) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                // no type qualifier, OK\n+                return true;\n+            }\n+            if (chars[i] == 'e' || chars[i] == 'E') {\n+                // can't have an E at the last byte\n+                return false;\n+            }\n+            if (!allowSigns\n+                && (chars[i] == 'd'\n+                    || chars[i] == 'D'\n+                    || chars[i] == 'f'\n+                    || chars[i] == 'F')) {\n+                return foundDigit;\n+            }\n+            if (chars[i] == 'l'\n+                || chars[i] == 'L') {\n+                // not allowing L with an exponent\n+                return foundDigit && !hasExp;\n+            }\n+            // last character is illegal\n+            return false;\n+        }\n+        // allowSigns is true iff the val ends in 'E'\n+        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n+        return !allowSigns && foundDigit;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/ObjectUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Operations on <code>Object</code>.</p>\n+ * \n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will generally not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Mario Winterer\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class ObjectUtils {\n+    \n+    /**\n+     * <p>Singleton used as a <code>null</code> placeholder where\n+     * <code>null</code> has another meaning.</p>\n+     *\n+     * <p>For example, in a <code>HashMap</code> the\n+     * {@link java.util.HashMap#get(java.lang.Object)} method returns\n+     * <code>null</code> if the <code>Map</code> contains\n+     * <code>null</code> or if there is no matching key. The\n+     * <code>Null</code> placeholder can be used to distinguish between\n+     * these two cases.</p>\n+     *\n+     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n+     * cannot be stored.</p>\n+     *\n+     * <p>This instance is Serializable.</p>\n+     */\n+    public static final Null NULL = new Null();\n+    \n+    /**\n+     * <p><code>ObjectUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public ObjectUtils() {\n+        super();\n+    }\n+\n+    // Defaulting\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a default value if the object passed is\n+     * <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.defaultIfNull(null, null)      = null\n+     * ObjectUtils.defaultIfNull(null, \"\")        = \"\"\n+     * ObjectUtils.defaultIfNull(null, \"zz\")      = \"zz\"\n+     * ObjectUtils.defaultIfNull(\"abc\", *)        = \"abc\"\n+     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param object  the <code>Object</code> to test, may be <code>null</code>\n+     * @param defaultValue  the default value to return, may be <code>null</code>\n+     * @return <code>object</code> if it is not <code>null</code>, defaultValue otherwise\n+     */\n+    public static Object defaultIfNull(Object object, Object defaultValue) {\n+        return object != null ? object : defaultValue;\n+    }\n+\n+    /**\n+     * <p>Compares two objects for equality, where either one or both\n+     * objects may be <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.equals(null, null)                  = true\n+     * ObjectUtils.equals(null, \"\")                    = false\n+     * ObjectUtils.equals(\"\", null)                    = false\n+     * ObjectUtils.equals(\"\", \"\")                      = true\n+     * ObjectUtils.equals(Boolean.TRUE, null)          = false\n+     * ObjectUtils.equals(Boolean.TRUE, \"true\")        = false\n+     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true\n+     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false\n+     * </pre>\n+     *\n+     * @param object1  the first object, may be <code>null</code>\n+     * @param object2  the second object, may be <code>null</code>\n+     * @return <code>true</code> if the values of both objects are the same\n+     */\n+    public static boolean equals(Object object1, Object object2) {\n+        if (object1 == object2) {\n+            return true;\n+        }\n+        if ((object1 == null) || (object2 == null)) {\n+            return false;\n+        }\n+        return object1.equals(object2);\n+    }\n+\n+    /**\n+     * <p>Gets the hash code of an object returning zero when the\n+     * object is <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.hashCode(null)   = 0\n+     * ObjectUtils.hashCode(obj)    = obj.hashCode()\n+     * </pre>\n+     *\n+     * @param obj  the object to obtain the hash code of, may be <code>null</code>\n+     * @return the hash code of the object, or zero if null\n+     * @since 2.1\n+     */\n+    public static int hashCode(Object obj) {\n+        return (obj == null) ? 0 : obj.hashCode();\n+    }\n+\n+    // Identity ToString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the toString that would be produced by <code>Object</code>\n+     * if a class did not override toString itself. <code>null</code>\n+     * will return <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.identityToString(null)         = null\n+     * ObjectUtils.identityToString(\"\")           = \"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(Boolean.TRUE) = \"java.lang.Boolean@7fa\"\n+     * </pre>\n+     *\n+     * @param object  the object to create a toString for, may be\n+     *  <code>null</code>\n+     * @return the default toString text, or <code>null</code> if\n+     *  <code>null</code> passed in\n+     */\n+    public static String identityToString(Object object) {\n+        if (object == null) {\n+            return null;\n+        }\n+        return appendIdentityToString(null, object).toString();\n+    }\n+\n+    /**\n+     * <p>Appends the toString that would be produced by <code>Object</code>\n+     * if a class did not override toString itself. <code>null</code>\n+     * will return <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.appendIdentityToString(*, null)            = null\n+     * ObjectUtils.appendIdentityToString(null, \"\")           = \"java.lang.String@1e23\"\n+     * ObjectUtils.appendIdentityToString(null, Boolean.TRUE) = \"java.lang.Boolean@7fa\"\n+     * ObjectUtils.appendIdentityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\")\n+     * </pre>\n+     *\n+     * @param buffer  the buffer to append to, may be <code>null</code>\n+     * @param object  the object to create a toString for, may be <code>null</code>\n+     * @return the default toString text, or <code>null</code> if\n+     *  <code>null</code> passed in\n+     * @since 2.0\n+     */\n+    public static StringBuffer appendIdentityToString(StringBuffer buffer, Object object) {\n+        if (object == null) {\n+            return null;\n+        }\n+        if (buffer == null) {\n+            buffer = new StringBuffer();\n+        }\n+        return buffer\n+            .append(object.getClass().getName())\n+            .append('@')\n+            .append(Integer.toHexString(System.identityHashCode(object)));\n+    }\n+\n+    // ToString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n+     * an empty string (\"\") if <code>null</code> input.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.toString(null)         = \"\"\n+     * ObjectUtils.toString(\"\")           = \"\"\n+     * ObjectUtils.toString(\"bat\")        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE) = \"true\"\n+     * </pre>\n+     * \n+     * @see StringUtils#defaultString(String)\n+     * @see String#valueOf(Object)\n+     * @param obj  the Object to <code>toString</code>, may be null\n+     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String toString(Object obj) {\n+        return obj == null ? \"\" : obj.toString();\n+    }\n+\n+    /**\n+     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n+     * a specified text if <code>null</code> input.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.toString(null, null)           = null\n+     * ObjectUtils.toString(null, \"null\")         = \"null\"\n+     * ObjectUtils.toString(\"\", \"null\")           = \"\"\n+     * ObjectUtils.toString(\"bat\", \"null\")        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE, \"null\") = \"true\"\n+     * </pre>\n+     * \n+     * @see StringUtils#defaultString(String,String)\n+     * @see String#valueOf(Object)\n+     * @param obj  the Object to <code>toString</code>, may be null\n+     * @param nullStr  the String to return if <code>null</code> input, may be null\n+     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String toString(Object obj, String nullStr) {\n+        return obj == null ? nullStr : obj.toString();\n+    }\n+\n+    // Null\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Class used as a null placeholder where <code>null</code>\n+     * has another meaning.</p>\n+     *\n+     * <p>For example, in a <code>HashMap</code> the\n+     * {@link java.util.HashMap#get(java.lang.Object)} method returns\n+     * <code>null</code> if the <code>Map</code> contains\n+     * <code>null</code> or if there is no matching key. The\n+     * <code>Null</code> placeholder can be used to distinguish between\n+     * these two cases.</p>\n+     *\n+     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n+     * cannot be stored.</p>\n+     */\n+    public static class Null implements Serializable {\n+        /**\n+         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0\n+         * \n+         * @see java.io.Serializable\n+         */\n+        private static final long serialVersionUID = 7092611880189329093L;\n+        \n+        /**\n+         * Restricted constructor - singleton.\n+         */\n+        Null() {\n+            super();\n+        }\n+        \n+        /**\n+         * <p>Ensure singleton.</p>\n+         * \n+         * @return the singleton value\n+         */\n+        private Object readResolve() {\n+            return ObjectUtils.NULL;\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/RandomStringUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.Random;\n+/**\n+ * <p>Operations for random <code>String</code>s.</p>\n+ * <p>Currently <em>private high surrogate</em> characters are ignored. \n+ * These are unicode characters that fall between the values 56192 (db80)\n+ * and 56319 (dbff) as we don't know how to handle them. \n+ * High and low surrogates are correctly dealt with - that is if a \n+ * high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) \n+ * then it is followed by a low surrogate. If a low surrogate is chosen, \n+ * 56320 (dc00) to 57343 (dfff) then it is placed after a randomly \n+ * chosen high surrogate. </p>\n+ *\n+ * @author GenerationJava Core library\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Phil Steitz\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class RandomStringUtils {\n+\n+    /**\n+     * <p>Random object used by random method. This has to be not local\n+     * to the random method so as to not return the same value in the \n+     * same millisecond.</p>\n+     */\n+    private static final Random RANDOM = new Random();\n+\n+    /**\n+     * <p><code>RandomStringUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>RandomStringUtils.random(5);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public RandomStringUtils() {\n+      super();\n+    }\n+\n+    // Random\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of all characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String random(int count) {\n+        return random(count, false, false);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters whose\n+     * ASCII value is between <code>32</code> and <code>126</code> (inclusive).</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAscii(int count) {\n+        return random(count, 32, 127, false, false);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alphabetic\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAlphabetic(int count) {\n+        return random(count, true, false);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAlphanumeric(int count) {\n+        return random(count, true, true);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of numeric\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomNumeric(int count) {\n+        return random(count, false, true);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters as indicated by the arguments.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param letters  if <code>true</code>, generated string will include\n+     *  alphabetic characters\n+     * @param numbers  if <code>true</code>, generated string will include\n+     *  numeric characters\n+     * @return the random string\n+     */\n+    public static String random(int count, boolean letters, boolean numbers) {\n+        return random(count, 0, 0, letters, numbers);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters as indicated by the arguments.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  if <code>true</code>, generated string will include\n+     *  alphabetic characters\n+     * @param numbers  if <code>true</code>, generated string will include\n+     *  numeric characters\n+     * @return the random string\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers) {\n+        return random(count, start, end, letters, numbers, null, RANDOM);\n+    }\n+\n+    /**\n+     * <p>Creates a random string based on a variety of options, using\n+     * default source of randomness.</p>\n+     *\n+     * <p>This method has exactly the same semantics as\n+     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n+     * instead of using an externally supplied source of randomness, it uses\n+     * the internal static {@link Random} instance.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  only allow letters?\n+     * @param numbers  only allow numbers?\n+     * @param chars  the set of chars to choose randoms from.\n+     *  If <code>null</code>, then it will use the set of all chars.\n+     * @return the random string\n+     * @throws ArrayIndexOutOfBoundsException if there are not\n+     *  <code>(end - start) + 1</code> characters in the set array.\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n+        return random(count, start, end, letters, numbers, chars, RANDOM);\n+    }\n+\n+    /**\n+     * <p>Creates a random string based on a variety of options, using\n+     * supplied source of randomness.</p>\n+     *\n+     * <p>If start and end are both <code>0</code>, start and end are set\n+     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n+     * characters, will be used, unless letters and numbers are both\n+     * <code>false</code>, in which case, start and end are set to\n+     * <code>0</code> and <code>Integer.MAX_VALUE</code>.\n+     *\n+     * <p>If set is not <code>null</code>, characters between start and\n+     * end are chosen.</p>\n+     *\n+     * <p>This method accepts a user-supplied {@link Random}\n+     * instance to use as a source of randomness. By seeding a single \n+     * {@link Random} instance with a fixed seed and using it for each call,\n+     * the same random sequence of strings can be generated repeatedly\n+     * and predictably.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  only allow letters?\n+     * @param numbers  only allow numbers?\n+     * @param chars  the set of chars to choose randoms from.\n+     *  If <code>null</code>, then it will use the set of all chars.\n+     * @param random  a source of randomness.\n+     * @return the random string\n+     * @throws ArrayIndexOutOfBoundsException if there are not\n+     *  <code>(end - start) + 1</code> characters in the set array.\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     * @since 2.0\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n+                                char[] chars, Random random) {\n+        if (count == 0) {\n+            return \"\";\n+        } else if (count < 0) {\n+            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n+        }\n+        if ((start == 0) && (end == 0)) {\n+            end = 'z' + 1;\n+            start = ' ';\n+            if (!letters && !numbers) {\n+                start = 0;\n+                end = Integer.MAX_VALUE;\n+            }\n+        }\n+\n+        char[] buffer = new char[count];\n+        int gap = end - start;\n+\n+        while (count-- != 0) {\n+            char ch;\n+            if (chars == null) {\n+                ch = (char) (random.nextInt(gap) + start);\n+            } else {\n+                ch = chars[random.nextInt(gap) + start];\n+            }\n+            if ((letters && Character.isLetter(ch))\n+                || (numbers && Character.isDigit(ch))\n+                || (!letters && !numbers)) \n+            {\n+                if(ch >= 56320 && ch <= 57343) {\n+                    if(count == 0) {\n+                        count++;\n+                    } else {\n+                        // low surrogate, insert high surrogate after putting it in\n+                        buffer[count] = ch;\n+                        count--;\n+                        buffer[count] = (char) (55296 + random.nextInt(128));\n+                    }\n+                } else if(ch >= 55296 && ch <= 56191) {\n+                    if(count == 0) {\n+                        count++;\n+                    } else {\n+                        // high surrogate, insert low surrogate before putting it in\n+                        buffer[count] = (char) (56320 + random.nextInt(128));\n+                        count--;\n+                        buffer[count] = ch;\n+                    }\n+                } else if(ch >= 56192 && ch <= 56319) {\n+                    // private high surrogate, no effing clue, so skip it\n+                    count++;\n+                } else {\n+                    buffer[count] = ch;\n+                }\n+            } else {\n+                count++;\n+            }\n+        }\n+        return new String(buffer);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters\n+     * specified.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param chars  the String containing the set of characters to use,\n+     *  may be null\n+     * @return the random string\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     */\n+    public static String random(int count, String chars) {\n+        if (chars == null) {\n+            return random(count, 0, 0, false, false, null, RANDOM);\n+        }\n+        return random(count, chars.toCharArray());\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters specified.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param chars  the character array containing the set of characters to use,\n+     *  may be null\n+     * @return the random string\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     */\n+    public static String random(int count, char[] chars) {\n+        if (chars == null) {\n+            return random(count, 0, 0, false, false, null, RANDOM);\n+        }\n+        return random(count, 0, chars.length, false, false, chars, RANDOM);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/SerializationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+\n+/**\n+ * <p>Exception thrown when the Serialization process fails.</p>\n+ *\n+ * <p>The original error is wrapped within this one.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SerializationException extends NestableRuntimeException {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 4029025366392702726L;\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> without specified\n+     * detail message.</p>\n+     */\n+    public SerializationException() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * detail message.</p>\n+     *\n+     * @param msg  The error message.\n+     */\n+    public SerializationException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * nested <code>Throwable</code>.</p>\n+     *\n+     * @param cause  The <code>Exception</code> or <code>Error</code>\n+     *  that caused this exception to be thrown.\n+     */\n+    public SerializationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * detail message and nested <code>Throwable</code>.</p>\n+     *\n+     * @param msg    The error message.\n+     * @param cause  The <code>Exception</code> or <code>Error</code>\n+     *  that caused this exception to be thrown.\n+     */\n+    public SerializationException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/SerializationUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Assists with the serialization process and performs additional functionality based \n+ * on serialization.</p>\n+ * <p>\n+ * <ul>\n+ * <li>Deep clone using serialization\n+ * <li>Serialize managing finally and IOException\n+ * <li>Deserialize managing finally and IOException\n+ * </ul>\n+ *\n+ * <p>This class throws exceptions for invalid <code>null</code> inputs.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author Stephen Colebourne\n+ * @author Jeff Varszegi\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SerializationUtils {\n+    \n+    /**\n+     * <p>SerializationUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>SerializationUtils.clone(object)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     * @since 2.0\n+     */\n+    public SerializationUtils() {\n+        super();\n+    }\n+\n+    // Clone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deep clone an <code>Object</code> using serialization.</p>\n+     *\n+     * <p>This is many times slower than writing clone methods by hand\n+     * on all objects in your object graph. However, for complex object\n+     * graphs, or for those that don't support deep cloning this can\n+     * be a simple alternative implementation. Of course all the objects\n+     * must be <code>Serializable</code>.</p>\n+     * \n+     * @param object  the <code>Serializable</code> object to clone\n+     * @return the cloned object\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object clone(Serializable object) {\n+        return deserialize(serialize(object));\n+    }\n+    \n+    // Serialize\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Serializes an <code>Object</code> to the specified stream.</p>\n+     *\n+     * <p>The stream will be closed once the object is written.\n+     * This avoids the need for a finally clause, and maybe also exception\n+     * handling, in the application code.</p>\n+     * \n+     * <p>The stream passed in is not buffered internally within this method.\n+     * This is the responsibility of your application if desired.</p>\n+     *\n+     * @param obj  the object to serialize to bytes, may be null\n+     * @param outputStream  the stream to write to, must not be null\n+     * @throws IllegalArgumentException if <code>outputStream</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static void serialize(Serializable obj, OutputStream outputStream) {\n+        if (outputStream == null) {\n+            throw new IllegalArgumentException(\"The OutputStream must not be null\");\n+        }\n+        ObjectOutputStream out = null;\n+        try {\n+            // stream closed in the finally\n+            out = new ObjectOutputStream(outputStream);\n+            out.writeObject(obj);\n+            \n+        } catch (IOException ex) {\n+            throw new SerializationException(ex);\n+        } finally {\n+            try {\n+                if (out != null) {\n+                    out.close();\n+                }\n+            } catch (IOException ex) {\n+                // ignore close exception\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Serializes an <code>Object</code> to a byte array for\n+     * storage/serialization.</p>\n+     *\n+     * @param obj  the object to serialize to bytes\n+     * @return a byte[] with the converted Serializable\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static byte[] serialize(Serializable obj) {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n+        serialize(obj, baos);\n+        return baos.toByteArray();\n+    }\n+\n+    // Deserialize\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deserializes an <code>Object</code> from the specified stream.</p>\n+     *\n+     * <p>The stream will be closed once the object is written. This\n+     * avoids the need for a finally clause, and maybe also exception\n+     * handling, in the application code.</p>\n+     * \n+     * <p>The stream passed in is not buffered internally within this method.\n+     * This is the responsibility of your application if desired.</p>\n+     *\n+     * @param inputStream  the serialized object input stream, must not be null\n+     * @return the deserialized object\n+     * @throws IllegalArgumentException if <code>inputStream</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object deserialize(InputStream inputStream) {\n+        if (inputStream == null) {\n+            throw new IllegalArgumentException(\"The InputStream must not be null\");\n+        }\n+        ObjectInputStream in = null;\n+        try {\n+            // stream closed in the finally\n+            in = new ObjectInputStream(inputStream);\n+            return in.readObject();\n+            \n+        } catch (ClassNotFoundException ex) {\n+            throw new SerializationException(ex);\n+        } catch (IOException ex) {\n+            throw new SerializationException(ex);\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException ex) {\n+                // ignore close exception\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Deserializes a single <code>Object</code> from an array of bytes.</p>\n+     *\n+     * @param objectData  the serialized object, must not be null\n+     * @return the deserialized object\n+     * @throws IllegalArgumentException if <code>objectData</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object deserialize(byte[] objectData) {\n+        if (objectData == null) {\n+            throw new IllegalArgumentException(\"The byte[] must not be null\");\n+        }\n+        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n+        return deserialize(bais);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+\n+/**\n+ * <p>Escapes and unescapes <code>String</code>s for\n+ * Java, Java Script, HTML, XML, and SQL.</p>\n+ *\n+ * @author Apache Jakarta Turbine\n+ * @author GenerationJavaCore library\n+ * @author Purple Technology\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @author Antony Riley\n+ * @author Helge Tesgaard\n+ * @author <a href=\"sean@boohai.com\">Sean Brown</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Phil Steitz\n+ * @author Pete Gieser\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class StringEscapeUtils {\n+\n+    /**\n+     * <p><code>StringEscapeUtils</code> instances should NOT be constructed in\n+     * standard programming.</p>\n+     *\n+     * <p>Instead, the class should be used as:\n+     * <pre>StringEscapeUtils.escapeJava(\"foo\");</pre></p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public StringEscapeUtils() {\n+      super();\n+    }\n+\n+    // Java and JavaScript\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n+     *\n+     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n+     *\n+     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n+     * <code>'t'</code>.</p>\n+     *\n+     * <p>The only difference between Java strings and JavaScript strings\n+     * is that in JavaScript, a single quote must be escaped.</p>\n+     *\n+     * <p>Example:\n+     * <pre>\n+     * input string: He didn't say, \"Stop!\"\n+     * output string: He didn't say, \\\"Stop!\\\"\n+     * </pre>\n+     * </p>\n+     *\n+     * @param str  String to escape values in, may be null\n+     * @return String with escaped values, <code>null</code> if null string input\n+     */\n+    public static String escapeJava(String str) {\n+        return escapeJavaStyleString(str, false);\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using Java String rules to\n+     * a <code>Writer</code>.</p>\n+     * \n+     * <p>A <code>null</code> string input has no effect.</p>\n+     * \n+     * @see #escapeJava(java.lang.String)\n+     * @param out  Writer to write escaped string into\n+     * @param str  String to escape values in, may be null\n+     * @throws IllegalArgumentException if the Writer is <code>null</code>\n+     * @throws IOException if error occurs on underlying Writer\n+     */\n+    public static void escapeJava(Writer out, String str) throws IOException {\n+        escapeJavaStyleString(out, str, false);\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n+     * <p>Escapes any values it finds into their JavaScript String form.\n+     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n+     *\n+     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n+     * <code>'t'</code>.</p>\n+     *\n+     * <p>The only difference between Java strings and JavaScript strings\n+     * is that in JavaScript, a single quote must be escaped.</p>\n+     *\n+     * <p>Example:\n+     * <pre>\n+     * input string: He didn't say, \"Stop!\"\n+     * output string: He didn\\'t say, \\\"Stop!\\\"\n+     * </pre>\n+     * </p>\n+     *\n+     * @param str  String to escape values in, may be null\n+     * @return String with escaped values, <code>null</code> if null string input\n+     */\n+    public static String escapeJavaScript(String str) {\n+        return escapeJavaStyleString(str, true);\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n+     * to a <code>Writer</code>.</p>\n+     * \n+     * <p>A <code>null</code> string input has no effect.</p>\n+     * \n+     * @see #escapeJavaScript(java.lang.String)\n+     * @param out  Writer to write escaped string into\n+     * @param str  String to escape values in, may be null\n+     * @throws IllegalArgumentException if the Writer is <code>null</code>\n+     * @throws IOException if error occurs on underlying Writer\n+     **/\n+    public static void escapeJavaScript(Writer out, String str) throws IOException {\n+        escapeJavaStyleString(out, str, true);\n+    }\n+\n+    /**\n+     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n+     * \n+     * @param str String to escape values in, may be null\n+     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n+     * @return the escaped string\n+     */\n+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n+        if (str == null) {\n+            return null;\n+        }\n+        try {\n+            StringWriter writer = new StringWriter(str.length() * 2);\n+            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n+            return writer.toString();\n+        } catch (IOException ioe) {\n+            // this should never ever happen while writing to a StringWriter\n+            ioe.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n+     * \n+     * @param out write to receieve the escaped string\n+     * @param str String to escape values in, may be null\n+     * @param escapeSingleQuote escapes single quotes if <code>true</code>\n+     * @throws IOException if an IOException occurs\n+     */\n+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n+        if (out == null) {\n+            throw new IllegalArgumentException(\"The Writer must not be null\");\n+        }\n+        if (str == null) {\n+            return;\n+        }\n+        int sz;\n+        sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            char ch = str.charAt(i);\n+\n+            // handle unicode\n+            if (ch > 0xfff) {\n+                out.write(\"\\\\u\" + hex(ch));\n+            } else if (ch > 0xff) {\n+                out.write(\"\\\\u0\" + hex(ch));\n+            } else if (ch > 0x7f) {\n+                out.write(\"\\\\u00\" + hex(ch));\n+            } else if (ch < 32) {\n+                switch (ch) {\n+                    case '\\b':\n+                        out.write('\\\\');\n+                        out.write('b');\n+                        break;\n+                    case '\\n':\n+                        out.write('\\\\');\n+                        out.write('n');\n+                        break;\n+                    case '\\t':\n+                        out.write('\\\\');\n+                        out.write('t');\n+                        break;\n+                    case '\\f':\n+                        out.write('\\\\');\n+                        out.write('f');\n+                        break;\n+                    case '\\r':\n+                        out.write('\\\\');\n+                        out.write('r');\n+                        break;\n+                    default :\n+                        if (ch > 0xf) {\n+                            out.write(\"\\\\u00\" + hex(ch));\n+                        } else {\n+                            out.write(\"\\\\u000\" + hex(ch));\n+                        }\n+                        break;\n+                }\n+            } else {\n+                switch (ch) {\n+                    case '\\'':\n+                        if (escapeSingleQuote) {\n+                          out.write('\\\\');\n+                        }\n+                        out.write('\\'');\n+                        break;\n+                    case '\"':\n+                        out.write('\\\\');\n+                        out.write('\"');\n+                        break;\n+                    case '\\\\':\n+                        out.write('\\\\');\n+                        out.write('\\\\');\n+                        break;\n+                    default :\n+                        out.write(ch);\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns an upper case hexadecimal <code>String</code> for the given\n+     * character.</p>\n+     * \n+     * @param ch The character to convert.\n+     * @return An upper case hexadecimal <code>String</code>\n+     */\n+    private static String hex(char ch) {\n+        return Integer.toHexString(ch).toUpperCase();\n+    }\n+\n+    /**\n+     * <p>Unescapes any Java literals found in the <code>String</code>.\n+     * For example, it will turn a sequence of <code>'\\'</code> and\n+     * <code>'n'</code> into a newline character, unless the <code>'\\'</code>\n+     * is preceded by another <code>'\\'</code>.</p>\n+     * \n+     * @param str  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     */\n+    public static String unescapeJava(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        try {\n+            StringWriter writer = new StringWriter(str.length());\n+            unescapeJava(writer, str);\n+            return writer.toString();\n+        } catch (IOException ioe) {\n+            // this should never ever happen while writing to a StringWriter\n+            ioe.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * <p>Unescapes any Java literals found in the <code>String</code> to a\n+     * <code>Writer</code>.</p>\n+     *\n+     * <p>For example, it will turn a sequence of <code>'\\'</code> and\n+     * <code>'n'</code> into a newline character, unless the <code>'\\'</code>\n+     * is preceded by another <code>'\\'</code>.</p>\n+     * \n+     * <p>A <code>null</code> string input has no effect.</p>\n+     * \n+     * @param out  the <code>Writer</code> used to output unescaped characters\n+     * @param str  the <code>String</code> to unescape, may be null\n+     * @throws IllegalArgumentException if the Writer is <code>null</code>\n+     * @throws IOException if error occurs on underlying Writer\n+     */\n+    public static void unescapeJava(Writer out, String str) throws IOException {\n+        if (out == null) {\n+            throw new IllegalArgumentException(\"The Writer must not be null\");\n+        }\n+        if (str == null) {\n+            return;\n+        }\n+        int sz = str.length();\n+        StringBuffer unicode = new StringBuffer(4);\n+        boolean hadSlash = false;\n+        boolean inUnicode = false;\n+        for (int i = 0; i < sz; i++) {\n+            char ch = str.charAt(i);\n+            if (inUnicode) {\n+                // if in unicode, then we're reading unicode\n+                // values in somehow\n+                unicode.append(ch);\n+                if (unicode.length() == 4) {\n+                    // unicode now contains the four hex digits\n+                    // which represents our unicode character\n+                    try {\n+                        int value = Integer.parseInt(unicode.toString(), 16);\n+                        out.write((char) value);\n+                        unicode.setLength(0);\n+                        inUnicode = false;\n+                        hadSlash = false;\n+                    } catch (NumberFormatException nfe) {\n+                        throw new NestableRuntimeException(\"Unable to parse unicode value: \" + unicode, nfe);\n+                    }\n+                }\n+                continue;\n+            }\n+            if (hadSlash) {\n+                // handle an escaped value\n+                hadSlash = false;\n+                switch (ch) {\n+                    case '\\\\':\n+                        out.write('\\\\');\n+                        break;\n+                    case '\\'':\n+                        out.write('\\'');\n+                        break;\n+                    case '\\\"':\n+                        out.write('\"');\n+                        break;\n+                    case 'r':\n+                        out.write('\\r');\n+                        break;\n+                    case 'f':\n+                        out.write('\\f');\n+                        break;\n+                    case 't':\n+                        out.write('\\t');\n+                        break;\n+                    case 'n':\n+                        out.write('\\n');\n+                        break;\n+                    case 'b':\n+                        out.write('\\b');\n+                        break;\n+                    case 'u':\n+                        {\n+                            // uh-oh, we're in unicode country....\n+                            inUnicode = true;\n+                            break;\n+                        }\n+                    default :\n+                        out.write(ch);\n+                        break;\n+                }\n+                continue;\n+            } else if (ch == '\\\\') {\n+                hadSlash = true;\n+                continue;\n+            }\n+            out.write(ch);\n+        }\n+        if (hadSlash) {\n+            // then we're in the weird case of a \\ at the end of the\n+            // string, let's output it anyway.\n+            out.write('\\\\');\n+        }\n+    }\n+\n+    /**\n+     * <p>Unescapes any JavaScript literals found in the <code>String</code>.</p>\n+     *\n+     * <p>For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code>\n+     * into a newline character, unless the <code>'\\'</code> is preceded by another\n+     * <code>'\\'</code>.</p>\n+     *\n+     * @see #unescapeJava(String)\n+     * @param str  the <code>String</code> to unescape, may be null\n+     * @return A new unescaped <code>String</code>, <code>null</code> if null string input\n+     */\n+    public static String unescapeJavaScript(String str) {\n+        return unescapeJava(str);\n+    }\n+\n+    /**\n+     * <p>Unescapes any JavaScript literals found in the <code>String</code> to a\n+     * <code>Writer</code>.</p>\n+     *\n+     * <p>For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code>\n+     * into a newline character, unless the <code>'\\'</code> is preceded by another\n+     * <code>'\\'</code>.</p>\n+     *\n+     * <p>A <code>null</code> string input has no effect.</p>\n+     * \n+     * @see #unescapeJava(Writer,String)\n+     * @param out  the <code>Writer</code> used to output unescaped characters\n+     * @param str  the <code>String</code> to unescape, may be null\n+     * @throws IllegalArgumentException if the Writer is <code>null</code>\n+     * @throws IOException if error occurs on underlying Writer\n+     */\n+    public static void unescapeJavaScript(Writer out, String str) throws IOException {\n+        unescapeJava(out, str);\n+    }\n+\n+    // HTML and XML\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using HTML entities.</p>\n+     *\n+     * <p>\n+     * For example:\n+     * </p> \n+     * <p><code>\"bread\" & \"butter\"</code></p>\n+     * becomes:\n+     * <p>\n+     * <code>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</code>.\n+     * </p>\n+     *\n+     * <p>Supports all known HTML 4.0 entities, including funky accents.\n+     * Note that the commonly used apostrophe escape character (&amp;apos;)\n+     * is not a legal entity and so is not supported). </p>\n+     *\n+     * @param str  the <code>String</code> to escape, may be null\n+     * @return a new escaped <code>String</code>, <code>null</code> if null string input\n+     * \n+     * @see #unescapeHtml(String)\n+     * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n+     */\n+    public static String escapeHtml(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        try {\n+            StringWriter writer = new StringWriter ((int)(str.length() * 1.5));\n+            escapeHtml(writer, str);\n+            return writer.toString();\n+        } catch (IOException e) {\n+            //assert false;\n+            //should be impossible\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using HTML entities and writes\n+     * them to a <code>Writer</code>.</p>\n+     *\n+     * <p>\n+     * For example:\n+     * </p> \n+     * <code>\"bread\" & \"butter\"</code>\n+     * <p>becomes:</p>\n+     * <code>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</code>.\n+     *\n+     * <p>Supports all known HTML 4.0 entities, including funky accents.\n+     * Note that the commonly used apostrophe escape character (&amp;apos;)\n+     * is not a legal entity and so is not supported). </p>\n+     *\n+     * @param writer  the writer receiving the escaped string, not null\n+     * @param string  the <code>String</code> to escape, may be null\n+     * @throws IllegalArgumentException if the writer is null\n+     * @throws IOException when <code>Writer</code> passed throws the exception from\n+     *                                       calls to the {@link Writer#write(int)} methods.\n+     * \n+     * @see #escapeHtml(String)\n+     * @see #unescapeHtml(String)\n+     * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n+     */\n+    public static void escapeHtml(Writer writer, String string) throws IOException {\n+        if (writer == null ) {\n+            throw new IllegalArgumentException (\"The Writer must not be null.\");\n+        }\n+        if (string == null) {\n+            return;\n+        }\n+        Entities.HTML40.escape(writer, string);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Unescapes a string containing entity escapes to a string\n+     * containing the actual Unicode characters corresponding to the\n+     * escapes. Supports HTML 4.0 entities.</p>\n+     *\n+     * <p>For example, the string \"&amp;lt;Fran&amp;ccedil;ais&amp;gt;\"\n+     * will become \"&lt;Fran&ccedil;ais&gt;\"</p>\n+     *\n+     * <p>If an entity is unrecognized, it is left alone, and inserted\n+     * verbatim into the result string. e.g. \"&amp;gt;&amp;zzzz;x\" will\n+     * become \"&gt;&amp;zzzz;x\".</p>\n+     *\n+     * @param str  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     * @see #escapeHtml(Writer, String)\n+     */\n+    public static String unescapeHtml(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        try {\n+            StringWriter writer = new StringWriter ((int)(str.length() * 1.5));\n+            unescapeHtml(writer, str);\n+            return writer.toString();\n+        } catch (IOException e) {\n+            //assert false;\n+            //should be impossible\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * <p>Unescapes a string containing entity escapes to a string\n+     * containing the actual Unicode characters corresponding to the\n+     * escapes. Supports HTML 4.0 entities.</p>\n+     *\n+     * <p>For example, the string \"&amp;lt;Fran&amp;ccedil;ais&amp;gt;\"\n+     * will become \"&lt;Fran&ccedil;ais&gt;\"</p>\n+     *\n+     * <p>If an entity is unrecognized, it is left alone, and inserted\n+     * verbatim into the result string. e.g. \"&amp;gt;&amp;zzzz;x\" will\n+     * become \"&gt;&amp;zzzz;x\".</p>\n+     *\n+     * @param writer  the writer receiving the unescaped string, not null\n+     * @param string  the <code>String</code> to unescape, may be null\n+     * @throws IllegalArgumentException if the writer is null\n+     * @throws IOException if an IOException occurs\n+     * @see #escapeHtml(String)\n+     */\n+    public static void unescapeHtml(Writer writer, String string) throws IOException {\n+        if (writer == null ) {\n+            throw new IllegalArgumentException (\"The Writer must not be null.\");\n+        }\n+        if (string == null) {\n+            return;\n+        }\n+        Entities.HTML40.unescape(writer, string);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using XML entities.</p>\n+     *\n+     * <p>For example: <tt>\"bread\" & \"butter\"</tt> =>\n+     * <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>.\n+     * </p>\n+     *\n+     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n+     * Does not support DTDs or external entities.</p>\n+     *\n+     * <p>Note that unicode characters greater than 0x7f are currently escaped to \n+     *    their numerical \\\\u equivalent. This may change in future releases. </p>\n+     *\n+     * @param writer  the writer receiving the unescaped string, not null\n+     * @param str  the <code>String</code> to escape, may be null\n+     * @throws IllegalArgumentException if the writer is null\n+     * @throws IOException if there is a problem writing\n+     * @see #unescapeXml(java.lang.String)\n+     */\n+    public static void escapeXml(Writer writer, String str) throws IOException {\n+        if (writer == null ) {\n+            throw new IllegalArgumentException (\"The Writer must not be null.\");\n+        }\n+        if (str == null) {\n+            return;\n+        }\n+        Entities.XML.escape(writer, str);\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using XML entities.</p>\n+     *\n+     * <p>For example: <tt>\"bread\" & \"butter\"</tt> =>\n+     * <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>.\n+     * </p>\n+     *\n+     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n+     * Does not support DTDs or external entities.</p>\n+     *\n+     * <p>Note that unicode characters greater than 0x7f are currently escaped to \n+     *    their numerical \\\\u equivalent. This may change in future releases. </p>\n+     *\n+     * @param str  the <code>String</code> to escape, may be null\n+     * @return a new escaped <code>String</code>, <code>null</code> if null string input\n+     * @see #unescapeXml(java.lang.String)\n+     */\n+    public static String escapeXml(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Entities.XML.escape(str);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Unescapes a string containing XML entity escapes to a string\n+     * containing the actual Unicode characters corresponding to the\n+     * escapes.</p>\n+     *\n+     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n+     * Does not support DTDs or external entities.</p>\n+     *\n+     * <p>Note that numerical \\\\u unicode codes are unescaped to their respective \n+     *    unicode characters. This may change in future releases. </p>\n+     *\n+     * @param writer  the writer receiving the unescaped string, not null\n+     * @param str  the <code>String</code> to unescape, may be null\n+     * @throws IllegalArgumentException if the writer is null\n+     * @throws IOException if there is a problem writing\n+     * @see #escapeXml(String)\n+     */\n+    public static void unescapeXml(Writer writer, String str) throws IOException {\n+        if (writer == null ) {\n+            throw new IllegalArgumentException (\"The Writer must not be null.\");\n+        }\n+        if (str == null) {\n+            return;\n+        }\n+        Entities.XML.unescape(writer, str);\n+    }\n+\n+    /**\n+     * <p>Unescapes a string containing XML entity escapes to a string\n+     * containing the actual Unicode characters corresponding to the\n+     * escapes.</p>\n+     *\n+     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n+     * Does not support DTDs or external entities.</p>\n+     *\n+     * <p>Note that numerical \\\\u unicode codes are unescaped to their respective \n+     *    unicode characters. This may change in future releases. </p>\n+     *\n+     * @param str  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     * @see #escapeXml(String)\n+     */\n+    public static String unescapeXml(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Entities.XML.unescape(str);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> to be suitable to pass to\n+     * an SQL query.</p>\n+     *\n+     * <p>For example,\n+     * <pre>statement.executeQuery(\"SELECT * FROM MOVIES WHERE TITLE='\" + \n+     *   StringEscapeUtils.escapeSql(\"McHale's Navy\") + \n+     *   \"'\");</pre>\n+     * </p>\n+     *\n+     * <p>At present, this method only turns single-quotes into doubled single-quotes\n+     * (<code>\"McHale's Navy\"</code> => <code>\"McHale''s Navy\"</code>). It does not\n+     * handle the cases of percent (%) or underscore (_) for use in LIKE clauses.</p>\n+     *\n+     * see http://www.jguru.com/faq/view.jsp?EID=8881\n+     * @param str  the string to escape, may be null\n+     * @return a new String, escaped for SQL, <code>null</code> if null string input\n+     */\n+    public static String escapeSql(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return StringUtils.replace(str, \"'\", \"''\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/StringUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>Operations on {@link java.lang.String} that are\n+ * <code>null</code> safe.</p>\n+ *\n+ * <ul>\n+ *  <li><b>IsEmpty/IsBlank</b>\n+ *      - checks if a String contains text</li>\n+ *  <li><b>Trim/Strip</b>\n+ *      - removes leading and trailing whitespace</li>\n+ *  <li><b>Equals</b>\n+ *      - compares two strings null-safe</li>\n+ *  <li><b>IndexOf/LastIndexOf/Contains</b>\n+ *      - null-safe index-of checks\n+ *  <li><b>IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut</b>\n+ *      - index-of any of a set of Strings</li>\n+ *  <li><b>ContainsOnly/ContainsNone</b>\n+ *      - does String contains only/none of these characters</li>\n+ *  <li><b>Substring/Left/Right/Mid</b>\n+ *      - null-safe substring extractions</li>\n+ *  <li><b>SubstringBefore/SubstringAfter/SubstringBetween</b>\n+ *      - substring extraction relative to other strings</li>\n+ *  <li><b>Split/Join</b>\n+ *      - splits a String into an array of substrings and vice versa</li>\n+ *  <li><b>Remove/Delete</b>\n+ *      - removes part of a String</li>\n+ *  <li><b>Replace/Overlay</b>\n+ *      - Searches a String and replaces one String with another</li>\n+ *  <li><b>Chomp/Chop</b>\n+ *      - removes the last part of a String</li>\n+ *  <li><b>LeftPad/RightPad/Center/Repeat</b>\n+ *      - pads a String</li>\n+ *  <li><b>UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize</b>\n+ *      - changes the case of a String</li>\n+ *  <li><b>CountMatches</b>\n+ *      - counts the number of occurrences of one String in another</li>\n+ *  <li><b>IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable</b>\n+ *      - checks the characters in a String</li>\n+ *  <li><b>DefaultString</b>\n+ *      - protects against a null input String</li>\n+ *  <li><b>Reverse/ReverseDelimited</b>\n+ *      - reverses a String</li>\n+ *  <li><b>Abbreviate</b>\n+ *      - abbreviates a string using ellipsis</li>\n+ *  <li><b>Difference</b>\n+ *      - compares two Strings and reports on their differences</li>\n+ *  <li><b>LevensteinDistance</b>\n+ *      - the number of changes needed to change one String into another</li>\n+ * </ul>\n+ *\n+ * <p>The <code>StringUtils</code> class defines certain words related to\n+ * String handling.</p>\n+ *\n+ * <ul>\n+ *  <li>null - <code>null</code></li>\n+ *  <li>empty - a zero-length string (<code>\"\"</code>)</li>\n+ *  <li>space - the space character (<code>' '</code>, char 32)</li>\n+ *  <li>whitespace - the characters defined by {@link Character#isWhitespace(char)}</li>\n+ *  <li>trim - the characters &lt;= 32 as in {@link String#trim()}</li>\n+ * </ul>\n+ *\n+ * <p><code>StringUtils</code> handles <code>null</code> input Strings quietly.\n+ * That is to say that a <code>null</code> input will return <code>null</code>.\n+ * Where a <code>boolean</code> or <code>int</code> is being returned\n+ * details vary by method.</p>\n+ *\n+ * <p>A side effect of the <code>null</code> handling is that a\n+ * <code>NullPointerException</code> should be considered a bug in\n+ * <code>StringUtils</code> (except for deprecated methods).</p>\n+ *\n+ * <p>Methods in this class give sample code to explain their operation.\n+ * The symbol <code>*</code> is used to indicate any input including <code>null</code>.</p>\n+ *\n+ * @see java.lang.String\n+ * @author <a href=\"http://jakarta.apache.org/turbine/\">Apache Jakarta Turbine</a>\n+ * @author GenerationJavaCore\n+ * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author <a href=\"mailto:gcoladonato@yahoo.com\">Greg Coladonato</a>\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:ed@apache.org\">Ed Korthof</a>\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @author Holger Krauth\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Arun Mammen Thomas\n+ * @author Gary Gregory\n+ * @author Phil Steitz\n+ * @author Al Chou\n+ * @author Michael Davey\n+ * @author Reuben Sivan\n+ * @author Chris Hyzer\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class StringUtils {\n+    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n+    // Whitespace:\n+    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n+    // where WHITESPACE is a string of all whitespace characters\n+    //\n+    // Character access:\n+    // String.charAt(n) versus toCharArray(), then array[n]\n+    // String.charAt(n) is about 15% worse for a 10K string\n+    // They are about equal for a length 50 string\n+    // String.charAt(n) is about 4 times better for a length 3 string\n+    // String.charAt(n) is best bet overall\n+    //\n+    // Append:\n+    // String.concat about twice as fast as StringBuffer.append\n+    // (not sure who tested this)\n+\n+    /**\n+     * The empty String <code>\"\"</code>.\n+     * @since 2.0\n+     */\n+    public static final String EMPTY = \"\";\n+\n+    /**\n+     * Represents a failed index search.\n+     * @since 2.1\n+     */\n+    public static final int INDEX_NOT_FOUND = -1;\n+\n+    /**\n+     * <p>The maximum size to which the padding constant(s) can expand.</p>\n+     */\n+    private static final int PAD_LIMIT = 8192;\n+\n+    /**\n+     * <p><code>StringUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>StringUtils.trim(\" foo \");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public StringUtils() {\n+        super();\n+    }\n+\n+    // Empty checks\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if a String is empty (\"\") or null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isEmpty(null)      = true\n+     * StringUtils.isEmpty(\"\")        = true\n+     * StringUtils.isEmpty(\" \")       = false\n+     * StringUtils.isEmpty(\"bob\")     = false\n+     * StringUtils.isEmpty(\"  bob  \") = false\n+     * </pre>\n+     *\n+     * <p>NOTE: This method changed in Lang version 2.0.\n+     * It no longer trims the String.\n+     * That functionality is available in isBlank().</p>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is empty or null\n+     */\n+    public static boolean isEmpty(String str) {\n+        return str == null || str.length() == 0;\n+    }\n+\n+    /**\n+     * <p>Checks if a String is not empty (\"\") and not null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNotEmpty(null)      = false\n+     * StringUtils.isNotEmpty(\"\")        = false\n+     * StringUtils.isNotEmpty(\" \")       = true\n+     * StringUtils.isNotEmpty(\"bob\")     = true\n+     * StringUtils.isNotEmpty(\"  bob  \") = true\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is not empty and not null\n+     */\n+    public static boolean isNotEmpty(String str) {\n+        return !StringUtils.isEmpty(str);\n+    }\n+\n+    /**\n+     * <p>Checks if a String is whitespace, empty (\"\") or null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isBlank(null)      = true\n+     * StringUtils.isBlank(\"\")        = true\n+     * StringUtils.isBlank(\" \")       = true\n+     * StringUtils.isBlank(\"bob\")     = false\n+     * StringUtils.isBlank(\"  bob  \") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is null, empty or whitespace\n+     * @since 2.0\n+     */\n+    public static boolean isBlank(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if a String is not empty (\"\"), not null and not whitespace only.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNotBlank(null)      = false\n+     * StringUtils.isNotBlank(\"\")        = false\n+     * StringUtils.isNotBlank(\" \")       = false\n+     * StringUtils.isNotBlank(\"bob\")     = true\n+     * StringUtils.isNotBlank(\"  bob  \") = true\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is\n+     *  not empty and not null and not whitespace\n+     * @since 2.0\n+     */\n+    public static boolean isNotBlank(String str) {\n+        return !StringUtils.isBlank(str);\n+    }\n+\n+    // Trim\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String, handling <code>null</code> by returning\n+     * an empty String (\"\").</p>\n+     *\n+     * <pre>\n+     * StringUtils.clean(null)          = \"\"\n+     * StringUtils.clean(\"\")            = \"\"\n+     * StringUtils.clean(\"abc\")         = \"abc\"\n+     * StringUtils.clean(\"    abc    \") = \"abc\"\n+     * StringUtils.clean(\"     \")       = \"\"\n+     * </pre>\n+     *\n+     * @see java.lang.String#trim()\n+     * @param str  the String to clean, may be null\n+     * @return the trimmed text, never <code>null</code>\n+     * @deprecated Use the clearer named {@link #trimToEmpty(String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String clean(String str) {\n+        return str == null ? EMPTY : str.trim();\n+    }\n+\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String, handling <code>null</code> by returning\n+     * <code>null</code>.</p>\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #strip(String)}.</p>\n+     *\n+     * <p>To trim your choice of characters, use the\n+     * {@link #strip(String, String)} methods.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trim(null)          = null\n+     * StringUtils.trim(\"\")            = \"\"\n+     * StringUtils.trim(\"     \")       = \"\"\n+     * StringUtils.trim(\"abc\")         = \"abc\"\n+     * StringUtils.trim(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed string, <code>null</code> if null String input\n+     */\n+    public static String trim(String str) {\n+        return str == null ? null : str.trim();\n+    }\n+\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String returning <code>null</code> if the String is\n+     * empty (\"\") after the trim or if it is <code>null</code>.\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #stripToNull(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trimToNull(null)          = null\n+     * StringUtils.trimToNull(\"\")            = null\n+     * StringUtils.trimToNull(\"     \")       = null\n+     * StringUtils.trimToNull(\"abc\")         = \"abc\"\n+     * StringUtils.trimToNull(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed String,\n+     *  <code>null</code> if only chars &lt;= 32, empty or null String input\n+     * @since 2.0\n+     */\n+    public static String trimToNull(String str) {\n+        String ts = trim(str);\n+        return isEmpty(ts) ? null : ts;\n+    }\n+\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String returning an empty String (\"\") if the String\n+     * is empty (\"\") after the trim or if it is <code>null</code>.\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #stripToEmpty(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trimToEmpty(null)          = \"\"\n+     * StringUtils.trimToEmpty(\"\")            = \"\"\n+     * StringUtils.trimToEmpty(\"     \")       = \"\"\n+     * StringUtils.trimToEmpty(\"abc\")         = \"abc\"\n+     * StringUtils.trimToEmpty(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed String, or an empty String if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String trimToEmpty(String str) {\n+        return str == null ? EMPTY : str.trim();\n+    }\n+\n+    // Stripping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Strips whitespace from the start and end of a String.</p>\n+     *\n+     * <p>This is similar to {@link #trim(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.strip(null)     = null\n+     * StringUtils.strip(\"\")       = \"\"\n+     * StringUtils.strip(\"   \")    = \"\"\n+     * StringUtils.strip(\"abc\")    = \"abc\"\n+     * StringUtils.strip(\"  abc\")  = \"abc\"\n+     * StringUtils.strip(\"abc  \")  = \"abc\"\n+     * StringUtils.strip(\" abc \")  = \"abc\"\n+     * StringUtils.strip(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove whitespace from, may be null\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String strip(String str) {\n+        return strip(str, null);\n+    }\n+\n+    /**\n+     * <p>Strips whitespace from the start and end of a String  returning\n+     * <code>null</code> if the String is empty (\"\") after the strip.</p>\n+     *\n+     * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripToNull(null)     = null\n+     * StringUtils.stripToNull(\"\")       = null\n+     * StringUtils.stripToNull(\"   \")    = null\n+     * StringUtils.stripToNull(\"abc\")    = \"abc\"\n+     * StringUtils.stripToNull(\"  abc\")  = \"abc\"\n+     * StringUtils.stripToNull(\"abc  \")  = \"abc\"\n+     * StringUtils.stripToNull(\" abc \")  = \"abc\"\n+     * StringUtils.stripToNull(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to be stripped, may be null\n+     * @return the stripped String,\n+     *  <code>null</code> if whitespace, empty or null String input\n+     * @since 2.0\n+     */\n+    public static String stripToNull(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        str = strip(str, null);\n+        return str.length() == 0 ? null : str;\n+    }\n+\n+    /**\n+     * <p>Strips whitespace from the start and end of a String  returning\n+     * an empty String if <code>null</code> input.</p>\n+     *\n+     * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripToEmpty(null)     = \"\"\n+     * StringUtils.stripToEmpty(\"\")       = \"\"\n+     * StringUtils.stripToEmpty(\"   \")    = \"\"\n+     * StringUtils.stripToEmpty(\"abc\")    = \"abc\"\n+     * StringUtils.stripToEmpty(\"  abc\")  = \"abc\"\n+     * StringUtils.stripToEmpty(\"abc  \")  = \"abc\"\n+     * StringUtils.stripToEmpty(\" abc \")  = \"abc\"\n+     * StringUtils.stripToEmpty(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to be stripped, may be null\n+     * @return the trimmed String, or an empty String if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String stripToEmpty(String str) {\n+        return str == null ? EMPTY : strip(str, null);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start and end of a String.\n+     * This is similar to {@link String#trim()} but allows the characters\n+     * to be stripped to be controlled.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.\n+     * Alternatively use {@link #strip(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.strip(null, *)          = null\n+     * StringUtils.strip(\"\", *)            = \"\"\n+     * StringUtils.strip(\"abc\", null)      = \"abc\"\n+     * StringUtils.strip(\"  abc\", null)    = \"abc\"\n+     * StringUtils.strip(\"abc  \", null)    = \"abc\"\n+     * StringUtils.strip(\" abc \", null)    = \"abc\"\n+     * StringUtils.strip(\"  abcyx\", \"xyz\") = \"  abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String strip(String str, String stripChars) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        str = stripStart(str, stripChars);\n+        return stripEnd(str, stripChars);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start of a String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripStart(null, *)          = null\n+     * StringUtils.stripStart(\"\", *)            = \"\"\n+     * StringUtils.stripStart(\"abc\", \"\")        = \"abc\"\n+     * StringUtils.stripStart(\"abc\", null)      = \"abc\"\n+     * StringUtils.stripStart(\"  abc\", null)    = \"abc\"\n+     * StringUtils.stripStart(\"abc  \", null)    = \"abc  \"\n+     * StringUtils.stripStart(\" abc \", null)    = \"abc \"\n+     * StringUtils.stripStart(\"yxabc  \", \"xyz\") = \"abc  \"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String stripStart(String str, String stripChars) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        int start = 0;\n+        if (stripChars == null) {\n+            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n+                start++;\n+            }\n+        } else if (stripChars.length() == 0) {\n+            return str;\n+        } else {\n+            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n+                start++;\n+            }\n+        }\n+        return str.substring(start);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the end of a String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripEnd(null, *)          = null\n+     * StringUtils.stripEnd(\"\", *)            = \"\"\n+     * StringUtils.stripEnd(\"abc\", \"\")        = \"abc\"\n+     * StringUtils.stripEnd(\"abc\", null)      = \"abc\"\n+     * StringUtils.stripEnd(\"  abc\", null)    = \"  abc\"\n+     * StringUtils.stripEnd(\"abc  \", null)    = \"abc\"\n+     * StringUtils.stripEnd(\" abc \", null)    = \" abc\"\n+     * StringUtils.stripEnd(\"  abcyx\", \"xyz\") = \"  abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String stripEnd(String str, String stripChars) {\n+        int end;\n+        if (str == null || (end = str.length()) == 0) {\n+            return str;\n+        }\n+\n+        if (stripChars == null) {\n+            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n+                end--;\n+            }\n+        } else if (stripChars.length() == 0) {\n+            return str;\n+        } else {\n+            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != -1)) {\n+                end--;\n+            }\n+        }\n+        return str.substring(0, end);\n+    }\n+\n+    // StripAll\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Strips whitespace from the start and end of every String in an array.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A new array is returned each time, except for length zero.\n+     * A <code>null</code> array will return <code>null</code>.\n+     * An empty array will return itself.\n+     * A <code>null</code> array entry will be ignored.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripAll(null)             = null\n+     * StringUtils.stripAll([])               = []\n+     * StringUtils.stripAll([\"abc\", \"  abc\"]) = [\"abc\", \"abc\"]\n+     * StringUtils.stripAll([\"abc  \", null])  = [\"abc\", null]\n+     * </pre>\n+     *\n+     * @param strs  the array to remove whitespace from, may be null\n+     * @return the stripped Strings, <code>null</code> if null array input\n+     */\n+    public static String[] stripAll(String[] strs) {\n+        return stripAll(strs, null);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start and end of every\n+     * String in an array.</p>\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A new array is returned each time, except for length zero.\n+     * A <code>null</code> array will return <code>null</code>.\n+     * An empty array will return itself.\n+     * A <code>null</code> array entry will be ignored.\n+     * A <code>null</code> stripChars will strip whitespace as defined by\n+     * {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripAll(null, *)                = null\n+     * StringUtils.stripAll([], *)                  = []\n+     * StringUtils.stripAll([\"abc\", \"  abc\"], null) = [\"abc\", \"abc\"]\n+     * StringUtils.stripAll([\"abc  \", null], null)  = [\"abc\", null]\n+     * StringUtils.stripAll([\"abc  \", null], \"yz\")  = [\"abc  \", null]\n+     * StringUtils.stripAll([\"yabcz\", null], \"yz\")  = [\"abc\", null]\n+     * </pre>\n+     *\n+     * @param strs  the array to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped Strings, <code>null</code> if null array input\n+     */\n+    public static String[] stripAll(String[] strs, String stripChars) {\n+        int strsLen;\n+        if (strs == null || (strsLen = strs.length) == 0) {\n+            return strs;\n+        }\n+        String[] newArr = new String[strsLen];\n+        for (int i = 0; i < strsLen; i++) {\n+            newArr[i] = strip(strs[i], stripChars);\n+        }\n+        return newArr;\n+    }\n+\n+    // Equals\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two Strings, returning <code>true</code> if they are equal.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case sensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.equals(null, null)   = true\n+     * StringUtils.equals(null, \"abc\")  = false\n+     * StringUtils.equals(\"abc\", null)  = false\n+     * StringUtils.equals(\"abc\", \"abc\") = true\n+     * StringUtils.equals(\"abc\", \"ABC\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#equals(Object)\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return <code>true</code> if the Strings are equal, case sensitive, or\n+     *  both <code>null</code>\n+     */\n+    public static boolean equals(String str1, String str2) {\n+        return str1 == null ? str2 == null : str1.equals(str2);\n+    }\n+\n+    /**\n+     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n+     * the case.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered equal. Comparison is case insensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.equalsIgnoreCase(null, null)   = true\n+     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n+     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n+     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n+     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n+     * </pre>\n+     *\n+     * @see java.lang.String#equalsIgnoreCase(String)\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return <code>true</code> if the Strings are equal, case insensitive, or\n+     *  both <code>null</code>\n+     */\n+    public static boolean equalsIgnoreCase(String str1, String str2) {\n+        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n+    }\n+\n+    // IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *)         = -1\n+     * StringUtils.indexOf(\"\", *)           = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'a') = 0\n+     * StringUtils.indexOf(\"aabaabaa\", 'b') = 2\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return the first index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.indexOf(searchChar);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String from a start position,\n+     * handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int, int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.\n+     * A negative start position is treated as zero.\n+     * A start position greater than the string length returns <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *, *)          = -1\n+     * StringUtils.indexOf(\"\", *, *)            = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 0)  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 3)  = 5\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 9)  = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, char searchChar, int startPos) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.indexOf(searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *)          = -1\n+     * StringUtils.indexOf(*, null)          = -1\n+     * StringUtils.indexOf(\"\", \"\")           = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"a\")  = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\")  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"ab\") = 1\n+     * StringUtils.indexOf(\"aabaabaa\", \"\")   = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.indexOf(searchStr);\n+    }\n+\n+    /**\n+     * <p>Finds the n-th index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.ordinalIndexOf(null, *, *)          = -1\n+     * StringUtils.ordinalIndexOf(*, null, *)          = -1\n+     * StringUtils.ordinalIndexOf(\"\", \"\", *)           = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1)  = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2)  = 1\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1)  = 2\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2)  = 5\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) = 1\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) = 4\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1)   = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param ordinal  the n-th <code>searchStr</code> to find\n+     * @return the n-th index of the search String,\n+     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n+     * @since 2.1\n+     */\n+    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n+        if (str == null || searchStr == null || ordinal <= 0) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (searchStr.length() == 0) {\n+            return 0;\n+        }\n+        int found = 0;\n+        int index = INDEX_NOT_FOUND;\n+        do {\n+            index = str.indexOf(searchStr, index + 1);\n+            if (index < 0) {\n+                return index;\n+            }\n+            found++;\n+        } while (found < ordinal);\n+        return index;\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String, int)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position is treated as zero.\n+     * An empty (\"\") search String always matches.\n+     * A start position greater than the string length only matches\n+     * an empty search String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *, *)          = -1\n+     * StringUtils.indexOf(*, null, *)          = -1\n+     * StringUtils.indexOf(\"\", \"\", 0)           = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"a\", 0)  = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 0)  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) = 1\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 3)  = 5\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 9)  = -1\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", -1) = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"\", 2)   = 2\n+     * StringUtils.indexOf(\"abc\", \"\", 9)        = 3\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        // JDK1.2/JDK1.3 have a bug, when startPos > str.length for \"\", hence\n+        if (searchStr.length() == 0 && startPos >= str.length()) {\n+            return str.length();\n+        }\n+        return str.indexOf(searchStr, startPos);\n+    }\n+\n+    // LastIndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the last index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *)         = -1\n+     * StringUtils.lastIndexOf(\"\", *)           = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'a') = 7\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return the last index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchChar);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a String from a start position,\n+     * handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(int, int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.\n+     * A negative start position returns <code>-1</code>.\n+     * A start position greater than the string length searches the whole string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *, *)          = -1\n+     * StringUtils.lastIndexOf(\"\", *,  *)           = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 8)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 4)  = 2\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 0)  = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1) = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @param startPos  the start position\n+     * @return the last index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, char searchChar, int startPos) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *)          = -1\n+     * StringUtils.lastIndexOf(*, null)          = -1\n+     * StringUtils.lastIndexOf(\"\", \"\")           = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\")  = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\")  = 2\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\") = 1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"\")   = 8\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the last index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchStr);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(String, int)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position returns <code>-1</code>.\n+     * An empty (\"\") search String always matches unless the start position is negative.\n+     * A start position greater than the string length searches the whole string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *, *)          = -1\n+     * StringUtils.lastIndexOf(*, null, *)          = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8)  = 7\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8) = 4\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1) = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0)  = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchStr, startPos);\n+    }\n+\n+    // Contains\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if String contains a search character, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *)    = false\n+     * StringUtils.contains(\"\", *)      = false\n+     * StringUtils.contains(\"abc\", 'a') = true\n+     * StringUtils.contains(\"abc\", 'z') = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return true if the String contains the search character,\n+     *  false if not or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static boolean contains(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return false;\n+        }\n+        return str.indexOf(searchChar) >= 0;\n+    }\n+\n+    /**\n+     * <p>Checks if String contains a search String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *)     = false\n+     * StringUtils.contains(*, null)     = false\n+     * StringUtils.contains(\"\", \"\")      = true\n+     * StringUtils.contains(\"abc\", \"\")   = true\n+     * StringUtils.contains(\"abc\", \"a\")  = true\n+     * StringUtils.contains(\"abc\", \"z\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return true if the String contains the search String,\n+     *  false if not or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static boolean contains(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return false;\n+        }\n+        return str.indexOf(searchStr) >= 0;\n+    }\n+\n+ /**\n+     * <p>Checks if String contains a search String irrespective of case,\n+     * handling <code>null</code>. This method uses\n+     * {@link #contains(String, String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *) = false\n+     * StringUtils.contains(*, null) = false\n+     * StringUtils.contains(\"\", \"\") = true\n+     * StringUtils.contains(\"abc\", \"\") = true\n+     * StringUtils.contains(\"abc\", \"a\") = true\n+     * StringUtils.contains(\"abc\", \"z\") = false\n+     * StringUtils.contains(\"abc\", \"A\") = true\n+     * StringUtils.contains(\"abc\", \"Z\") = false\n+     * </pre>\n+     *\n+     * @param str the String to check, may be null\n+     * @param searchStr the String to find, may be null\n+     * @return true if the String contains the search String irrespective of\n+     * case or false if not or <code>null</code> string input\n+     */\n+    public static boolean containsIgnoreCase(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return false;\n+        }\n+        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+    } \n+\n+    // IndexOfAny chars\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)                = -1\n+     * StringUtils.indexOfAny(\"\", *)                  = -1\n+     * StringUtils.indexOfAny(*, null)                = -1\n+     * StringUtils.indexOfAny(*, [])                  = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\",['z','a']) = 0\n+     * StringUtils.indexOfAny(\"zzabyycdxx\",['b','y']) = 3\n+     * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAny(String str, char[] searchChars) {\n+        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search string will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)            = -1\n+     * StringUtils.indexOfAny(\"\", *)              = -1\n+     * StringUtils.indexOfAny(*, null)            = -1\n+     * StringUtils.indexOfAny(*, \"\")              = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", \"za\") = 0\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", \"by\") = 3\n+     * StringUtils.indexOfAny(\"aba\",\"z\")          = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAny(String str, String searchChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        return indexOfAny(str, searchChars.toCharArray());\n+    }\n+\n+    // IndexOfAnyBut chars\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAnyBut(null, *)           = -1\n+     * StringUtils.indexOfAnyBut(\"\", *)             = -1\n+     * StringUtils.indexOfAnyBut(*, null)           = -1\n+     * StringUtils.indexOfAnyBut(*, [])             = -1\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\",'za') = 3\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", '')  = 0\n+     * StringUtils.indexOfAnyBut(\"aba\", 'ab')       = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAnyBut(String str, char[] searchChars) {\n+        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        outer : for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    continue outer;\n+                }\n+            }\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search string will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAnyBut(null, *)            = -1\n+     * StringUtils.indexOfAnyBut(\"\", *)              = -1\n+     * StringUtils.indexOfAnyBut(*, null)            = -1\n+     * StringUtils.indexOfAnyBut(*, \"\")              = -1\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = 0\n+     * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAnyBut(String str, String searchChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            if (searchChars.indexOf(str.charAt(i)) < 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    // ContainsOnly\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the String contains only certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.\n+     * A <code>null</code> valid character array will return <code>false</code>.\n+     * An empty String (\"\") always returns <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, *)       = false\n+     * StringUtils.containsOnly(*, null)       = false\n+     * StringUtils.containsOnly(\"\", *)         = true\n+     * StringUtils.containsOnly(\"ab\", '')      = false\n+     * StringUtils.containsOnly(\"abab\", 'abc') = true\n+     * StringUtils.containsOnly(\"ab1\", 'abc')  = false\n+     * StringUtils.containsOnly(\"abz\", 'abc')  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param valid  an array of valid chars, may be null\n+     * @return true if it only contains valid chars and is non-null\n+     */\n+    public static boolean containsOnly(String str, char[] valid) {\n+        // All these pre-checks are to maintain API with an older version\n+        if ((valid == null) || (str == null)) {\n+            return false;\n+        }\n+        if (str.length() == 0) {\n+            return true;\n+        }\n+        if (valid.length == 0) {\n+            return false;\n+        }\n+        return indexOfAnyBut(str, valid) == -1;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.\n+     * A <code>null</code> valid character String will return <code>false</code>.\n+     * An empty String (\"\") always returns <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, *)       = false\n+     * StringUtils.containsOnly(*, null)       = false\n+     * StringUtils.containsOnly(\"\", *)         = true\n+     * StringUtils.containsOnly(\"ab\", \"\")      = false\n+     * StringUtils.containsOnly(\"abab\", \"abc\") = true\n+     * StringUtils.containsOnly(\"ab1\", \"abc\")  = false\n+     * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param validChars  a String of valid chars, may be null\n+     * @return true if it only contains valid chars and is non-null\n+     * @since 2.0\n+     */\n+    public static boolean containsOnly(String str, String validChars) {\n+        if (str == null || validChars == null) {\n+            return false;\n+        }\n+        return containsOnly(str, validChars.toCharArray());\n+    }\n+\n+    // ContainsNone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks that the String does not contain certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>true</code>.\n+     * A <code>null</code> invalid character array will return <code>true</code>.\n+     * An empty String (\"\") always returns true.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsNone(null, *)       = true\n+     * StringUtils.containsNone(*, null)       = true\n+     * StringUtils.containsNone(\"\", *)         = true\n+     * StringUtils.containsNone(\"ab\", '')      = true\n+     * StringUtils.containsNone(\"abab\", 'xyz') = true\n+     * StringUtils.containsNone(\"ab1\", 'xyz')  = true\n+     * StringUtils.containsNone(\"abz\", 'xyz')  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param invalidChars  an array of invalid chars, may be null\n+     * @return true if it contains none of the invalid chars, or is null\n+     * @since 2.0\n+     */\n+    public static boolean containsNone(String str, char[] invalidChars) {\n+        if (str == null || invalidChars == null) {\n+            return true;\n+        }\n+        int strSize = str.length();\n+        int validSize = invalidChars.length;\n+        for (int i = 0; i < strSize; i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < validSize; j++) {\n+                if (invalidChars[j] == ch) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks that the String does not contain certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>true</code>.\n+     * A <code>null</code> invalid character array will return <code>true</code>.\n+     * An empty String (\"\") always returns true.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsNone(null, *)       = true\n+     * StringUtils.containsNone(*, null)       = true\n+     * StringUtils.containsNone(\"\", *)         = true\n+     * StringUtils.containsNone(\"ab\", \"\")      = true\n+     * StringUtils.containsNone(\"abab\", \"xyz\") = true\n+     * StringUtils.containsNone(\"ab1\", \"xyz\")  = true\n+     * StringUtils.containsNone(\"abz\", \"xyz\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param invalidChars  a String of invalid chars, may be null\n+     * @return true if it contains none of the invalid chars, or is null\n+     * @since 2.0\n+     */\n+    public static boolean containsNone(String str, String invalidChars) {\n+        if (str == null || invalidChars == null) {\n+            return true;\n+        }\n+        return containsNone(str, invalidChars.toCharArray());\n+    }\n+\n+    // IndexOfAny strings\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Find the first index of any of a set of potential substrings.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.\n+     * A <code>null</code> search array entry will be ignored, but a search\n+     * array containing \"\" will return <code>0</code> if <code>str</code> is not\n+     * null. This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)                     = -1\n+     * StringUtils.indexOfAny(*, null)                     = -1\n+     * StringUtils.indexOfAny(*, [])                       = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"])   = 2\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"])   = 2\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"])   = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"zab\",\"aby\"]) = 1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"\"])          = 0\n+     * StringUtils.indexOfAny(\"\", [\"\"])                    = 0\n+     * StringUtils.indexOfAny(\"\", [\"a\"])                   = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStrs  the Strings to search for, may be null\n+     * @return the first index of any of the searchStrs in str, -1 if no match\n+     */\n+    public static int indexOfAny(String str, String[] searchStrs) {\n+        if ((str == null) || (searchStrs == null)) {\n+            return -1;\n+        }\n+        int sz = searchStrs.length;\n+\n+        // String's can't have a MAX_VALUEth index.\n+        int ret = Integer.MAX_VALUE;\n+\n+        int tmp = 0;\n+        for (int i = 0; i < sz; i++) {\n+            String search = searchStrs[i];\n+            if (search == null) {\n+                continue;\n+            }\n+            tmp = str.indexOf(search);\n+            if (tmp == -1) {\n+                continue;\n+            }\n+\n+            if (tmp < ret) {\n+                ret = tmp;\n+            }\n+        }\n+\n+        return (ret == Integer.MAX_VALUE) ? -1 : ret;\n+    }\n+\n+    /**\n+     * <p>Find the latest index of any of a set of potential substrings.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search array will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array entry will be ignored,\n+     * but a search array containing \"\" will return the length of <code>str</code>\n+     * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOfAny(null, *)                   = -1\n+     * StringUtils.lastIndexOfAny(*, null)                   = -1\n+     * StringUtils.lastIndexOfAny(*, [])                     = -1\n+     * StringUtils.lastIndexOfAny(*, [null])                 = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"]) = 6\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"]) = 6\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   = 10\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStrs  the Strings to search for, may be null\n+     * @return the last index of any of the Strings, -1 if no match\n+     */\n+    public static int lastIndexOfAny(String str, String[] searchStrs) {\n+        if ((str == null) || (searchStrs == null)) {\n+            return -1;\n+        }\n+        int sz = searchStrs.length;\n+        int ret = -1;\n+        int tmp = 0;\n+        for (int i = 0; i < sz; i++) {\n+            String search = searchStrs[i];\n+            if (search == null) {\n+                continue;\n+            }\n+            tmp = str.lastIndexOf(search);\n+            if (tmp > ret) {\n+                ret = tmp;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    // Substring\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n+     *\n+     * <p>A negative start position can be used to start <code>n</code>\n+     * characters from the end of the String.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>null</code>.\n+     * An empty (\"\") String will return \"\".</p>\n+     *\n+     * <pre>\n+     * StringUtils.substring(null, *)   = null\n+     * StringUtils.substring(\"\", *)     = \"\"\n+     * StringUtils.substring(\"abc\", 0)  = \"abc\"\n+     * StringUtils.substring(\"abc\", 2)  = \"c\"\n+     * StringUtils.substring(\"abc\", 4)  = \"\"\n+     * StringUtils.substring(\"abc\", -2) = \"bc\"\n+     * StringUtils.substring(\"abc\", -4) = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the substring from, may be null\n+     * @param start  the position to start from, negative means\n+     *  count back from the end of the String by this many characters\n+     * @return substring from start position, <code>null</code> if null String input\n+     */\n+    public static String substring(String str, int start) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // handle negatives, which means last n characters\n+        if (start < 0) {\n+            start = str.length() + start; // remember start is negative\n+        }\n+\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (start > str.length()) {\n+            return EMPTY;\n+        }\n+\n+        return str.substring(start);\n+    }\n+\n+    /**\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n+     *\n+     * <p>A negative start position can be used to start/end <code>n</code>\n+     * characters from the end of the String.</p>\n+     *\n+     * <p>The returned substring starts with the character in the <code>start</code>\n+     * position and ends before the <code>end</code> position. All position counting is\n+     * zero-based -- i.e., to start at the beginning of the string use\n+     * <code>start = 0</code>. Negative start and end positions can be used to\n+     * specify offsets relative to the end of the String.</p>\n+     *\n+     * <p>If <code>start</code> is not strictly to the left of <code>end</code>, \"\"\n+     * is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substring(null, *, *)    = null\n+     * StringUtils.substring(\"\", * ,  *)    = \"\";\n+     * StringUtils.substring(\"abc\", 0, 2)   = \"ab\"\n+     * StringUtils.substring(\"abc\", 2, 0)   = \"\"\n+     * StringUtils.substring(\"abc\", 2, 4)   = \"c\"\n+     * StringUtils.substring(\"abc\", 4, 6)   = \"\"\n+     * StringUtils.substring(\"abc\", 2, 2)   = \"\"\n+     * StringUtils.substring(\"abc\", -2, -1) = \"b\"\n+     * StringUtils.substring(\"abc\", -4, 2)  = \"ab\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the substring from, may be null\n+     * @param start  the position to start from, negative means\n+     *  count back from the end of the String by this many characters\n+     * @param end  the position to end at (exclusive), negative means\n+     *  count back from the end of the String by this many characters\n+     * @return substring from start position to end positon,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String substring(String str, int start, int end) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // handle negatives\n+        if (end < 0) {\n+            end = str.length() + end; // remember end is negative\n+        }\n+        if (start < 0) {\n+            start = str.length() + start; // remember start is negative\n+        }\n+\n+        // check length next\n+        if (end > str.length()) {\n+            end = str.length();\n+        }\n+\n+        // if start is greater than end, return \"\"\n+        if (start > end) {\n+            return EMPTY;\n+        }\n+\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (end < 0) {\n+            end = 0;\n+        }\n+\n+        return str.substring(start, end);\n+    }\n+\n+    // Left/Right/Mid\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the leftmost <code>len</code> characters of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, or the\n+     * String is <code>null</code>, the String will be returned without\n+     * an exception. An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.left(null, *)    = null\n+     * StringUtils.left(*, -ve)     = \"\"\n+     * StringUtils.left(\"\", *)      = \"\"\n+     * StringUtils.left(\"abc\", 0)   = \"\"\n+     * StringUtils.left(\"abc\", 2)   = \"ab\"\n+     * StringUtils.left(\"abc\", 4)   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the leftmost characters from, may be null\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the leftmost characters, <code>null</code> if null String input\n+     */\n+    public static String left(String str, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0) {\n+            return EMPTY;\n+        }\n+        if (str.length() <= len) {\n+            return str;\n+        } else {\n+            return str.substring(0, len);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the rightmost <code>len</code> characters of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, or the String\n+     * is <code>null</code>, the String will be returned without an\n+     * an exception. An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.right(null, *)    = null\n+     * StringUtils.right(*, -ve)     = \"\"\n+     * StringUtils.right(\"\", *)      = \"\"\n+     * StringUtils.right(\"abc\", 0)   = \"\"\n+     * StringUtils.right(\"abc\", 2)   = \"bc\"\n+     * StringUtils.right(\"abc\", 4)   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the rightmost characters from, may be null\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the rightmost characters, <code>null</code> if null String input\n+     */\n+    public static String right(String str, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0) {\n+            return EMPTY;\n+        }\n+        if (str.length() <= len) {\n+            return str;\n+        } else {\n+            return str.substring(str.length() - len);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets <code>len</code> characters from the middle of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, the remainder\n+     * of the String will be returned without an exception. If the\n+     * String is <code>null</code>, <code>null</code> will be returned.\n+     * An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.mid(null, *, *)    = null\n+     * StringUtils.mid(*, *, -ve)     = \"\"\n+     * StringUtils.mid(\"\", 0, *)      = \"\"\n+     * StringUtils.mid(\"abc\", 0, 2)   = \"ab\"\n+     * StringUtils.mid(\"abc\", 0, 4)   = \"abc\"\n+     * StringUtils.mid(\"abc\", 2, 4)   = \"c\"\n+     * StringUtils.mid(\"abc\", 4, 2)   = \"\"\n+     * StringUtils.mid(\"abc\", -2, 2)  = \"ab\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the characters from, may be null\n+     * @param pos  the position to start from, negative treated as zero\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the middle characters, <code>null</code> if null String input\n+     */\n+    public static String mid(String str, int pos, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0 || pos > str.length()) {\n+            return EMPTY;\n+        }\n+        if (pos < 0) {\n+            pos = 0;\n+        }\n+        if (str.length() <= (pos + len)) {\n+            return str.substring(pos);\n+        } else {\n+            return str.substring(pos, pos + len);\n+        }\n+    }\n+\n+    // SubStringAfter/SubStringBefore\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the substring before the first occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * A <code>null</code> separator will return the input string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBefore(null, *)      = null\n+     * StringUtils.substringBefore(\"\", *)        = \"\"\n+     * StringUtils.substringBefore(\"abc\", \"a\")   = \"\"\n+     * StringUtils.substringBefore(\"abcba\", \"b\") = \"a\"\n+     * StringUtils.substringBefore(\"abc\", \"c\")   = \"ab\"\n+     * StringUtils.substringBefore(\"abc\", \"d\")   = \"abc\"\n+     * StringUtils.substringBefore(\"abc\", \"\")    = \"\"\n+     * StringUtils.substringBefore(\"abc\", null)  = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring before the first occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringBefore(String str, String separator) {\n+        if (isEmpty(str) || separator == null) {\n+            return str;\n+        }\n+        if (separator.length() == 0) {\n+            return EMPTY;\n+        }\n+        int pos = str.indexOf(separator);\n+        if (pos == -1) {\n+            return str;\n+        }\n+        return str.substring(0, pos);\n+    }\n+\n+    /**\n+     * <p>Gets the substring after the first occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * A <code>null</code> separator will return the empty string if the\n+     * input string is not <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringAfter(null, *)      = null\n+     * StringUtils.substringAfter(\"\", *)        = \"\"\n+     * StringUtils.substringAfter(*, null)      = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"a\")   = \"bc\"\n+     * StringUtils.substringAfter(\"abcba\", \"b\") = \"cba\"\n+     * StringUtils.substringAfter(\"abc\", \"c\")   = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"d\")   = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring after the first occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringAfter(String str, String separator) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        if (separator == null) {\n+            return EMPTY;\n+        }\n+        int pos = str.indexOf(separator);\n+        if (pos == -1) {\n+            return EMPTY;\n+        }\n+        return str.substring(pos + separator.length());\n+    }\n+\n+    /**\n+     * <p>Gets the substring before the last occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * An empty or <code>null</code> separator will return the input string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBeforeLast(null, *)      = null\n+     * StringUtils.substringBeforeLast(\"\", *)        = \"\"\n+     * StringUtils.substringBeforeLast(\"abcba\", \"b\") = \"abc\"\n+     * StringUtils.substringBeforeLast(\"abc\", \"c\")   = \"ab\"\n+     * StringUtils.substringBeforeLast(\"a\", \"a\")     = \"\"\n+     * StringUtils.substringBeforeLast(\"a\", \"z\")     = \"a\"\n+     * StringUtils.substringBeforeLast(\"a\", null)    = \"a\"\n+     * StringUtils.substringBeforeLast(\"a\", \"\")      = \"a\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring before the last occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringBeforeLast(String str, String separator) {\n+        if (isEmpty(str) || isEmpty(separator)) {\n+            return str;\n+        }\n+        int pos = str.lastIndexOf(separator);\n+        if (pos == -1) {\n+            return str;\n+        }\n+        return str.substring(0, pos);\n+    }\n+\n+    /**\n+     * <p>Gets the substring after the last occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * An empty or <code>null</code> separator will return the empty string if\n+     * the input string is not <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringAfterLast(null, *)      = null\n+     * StringUtils.substringAfterLast(\"\", *)        = \"\"\n+     * StringUtils.substringAfterLast(*, \"\")        = \"\"\n+     * StringUtils.substringAfterLast(*, null)      = \"\"\n+     * StringUtils.substringAfterLast(\"abc\", \"a\")   = \"bc\"\n+     * StringUtils.substringAfterLast(\"abcba\", \"b\") = \"a\"\n+     * StringUtils.substringAfterLast(\"abc\", \"c\")   = \"\"\n+     * StringUtils.substringAfterLast(\"a\", \"a\")     = \"\"\n+     * StringUtils.substringAfterLast(\"a\", \"z\")     = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring after the last occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringAfterLast(String str, String separator) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        if (isEmpty(separator)) {\n+            return EMPTY;\n+        }\n+        int pos = str.lastIndexOf(separator);\n+        if (pos == -1 || pos == (str.length() - separator.length())) {\n+            return EMPTY;\n+        }\n+        return str.substring(pos + separator.length());\n+    }\n+\n+    // Substring between\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the String that is nested in between two instances of the\n+     * same String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> tag returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBetween(null, *)            = null\n+     * StringUtils.substringBetween(\"\", \"\")             = \"\"\n+     * StringUtils.substringBetween(\"\", \"tag\")          = null\n+     * StringUtils.substringBetween(\"tagabctag\", null)  = null\n+     * StringUtils.substringBetween(\"tagabctag\", \"\")    = \"\"\n+     * StringUtils.substringBetween(\"tagabctag\", \"tag\") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing the substring, may be null\n+     * @param tag  the String before and after the substring, may be null\n+     * @return the substring, <code>null</code> if no match\n+     * @since 2.0\n+     */\n+    public static String substringBetween(String str, String tag) {\n+        return substringBetween(str, tag, tag);\n+    }\n+\n+    /**\n+     * <p>Gets the String that is nested in between two Strings.\n+     * Only the first match is returned.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> open/close returns <code>null</code> (no match).\n+     * An empty (\"\") open/close returns an empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBetween(null, *, *)          = null\n+     * StringUtils.substringBetween(\"\", \"\", \"\")          = \"\"\n+     * StringUtils.substringBetween(\"\", \"\", \"tag\")       = null\n+     * StringUtils.substringBetween(\"\", \"tag\", \"tag\")    = null\n+     * StringUtils.substringBetween(\"yabcz\", null, null) = null\n+     * StringUtils.substringBetween(\"yabcz\", \"\", \"\")     = \"\"\n+     * StringUtils.substringBetween(\"yabcz\", \"y\", \"z\")   = \"abc\"\n+     * StringUtils.substringBetween(\"yabczyabcz\", \"y\", \"z\")   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing the substring, may be null\n+     * @param open  the String before the substring, may be null\n+     * @param close  the String after the substring, may be null\n+     * @return the substring, <code>null</code> if no match\n+     * @since 2.0\n+     */\n+    public static String substringBetween(String str, String open, String close) {\n+        if (str == null || open == null || close == null) {\n+            return null;\n+        }\n+        int start = str.indexOf(open);\n+        if (start != -1) {\n+            int end = str.indexOf(close, start + open.length());\n+            if (end != -1) {\n+                return str.substring(start + open.length(), end);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Nested extraction\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the String that is nested in between two instances of the\n+     * same String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> tag returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.getNestedString(null, *)            = null\n+     * StringUtils.getNestedString(\"\", \"\")             = \"\"\n+     * StringUtils.getNestedString(\"\", \"tag\")          = null\n+     * StringUtils.getNestedString(\"tagabctag\", null)  = null\n+     * StringUtils.getNestedString(\"tagabctag\", \"\")    = \"\"\n+     * StringUtils.getNestedString(\"tagabctag\", \"tag\") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing nested-string, may be null\n+     * @param tag  the String before and after nested-string, may be null\n+     * @return the nested String, <code>null</code> if no match\n+     * @deprecated Use the better named {@link #substringBetween(String, String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String getNestedString(String str, String tag) {\n+        return substringBetween(str, tag, tag);\n+    }\n+\n+    /**\n+     * <p>Gets the String that is nested in between two Strings.\n+     * Only the first match is returned.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> open/close returns <code>null</code> (no match).\n+     * An empty (\"\") open/close returns an empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.getNestedString(null, *, *)          = null\n+     * StringUtils.getNestedString(\"\", \"\", \"\")          = \"\"\n+     * StringUtils.getNestedString(\"\", \"\", \"tag\")       = null\n+     * StringUtils.getNestedString(\"\", \"tag\", \"tag\")    = null\n+     * StringUtils.getNestedString(\"yabcz\", null, null) = null\n+     * StringUtils.getNestedString(\"yabcz\", \"\", \"\")     = \"\"\n+     * StringUtils.getNestedString(\"yabcz\", \"y\", \"z\")   = \"abc\"\n+     * StringUtils.getNestedString(\"yabczyabcz\", \"y\", \"z\")   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing nested-string, may be null\n+     * @param open  the String before nested-string, may be null\n+     * @param close  the String after nested-string, may be null\n+     * @return the nested String, <code>null</code> if no match\n+     * @deprecated Use the better named {@link #substringBetween(String, String, String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String getNestedString(String str, String open, String close) {\n+        return substringBetween(str, open, close);\n+    }\n+\n+    // Splitting\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Splits the provided text into an array, using whitespace as the\n+     * separator.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null)       = null\n+     * StringUtils.split(\"\")         = []\n+     * StringUtils.split(\"abc def\")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc  def\") = [\"abc\", \"def\"]\n+     * StringUtils.split(\" abc \")    = [\"abc\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str) {\n+        return split(str, null, -1);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator specified.\n+     * This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *)         = null\n+     * StringUtils.split(\"\", *)           = []\n+     * StringUtils.split(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a..b.c\", '.')   = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a:b:c\", '.')    = [\"a:b:c\"]\n+     * StringUtils.split(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChar  the character used as the delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String[] split(String str, char separatorChar) {\n+        return splitWorker(str, separatorChar, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separators specified.\n+     * This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *)         = null\n+     * StringUtils.split(\"\", *)           = []\n+     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, String separatorChars) {\n+        return splitWorker(str, separatorChars, -1, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array with a maximum length,\n+     * separators specified.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <p>If more than <code>max</code> delimited substrings are found, the last\n+     * returned string includes all characters after the first <code>max - 1</code>\n+     * returned strings (including separator characters).</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *, *)            = null\n+     * StringUtils.split(\"\", *, *)              = []\n+     * StringUtils.split(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, String separatorChars, int max) {\n+        return splitWorker(str, separatorChars, max, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.</p>\n+     *\n+     * <p>The separator(s) will not be included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparator(null, *)               = null\n+     * StringUtils.splitByWholeSeparator(\"\", *)                 = []\n+     * StringUtils.splitByWholeSeparator(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null)    = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     */\n+    public static String[] splitByWholeSeparator(String str, String separator) {\n+        return splitByWholeSeparator( str, separator, -1 ) ;\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.\n+     * Returns a maximum of <code>max</code> substrings.</p>\n+     *\n+     * <p>The separator(s) will not be included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparator(null, *, *)               = null\n+     * StringUtils.splitByWholeSeparator(\"\", *, *)                 = []\n+     * StringUtils.splitByWholeSeparator(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null, 0)    = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     */\n+    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        int len = str.length() ;\n+\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+\n+        if ( ( separator == null ) || ( \"\".equals( separator ) ) ) {\n+            // Split on whitespace.\n+            return split( str, null, max ) ;\n+        }\n+\n+\n+        int separatorLength = separator.length() ;\n+\n+        ArrayList substrings = new ArrayList() ;\n+        int numberOfSubstrings = 0 ;\n+        int beg = 0 ;\n+        int end = 0 ;\n+        while ( end < len ) {\n+            end = str.indexOf( separator, beg ) ;\n+\n+            if ( end > -1 ) {\n+                if ( end > beg ) {\n+                    numberOfSubstrings += 1 ;\n+\n+                    if ( numberOfSubstrings == max ) {\n+                        end = len ;\n+                        substrings.add( str.substring( beg ) ) ;\n+                    } else {\n+                        // The following is OK, because String.substring( beg, end ) excludes\n+                        // the character at the position 'end'.\n+                        substrings.add( str.substring( beg, end ) ) ;\n+\n+                        // Set the starting point for the next search.\n+                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n+                        // which is the right calculation:\n+                        beg = end + separatorLength ;\n+                    }\n+                } else {\n+                    // We found a consecutive occurrence of the separator, so skip it.\n+                    beg = end + separatorLength ;\n+                }\n+            } else {\n+                // String.substring( beg ) goes from 'beg' to the end of the String.\n+                substrings.add( str.substring( beg ) ) ;\n+                end = len ;\n+            }\n+        }\n+\n+        return (String[]) substrings.toArray( new String[substrings.size()] ) ;\n+    }\n+\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Splits the provided text into an array, using whitespace as the\n+     * separator, preserving all tokens, including empty tokens created by \n+     * adjacent separators. This is an alternative to using StringTokenizer.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null)       = null\n+     * StringUtils.splitPreserveAllTokens(\"\")         = []\n+     * StringUtils.splitPreserveAllTokens(\"abc def\")  = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc  def\") = [\"abc\", \"\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\" abc \")    = [\"\", \"abc\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str) {\n+        return splitWorker(str, null, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator specified,\n+     * preserving all tokens, including empty tokens created by adjacent\n+     * separators. This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *)         = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *)           = []\n+     * StringUtils.splitPreserveAllTokens(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a..b.c\", '.')   = [\"a\", \"\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a:b:c\", '.')    = [\"a:b:c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c  \", ' ')   = [\"a\", \"b\", \"c\", \"\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\" a b c\", ' ')   = [\"\", a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"  a b c\", ' ')  = [\"\", \"\", a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\" a b c \", ' ')  = [\"\", a\", \"b\", \"c\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChar  the character used as the delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n+        return splitWorker(str, separatorChar, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>split</code> and \n+     * <code>splitPreserveAllTokens</code> methods that do not return a\n+     * maximum array length.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChar the separate character\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        List list = new ArrayList();\n+        int i = 0, start = 0;\n+        boolean match = false;\n+        boolean lastMatch = false;\n+        while (i < len) {\n+            if (str.charAt(i) == separatorChar) {\n+                if (match || preserveAllTokens) {\n+                    list.add(str.substring(start, i));\n+                    match = false;\n+                    lastMatch = true;\n+                }\n+                start = ++i;\n+                continue;\n+            } else {\n+                lastMatch = false;\n+            }\n+            match = true;\n+            i++;\n+        }\n+        if (match || (preserveAllTokens && lastMatch)) {\n+            list.add(str.substring(start, i));\n+        }\n+        return (String[]) list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separators specified, \n+     * preserving all tokens, including empty tokens created by adjacent\n+     * separators. This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *)           = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *)             = []\n+     * StringUtils.splitPreserveAllTokens(\"abc def\", null)   = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc def\", \" \")    = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc  def\", \" \")   = [\"abc\", \"\", def\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\")   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef:\", \":\")  = [\"ab\", \"cd\", \"ef\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef::\", \":\") = [\"ab\", \"cd\", \"ef\", \"\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab::cd:ef\", \":\")  = [\"ab\", \"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\":cd:ef\", \":\")     = [\"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"::cd:ef\", \":\")    = [\"\", \"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\":cd:ef:\", \":\")    = [\"\", cd\", \"ef\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n+        return splitWorker(str, separatorChars, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array with a maximum length,\n+     * separators specified, preserving all tokens, including empty tokens \n+     * created by adjacent separators.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <p>If more than <code>max</code> delimited substrings are found, the last\n+     * returned string includes all characters after the first <code>max - 1</code>\n+     * returned strings (including separator characters).</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *, *)            = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *, *)              = []\n+     * StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) = [\"ab\", \"  de fg\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) = [\"ab\", \"\", \" de fg\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) = [\"ab\", \"\", \"\", \"de fg\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n+        return splitWorker(str, separatorChars, max, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>split</code> and \n+     * <code>splitPreserveAllTokens</code> methods that return a maximum array \n+     * length.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars the separate character\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit.\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+        // Direct code is quicker than StringTokenizer.\n+        // Also, StringTokenizer uses isSpace() not isWhitespace()\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        List list = new ArrayList();\n+        int sizePlus1 = 1;\n+        int i = 0, start = 0;\n+        boolean match = false;\n+        boolean lastMatch = false;\n+        if (separatorChars == null) {\n+            // Null separator means use whitespace\n+            while (i < len) {\n+                if (Character.isWhitespace(str.charAt(i))) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                } else {\n+                    lastMatch = false;\n+                }\n+                match = true;\n+                i++;\n+            }\n+        } else if (separatorChars.length() == 1) {\n+            // Optimise 1 character case\n+            char sep = separatorChars.charAt(0);\n+            while (i < len) {\n+                if (str.charAt(i) == sep) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                } else {\n+                    lastMatch = false;\n+                }\n+                match = true;\n+                i++;\n+            }\n+        } else {\n+            // standard case\n+            while (i < len) {\n+                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                } else {\n+                    lastMatch = false;\n+                }\n+                match = true;\n+                i++;\n+            }\n+        }\n+        if (match || (preserveAllTokens && lastMatch)) {\n+            list.add(str.substring(start, i));\n+        }\n+        return (String[]) list.toArray(new String[list.size()]);\n+    }\n+\n+    // Joining\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Concatenates elements of an array into a single String.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.concatenate(null)            = null\n+     * StringUtils.concatenate([])              = \"\"\n+     * StringUtils.concatenate([null])          = \"\"\n+     * StringUtils.concatenate([\"a\", \"b\", \"c\"]) = \"abc\"\n+     * StringUtils.concatenate([null, \"\", \"a\"]) = \"a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to concatenate, may be null\n+     * @return the concatenated String, <code>null</code> if null array input\n+     * @deprecated Use the better named {@link #join(Object[])} instead.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String concatenate(Object[] array) {\n+        return join(array, null);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No separator is added to the joined String.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null)            = null\n+     * StringUtils.join([])              = \"\"\n+     * StringUtils.join([null])          = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"]) = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"]) = \"a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @return the joined String, <code>null</code> if null array input\n+     * @since 2.0\n+     */\n+    public static String join(Object[] array) {\n+        return join(array, null);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)               = null\n+     * StringUtils.join([], *)                 = \"\"\n+     * StringUtils.join([null], *)             = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null array input\n+     * @since 2.0\n+     */\n+    public static String join(Object[] array, char separator) {\n+        if (array == null) {\n+            return null;\n+        }\n+        int arraySize = array.length;\n+        int bufSize = (arraySize == 0 ? 0 : ((array[0] == null ? 16 : array[0].toString().length()) + 1) * arraySize);\n+        StringBuffer buf = new StringBuffer(bufSize);\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            if (i > 0) {\n+                buf.append(separator);\n+            }\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)                = null\n+     * StringUtils.join([], *)                  = \"\"\n+     * StringUtils.join([null], *)              = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null array input\n+     */\n+    public static String join(Object[] array, String separator) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (separator == null) {\n+            separator = EMPTY;\n+        }\n+        int arraySize = array.length;\n+\n+        // ArraySize ==  0: Len = 0\n+        // ArraySize > 0:   Len = NofStrings *(len(firstString) + len(separator))\n+        //           (Assuming that all Strings are roughly equally long)\n+        int bufSize =\n+            ((arraySize == 0)\n+                ? 0\n+                : arraySize\n+                    * ((array[0] == null ? 16 : array[0].toString().length())\n+                        + separator.length()));\n+\n+        StringBuffer buf = new StringBuffer(bufSize);\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            if (i > 0) {\n+                buf.append(separator);\n+            }\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterator</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list. Null objects or empty\n+     * strings within the iteration are represented by empty strings.</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n+     *\n+     * @param iterator  the <code>Iterator</code> of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null iterator input\n+     * @since 2.0\n+     */\n+    public static String join(Iterator iterator, char separator) {\n+        if (iterator == null) {\n+            return null;\n+        }\n+        StringBuffer buf = new StringBuffer(256); // Java default is 16, probably too small\n+        while (iterator.hasNext()) {\n+            Object obj = iterator.next();\n+            if (obj != null) {\n+                buf.append(obj);\n+            }\n+            if (iterator.hasNext()) {\n+                buf.append(separator);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterator</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n+     *\n+     * @param iterator  the <code>Iterator</code> of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null iterator input\n+     */\n+    public static String join(Iterator iterator, String separator) {\n+        if (iterator == null) {\n+            return null;\n+        }\n+        StringBuffer buf = new StringBuffer(256); // Java default is 16, probably too small\n+        while (iterator.hasNext()) {\n+            Object obj = iterator.next();\n+            if (obj != null) {\n+                buf.append(obj);\n+            }\n+            if ((separator != null) && iterator.hasNext()) {\n+                buf.append(separator);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    // Delete\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deletes all 'space' characters from a String as defined by\n+     * {@link Character#isSpace(char)}.</p>\n+     *\n+     * <p>This is the only StringUtils method that uses the\n+     * <code>isSpace</code> definition. You are advised to use\n+     * {@link #deleteWhitespace(String)} instead as whitespace is much\n+     * better localized.</p>\n+     *\n+     * <pre>\n+     * StringUtils.deleteSpaces(null)           = null\n+     * StringUtils.deleteSpaces(\"\")             = \"\"\n+     * StringUtils.deleteSpaces(\"abc\")          = \"abc\"\n+     * StringUtils.deleteSpaces(\" \\t  abc \\n \") = \"abc\"\n+     * StringUtils.deleteSpaces(\"ab  c\")        = \"abc\"\n+     * StringUtils.deleteSpaces(\"a\\nb\\tc     \") = \"abc\"\n+     * </pre>\n+     *\n+     * <p>Spaces are defined as <code>{' ', '\\t', '\\r', '\\n', '\\b'}</code>\n+     * in line with the deprecated <code>isSpace</code> method.</p>\n+     *\n+     * @param str  the String to delete spaces from, may be null\n+     * @return the String without 'spaces', <code>null</code> if null String input\n+     * @deprecated Use the better localized {@link #deleteWhitespace(String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String deleteSpaces(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return CharSetUtils.delete(str, \" \\t\\r\\n\\b\");\n+    }\n+\n+    /**\n+     * <p>Deletes all whitespaces from a String as defined by\n+     * {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.deleteWhitespace(null)         = null\n+     * StringUtils.deleteWhitespace(\"\")           = \"\"\n+     * StringUtils.deleteWhitespace(\"abc\")        = \"abc\"\n+     * StringUtils.deleteWhitespace(\"   ab  c  \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to delete whitespace from, may be null\n+     * @return the String without whitespaces, <code>null</code> if null String input\n+     */\n+    public static String deleteWhitespace(String str) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        int sz = str.length();\n+        char[] chs = new char[sz];\n+        int count = 0;\n+        for (int i = 0; i < sz; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                chs[count++] = str.charAt(i);\n+            }\n+        }\n+        if (count == sz) {\n+            return str;\n+        }\n+        return new String(chs, 0, count);\n+    }\n+\n+    // Remove\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes a substring only if it is at the begining of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeStart(null, *)      = null\n+     * StringUtils.removeStart(\"\", *)        = \"\"\n+     * StringUtils.removeStart(*, null)      = *\n+     * StringUtils.removeStart(\"www.domain.com\", \"www.\")   = \"domain.com\"\n+     * StringUtils.removeStart(\"domain.com\", \"www.\")       = \"domain.com\"\n+     * StringUtils.removeStart(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeStart(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String removeStart(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (str.startsWith(remove)){\n+            return str.substring(remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Removes a substring only if it is at the end of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeEnd(null, *)      = null\n+     * StringUtils.removeEnd(\"\", *)        = \"\"\n+     * StringUtils.removeEnd(*, null)      = *\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com.\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String removeEnd(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (str.endsWith(remove)) {\n+            return str.substring(0, str.length() - remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Removes all occurances of a substring from within the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> remove string will return the source string.\n+     * An empty (\"\") remove string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.remove(null, *)        = null\n+     * StringUtils.remove(\"\", *)          = \"\"\n+     * StringUtils.remove(*, null)        = *\n+     * StringUtils.remove(*, \"\")          = *\n+     * StringUtils.remove(\"queued\", \"ue\") = \"qd\"\n+     * StringUtils.remove(\"queued\", \"zz\") = \"queued\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String remove(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        return replace(str, remove, \"\", -1);\n+    }\n+\n+    /**\n+     * <p>Removes all occurances of a character from within the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.remove(null, *)       = null\n+     * StringUtils.remove(\"\", *)         = \"\"\n+     * StringUtils.remove(\"queued\", 'u') = \"qeed\"\n+     * StringUtils.remove(\"queued\", 'z') = \"queued\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the char to search for and remove, may be null\n+     * @return the substring with the char removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String remove(String str, char remove) {\n+        if (isEmpty(str) || str.indexOf(remove) == -1) {\n+            return str;\n+        }\n+        char[] chars = str.toCharArray();\n+        int pos = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            if (chars[i] != remove) {\n+                chars[pos++] = chars[i];\n+            }\n+        }\n+        return new String(chars, 0, pos);\n+    }\n+\n+    // Replacing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Replaces a String with another String inside a larger String, once.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceOnce(null, *, *)        = null\n+     * StringUtils.replaceOnce(\"\", *, *)          = \"\"\n+     * StringUtils.replaceOnce(\"any\", null, *)    = \"any\"\n+     * StringUtils.replaceOnce(\"any\", *, null)    = \"any\"\n+     * StringUtils.replaceOnce(\"any\", \"\", *)      = \"any\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", null)  = \"aba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", \"\")    = \"ba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   = \"zba\"\n+     * </pre>\n+     *\n+     * @see #replace(String text, String repl, String with, int max)\n+     * @param text  text to search and replace in, may be null\n+     * @param repl  the String to search for, may be null\n+     * @param with  the String to replace with, may be null\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replaceOnce(String text, String repl, String with) {\n+        return replace(text, repl, with, 1);\n+    }\n+\n+    /**\n+     * <p>Replaces all occurrences of a String within another String.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replace(null, *, *)        = null\n+     * StringUtils.replace(\"\", *, *)          = \"\"\n+     * StringUtils.replace(\"any\", null, *)    = \"any\"\n+     * StringUtils.replace(\"any\", *, null)    = \"any\"\n+     * StringUtils.replace(\"any\", \"\", *)      = \"any\"\n+     * StringUtils.replace(\"aba\", \"a\", null)  = \"aba\"\n+     * StringUtils.replace(\"aba\", \"a\", \"\")    = \"b\"\n+     * StringUtils.replace(\"aba\", \"a\", \"z\")   = \"zbz\"\n+     * </pre>\n+     *\n+     * @see #replace(String text, String repl, String with, int max)\n+     * @param text  text to search and replace in, may be null\n+     * @param repl  the String to search for, may be null\n+     * @param with  the String to replace with, may be null\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replace(String text, String repl, String with) {\n+        return replace(text, repl, with, -1);\n+    }\n+\n+    /**\n+     * <p>Replaces a String with another String inside a larger String,\n+     * for the first <code>max</code> values of the search String.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replace(null, *, *, *)         = null\n+     * StringUtils.replace(\"\", *, *, *)           = \"\"\n+     * StringUtils.replace(\"any\", null, *, *)     = \"any\"\n+     * StringUtils.replace(\"any\", *, null, *)     = \"any\"\n+     * StringUtils.replace(\"any\", \"\", *, *)       = \"any\"\n+     * StringUtils.replace(\"any\", *, *, 0)        = \"any\"\n+     * StringUtils.replace(\"abaa\", \"a\", null, -1) = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"\", -1)   = \"b\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   = \"zbaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   = \"zbza\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  = \"zbzz\"\n+     * </pre>\n+     *\n+     * @param text  text to search and replace in, may be null\n+     * @param repl  the String to search for, may be null\n+     * @param with  the String to replace with, may be null\n+     * @param max  maximum number of values to replace, or <code>-1</code> if no maximum\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replace(String text, String repl, String with, int max) {\n+        if (isEmpty(text) || isEmpty(repl) || with == null || max == 0) {\n+            return text;\n+        }\n+        int start = 0;\n+        int end = text.indexOf(repl, start);\n+        if (end == -1) {\n+            return text;\n+        }\n+        int replLength = repl.length();\n+        int increase = with.length() - replLength;\n+        increase = (increase < 0 ? 0 : increase);\n+        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n+        StringBuffer buf = new StringBuffer(text.length() + increase);\n+        while (end != -1) {\n+            buf.append(text.substring(start, end)).append(with);\n+            start = end + replLength;\n+            if (--max == 0) {\n+                break;\n+            }\n+            end = text.indexOf(repl, start);\n+        }\n+        buf.append(text.substring(start));\n+        return buf.toString();\n+    }\n+\n+    // Replace, character based\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Replaces all occurrences of a character in a String with another.\n+     * This is a null-safe version of {@link String#replace(char, char)}.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * An empty (\"\") string input returns an empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceChars(null, *, *)        = null\n+     * StringUtils.replaceChars(\"\", *, *)          = \"\"\n+     * StringUtils.replaceChars(\"abcba\", 'b', 'y') = \"aycya\"\n+     * StringUtils.replaceChars(\"abcba\", 'z', 'y') = \"abcba\"\n+     * </pre>\n+     *\n+     * @param str  String to replace characters in, may be null\n+     * @param searchChar  the character to search for, may be null\n+     * @param replaceChar  the character to replace, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String replaceChars(String str, char searchChar, char replaceChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.replace(searchChar, replaceChar);\n+    }\n+\n+    /**\n+     * <p>Replaces multiple characters in a String in one go.\n+     * This method can also be used to delete characters.</p>\n+     *\n+     * <p>For example:<br />\n+     * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * An empty (\"\") string input returns an empty string.\n+     * A null or empty set of search characters returns the input string.</p>\n+     *\n+     * <p>The length of the search characters should normally equal the length\n+     * of the replace characters.\n+     * If the search characters is longer, then the extra search characters\n+     * are deleted.\n+     * If the search characters is shorter, then the extra replace characters\n+     * are ignored.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceChars(null, *, *)           = null\n+     * StringUtils.replaceChars(\"\", *, *)             = \"\"\n+     * StringUtils.replaceChars(\"abc\", null, *)       = \"abc\"\n+     * StringUtils.replaceChars(\"abc\", \"\", *)         = \"abc\"\n+     * StringUtils.replaceChars(\"abc\", \"b\", null)     = \"ac\"\n+     * StringUtils.replaceChars(\"abc\", \"b\", \"\")       = \"ac\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\")  = \"ayzya\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"y\")   = \"ayya\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\") = \"ayzya\"\n+     * </pre>\n+     *\n+     * @param str  String to replace characters in, may be null\n+     * @param searchChars  a set of characters to search for, may be null\n+     * @param replaceChars  a set of characters to replace, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String replaceChars(String str, String searchChars, String replaceChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return str;\n+        }\n+        if (replaceChars == null) {\n+            replaceChars = \"\";\n+        }\n+        boolean modified = false;\n+        int replaceCharsLength = replaceChars.length();\n+        int strLength = str.length();\n+        StringBuffer buf = new StringBuffer(strLength);\n+        for (int i = 0; i < strLength; i++) {\n+            char ch = str.charAt(i);\n+            int index = searchChars.indexOf(ch);\n+            if (index >= 0) {\n+                modified = true;\n+                if (index < replaceCharsLength) {\n+                    buf.append(replaceChars.charAt(index));\n+                }\n+            } else {\n+                buf.append(ch);\n+            }\n+        }\n+        if (modified) {\n+            return buf.toString();\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    // Overlay\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Overlays part of a String with another String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.overlayString(null, *, *, *)           = NullPointerException\n+     * StringUtils.overlayString(*, null, *, *)           = NullPointerException\n+     * StringUtils.overlayString(\"\", \"abc\", 0, 0)         = \"abc\"\n+     * StringUtils.overlayString(\"abcdef\", null, 2, 4)    = \"abef\"\n+     * StringUtils.overlayString(\"abcdef\", \"\", 2, 4)      = \"abef\"\n+     * StringUtils.overlayString(\"abcdef\", \"zzzz\", 2, 4)  = \"abzzzzef\"\n+     * StringUtils.overlayString(\"abcdef\", \"zzzz\", 4, 2)  = \"abcdzzzzcdef\"\n+     * StringUtils.overlayString(\"abcdef\", \"zzzz\", -1, 4) = IndexOutOfBoundsException\n+     * StringUtils.overlayString(\"abcdef\", \"zzzz\", 2, 8)  = IndexOutOfBoundsException\n+     * </pre>\n+     *\n+     * @param text  the String to do overlaying in, may be null\n+     * @param overlay  the String to overlay, may be null\n+     * @param start  the position to start overlaying at, must be valid\n+     * @param end  the position to stop overlaying before, must be valid\n+     * @return overlayed String, <code>null</code> if null String input\n+     * @throws NullPointerException if text or overlay is null\n+     * @throws IndexOutOfBoundsException if either position is invalid\n+     * @deprecated Use better named {@link #overlay(String, String, int, int)} instead.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String overlayString(String text, String overlay, int start, int end) {\n+        return new StringBuffer(start + overlay.length() + text.length() - end + 1)\n+            .append(text.substring(0, start))\n+            .append(overlay)\n+            .append(text.substring(end))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Overlays part of a String with another String.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * A negative index is treated as zero.\n+     * An index greater than the string length is treated as the string length.\n+     * The start index is always the smaller of the two indices.</p>\n+     *\n+     * <pre>\n+     * StringUtils.overlay(null, *, *, *)            = null\n+     * StringUtils.overlay(\"\", \"abc\", 0, 0)          = \"abc\"\n+     * StringUtils.overlay(\"abcdef\", null, 2, 4)     = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"\", 2, 4)       = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"\", 4, 2)       = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4)   = \"abzzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2)   = \"abzzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4)  = \"zzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 8)   = \"abzzzz\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -3) = \"zzzzabcdef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10)  = \"abcdefzzzz\"\n+     * </pre>\n+     *\n+     * @param str  the String to do overlaying in, may be null\n+     * @param overlay  the String to overlay, may be null\n+     * @param start  the position to start overlaying at\n+     * @param end  the position to stop overlaying before\n+     * @return overlayed String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String overlay(String str, String overlay, int start, int end) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (overlay == null) {\n+            overlay = EMPTY;\n+        }\n+        int len = str.length();\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (start > len) {\n+            start = len;\n+        }\n+        if (end < 0) {\n+            end = 0;\n+        }\n+        if (end > len) {\n+            end = len;\n+        }\n+        if (start > end) {\n+            int temp = start;\n+            start = end;\n+            end = temp;\n+        }\n+        return new StringBuffer(len + start - end + overlay.length() + 1)\n+            .append(str.substring(0, start))\n+            .append(overlay)\n+            .append(str.substring(end))\n+            .toString();\n+    }\n+\n+    // Chomping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes one newline from end of a String if it's there,\n+     * otherwise leave it alone.  A newline is &quot;<code>\\n</code>&quot;,\n+     * &quot;<code>\\r</code>&quot;, or &quot;<code>\\r\\n</code>&quot;.</p>\n+     *\n+     * <p>NOTE: This method changed in 2.0.\n+     * It now more closely matches Perl chomp.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chomp(null)          = null\n+     * StringUtils.chomp(\"\")            = \"\"\n+     * StringUtils.chomp(\"abc \\r\")      = \"abc \"\n+     * StringUtils.chomp(\"abc\\n\")       = \"abc\"\n+     * StringUtils.chomp(\"abc\\r\\n\")     = \"abc\"\n+     * StringUtils.chomp(\"abc\\r\\n\\r\\n\") = \"abc\\r\\n\"\n+     * StringUtils.chomp(\"abc\\n\\r\")     = \"abc\\n\"\n+     * StringUtils.chomp(\"abc\\n\\rabc\")  = \"abc\\n\\rabc\"\n+     * StringUtils.chomp(\"\\r\")          = \"\"\n+     * StringUtils.chomp(\"\\n\")          = \"\"\n+     * StringUtils.chomp(\"\\r\\n\")        = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to chomp a newline from, may be null\n+     * @return String without newline, <code>null</code> if null String input\n+     */\n+    public static String chomp(String str) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+\n+        if (str.length() == 1) {\n+            char ch = str.charAt(0);\n+            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n+                return EMPTY;\n+            } else {\n+                return str;\n+            }\n+        }\n+\n+        int lastIdx = str.length() - 1;\n+        char last = str.charAt(lastIdx);\n+\n+        if (last == CharUtils.LF) {\n+            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n+                lastIdx--;\n+            }\n+        } else if (last != CharUtils.CR) {\n+            lastIdx++;\n+        }\n+        return str.substring(0, lastIdx);\n+    }\n+\n+    /**\n+     * <p>Removes <code>separator</code> from the end of\n+     * <code>str</code> if it's there, otherwise leave it alone.</p>\n+     *\n+     * <p>NOTE: This method changed in version 2.0.\n+     * It now more closely matches Perl chomp.\n+     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.\n+     * This method uses {@link String#endsWith(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chomp(null, *)         = null\n+     * StringUtils.chomp(\"\", *)           = \"\"\n+     * StringUtils.chomp(\"foobar\", \"bar\") = \"foo\"\n+     * StringUtils.chomp(\"foobar\", \"baz\") = \"foobar\"\n+     * StringUtils.chomp(\"foo\", \"foo\")    = \"\"\n+     * StringUtils.chomp(\"foo \", \"foo\")   = \"foo \"\n+     * StringUtils.chomp(\" foo\", \"foo\")   = \" \"\n+     * StringUtils.chomp(\"foo\", \"foooo\")  = \"foo\"\n+     * StringUtils.chomp(\"foo\", \"\")       = \"foo\"\n+     * StringUtils.chomp(\"foo\", null)     = \"foo\"\n+     * </pre>\n+     *\n+     * @param str  the String to chomp from, may be null\n+     * @param separator  separator String, may be null\n+     * @return String without trailing separator, <code>null</code> if null String input\n+     */\n+    public static String chomp(String str, String separator) {\n+        if (isEmpty(str) || separator == null) {\n+            return str;\n+        }\n+        if (str.endsWith(separator)) {\n+            return str.substring(0, str.length() - separator.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Remove any &quot;\\n&quot; if and only if it is at the end\n+     * of the supplied String.</p>\n+     *\n+     * @param str  the String to chomp from, must not be null\n+     * @return String without chomped ending\n+     * @throws NullPointerException if str is <code>null</code>\n+     * @deprecated Use {@link #chomp(String)} instead.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String chompLast(String str) {\n+        return chompLast(str, \"\\n\");\n+    }\n+\n+    /**\n+     * <p>Remove a value if and only if the String ends with that value.</p>\n+     *\n+     * @param str  the String to chomp from, must not be null\n+     * @param sep  the String to chomp, must not be null\n+     * @return String without chomped ending\n+     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @deprecated Use {@link #chomp(String,String)} instead.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String chompLast(String str, String sep) {\n+        if (str.length() == 0) {\n+            return str;\n+        }\n+        String sub = str.substring(str.length() - sep.length());\n+        if (sep.equals(sub)) {\n+            return str.substring(0, str.length() - sep.length());\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * <p>Remove everything and return the last value of a supplied String, and\n+     * everything after it from a String.</p>\n+     *\n+     * @param str  the String to chomp from, must not be null\n+     * @param sep  the String to chomp, must not be null\n+     * @return String chomped\n+     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @deprecated Use {@link #substringAfterLast(String, String)} instead\n+     *             (although this doesn't include the separator)\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String getChomp(String str, String sep) {\n+        int idx = str.lastIndexOf(sep);\n+        if (idx == str.length() - sep.length()) {\n+            return sep;\n+        } else if (idx != -1) {\n+            return str.substring(idx);\n+        } else {\n+            return EMPTY;\n+        }\n+    }\n+\n+    /**\n+     * <p>Remove the first value of a supplied String, and everything before it\n+     * from a String.</p>\n+     *\n+     * @param str  the String to chomp from, must not be null\n+     * @param sep  the String to chomp, must not be null\n+     * @return String without chomped beginning\n+     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @deprecated Use {@link #substringAfter(String,String)} instead.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String prechomp(String str, String sep) {\n+        int idx = str.indexOf(sep);\n+        if (idx != -1) {\n+            return str.substring(idx + sep.length());\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * <p>Remove and return everything before the first value of a\n+     * supplied String from another String.</p>\n+     *\n+     * @param str  the String to chomp from, must not be null\n+     * @param sep  the String to chomp, must not be null\n+     * @return String prechomped\n+     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @deprecated Use {@link #substringBefore(String,String)} instead\n+     *             (although this doesn't include the separator).\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String getPrechomp(String str, String sep) {\n+        int idx = str.indexOf(sep);\n+        if (idx != -1) {\n+            return str.substring(0, idx + sep.length());\n+        } else {\n+            return EMPTY;\n+        }\n+    }\n+\n+    // Chopping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Remove the last character from a String.</p>\n+     *\n+     * <p>If the String ends in <code>\\r\\n</code>, then remove both\n+     * of them.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chop(null)          = null\n+     * StringUtils.chop(\"\")            = \"\"\n+     * StringUtils.chop(\"abc \\r\")      = \"abc \"\n+     * StringUtils.chop(\"abc\\n\")       = \"abc\"\n+     * StringUtils.chop(\"abc\\r\\n\")     = \"abc\"\n+     * StringUtils.chop(\"abc\")         = \"ab\"\n+     * StringUtils.chop(\"abc\\nabc\")    = \"abc\\nab\"\n+     * StringUtils.chop(\"a\")           = \"\"\n+     * StringUtils.chop(\"\\r\")          = \"\"\n+     * StringUtils.chop(\"\\n\")          = \"\"\n+     * StringUtils.chop(\"\\r\\n\")        = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to chop last character from, may be null\n+     * @return String without last character, <code>null</code> if null String input\n+     */\n+    public static String chop(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int strLen = str.length();\n+        if (strLen < 2) {\n+            return EMPTY;\n+        }\n+        int lastIdx = strLen - 1;\n+        String ret = str.substring(0, lastIdx);\n+        char last = str.charAt(lastIdx);\n+        if (last == CharUtils.LF) {\n+            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n+                return ret.substring(0, lastIdx - 1);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * <p>Removes <code>\\n</code> from end of a String if it's there.\n+     * If a <code>\\r</code> precedes it, then remove that too.</p>\n+     *\n+     * @param str  the String to chop a newline from, must not be null\n+     * @return String without newline\n+     * @throws NullPointerException if str is <code>null</code>\n+     * @deprecated Use {@link #chomp(String)} instead.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String chopNewline(String str) {\n+        int lastIdx = str.length() - 1;\n+        if (lastIdx <= 0) {\n+            return EMPTY;\n+        }\n+        char last = str.charAt(lastIdx);\n+        if (last == CharUtils.LF) {\n+            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n+                lastIdx--;\n+            }\n+        } else {\n+            lastIdx++;\n+        }\n+        return str.substring(0, lastIdx);\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Escapes any values it finds into their String form.</p>\n+     *\n+     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n+     * <code>'t'</code>.</p>\n+     *\n+     * <p>As of Lang 2.0, this calls {@link StringEscapeUtils#escapeJava(String)}\n+     * behind the scenes.\n+     * </p>\n+     * @see StringEscapeUtils#escapeJava(java.lang.String)\n+     * @param str String to escape values in\n+     * @return String with escaped values\n+     * @throws NullPointerException if str is <code>null</code>\n+     * @deprecated Use {@link StringEscapeUtils#escapeJava(String)}\n+     *             This method will be removed in Commons Lang 3.0\n+     */\n+    public static String escape(String str) {\n+        return StringEscapeUtils.escapeJava(str);\n+    }\n+\n+    // Padding\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Repeat a String <code>repeat</code> times to form a\n+     * new String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.repeat(null, 2) = null\n+     * StringUtils.repeat(\"\", 0)   = \"\"\n+     * StringUtils.repeat(\"\", 2)   = \"\"\n+     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n+     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n+     * StringUtils.repeat(\"a\", -2) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to repeat, may be null\n+     * @param repeat  number of times to repeat str, negative treated as zero\n+     * @return a new String consisting of the original String repeated,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String repeat(String str, int repeat) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        if (repeat <= 0) {\n+            return EMPTY;\n+        }\n+        int inputLength = str.length();\n+        if (repeat == 1 || inputLength == 0) {\n+            return str;\n+        }\n+        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n+            return padding(repeat, str.charAt(0));\n+        }\n+\n+        int outputLength = inputLength * repeat;\n+        switch (inputLength) {\n+            case 1 :\n+                char ch = str.charAt(0);\n+                char[] output1 = new char[outputLength];\n+                for (int i = repeat - 1; i >= 0; i--) {\n+                    output1[i] = ch;\n+                }\n+                return new String(output1);\n+            case 2 :\n+                char ch0 = str.charAt(0);\n+                char ch1 = str.charAt(1);\n+                char[] output2 = new char[outputLength];\n+                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n+                    output2[i] = ch0;\n+                    output2[i + 1] = ch1;\n+                }\n+                return new String(output2);\n+            default :\n+                StringBuffer buf = new StringBuffer(outputLength);\n+                for (int i = 0; i < repeat; i++) {\n+                    buf.append(str);\n+                }\n+                return buf.toString();\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns padding using the specified delimiter repeated\n+     * to a given length.</p>\n+     *\n+     * <pre>\n+     * StringUtils.padding(0, 'e')  = \"\"\n+     * StringUtils.padding(3, 'e')  = \"eee\"\n+     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n+     * </pre>\n+     *\n+     * <p>Note: this method doesn't not support padding with\n+     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n+     * as they require a pair of <code>char</code>s to be represented.\n+     * If you are needing to support full I18N of your applications\n+     * consider using {@link #repeat(String, int)} instead. \n+     * </p>\n+     *\n+     * @param repeat  number of times to repeat delim\n+     * @param padChar  character to repeat\n+     * @return String with repeated character\n+     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n+     * @see #repeat(String, int)\n+     */\n+    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n+        if (repeat < 0) {\n+            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n+        }\n+        final char[] buf = new char[repeat];\n+        for (int i = 0; i < buf.length; i++) {\n+            buf[i] = padChar;\n+        }\n+        return new String(buf);\n+    }\n+\n+    /**\n+     * <p>Right pad a String with spaces (' ').</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *)   = null\n+     * StringUtils.rightPad(\"\", 3)     = \"   \"\n+     * StringUtils.rightPad(\"bat\", 3)  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5)  = \"bat  \"\n+     * StringUtils.rightPad(\"bat\", 1)  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1) = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String rightPad(String str, int size) {\n+        return rightPad(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Right pad a String with a specified character.</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *, *)     = null\n+     * StringUtils.rightPad(\"\", 3, 'z')     = \"zzz\"\n+     * StringUtils.rightPad(\"bat\", 3, 'z')  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, 'z')  = \"batzz\"\n+     * StringUtils.rightPad(\"bat\", 1, 'z')  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1, 'z') = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padChar  the character to pad with\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String rightPad(String str, int size, char padChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return rightPad(str, size, String.valueOf(padChar));\n+        }\n+        return str.concat(padding(pads, padChar));\n+    }\n+\n+    /**\n+     * <p>Right pad a String with a specified String.</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *, *)      = null\n+     * StringUtils.rightPad(\"\", 3, \"z\")      = \"zzz\"\n+     * StringUtils.rightPad(\"bat\", 3, \"yz\")  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, \"yz\")  = \"batyz\"\n+     * StringUtils.rightPad(\"bat\", 8, \"yz\")  = \"batyzyzy\"\n+     * StringUtils.rightPad(\"bat\", 1, \"yz\")  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1, \"yz\") = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, null)  = \"bat  \"\n+     * StringUtils.rightPad(\"bat\", 5, \"\")    = \"bat  \"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padStr  the String to pad with, null or empty treated as single space\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String rightPad(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int padLen = padStr.length();\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (padLen == 1 && pads <= PAD_LIMIT) {\n+            return rightPad(str, size, padStr.charAt(0));\n+        }\n+\n+        if (pads == padLen) {\n+            return str.concat(padStr);\n+        } else if (pads < padLen) {\n+            return str.concat(padStr.substring(0, pads));\n+        } else {\n+            char[] padding = new char[pads];\n+            char[] padChars = padStr.toCharArray();\n+            for (int i = 0; i < pads; i++) {\n+                padding[i] = padChars[i % padLen];\n+            }\n+            return str.concat(new String(padding));\n+        }\n+    }\n+\n+    /**\n+     * <p>Left pad a String with spaces (' ').</p>\n+     *\n+     * <p>The String is padded to the size of <code>size<code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *)   = null\n+     * StringUtils.leftPad(\"\", 3)     = \"   \"\n+     * StringUtils.leftPad(\"bat\", 3)  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5)  = \"  bat\"\n+     * StringUtils.leftPad(\"bat\", 1)  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1) = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String leftPad(String str, int size) {\n+        return leftPad(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Left pad a String with a specified character.</p>\n+     *\n+     * <p>Pad to a size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *, *)     = null\n+     * StringUtils.leftPad(\"\", 3, 'z')     = \"zzz\"\n+     * StringUtils.leftPad(\"bat\", 3, 'z')  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, 'z')  = \"zzbat\"\n+     * StringUtils.leftPad(\"bat\", 1, 'z')  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1, 'z') = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padChar  the character to pad with\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String leftPad(String str, int size, char padChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return leftPad(str, size, String.valueOf(padChar));\n+        }\n+        return padding(pads, padChar).concat(str);\n+    }\n+\n+    /**\n+     * <p>Left pad a String with a specified String.</p>\n+     *\n+     * <p>Pad to a size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *, *)      = null\n+     * StringUtils.leftPad(\"\", 3, \"z\")      = \"zzz\"\n+     * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n+     * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n+     * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, null)  = \"  bat\"\n+     * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padStr  the String to pad with, null or empty treated as single space\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String leftPad(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int padLen = padStr.length();\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (padLen == 1 && pads <= PAD_LIMIT) {\n+            return leftPad(str, size, padStr.charAt(0));\n+        }\n+\n+        if (pads == padLen) {\n+            return padStr.concat(str);\n+        } else if (pads < padLen) {\n+            return padStr.substring(0, pads).concat(str);\n+        } else {\n+            char[] padding = new char[pads];\n+            char[] padChars = padStr.toCharArray();\n+            for (int i = 0; i < pads; i++) {\n+                padding[i] = padChars[i % padLen];\n+            }\n+            return new String(padding).concat(str);\n+        }\n+    }\n+\n+    // Centering\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>\n+     * using the space character (' ').<p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <p>Equivalent to <code>center(str, size, \" \")</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *)   = null\n+     * StringUtils.center(\"\", 4)     = \"    \"\n+     * StringUtils.center(\"ab\", -1)  = \"ab\"\n+     * StringUtils.center(\"ab\", 4)   = \" ab \"\n+     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n+     * StringUtils.center(\"a\", 4)    = \" a  \"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @return centered String, <code>null</code> if null String input\n+     */\n+    public static String center(String str, int size) {\n+        return center(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>.\n+     * Uses a supplied character as the value to pad the String with.</p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *, *)     = null\n+     * StringUtils.center(\"\", 4, ' ')     = \"    \"\n+     * StringUtils.center(\"ab\", -1, ' ')  = \"ab\"\n+     * StringUtils.center(\"ab\", 4, ' ')   = \" ab\"\n+     * StringUtils.center(\"abcd\", 2, ' ') = \"abcd\"\n+     * StringUtils.center(\"a\", 4, ' ')    = \" a  \"\n+     * StringUtils.center(\"a\", 4, 'y')    = \"yayy\"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @param padChar  the character to pad the new String with\n+     * @return centered String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String center(String str, int size, char padChar) {\n+        if (str == null || size <= 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str;\n+        }\n+        str = leftPad(str, strLen + pads / 2, padChar);\n+        str = rightPad(str, size, padChar);\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>.\n+     * Uses a supplied String as the value to pad the String with.</p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *, *)     = null\n+     * StringUtils.center(\"\", 4, \" \")     = \"    \"\n+     * StringUtils.center(\"ab\", -1, \" \")  = \"ab\"\n+     * StringUtils.center(\"ab\", 4, \" \")   = \" ab\"\n+     * StringUtils.center(\"abcd\", 2, \" \") = \"abcd\"\n+     * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n+     * StringUtils.center(\"a\", 4, \"yz\")   = \"yayz\"\n+     * StringUtils.center(\"abc\", 7, null) = \"  abc  \"\n+     * StringUtils.center(\"abc\", 7, \"\")   = \"  abc  \"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @param padStr  the String to pad the new String with, must not be null or empty\n+     * @return centered String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if padStr is <code>null</code> or empty\n+     */\n+    public static String center(String str, int size, String padStr) {\n+        if (str == null || size <= 0) {\n+            return str;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str;\n+        }\n+        str = leftPad(str, strLen + pads / 2, padStr);\n+        str = rightPad(str, size, padStr);\n+        return str;\n+    }\n+\n+    // Case conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.upperCase(null)  = null\n+     * StringUtils.upperCase(\"\")    = \"\"\n+     * StringUtils.upperCase(\"aBc\") = \"ABC\"\n+     * </pre>\n+     *\n+     * @param str  the String to upper case, may be null\n+     * @return the upper cased String, <code>null</code> if null String input\n+     */\n+    public static String upperCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toUpperCase();\n+    }\n+\n+    /**\n+     * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lowerCase(null)  = null\n+     * StringUtils.lowerCase(\"\")    = \"\"\n+     * StringUtils.lowerCase(\"aBc\") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to lower case, may be null\n+     * @return the lower cased String, <code>null</code> if null String input\n+     */\n+    public static String lowerCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toLowerCase();\n+    }\n+\n+    /**\n+     * <p>Capitalizes a String changing the first letter to title case as\n+     * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#capitalize(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.capitalize(null)  = null\n+     * StringUtils.capitalize(\"\")    = \"\"\n+     * StringUtils.capitalize(\"cat\") = \"Cat\"\n+     * StringUtils.capitalize(\"cAt\") = \"CAt\"\n+     * </pre>\n+     *\n+     * @param str  the String to capitalize, may be null\n+     * @return the capitalized String, <code>null</code> if null String input\n+     * @see WordUtils#capitalize(String)\n+     * @see #uncapitalize(String)\n+     * @since 2.0\n+     */\n+    public static String capitalize(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        return new StringBuffer(strLen)\n+            .append(Character.toTitleCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Capitalizes a String changing the first letter to title case as\n+     * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>\n+     *\n+     * @param str  the String to capitalize, may be null\n+     * @return the capitalized String, <code>null</code> if null String input\n+     * @deprecated Use the standardly named {@link #capitalize(String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String capitalise(String str) {\n+        return capitalize(str);\n+    }\n+\n+    /**\n+     * <p>Uncapitalizes a String changing the first letter to title case as\n+     * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.uncapitalize(null)  = null\n+     * StringUtils.uncapitalize(\"\")    = \"\"\n+     * StringUtils.uncapitalize(\"Cat\") = \"cat\"\n+     * StringUtils.uncapitalize(\"CAT\") = \"cAT\"\n+     * </pre>\n+     *\n+     * @param str  the String to uncapitalize, may be null\n+     * @return the uncapitalized String, <code>null</code> if null String input\n+     * @see WordUtils#uncapitalize(String)\n+     * @see #capitalize(String)\n+     * @since 2.0\n+     */\n+    public static String uncapitalize(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        return new StringBuffer(strLen)\n+            .append(Character.toLowerCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Uncapitalizes a String changing the first letter to title case as\n+     * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>\n+     *\n+     * @param str  the String to uncapitalize, may be null\n+     * @return the uncapitalized String, <code>null</code> if null String input\n+     * @deprecated Use the standardly named {@link #uncapitalize(String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String uncapitalise(String str) {\n+        return uncapitalize(str);\n+    }\n+\n+    /**\n+     * <p>Swaps the case of a String changing upper and title case to\n+     * lower case, and lower case to upper case.</p>\n+     *\n+     * <ul>\n+     *  <li>Upper case character converts to Lower case</li>\n+     *  <li>Title case character converts to Lower case</li>\n+     *  <li>Lower case character converts to Upper case</li>\n+     * </ul>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#swapCase(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.swapCase(null)                 = null\n+     * StringUtils.swapCase(\"\")                   = \"\"\n+     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n+     * </pre>\n+     *\n+     * <p>NOTE: This method changed in Lang version 2.0.\n+     * It no longer performs a word based algorithm.\n+     * If you only use ASCII, you will notice no change.\n+     * That functionality is available in WordUtils.</p>\n+     *\n+     * @param str  the String to swap case, may be null\n+     * @return the changed String, <code>null</code> if null String input\n+     */\n+    public static String swapCase(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        StringBuffer buffer = new StringBuffer(strLen);\n+\n+        char ch = 0;\n+        for (int i = 0; i < strLen; i++) {\n+            ch = str.charAt(i);\n+            if (Character.isUpperCase(ch)) {\n+                ch = Character.toLowerCase(ch);\n+            } else if (Character.isTitleCase(ch)) {\n+                ch = Character.toLowerCase(ch);\n+            } else if (Character.isLowerCase(ch)) {\n+                ch = Character.toUpperCase(ch);\n+            }\n+            buffer.append(ch);\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * <p>Capitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * @param str  the String to capitalize, may be null\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @deprecated Use the relocated {@link WordUtils#capitalize(String)}.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static String capitaliseAllWords(String str) {\n+        return WordUtils.capitalize(str);\n+    }\n+\n+    // Count matches\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Counts how many times the substring appears in the larger String.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String input returns <code>0</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.countMatches(null, *)       = 0\n+     * StringUtils.countMatches(\"\", *)         = 0\n+     * StringUtils.countMatches(\"abba\", null)  = 0\n+     * StringUtils.countMatches(\"abba\", \"\")    = 0\n+     * StringUtils.countMatches(\"abba\", \"a\")   = 2\n+     * StringUtils.countMatches(\"abba\", \"ab\")  = 1\n+     * StringUtils.countMatches(\"abba\", \"xxx\") = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param sub  the substring to count, may be null\n+     * @return the number of occurrences, 0 if either String is <code>null</code>\n+     */\n+    public static int countMatches(String str, String sub) {\n+        if (isEmpty(str) || isEmpty(sub)) {\n+            return 0;\n+        }\n+        int count = 0;\n+        int idx = 0;\n+        while ((idx = str.indexOf(sub, idx)) != -1) {\n+            count++;\n+            idx += sub.length();\n+        }\n+        return count;\n+    }\n+\n+    // Character Tests\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the String contains only unicode letters.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlpha(null)   = false\n+     * StringUtils.isAlpha(\"\")     = true\n+     * StringUtils.isAlpha(\"  \")   = false\n+     * StringUtils.isAlpha(\"abc\")  = true\n+     * StringUtils.isAlpha(\"ab2c\") = false\n+     * StringUtils.isAlpha(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters, and is non-null\n+     */\n+    public static boolean isAlpha(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLetter(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters and\n+     * space (' ').</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphaSpace(null)   = false\n+     * StringUtils.isAlphaSpace(\"\")     = true\n+     * StringUtils.isAlphaSpace(\"  \")   = true\n+     * StringUtils.isAlphaSpace(\"abc\")  = true\n+     * StringUtils.isAlphaSpace(\"ab c\") = true\n+     * StringUtils.isAlphaSpace(\"ab2c\") = false\n+     * StringUtils.isAlphaSpace(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters and space,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphaSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters or digits.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphanumeric(null)   = false\n+     * StringUtils.isAlphanumeric(\"\")     = true\n+     * StringUtils.isAlphanumeric(\"  \")   = false\n+     * StringUtils.isAlphanumeric(\"abc\")  = true\n+     * StringUtils.isAlphanumeric(\"ab c\") = false\n+     * StringUtils.isAlphanumeric(\"ab2c\") = true\n+     * StringUtils.isAlphanumeric(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters or digits,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphanumeric(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters, digits\n+     * or space (<code>' '</code>).</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphanumeric(null)   = false\n+     * StringUtils.isAlphanumeric(\"\")     = true\n+     * StringUtils.isAlphanumeric(\"  \")   = true\n+     * StringUtils.isAlphanumeric(\"abc\")  = true\n+     * StringUtils.isAlphanumeric(\"ab c\") = true\n+     * StringUtils.isAlphanumeric(\"ab2c\") = true\n+     * StringUtils.isAlphanumeric(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters, digits or space,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphanumericSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the string contains only ASCII printable characters.</p>\n+     * \n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.isAsciiPrintable(null)     = false\n+     * StringUtils.isAsciiPrintable(\"\")       = true\n+     * StringUtils.isAsciiPrintable(\" \")      = true\n+     * StringUtils.isAsciiPrintable(\"Ceki\")   = true\n+     * StringUtils.isAsciiPrintable(\"ab2c\")   = true\n+     * StringUtils.isAsciiPrintable(\"!ab-c~\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u0020\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u0021\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u007e\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u007f\") = false\n+     * StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") = false\n+     * </pre>\n+     *\n+     * @param str the string to check, may be null\n+     * @return <code>true</code> if every character is in the range\n+     *  32 thru 126\n+     * @since 2.1\n+     */\n+    public static boolean isAsciiPrintable(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+  \n+    /**\n+     * <p>Checks if the String contains only unicode digits.\n+     * A decimal point is not a unicode digit and returns false.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNumeric(null)   = false\n+     * StringUtils.isNumeric(\"\")     = true\n+     * StringUtils.isNumeric(\"  \")   = false\n+     * StringUtils.isNumeric(\"123\")  = true\n+     * StringUtils.isNumeric(\"12 3\") = false\n+     * StringUtils.isNumeric(\"ab2c\") = false\n+     * StringUtils.isNumeric(\"12-3\") = false\n+     * StringUtils.isNumeric(\"12.3\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains digits, and is non-null\n+     */\n+    public static boolean isNumeric(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isDigit(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode digits or space\n+     * (<code>' '</code>).\n+     * A decimal point is not a unicode digit and returns false.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNumeric(null)   = false\n+     * StringUtils.isNumeric(\"\")     = true\n+     * StringUtils.isNumeric(\"  \")   = true\n+     * StringUtils.isNumeric(\"123\")  = true\n+     * StringUtils.isNumeric(\"12 3\") = true\n+     * StringUtils.isNumeric(\"ab2c\") = false\n+     * StringUtils.isNumeric(\"12-3\") = false\n+     * StringUtils.isNumeric(\"12.3\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains digits or space,\n+     *  and is non-null\n+     */\n+    public static boolean isNumericSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only whitespace.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isWhitespace(null)   = false\n+     * StringUtils.isWhitespace(\"\")     = true\n+     * StringUtils.isWhitespace(\"  \")   = true\n+     * StringUtils.isWhitespace(\"abc\")  = false\n+     * StringUtils.isWhitespace(\"ab2c\") = false\n+     * StringUtils.isWhitespace(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains whitespace, and is non-null\n+     * @since 2.0\n+     */\n+    public static boolean isWhitespace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Defaults\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns either the passed in String,\n+     * or if the String is <code>null</code>, an empty String (\"\").</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultString(null)  = \"\"\n+     * StringUtils.defaultString(\"\")    = \"\"\n+     * StringUtils.defaultString(\"bat\") = \"bat\"\n+     * </pre>\n+     *\n+     * @see ObjectUtils#toString(Object)\n+     * @see String#valueOf(Object)\n+     * @param str  the String to check, may be null\n+     * @return the passed in String, or the empty String if it\n+     *  was <code>null</code>\n+     */\n+    public static String defaultString(String str) {\n+        return str == null ? EMPTY : str;\n+    }\n+\n+    /**\n+     * <p>Returns either the passed in String, or if the String is\n+     * <code>null</code>, the value of <code>defaultStr</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultString(null, \"NULL\")  = \"NULL\"\n+     * StringUtils.defaultString(\"\", \"NULL\")    = \"\"\n+     * StringUtils.defaultString(\"bat\", \"NULL\") = \"bat\"\n+     * </pre>\n+     *\n+     * @see ObjectUtils#toString(Object,String)\n+     * @see String#valueOf(Object)\n+     * @param str  the String to check, may be null\n+     * @param defaultStr  the default String to return\n+     *  if the input is <code>null</code>, may be null\n+     * @return the passed in String, or the default if it was <code>null</code>\n+     */\n+    public static String defaultString(String str, String defaultStr) {\n+        return str == null ? defaultStr : str;\n+    }\n+\n+    /**\n+     * <p>Returns either the passed in String, or if the String is\n+     * empty or <code>null</code>, the value of <code>defaultStr</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultIfEmpty(null, \"NULL\")  = \"NULL\"\n+     * StringUtils.defaultIfEmpty(\"\", \"NULL\")    = \"NULL\"\n+     * StringUtils.defaultIfEmpty(\"bat\", \"NULL\") = \"bat\"\n+     * </pre>\n+     *\n+     * @see StringUtils#defaultString(String, String)\n+     * @param str  the String to check, may be null\n+     * @param defaultStr  the default String to return\n+     *  if the input is empty (\"\") or <code>null</code>, may be null\n+     * @return the passed in String, or the default\n+     */\n+    public static String defaultIfEmpty(String str, String defaultStr) {\n+        return StringUtils.isEmpty(str) ? defaultStr : str;\n+    }\n+\n+    // Reversing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Reverses a String as per {@link StringBuffer#reverse()}.</p>\n+     *\n+     * <p>A <code>null</code> String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.reverse(null)  = null\n+     * StringUtils.reverse(\"\")    = \"\"\n+     * StringUtils.reverse(\"bat\") = \"tab\"\n+     * </pre>\n+     *\n+     * @param str  the String to reverse, may be null\n+     * @return the reversed String, <code>null</code> if null String input\n+     */\n+    public static String reverse(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return new StringBuffer(str).reverse().toString();\n+    }\n+\n+    /**\n+     * <p>Reverses a String that is delimited by a specific character.</p>\n+     *\n+     * <p>The Strings between the delimiters are not reversed.\n+     * Thus java.lang.String becomes String.lang.java (if the delimiter\n+     * is <code>'.'</code>).</p>\n+     *\n+     * <pre>\n+     * StringUtils.reverseDelimited(null, *)      = null\n+     * StringUtils.reverseDelimited(\"\", *)        = \"\"\n+     * StringUtils.reverseDelimited(\"a.b.c\", 'x') = \"a.b.c\"\n+     * StringUtils.reverseDelimited(\"a.b.c\", \".\") = \"c.b.a\"\n+     * </pre>\n+     *\n+     * @param str  the String to reverse, may be null\n+     * @param separatorChar  the separator character to use\n+     * @return the reversed String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String reverseDelimited(String str, char separatorChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // could implement manually, but simple way is to reuse other,\n+        // probably slower, methods.\n+        String[] strs = split(str, separatorChar);\n+        ArrayUtils.reverse(strs);\n+        return join(strs, separatorChar);\n+    }\n+\n+    /**\n+     * <p>Reverses a String that is delimited by a specific character.</p>\n+     *\n+     * <p>The Strings between the delimiters are not reversed.\n+     * Thus java.lang.String becomes String.lang.java (if the delimiter\n+     * is <code>\".\"</code>).</p>\n+     *\n+     * <pre>\n+     * StringUtils.reverseDelimitedString(null, *)       = null\n+     * StringUtils.reverseDelimitedString(\"\",*)          = \"\"\n+     * StringUtils.reverseDelimitedString(\"a.b.c\", null) = \"a.b.c\"\n+     * StringUtils.reverseDelimitedString(\"a.b.c\", \".\")  = \"c.b.a\"\n+     * </pre>\n+     *\n+     * @param str  the String to reverse, may be null\n+     * @param separatorChars  the separator characters to use, null treated as whitespace\n+     * @return the reversed String, <code>null</code> if null String input\n+     * @deprecated Use {@link #reverseDelimited(String, char)} instead.\n+     *      This method is broken as the join doesn't know which char to use.\n+     *      Method will be removed in Commons Lang 3.0.\n+     *\n+     */\n+    public static String reverseDelimitedString(String str, String separatorChars) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // could implement manually, but simple way is to reuse other,\n+        // probably slower, methods.\n+        String[] strs = split(str, separatorChars);\n+        ArrayUtils.reverse(strs);\n+        if (separatorChars == null) {\n+            return join(strs, ' ');\n+        }\n+        return join(strs, separatorChars);\n+    }\n+\n+    // Abbreviating\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Abbreviates a String using ellipses. This will turn\n+     * \"Now is the time for all good men\" into \"Now is the time for...\"</p>\n+     *\n+     * <p>Specifically:\n+     * <ul>\n+     *   <li>If <code>str</code> is less than <code>maxWidth</code> characters\n+     *       long, return it.</li>\n+     *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + \"...\")</code>.</li>\n+     *   <li>If <code>maxWidth</code> is less than <code>4</code>, throw an\n+     *       <code>IllegalArgumentException</code>.</li>\n+     *   <li>In no case will it return a String of length greater than\n+     *       <code>maxWidth</code>.</li>\n+     * </ul>\n+     * </p>\n+     *\n+     * <pre>\n+     * StringUtils.abbreviate(null, *)      = null\n+     * StringUtils.abbreviate(\"\", 4)        = \"\"\n+     * StringUtils.abbreviate(\"abcdefg\", 6) = \"abc...\"\n+     * StringUtils.abbreviate(\"abcdefg\", 7) = \"abcdefg\"\n+     * StringUtils.abbreviate(\"abcdefg\", 8) = \"abcdefg\"\n+     * StringUtils.abbreviate(\"abcdefg\", 4) = \"a...\"\n+     * StringUtils.abbreviate(\"abcdefg\", 3) = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param maxWidth  maximum length of result String, must be at least 4\n+     * @return abbreviated String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if the width is too small\n+     * @since 2.0\n+     */\n+    public static String abbreviate(String str, int maxWidth) {\n+        return abbreviate(str, 0, maxWidth);\n+    }\n+\n+    /**\n+     * <p>Abbreviates a String using ellipses. This will turn\n+     * \"Now is the time for all good men\" into \"...is the time for...\"</p>\n+     *\n+     * <p>Works like <code>abbreviate(String, int)</code>, but allows you to specify\n+     * a \"left edge\" offset.  Note that this left edge is not necessarily going to\n+     * be the leftmost character in the result, or the first character following the\n+     * ellipses, but it will appear somewhere in the result.\n+     *\n+     * <p>In no case will it return a String of length greater than\n+     * <code>maxWidth</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.abbreviate(null, *, *)                = null\n+     * StringUtils.abbreviate(\"\", 0, 4)                  = \"\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  = \"...fghi...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  = \"...ghij...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghij\", 0, 3)        = IllegalArgumentException\n+     * StringUtils.abbreviate(\"abcdefghij\", 5, 6)        = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param offset  left edge of source String\n+     * @param maxWidth  maximum length of result String, must be at least 4\n+     * @return abbreviated String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if the width is too small\n+     * @since 2.0\n+     */\n+    public static String abbreviate(String str, int offset, int maxWidth) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (maxWidth < 4) {\n+            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n+        }\n+        if (str.length() <= maxWidth) {\n+            return str;\n+        }\n+        if (offset > str.length()) {\n+            offset = str.length();\n+        }\n+        if ((str.length() - offset) < (maxWidth - 3)) {\n+            offset = str.length() - (maxWidth - 3);\n+        }\n+        if (offset <= 4) {\n+            return str.substring(0, maxWidth - 3) + \"...\";\n+        }\n+        if (maxWidth < 7) {\n+            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n+        }\n+        if ((offset + (maxWidth - 3)) < str.length()) {\n+            return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n+        }\n+        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n+    }\n+\n+    // Difference\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two Strings, and returns the portion where they differ.\n+     * (More precisely, return the remainder of the second String,\n+     * starting from where it's different from the first.)</p>\n+     *\n+     * <p>For example,\n+     * <code>difference(\"i am a machine\", \"i am a robot\") -> \"robot\"</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.difference(null, null) = null\n+     * StringUtils.difference(\"\", \"\") = \"\"\n+     * StringUtils.difference(\"\", \"abc\") = \"abc\"\n+     * StringUtils.difference(\"abc\", \"\") = \"\"\n+     * StringUtils.difference(\"abc\", \"abc\") = \"\"\n+     * StringUtils.difference(\"ab\", \"abxyz\") = \"xyz\"\n+     * StringUtils.difference(\"abcde\", \"abxyz\") = \"xyz\"\n+     * StringUtils.difference(\"abcde\", \"xyz\") = \"xyz\"\n+     * </pre>\n+     *\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return the portion of str2 where it differs from str1; returns the\n+     * empty String if they are equal\n+     * @since 2.0\n+     */\n+    public static String difference(String str1, String str2) {\n+        if (str1 == null) {\n+            return str2;\n+        }\n+        if (str2 == null) {\n+            return str1;\n+        }\n+        int at = indexOfDifference(str1, str2);\n+        if (at == -1) {\n+            return EMPTY;\n+        }\n+        return str2.substring(at);\n+    }\n+\n+    /**\n+     * <p>Compares two Strings, and returns the index at which the\n+     * Strings begin to differ.</p>\n+     *\n+     * <p>For example,\n+     * <code>indexOfDifference(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfDifference(null, null) = -1\n+     * StringUtils.indexOfDifference(\"\", \"\") = -1\n+     * StringUtils.indexOfDifference(\"\", \"abc\") = 0\n+     * StringUtils.indexOfDifference(\"abc\", \"\") = 0\n+     * StringUtils.indexOfDifference(\"abc\", \"abc\") = -1\n+     * StringUtils.indexOfDifference(\"ab\", \"abxyz\") = 2\n+     * StringUtils.indexOfDifference(\"abcde\", \"abxyz\") = 2\n+     * StringUtils.indexOfDifference(\"abcde\", \"xyz\") = 0\n+     * </pre>\n+     *\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return the index where str2 and str1 begin to differ; -1 if they are equal\n+     * @since 2.0\n+     */\n+    public static int indexOfDifference(String str1, String str2) {\n+        if (str1 == str2) {\n+            return -1;\n+        }\n+        if (str1 == null || str2 == null) {\n+            return 0;\n+        }\n+        int i;\n+        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n+            if (str1.charAt(i) != str2.charAt(i)) {\n+                break;\n+            }\n+        }\n+        if (i < str2.length() || i < str1.length()) {\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Find the Levenshtein distance between two Strings.</p>\n+     *\n+     * <p>This is the number of changes needed to change one String into\n+     * another, where each change is a single character modification (deletion,\n+     * insertion or substitution).</p>\n+     *\n+     * <p>The previous implementation of the Levenshtein distance algorithm\n+     * was from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n+     *\n+     * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError\n+     * which can occur when my Java implementation is used with very large strings.<br>\n+     * This implementation of the Levenshtein distance algorithm\n+     * is from <a href=\"http://www.merriampark.com/ldjava.htm\">http://www.merriampark.com/ldjava.htm</a></p>\n+     *\n+     * <pre>\n+     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(\"\",\"\")               = 0\n+     * StringUtils.getLevenshteinDistance(\"\",\"a\")              = 1\n+     * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\")       = 7\n+     * StringUtils.getLevenshteinDistance(\"frog\", \"fog\")       = 1\n+     * StringUtils.getLevenshteinDistance(\"fly\", \"ant\")        = 3\n+     * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") = 7\n+     * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") = 7\n+     * StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") = 8\n+     * StringUtils.getLevenshteinDistance(\"hello\", \"hallo\")    = 1\n+     * </pre>\n+     *\n+     * @param s  the first String, must not be null\n+     * @param t  the second String, must not be null\n+     * @return result distance\n+     * @throws IllegalArgumentException if either String input <code>null</code>\n+     */\n+    public static int getLevenshteinDistance(String s, String t) {\n+        if (s == null || t == null) {\n+            throw new IllegalArgumentException(\"Strings must not be null\");\n+        }\n+\n+        /*\n+           The difference between this impl. and the previous is that, rather \n+           than creating and retaining a matrix of size s.length()+1 by t.length()+1, \n+           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n+           is the 'current working' distance array that maintains the newest distance cost\n+           counts as we iterate through the characters of String s.  Each time we increment\n+           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n+           allows us to retain the previous cost counts as required by the algorithm (taking \n+           the minimum of the cost count to the left, up one, and diagonally up and to the left\n+           of the current cost count being calculated).  (Note that the arrays aren't really \n+           copied anymore, just switched...this is clearly much better than cloning an array \n+           or doing a System.arraycopy() each time  through the outer loop.)\n+\n+           Effectively, the difference between the two implementations is this one does not \n+           cause an out of memory condition when calculating the LD over two very large strings.\n+         */\n+\n+        int n = s.length(); // length of s\n+        int m = t.length(); // length of t\n+\n+        if (n == 0) {\n+            return m;\n+        } else if (m == 0) {\n+            return n;\n+        }\n+\n+        int p[] = new int[n+1]; //'previous' cost array, horizontally\n+        int d[] = new int[n+1]; // cost array, horizontally\n+        int _d[]; //placeholder to assist in swapping p and d\n+\n+        // indexes into strings s and t\n+        int i; // iterates through s\n+        int j; // iterates through t\n+\n+        char t_j; // jth character of t\n+\n+        int cost; // cost\n+\n+        for (i = 0; i<=n; i++) {\n+            p[i] = i;\n+        }\n+\n+        for (j = 1; j<=m; j++) {\n+            t_j = t.charAt(j-1);\n+            d[0] = j;\n+\n+            for (i=1; i<=n; i++) {\n+                cost = s.charAt(i-1)==t_j ? 0 : 1;\n+                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n+                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);  \n+            }\n+\n+            // copy current distance counts to 'previous row' distance counts\n+            _d = p;\n+            p = d;\n+            d = _d;\n+        }\n+\n+        // our last action in the above loop was to switch d and p, so p now \n+        // actually has the most recent cost counts\n+        return p[n];\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>int</code> values.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+/*\n+    private static int min(int a, int b, int c) {\n+        // Method copied from NumberUtils to avoid dependency on subpackage\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+*/\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/SystemUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.File;\n+\n+/**\n+ * <p>Helpers for <code>java.lang.System</code>.</p>\n+ * \n+ * <p>If a system property cannot be read due to security restrictions, \n+ * the corresponding field in this class will be set to <code>null</code>\n+ * and a message will be written to <code>System.err</code>.</p>\n+ *\n+ * @author Based on code from Avalon Excalibur\n+ * @author Based on code from Lucene\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n+ * @author Gary Gregory\n+ * @author Michael Becke\n+ * @author Tetsuya Kaneuchi\n+ * @author Rafal Krupinski\n+ * @author Jason Gritman\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SystemUtils {\n+\n+    /**\n+     * The prefix String for all Windows OS.\n+     */\n+    private static final String OS_NAME_WINDOWS_PREFIX = \"Windows\";\n+    \n+    // System property constants\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared first. Other constants depend on this.\n+    \n+    /**\n+     * The System property key for the user home directory.\n+     */\n+    private static final String USER_HOME_KEY = \"user.home\";\n+\n+    /**\n+     * The System property key for the user directory.\n+     */\n+    private static final String USER_DIR_KEY = \"user.dir\";\n+    \n+    /**\n+     * The System property key for the Java IO temporary directory.\n+     */\n+    private static final String JAVA_IO_TMPDIR_KEY = \"java.io.tmpdir\";\n+    \n+    /**\n+     * The System property key for the Java home directory.\n+     */\n+    private static final String JAVA_HOME_KEY = \"java.home\";\n+    \n+    /**\n+     * <p>The <code>awt.toolkit</code> System Property.</p>\n+     * <p>Holds a class name, on Windows XP this is <code>sun.awt.windows.WToolkit</code>.</p>\n+     * <p><b>On platforms without a GUI, this value is <code>null</code>.</b></p>\n+     * \n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n+\n+    /**\n+     * <p>The <code>file.encoding</code> System Property.</p>\n+     * <p>File encoding, such as <code>Cp1252</code>.</p>\n+     * \n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String FILE_ENCODING = getSystemProperty(\"file.encoding\");\n+\n+    /**\n+     * <p>The <code>file.separator</code> System Property.\n+     * File separator (<code>&quot;/&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String FILE_SEPARATOR = getSystemProperty(\"file.separator\");\n+\n+    /**\n+     * <p>The <code>java.awt.fonts</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_FONTS = getSystemProperty(\"java.awt.fonts\");\n+\n+    /**\n+     * <p>The <code>java.awt.graphicsenv</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_GRAPHICSENV = getSystemProperty(\"java.awt.graphicsenv\");\n+\n+    /**\n+     * <p>\n+     * The <code>java.awt.headless</code> System Property.\n+     * The value of this property is the String <code>\"true\"</code> or <code>\"false\"</code>. \n+     * </p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @see #isJavaAwtHeadless()\n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_AWT_HEADLESS = getSystemProperty(\"java.awt.headless\");\n+\n+    /**\n+     * <p>The <code>java.awt.printerjob</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_PRINTERJOB = getSystemProperty(\"java.awt.printerjob\");\n+\n+    /**\n+     * <p>The <code>java.class.path</code> System Property. Java class path.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_CLASS_PATH = getSystemProperty(\"java.class.path\");\n+\n+    /**\n+     * <p>The <code>java.class.version</code> System Property.\n+     * Java class format version number.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_CLASS_VERSION = getSystemProperty(\"java.class.version\");\n+\n+    /**\n+     * <p>The <code>java.compiler</code> System Property. Name of JIT compiler to use.\n+     * First in JDK version 1.2. Not used in Sun JDKs after 1.2.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2. Not used in Sun versions after 1.2.\n+     */\n+    public static final String JAVA_COMPILER = getSystemProperty(\"java.compiler\");\n+\n+    /**\n+     * <p>The <code>java.endorsed.dirs</code> System Property. Path of endorsed directory\n+     * or directories.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_ENDORSED_DIRS = getSystemProperty(\"java.endorsed.dirs\");\n+\n+    /**\n+     * <p>The <code>java.ext.dirs</code> System Property. Path of extension directory\n+     * or directories.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_EXT_DIRS = getSystemProperty(\"java.ext.dirs\");\n+\n+    /**\n+     * <p>The <code>java.home</code> System Property. Java installation directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_HOME = getSystemProperty(JAVA_HOME_KEY);\n+\n+    /**\n+     * <p>The <code>java.io.tmpdir</code> System Property. Default temp file path.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_IO_TMPDIR = getSystemProperty(JAVA_IO_TMPDIR_KEY);\n+\n+    /**\n+     * <p>The <code>java.library.path</code> System Property. List of paths to search\n+     * when loading libraries.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_LIBRARY_PATH = getSystemProperty(\"java.library.path\");\n+\n+    /**\n+     * <p>The <code>java.runtime.name</code> System Property. Java Runtime Environment\n+     * name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_RUNTIME_NAME = getSystemProperty(\"java.runtime.name\");\n+\n+    /**\n+     * <p>The <code>java.runtime.version</code> System Property. Java Runtime Environment\n+     * version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_RUNTIME_VERSION = getSystemProperty(\"java.runtime.version\");\n+\n+    /**\n+     * <p>The <code>java.specification.name</code> System Property. Java Runtime Environment\n+     * specification name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_SPECIFICATION_NAME = getSystemProperty(\"java.specification.name\");\n+\n+    /**\n+     * <p>The <code>java.specification.vendor</code> System Property. Java Runtime Environment\n+     * specification vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_SPECIFICATION_VENDOR = getSystemProperty(\"java.specification.vendor\");\n+\n+    /**\n+     * <p>The <code>java.specification.version</code> System Property. Java Runtime Environment\n+     * specification version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_SPECIFICATION_VERSION = getSystemProperty(\"java.specification.version\");\n+\n+    /**\n+     * <p>The <code>java.util.prefs.PreferencesFactory</code> System Property. A class name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY = \n+        getSystemProperty(\"java.util.prefs.PreferencesFactory\");\n+\n+    /**\n+     * <p>The <code>java.vendor</code> System Property. Java vendor-specific string.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_VENDOR = getSystemProperty(\"java.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vendor.url</code> System Property. Java vendor URL.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+    */\n+    public static final String JAVA_VENDOR_URL = getSystemProperty(\"java.vendor.url\");\n+\n+    /**\n+     * <p>The <code>java.version</code> System Property. Java version number.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_VERSION = getSystemProperty(\"java.version\");\n+\n+    /**\n+     * <p>The <code>java.vm.info</code> System Property. Java Virtual Machine implementation\n+     * info.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_INFO = getSystemProperty(\"java.vm.info\");\n+\n+    /**\n+     * <p>The <code>java.vm.name</code> System Property. Java Virtual Machine implementation\n+     * name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_NAME = getSystemProperty(\"java.vm.name\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.name</code> System Property. Java Virtual Machine\n+     * specification name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_NAME = getSystemProperty(\"java.vm.specification.name\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.vendor</code> System Property. Java Virtual\n+     * Machine specification vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_VENDOR = getSystemProperty(\"java.vm.specification.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.version</code> System Property. Java Virtual Machine\n+     * specification version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_VERSION = getSystemProperty(\"java.vm.specification.version\");\n+\n+    /**\n+     * <p>The <code>java.vm.vendor</code> System Property. Java Virtual Machine implementation\n+     * vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_VENDOR = getSystemProperty(\"java.vm.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vm.version</code> System Property. Java Virtual Machine\n+     * implementation version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_VERSION = getSystemProperty(\"java.vm.version\");\n+\n+    /**\n+     * <p>The <code>line.separator</code> System Property. Line separator\n+     * (<code>&quot;\\n&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String LINE_SEPARATOR = getSystemProperty(\"line.separator\");\n+\n+    /**\n+     * <p>The <code>os.arch</code> System Property. Operating system architecture.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_ARCH = getSystemProperty(\"os.arch\");\n+\n+    /**\n+     * <p>The <code>os.name</code> System Property. Operating system name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_NAME = getSystemProperty(\"os.name\");\n+\n+    /**\n+     * <p>The <code>os.version</code> System Property. Operating system version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_VERSION = getSystemProperty(\"os.version\");\n+\n+    /**\n+     * <p>The <code>path.separator</code> System Property. Path separator\n+     * (<code>&quot;:&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String PATH_SEPARATOR = getSystemProperty(\"path.separator\");\n+\n+    /**\n+     * <p>The <code>user.country</code> or <code>user.region</code> System Property.\n+     * User's country code, such as <code>GB</code>. First in JDK version 1.2 as\n+     * <code>user.region</code>. Renamed to <code>user.country</code> in 1.4</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String USER_COUNTRY = \n+        getSystemProperty(\"user.country\") == null ?\n+            getSystemProperty(\"user.region\") : getSystemProperty(\"user.country\");\n+\n+    /**\n+     * <p>The <code>user.dir</code> System Property. User's current working\n+     * directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_DIR = getSystemProperty(USER_DIR_KEY);\n+\n+    /**\n+     * <p>The <code>user.home</code> System Property. User's home directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_HOME = getSystemProperty(USER_HOME_KEY);\n+\n+    /**\n+     * <p>The <code>user.language</code> System Property. User's language code,\n+     * such as <code>\"en\"</code>.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String USER_LANGUAGE = getSystemProperty(\"user.language\");\n+\n+    /**\n+     * <p>The <code>user.name</code> System Property. User's account name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_NAME = getSystemProperty(\"user.name\");\n+\n+    /**\n+     * <p>The <code>user.timezone</code> System Property. \n+     * For example: <code>\"America/Los_Angeles\"</code>.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String USER_TIMEZONE = getSystemProperty(\"user.timezone\");\n+\n+    // Java version\n+    //-----------------------------------------------------------------------\n+    // This MUST be declared after those above as it depends on the\n+    // values being set up\n+\n+    /**\n+     * <p>Gets the Java version as a <code>String</code> trimming leading letters.</p>\n+     *\n+     * <p>The field will return <code>null</code> if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+\n+    // Java version values\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after the trim above as they depend on the\n+    // value being set up\n+\n+    /**\n+     * <p>Gets the Java version as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     *\n+     * <p>The field will return zero if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final float JAVA_VERSION_FLOAT = getJavaVersionAsFloat();\n+\n+    /**\n+     * <p>Gets the Java version as an <code>int</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>120</code> for JDK 1.2\n+     *  <li><code>131</code> for JDK 1.3.1\n+     * </ul>\n+     *\n+     * <p>The field will return zero if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final int JAVA_VERSION_INT = getJavaVersionAsInt();\n+\n+    // Java version checks\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after those above as they depend on the\n+    // values being set up\n+    \n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.1 (also 1.1.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_1 = getJavaVersionMatches(\"1.1\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.2 (also 1.2.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_2 = getJavaVersionMatches(\"1.2\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.3 (also 1.3.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_3 = getJavaVersionMatches(\"1.3\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.4 (also 1.4.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_4 = getJavaVersionMatches(\"1.4\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.5 (also 1.5.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_5 = getJavaVersionMatches(\"1.5\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.6 (also 1.6.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_6 = getJavaVersionMatches(\"1.6\");\n+\n+    // Operating system checks\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after those above as they depend on the\n+    // values being set up\n+    // OS names from http://www.vamphq.com/os.html\n+    // Selected ones included - please advise commons-dev@jakarta.apache.org\n+    // if you want another added or a mistake corrected\n+\n+    /**\n+     * <p>Is <code>true</code> if this is AIX.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_AIX = getOSMatches(\"AIX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is HP-UX.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_HP_UX = getOSMatches(\"HP-UX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Irix.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_IRIX = getOSMatches(\"Irix\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Linux.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_LINUX = getOSMatches(\"Linux\") || getOSMatches(\"LINUX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Mac.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_MAC = getOSMatches(\"Mac\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Mac.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_MAC_OSX = getOSMatches(\"Mac OS X\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is OS/2.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_OS2 = getOSMatches(\"OS/2\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Solaris.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_SOLARIS = getOSMatches(\"Solaris\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is SunOS.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_SUN_OS = getOSMatches(\"SunOS\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is a POSIX compilant system,\n+     * as in any of AIX, HP-UX, Irix, Linux, MacOSX, Solaris or SUN OS.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final boolean IS_OS_UNIX =\n+        IS_OS_AIX || IS_OS_HP_UX || IS_OS_IRIX || IS_OS_LINUX ||\n+        IS_OS_MAC_OSX || IS_OS_SOLARIS || IS_OS_SUN_OS;\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS = getOSMatches(OS_NAME_WINDOWS_PREFIX);\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 2000.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_2000 = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"5.0\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 95.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_95 = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" 9\", \"4.0\");\n+    // JDK 1.2 running on Windows98 returns 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 98.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_98 = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" 9\", \"4.1\");\n+    // JDK 1.2 running on Windows98 returns 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows ME.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_ME = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"4.9\");\n+    // JDK 1.2 running on WindowsME may return 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows NT.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_NT = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" NT\");\n+    // Windows 2000 returns 'Windows 2000' but may suffer from same JDK1.2 problem\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows XP.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_XP = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"5.1\");\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * <p>SystemUtils instances should NOT be constructed in standard\n+     * programming. Instead, the class should be used as\n+     * <code>SystemUtils.FILE_SEPARATOR</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public SystemUtils() {\n+        super();\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * <p>Gets the Java version number as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * @return the version, for example 1.31f for JDK 1.3.1\n+     * @deprecated Use {@link #JAVA_VERSION_FLOAT} instead.\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public static float getJavaVersion() {\n+        return JAVA_VERSION_FLOAT;\n+    }\n+\n+    /**\n+     * <p>Gets the Java version number as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 1.31f for JDK 1.3.1\n+     */\n+    private static float getJavaVersionAsFloat() {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return 0f;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        }\n+        try {\n+            return Float.parseFloat(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Gets the Java version number as an <code>int</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>120</code> for JDK 1.2\n+     *  <li><code>131</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 131 for JDK 1.3.1\n+     */\n+    private static int getJavaVersionAsInt() {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return 0;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 1);\n+        str = str + JAVA_VERSION_TRIMMED.substring(2, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        } else {\n+            str = str + \"0\";\n+        }\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Trims the text of the java version to start with numbers.\n+     * \n+     * @return the trimmed java version\n+     */\n+    private static String getJavaVersionTrimmed() {\n+        if (JAVA_VERSION != null) {\n+            for (int i = 0; i < JAVA_VERSION.length(); i++) {\n+                char ch = JAVA_VERSION.charAt(i);\n+                if (ch >= '0' && ch <= '9') {\n+                    return JAVA_VERSION.substring(i);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Decides if the java version matches.</p>\n+     * \n+     * @param versionPrefix  the prefix for the java version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getJavaVersionMatches(String versionPrefix) {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return false;\n+        }\n+        return JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n+    }    \n+    \n+    /**\n+     * <p>Decides if the operating system matches.</p>\n+     * \n+     * @param osNamePrefix  the prefix for the os name\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getOSMatches(String osNamePrefix) {\n+        if (OS_NAME == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix);\n+    }    \n+\n+    /**\n+     * <p>Decides if the operating system matches.</p>\n+     * \n+     * @param osNamePrefix  the prefix for the os name\n+     * @param osVersionPrefix  the prefix for the version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\n+        if (OS_NAME == null || OS_VERSION == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n+    }    \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a System property, defaulting to <code>null</code> if the property\n+     * cannot be read.</p>\n+     *\n+     * <p>If a <code>SecurityException</code> is caught, the return\n+     * value is <code>null</code> and a message is written to <code>System.err</code>.</p>\n+     * \n+     * @param property the system property name\n+     * @return the system property value or <code>null</code> if a security problem occurs\n+     */\n+    private static String getSystemProperty(String property) {\n+        try {\n+            return System.getProperty(property);\n+        } catch (SecurityException ex) {\n+            // we are not allowed to look at this property\n+            System.err.println(\n+                \"Caught a SecurityException reading the system property '\" + property \n+                + \"'; the SystemUtils property value will default to null.\"\n+            );\n+            return null;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Is the Java version at least the requested version.</p>\n+     *\n+     * <p>Example input:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> to test for JDK 1.2</li>\n+     *  <li><code>1.31f</code> to test for JDK 1.3.1</li>\n+     * </ul>\n+     * \n+     * @param requiredVersion  the required version, for example 1.31f\n+     * @return <code>true</code> if the actual version is equal or greater\n+     *  than the required version\n+     */\n+    public static boolean isJavaVersionAtLeast(float requiredVersion) {\n+        return JAVA_VERSION_FLOAT >= requiredVersion;\n+    }\n+    \n+    /**\n+     * <p>Is the Java version at least the requested version.</p>\n+     *\n+     * <p>Example input:</p>\n+     * <ul>\n+     *  <li><code>120</code> to test for JDK 1.2 or greater</li>\n+     *  <li><code>131</code> to test for JDK 1.3.1 or greater</li>\n+     * </ul>\n+     * \n+     * @param requiredVersion  the required version, for example 131\n+     * @return <code>true</code> if the actual version is equal or greater\n+     *  than the required version\n+     * @since 2.0\n+     */\n+    public static boolean isJavaVersionAtLeast(int requiredVersion) {\n+        return JAVA_VERSION_INT >= requiredVersion;\n+    }\n+\n+    /**\n+     * Returns whether the {@link #JAVA_AWT_HEADLESS} value is <code>true</code>.\n+     *  \n+     * @return <code>true</code> if <code>JAVA_AWT_HEADLESS</code> is <code>\"true\"</code>,\n+     * <code>false</code> otherwise.\n+     * \n+     * @see #JAVA_AWT_HEADLESS\n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static boolean isJavaAwtHeadless() {\n+        return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false;\n+    }\n+    /**\n+     * <p>Gets the Java home directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getJavaHome() {\n+        return new File(System.getProperty(JAVA_HOME_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the Java IO temporary directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getJavaIoTmpDir() {\n+        return new File(System.getProperty(JAVA_IO_TMPDIR_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the user directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getUserDir() {\n+        return new File(System.getProperty(USER_DIR_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the user home directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getUserHome() {\n+        return new File(System.getProperty(USER_HOME_KEY));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/UnhandledException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+\n+/**\n+ * <p>Thrown when it is impossible or undesirable to consume or throw a checked exception.</p>\n+ * This exception supplements the standard exception classes by providing a more\n+ * semantically rich description of the problem.</p>\n+ * \n+ * <p><code>UnhandledException</code> represents the case where a method has to deal\n+ * with a checked exception but does not wish to.\n+ * Instead, the checked exception is rethrown in this unchecked wrapper.</p>\n+ * \n+ * <pre>\n+ * public void foo() {\n+ *   try {\n+ *     // do something that throws IOException\n+ *   } catch (IOException ex) {\n+ *     // don't want to or can't throw IOException from foo()\n+ *     throw new UnhandledException(ex);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * @author Matthew Hawthorne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class UnhandledException extends NestableRuntimeException {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1832101364842773720L;\n+\n+    /**\n+     * Constructs the exception using a cause.\n+     *\n+     * @param cause  the underlying cause\n+     */\n+    public UnhandledException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * Constructs the exception using a message and cause.\n+     *\n+     * @param message  the message to use\n+     * @param cause  the underlying cause\n+     */\n+    public UnhandledException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/Validate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * <p>Assists in validating arguments.</p>\n+ * \n+ * <p>The class is based along the lines of JUnit. If an argument value is \n+ * deemed invalid, an IllegalArgumentException is thrown. For example:</p>\n+ * \n+ * <pre>\n+ * Validate.isTrue( i > 0, \"The value must be greater than zero: \", i);\n+ * Validate.notNull( surname, \"The surname must not be null\");\n+ * </pre>\n+ *\n+ * @author <a href=\"mailto:ola.berg@arkitema.se\">Ola Berg</a>\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Norm Deane\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class Validate {\n+    // Validate has no dependencies on other classes in Commons Lang at present\n+    \n+    /**\n+     * Constructor. This class should not normally be instantiated.\n+     */\n+    public Validate() {\n+      super();\n+    }\n+    \n+    // isTrue\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the test result is <code>false</code>.</p>\n+     * \n+     * <p>This is used when validating according to an arbitrary boolean expression,\n+     * such as validating a primitive number or using your own custom validation \n+     * expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue( myObject.isOk(), \"The object is not OK: \", myObject);\n+     * </pre>\n+     *\n+     * <p>For performance reasons, the object is passed as a separate parameter and\n+     * appended to the message string only in the case of an error.</p>\n+     * \n+     * @param expression  a boolean expression\n+     * @param message  the exception message you would like to see if the\n+     *  expression is <code>false</code>\n+     * @param value  the value to append to the message in case of error\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     */\n+    public static void isTrue(boolean expression, String message, Object value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(message + value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the test result is <code>false</code>.</p>\n+     * \n+     * <p>This is used when validating according to an arbitrary boolean expression,\n+     * such as validating a primitive number or using your own custom validation \n+     * expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue( i > 0, \"The value must be greater than zero: \", i);\n+     * </pre>\n+     *\n+     * <p>For performance reasons, the long value is passed as a separate parameter and\n+     * appended to the message string only in the case of an error.</p>\n+     * \n+     * @param expression  a boolean expression\n+     * @param message  the exception message you would like to see if the expression is <code>false</code>\n+     * @param value  the value to append to the message in case of error\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     */\n+    public static void isTrue(boolean expression, String message, long value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(message + value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the test result is <code>false</code>.</p>\n+     * \n+     * <p>This is used when validating according to an arbitrary boolean expression,\n+     * such as validating a primitive number or using your own custom validation \n+     * expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue( d > 0.0, \"The value must be greater than zero: \", d);\n+     * </pre>\n+     *\n+     * <p>For performance reasons, the double value is passed as a separate parameter and\n+     * appended to the message string only in the case of an error.</p>\n+     * \n+     * @param expression  a boolean expression\n+     * @param message  the exception message you would like to see if the expression\n+     *  is <code>false</code>\n+     * @param value  the value to append to the message in case of error\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     */\n+    public static void isTrue(boolean expression, String message, double value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(message + value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the test result is <code>false</code>.</p>\n+     * \n+     * <p>This is used when validating according to an arbitrary boolean expression,\n+     * such as validating a primitive number or using your own custom validation \n+     * expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue( (i > 0), \"The value must be greater than zero\");\n+     * Validate.isTrue( myObject.isOk(), \"The object is not OK\");\n+     * </pre>\n+     *\n+     * <p>For performance reasons, the message string should not involve a string append,\n+     * instead use the {@link #isTrue(boolean, String, Object)} method.</p>\n+     * \n+     * @param expression  a boolean expression\n+     * @param message  the exception message you would like to see if the expression\n+     *  is <code>false</code>\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     */\n+    public static void isTrue(boolean expression, String message) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(message);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the test result is <code>false</code>.</p>\n+     * \n+     * <p>This is used when validating according to an arbitrary boolean expression,\n+     * such as validating a primitive number or using your own custom validation \n+     * expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue( i > 0 );\n+     * Validate.isTrue( myObject.isOk() );\n+     * </pre>\n+     *\n+     * <p>The message in the exception is 'The validated expression is false'.</p>\n+     * \n+     * @param expression  a boolean expression\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     */\n+    public static void isTrue(boolean expression) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(\"The validated expression is false\");\n+        }\n+    }\n+\n+    // notNull\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument is <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * Validate.notNull(myObject, \"The object must not be null\");\n+     * </pre>\n+     * \n+     * @param object  the object to check is not <code>null</code>\n+     * @param message  the exception message you would like to see\n+     *  if the object is <code>null</code>\n+     * @throws IllegalArgumentException if the object is <code>null</code>\n+     */\n+    public static void notNull(Object object, String message) {\n+        if (object == null) {\n+            throw new IllegalArgumentException(message);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument is <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * Validate.notNull(myObject);\n+     * </pre>\n+     *\n+     * <p>The message in the exception is 'The validated object is null'.</p>\n+     * \n+     * @param object  the object to check is not <code>null</code>\n+     * @throws IllegalArgumentException if the object is <code>null</code>\n+     */\n+    public static void notNull(Object object) {\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The validated object is null\");\n+        }\n+    }\n+\n+    // notEmpty array\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument array is empty (<code>null</code> or no elements).</p>\n+     *\n+     * <pre>\n+     * Validate.notEmpty(myArray, \"The array must not be empty\");\n+     * </pre>\n+     * \n+     * @param array  the array to check is not empty\n+     * @param message  the exception message you would like to see if the array is empty\n+     * @throws IllegalArgumentException if the array is empty\n+     */\n+    public static void notEmpty(Object[] array, String message) {\n+        if (array == null || array.length == 0) {\n+            throw new IllegalArgumentException(message);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument array is empty (<code>null</code> or no elements).</p>\n+     *\n+     * <pre>\n+     * Validate.notEmpty(myArray);\n+     * </pre>\n+     *\n+     * <p>The message in the exception is 'The validated array is empty'.\n+     * \n+     * @param array  the array to check is not empty\n+     * @throws IllegalArgumentException if the array is empty\n+     */\n+    public static void notEmpty(Object[] array) {\n+        if (array == null || array.length == 0) {\n+            throw new IllegalArgumentException(\"The validated array is empty\");\n+        }\n+    }\n+\n+    // notEmpty collection\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument Collection is empty (<code>null</code> or no elements).</p>\n+     *\n+     * <pre>\n+     * Validate.notEmpty(myCollection, \"The collection must not be empty\");\n+     * </pre>\n+     * \n+     * @param collection  the collection to check is not empty\n+     * @param message  the exception message you would like to see if the collection is empty\n+     * @throws IllegalArgumentException if the collection is empty\n+     */\n+    public static void notEmpty(Collection collection, String message) {\n+        if (collection == null || collection.size() == 0) {\n+            throw new IllegalArgumentException(message);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument Collection is empty (<code>null</code> or no elements).</p>\n+     *\n+     * <pre>\n+     * Validate.notEmpty(myCollection);\n+     * </pre>\n+     *\n+     * <p>The message in the exception is 'The validated collection is empty'.</p>\n+     * \n+     * @param collection  the collection to check is not empty\n+     * @throws IllegalArgumentException if the collection is empty\n+     */\n+    public static void notEmpty(Collection collection) {\n+        if (collection == null || collection.size() == 0) {\n+            throw new IllegalArgumentException(\"The validated collection is empty\");\n+        }\n+    }\n+\n+    // notEmpty map\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument Map is empty (<code>null</code> or no elements).</p>\n+     *\n+     * <pre>\n+     * Validate.notEmpty(myMap, \"The map must not be empty\");\n+     * </pre>\n+     * \n+     * @param map  the map to check is not empty\n+     * @param message  the exception message you would like to see if the map is empty\n+     * @throws IllegalArgumentException if the map is empty\n+     */\n+    public static void notEmpty(Map map, String message) {\n+        if (map == null || map.size() == 0) {\n+            throw new IllegalArgumentException(message);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument Map is empty (<code>null</code> or no elements).</p>\n+     *\n+     * <pre>\n+     * Validate.notEmpty(myMap);\n+     * </pre>\n+     *\n+     * <p>The message in the exception is 'The validated map is empty'.</p>\n+     * \n+     * @param map  the map to check is not empty\n+     * @throws IllegalArgumentException if the map is empty\n+     */\n+    public static void notEmpty(Map map) {\n+        if (map == null || map.size() == 0) {\n+            throw new IllegalArgumentException(\"The validated map is empty\");\n+        }\n+    }\n+\n+    // notEmpty string\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument String is empty (<code>null</code> or zero length).</p>\n+     *\n+     * <pre>\n+     * Validate.notEmpty(myString, \"The string must not be empty\");\n+     * </pre>\n+     * \n+     * @param string  the string to check is not empty\n+     * @param message  the exception message you would like to see if the string is empty\n+     * @throws IllegalArgumentException if the string is empty\n+     */\n+    public static void notEmpty(String string, String message) {\n+        if (string == null || string.length() == 0) {\n+            throw new IllegalArgumentException(message);\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument String is empty (<code>null</code> or zero length).</p>\n+     *\n+     * <pre>\n+     * Validate.notEmpty(myString);\n+     * </pre>\n+     *\n+     * <p>The message in the exception is 'The validated string is empty'.</p>\n+     * \n+     * @param string  the string to check is not empty\n+     * @throws IllegalArgumentException if the string is empty\n+     */\n+    public static void notEmpty(String string) {\n+        if (string == null || string.length() == 0) {\n+            throw new IllegalArgumentException(\"The validated string is empty\");\n+        }\n+    }\n+\n+    // notNullElements array\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument array has <code>null</code> elements or is\n+     * <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * Validate.noNullElements(myArray, \"The array must not contain null elements\");\n+     * </pre>\n+     * \n+     * <p>If the array is null then the message in the exception is 'The validated object is null'.</p>\n+     *\n+     * @param array  the array to check\n+     * @param message  the exception message if the array has\n+     *  <code>null</code> elements\n+     * @throws IllegalArgumentException if the array has <code>null</code>\n+     *  elements or is <code>null</code>\n+     */\n+    public static void noNullElements(Object[] array, String message) {\n+        Validate.notNull(array);\n+        for (int i = 0; i < array.length; i++) {\n+            if (array[i] == null) {\n+                throw new IllegalArgumentException(message);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument array has <code>null</code> elements or is\n+     * <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * Validate.noNullElements(myArray);\n+     * </pre>\n+     *\n+     * <p>If the array has a null element the message in the exception is\n+     * 'The validated array contains null element at index: '.</p>\n+     *\n+     * <p>If the array is null then the message in the exception is 'The validated object is null'.</p>\n+     * \n+     * @param array  the array to check\n+     * @throws IllegalArgumentException if the array has <code>null</code>\n+     *  elements or is <code>null</code>\n+     */\n+    public static void noNullElements(Object[] array) {\n+        Validate.notNull(array);\n+        for (int i = 0; i < array.length; i++) {\n+            if (array[i] == null) {\n+                throw new IllegalArgumentException(\"The validated array contains null element at index: \" + i);\n+            }\n+        }\n+    }\n+\n+    // notNullElements collection\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument Collection has <code>null</code> elements or is\n+     * <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * Validate.noNullElements(myCollection, \"The collection must not contain null elements\");\n+     * </pre>\n+     *\n+     * <p>If the collection is null then the message in the exception is 'The validated object is null'.</p>\n+     * \n+     * @param collection  the collection to check\n+     * @param message  the exception message if the collection has\n+     *  <code>null</code> elements\n+     * @throws IllegalArgumentException if the collection has\n+     *  <code>null</code> elements or is <code>null</code>\n+     */\n+    public static void noNullElements(Collection collection, String message) {\n+        Validate.notNull(collection);\n+        for (Iterator it = collection.iterator(); it.hasNext();) {\n+            if (it.next() == null) {\n+                throw new IllegalArgumentException(message);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument Collection has <code>null</code> elements or is\n+     * <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * Validate.noNullElements(myCollection);\n+     * </pre>\n+     *\n+     * <p>The message in the exception is 'The validated collection contains null element at index: '.</p>\n+     *\n+     * <p>If the collection is null then the message in the exception is 'The validated object is null'.</p>\n+     * \n+     * @param collection  the collection to check\n+     * @throws IllegalArgumentException if the collection has\n+     *  <code>null</code> elements or is <code>null</code>\n+     */\n+    public static void noNullElements(Collection collection) {\n+        Validate.notNull(collection);\n+        int i = 0;\n+        for (Iterator it = collection.iterator(); it.hasNext(); i++) {\n+            if (it.next() == null) {\n+                throw new IllegalArgumentException(\"The validated collection contains null element at index: \" + i);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n+     * if the argument collection  is <code>null</code> or has elements that\n+     * are not of type <code>clazz</code> or a subclass.</p>\n+     *\n+     * <pre>\n+     * Validate.allElementsOfType(collection, String.class, \"Collection has invalid elements\");\n+     * </pre>\n+     *\n+     * @param collection  the collection to check, not null\n+     * @param clazz  the <code>Class</code> which the collection's elements are expected to be, not null\n+     * @param message  the exception message if the <code>Collection</code> has elements not of type <code>clazz</code>\n+     * @since 2.1\n+     */\n+    public static void allElementsOfType(Collection collection, Class clazz, String message) {\n+        Validate.notNull(collection);\n+        Validate.notNull(clazz);\n+        for (Iterator it = collection.iterator(); it.hasNext(); ) {\n+            if (clazz.isInstance(it.next()) == false) {\n+                throw new IllegalArgumentException(message);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Validate an argument, throwing <code>IllegalArgumentException</code> if the argument collection is\n+     * <code>null</code> or has elements that are not of type <code>clazz</code> or a subclass.\n+     * </p>\n+     * \n+     * <pre>\n+     * Validate.allElementsOfType(collection, String.class);\n+     * </pre>\n+     * \n+     * <p>\n+     * The message in the exception is 'The validated collection contains an element not of type clazz at index: '.\n+     * </p>\n+     * \n+     * @param collection\n+     *            the collection to check, not null\n+     * @param clazz\n+     *            the <code>Class</code> which the collection's elements are expected to be, not null\n+     * @since 2.1\n+     */\n+    public static void allElementsOfType(Collection collection, Class clazz) {\n+        Validate.notNull(collection);\n+        Validate.notNull(clazz);\n+        int i = 0;\n+        for (Iterator it = collection.iterator(); it.hasNext(); i++) {\n+            if (clazz.isInstance(it.next()) == false) {\n+                throw new IllegalArgumentException(\"The validated collection contains an element not of type \"\n+                    + clazz.getName() + \" at index: \" + i);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/WordUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * <p>Operations on Strings that contain words.</p>\n+ * \n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Apache Jakarta Velocity\n+ * @author Henri Yandell\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class WordUtils {\n+\n+    /**\n+     * <p><code>WordUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>WordUtils.wrap(\"foo bar\", 20);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public WordUtils() {\n+      super();\n+    }\n+\n+    // Wrapping\n+    //--------------------------------------------------------------------------\n+//    /**\n+//     * <p>Wraps a block of text to a specified line length using '\\n' as\n+//     * a newline.</p>\n+//     *\n+//     * <p>This method takes a block of text, which might have long lines in it\n+//     * and wraps the long lines based on the supplied lineLength parameter.</p>\n+//     * \n+//     * <p>If a single word is longer than the line length (eg. a URL), it will\n+//     * not be broken, and will display beyond the expected width.</p>\n+//     * \n+//     * <p>If there are tabs in inString, you are going to get results that are\n+//     * a bit strange. Tabs are a single character but are displayed as 4 or 8\n+//     * spaces. Remove the tabs.</p>\n+//     *\n+//     * @param str  text which is in need of word-wrapping, may be null\n+//     * @param lineLength  the column to wrap the words at\n+//     * @return the text with all the long lines word-wrapped\n+//     *  <code>null</code> if null string input\n+//     */\n+//    public static String wrapText(String str, int lineLength) {\n+//        return wrap(str, null, lineLength);\n+//    }\n+    \n+//    /**\n+//     * <p>Wraps a block of text to a specified line length.</p>\n+//     *\n+//     * <p>This method takes a block of text, which might have long lines in it\n+//     * and wraps the long lines based on the supplied lineLength parameter.</p>\n+//     * \n+//     * <p>If a single word is longer than the wrapColumn (eg. a URL), it will\n+//     * not be broken, and will display beyond the expected width.</p>\n+//     * \n+//     * <p>If there are tabs in inString, you are going to get results that are\n+//     * a bit strange. Tabs are a single character but are displayed as 4 or 8\n+//     * spaces. Remove the tabs.</p>\n+//     *\n+//     * @param str  text which is in need of word-wrapping, may be null\n+//     * @param newLineChars  the characters that define a newline, null treated as \\n\n+//     * @param lineLength  the column to wrap the words at\n+//     * @return the text with all the long lines word-wrapped\n+//     *  <code>null</code> if null string input\n+//     */\n+//    public static String wrapText(String str, String newLineChars, int lineLength) {\n+//        if (str == null) {\n+//            return null;\n+//        }\n+//        if (newLineChars == null) {\n+//            newLineChars = \"\\n\";\n+//        }\n+//        StringTokenizer lineTokenizer = new StringTokenizer(str, newLineChars, true);\n+//        StringBuffer stringBuffer = new StringBuffer();\n+//\n+//        while (lineTokenizer.hasMoreTokens()) {\n+//            try {\n+//                String nextLine = lineTokenizer.nextToken();\n+//\n+//                if (nextLine.length() > lineLength) {\n+//                    // This line is long enough to be wrapped.\n+//                    nextLine = wrapLine(nextLine, null, lineLength, false);\n+//                }\n+//\n+//                stringBuffer.append(nextLine);\n+//\n+//            } catch (NoSuchElementException nsee) {\n+//                // thrown by nextToken(), but I don't know why it would\n+//                break;\n+//            }\n+//        }\n+//\n+//        return stringBuffer.toString();\n+//    }\n+\n+    // Wrapping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n+     * \n+     * <p>New lines will be separated by the system property line separator.\n+     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n+     * \n+     * <p>Leading spaces on a new line are stripped.\n+     * Trailing spaces are not stripped.</p>\n+     *\n+     * <pre>\n+     * WordUtils.wrap(null, *) = null\n+     * WordUtils.wrap(\"\", *) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to be word wrapped, may be null\n+     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n+     * @return a line with newlines inserted, <code>null</code> if null input\n+     */\n+    public static String wrap(String str, int wrapLength) {\n+        return wrap(str, wrapLength, null, false);\n+    }\n+    \n+    /**\n+     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n+     * \n+     * <p>Leading spaces on a new line are stripped.\n+     * Trailing spaces are not stripped.</p>\n+     * \n+     * <pre>\n+     * WordUtils.wrap(null, *, *, *) = null\n+     * WordUtils.wrap(\"\", *, *, *) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to be word wrapped, may be null\n+     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n+     * @param newLineStr  the string to insert for a new line, \n+     *  <code>null</code> uses the system property line separator\n+     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n+     * @return a line with newlines inserted, <code>null</code> if null input\n+     */\n+    public static String wrap(String str, int wrapLength, String newLineStr, boolean wrapLongWords) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (newLineStr == null) {\n+            newLineStr = SystemUtils.LINE_SEPARATOR;\n+        }\n+        if (wrapLength < 1) {\n+            wrapLength = 1;\n+        }\n+        int inputLineLength = str.length();\n+        int offset = 0;\n+        StringBuffer wrappedLine = new StringBuffer(inputLineLength + 32);\n+        \n+        while ((inputLineLength - offset) > wrapLength) {\n+            if (str.charAt(offset) == ' ') {\n+                offset++;\n+                continue;\n+            }\n+            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);\n+\n+            if (spaceToWrapAt >= offset) {\n+                // normal case\n+                wrappedLine.append(str.substring(offset, spaceToWrapAt));\n+                wrappedLine.append(newLineStr);\n+                offset = spaceToWrapAt + 1;\n+                \n+            } else {\n+                // really long word or URL\n+                if (wrapLongWords) {\n+                    // wrap really long word one line at a time\n+                    wrappedLine.append(str.substring(offset, wrapLength + offset));\n+                    wrappedLine.append(newLineStr);\n+                    offset += wrapLength;\n+                } else {\n+                    // do not wrap really long word, just extend beyond limit\n+                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);\n+                    if (spaceToWrapAt >= 0) {\n+                        wrappedLine.append(str.substring(offset, spaceToWrapAt));\n+                        wrappedLine.append(newLineStr);\n+                        offset = spaceToWrapAt + 1;\n+                    } else {\n+                        wrappedLine.append(str.substring(offset));\n+                        offset = inputLineLength;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Whatever is left in line is short enough to just pass through\n+        wrappedLine.append(str.substring(offset));\n+\n+        return wrappedLine.toString();\n+    }\n+\n+    // Capitalizing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Capitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed. To convert the \n+     * rest of each word to lowercase at the same time, \n+     * use {@link #capitalizeFully(String)}.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalize(null)        = null\n+     * WordUtils.capitalize(\"\")          = \"\"\n+     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @see #uncapitalize(String)\n+     * @see #capitalizeFully(String)\n+     */\n+    public static String capitalize(String str) {\n+        return capitalize(str, null);\n+    }\n+\n+    /**\n+     * <p>Capitalizes all the delimiter separated words in a String.\n+     * Only the first letter of each word is changed. To convert the \n+     * rest of each word to lowercase at the same time, \n+     * use {@link #capitalizeFully(String, char[])}.</p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be capitalized. </p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalize(null, *)            = null\n+     * WordUtils.capitalize(\"\", *)              = \"\"\n+     * WordUtils.capitalize(*, new char[0])     = *\n+     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n+     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @param delimiters  set of characters to determine capitalization, null means whitespace\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @see #uncapitalize(String)\n+     * @see #capitalizeFully(String)\n+     * @since 2.1\n+     */\n+    public static String capitalize(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        StringBuffer buffer = new StringBuffer(strLen);\n+        boolean capitalizeNext = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                buffer.append(ch);\n+                capitalizeNext = true;\n+            } else if (capitalizeNext) {\n+                buffer.append(Character.toTitleCase(ch));\n+                capitalizeNext = false;\n+            } else {\n+                buffer.append(ch);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts all the whitespace separated words in a String into capitalized words, \n+     * that is each word is made up of a titlecase character and then a series of \n+     * lowercase characters.  </p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalizeFully(null)        = null\n+     * WordUtils.capitalizeFully(\"\")          = \"\"\n+     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @return capitalized String, <code>null</code> if null String input\n+     */\n+    public static String capitalizeFully(String str) {\n+        return capitalizeFully(str, null);\n+    }\n+\n+    /**\n+     * <p>Converts all the delimiter separated words in a String into capitalized words, \n+     * that is each word is made up of a titlecase character and then a series of \n+     * lowercase characters. </p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be capitalized. </p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalizeFully(null, *)            = null\n+     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n+     * WordUtils.capitalizeFully(*, null)            = *\n+     * WordUtils.capitalizeFully(*, new char[0])     = *\n+     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @param delimiters  set of characters to determine capitalization, null means whitespace\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String capitalizeFully(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        str = str.toLowerCase();\n+        return capitalize(str, delimiters);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Uncapitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.uncapitalize(null)        = null\n+     * WordUtils.uncapitalize(\"\")          = \"\"\n+     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to uncapitalize, may be null\n+     * @return uncapitalized String, <code>null</code> if null String input\n+     * @see #capitalize(String)\n+     */\n+    public static String uncapitalize(String str) {\n+        return uncapitalize(str, null);\n+    }\n+\n+    /**\n+     * <p>Uncapitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be uncapitalized. </p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.uncapitalize(null, *)            = null\n+     * WordUtils.uncapitalize(\"\", *)              = \"\"\n+     * WordUtils.uncapitalize(*, null)            = *\n+     * WordUtils.uncapitalize(*, new char[0])     = *\n+     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to uncapitalize, may be null\n+     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n+     * @return uncapitalized String, <code>null</code> if null String input\n+     * @see #capitalize(String)\n+     * @since 2.1\n+     */\n+    public static String uncapitalize(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        StringBuffer buffer = new StringBuffer(strLen);\n+        boolean uncapitalizeNext = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                buffer.append(ch);\n+                uncapitalizeNext = true;\n+            } else if (uncapitalizeNext) {\n+                buffer.append(Character.toLowerCase(ch));\n+                uncapitalizeNext = false;\n+            } else {\n+                buffer.append(ch);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Swaps the case of a String using a word based algorithm.</p>\n+     * \n+     * <ul>\n+     *  <li>Upper case character converts to Lower case</li>\n+     *  <li>Title case character converts to Lower case</li>\n+     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n+     *  <li>Other Lower case character converts to Upper case</li>\n+     * </ul>\n+     * \n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.swapCase(null)                 = null\n+     * StringUtils.swapCase(\"\")                   = \"\"\n+     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n+     * </pre>\n+     * \n+     * @param str  the String to swap case, may be null\n+     * @return the changed String, <code>null</code> if null String input\n+     */\n+    public static String swapCase(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        StringBuffer buffer = new StringBuffer(strLen);\n+\n+        boolean whitespace = true;\n+        char ch = 0;\n+        char tmp = 0;\n+\n+        for (int i = 0; i < strLen; i++) {\n+            ch = str.charAt(i);\n+            if (Character.isUpperCase(ch)) {\n+                tmp = Character.toLowerCase(ch);\n+            } else if (Character.isTitleCase(ch)) {\n+                tmp = Character.toLowerCase(ch);\n+            } else if (Character.isLowerCase(ch)) {\n+                if (whitespace) {\n+                    tmp = Character.toTitleCase(ch);\n+                } else {\n+                    tmp = Character.toUpperCase(ch);\n+                }\n+            } else {\n+                tmp = ch;\n+            }\n+            buffer.append(tmp);\n+            whitespace = Character.isWhitespace(ch);\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Extracts the initial letters from each word in the String.</p>\n+     * \n+     * <p>The first letter of the string and all first letters after\n+     * whitespace are returned as a new string.\n+     * Their case is not changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.initials(null)             = null\n+     * WordUtils.initials(\"\")               = \"\"\n+     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n+     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n+     * </pre>\n+     *\n+     * @param str  the String to get initials from, may be null\n+     * @return String of initial letters, <code>null</code> if null String input\n+     * @see #initials(String,char[])\n+     * @since 2.2\n+     */\n+    public static String initials(String str) {\n+        return initials(str, null);\n+    }\n+\n+    /**\n+     * <p>Extracts the initial letters from each word in the String.</p>\n+     * \n+     * <p>The first letter of the string and all first letters after the\n+     * defined delimiters are returned as a new string.\n+     * Their case is not changed.</p>\n+     *\n+     * <p>If the delimiters array is null, then Whitespace is used.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * An empty delimiter array returns an empty String.</p>\n+     *\n+     * <pre>\n+     * WordUtils.initials(null, *)                = null\n+     * WordUtils.initials(\"\", *)                  = \"\"\n+     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n+     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n+     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n+     * WordUtils.initials(*, new char[0])         = \"\"\n+     * </pre>\n+     * \n+     * @param str  the String to get initials from, may be null\n+     * @param delimiters  set of characters to determine words, null means whitespace\n+     * @return String of initial letters, <code>null</code> if null String input\n+     * @see #initials(String)\n+     * @since 2.2\n+     */\n+    public static String initials(String str, char[] delimiters) {\n+        if (str == null || str.length() == 0) {\n+            return str;\n+        }\n+        if (delimiters != null && delimiters.length == 0) {\n+            return \"\";\n+        }\n+        int strLen = str.length();\n+        char[] buf = new char[strLen / 2 + 1];\n+        int count = 0;\n+        boolean lastWasGap = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                lastWasGap = true;\n+            } else if (lastWasGap) {\n+                buf[count++] = ch;\n+                lastWasGap = false;\n+            } else {\n+                // ignore ch\n+            }\n+        }\n+        return new String(buf, 0, count);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is the character a delimiter.\n+     *\n+     * @param ch  the character to check\n+     * @param delimiters  the delimiters\n+     * @return true if it is a delimiter\n+     */\n+    private static boolean isDelimiter(char ch, char[] delimiters) {\n+        if (delimiters == null) {\n+            return Character.isWhitespace(ch);\n+        }\n+        for (int i = 0, isize = delimiters.length; i < isize; i++) {\n+            if (ch == delimiters[i]) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.commons.lang.math.NumberUtils;\n+\n+/** \n+ * Assists in implementing {@link java.lang.Comparable#compareTo(Object)} methods.\n+ *\n+ * It is consistent with <code>equals(Object)</code> and\n+ * <code>hashcode()</code> built with {@link EqualsBuilder} and\n+ * {@link HashCodeBuilder}.</p>\n+ *\n+ * <p>Two Objects that compare equal using <code>equals(Object)</code> should normally\n+ * also compare equal using <code>compareTo(Object)</code>.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of the\n+ * comparison. Derived fields may be ignored. The same fields, in the same\n+ * order, should be used in both <code>compareTo(Object)</code> and\n+ * <code>equals(Object)</code>.</p>\n+ *\n+ * <p>To use this class write code as follows:</p>\n+ *\n+ * <pre>\n+ * public class MyClass {\n+ *   String field1;\n+ *   int field2;\n+ *   boolean field3;\n+ *\n+ *   ...\n+ *\n+ *   public int compareTo(Object o) {\n+ *     MyClass myClass = (MyClass) o;\n+ *     return new CompareToBuilder()\n+ *       .appendSuper(super.compareTo(o)\n+ *       .append(this.field1, myClass.field1)\n+ *       .append(this.field2, myClass.field2)\n+ *       .append(this.field3, myClass.field3)\n+ *       .toComparison();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>Alternatively, there are {@link #reflectionCompare(Object, Object) reflectionCompare} methods that use\n+ * reflection to determine the fields to append. Because fields can be private,\n+ * <code>reflectionCompare</code> uses {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} to\n+ * bypass normal access control checks. This will fail under a security manager,\n+ * unless the appropriate permissions are set up correctly. It is also\n+ * slower than appending explicitly.</p>\n+ *\n+ * <p>A typical implementation of <code>compareTo(Object)</code> using\n+ * <code>reflectionCompare</code> looks like:</p>\n+\n+ * <pre>\n+ * public int compareTo(Object o) {\n+ *   return CompareToBuilder.reflectionCompare(this, o);\n+ * }\n+ * </pre>\n+ *\n+ * @see java.lang.Comparable\n+ * @see java.lang.Object#equals(Object)\n+ * @see java.lang.Object#hashCode()\n+ * @see EqualsBuilder\n+ * @see HashCodeBuilder\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CompareToBuilder {\n+    \n+    /**\n+     * Current state of the comparison as appended fields are checked.\n+     */\n+    private int comparison;\n+\n+    /**\n+     * <p>Constructor for CompareToBuilder.</p>\n+     *\n+     * <p>Starts off assuming that the objects are equal. Multiple calls are \n+     * then made to the various append methods, followed by a call to \n+     * {@link #toComparison} to get the result.</p>\n+     */\n+    public CompareToBuilder() {\n+        super();\n+        comparison = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>Transient members will be not be compared, as they are likely derived\n+     *     fields</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either (but not both) parameters are\n+     *  <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs) {\n+        return reflectionCompare(lhs, rhs, false, null, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients) {\n+        return reflectionCompare(lhs, rhs, compareTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param excludeFields  Collection of String fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, Collection /*String*/ excludeFields) {\n+        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param excludeFields  array of fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If the <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Compares superclass fields up to and including <code>reflectUpToClass</code>.\n+     *     If <code>reflectUpToClass</code> is <code>null</code>, compares all superclass fields.</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @param reflectUpToClass  last superclass for which fields are compared\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, \n+                                        Class reflectUpToClass) \n+    {\n+        return reflectionCompare(lhs, rhs, false, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If the <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Compares superclass fields up to and including <code>reflectUpToClass</code>.\n+     *     If <code>reflectUpToClass</code> is <code>null</code>, compares all superclass fields.</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @param reflectUpToClass  last superclass for which fields are compared\n+     * @param excludeFields  fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(\n+        Object lhs, \n+        Object rhs, \n+        boolean compareTransients, \n+        Class reflectUpToClass, \n+        String[] excludeFields) {\n+\n+        if (lhs == rhs) {\n+            return 0;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        Class lhsClazz = lhs.getClass();\n+        if (!lhsClazz.isInstance(rhs)) {\n+            throw new ClassCastException();\n+        }\n+        CompareToBuilder compareToBuilder = new CompareToBuilder();\n+        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n+        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n+            lhsClazz = lhsClazz.getSuperclass();\n+            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n+        }\n+        return compareToBuilder.toComparison();\n+    }\n+\n+    /**\n+     * <p>Appends to <code>builder</code> the comparison of <code>lhs</code>\n+     * to <code>rhs</code> using the fields defined in <code>clazz</code>.</p>\n+     * \n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param clazz  <code>Class</code> that defines fields to be compared\n+     * @param builder  <code>CompareToBuilder</code> to append to\n+     * @param useTransients  whether to compare transient fields\n+     * @param excludeFields  fields to exclude\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class clazz,\n+        CompareToBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+        \n+        Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n+            Field f = fields[i];\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n+                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                && (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    // This can't happen. Would get a Security exception instead.\n+                    // Throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the <code>compareTo(Object)</code>\n+     * result of the superclass.</p>\n+     *\n+     * @param superCompareTo  result of calling <code>super.compareTo(Object)</code>\n+     * @return this - used to chain append calls\n+     * @since 2.0\n+     */\n+    public CompareToBuilder appendSuper(int superCompareTo) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = superCompareTo;\n+        return this;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>Object</code>s.</p>\n+     *\n+     * <ol>\n+     * <li>Check if <code>lhs == rhs</code></li>\n+     * <li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,\n+     *     a <code>null</code> object is less than a non-<code>null</code> object</li>\n+     * <li>Check the object contents</li>\n+     * </ol>\n+     * \n+     * <p><code>lhs</code> must either be an array or implement {@link Comparable}.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public CompareToBuilder append(Object lhs, Object rhs) {\n+        return append(lhs, rhs, null);\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>Object</code>s.</p>\n+     *\n+     * <ol>\n+     * <li>Check if <code>lhs == rhs</code></li>\n+     * <li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,\n+     *     a <code>null</code> object is less than a non-<code>null</code> object</li>\n+     * <li>Check the object contents</li>\n+     * </ol>\n+     *\n+     * <p>If <code>lhs</code> is an array, array comparison methods will be used.\n+     * Otherwise <code>comparator</code> will be used to compare the objects.\n+     * If <code>comparator</code> is <code>null</code>, <code>lhs</code> must\n+     * implement {@link Comparable} instead.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param comparator  <code>Comparator</code> used to compare the objects,\n+     *  <code>null</code> means treat lhs as <code>Comparable</code>\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    public CompareToBuilder append(Object lhs, Object rhs, Comparator comparator) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.getClass().isArray()) {\n+            // switch on type of array, to dispatch to the correct handler\n+            // handles multi dimensional arrays\n+            // throws a ClassCastException if rhs is not the correct array type\n+            if (lhs instanceof long[]) {\n+                append((long[]) lhs, (long[]) rhs);\n+            } else if (lhs instanceof int[]) {\n+                append((int[]) lhs, (int[]) rhs);\n+            } else if (lhs instanceof short[]) {\n+                append((short[]) lhs, (short[]) rhs);\n+            } else if (lhs instanceof char[]) {\n+                append((char[]) lhs, (char[]) rhs);\n+            } else if (lhs instanceof byte[]) {\n+                append((byte[]) lhs, (byte[]) rhs);\n+            } else if (lhs instanceof double[]) {\n+                append((double[]) lhs, (double[]) rhs);\n+            } else if (lhs instanceof float[]) {\n+                append((float[]) lhs, (float[]) rhs);\n+            } else if (lhs instanceof boolean[]) {\n+                append((boolean[]) lhs, (boolean[]) rhs);\n+            } else {\n+                // not an array of primitives\n+                // throws a ClassCastException if rhs is not an array\n+                append((Object[]) lhs, (Object[]) rhs, comparator);\n+            }\n+        } else {\n+            // the simple case, not an array, just test the element\n+            if (comparator == null) {\n+                comparison = ((Comparable) lhs).compareTo(rhs);\n+            } else {\n+                comparison = comparator.compare(lhs, rhs);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>long</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(long lhs, long rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>int</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(int lhs, int rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>short</code>s.\n+     * \n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(short lhs, short rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>char</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(char lhs, char rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>byte</code>s.\n+     * \n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(byte lhs, byte rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>double</code>s.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(double lhs, double rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = NumberUtils.compare(lhs, rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>float</code>s.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(float lhs, float rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = NumberUtils.compare(lhs, rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>booleans</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+      */\n+    public CompareToBuilder append(boolean lhs, boolean rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == false) {\n+            comparison = -1;\n+        } else {\n+            comparison = +1;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>Object</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a short length array is less than a long length array</li>\n+     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n+     * </ol>\n+     *\n+     * <p>This method will also will be called for the top level of multi-dimensional,\n+     * ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public CompareToBuilder append(Object[] lhs, Object[] rhs) {\n+        return append(lhs, rhs, null);\n+    }\n+    \n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>Object</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a short length array is less than a long length array</li>\n+     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n+     * </ol>\n+     *\n+     * <p>This method will also will be called for the top level of multi-dimensional,\n+     * ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @param comparator  <code>Comparator</code> to use to compare the array elements,\n+     *  <code>null</code> means to treat <code>lhs</code> elements as <code>Comparable</code>.\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    public CompareToBuilder append(Object[] lhs, Object[] rhs, Comparator comparator) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i], comparator);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>long</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(long, long)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(long[] lhs, long[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>int</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(int, int)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(int[] lhs, int[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>short</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(short, short)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(short[] lhs, short[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>char</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(char, char)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(char[] lhs, char[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>byte</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(byte, byte)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(byte[] lhs, byte[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>double</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(double, double)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(double[] lhs, double[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>float</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(float, float)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(float[] lhs, float[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>boolean</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(boolean, boolean)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a negative integer, a positive integer, or zero as\n+     * the <code>builder</code> has judged the \"left-hand\" side\n+     * as less than, greater than, or equal to the \"right-hand\"\n+     * side.\n+     * \n+     * @return final comparison result\n+     */\n+    public int toComparison() {\n+        return comparison;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n+ *\n+ * <p> This class provides methods to build a good equals method for any\n+ * class. It follows rules laid out in\n+ * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\n+ * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,\n+ * <code>floats</code>, and arrays can be tricky. Also, making sure that\n+ * <code>equals()</code> and <code>hashCode()</code> are consistent can be\n+ * difficult.</p>\n+ *\n+ * <p>Two Objects that compare as equals must generate the same hash code,\n+ * but two Objects with the same hash code do not have to be equal.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of equals.\n+ * Derived fields may be ignored. In particular, any field used in\n+ * generating a hash code must be used in the equals method, and vice\n+ * versa.</p>\n+ *\n+ * <p>Typical use for the code is as follows:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   if (obj instanceof MyClass == false) {\n+ *     return false;\n+ *   }\n+ *   if (this == obj) {\n+ *     return true;\n+ *   }\n+ *   MyClass rhs = (MyClass) obj;\n+ *   return new EqualsBuilder()\n+ *                 .appendSuper(super.equals(obj))\n+ *                 .append(field1, rhs.field1)\n+ *                 .append(field2, rhs.field2)\n+ *                 .append(field3, rhs.field3)\n+ *                 .isEquals();\n+ *  }\n+ * </pre>\n+ *\n+ * <p> Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method,\n+ * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security\n+ * manager, unless the appropriate permissions are set up correctly. It is\n+ * also slower than testing explicitly.</p>\n+ *\n+ * <p> A typical invocation for this method would look like:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   return EqualsBuilder.reflectionEquals(this, obj);\n+ * }\n+ * </pre>\n+ *\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @author Arun Mammen Thomas\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class EqualsBuilder {\n+    \n+    /**\n+     * If the fields tested are equals.\n+     * The default value is <code>true</code>.\n+     */\n+    private boolean isEquals = true;\n+\n+    /**\n+     * <p>Constructor for EqualsBuilder.</p>\n+     *\n+     * <p>Starts off assuming that equals is <code>true</code>.</p>\n+     * @see Object#equals(Object)\n+     */\n+    public EqualsBuilder() {\n+        // do nothing for now.\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs) {\n+        return reflectionEquals(lhs, rhs, false, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  Collection of String field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, Collection /*String*/ excludeFields) {\n+        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+        return reflectionEquals(lhs, rhs, testTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {\n+        return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass,\n+            String[] excludeFields) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null) {\n+            return false;\n+        }\n+        // Find the leaf class since there may be transients in the leaf \n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars, \n+        // then a subclass can test equals to a superclass.\n+        Class lhsClass = lhs.getClass();\n+        Class rhsClass = rhs.getClass();\n+        Class testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            return false;\n+        }\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        try {\n+            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                testClass = testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and \n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            return false;\n+        }\n+        return equalsBuilder.isEquals();\n+    }\n+\n+    /**\n+     * <p>Appends the fields and values defined by the given object of the\n+     * given Class.</p>\n+     * \n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to test transient fields\n+     * @param excludeFields  array of field names to exclude from testing\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class clazz,\n+        EqualsBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+        Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+            Field f = fields[i];\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n+                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                && (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\n+     *\n+     * @param superEquals  the result of calling <code>super.equals()</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     * @since 2.0\n+     */\n+    public EqualsBuilder appendSuper(boolean superEquals) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = superEquals;\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Test if two <code>Object</code>s are equal using their\n+     * <code>equals</code> method.</p>\n+     *\n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object lhs, Object rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        Class lhsClass = lhs.getClass();\n+        if (!lhsClass.isArray()) {\n+            // The simple case, not an array, just test the element\n+            isEquals = lhs.equals(rhs);\n+        } else if (lhs.getClass() != rhs.getClass()) {\n+            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n+            this.setEquals(false);\n+        }\n+        // 'Switch' on type of array, to dispatch to the correct handler\n+        // This handles multi dimensional arrays of the same depth\n+        else if (lhs instanceof long[]) {\n+            append((long[]) lhs, (long[]) rhs);\n+        } else if (lhs instanceof int[]) {\n+            append((int[]) lhs, (int[]) rhs);\n+        } else if (lhs instanceof short[]) {\n+            append((short[]) lhs, (short[]) rhs);\n+        } else if (lhs instanceof char[]) {\n+            append((char[]) lhs, (char[]) rhs);\n+        } else if (lhs instanceof byte[]) {\n+            append((byte[]) lhs, (byte[]) rhs);\n+        } else if (lhs instanceof double[]) {\n+            append((double[]) lhs, (double[]) rhs);\n+        } else if (lhs instanceof float[]) {\n+            append((float[]) lhs, (float[]) rhs);\n+        } else if (lhs instanceof boolean[]) {\n+            append((boolean[]) lhs, (boolean[]) rhs);\n+        } else {\n+            // Not an array of primitives\n+            append((Object[]) lhs, (Object[]) rhs);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Test if two <code>long</code> s are equal.\n+     * </p>\n+     * \n+     * @param lhs\n+     *                  the left hand <code>long</code>\n+     * @param rhs\n+     *                  the right hand <code>long</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long lhs, long rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>int</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>int</code>\n+     * @param rhs  the right hand <code>int</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int lhs, int rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>short</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>short</code>\n+     * @param rhs  the right hand <code>short</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short lhs, short rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>char</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>char</code>\n+     * @param rhs  the right hand <code>char</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char lhs, char rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>byte</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>byte</code>\n+     * @param rhs  the right hand <code>byte</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte lhs, byte rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>double</code>s are equal by testing that the\n+     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>double</code>\n+     * @param rhs  the right hand <code>double</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double lhs, double rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>float</code>s are equal byt testing that the\n+     * pattern of bits returned by doubleToLong are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>float</code>\n+     * @param rhs  the right hand <code>float</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float lhs, float rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>booleans</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean</code>\n+     * @param rhs  the right hand <code>boolean</code>\n+     * @return EqualsBuilder - used to chain calls.\n+      */\n+    public EqualsBuilder append(boolean lhs, boolean rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\n+     *\n+     * <p>This also will be called for the top level of\n+     * multi-dimensional, ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  the left hand <code>Object[]</code>\n+     * @param rhs  the right hand <code>Object[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>long</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(long, long)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>long[]</code>\n+     * @param rhs  the right hand <code>long[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long[] lhs, long[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>int</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(int, int)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>int[]</code>\n+     * @param rhs  the right hand <code>int[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int[] lhs, int[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>short</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(short, short)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>short[]</code>\n+     * @param rhs  the right hand <code>short[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short[] lhs, short[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>char</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(char, char)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>char[]</code>\n+     * @param rhs  the right hand <code>char[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char[] lhs, char[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>byte</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(byte, byte)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>byte[]</code>\n+     * @param rhs  the right hand <code>byte[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>double</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(double, double)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>double[]</code>\n+     * @param rhs  the right hand <code>double[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double[] lhs, double[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>float</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(float, float)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>float[]</code>\n+     * @param rhs  the right hand <code>float[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float[] lhs, float[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>boolean</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(boolean, boolean)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean[]</code>\n+     * @param rhs  the right hand <code>boolean[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the fields that have been checked\n+     * are all equal.</p>\n+     *\n+     * @return boolean\n+     */\n+    public boolean isEquals() {\n+        return this.isEquals;\n+    }\n+\n+    /**\n+     * Sets the <code>isEquals</code> value.\n+     * \n+     * @param isEquals The value to set.\n+     * @since 2.1\n+     */\n+    protected void setEquals(boolean isEquals) {\n+        this.isEquals = isEquals;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#hashCode()} methods.</p>\n+ *\n+ * <p> This class enables a good <code>hashCode</code> method to be built for any class. It\n+ * follows the rules laid out in the book\n+ * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\n+ * by Joshua Bloch. Writing a good <code>hashCode</code> method is actually quite\n+ * difficult. This class aims to simplify the process.</p>\n+ *\n+ * <p>All relevant fields from the object should be included in the\n+ * <code>hashCode</code> method. Derived fields may be excluded. In general, any\n+ * field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n+ * method.</p>\n+ *\n+ * <p>To use this class write code as follows:</p>\n+ * <pre>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean smoker;\n+ *   ...\n+ *\n+ *   public int hashCode() {\n+ *     // you pick a hard-coded, randomly chosen, non-zero, odd number\n+ *     // ideally different for each class\n+ *     return new HashCodeBuilder(17, 37).\n+ *       append(name).\n+ *       append(age).\n+ *       append(smoker).\n+ *       toHashCode();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>If required, the superclass <code>hashCode()</code> can be added\n+ * using {@link #appendSuper}.</p>\n+ *\n+ * <p>Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method,\n+ * <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security manager,\n+ * unless the appropriate permissions are set up correctly. It is also slower\n+ * than testing explicitly.</p>\n+ *\n+ * <p>A typical invocation for this method would look like:</p>\n+ * <pre>\n+ * public int hashCode() {\n+ *   return HashCodeBuilder.reflectionHashCode(this);\n+ * }\n+ * </pre>\n+ *\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class HashCodeBuilder {\n+\n+    /**\n+     * Constant to use in building the hashCode.\n+     */\n+    private final int iConstant;\n+    /**\n+     * Running total of the hashCode.\n+     */\n+    private int iTotal = 0;\n+\n+    /**\n+     * <p>Uses two hard coded choices for the constants\n+     * needed to build a <code>hashCode</code>.</p>\n+     */\n+    public HashCodeBuilder() {\n+        iConstant = 37;\n+        iTotal = 17;\n+    }\n+\n+    /**\n+     * <p>Two randomly chosen, non-zero, odd numbers must be passed in.\n+     * Ideally these should be different for each class, however this is\n+     * not vital.</p>\n+     *\n+     * <p>Prime numbers are preferred, especially for the multiplier.</p>\n+     *\n+     * @param initialNonZeroOddNumber  a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber  a non-zero, odd number used as the multiplier\n+     * @throws IllegalArgumentException if the number is zero or even\n+     */\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>This constructor uses two hard coded choices for the constants\n+     * needed to build a hash code.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be used, as they are likely derived\n+     * fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object) {\n+        return reflectionHashCode(17, 37, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>This constructor uses two hard coded choices for the constants\n+     * needed to build a hash code.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be used, as they are likely derived\n+     * fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @param excludeFields  Collection of String field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, Collection /*String*/ excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>This constructor uses two hard coded choices for the constants\n+     * needed to build a hash code.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be used, as they are likely derived\n+     * fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @param excludeFields  array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, String[] excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>This constructor uses two hard coded choices for the constants needed\n+     * to build a hash code.</p>\n+     *\n+     * <p> It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.</p>\n+     *\n+     * <P>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @param testTransients  whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be used, as they are likely derived\n+     * fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n+     * these should be different for each class, however this is not vital.\n+     * Prime numbers are preferred, especially for the multiplier.</p>\n+     *\n+     * @param initialNonZeroOddNumber  a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber  a non-zero, odd number used as the multiplier\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * @throws IllegalArgumentException if the number is zero or even\n+     */\n+    public static int reflectionHashCode(\n+            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n+     * these should be different for each class, however this is not vital.\n+     * Prime numbers are preferred, especially for the multiplier.</p>\n+     *\n+     * @param initialNonZeroOddNumber  a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber  a non-zero, odd number used as the multiplier\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @param testTransients  whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * @throws IllegalArgumentException if the number is zero or even\n+     */\n+    public static int reflectionHashCode(\n+            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n+            Object object, boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, \n+                                  object, testTransients, null, null\n+                                 );\n+    }\n+            \n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n+                                         Object object, boolean testTransients, Class reflectUpToClass) \n+    {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, \n+                                  testTransients, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be included\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * <p>Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n+     * these should be different for each class, however this is not vital.\n+     * Prime numbers are preferred, especially for the multiplier.</p>\n+     *\n+     * @param initialNonZeroOddNumber  a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber  a non-zero, odd number used as the multiplier\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * @throws IllegalArgumentException if the number is zero or even\n+     * @since 2.0\n+     */\n+    public static int reflectionHashCode(\n+        int initialNonZeroOddNumber,\n+        int multiplierNonZeroOddNumber,\n+        Object object,\n+        boolean testTransients,\n+        Class reflectUpToClass,\n+        String[] excludeFields) {\n+\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n+        }\n+        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n+        Class clazz = object.getClass();\n+        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        }\n+        return builder.toHashCode();\n+    }\n+\n+    /**\n+     * <p>Appends the fields and values defined by the given object of the\n+     * given <code>Class</code>.</p>\n+     * \n+     * @param object  the object to append details of\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to use transient fields\n+     * @param excludeFields  Collection of String field names to exclude from use in calculation of hash code\n+     */\n+    private static void reflectionAppend(\n+            Object object, \n+            Class clazz, \n+            HashCodeBuilder builder, \n+            boolean useTransients,\n+            String[] excludeFields) {\n+        Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length; i++) {\n+            Field f = fields[i];\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n+                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                && (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(object));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Adds the result of super.hashCode() to this builder.</p>\n+     *\n+     * @param superHashCode  the result of calling <code>super.hashCode()</code>\n+     * @return this HashCodeBuilder, used to chain calls.\n+     * @since 2.0\n+     */\n+    public HashCodeBuilder appendSuper(int superHashCode) {\n+        iTotal = iTotal * iConstant + superHashCode;\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for an <code>Object</code>.</p>\n+     *\n+     * @param object  the Object to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object object) {\n+        if (object == null) {\n+            iTotal = iTotal * iConstant;\n+\n+        } else {\n+            if (object.getClass().isArray() == false) {\n+                //the simple case, not an array, just the element\n+                iTotal = iTotal * iConstant + object.hashCode();\n+\n+            } else {\n+                //'Switch' on type of array, to dispatch to the correct handler\n+                // This handles multi dimensional arrays\n+                if (object instanceof long[]) {\n+                    append((long[]) object);\n+                } else if (object instanceof int[]) {\n+                    append((int[]) object);\n+                } else if (object instanceof short[]) {\n+                    append((short[]) object);\n+                } else if (object instanceof char[]) {\n+                    append((char[]) object);\n+                } else if (object instanceof byte[]) {\n+                    append((byte[]) object);\n+                } else if (object instanceof double[]) {\n+                    append((double[]) object);\n+                } else if (object instanceof float[]) {\n+                    append((float[]) object);\n+                } else if (object instanceof boolean[]) {\n+                    append((boolean[]) object);\n+                } else {\n+                    // Not an array of primitives\n+                    append((Object[]) object);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>long</code>.</p>\n+     *\n+     * @param value  the long to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for an <code>int</code>.</p>\n+     *\n+     * @param value  the int to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>short</code>.</p>\n+     *\n+     * @param value  the short to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>char</code>.</p>\n+     *\n+     * @param value  the char to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>byte</code>.</p>\n+     *\n+     * @param value  the byte to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>double</code>.</p>\n+     *\n+     * @param value  the double to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double value) {\n+        return append(Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>float</code>.</p>\n+     *\n+     * @param value  the float to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>boolean</code>.</p>\n+     * <p>This adds <code>iConstant * 1</code> to the <code>hashCode</code>\n+     * and not a <code>1231</code> or <code>1237</code> as done in java.lang.Boolean. \n+     * This is in accordance with the <quote>Effective Java</quote> design. </p>\n+     *\n+     * @param value  the boolean to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for an <code>Object</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>long</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for an <code>int</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>short</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>char</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>byte</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>double</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>float</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append a <code>hashCode</code> for a <code>boolean</code> array.</p>\n+     *\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Return the computed <code>hashCode</code>.</p>\n+     *\n+     * @return <code>hashCode</code> based on the fields appended\n+     */\n+    public int toHashCode() {\n+        return iTotal;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#toString()} methods using reflection.\n+ * </p>\n+ * \n+ * <p>\n+ * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n+ * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n+ * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n+ * set up correctly.\n+ * </p>\n+ * \n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * \n+ * <pre>\n+ * public String toString() {\n+ *   return ReflectionToStringBuilder.toString(this);\n+ * }</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * You can also use the builder to debug 3rd party objects:\n+ * </p>\n+ * \n+ * <pre>\n+ * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * A subclass can control field output by overriding the methods:\n+ * <ul>\n+ * <li>{@link #accept(java.lang.reflect.Field)}</li>\n+ * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * For example, this method does <i>not</i> include the <code>password</code> field in the returned\n+ * <code>String</code>:\n+ * </p>\n+ * \n+ * <pre>\n+ * public String toString() {\n+ *     return (new ReflectionToStringBuilder(this) {\n+ *         protected boolean accept(Field f) {\n+ *             return super.accept(f) && !f.getName().equals(\"password\");\n+ *         }\n+ *     }).toString();\n+ * }</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the\n+ * constructor.\n+ * </p>\n+ * \n+ * @author Gary Gregory\n+ * @author Stephen Colebourne\n+ * @author Pete Gieser\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ReflectionToStringBuilder extends ToStringBuilder {\n+    /**\n+     * <p>\n+     * A registry of objects used by <code>reflectionToString</code> methods to detect cyclical object references and\n+     * avoid infinite loops.\n+     * </p>\n+     */\n+    private static ThreadLocal registry = new ThreadLocal() {\n+        protected synchronized Object initialValue() {\n+            // The HashSet implementation is not synchronized,\n+            // which is just what we need here.\n+            return new HashSet();\n+        }\n+    };\n+\n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the <code>reflectionToString</code> methods in the current\n+     * thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n+     */\n+    static Set getRegistry() {\n+        return (Set) registry.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getRegistry().contains(value);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to register.\n+     */\n+    static void register(Object value) {\n+        getRegistry().add(value);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object) {\n+        return toString(object, null, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style) {\n+        return toString(object, style, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+        return toString(object, style, outputTransients, outputStatics, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     * \n+     * <p>\n+     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n+     * <code>java.lang.Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics,\n+            Class reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n+                .toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended up to and including the specified\n+     * superclass. A null superclass is treated as <code>java.lang.Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @deprecated Use {@link #toString(Object,ToStringStyle,boolean,boolean,Class)}\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.0\n+     */\n+    public static String toString(Object object, ToStringStyle style, \n+                                  boolean outputTransients, Class reflectUpToClass) \n+    {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients).toString();\n+    }\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field name.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldName\n+     *            The field name to exclude\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, final String excludeFieldName) {\n+        return toStringExclude(object, new String[]{excludeFieldName});\n+    }\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude. Null excludes nothing.\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, Collection /*String*/ excludeFieldNames) {\n+        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n+    }\n+\n+    /**\n+     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n+     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element \n+     * is <code>null</code>.\n+     * \n+     * @param collection\n+     *            The collection to convert\n+     * @return A new array of Strings.\n+     */\n+    static String[] toNoNullStringArray(Collection collection) {\n+        if (collection == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return toNoNullStringArray(collection.toArray());\n+    }\n+\n+    /**\n+     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n+     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} \n+     * if an array element is <code>null</code>.\n+     * \n+     * @param array\n+     *            The array to check\n+     * @return The given array or a new array without null.\n+     */\n+    static String[] toNoNullStringArray(Object[] array) {\n+        ArrayList list = new ArrayList(array.length);\n+        for (int i = 0; i < array.length; i++) {\n+            Object e = array[i];\n+            if (e != null) {\n+                list.add(e.toString());\n+            }\n+        }\n+        return (String[]) list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+    }\n+    \n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, String[] excludeFieldNames) {\n+        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to unregister.\n+     */\n+    static void unregister(Object value) {\n+        getRegistry().remove(value);\n+    }\n+\n+    /**\n+     * Whether or not to append static fields.\n+     */\n+    private boolean appendStatics = false;\n+\n+    /**\n+     * Whether or not to append transient fields.\n+     */\n+    private boolean appendTransients = false;\n+\n+    /**\n+     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n+     */\n+    private String[] excludeFieldNames;\n+\n+    /**\n+     * The last super class to stop appending fields for.\n+     */\n+    private Class upToClass = null;\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+        super(object, style);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     * \n+     * <p>\n+     * If the buffer is <code>null</code>, a new one is created.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        super(object, style, buffer);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @deprecated Use {@link #ReflectionToStringBuilder(Object,ToStringStyle,StringBuffer,Class,boolean,boolean)}.\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class reflectUpToClass,\n+            boolean outputTransients) {\n+        super(object, style, buffer);\n+        this.setUpToClass(reflectUpToClass);\n+        this.setAppendTransients(outputTransients);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @since 2.1\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class reflectUpToClass,\n+            boolean outputTransients, boolean outputStatics) {\n+        super(object, style, buffer);\n+        this.setUpToClass(reflectUpToClass);\n+        this.setAppendTransients(outputTransients);\n+        this.setAppendStatics(outputStatics);\n+    }\n+\n+    /**\n+     * Returns whether or not to append the given <code>Field</code>.\n+     * <ul>\n+     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n+     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n+     * <li>Inner class fields are not appened.</li>\n+     * </ul>\n+     * \n+     * @param field\n+     *            The Field to test.\n+     * @return Whether or not to append the given <code>Field</code>.\n+     */\n+    protected boolean accept(Field field) {\n+        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n+            // Reject field from inner class.\n+            return false;\n+        }\n+        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n+            // Reject transient fields.\n+            return false;\n+        }\n+        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n+            // Rject static fields.\n+            return false;\n+        }\n+        if (this.getExcludeFieldNames() != null\n+            && Arrays.binarySearch(this.getExcludeFieldNames(), field.getName()) >= 0) {\n+            // Reject fields from the getExcludeFieldNames list.\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given Class.\n+     * </p>\n+     * \n+     * <p>\n+     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n+     * <code>Object.toString()</code> had been called and not implemented by the object.\n+     * </p>\n+     * \n+     * @param clazz\n+     *            The class of object parameter\n+     */\n+    protected void appendFieldsIn(Class clazz) {\n+        if (isRegistered(this.getObject())) {\n+            // The object has already been appended, therefore we have an\n+            // object cycle.\n+            // Append a simple Object.toString style string. The field name is\n+            // already appended at this point.\n+            this.appendAsObjectToString(this.getObject());\n+            return;\n+        }\n+        try {\n+            this.registerObject();\n+            if (clazz.isArray()) {\n+                this.reflectionAppendArray(this.getObject());\n+                return;\n+            }\n+            Field[] fields = clazz.getDeclaredFields();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (int i = 0; i < fields.length; i++) {\n+                Field field = fields[i];\n+                String fieldName = field.getName();\n+                if (this.accept(field)) {\n+                    try {\n+                        // Warning: Field.get(Object) creates wrappers objects\n+                        // for primitive types.\n+                        Object fieldValue = this.getValue(field);\n+                        if (isRegistered(fieldValue) && !field.getType().isPrimitive()) {\n+                            // A known field value has already been appended,\n+                            // therefore we have an object cycle,\n+                            // append a simple Object.toString style string.\n+                            this.getStyle().appendFieldStart(this.getStringBuffer(), fieldName);\n+                            this.appendAsObjectToString(fieldValue);\n+                            this.getStyle().appendFieldEnd(this.getStringBuffer(), fieldName);\n+                            // The recursion out of\n+                            // builder.append(fieldName, fieldValue);\n+                            // below will append the field\n+                            // end marker.\n+                        } else {\n+                            try {\n+                                this.registerObject();\n+                                this.append(fieldName, fieldValue);\n+                            } finally {\n+                                this.unregisterObject();\n+                            }\n+                        }\n+                    } catch (IllegalAccessException ex) {\n+                        // this can't happen. Would get a Security exception\n+                        // instead\n+                        // throw a runtime exception in case the impossible\n+                        // happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                    }\n+                }\n+            }\n+        } finally {\n+            this.unregisterObject();\n+        }\n+    }\n+\n+    /**\n+     * @return Returns the excludeFieldNames.\n+     */\n+    public String[] getExcludeFieldNames() {\n+        return this.excludeFieldNames;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the last super class to stop appending fields for.\n+     * </p>\n+     * \n+     * @return The last super class to stop appending fields for.\n+     */\n+    public Class getUpToClass() {\n+        return this.upToClass;\n+    }\n+\n+    /**\n+     * <p>\n+     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n+     * </p>\n+     * \n+     * @param field\n+     *            The Field to query.\n+     * @return The Object from the given Field.\n+     * \n+     * @throws IllegalArgumentException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     * @throws IllegalAccessException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     * \n+     * @see java.lang.reflect.Field#get(Object)\n+     */\n+    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+        return field.get(this.getObject());\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append static fields.\n+     * </p>\n+     * \n+     * @return Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public boolean isAppendStatics() {\n+        return this.appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append transient fields.\n+     * </p>\n+     * \n+     * @return Whether or not to append transient fields.\n+     */\n+    public boolean isAppendTransients() {\n+        return this.appendTransients;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append to the <code>toString</code> an <code>Object</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder reflectionAppendArray(Object array) {\n+        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers this builder's source object to avoid infinite loops when processing circular object references.\n+     * </p>\n+     */\n+    void registerObject() {\n+        register(this.getObject());\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append static fields.\n+     * </p>\n+     * \n+     * @param appendStatics\n+     *            Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public void setAppendStatics(boolean appendStatics) {\n+        this.appendStatics = appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append transient fields.\n+     * </p>\n+     * \n+     * @param appendTransients\n+     *            Whether or not to append transient fields.\n+     */\n+    public void setAppendTransients(boolean appendTransients) {\n+        this.appendTransients = appendTransients;\n+    }\n+\n+    /**\n+     * Sets the field names to exclude.\n+     * \n+     * @param excludeFieldNamesParam\n+     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n+     * @return <code>this</code>\n+     */\n+    public ReflectionToStringBuilder setExcludeFieldNames(String[] excludeFieldNamesParam) {\n+        if (excludeFieldNamesParam == null) {\n+            this.excludeFieldNames = null;\n+        } else {\n+            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n+            Arrays.sort(this.excludeFieldNames);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the last super class to stop appending fields for.\n+     * </p>\n+     * \n+     * @param clazz\n+     *            The last super class to stop appending fields for.\n+     */\n+    public void setUpToClass(Class clazz) {\n+        this.upToClass = clazz;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the String built by this builder.\n+     * </p>\n+     * \n+     * @return the built string\n+     */\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            return this.getStyle().getNullText();\n+        }\n+        Class clazz = this.getObject().getClass();\n+        this.appendFieldsIn(clazz);\n+        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n+            clazz = clazz.getSuperclass();\n+            this.appendFieldsIn(clazz);\n+        }\n+        return super.toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters this builder's source object to avoid infinite loops when processing circular object references.\n+     * </p>\n+     */\n+    void unregisterObject() {\n+        unregister(this.getObject());\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/builder/StandardToStringStyle.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+/**\n+ * <p>Works with {@link ToStringBuilder} to create a <code>toString</code>.</p>\n+ *\n+ * <p>This class is intended to be used as a singleton.\n+ * There is no need to instantiate a new style each time.\n+ * Simply instantiate the class once, customize the values as required, and\n+ * store the result in a public static final variable for the rest of the\n+ * program to access.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class StandardToStringStyle extends ToStringStyle {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * <p>Constructor.</p>\n+     */\n+    public StandardToStringStyle() {\n+        super();\n+    }\n+    \n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the class name.</p>\n+     *\n+     * @return the current useClassName flag\n+     */\n+    public boolean isUseClassName() {\n+        return super.isUseClassName();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the class name.</p>\n+     *\n+     * @param useClassName  the new useClassName flag\n+     */\n+    public void setUseClassName(boolean useClassName) {\n+        super.setUseClassName(useClassName);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to output short or long class names.</p>\n+     *\n+     * @return the current useShortClassName flag\n+     * @since 2.0\n+     */\n+    public boolean isUseShortClassName() {\n+        return super.isUseShortClassName();\n+    }\n+\n+    /**\n+     * <p>Gets whether to output short or long class names.</p>\n+     *\n+     * @return the current shortClassName flag\n+     * @deprecated Use {@link #isUseShortClassName()}\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public boolean isShortClassName() {\n+        return super.isUseShortClassName();\n+    }\n+\n+    /**\n+     * <p>Sets whether to output short or long class names.</p>\n+     *\n+     * @param useShortClassName  the new useShortClassName flag\n+     * @since 2.0\n+     */\n+    public void setUseShortClassName(boolean useShortClassName) {\n+        super.setUseShortClassName(useShortClassName);\n+    }\n+\n+    /**\n+     * <p>Sets whether to output short or long class names.</p>\n+     *\n+     * @param shortClassName  the new shortClassName flag\n+     * @deprecated Use {@link #setUseShortClassName(boolean)}\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    public void setShortClassName(boolean shortClassName) {\n+        super.setUseShortClassName(shortClassName);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the identity hash code.</p>\n+     * @return the current useIdentityHashCode flag\n+     */\n+    public boolean isUseIdentityHashCode() {\n+        return super.isUseIdentityHashCode();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the identity hash code.</p>\n+     *\n+     * @param useIdentityHashCode  the new useIdentityHashCode flag\n+     */\n+    public void setUseIdentityHashCode(boolean useIdentityHashCode) {\n+        super.setUseIdentityHashCode(useIdentityHashCode);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the field names passed in.</p>\n+     *\n+     * @return the current useFieldNames flag\n+     */\n+    public boolean isUseFieldNames() {\n+        return super.isUseFieldNames();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the field names passed in.</p>\n+     *\n+     * @param useFieldNames  the new useFieldNames flag\n+     */\n+    public void setUseFieldNames(boolean useFieldNames) {\n+        super.setUseFieldNames(useFieldNames);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @return the current defaultFullDetail flag\n+     */\n+    public boolean isDefaultFullDetail() {\n+        return super.isDefaultFullDetail();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @param defaultFullDetail  the new defaultFullDetail flag\n+     */\n+    public void setDefaultFullDetail(boolean defaultFullDetail) {\n+        super.setDefaultFullDetail(defaultFullDetail);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to output array content detail.</p>\n+     *\n+     * @return the current array content detail setting\n+     */\n+    public boolean isArrayContentDetail() {\n+        return super.isArrayContentDetail();\n+    }\n+    \n+    /**\n+     * <p>Sets whether to output array content detail.</p>\n+     *\n+     * @param arrayContentDetail  the new arrayContentDetail flag\n+     */\n+    public void setArrayContentDetail(boolean arrayContentDetail) {\n+        super.setArrayContentDetail(arrayContentDetail);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array start text.</p>\n+     *\n+     * @return the current array start text\n+     */\n+    public String getArrayStart() {\n+        return super.getArrayStart();\n+    }\n+\n+    /**\n+     * <p>Sets the array start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arrayStart  the new array start text\n+     */\n+    public void setArrayStart(String arrayStart) {\n+        super.setArrayStart(arrayStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array end text.</p>\n+     *\n+     * @return the current array end text\n+     */\n+    public String getArrayEnd() {\n+        return super.getArrayEnd();\n+    }\n+\n+    /**\n+     * <p>Sets the array end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arrayEnd  the new array end text\n+     */\n+    public void setArrayEnd(String arrayEnd) {\n+        super.setArrayEnd(arrayEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array separator text.</p>\n+     *\n+     * @return the current array separator text\n+     */\n+    public String getArraySeparator() {\n+        return super.getArraySeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the array separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arraySeparator  the new array separator text\n+     */\n+    public void setArraySeparator(String arraySeparator) {\n+        super.setArraySeparator(arraySeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the content start text.</p>\n+     *\n+     * @return the current content start text\n+     */\n+    public String getContentStart() {\n+        return super.getContentStart();\n+    }\n+\n+    /**\n+     * <p>Sets the content start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param contentStart  the new content start text\n+     */\n+    public void setContentStart(String contentStart) {\n+        super.setContentStart(contentStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the content end text.</p>\n+     *\n+     * @return the current content end text\n+     */\n+    public String getContentEnd() {\n+        return super.getContentEnd();\n+    }\n+\n+    /**\n+     * <p>Sets the content end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param contentEnd  the new content end text\n+     */\n+    public void setContentEnd(String contentEnd) {\n+        super.setContentEnd(contentEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the field name value separator text.</p>\n+     *\n+     * @return the current field name value separator text\n+     */\n+    public String getFieldNameValueSeparator() {\n+        return super.getFieldNameValueSeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the field name value separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param fieldNameValueSeparator  the new field name value separator text\n+     */\n+    public void setFieldNameValueSeparator(String fieldNameValueSeparator) {\n+        super.setFieldNameValueSeparator(fieldNameValueSeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the field separator text.</p>\n+     *\n+     * @return the current field separator text\n+     */\n+    public String getFieldSeparator() {\n+        return super.getFieldSeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the field separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param fieldSeparator  the new field separator text\n+     */\n+    public void setFieldSeparator(String fieldSeparator) {\n+        super.setFieldSeparator(fieldSeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @return the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    public boolean isFieldSeparatorAtStart() {\n+        return super.isFieldSeparatorAtStart();\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    public void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\n+        super.setFieldSeparatorAtStart(fieldSeparatorAtStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @return fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    public boolean isFieldSeparatorAtEnd() {\n+        return super.isFieldSeparatorAtEnd();\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    public void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) {\n+        super.setFieldSeparatorAtEnd(fieldSeparatorAtEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the text to output when <code>null</code> found.</p>\n+     *\n+     * @return the current text to output when <code>null</code> found\n+     */\n+    public String getNullText() {\n+        return super.getNullText();\n+    }\n+\n+    /**\n+     * <p>Sets the text to output when <code>null</code> found.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param nullText  the new text to output when <code>null</code> found\n+     */\n+    public void setNullText(String nullText) {\n+        super.setNullText(nullText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of size text\n+     */\n+    public String getSizeStartText() {\n+        return super.getSizeStartText();\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeStartText  the new start of size text\n+     */\n+    public void setSizeStartText(String sizeStartText) {\n+        super.setSizeStartText(sizeStartText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of size text\n+     */\n+    public String getSizeEndText() {\n+        return super.getSizeEndText();\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param sizeEndText  the new end of size text\n+     */\n+    public void setSizeEndText(String sizeEndText) {\n+        super.setSizeEndText(sizeEndText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <P>This is output before the size value.</p>\n+     *\n+     * @return the current start of summary text\n+     */\n+    public String getSummaryObjectStartText() {\n+        return super.getSummaryObjectStartText();\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectStartText  the new start of summary text\n+     */\n+    public void setSummaryObjectStartText(String summaryObjectStartText) {\n+        super.setSummaryObjectStartText(summaryObjectStartText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of summary text\n+     */\n+    public String getSummaryObjectEndText() {\n+        return super.getSummaryObjectEndText();\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectEndText  the new end of summary text\n+     */\n+    public void setSummaryObjectEndText(String summaryObjectEndText) {\n+        super.setSummaryObjectEndText(summaryObjectEndText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import org.apache.commons.lang.BooleanUtils;\n+import org.apache.commons.lang.ObjectUtils;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#toString()} methods.</p>\n+ *\n+ * <p>This class enables a good and consistent <code>toString()</code> to be built for any\n+ * class or object. This class aims to simplify the process by:</p>\n+ * <ul>\n+ *  <li>allowing field names</li>\n+ *  <li>handling all types consistently</li>\n+ *  <li>handling nulls consistently</li>\n+ *  <li>outputting arrays and multi-dimensional arrays</li>\n+ *  <li>enabling the detail level to be controlled for Objects and Collections</li>\n+ *  <li>handling class hierarchies</li>\n+ * </ul>\n+ *\n+ * <p>To use this class write code as follows:</p>\n+ *\n+ * <pre>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean smoker;\n+ * \n+ *   ...\n+ * \n+ *   public String toString() {\n+ *     return new ToStringBuilder(this).\n+ *       append(\"name\", name).\n+ *       append(\"age\", age).\n+ *       append(\"smoker\", smoker).\n+ *       toString();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>This will produce a toString of the format:\n+ * <code>Person@7f54[name=Stephen,age=29,smoker=false]</code></p>\n+ * \n+ * <p>To add the superclass <code>toString</code>, use {@link #appendSuper}.\n+ * To append the <code>toString</code> from an object that is delegated\n+ * to (or any other object), use {@link #appendToString}.</p>\n+ *\n+ * <p>Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method, \n+ * <code>reflectionToString</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security manager,\n+ * unless the appropriate permissions are set up correctly. It is also\n+ * slower than testing explicitly.</p>\n+ *\n+ * <p>A typical invocation for this method would look like:</p>\n+ *\n+ * <pre>\n+ * public String toString() {\n+ *   return ToStringBuilder.reflectionToString(this);\n+ * }\n+ * </pre>\n+ *\n+ * <p>You can also use the builder to debug 3rd party objects:</p>\n+ *\n+ * <pre>\n+ * System.out.println(\"An object: \" + ToStringBuilder.reflectionToString(anObject));\n+ * </pre>\n+ * \n+ * <p>The exact format of the <code>toString</code> is determined by\n+ * the {@link ToStringStyle} passed into the constructor.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class ToStringBuilder {\n+\n+    /**\n+     * The default style of output to use.\n+     */\n+    private static ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the default <code>ToStringStyle</code> to use.</p>\n+     *\n+     * <p>This could allow the <code>ToStringStyle</code> to be\n+     * controlled for an entire application with one call.</p>\n+     *\n+     * <p>This might be used to have a verbose\n+     * <code>ToStringStyle</code> during development and a compact\n+     * <code>ToStringStyle</code> in production.</p>\n+     * \n+     * @return the default <code>ToStringStyle</code>\n+     */\n+    public static ToStringStyle getDefaultStyle() {\n+        return defaultStyle;\n+    }\n+\n+    /**\n+     * <p>Forwards to <code>ReflectionToStringBuilder</code>.</p>\n+     * \n+     * @see ReflectionToStringBuilder#toString(Object)\n+     */\n+    public static String reflectionToString(Object object) {\n+        return ReflectionToStringBuilder.toString(object);\n+    }\n+\n+    /**\n+     * <p>Forwards to <code>ReflectionToStringBuilder</code>.</p>\n+     * \n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle)\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style) {\n+        return ReflectionToStringBuilder.toString(object, style);\n+    }\n+\n+    /**\n+     * <p>Forwards to <code>ReflectionToStringBuilder</code>.</p>\n+     * \n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean)\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>Forwards to <code>ReflectionToStringBuilder</code>.</p>\n+     * \n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean,boolean,Class)\n+     * @since 2.0\n+     */\n+    public static String reflectionToString(\n+        Object object,\n+        ToStringStyle style,\n+        boolean outputTransients,\n+        Class reflectUpToClass) {\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);\n+    }\n+\n+    /**\n+     * <p>Sets the default <code>ToStringStyle</code> to use.</p>\n+     * \n+     * @param style  the default <code>ToStringStyle</code>\n+     * @throws IllegalArgumentException if the style is <code>null</code>\n+     */\n+    public static void setDefaultStyle(ToStringStyle style) {\n+        if (style == null) {\n+            throw new IllegalArgumentException(\"The style must not be null\");\n+        }\n+        defaultStyle = style;\n+    }\n+\n+    /**\n+     * Current toString buffer.\n+     */\n+    private final StringBuffer buffer;\n+\n+    /**\n+     * The object being output.\n+     */\n+    private final Object object;\n+\n+    /**\n+     * The style of output to use.\n+     */\n+    private final ToStringStyle style;\n+\n+    /**\n+     * <p>Constructor for <code>ToStringBuilder</code>.</p>\n+     *\n+     * <p>This constructor outputs using the default style set with\n+     * <code>setDefaultStyle</code>.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for\n+     * @throws IllegalArgumentException  if the Object passed in is\n+     *  <code>null</code>\n+     */\n+    public ToStringBuilder(Object object) {\n+        this(object, getDefaultStyle(), null);\n+    }\n+\n+    /**\n+     * <p>Constructor for <code>ToStringBuilder</code> specifying the\n+     * output style.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default style is used.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @throws IllegalArgumentException  if the Object passed in is\n+     *  <code>null</code>\n+     */\n+    public ToStringBuilder(Object object, ToStringStyle style) {\n+        this(object, style, null);\n+    }\n+\n+    /**\n+     * <p>Constructor for <code>ToStringBuilder</code>.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default style is used.</p>\n+     *\n+     * <p>If the buffer is <code>null</code>, a new one is created.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param buffer  the <code>StringBuffer</code> to populate, may be\n+     *  <code>null</code>\n+     */\n+    public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        if (style == null) {\n+            style = getDefaultStyle();\n+        }\n+        if (buffer == null) {\n+            buffer = new StringBuffer(512);\n+        }\n+        this.buffer = buffer;\n+        this.style = style;\n+        this.object = object;\n+\n+        style.appendStart(buffer, object);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(boolean value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(boolean[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(byte value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(byte[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(char value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(char[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(double value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(double[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(float value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(float[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(int value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(int[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(long value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(long[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param object  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(Object object) {\n+        style.append(buffer, null, object, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(Object[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(short value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(short[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code> array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>float</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param object  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object object) {\n+        style.append(buffer, fieldName, object, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param object  the value to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail,\n+     *  <code>false</code> for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object object, boolean fullDetail) {\n+        style.append(buffer, fieldName, object, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>short</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, BooleanUtils.toBooleanObject(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends with the same format as the default <code>Object toString()\n+     * </code> method. Appends the class name followed by \n+     * {@link System#identityHashCode(java.lang.Object)}.</p>\n+     * \n+     * @param object  the <code>Object</code> whose class name and id to output\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendAsObjectToString(Object object) {\n+        ObjectUtils.appendIdentityToString(this.getStringBuffer(), object);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append the <code>toString</code> from the superclass.</p>\n+     * \n+     * <p>This method assumes that the superclass uses the same <code>ToStringStyle</code>\n+     * as this one.</p>\n+     * \n+     * <p>If <code>superToString</code> is <code>null</code>, no change is made.</p>\n+     *\n+     * @param superToString  the result of <code>super.toString()</code>\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendSuper(String superToString) {\n+        if (superToString != null) {\n+            style.appendSuper(buffer, superToString);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append the <code>toString</code> from another object.</p>\n+     * \n+     * <p>This method is useful where a class delegates most of the implementation of\n+     * its properties to another class. You can then call <code>toString()</code> on\n+     * the other class and pass the result into this method.</p>\n+     * \n+     * <pre>\n+     *   private AnotherObject delegate;\n+     *   private String fieldInThisClass;\n+     * \n+     *   public String toString() {\n+     *     return new ToStringBuilder(this).\n+     *       appendToString(delegate.toString()).\n+     *       append(fieldInThisClass).\n+     *       toString();\n+     *   }</pre>\n+     * \n+     * <p>This method assumes that the other object uses the same <code>ToStringStyle</code>\n+     * as this one.</p>\n+     * \n+     * <p>If the <code>toString</code> is <code>null</code>, no change is made.</p>\n+     *\n+     * @param toString  the result of <code>toString()</code> on another object\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendToString(String toString) {\n+        if (toString != null) {\n+            style.appendToString(buffer, toString);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns the <code>Object</code> being output.</p>\n+     * \n+     * @return The object being output.\n+     * @since 2.0\n+     */\n+    public Object getObject() {\n+        return object;\n+    }\n+\n+    /**\n+     * <p>Gets the <code>StringBuffer</code> being populated.</p>\n+     * \n+     * @return the <code>StringBuffer</code> being populated\n+     */\n+    public StringBuffer getStringBuffer() {\n+        return buffer;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the <code>ToStringStyle</code> being used.</p>\n+     * \n+     * @return the <code>ToStringStyle</code> being used\n+     * @since 2.0\n+     */\n+    public ToStringStyle getStyle() {\n+        return style;\n+    }\n+\n+    /**\n+     * <p>Returns the built <code>toString</code>.</p>\n+     * \n+     * <p>This method appends the end of data indicator, and can only be called once.\n+     * Use {@link #getStringBuffer} to get the current string state.</p>\n+     * \n+     * <p>If the object is <code>null</code>, return the style's <code>nullText</code></p>\n+     * \n+     * @return the String <code>toString</code>\n+     */\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            this.getStringBuffer().append(this.getStyle().getNullText());\n+        } else {\n+            style.appendEnd(this.getStringBuffer(), this.getObject());\n+        }\n+        return this.getStringBuffer().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * <p>Controls <code>String</code> formatting for {@link ToStringBuilder}.\n+ * The main public interface is always via <code>ToStringBuilder</code>.</p>\n+ *\n+ * <p>These classes are intended to be used as <code>Singletons</code>.\n+ * There is no need to instantiate a new style each time. A program\n+ * will generally use one of the predefined constants on this class.\n+ * Alternatively, the {@link StandardToStringStyle} class can be used\n+ * to set the individual settings. Thus most styles can be achieved\n+ * without subclassing.</p>\n+ *\n+ * <p>If required, a subclass can override as many or as few of the\n+ * methods as it requires. Each object type (from <code>boolean</code>\n+ * to <code>long</code> to <code>Object</code> to <code>int[]</code>) has\n+ * its own methods to output it. Most have two versions, detail and summary.\n+ *\n+ * <p>For example, the detail version of the array based methods will\n+ * output the whole array, whereas the summary method will just output\n+ * the array length.</p>\n+ * \n+ * <p>If you want to format the output of certain objects, such as dates, you\n+ * must create a subclass and override a method.\n+ * <pre>\n+ * public class MyStyle extends ToStringStyle {\n+ *   protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+ *     if (value instanceof Date) {\n+ *       value = new SimpleDateFormat(\"yyyy-MM-dd\").format(value);\n+ *     }\n+ *     buffer.append(value);\n+ *   }\n+ * }\n+ * </pre>\n+ * </p>\n+ *\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @author Masato Tezuka\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public abstract class ToStringStyle implements Serializable {\n+\n+    /**\n+     * The default toString style.\n+     */\n+    public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n+    \n+    /**\n+     * The multi line toString style.\n+     */\n+    public static final ToStringStyle MULTI_LINE_STYLE = new MultiLineToStringStyle();\n+    \n+    /**\n+     * The no field names toString style.\n+     */\n+    public static final ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle();\n+    \n+    /**\n+     * The short prefix toString style.\n+     * @since 2.1\n+     */\n+    public static final ToStringStyle SHORT_PREFIX_STYLE = new ShortPrefixToStringStyle();\n+\n+    /**\n+     * The simple toString style.\n+     */\n+    public static final ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle();\n+    \n+    /**\n+     * Whether to use the field names, the default is <code>true</code>.\n+     */\n+    private boolean useFieldNames = true;\n+    \n+    /**\n+     * Whether to use the class name, the default is <code>true</code>.\n+     */\n+    private boolean useClassName = true;\n+    \n+    /**\n+     * Whether to use short class names, the default is <code>false</code>.\n+     */\n+    private boolean useShortClassName = false;\n+    \n+    /**\n+     * Whether to use the identity hash code, the default is <code>true</code>.\n+     */\n+    private boolean useIdentityHashCode = true;\n+\n+    /**\n+     * The content start <code>'['</code>.\n+     */\n+    private String contentStart = \"[\";\n+    \n+    /**\n+     * The content end <code>']'</code>.\n+     */\n+    private String contentEnd = \"]\";\n+    \n+    /**\n+     * The field name value separator <code>'='</code>.\n+     */\n+    private String fieldNameValueSeparator = \"=\";\n+    \n+    /**\n+     * Whether the field separator should be added before any other fields.\n+     */\n+    private boolean fieldSeparatorAtStart = false;\n+    \n+    /**\n+     * Whether the field separator should be added after any other fields.\n+     */\n+    private boolean fieldSeparatorAtEnd = false;\n+    \n+    /**\n+     * The field separator <code>','</code>.\n+     */\n+    private String fieldSeparator = \",\";\n+    \n+    /**\n+     * The array start <code>'{'</code>.\n+     */\n+    private String arrayStart = \"{\";\n+    \n+    /**\n+     * The array separator <code>','</code>.\n+     */\n+    private String arraySeparator = \",\";\n+    \n+    /**\n+     * The detail for array content.\n+     */\n+    private boolean arrayContentDetail = true;\n+    \n+    /**\n+     * The array end <code>'}'</code>.\n+     */\n+    private String arrayEnd = \"}\";\n+    \n+    /**\n+     * The value to use when fullDetail is <code>null</code>,\n+     * the default value is <code>true</code>.\n+     */\n+    private boolean defaultFullDetail = true;\n+    \n+    /**\n+     * The <code>null</code> text <code>'&lt;null&gt;'</code>.\n+     */\n+    private String nullText = \"<null>\";\n+    \n+    /**\n+     * The summary size text start <code>'<size'</code>.\n+     */\n+    private String sizeStartText = \"<size=\";\n+    \n+    /**\n+     * The summary size text start <code>'&gt;'</code>.\n+     */\n+    private String sizeEndText = \">\";\n+    \n+    /**\n+     * The summary object text start <code>'&lt;'</code>.\n+     */\n+    private String summaryObjectStartText = \"<\";\n+    \n+    /**\n+     * The summary object text start <code>'&gt;'</code>.\n+     */\n+    private String summaryObjectEndText = \">\";\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Constructor.</p>\n+     */\n+    protected ToStringStyle() {\n+        super();\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the superclass toString.</p>\n+     * \n+     * <p>A <code>null</code> <code>superToString</code> is ignored.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param superToString  the <code>super.toString()</code>\n+     * @since 2.0\n+     */\n+    public void appendSuper(StringBuffer buffer, String superToString) {\n+        appendToString(buffer, superToString);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> another toString.</p>\n+     * \n+     * <p>A <code>null</code> <code>toString</code> is ignored.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param toString  the additional <code>toString</code>\n+     * @since 2.0\n+     */\n+    public void appendToString(StringBuffer buffer, String toString) {\n+        if (toString != null) {\n+            int pos1 = toString.indexOf(contentStart) + contentStart.length();\n+            int pos2 = toString.lastIndexOf(contentEnd);\n+            if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {\n+                String data = toString.substring(pos1, pos2);\n+                if (fieldSeparatorAtStart) {\n+                    removeLastFieldSeparator(buffer);\n+                }\n+                buffer.append(data);\n+                appendFieldSeparator(buffer);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the start of data indicator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> to build a <code>toString</code> for\n+     */\n+    public void appendStart(StringBuffer buffer, Object object) {\n+        if (object != null) {\n+            appendClassName(buffer, object);\n+            appendIdentityHashCode(buffer, object);\n+            appendContentStart(buffer);\n+            if (fieldSeparatorAtStart) {\n+                appendFieldSeparator(buffer);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the end of data indicator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> to build a\n+     *  <code>toString</code> for.\n+     */\n+    public void appendEnd(StringBuffer buffer, Object object) {\n+        if (this.fieldSeparatorAtEnd == false) {\n+            removeLastFieldSeparator(buffer);\n+        }\n+        appendContentEnd(buffer);\n+    }\n+\n+    /**\n+     * <p>Remove the last field separator from the buffer.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @since 2.0\n+     */\n+    protected void removeLastFieldSeparator(StringBuffer buffer) {\n+        int len = buffer.length();\n+        int sepLen = fieldSeparator.length();\n+        if (len > 0 && sepLen > 0 && len >= sepLen) {\n+            boolean match = true;\n+            for (int i = 0; i < sepLen; i++) {\n+                if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\n+                    match = false;\n+                    break;\n+                }\n+            }\n+            if (match) {\n+                buffer.setLength(len - sepLen);\n+            }\n+        }\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing the full <code>toString</code> of the\n+     * <code>Object</code> passed in.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (value == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else {\n+            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>,\n+     * correctly interpreting its type.</p>\n+     *\n+     * <p>This method performs the main lookup by Class type to correctly\n+     * route arrays, <code>Collections</code>, <code>Maps</code> and\n+     * <code>Objects</code> to the appropriate method.</p>\n+     *\n+     * <p>Either detail or summary views can be specified.</p>\n+     *\n+     * <p>If a cycle is detected, an object will be appended with the\n+     * <code>Object.toString()</code> format.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     * @param detail  output detail or not\n+     */\n+    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n+        if (ReflectionToStringBuilder.isRegistered(value)\n+            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n+            ObjectUtils.appendIdentityToString(buffer, value);\n+\n+        } else if (value instanceof Collection) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (Collection) value);\n+            } else {\n+                appendSummarySize(buffer, fieldName, ((Collection) value).size());\n+            }\n+\n+        } else if (value instanceof Map) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (Map) value);\n+            } else {\n+                appendSummarySize(buffer, fieldName, ((Map) value).size());\n+            }\n+\n+        } else if (value instanceof long[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (long[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (long[]) value);\n+            }\n+\n+        } else if (value instanceof int[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (int[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (int[]) value);\n+            }\n+\n+        } else if (value instanceof short[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (short[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (short[]) value);\n+            }\n+\n+        } else if (value instanceof byte[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (byte[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (byte[]) value);\n+            }\n+\n+        } else if (value instanceof char[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (char[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (char[]) value);\n+            }\n+\n+        } else if (value instanceof double[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (double[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (double[]) value);\n+            }\n+\n+        } else if (value instanceof float[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (float[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (float[]) value);\n+            }\n+\n+        } else if (value instanceof boolean[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (boolean[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (boolean[]) value);\n+            }\n+\n+        } else if (value.getClass().isArray()) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (Object[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (Object[]) value);\n+            }\n+\n+        } else {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, value);\n+            } else {\n+                appendSummary(buffer, fieldName, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing the full detail of the <code>Object</code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+        buffer.append(value);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>Collection</code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param coll  the <code>Collection</code> to add to the\n+     *  <code>toString</code>, not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Collection coll) {\n+        buffer.append(coll);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>Map<code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param map  the <code>Map</code> to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Map map) {\n+        buffer.append(map);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing a summary of the <code>Object</code>.</P>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, Object value) {\n+        buffer.append(summaryObjectStartText);\n+        buffer.append(getShortClassName(value.getClass()));\n+        buffer.append(summaryObjectEndText);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, long value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, long value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, int value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, int value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, short value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, short value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, byte value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, byte value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, char value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, char value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, double value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, double value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, float value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, float value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, boolean value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, boolean value) {\n+        buffer.append(value);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, Object[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an\n+     * <code>Object</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            Object item = array[i];\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            if (item == null) {\n+                appendNullText(buffer, fieldName);\n+\n+            } else {\n+                appendInternal(buffer, fieldName, item, arrayContentDetail);\n+            }\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     * @since 2.0\n+     */\n+    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n+        buffer.append(arrayStart);\n+        int length = Array.getLength(array);\n+        for (int i = 0; i < length; i++) {\n+            Object item = Array.get(array, i);\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            if (item == null) {\n+                appendNullText(buffer, fieldName);\n+\n+            } else {\n+                appendInternal(buffer, fieldName, item, arrayContentDetail);\n+            }\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of an\n+     * <code>Object</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, Object[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, long[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>long</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, long[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>long</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, long[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, int[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an\n+     * <code>int</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of an\n+     * <code>int</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, int[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, short[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>short</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, short[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>short</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, short[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, byte[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>byte</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>byte</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, byte[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, char[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>char</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, char[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>char</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, char[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, double[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>double</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, double[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>double</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, double[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, float[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>float</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, float[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>float</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, float[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, boolean[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>boolean</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, boolean[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>boolean</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, boolean[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the class name.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> whose name to output\n+     */\n+    protected void appendClassName(StringBuffer buffer, Object object) {\n+        if (useClassName && object != null) {\n+            if (useShortClassName) {\n+                buffer.append(getShortClassName(object.getClass()));\n+            } else {\n+                buffer.append(object.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append the {@link System#identityHashCode(java.lang.Object)}.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> whose id to output\n+     */\n+    protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\n+        if (this.isUseIdentityHashCode() && object!=null) {\n+            buffer.append('@');\n+            buffer.append(Integer.toHexString(System.identityHashCode(object)));\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the content start.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendContentStart(StringBuffer buffer) {\n+        buffer.append(contentStart);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the content end.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendContentEnd(StringBuffer buffer) {\n+        buffer.append(contentEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an indicator for <code>null</code>.</p>\n+     *\n+     * <p>The default indicator is <code>'&lt;null&gt;'</code>.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     */\n+    protected void appendNullText(StringBuffer buffer, String fieldName) {\n+        buffer.append(nullText);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the field separator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendFieldSeparator(StringBuffer buffer) {\n+        buffer.append(fieldSeparator);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the field start.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     */\n+    protected void appendFieldStart(StringBuffer buffer, String fieldName) {\n+        if (useFieldNames && fieldName != null) {\n+            buffer.append(fieldName);\n+            buffer.append(fieldNameValueSeparator);\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString<code> the field end.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     */\n+    protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\n+        appendFieldSeparator(buffer);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a size summary.</p>\n+     *\n+     * <p>The size summary is used to summarize the contents of\n+     * <code>Collections</code>, <code>Maps</code> and arrays.</p>\n+     *\n+     * <p>The output consists of a prefix, the passed in size\n+     * and a suffix.</p>\n+     *\n+     * <p>The default format is <code>'&lt;size=n&gt;'<code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param size  the size to append\n+     */\n+    protected void appendSummarySize(StringBuffer buffer, String fieldName, int size) {\n+        buffer.append(sizeStartText);\n+        buffer.append(size);\n+        buffer.append(sizeEndText);\n+    }\n+\n+    /**\n+     * <p>Is this field to be output in full detail.</p>\n+     *\n+     * <p>This method converts a detail request into a detail level.\n+     * The calling code may request full detail (<code>true</code>),\n+     * but a subclass might ignore that and always return\n+     * <code>false</code>. The calling code may pass in\n+     * <code>null</code> indicating that it doesn't care about\n+     * the detail level. In this case the default detail level is\n+     * used.</p>\n+     * \n+     * @param fullDetailRequest  the detail level requested\n+     * @return whether full detail is to be shown\n+     */\n+    protected boolean isFullDetail(Boolean fullDetailRequest) {\n+        if (fullDetailRequest == null) {\n+            return defaultFullDetail;\n+        }\n+        return fullDetailRequest.booleanValue();\n+    }\n+\n+    /**\n+     * <p>Gets the short class name for a class.</p>\n+     *\n+     * <p>The short class name is the classname excluding\n+     * the package name.</p>\n+     *\n+     * @param cls  the <code>Class</code> to get the short name of\n+     * @return the short name\n+     */\n+    protected String getShortClassName(Class cls) {\n+        return ClassUtils.getShortClassName(cls);\n+    }\n+\n+    // Setters and getters for the customizable parts of the style\n+    // These methods are not expected to be overridden, except to make public\n+    // (They are not public so that immutable subclasses can be written)\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the class name.</p>\n+     *\n+     * @return the current useClassName flag\n+     */\n+    protected boolean isUseClassName() {\n+        return useClassName;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the class name.</p>\n+     *\n+     * @param useClassName  the new useClassName flag\n+     */\n+    protected void setUseClassName(boolean useClassName) {\n+        this.useClassName = useClassName;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to output short or long class names.</p>\n+     *\n+     * @return the current useShortClassName flag\n+     * @since 2.0\n+     */\n+    protected boolean isUseShortClassName() {\n+        return useShortClassName;\n+    }\n+\n+    /**\n+     * <p>Gets whether to output short or long class names.</p>\n+     *\n+     * @return the current shortClassName flag\n+     * @deprecated Use {@link #isUseShortClassName()}\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    protected boolean isShortClassName() {\n+        return useShortClassName;\n+    }\n+\n+    /**\n+     * <p>Sets whether to output short or long class names.</p>\n+     *\n+     * @param useShortClassName  the new useShortClassName flag\n+     * @since 2.0\n+     */\n+    protected void setUseShortClassName(boolean useShortClassName) {\n+        this.useShortClassName = useShortClassName;\n+    }\n+\n+    /**\n+     * <p>Sets whether to output short or long class names.</p>\n+     *\n+     * @param shortClassName  the new shortClassName flag\n+     * @deprecated Use {@link #setUseShortClassName(boolean)}\n+     *             Method will be removed in Commons Lang 3.0.\n+     */\n+    protected void setShortClassName(boolean shortClassName) {\n+        this.useShortClassName = shortClassName;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the identity hash code.</p>\n+     *\n+     * @return the current useIdentityHashCode flag\n+     */\n+    protected boolean isUseIdentityHashCode() {\n+        return useIdentityHashCode;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the identity hash code.</p>\n+     *\n+     * @param useIdentityHashCode  the new useIdentityHashCode flag\n+     */\n+    protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\n+        this.useIdentityHashCode = useIdentityHashCode;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the field names passed in.</p>\n+     *\n+     * @return the current useFieldNames flag\n+     */\n+    protected boolean isUseFieldNames() {\n+        return useFieldNames;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the field names passed in.</p>\n+     *\n+     * @param useFieldNames  the new useFieldNames flag\n+     */\n+    protected void setUseFieldNames(boolean useFieldNames) {\n+        this.useFieldNames = useFieldNames;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @return the current defaultFullDetail flag\n+     */\n+    protected boolean isDefaultFullDetail() {\n+        return defaultFullDetail;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @param defaultFullDetail  the new defaultFullDetail flag\n+     */\n+    protected void setDefaultFullDetail(boolean defaultFullDetail) {\n+        this.defaultFullDetail = defaultFullDetail;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to output array content detail.</p>\n+     *\n+     * @return the current array content detail setting\n+     */\n+    protected boolean isArrayContentDetail() {\n+        return arrayContentDetail;\n+    }\n+\n+    /**\n+     * <p>Sets whether to output array content detail.</p>\n+     *\n+     * @param arrayContentDetail  the new arrayContentDetail flag\n+     */\n+    protected void setArrayContentDetail(boolean arrayContentDetail) {\n+        this.arrayContentDetail = arrayContentDetail;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array start text.</p>\n+     *\n+     * @return the current array start text\n+     */\n+    protected String getArrayStart() {\n+        return arrayStart;\n+    }\n+\n+    /**\n+     * <p>Sets the array start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arrayStart  the new array start text\n+     */\n+    protected void setArrayStart(String arrayStart) {\n+        if (arrayStart == null) {\n+            arrayStart = \"\";\n+        }\n+        this.arrayStart = arrayStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array end text.</p>\n+     *\n+     * @return the current array end text\n+     */\n+    protected String getArrayEnd() {\n+        return arrayEnd;\n+    }\n+\n+    /**\n+     * <p>Sets the array end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arrayEnd  the new array end text\n+     */\n+    protected void setArrayEnd(String arrayEnd) {\n+        if (arrayEnd == null) {\n+            arrayEnd = \"\";\n+        }\n+        this.arrayEnd = arrayEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array separator text.</p>\n+     *\n+     * @return the current array separator text\n+     */\n+    protected String getArraySeparator() {\n+        return arraySeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the array separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arraySeparator  the new array separator text\n+     */\n+    protected void setArraySeparator(String arraySeparator) {\n+        if (arraySeparator == null) {\n+            arraySeparator = \"\";\n+        }\n+        this.arraySeparator = arraySeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the content start text.</p>\n+     *\n+     * @return the current content start text\n+     */\n+    protected String getContentStart() {\n+        return contentStart;\n+    }\n+\n+    /**\n+     * <p>Sets the content start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param contentStart  the new content start text\n+     */\n+    protected void setContentStart(String contentStart) {\n+        if (contentStart == null) {\n+            contentStart = \"\";\n+        }\n+        this.contentStart = contentStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the content end text.</p>\n+     *\n+     * @return the current content end text\n+     */\n+    protected String getContentEnd() {\n+        return contentEnd;\n+    }\n+\n+    /**\n+     * <p>Sets the content end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param contentEnd  the new content end text\n+     */\n+    protected void setContentEnd(String contentEnd) {\n+        if (contentEnd == null) {\n+            contentEnd = \"\";\n+        }\n+        this.contentEnd = contentEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the field name value separator text.</p>\n+     *\n+     * @return the current field name value separator text\n+     */\n+    protected String getFieldNameValueSeparator() {\n+        return fieldNameValueSeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the field name value separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param fieldNameValueSeparator  the new field name value separator text\n+     */\n+    protected void setFieldNameValueSeparator(String fieldNameValueSeparator) {\n+        if (fieldNameValueSeparator == null) {\n+            fieldNameValueSeparator = \"\";\n+        }\n+        this.fieldNameValueSeparator = fieldNameValueSeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the field separator text.</p>\n+     *\n+     * @return the current field separator text\n+     */\n+    protected String getFieldSeparator() {\n+        return fieldSeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the field separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param fieldSeparator  the new field separator text\n+     */\n+    protected void setFieldSeparator(String fieldSeparator) {\n+        if (fieldSeparator == null) {\n+            fieldSeparator = \"\";\n+        }\n+        this.fieldSeparator = fieldSeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @return the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    protected boolean isFieldSeparatorAtStart() {\n+        return fieldSeparatorAtStart;\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\n+        this.fieldSeparatorAtStart = fieldSeparatorAtStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @return fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    protected boolean isFieldSeparatorAtEnd() {\n+        return fieldSeparatorAtEnd;\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    protected void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) {\n+        this.fieldSeparatorAtEnd = fieldSeparatorAtEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the text to output when <code>null</code> found.</p>\n+     *\n+     * @return the current text to output when null found\n+     */\n+    protected String getNullText() {\n+        return nullText;\n+    }\n+\n+    /**\n+     * <p>Sets the text to output when <code>null</code> found.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param nullText  the new text to output when null found\n+     */\n+    protected void setNullText(String nullText) {\n+        if (nullText == null) {\n+            nullText = \"\";\n+        }\n+        this.nullText = nullText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of size text\n+     */\n+    protected String getSizeStartText() {\n+        return sizeStartText;\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeStartText  the new start of size text\n+     */\n+    protected void setSizeStartText(String sizeStartText) {\n+        if (sizeStartText == null) {\n+            sizeStartText = \"\";\n+        }\n+        this.sizeStartText = sizeStartText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of size text\n+     */\n+    protected String getSizeEndText() {\n+        return sizeEndText;\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeEndText  the new end of size text\n+     */\n+    protected void setSizeEndText(String sizeEndText) {\n+        if (sizeEndText == null) {\n+            sizeEndText = \"\";\n+        }\n+        this.sizeEndText = sizeEndText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of summary text\n+     */\n+    protected String getSummaryObjectStartText() {\n+        return summaryObjectStartText;\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectStartText  the new start of summary text\n+     */\n+    protected void setSummaryObjectStartText(String summaryObjectStartText) {\n+        if (summaryObjectStartText == null) {\n+            summaryObjectStartText = \"\";\n+        }\n+        this.summaryObjectStartText = summaryObjectStartText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of summary text\n+     */\n+    protected String getSummaryObjectEndText() {\n+        return summaryObjectEndText;\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectEndText  the new end of summary text\n+     */\n+    protected void setSummaryObjectEndText(String summaryObjectEndText) {\n+        if (summaryObjectEndText == null) {\n+            summaryObjectEndText = \"\";\n+        }\n+        this.summaryObjectEndText = summaryObjectEndText;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Default <code>ToStringStyle</code>.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class DefaultToStringStyle extends ToStringStyle {\n+\n+        /**\n+         * Required for serialization support.\n+         * \n+         * @see java.io.Serializable\n+         */\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        DefaultToStringStyle() {\n+            super();\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.DEFAULT_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that does not print out\n+     * the field names.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.\n+     */\n+    private static final class NoFieldNameToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        NoFieldNameToStringStyle() {\n+            super();\n+            this.setUseFieldNames(false);\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.NO_FIELD_NAMES_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * <p><code>ToStringStyle</code> that prints out the short\n+     * class name and no identity hashcode.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class ShortPrefixToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        ShortPrefixToStringStyle() {\n+            super();\n+            this.setUseShortClassName(true);\n+            this.setUseIdentityHashCode(false);\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</ode> after serialization.</p>\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.SHORT_PREFIX_STYLE;\n+        }\n+\n+    }\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that does not print out the\n+     * classname, identity hashcode, content start or field name.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class SimpleToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        SimpleToStringStyle() {\n+            super();\n+            this.setUseClassName(false);\n+            this.setUseIdentityHashCode(false);\n+            this.setUseFieldNames(false);\n+            this.setContentStart(\"\");\n+            this.setContentEnd(\"\");\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</ode> after serialization.</p>\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.SIMPLE_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that outputs on multiple lines.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class MultiLineToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        MultiLineToStringStyle() {\n+            super();\n+            this.setContentStart(\"[\");\n+            this.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\n+            this.setFieldSeparatorAtStart(true);\n+            this.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.MULTI_LINE_STYLE;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/enum/Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * <p>Abstract superclass for type-safe enums.</p>\n+ *\n+ * <p>One feature of the C programming language lacking in Java is enumerations. The\n+ * C implementation based on ints was poor and open to abuse. The original Java\n+ * recommendation and most of the JDK also uses int constants. It has been recognised\n+ * however that a more robust type-safe class-based solution can be designed. This\n+ * class follows the basic Java type-safe enumeration pattern.</p>\n+ *\n+ * <p><em>NOTE:</em>Due to the way in which Java ClassLoaders work, comparing\n+ * Enum objects should always be done using <code>equals()</code>, not <code>==</code>.\n+ * The equals() method will try == first so in most cases the effect is the same.</p>\n+ * \n+ * <p>Of course, if you actually want (or don't mind) Enums in different class\n+ * loaders being non-equal, then you can use <code>==</code>.</p>\n+ * \n+ * <h4>Simple Enums</h4>\n+ *\n+ * <p>To use this class, it must be subclassed. For example:</p>\n+ *\n+ * <pre>\n+ * public final class ColorEnum extends Enum {\n+ *   public static final ColorEnum RED = new ColorEnum(\"Red\");\n+ *   public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+ *   public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+ *\n+ *   private ColorEnum(String color) {\n+ *     super(color);\n+ *   }\n+ * \n+ *   public static ColorEnum getEnum(String color) {\n+ *     return (ColorEnum) getEnum(ColorEnum.class, color);\n+ *   }\n+ * \n+ *   public static Map getEnumMap() {\n+ *     return getEnumMap(ColorEnum.class);\n+ *   }\n+ * \n+ *   public static List getEnumList() {\n+ *     return getEnumList(ColorEnum.class);\n+ *   }\n+ * \n+ *   public static Iterator iterator() {\n+ *     return iterator(ColorEnum.class);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>As shown, each enum has a name. This can be accessed using <code>getName</code>.</p>\n+ *\n+ * <p>The <code>getEnum</code> and <code>iterator</code> methods are recommended.\n+ * Unfortunately, Java restrictions require these to be coded as shown in each subclass.\n+ * An alternative choice is to use the {@link EnumUtils} class.</p>\n+ * \n+ * <h4>Subclassed Enums</h4>\n+ * <p>A hierarchy of Enum classes can be built. In this case, the superclass is\n+ * unaffected by the addition of subclasses (as per normal Java). The subclasses\n+ * may add additional Enum constants <em>of the type of the superclass</em>. The\n+ * query methods on the subclass will return all of the Enum constants from the\n+ * superclass and subclass.</p>\n+ *\n+ * <pre>\n+ * public final class ExtraColorEnum extends ColorEnum {\n+ *   // NOTE: Color enum declared above is final, change that to get this\n+ *   // example to compile.\n+ *   public static final ColorEnum YELLOW = new ExtraColorEnum(\"Yellow\");\n+ *\n+ *   private ExtraColorEnum(String color) {\n+ *     super(color);\n+ *   }\n+ * \n+ *   public static ColorEnum getEnum(String color) {\n+ *     return (ColorEnum) getEnum(ExtraColorEnum.class, color);\n+ *   }\n+ * \n+ *   public static Map getEnumMap() {\n+ *     return getEnumMap(ExtraColorEnum.class);\n+ *   }\n+ * \n+ *   public static List getEnumList() {\n+ *     return getEnumList(ExtraColorEnum.class);\n+ *   }\n+ * \n+ *   public static Iterator iterator() {\n+ *     return iterator(ExtraColorEnum.class);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>This example will return RED, GREEN, BLUE, YELLOW from the List and iterator\n+ * methods in that order. The RED, GREEN and BLUE instances will be the same (==) \n+ * as those from the superclass ColorEnum. Note that YELLOW is declared as a\n+ * ColorEnum and not an ExtraColorEnum.</p>\n+ * \n+ * <h4>Functional Enums</h4>\n+ *\n+ * <p>The enums can have functionality by defining subclasses and\n+ * overriding the <code>getEnumClass()</code> method:</p>\n+ * \n+ * <pre>\n+ *   public static final OperationEnum PLUS = new PlusOperation();\n+ *   private static final class PlusOperation extends OperationEnum {\n+ *     private PlusOperation() {\n+ *       super(\"Plus\");\n+ *     }\n+ *     public int eval(int a, int b) {\n+ *       return a + b;\n+ *     }\n+ *   }\n+ *   public static final OperationEnum MINUS = new MinusOperation();\n+ *   private static final class MinusOperation extends OperationEnum {\n+ *     private MinusOperation() {\n+ *       super(\"Minus\");\n+ *     }\n+ *     public int eval(int a, int b) {\n+ *       return a - b;\n+ *     }\n+ *   }\n+ *\n+ *   private OperationEnum(String color) {\n+ *     super(color);\n+ *   }\n+ * \n+ *   public final Class getEnumClass() {     // NOTE: new method!\n+ *     return OperationEnum.class;\n+ *   }\n+ *\n+ *   public abstract double eval(double a, double b);\n+ * \n+ *   public static OperationEnum getEnum(String name) {\n+ *     return (OperationEnum) getEnum(OperationEnum.class, name);\n+ *   }\n+ * \n+ *   public static Map getEnumMap() {\n+ *     return getEnumMap(OperationEnum.class);\n+ *   }\n+ * \n+ *   public static List getEnumList() {\n+ *     return getEnumList(OperationEnum.class);\n+ *   }\n+ * \n+ *   public static Iterator iterator() {\n+ *     return iterator(OperationEnum.class);\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>The code above will work on JDK 1.2. If JDK1.3 and later is used,\n+ * the subclasses may be defined as anonymous.</p>\n+ * \n+ * <h4>Nested class Enums</h4>\n+ *\n+ * <p>Care must be taken with class loading when defining a static nested class\n+ * for enums. The static nested class can be loaded without the surrounding outer\n+ * class being loaded. This can result in an empty list/map/iterator being returned.\n+ * One solution is to define a static block that references the outer class where\n+ * the constants are defined. For example:</p>\n+ *\n+ * <pre>\n+ * public final class Outer {\n+ *   public static final BWEnum BLACK = new BWEnum(\"Black\");\n+ *   public static final BWEnum WHITE = new BWEnum(\"White\");\n+ *\n+ *   // static nested enum class\n+ *   public static final class BWEnum extends Enum {\n+ * \n+ *     static {\n+ *       // explicitly reference BWEnum class to force constants to load\n+ *       Object obj = Outer.BLACK;\n+ *     }\n+ * \n+ *     // ... other methods omitted\n+ *   }\n+ * }\n+ * </pre>\n+ * \n+ * <p>Although the above solves the problem, it is not recommended. The best solution\n+ * is to define the constants in the enum class, and hold references in the outer class:\n+ *\n+ * <pre>\n+ * public final class Outer {\n+ *   public static final BWEnum BLACK = BWEnum.BLACK;\n+ *   public static final BWEnum WHITE = BWEnum.WHITE;\n+ *\n+ *   // static nested enum class\n+ *   public static final class BWEnum extends Enum {\n+ *     // only define constants in enum classes - private if desired\n+ *     private static final BWEnum BLACK = new BWEnum(\"Black\");\n+ *     private static final BWEnum WHITE = new BWEnum(\"White\");\n+ * \n+ *     // ... other methods omitted\n+ *   }\n+ * }\n+ * </pre>\n+ * \n+ * <p>For more details, see the 'Nested' test cases.\n+ * \n+ * @deprecated Replaced by {@link org.apache.commons.lang.enums.Enum org.apache.commons.lang.enums.Enum} \n+ *          and will be removed in version 3.0. All classes in this package are deprecated and repackaged to \n+ *          {@link org.apache.commons.lang.enums} since <code>enum</code> is a Java 1.5 keyword. \n+ * @see org.apache.commons.lang.enums.Enum\n+ * @author Apache Avalon project\n+ * @author Stephen Colebourne\n+ * @author Chris Webb\n+ * @author Mike Bowler\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public abstract class Enum implements Comparable, Serializable {\n+\n+    /**\n+     * Required for serialization support. Lang version 1.0.1 serial compatibility.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -487045951170455942L;\n+    \n+    // After discussion, the default size for HashMaps is used, as the\n+    // sizing algorithm changes across the JDK versions\n+    /**\n+     * An empty <code>Map</code>, as JDK1.2 didn't have an empty map.\n+     */\n+    private static final Map EMPTY_MAP = Collections.unmodifiableMap(new HashMap(0));\n+    \n+    /**\n+     * <code>Map</code>, key of class name, value of <code>Entry</code>.\n+     */\n+    private static final Map cEnumClasses = new HashMap();\n+    \n+    /**\n+     * The string representation of the Enum.\n+     */\n+    private final String iName;\n+    \n+    /**\n+     * The hashcode representation of the Enum.\n+     */\n+    private transient final int iHashCode;\n+    \n+    /**\n+     * The toString representation of the Enum.\n+     * @since 2.0\n+     */\n+    protected transient String iToString = null;\n+\n+    /**\n+     * <p>Enable the iterator to retain the source code order.</p>\n+     */\n+    private static class Entry {\n+        /**\n+         * Map of Enum name to Enum.\n+         */\n+        final Map map = new HashMap();\n+        /**\n+         * Map of Enum name to Enum.\n+         */\n+        final Map unmodifiableMap = Collections.unmodifiableMap(map);\n+        /**\n+         * List of Enums in source code order.\n+         */\n+        final List list = new ArrayList(25);\n+        /**\n+         * Map of Enum name to Enum.\n+         */\n+        final List unmodifiableList = Collections.unmodifiableList(list);\n+\n+        /**\n+         * <p>Restrictive constructor.</p>\n+         */\n+        protected Entry() {\n+            super();\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructor to add a new named item to the enumeration.</p>\n+     *\n+     * @param name  the name of the enum object,\n+     *  must not be empty or <code>null</code>\n+     * @throws IllegalArgumentException if the name is <code>null</code>\n+     *  or an empty string\n+     * @throws IllegalArgumentException if the getEnumClass() method returns\n+     *  a null or invalid Class\n+     */\n+    protected Enum(String name) {\n+        super();\n+        init(name);\n+        iName = name;\n+        iHashCode = 7 + getEnumClass().hashCode() + 3 * name.hashCode();\n+        // cannot create toString here as subclasses may want to include other data\n+    }\n+\n+    /**\n+     * Initializes the enumeration.\n+     * \n+     * @param name  the enum name\n+     * @throws IllegalArgumentException if the name is null or empty or duplicate\n+     * @throws IllegalArgumentException if the enumClass is null or invalid\n+     */\n+    private void init(String name) {\n+        if (StringUtils.isEmpty(name)) {\n+            throw new IllegalArgumentException(\"The Enum name must not be empty or null\");\n+        }\n+        \n+        Class enumClass = getEnumClass();\n+        if (enumClass == null) {\n+            throw new IllegalArgumentException(\"getEnumClass() must not be null\");\n+        }\n+        Class cls = getClass();\n+        boolean ok = false;\n+        while (cls != null && cls != Enum.class && cls != ValuedEnum.class) {\n+            if (cls == enumClass) {\n+                ok = true;\n+                break;\n+            }\n+            cls = cls.getSuperclass();\n+        }\n+        if (ok == false) {\n+            throw new IllegalArgumentException(\"getEnumClass() must return a superclass of this class\");\n+        }\n+        \n+        // create entry\n+        Entry entry = (Entry) cEnumClasses.get(enumClass);\n+        if (entry == null) {\n+            entry = createEntry(enumClass);\n+            cEnumClasses.put(enumClass, entry);\n+        }\n+        if (entry.map.containsKey(name)) {\n+            throw new IllegalArgumentException(\"The Enum name must be unique, '\" + name + \"' has already been added\");\n+        }\n+        entry.map.put(name, this);\n+        entry.list.add(this);\n+    }\n+\n+    /**\n+     * <p>Handle the deserialization of the class to ensure that multiple\n+     * copies are not wastefully created, or illegal enum types created.</p>\n+     *\n+     * @return the resolved object\n+     */\n+    protected Object readResolve() {\n+        Entry entry = (Entry) cEnumClasses.get(getEnumClass());\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.map.get(getName());\n+    }\n+    \n+    //--------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets an <code>Enum</code> object by class and name.</p>\n+     * \n+     * @param enumClass  the class of the Enum to get, must not\n+     *  be <code>null</code>\n+     * @param name  the name of the <code>Enum</code> to get,\n+     *  may be <code>null</code>\n+     * @return the enum object, or <code>null</code> if the enum does not exist\n+     * @throws IllegalArgumentException if the enum class\n+     *  is <code>null</code>\n+     */\n+    protected static Enum getEnum(Class enumClass, String name) {\n+        Entry entry = getEntry(enumClass);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return (Enum) entry.map.get(name);\n+    }\n+\n+    /**\n+     * <p>Gets the <code>Map</code> of <code>Enum</code> objects by\n+     * name using the <code>Enum</code> class.</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>Map</code> is returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n+     * @return the enum object Map\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n+     */\n+    protected static Map getEnumMap(Class enumClass) {\n+        Entry entry = getEntry(enumClass);\n+        if (entry == null) {\n+            return EMPTY_MAP;\n+        }\n+        return entry.unmodifiableMap;\n+    }\n+\n+    /**\n+     * <p>Gets the <code>List</code> of <code>Enum</code> objects using the\n+     * <code>Enum</code> class.</p>\n+     *\n+     * <p>The list is in the order that the objects were created (source code order).\n+     * If the requested class has no enum objects an empty <code>List</code> is\n+     * returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n+     * @return the enum object Map\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n+     */\n+    protected static List getEnumList(Class enumClass) {\n+        Entry entry = getEntry(enumClass);\n+        if (entry == null) {\n+            return Collections.EMPTY_LIST;\n+        }\n+        return entry.unmodifiableList;\n+    }\n+\n+    /**\n+     * <p>Gets an <code>Iterator</code> over the <code>Enum</code> objects in\n+     * an <code>Enum</code> class.</p>\n+     *\n+     * <p>The <code>Iterator</code> is in the order that the objects were\n+     * created (source code order). If the requested class has no enum\n+     * objects an empty <code>Iterator</code> is returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n+     * @return an iterator of the Enum objects\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n+     */\n+    protected static Iterator iterator(Class enumClass) {\n+        return Enum.getEnumList(enumClass).iterator();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets an <code>Entry</code> from the map of Enums.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @return the enum entry\n+     */\n+    private static Entry getEntry(Class enumClass) {\n+        if (enumClass == null) {\n+            throw new IllegalArgumentException(\"The Enum Class must not be null\");\n+        }\n+        if (Enum.class.isAssignableFrom(enumClass) == false) {\n+            throw new IllegalArgumentException(\"The Class must be a subclass of Enum\");\n+        }\n+        Entry entry = (Entry) cEnumClasses.get(enumClass);\n+        return entry;\n+    }\n+    \n+    /**\n+     * <p>Creates an <code>Entry</code> for storing the Enums.</p>\n+     *\n+     * <p>This accounts for subclassed Enums.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @return the enum entry\n+     */\n+    private static Entry createEntry(Class enumClass) {\n+        Entry entry = new Entry();\n+        Class cls = enumClass.getSuperclass();\n+        while (cls != null && cls != Enum.class && cls != ValuedEnum.class) {\n+            Entry loopEntry = (Entry) cEnumClasses.get(cls);\n+            if (loopEntry != null) {\n+                entry.list.addAll(loopEntry.list);\n+                entry.map.putAll(loopEntry.map);\n+                break;  // stop here, as this will already have had superclasses added\n+            }\n+            cls = cls.getSuperclass();\n+        }\n+        return entry;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Retrieve the name of this Enum item, set in the constructor.</p>\n+     * \n+     * @return the <code>String</code> name of this Enum item\n+     */\n+    public final String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * <p>Retrieves the Class of this Enum item, set in the constructor.</p>\n+     * \n+     * <p>This is normally the same as <code>getClass()</code>, but for\n+     * advanced Enums may be different. If overridden, it must return a\n+     * constant value.</p>\n+     * \n+     * @return the <code>Class</code> of the enum\n+     * @since 2.0\n+     */\n+    public Class getEnumClass() {\n+        return getClass();\n+    }\n+\n+    /**\n+     * <p>Tests for equality.</p>\n+     *\n+     * <p>Two Enum objects are considered equal\n+     * if they have the same class names and the same names.\n+     * Identity is tested for first, so this method usually runs fast.</p>\n+     * \n+     * <p>If the parameter is in a different class loader than this instance,\n+     * reflection is used to compare the names.</p>\n+     *\n+     * @param other  the other object to compare for equality\n+     * @return <code>true</code> if the Enums are equal\n+     */\n+    public final boolean equals(Object other) {\n+        if (other == this) {\n+            return true;\n+        } else if (other == null) {\n+            return false;\n+        } else if (other.getClass() == this.getClass()) {\n+            // Ok to do a class cast to Enum here since the test above\n+            // guarantee both\n+            // classes are in the same class loader.\n+            return iName.equals(((Enum) other).iName);\n+        } else {\n+            // This and other are in different class loaders, we must use reflection.\n+            if (other.getClass().getName().equals(this.getClass().getName()) == false) {\n+                return false;\n+            }\n+            return iName.equals( getNameInOtherClassLoader(other) );\n+        }\n+    }\n+    \n+    /**\n+     * <p>Returns a suitable hashCode for the enumeration.</p>\n+     *\n+     * @return a hashcode based on the name\n+     */\n+    public final int hashCode() {\n+        return iHashCode;\n+    }\n+\n+    /**\n+     * <p>Tests for order.</p>\n+     *\n+     * <p>The default ordering is alphabetic by name, but this\n+     * can be overridden by subclasses.</p>\n+     * \n+     * <p>If the parameter is in a different class loader than this instance,\n+     * reflection is used to compare the names.</p>\n+     *\n+     * @see java.lang.Comparable#compareTo(Object)\n+     * @param other  the other object to compare to\n+     * @return -ve if this is less than the other object, +ve if greater\n+     *  than, <code>0</code> of equal\n+     * @throws ClassCastException if other is not an Enum\n+     * @throws NullPointerException if other is <code>null</code>\n+     */\n+    public int compareTo(Object other) {\n+        if (other == this) {\n+            return 0;\n+        }\n+        if (other.getClass() != this.getClass()) {\n+            if (other.getClass().getName().equals(this.getClass().getName())) {\n+                return iName.compareTo( getNameInOtherClassLoader(other) );\n+            }\n+        }\n+        return iName.compareTo(((Enum) other).iName);\n+    }\n+\n+    /**\n+     * <p>Use reflection to return an objects class name.</p>\n+     *\n+     * @param other The object to determine the class name for\n+     * @return The class name\n+     */\n+    private String getNameInOtherClassLoader(Object other) {\n+        try {\n+            Method mth = other.getClass().getMethod(\"getName\", null);\n+            String name = (String) mth.invoke(other, null);\n+            return name;\n+        } catch (NoSuchMethodException e) {\n+            // ignore - should never happen\n+        } catch (IllegalAccessException e) {\n+            // ignore - should never happen\n+        } catch (InvocationTargetException e) {\n+            // ignore - should never happen\n+        }\n+        throw new IllegalStateException(\"This should not happen\");\n+    }\n+\n+    /**\n+     * <p>Human readable description of this Enum item.</p>\n+     * \n+     * @return String in the form <code>type[name]</code>, for example:\n+     * <code>Color[Red]</code>. Note that the package name is stripped from\n+     * the type name.\n+     */\n+    public String toString() {\n+        if (iToString == null) {\n+            String shortName = ClassUtils.getShortClassName(getEnumClass());\n+            iToString = shortName + \"[\" + getName() + \"]\";\n+        }\n+        return iToString;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/enum/EnumUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <p>Utility class for accessing and manipulating {@link Enum}s.</p>\n+ *\n+ * @deprecated Replaced by {@link org.apache.commons.lang.enums.EnumUtils org.apache.commons.lang.enums.EnumUtils} \n+ *          and will be removed in version 3.0. All classes in this package are deprecated and repackaged to \n+ *          {@link org.apache.commons.lang.enums} since <code>enum</code> is a Java 1.5 keyword. \n+ * @see org.apache.commons.lang.enums.EnumUtils\n+ * @see Enum\n+ * @see ValuedEnum\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class EnumUtils {\n+\n+    /**\n+     * Public constructor. This class should not normally be instantiated.\n+     * @since 2.0\n+     */\n+    public EnumUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Gets an <code>Enum</code> object by class and name.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @param name  the name of the Enum to get, may be <code>null</code>\n+     * @return the enum object\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     */\n+    public static Enum getEnum(Class enumClass, String name) {\n+        return Enum.getEnum(enumClass, name);\n+    }\n+\n+    /**\n+     * <p>Gets a <code>ValuedEnum</code> object by class and value.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @param value  the value of the <code>Enum</code> to get\n+     * @return the enum object, or null if the enum does not exist\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     */\n+    public static ValuedEnum getEnum(Class enumClass, int value) {\n+        return (ValuedEnum) ValuedEnum.getEnum(enumClass, value);\n+    }\n+\n+    /**\n+     * <p>Gets the <code>Map</code> of <code>Enum</code> objects by\n+     * name using the <code>Enum</code> class.</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>Map</code> is returned. The <code>Map</code> is unmodifiable.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @return the enum object Map\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass\n+     *  of <code>Enum</code>\n+     */\n+    public static Map getEnumMap(Class enumClass) {\n+        return Enum.getEnumMap(enumClass);\n+    }\n+\n+    /**\n+     * <p>Gets the <code>List</code> of <code>Enum</code> objects using\n+     * the <code>Enum</code> class.</p>\n+     *\n+     * <p>The list is in the order that the objects were created\n+     * (source code order).</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>List</code> is returned. The <code>List</code> is unmodifiable.</p>\n+     * \n+     * @param enumClass  the class of the Enum to get\n+     * @return the enum object Map\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass\n+     *  of <code>Enum</code>\n+     */\n+    public static List getEnumList(Class enumClass) {\n+        return Enum.getEnumList(enumClass);\n+    }\n+\n+    /**\n+     * <p>Gets an <code>Iterator</code> over the <code>Enum</code> objects\n+     * in an <code>Enum</code> class.</p>\n+     *\n+     * <p>The iterator is in the order that the objects were created\n+     * (source code order).</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>Iterator</code> is returned. The <code>Iterator</code>\n+     * is unmodifiable.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @return an <code>Iterator</code> of the <code>Enum</code> objects\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass of <code>Enum</code>\n+     */\n+    public static Iterator iterator(Class enumClass) {\n+        return Enum.getEnumList(enumClass).iterator();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/enum/ValuedEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p>Abstract superclass for type-safe enums with integer values suitable\n+ * for use in <code>switch</code> statements.</p>\n+ *\n+ * <p><em>NOTE:</em>Due to the way in which Java ClassLoaders work, comparing\n+ * <code>Enum</code> objects should always be done using the equals() method,\n+ * not <code>==</code>. The equals() method will try <code>==</code> first so\n+ * in most cases the effect is the same.</p>\n+ *\n+ * <p>To use this class, it must be subclassed. For example:</p>\n+ *\n+ * <pre>\n+ * public final class JavaVersionEnum extends ValuedEnum {\n+ *   //standard enums for version of JVM\n+ *   public static final int  JAVA1_0_VALUE  = 100;\n+ *   public static final int  JAVA1_1_VALUE  = 110;\n+ *   public static final int  JAVA1_2_VALUE  = 120;\n+ *   public static final int  JAVA1_3_VALUE  = 130;\n+ *   public static final JavaVersionEnum  JAVA1_0  = new JavaVersionEnum( \"Java 1.0\", JAVA1_0_VALUE );\n+ *   public static final JavaVersionEnum  JAVA1_1  = new JavaVersionEnum( \"Java 1.1\", JAVA1_1_VALUE );\n+ *   public static final JavaVersionEnum  JAVA1_2  = new JavaVersionEnum( \"Java 1.2\", JAVA1_2_VALUE );\n+ *   public static final JavaVersionEnum  JAVA1_3  = new JavaVersionEnum( \"Java 1.3\", JAVA1_3_VALUE );\n+ *\n+ *   private JavaVersionEnum(String name, int value) {\n+ *     super( name, value );\n+ *   }\n+ * \n+ *   public static JavaVersionEnum getEnum(String javaVersion) {\n+ *     return (JavaVersionEnum) getEnum(JavaVersionEnum.class, javaVersion);\n+ *   }\n+ * \n+ *   public static JavaVersionEnum getEnum(int javaVersion) {\n+ *     return (JavaVersionEnum) getEnum(JavaVersionEnum.class, javaVersion);\n+ *   }\n+ * \n+ *   public static Map getEnumMap() {\n+ *     return getEnumMap(JavaVersionEnum.class);\n+ *   }\n+ * \n+ *   public static List getEnumList() {\n+ *     return getEnumList(JavaVersionEnum.class);\n+ *   }\n+ * \n+ *   public static Iterator iterator() {\n+ *     return iterator(JavaVersionEnum.class);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>The above class could then be used as follows:</p>\n+ *\n+ * <pre>\n+ * public void doSomething(JavaVersionEnum ver) {\n+ *   switch (ver.getValue()) {\n+ *     case JAVA1_0_VALUE:\n+ *       // ...\n+ *       break;\n+ *     case JAVA1_1_VALUE:\n+ *       // ...\n+ *       break;\n+ *     //...\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>As shown, each enum has a name and a value. These can be accessed using\n+ * <code>getName</code> and <code>getValue</code>.</p>\n+ *\n+ * <p>The <code>getEnum</code> and <code>iterator</code> methods are recommended.\n+ * Unfortunately, Java restrictions require these to be coded as shown in each subclass.\n+ * An alternative choice is to use the {@link EnumUtils} class.</p>\n+ *\n+ * @deprecated Replaced by {@link org.apache.commons.lang.enums.ValuedEnum org.apache.commons.lang.enums.ValuedEnum}\n+ *          and will be removed in version 3.0. All classes in this package are deprecated and repackaged to \n+ *          {@link org.apache.commons.lang.enums} since <code>enum</code> is a Java 1.5 keyword. \n+ * @see org.apache.commons.lang.enums.ValuedEnum\n+ * @author Apache Avalon project\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public abstract class ValuedEnum extends Enum {\n+    \n+    /**\n+     * Required for serialization support. Lang version 1.0.1 serial compatibility.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -7129650521543789085L;\n+    \n+    /**\n+     * The value contained in enum.\n+     */\n+    private final int iValue;\n+\n+    /**\n+     * Constructor for enum item.\n+     *\n+     * @param name  the name of enum item\n+     * @param value  the value of enum item\n+     */\n+    protected ValuedEnum(String name, int value) {\n+        super(name);\n+        iValue = value;\n+    }\n+\n+    /**\n+     * <p>Gets an <code>Enum</code> object by class and value.</p>\n+     *\n+     * <p>This method loops through the list of <code>Enum</code>,\n+     * thus if there are many <code>Enum</code>s this will be\n+     * slow.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @param value  the value of the <code>Enum</code> to get\n+     * @return the enum object, or null if the enum does not exist\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     */\n+    protected static Enum getEnum(Class enumClass, int value) {\n+        if (enumClass == null) {\n+            throw new IllegalArgumentException(\"The Enum Class must not be null\");\n+        }\n+        List list = Enum.getEnumList(enumClass);\n+        for (Iterator it = list.iterator(); it.hasNext();) {\n+            ValuedEnum enumeration = (ValuedEnum) it.next();\n+            if (enumeration.getValue() == value) {\n+                return enumeration;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Get value of enum item.</p>\n+     *\n+     * @return the enum item's value.\n+     */\n+    public final int getValue() {\n+        return iValue;\n+    }\n+\n+    /**\n+     * <p>Tests for order.</p>\n+     *\n+     * <p>The default ordering is numeric by value, but this\n+     * can be overridden by subclasses.</p>\n+     * \n+     * @see java.lang.Comparable#compareTo(Object)\n+     * @param other  the other object to compare to\n+     * @return -ve if this is less than the other object, +ve if greater than,\n+     *  <code>0</code> of equal\n+     * @throws ClassCastException if other is not an <code>Enum</code>\n+     * @throws NullPointerException if other is <code>null</code>\n+     */\n+    public int compareTo(Object other) {\n+        return iValue - ((ValuedEnum) other).iValue;\n+    }\n+\n+    /**\n+     * <p>Human readable description of this <code>Enum</code> item.</p>\n+     *\n+     * @return String in the form <code>type[name=value]</code>, for example:\n+     *  <code>JavaVersion[Java 1.0=100]</code>. Note that the package name is\n+     *  stripped from the type name.\n+     */\n+    public String toString() {\n+        if (iToString == null) {\n+            String shortName = ClassUtils.getShortClassName(getEnumClass());\n+            iToString = shortName + \"[\" + getName() + \"=\" + getValue() + \"]\";\n+        }\n+        return iToString;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/enums/Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * <p>Abstract superclass for type-safe enums.</p>\n+ *\n+ * <p>One feature of the C programming language lacking in Java is enumerations. The\n+ * C implementation based on ints was poor and open to abuse. The original Java\n+ * recommendation and most of the JDK also uses int constants. It has been recognised\n+ * however that a more robust type-safe class-based solution can be designed. This\n+ * class follows the basic Java type-safe enumeration pattern.</p>\n+ *\n+ * <p><em>NOTE:</em> Due to the way in which Java ClassLoaders work, comparing\n+ * Enum objects should always be done using <code>equals()</code>, not <code>==</code>.\n+ * The equals() method will try == first so in most cases the effect is the same.</p>\n+ * \n+ * <p>Of course, if you actually want (or don't mind) Enums in different class\n+ * loaders being non-equal, then you can use <code>==</code>.</p>\n+ * \n+ * <h4>Simple Enums</h4>\n+ *\n+ * <p>To use this class, it must be subclassed. For example:</p>\n+ *\n+ * <pre>\n+ * public final class ColorEnum extends Enum {\n+ *   public static final ColorEnum RED = new ColorEnum(\"Red\");\n+ *   public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+ *   public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+ *\n+ *   private ColorEnum(String color) {\n+ *     super(color);\n+ *   }\n+ * \n+ *   public static ColorEnum getEnum(String color) {\n+ *     return (ColorEnum) getEnum(ColorEnum.class, color);\n+ *   }\n+ * \n+ *   public static Map getEnumMap() {\n+ *     return getEnumMap(ColorEnum.class);\n+ *   }\n+ * \n+ *   public static List getEnumList() {\n+ *     return getEnumList(ColorEnum.class);\n+ *   }\n+ * \n+ *   public static Iterator iterator() {\n+ *     return iterator(ColorEnum.class);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>As shown, each enum has a name. This can be accessed using <code>getName</code>.</p>\n+ *\n+ * <p>The <code>getEnum</code> and <code>iterator</code> methods are recommended.\n+ * Unfortunately, Java restrictions require these to be coded as shown in each subclass.\n+ * An alternative choice is to use the {@link EnumUtils} class.</p>\n+ * \n+ * <h4>Subclassed Enums</h4>\n+ * <p>A hierarchy of Enum classes can be built. In this case, the superclass is\n+ * unaffected by the addition of subclasses (as per normal Java). The subclasses\n+ * may add additional Enum constants <em>of the type of the superclass</em>. The\n+ * query methods on the subclass will return all of the Enum constants from the\n+ * superclass and subclass.</p>\n+ *\n+ * <pre>\n+ * public final class ExtraColorEnum extends ColorEnum {\n+ *   // NOTE: Color enum declared above is final, change that to get this\n+ *   // example to compile.\n+ *   public static final ColorEnum YELLOW = new ExtraColorEnum(\"Yellow\");\n+ *\n+ *   private ExtraColorEnum(String color) {\n+ *     super(color);\n+ *   }\n+ * \n+ *   public static ColorEnum getEnum(String color) {\n+ *     return (ColorEnum) getEnum(ExtraColorEnum.class, color);\n+ *   }\n+ * \n+ *   public static Map getEnumMap() {\n+ *     return getEnumMap(ExtraColorEnum.class);\n+ *   }\n+ * \n+ *   public static List getEnumList() {\n+ *     return getEnumList(ExtraColorEnum.class);\n+ *   }\n+ * \n+ *   public static Iterator iterator() {\n+ *     return iterator(ExtraColorEnum.class);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>This example will return RED, GREEN, BLUE, YELLOW from the List and iterator\n+ * methods in that order. The RED, GREEN and BLUE instances will be the same (==) \n+ * as those from the superclass ColorEnum. Note that YELLOW is declared as a\n+ * ColorEnum and not an ExtraColorEnum.</p>\n+ * \n+ * <h4>Functional Enums</h4>\n+ *\n+ * <p>The enums can have functionality by defining subclasses and\n+ * overriding the <code>getEnumClass()</code> method:</p>\n+ * \n+ * <pre>\n+ *   public static final OperationEnum PLUS = new PlusOperation();\n+ *   private static final class PlusOperation extends OperationEnum {\n+ *     private PlusOperation() {\n+ *       super(\"Plus\");\n+ *     }\n+ *     public int eval(int a, int b) {\n+ *       return a + b;\n+ *     }\n+ *   }\n+ *   public static final OperationEnum MINUS = new MinusOperation();\n+ *   private static final class MinusOperation extends OperationEnum {\n+ *     private MinusOperation() {\n+ *       super(\"Minus\");\n+ *     }\n+ *     public int eval(int a, int b) {\n+ *       return a - b;\n+ *     }\n+ *   }\n+ *\n+ *   private OperationEnum(String color) {\n+ *     super(color);\n+ *   }\n+ * \n+ *   public final Class getEnumClass() {     // NOTE: new method!\n+ *     return OperationEnum.class;\n+ *   }\n+ *\n+ *   public abstract double eval(double a, double b);\n+ * \n+ *   public static OperationEnum getEnum(String name) {\n+ *     return (OperationEnum) getEnum(OperationEnum.class, name);\n+ *   }\n+ * \n+ *   public static Map getEnumMap() {\n+ *     return getEnumMap(OperationEnum.class);\n+ *   }\n+ * \n+ *   public static List getEnumList() {\n+ *     return getEnumList(OperationEnum.class);\n+ *   }\n+ * \n+ *   public static Iterator iterator() {\n+ *     return iterator(OperationEnum.class);\n+ *   }\n+ * }\n+ * </pre>\n+ * <p>The code above will work on JDK 1.2. If JDK1.3 and later is used,\n+ * the subclasses may be defined as anonymous.</p>\n+ * \n+ * <h4>Nested class Enums</h4>\n+ *\n+ * <p>Care must be taken with class loading when defining a static nested class\n+ * for enums. The static nested class can be loaded without the surrounding outer\n+ * class being loaded. This can result in an empty list/map/iterator being returned.\n+ * One solution is to define a static block that references the outer class where\n+ * the constants are defined. For example:</p>\n+ *\n+ * <pre>\n+ * public final class Outer {\n+ *   public static final BWEnum BLACK = new BWEnum(\"Black\");\n+ *   public static final BWEnum WHITE = new BWEnum(\"White\");\n+ *\n+ *   // static nested enum class\n+ *   public static final class BWEnum extends Enum {\n+ * \n+ *     static {\n+ *       // explicitly reference BWEnum class to force constants to load\n+ *       Object obj = Outer.BLACK;\n+ *     }\n+ * \n+ *     // ... other methods omitted\n+ *   }\n+ * }\n+ * </pre>\n+ * \n+ * <p>Although the above solves the problem, it is not recommended. The best solution\n+ * is to define the constants in the enum class, and hold references in the outer class:\n+ *\n+ * <pre>\n+ * public final class Outer {\n+ *   public static final BWEnum BLACK = BWEnum.BLACK;\n+ *   public static final BWEnum WHITE = BWEnum.WHITE;\n+ *\n+ *   // static nested enum class\n+ *   public static final class BWEnum extends Enum {\n+ *     // only define constants in enum classes - private if desired\n+ *     private static final BWEnum BLACK = new BWEnum(\"Black\");\n+ *     private static final BWEnum WHITE = new BWEnum(\"White\");\n+ * \n+ *     // ... other methods omitted\n+ *   }\n+ * }\n+ * </pre>\n+ * \n+ * <p>For more details, see the 'Nested' test cases.\n+ * \n+ * @author Apache Avalon project\n+ * @author Stephen Colebourne\n+ * @author Chris Webb\n+ * @author Mike Bowler\n+ * @author Matthias Eichel\n+ * @since 2.1 (class existed in enum package from v1.0)\n+ * @version $Id$\n+ */\n+public abstract class Enum implements Comparable, Serializable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -487045951170455942L;\n+    \n+    // After discussion, the default size for HashMaps is used, as the\n+    // sizing algorithm changes across the JDK versions\n+    /**\n+     * An empty <code>Map</code>, as JDK1.2 didn't have an empty map.\n+     */\n+    private static final Map EMPTY_MAP = Collections.unmodifiableMap(new HashMap(0));\n+    \n+    /**\n+     * <code>Map</code>, key of class name, value of <code>Entry</code>.\n+     */\n+    private static final Map cEnumClasses = new HashMap();\n+    \n+    /**\n+     * The string representation of the Enum.\n+     */\n+    private final String iName;\n+    \n+    /**\n+     * The hashcode representation of the Enum.\n+     */\n+    private transient final int iHashCode;\n+    \n+    /**\n+     * The toString representation of the Enum.\n+     * @since 2.0\n+     */\n+    protected transient String iToString = null;\n+\n+    /**\n+     * <p>Enable the iterator to retain the source code order.</p>\n+     */\n+    private static class Entry {\n+        /**\n+         * Map of Enum name to Enum.\n+         */\n+        final Map map = new HashMap();\n+        /**\n+         * Map of Enum name to Enum.\n+         */\n+        final Map unmodifiableMap = Collections.unmodifiableMap(map);\n+        /**\n+         * List of Enums in source code order.\n+         */\n+        final List list = new ArrayList(25);\n+        /**\n+         * Map of Enum name to Enum.\n+         */\n+        final List unmodifiableList = Collections.unmodifiableList(list);\n+\n+        /**\n+         * <p>Restrictive constructor.</p>\n+         */\n+        protected Entry() {\n+          super();\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructor to add a new named item to the enumeration.</p>\n+     *\n+     * @param name  the name of the enum object,\n+     *  must not be empty or <code>null</code>\n+     * @throws IllegalArgumentException if the name is <code>null</code>\n+     *  or an empty string\n+     * @throws IllegalArgumentException if the getEnumClass() method returns\n+     *  a null or invalid Class\n+     */\n+    protected Enum(String name) {\n+        super();\n+        init(name);\n+        iName = name;\n+        iHashCode = 7 + getEnumClass().hashCode() + 3 * name.hashCode();\n+        // cannot create toString here as subclasses may want to include other data\n+    }\n+\n+    /**\n+     * Initializes the enumeration.\n+     * \n+     * @param name  the enum name\n+     * @throws IllegalArgumentException if the name is null or empty or duplicate\n+     * @throws IllegalArgumentException if the enumClass is null or invalid\n+     */\n+    private void init(String name) {\n+        if (StringUtils.isEmpty(name)) {\n+            throw new IllegalArgumentException(\"The Enum name must not be empty or null\");\n+        }\n+        \n+        Class enumClass = getEnumClass();\n+        if (enumClass == null) {\n+            throw new IllegalArgumentException(\"getEnumClass() must not be null\");\n+        }\n+        Class cls = getClass();\n+        boolean ok = false;\n+        while (cls != null && cls != Enum.class && cls != ValuedEnum.class) {\n+            if (cls == enumClass) {\n+                ok = true;\n+                break;\n+            }\n+            cls = cls.getSuperclass();\n+        }\n+        if (ok == false) {\n+            throw new IllegalArgumentException(\"getEnumClass() must return a superclass of this class\");\n+        }\n+        \n+        // create entry\n+        Entry entry = (Entry) cEnumClasses.get(enumClass);\n+        if (entry == null) {\n+            entry = createEntry(enumClass);\n+            cEnumClasses.put(enumClass, entry);\n+        }\n+        if (entry.map.containsKey(name)) {\n+            throw new IllegalArgumentException(\"The Enum name must be unique, '\" + name + \"' has already been added\");\n+        }\n+        entry.map.put(name, this);\n+        entry.list.add(this);\n+    }\n+\n+    /**\n+     * <p>Handle the deserialization of the class to ensure that multiple\n+     * copies are not wastefully created, or illegal enum types created.</p>\n+     *\n+     * @return the resolved object\n+     */\n+    protected Object readResolve() {\n+        Entry entry = (Entry) cEnumClasses.get(getEnumClass());\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.map.get(getName());\n+    }\n+    \n+    //--------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets an <code>Enum</code> object by class and name.</p>\n+     * \n+     * @param enumClass  the class of the Enum to get, must not\n+     *  be <code>null</code>\n+     * @param name  the name of the <code>Enum</code> to get,\n+     *  may be <code>null</code>\n+     * @return the enum object, or <code>null</code> if the enum does not exist\n+     * @throws IllegalArgumentException if the enum class\n+     *  is <code>null</code>\n+     */\n+    protected static Enum getEnum(Class enumClass, String name) {\n+        Entry entry = getEntry(enumClass);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return (Enum) entry.map.get(name);\n+    }\n+\n+    /**\n+     * <p>Gets the <code>Map</code> of <code>Enum</code> objects by\n+     * name using the <code>Enum</code> class.</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>Map</code> is returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n+     * @return the enum object Map\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n+     */\n+    protected static Map getEnumMap(Class enumClass) {\n+        Entry entry = getEntry(enumClass);\n+        if (entry == null) {\n+            return EMPTY_MAP;\n+        }\n+        return entry.unmodifiableMap;\n+    }\n+\n+    /**\n+     * <p>Gets the <code>List</code> of <code>Enum</code> objects using the\n+     * <code>Enum</code> class.</p>\n+     *\n+     * <p>The list is in the order that the objects were created (source code order).\n+     * If the requested class has no enum objects an empty <code>List</code> is\n+     * returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n+     * @return the enum object Map\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n+     */\n+    protected static List getEnumList(Class enumClass) {\n+        Entry entry = getEntry(enumClass);\n+        if (entry == null) {\n+            return Collections.EMPTY_LIST;\n+        }\n+        return entry.unmodifiableList;\n+    }\n+\n+    /**\n+     * <p>Gets an <code>Iterator</code> over the <code>Enum</code> objects in\n+     * an <code>Enum</code> class.</p>\n+     *\n+     * <p>The <code>Iterator</code> is in the order that the objects were\n+     * created (source code order). If the requested class has no enum\n+     * objects an empty <code>Iterator</code> is returned.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get,\n+     *  must not be <code>null</code>\n+     * @return an iterator of the Enum objects\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass of Enum\n+     */\n+    protected static Iterator iterator(Class enumClass) {\n+        return Enum.getEnumList(enumClass).iterator();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets an <code>Entry</code> from the map of Enums.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @return the enum entry\n+     */\n+    private static Entry getEntry(Class enumClass) {\n+        if (enumClass == null) {\n+            throw new IllegalArgumentException(\"The Enum Class must not be null\");\n+        }\n+        if (Enum.class.isAssignableFrom(enumClass) == false) {\n+            throw new IllegalArgumentException(\"The Class must be a subclass of Enum\");\n+        }\n+        Entry entry = (Entry) cEnumClasses.get(enumClass);\n+        return entry;\n+    }\n+    \n+    /**\n+     * <p>Creates an <code>Entry</code> for storing the Enums.</p>\n+     *\n+     * <p>This accounts for subclassed Enums.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @return the enum entry\n+     */\n+    private static Entry createEntry(Class enumClass) {\n+        Entry entry = new Entry();\n+        Class cls = enumClass.getSuperclass();\n+        while (cls != null && cls != Enum.class && cls != ValuedEnum.class) {\n+            Entry loopEntry = (Entry) cEnumClasses.get(cls);\n+            if (loopEntry != null) {\n+                entry.list.addAll(loopEntry.list);\n+                entry.map.putAll(loopEntry.map);\n+                break;  // stop here, as this will already have had superclasses added\n+            }\n+            cls = cls.getSuperclass();\n+        }\n+        return entry;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Retrieve the name of this Enum item, set in the constructor.</p>\n+     * \n+     * @return the <code>String</code> name of this Enum item\n+     */\n+    public final String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * <p>Retrieves the Class of this Enum item, set in the constructor.</p>\n+     * \n+     * <p>This is normally the same as <code>getClass()</code>, but for\n+     * advanced Enums may be different. If overridden, it must return a\n+     * constant value.</p>\n+     * \n+     * @return the <code>Class</code> of the enum\n+     * @since 2.0\n+     */\n+    public Class getEnumClass() {\n+        return getClass();\n+    }\n+\n+    /**\n+     * <p>Tests for equality.</p>\n+     *\n+     * <p>Two Enum objects are considered equal\n+     * if they have the same class names and the same names.\n+     * Identity is tested for first, so this method usually runs fast.</p>\n+     * \n+     * <p>If the parameter is in a different class loader than this instance,\n+     * reflection is used to compare the names.</p>\n+     *\n+     * @param other  the other object to compare for equality\n+     * @return <code>true</code> if the Enums are equal\n+     */\n+    public final boolean equals(Object other) {\n+        if (other == this) {\n+            return true;\n+        } else if (other == null) {\n+            return false;\n+        } else if (other.getClass() == this.getClass()) {\n+            // Ok to do a class cast to Enum here since the test above\n+            // guarantee both\n+            // classes are in the same class loader.\n+            return iName.equals(((Enum) other).iName);\n+        } else {\n+            // This and other are in different class loaders, we must check indirectly\n+            if (other.getClass().getName().equals(this.getClass().getName()) == false) {\n+                return false;\n+            }\n+            return iName.equals( getNameInOtherClassLoader(other) );\n+        }\n+    }\n+    \n+    /**\n+     * <p>Returns a suitable hashCode for the enumeration.</p>\n+     *\n+     * @return a hashcode based on the name\n+     */\n+    public final int hashCode() {\n+        return iHashCode;\n+    }\n+\n+    /**\n+     * <p>Tests for order.</p>\n+     *\n+     * <p>The default ordering is alphabetic by name, but this\n+     * can be overridden by subclasses.</p>\n+     * \n+     * <p>If the parameter is in a different class loader than this instance,\n+     * reflection is used to compare the names.</p>\n+     *\n+     * @see java.lang.Comparable#compareTo(Object)\n+     * @param other  the other object to compare to\n+     * @return -ve if this is less than the other object, +ve if greater\n+     *  than, <code>0</code> of equal\n+     * @throws ClassCastException if other is not an Enum\n+     * @throws NullPointerException if other is <code>null</code>\n+     */\n+    public int compareTo(Object other) {\n+        if (other == this) {\n+            return 0;\n+        }\n+        if (other.getClass() != this.getClass()) {\n+            if (other.getClass().getName().equals(this.getClass().getName())) {\n+                return iName.compareTo( getNameInOtherClassLoader(other) );\n+            }\n+            throw new ClassCastException(\n+                    \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\");\n+        }\n+        return iName.compareTo(((Enum) other).iName);\n+    }\n+\n+    /**\n+     * <p>Use reflection to return an objects class name.</p>\n+     *\n+     * @param other The object to determine the class name for\n+     * @return The class name\n+     */\n+    private String getNameInOtherClassLoader(Object other) {\n+        try {\n+            Method mth = other.getClass().getMethod(\"getName\", null);\n+            String name = (String) mth.invoke(other, null);\n+            return name;\n+        } catch (NoSuchMethodException e) {\n+            // ignore - should never happen\n+        } catch (IllegalAccessException e) {\n+            // ignore - should never happen\n+        } catch (InvocationTargetException e) {\n+            // ignore - should never happen\n+        }\n+        throw new IllegalStateException(\"This should not happen\");\n+    }\n+\n+    /**\n+     * <p>Human readable description of this Enum item.</p>\n+     * \n+     * @return String in the form <code>type[name]</code>, for example:\n+     * <code>Color[Red]</code>. Note that the package name is stripped from\n+     * the type name.\n+     */\n+    public String toString() {\n+        if (iToString == null) {\n+            String shortName = ClassUtils.getShortClassName(getEnumClass());\n+            iToString = shortName + \"[\" + getName() + \"]\";\n+        }\n+        return iToString;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/enums/EnumUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <p>Utility class for accessing and manipulating {@link Enum}s.</p>\n+ *\n+ * @see Enum\n+ * @see ValuedEnum\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @since 2.1 (class existed in enum package from v1.0)\n+ * @version $Id$\n+ */\n+public class EnumUtils {\n+\n+    /**\n+     * Public constructor. This class should not normally be instantiated.\n+     * @since 2.0\n+     */\n+    public EnumUtils() {\n+      super();\n+    }\n+\n+    /**\n+     * <p>Gets an <code>Enum</code> object by class and name.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @param name  the name of the Enum to get, may be <code>null</code>\n+     * @return the enum object\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     */\n+    public static Enum getEnum(Class enumClass, String name) {\n+        return Enum.getEnum(enumClass, name);\n+    }\n+\n+    /**\n+     * <p>Gets a <code>ValuedEnum</code> object by class and value.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @param value  the value of the <code>Enum</code> to get\n+     * @return the enum object, or null if the enum does not exist\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     */\n+    public static ValuedEnum getEnum(Class enumClass, int value) {\n+        return (ValuedEnum) ValuedEnum.getEnum(enumClass, value);\n+    }\n+\n+    /**\n+     * <p>Gets the <code>Map</code> of <code>Enum</code> objects by\n+     * name using the <code>Enum</code> class.</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>Map</code> is returned. The <code>Map</code> is unmodifiable.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @return the enum object Map\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass\n+     *  of <code>Enum</code>\n+     */\n+    public static Map getEnumMap(Class enumClass) {\n+        return Enum.getEnumMap(enumClass);\n+    }\n+\n+    /**\n+     * <p>Gets the <code>List</code> of <code>Enum</code> objects using\n+     * the <code>Enum</code> class.</p>\n+     *\n+     * <p>The list is in the order that the objects were created\n+     * (source code order).</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>List</code> is returned. The <code>List</code> is unmodifiable.</p>\n+     * \n+     * @param enumClass  the class of the Enum to get\n+     * @return the enum object Map\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass\n+     *  of <code>Enum</code>\n+     */\n+    public static List getEnumList(Class enumClass) {\n+        return Enum.getEnumList(enumClass);\n+    }\n+\n+    /**\n+     * <p>Gets an <code>Iterator</code> over the <code>Enum</code> objects\n+     * in an <code>Enum</code> class.</p>\n+     *\n+     * <p>The iterator is in the order that the objects were created\n+     * (source code order).</p>\n+     *\n+     * <p>If the requested class has no enum objects an empty\n+     * <code>Iterator</code> is returned. The <code>Iterator</code>\n+     * is unmodifiable.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @return an <code>Iterator</code> of the <code>Enum</code> objects\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     * @throws IllegalArgumentException if the enum class is not a subclass of <code>Enum</code>\n+     */\n+    public static Iterator iterator(Class enumClass) {\n+        return Enum.getEnumList(enumClass).iterator();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/enums/ValuedEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p>Abstract superclass for type-safe enums with integer values suitable\n+ * for use in <code>switch</code> statements.</p>\n+ *\n+ * <p><em>NOTE:</em>Due to the way in which Java ClassLoaders work, comparing\n+ * <code>Enum</code> objects should always be done using the equals() method,\n+ * not <code>==</code>. The equals() method will try <code>==</code> first so\n+ * in most cases the effect is the same.</p>\n+ *\n+ * <p>To use this class, it must be subclassed. For example:</p>\n+ *\n+ * <pre>\n+ * public final class JavaVersionEnum extends ValuedEnum {\n+ *   //standard enums for version of JVM\n+ *   public static final int  JAVA1_0_VALUE  = 100;\n+ *   public static final int  JAVA1_1_VALUE  = 110;\n+ *   public static final int  JAVA1_2_VALUE  = 120;\n+ *   public static final int  JAVA1_3_VALUE  = 130;\n+ *   public static final JavaVersionEnum  JAVA1_0  = new JavaVersionEnum( \"Java 1.0\", JAVA1_0_VALUE );\n+ *   public static final JavaVersionEnum  JAVA1_1  = new JavaVersionEnum( \"Java 1.1\", JAVA1_1_VALUE );\n+ *   public static final JavaVersionEnum  JAVA1_2  = new JavaVersionEnum( \"Java 1.2\", JAVA1_2_VALUE );\n+ *   public static final JavaVersionEnum  JAVA1_3  = new JavaVersionEnum( \"Java 1.3\", JAVA1_3_VALUE );\n+ *\n+ *   private JavaVersionEnum(String name, int value) {\n+ *     super( name, value );\n+ *   }\n+ * \n+ *   public static JavaVersionEnum getEnum(String javaVersion) {\n+ *     return (JavaVersionEnum) getEnum(JavaVersionEnum.class, javaVersion);\n+ *   }\n+ * \n+ *   public static JavaVersionEnum getEnum(int javaVersion) {\n+ *     return (JavaVersionEnum) getEnum(JavaVersionEnum.class, javaVersion);\n+ *   }\n+ * \n+ *   public static Map getEnumMap() {\n+ *     return getEnumMap(JavaVersionEnum.class);\n+ *   }\n+ * \n+ *   public static List getEnumList() {\n+ *     return getEnumList(JavaVersionEnum.class);\n+ *   }\n+ * \n+ *   public static Iterator iterator() {\n+ *     return iterator(JavaVersionEnum.class);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p><em>NOTE:</em>These are declared <code>final</code>, so compilers may \n+ * inline the code. Ensure you recompile everything when using final. </p>\n+ *\n+ * <p>The above class could then be used as follows:</p>\n+ *\n+ * <pre>\n+ * public void doSomething(JavaVersionEnum ver) {\n+ *   switch (ver.getValue()) {\n+ *     case JAVA1_0_VALUE:\n+ *       // ...\n+ *       break;\n+ *     case JAVA1_1_VALUE:\n+ *       // ...\n+ *       break;\n+ *     //...\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>As shown, each enum has a name and a value. These can be accessed using\n+ * <code>getName</code> and <code>getValue</code>.</p>\n+ *\n+ * <p>The <code>getEnum</code> and <code>iterator</code> methods are recommended.\n+ * Unfortunately, Java restrictions require these to be coded as shown in each subclass.\n+ * An alternative choice is to use the {@link EnumUtils} class.</p>\n+ *\n+ * @author Apache Avalon project\n+ * @author Stephen Colebourne\n+ * @since 2.1 (class existed in enum package from v1.0)\n+ * @version $Id$\n+ */\n+public abstract class ValuedEnum extends Enum {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -7129650521543789085L;\n+    \n+    /**\n+     * The value contained in enum.\n+     */\n+    private final int iValue;\n+\n+    /**\n+     * Constructor for enum item.\n+     *\n+     * @param name  the name of enum item\n+     * @param value  the value of enum item\n+     */\n+    protected ValuedEnum(String name, int value) {\n+        super(name);\n+        iValue = value;\n+    }\n+\n+    /**\n+     * <p>Gets an <code>Enum</code> object by class and value.</p>\n+     *\n+     * <p>This method loops through the list of <code>Enum</code>,\n+     * thus if there are many <code>Enum</code>s this will be\n+     * slow.</p>\n+     * \n+     * @param enumClass  the class of the <code>Enum</code> to get\n+     * @param value  the value of the <code>Enum</code> to get\n+     * @return the enum object, or null if the enum does not exist\n+     * @throws IllegalArgumentException if the enum class is <code>null</code>\n+     */\n+    protected static Enum getEnum(Class enumClass, int value) {\n+        if (enumClass == null) {\n+            throw new IllegalArgumentException(\"The Enum Class must not be null\");\n+        }\n+        List list = Enum.getEnumList(enumClass);\n+        for (Iterator it = list.iterator(); it.hasNext();) {\n+            ValuedEnum enumeration = (ValuedEnum) it.next();\n+            if (enumeration.getValue() == value) {\n+                return enumeration;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Get value of enum item.</p>\n+     *\n+     * @return the enum item's value.\n+     */\n+    public final int getValue() {\n+        return iValue;\n+    }\n+\n+    /**\n+     * <p>Tests for order.</p>\n+     *\n+     * <p>The default ordering is numeric by value, but this\n+     * can be overridden by subclasses.</p>\n+     *\n+     * <p>NOTE: From v2.2 the enums must be of the same type.\n+     * If the parameter is in a different class loader than this instance,\n+     * reflection is used to compare the values.</p>\n+     *\n+     * @see java.lang.Comparable#compareTo(Object)\n+     * @param other  the other object to compare to\n+     * @return -ve if this is less than the other object, +ve if greater than,\n+     *  <code>0</code> of equal\n+     * @throws ClassCastException if other is not an <code>Enum</code>\n+     * @throws NullPointerException if other is <code>null</code>\n+     */\n+    public int compareTo(Object other) {\n+        if (other == this) {\n+            return 0;\n+        }\n+        if (other.getClass() != this.getClass()) {\n+            if (other.getClass().getName().equals(this.getClass().getName())) {\n+                return iValue - getValueInOtherClassLoader(other);\n+            }\n+            throw new ClassCastException(\n+                    \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\");\n+        }\n+        return iValue - ((ValuedEnum) other).iValue;\n+    }\n+\n+    /**\n+     * <p>Use reflection to return an objects value.</p>\n+     *\n+     * @param other  the object to determine the value for\n+     * @return the value\n+     */\n+    private int getValueInOtherClassLoader(Object other) {\n+        try {\n+            Method mth = other.getClass().getMethod(\"getValue\", null);\n+            Integer value = (Integer) mth.invoke(other, null);\n+            return value.intValue();\n+        } catch (NoSuchMethodException e) {\n+            // ignore - should never happen\n+        } catch (IllegalAccessException e) {\n+            // ignore - should never happen\n+        } catch (InvocationTargetException e) {\n+            // ignore - should never happen\n+        }\n+        throw new IllegalStateException(\"This should not happen\");\n+    }\n+\n+    /**\n+     * <p>Human readable description of this <code>Enum</code> item.</p>\n+     *\n+     * @return String in the form <code>type[name=value]</code>, for example:\n+     *  <code>JavaVersion[Java 1.0=100]</code>. Note that the package name is\n+     *  stripped from the type name.\n+     */\n+    public String toString() {\n+        if (iToString == null) {\n+            String shortName = ClassUtils.getShortClassName(getEnumClass());\n+            iToString = shortName + \"[\" + getName() + \"=\" + getValue() + \"]\";\n+        }\n+        return iToString;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ClassUtils;\n+import org.apache.commons.lang.NullArgumentException;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * <p>Provides utilities for manipulating and examining \n+ * <code>Throwable</code> objects.</p>\n+ *\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author Dmitri Plotnikov\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class ExceptionUtils {\n+    \n+    /**\n+     * <p>Used when printing stack frames to denote the start of a\n+     * wrapped exception.</p>\n+     *\n+     * <p>Package private for accessibility by test suite.</p>\n+     */\n+    static final String WRAPPED_MARKER = \" [wrapped] \";\n+\n+    /**\n+     * <p>The names of methods commonly used to access a wrapped exception.</p>\n+     */\n+    private static String[] CAUSE_METHOD_NAMES = {\n+        \"getCause\",\n+        \"getNextException\",\n+        \"getTargetException\",\n+        \"getException\",\n+        \"getSourceException\",\n+        \"getRootCause\",\n+        \"getCausedByException\",\n+        \"getNested\",\n+        \"getLinkedException\",\n+        \"getNestedException\",\n+        \"getLinkedCause\",\n+        \"getThrowable\",\n+    };\n+\n+    /**\n+     * <p>The Method object for Java 1.4 getCause.</p>\n+     */\n+    private static final Method THROWABLE_CAUSE_METHOD;\n+\n+    /**\n+     * <p>The Method object for Java 1.4 initCause.</p>\n+     */\n+    private static final Method THROWABLE_INITCAUSE_METHOD;\n+    \n+    static {\n+        Method causeMethod;\n+        try {\n+            causeMethod = Throwable.class.getMethod(\"getCause\", null);\n+        } catch (Exception e) {\n+            causeMethod = null;\n+        }\n+        THROWABLE_CAUSE_METHOD = causeMethod;\n+        try {\n+            causeMethod = Throwable.class.getMethod(\"initCause\", new Class[]{Throwable.class});\n+        } catch (Exception e) {\n+            causeMethod = null;\n+        }\n+        THROWABLE_INITCAUSE_METHOD = causeMethod;\n+    }\n+    \n+    /**\n+     * <p>\n+     * Public constructor allows an instance of <code>ExceptionUtils</code> to be created, although that is not\n+     * normally necessary.\n+     * </p>\n+     */\n+    public ExceptionUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Adds to the list of method names used in the search for <code>Throwable</code>\n+     * objects.</p>\n+     * \n+     * @param methodName  the methodName to add to the list, <code>null</code>\n+     *  and empty strings are ignored\n+     * @since 2.0\n+     */\n+    public static void addCauseMethodName(String methodName) {\n+        if (StringUtils.isNotEmpty(methodName) && !isCauseMethodName(methodName)) {            \n+            List list = getCauseMethodNameList();\n+            if (list.add(methodName)) {\n+                CAUSE_METHOD_NAMES = toArray(list);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Removes from the list of method names used in the search for <code>Throwable</code>\n+     * objects.</p>\n+     * \n+     * @param methodName  the methodName to remove from the list, <code>null</code>\n+     *  and empty strings are ignored\n+     * @since 2.1\n+     */\n+    public static void removeCauseMethodName(String methodName) {\n+        if (StringUtils.isNotEmpty(methodName)) {\n+            List list = getCauseMethodNameList();\n+            if (list.remove(methodName)) {\n+                CAUSE_METHOD_NAMES = toArray(list);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Sets the cause of a <code>Throwable</code> using introspection, allowing\n+     * source code compatibility between pre-1.4 and post-1.4 Java releases.</p>\n+     *\n+     * <p>The typical use of this method is inside a constructor as in\n+     * the following example:</p>\n+     *\n+     * <pre>\n+     * import org.apache.commons.lang.exception.ExceptionUtils;\n+     *  \n+     * public class MyException extends Exception {\n+     *  \n+     *    public MyException(String msg) {\n+     *       super(msg);\n+     *    }\n+     *\n+     *    public MyException(String msg, Throwable cause) {\n+     *       super(msg);\n+     *       ExceptionUtils.setCause(this, cause);\n+     *    }\n+     * }\n+     * </pre>\n+     *\n+     * @param target  the target <code>Throwable</code>\n+     * @param cause  the <code>Throwable</code> to set in the target\n+     * @return a <code>true</code> if the target has been modified\n+     * @since 2.2\n+     */\n+    public static boolean setCause(Throwable target, Throwable cause) {\n+        if (target == null) {\n+            throw new NullArgumentException(\"target\");\n+        }\n+        Object[] causeArgs = new Object[]{cause};\n+        boolean modifiedTarget = false;\n+        if (THROWABLE_INITCAUSE_METHOD != null) {\n+            try {\n+                THROWABLE_INITCAUSE_METHOD.invoke(target, causeArgs);\n+                modifiedTarget = true;\n+            } catch (IllegalAccessException ignored) {\n+                // Exception ignored.\n+            } catch (InvocationTargetException ignored) {\n+                // Exception ignored.\n+            }\n+        }\n+        try {\n+            Method setCauseMethod = target.getClass().getMethod(\"setCause\", new Class[]{Throwable.class});\n+            setCauseMethod.invoke(target, causeArgs);\n+            modifiedTarget = true;\n+        } catch (NoSuchMethodException ignored) {\n+            // Exception ignored.\n+        } catch (IllegalAccessException ignored) {\n+            // Exception ignored.\n+        } catch (InvocationTargetException ignored) {\n+            // Exception ignored.\n+        }\n+        return modifiedTarget;\n+    }\n+\n+    /**\n+     * Returns the given list as a <code>String[]</code>.\n+     * @param list a list to transform.\n+     * @return the given list as a <code>String[]</code>.\n+     */\n+    private static String[] toArray(List list) {\n+        return (String[]) list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * Returns {@link #CAUSE_METHOD_NAMES} as a List.\n+     *\n+     * @return {@link #CAUSE_METHOD_NAMES} as a List.\n+     */\n+    private static ArrayList getCauseMethodNameList() {\n+        return new ArrayList(Arrays.asList(CAUSE_METHOD_NAMES));\n+    }\n+\n+    /**\n+     * <p>Tests if the list of method names used in the search for <code>Throwable</code>\n+     * objects include the given name.</p>\n+     * \n+     * @param methodName  the methodName to search in the list.\n+     * @return if the list of method names used in the search for <code>Throwable</code>\n+     *  objects include the given name.\n+     * @since 2.1\n+     */\n+    public static boolean isCauseMethodName(String methodName) {\n+        return ArrayUtils.indexOf(CAUSE_METHOD_NAMES, methodName) >= 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the cause.</p>\n+     *\n+     * <p>The method searches for methods with specific names that return a \n+     * <code>Throwable</code> object. This will pick up most wrapping exceptions,\n+     * including those from JDK 1.4, and\n+     * {@link org.apache.commons.lang.exception.NestableException NestableException}.\n+     * The method names can be added to using {@link #addCauseMethodName(String)}.</p>\n+     *\n+     * <p>The default list searched for are:</p>\n+     * <ul>\n+     *  <li><code>getCause()</code></li>\n+     *  <li><code>getNextException()</code></li>\n+     *  <li><code>getTargetException()</code></li>\n+     *  <li><code>getException()</code></li>\n+     *  <li><code>getSourceException()</code></li>\n+     *  <li><code>getRootCause()</code></li>\n+     *  <li><code>getCausedByException()</code></li>\n+     *  <li><code>getNested()</code></li>\n+     * </ul>\n+     * \n+     * <p>In the absence of any such method, the object is inspected for a\n+     * <code>detail</code> field assignable to a <code>Throwable</code>.</p>\n+     *\n+     * <p>If none of the above is found, returns <code>null</code>.</p>\n+     *\n+     * @param throwable  the throwable to introspect for a cause, may be null\n+     * @return the cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     * @since 1.0\n+     */\n+    public static Throwable getCause(Throwable throwable) {\n+        return getCause(throwable, CAUSE_METHOD_NAMES);\n+    }\n+\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the cause.</p>\n+     *\n+     * <ol>\n+     * <li>Try known exception types.</li>\n+     * <li>Try the supplied array of method names.</li>\n+     * <li>Try the field 'detail'.</li>\n+     * </ol>\n+     *\n+     * <p>A <code>null</code> set of method names means use the default set.\n+     * A <code>null</code> in the set of method names will be ignored.</p>\n+     *\n+     * @param throwable  the throwable to introspect for a cause, may be null\n+     * @param methodNames  the method names, null treated as default set\n+     * @return the cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     * @since 1.0\n+     */\n+    public static Throwable getCause(Throwable throwable, String[] methodNames) {\n+        if (throwable == null) {\n+            return null;\n+        }\n+        Throwable cause = getCauseUsingWellKnownTypes(throwable);\n+        if (cause == null) {\n+            if (methodNames == null) {\n+                methodNames = CAUSE_METHOD_NAMES;\n+            }\n+            for (int i = 0; i < methodNames.length; i++) {\n+                String methodName = methodNames[i];\n+                if (methodName != null) {\n+                    cause = getCauseUsingMethodName(throwable, methodName);\n+                    if (cause != null) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (cause == null) {\n+                cause = getCauseUsingFieldName(throwable, \"detail\");\n+            }\n+        }\n+        return cause;\n+    }\n+\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the root cause.</p>\n+     *\n+     * <p>This method walks through the exception chain to the last element,\n+     * \"root\" of the tree, using {@link #getCause(Throwable)}, and\n+     * returns that exception.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. If the throwable parameter\n+     * has a cause of itself, then null will be returned. If the throwable\n+     * parameter cause chain loops, the last element in the chain before the\n+     * loop is returned.</p>\n+     *\n+     * @param throwable  the throwable to get the root cause for, may be null\n+     * @return the root cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     */\n+    public static Throwable getRootCause(Throwable throwable) {\n+        List list = getThrowableList(throwable);\n+        return (list.size() < 2 ? null : (Throwable)list.get(list.size() - 1));\n+    }\n+\n+    /**\n+     * <p>Finds a <code>Throwable</code> for known types.</p>\n+     * \n+     * <p>Uses <code>instanceof</code> checks to examine the exception,\n+     * looking for well known types which could contain chained or\n+     * wrapped exceptions.</p>\n+     *\n+     * @param throwable  the exception to examine\n+     * @return the wrapped exception, or <code>null</code> if not found\n+     */\n+    private static Throwable getCauseUsingWellKnownTypes(Throwable throwable) {\n+        if (throwable instanceof Nestable) {\n+            return ((Nestable) throwable).getCause();\n+        } else if (throwable instanceof SQLException) {\n+            return ((SQLException) throwable).getNextException();\n+        } else if (throwable instanceof InvocationTargetException) {\n+            return ((InvocationTargetException) throwable).getTargetException();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * <p>Finds a <code>Throwable</code> by method name.</p>\n+     *\n+     * @param throwable  the exception to examine\n+     * @param methodName  the name of the method to find and invoke\n+     * @return the wrapped exception, or <code>null</code> if not found\n+     */\n+    private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {\n+        Method method = null;\n+        try {\n+            method = throwable.getClass().getMethod(methodName, null);\n+        } catch (NoSuchMethodException ignored) {\n+            // exception ignored\n+        } catch (SecurityException ignored) {\n+            // exception ignored\n+        }\n+\n+        if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n+            try {\n+                return (Throwable) method.invoke(throwable, ArrayUtils.EMPTY_OBJECT_ARRAY);\n+            } catch (IllegalAccessException ignored) {\n+                // exception ignored\n+            } catch (IllegalArgumentException ignored) {\n+                // exception ignored\n+            } catch (InvocationTargetException ignored) {\n+                // exception ignored\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Finds a <code>Throwable</code> by field name.</p>\n+     *\n+     * @param throwable  the exception to examine\n+     * @param fieldName  the name of the attribute to examine\n+     * @return the wrapped exception, or <code>null</code> if not found\n+     */\n+    private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {\n+        Field field = null;\n+        try {\n+            field = throwable.getClass().getField(fieldName);\n+        } catch (NoSuchFieldException ignored) {\n+            // exception ignored\n+        } catch (SecurityException ignored) {\n+            // exception ignored\n+        }\n+\n+        if (field != null && Throwable.class.isAssignableFrom(field.getType())) {\n+            try {\n+                return (Throwable) field.get(throwable);\n+            } catch (IllegalAccessException ignored) {\n+                // exception ignored\n+            } catch (IllegalArgumentException ignored) {\n+                // exception ignored\n+            }\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the Throwable class has a <code>getCause</code> method.</p>\n+     *\n+     * <p>This is true for JDK 1.4 and above.</p>\n+     *\n+     * @return true if Throwable is nestable\n+     * @since 2.0\n+     */\n+    public static boolean isThrowableNested() {\n+        return THROWABLE_CAUSE_METHOD != null;\n+    }\n+    \n+    /**\n+     * <p>Checks whether this <code>Throwable</code> class can store a cause.</p>\n+     *\n+     * <p>This method does <b>not</b> check whether it actually does store a cause.<p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to examine, may be null\n+     * @return boolean <code>true</code> if nested otherwise <code>false</code>\n+     * @since 2.0\n+     */\n+    public static boolean isNestedThrowable(Throwable throwable) {\n+        if (throwable == null) {\n+            return false;\n+        }\n+\n+        if (throwable instanceof Nestable) {\n+            return true;\n+        } else if (throwable instanceof SQLException) {\n+            return true;\n+        } else if (throwable instanceof InvocationTargetException) {\n+            return true;\n+        } else if (isThrowableNested()) {\n+            return true;\n+        }\n+\n+        Class cls = throwable.getClass();\n+        for (int i = 0, isize = CAUSE_METHOD_NAMES.length; i < isize; i++) {\n+            try {\n+                Method method = cls.getMethod(CAUSE_METHOD_NAMES[i], null);\n+                if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n+                    return true;\n+                }\n+            } catch (NoSuchMethodException ignored) {\n+                // exception ignored\n+            } catch (SecurityException ignored) {\n+                // exception ignored\n+            }\n+        }\n+\n+        try {\n+            Field field = cls.getField(\"detail\");\n+            if (field != null) {\n+                return true;\n+            }\n+        } catch (NoSuchFieldException ignored) {\n+            // exception ignored\n+        } catch (SecurityException ignored) {\n+            // exception ignored\n+        }\n+\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Counts the number of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return <code>1</code>.\n+     * A throwable with one cause will return <code>2</code> and so on.\n+     * A <code>null</code> throwable will return <code>0</code>.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. The cause chain is\n+     * processed until the end is reached, or until the next item in the\n+     * chain is already in the result set.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the count of throwables, zero if null input\n+     */\n+    public static int getThrowableCount(Throwable throwable) {\n+        return getThrowableList(throwable).size();\n+    }\n+\n+    /**\n+     * <p>Returns the list of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return an array containing\n+     * one element - the input throwable.\n+     * A throwable with one cause will return an array containing\n+     * two elements. - the input throwable and the cause throwable.\n+     * A <code>null</code> throwable will return an array of size zero.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. The cause chain is\n+     * processed until the end is reached, or until the next item in the\n+     * chain is already in the result set.</p>\n+     *\n+     * @see #getThrowableList(Throwable)\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the array of throwables, never null\n+     */\n+    public static Throwable[] getThrowables(Throwable throwable) {\n+        List list = getThrowableList(throwable);\n+        return (Throwable[]) list.toArray(new Throwable[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Returns the list of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return a list containing\n+     * one element - the input throwable.\n+     * A throwable with one cause will return a list containing\n+     * two elements. - the input throwable and the cause throwable.\n+     * A <code>null</code> throwable will return a list of size zero.</p>\n+     *\n+     * <p>This method handles recursive cause structures that might\n+     * otherwise cause infinite loops. The cause chain is processed until\n+     * the end is reached, or until the next item in the chain is already\n+     * in the result set.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the list of throwables, never null\n+     * @since Commons Lang 2.2\n+     */\n+    public static List getThrowableList(Throwable throwable) {\n+        List list = new ArrayList();\n+        while (throwable != null && list.contains(throwable) == false) {\n+            list.add(throwable);\n+            throwable = ExceptionUtils.getCause(throwable);\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified class (exactly) in the exception chain.\n+     * Subclasses of the specified class do not match - see\n+     * {@link #indexOfType(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param clazz  the class to search for, subclasses do not match, null returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     */\n+    public static int indexOfThrowable(Throwable throwable, Class clazz) {\n+        return indexOf(throwable, clazz, 0, false);\n+    }\n+\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified type in the exception chain from\n+     * a specified index.\n+     * Subclasses of the specified class do not match - see\n+     * {@link #indexOfType(Throwable, Class, int)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.\n+     * A negative start index is treated as zero.\n+     * A start index greater than the number of throwables returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param clazz  the class to search for, subclasses do not match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     */\n+    public static int indexOfThrowable(Throwable throwable, Class clazz, int fromIndex) {\n+        return indexOf(throwable, clazz, fromIndex, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified class or subclass in the exception chain.\n+     * Subclasses of the specified class do match - see\n+     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     * @since 2.1\n+     */\n+    public static int indexOfType(Throwable throwable, Class type) {\n+        return indexOf(throwable, type, 0, true);\n+    }\n+\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified type in the exception chain from\n+     * a specified index.\n+     * Subclasses of the specified class do match - see\n+     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.\n+     * A negative start index is treated as zero.\n+     * A start index greater than the number of throwables returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     * @since 2.1\n+     */\n+    public static int indexOfType(Throwable throwable, Class type, int fromIndex) {\n+        return indexOf(throwable, type, fromIndex, true);\n+    }\n+\n+    /**\n+     * <p>Worker method for the <code>indexOfType</code> methods.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @param subclass if <code>true</code>, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares\n+     * using references\n+     * @return index of the <code>type</code> within throwables nested withing the specified <code>throwable</code>\n+     */\n+    private static int indexOf(Throwable throwable, Class type, int fromIndex, boolean subclass) {\n+        if (throwable == null || type == null) {\n+            return -1;\n+        }\n+        if (fromIndex < 0) {\n+            fromIndex = 0;\n+        }\n+        Throwable[] throwables = ExceptionUtils.getThrowables(throwable);\n+        if (fromIndex >= throwables.length) {\n+            return -1;\n+        }\n+        if (subclass) {\n+            for (int i = fromIndex; i < throwables.length; i++) {\n+                if (type.isAssignableFrom(throwables[i].getClass())) {\n+                    return i;\n+                }\n+            }\n+        } else {\n+            for (int i = fromIndex; i < throwables.length; i++) {\n+                if (type.equals(throwables[i].getClass())) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable\n+     * to <code>System.err</code>.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable) {\n+        printRootCauseStackTrace(throwable, System.err);\n+    }\n+\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output, may be null\n+     * @param stream  the stream to output to, may not be null\n+     * @throws IllegalArgumentException if the stream is <code>null</code>\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable, PrintStream stream) {\n+        if (throwable == null) {\n+            return;\n+        }\n+        if (stream == null) {\n+            throw new IllegalArgumentException(\"The PrintStream must not be null\");\n+        }\n+        String trace[] = getRootCauseStackTrace(throwable);\n+        for (int i = 0; i < trace.length; i++) {\n+            stream.println(trace[i]);\n+        }\n+        stream.flush();\n+    }\n+\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output, may be null\n+     * @param writer  the writer to output to, may not be null\n+     * @throws IllegalArgumentException if the writer is <code>null</code>\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable, PrintWriter writer) {\n+        if (throwable == null) {\n+            return;\n+        }\n+        if (writer == null) {\n+            throw new IllegalArgumentException(\"The PrintWriter must not be null\");\n+        }\n+        String trace[] = getRootCauseStackTrace(throwable);\n+        for (int i = 0; i < trace.length; i++) {\n+            writer.println(trace[i]);\n+        }\n+        writer.flush();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Creates a compact stack trace for the root cause of the supplied\n+     * <code>Throwable</code>.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * It consists of the root exception followed by each of its wrapping\n+     * exceptions separated by '[wrapped]'. Note that this is the opposite\n+     * order to the JDK1.4 display.</p>\n+     *\n+     * @param throwable  the throwable to examine, may be null\n+     * @return an array of stack trace frames, never null\n+     * @since 2.0\n+     */\n+    public static String[] getRootCauseStackTrace(Throwable throwable) {\n+        if (throwable == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        Throwable throwables[] = getThrowables(throwable);\n+        int count = throwables.length;\n+        ArrayList frames = new ArrayList();\n+        List nextTrace = getStackFrameList(throwables[count - 1]);\n+        for (int i = count; --i >= 0;) {\n+            List trace = nextTrace;\n+            if (i != 0) {\n+                nextTrace = getStackFrameList(throwables[i - 1]);\n+                removeCommonFrames(trace, nextTrace);\n+            }\n+            if (i == count - 1) {\n+                frames.add(throwables[i].toString());\n+            } else {\n+                frames.add(WRAPPED_MARKER + throwables[i].toString());\n+            }\n+            for (int j = 0; j < trace.size(); j++) {\n+                frames.add(trace.get(j));\n+            }\n+        }\n+        return (String[]) frames.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * <p>Removes common frames from the cause trace given the two stack traces.</p>\n+     *\n+     * @param causeFrames  stack trace of a cause throwable\n+     * @param wrapperFrames  stack trace of a wrapper throwable\n+     * @throws IllegalArgumentException if either argument is null\n+     * @since 2.0\n+     */\n+    public static void removeCommonFrames(List causeFrames, List wrapperFrames) {\n+        if (causeFrames == null || wrapperFrames == null) {\n+            throw new IllegalArgumentException(\"The List must not be null\");\n+        }\n+        int causeFrameIndex = causeFrames.size() - 1;\n+        int wrapperFrameIndex = wrapperFrames.size() - 1;\n+        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n+            // Remove the frame from the cause trace if it is the same\n+            // as in the wrapper trace\n+            String causeFrame = (String) causeFrames.get(causeFrameIndex);\n+            String wrapperFrame = (String) wrapperFrames.get(wrapperFrameIndex);\n+            if (causeFrame.equals(wrapperFrame)) {\n+                causeFrames.remove(causeFrameIndex);\n+            }\n+            causeFrameIndex--;\n+            wrapperFrameIndex--;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>A way to get the entire nested stack-trace of an throwable.</p>\n+     *\n+     * <p>The result of this method is highly dependent on the JDK version\n+     * and whether the exceptions override printStackTrace or not.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to be examined\n+     * @return the nested stack trace, with the root cause first\n+     * @since 2.0\n+     */\n+    public static String getFullStackTrace(Throwable throwable) {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw, true);\n+        Throwable[] ts = getThrowables(throwable);\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i].printStackTrace(pw);\n+            if (isNestedThrowable(ts[i])) {\n+                break;\n+            }\n+        }\n+        return sw.getBuffer().toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the stack trace from a Throwable as a String.</p>\n+     *\n+     * <p>The result of this method vary by JDK version as this method\n+     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n+     * On JDK1.3 and earlier, the cause exception will not be shown\n+     * unless the specified throwable alters printStackTrace.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to be examined\n+     * @return the stack trace as generated by the exception's\n+     *  <code>printStackTrace(PrintWriter)</code> method\n+     */\n+    public static String getStackTrace(Throwable throwable) {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw, true);\n+        throwable.printStackTrace(pw);\n+        return sw.getBuffer().toString();\n+    }\n+\n+    /**\n+     * <p>Captures the stack trace associated with the specified\n+     * <code>Throwable</code> object, decomposing it into a list of\n+     * stack frames.</p>\n+     *\n+     * <p>The result of this method vary by JDK version as this method\n+     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n+     * On JDK1.3 and earlier, the cause exception will not be shown\n+     * unless the specified throwable alters printStackTrace.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to examine, may be null\n+     * @return an array of strings describing each stack frame, never null\n+     */\n+    public static String[] getStackFrames(Throwable throwable) {\n+        if (throwable == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return getStackFrames(getStackTrace(throwable));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns an array where each element is a line from the argument.</p>\n+     *\n+     * <p>The end of line is determined by the value of {@link SystemUtils#LINE_SEPARATOR}.</p>\n+     *\n+     * <p>Functionality shared between the\n+     * <code>getStackFrames(Throwable)</code> methods of this and the\n+     * {@link org.apache.commons.lang.exception.NestableDelegate} classes.</p>\n+     *\n+     * @param stackTrace  a stack trace String\n+     * @return an array where each element is a line from the argument\n+     */\n+    static String[] getStackFrames(String stackTrace) {\n+        String linebreak = SystemUtils.LINE_SEPARATOR;\n+        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        List list = new ArrayList();\n+        while (frames.hasMoreTokens()) {\n+            list.add(frames.nextToken());\n+        }\n+        return toArray(list);\n+    }\n+\n+    /**\n+     * <p>Produces a <code>List</code> of stack frames - the message\n+     * is not included. Only the trace of the specified exception is\n+     * returned, any caused by trace is stripped.</p>\n+     *\n+     * <p>This works in most cases - it will only fail if the exception\n+     * message contains a line that starts with:\n+     * <code>&quot;&nbsp;&nbsp;&nbsp;at&quot;.</code></p>\n+     * \n+     * @param t is any throwable\n+     * @return List of stack frames\n+     */\n+    static List getStackFrameList(Throwable t) {\n+        String stackTrace = getStackTrace(t);\n+        String linebreak = SystemUtils.LINE_SEPARATOR;\n+        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        List list = new ArrayList();\n+        boolean traceStarted = false;\n+        while (frames.hasMoreTokens()) {\n+            String token = frames.nextToken();\n+            // Determine if the line starts with <whitespace>at\n+            int at = token.indexOf(\"at\");\n+            if (at != -1 && token.substring(0, at).trim().length() == 0) {\n+                traceStarted = true;\n+                list.add(token);\n+            } else if (traceStarted) {\n+                break;\n+            }\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a short message summarising the exception.\n+     * <p>\n+     * The message returned is of the form\n+     * {ClassNameWithoutPackage}: {ThrowableMessage}\n+     *\n+     * @param th  the throwable to get a message for, null returns empty string\n+     * @return the message, non-null\n+     * @since Commons Lang 2.2\n+     */\n+    public static String getMessage(Throwable th) {\n+        if (th == null) {\n+            return \"\";\n+        }\n+        String clsName = ClassUtils.getShortClassName(th, null);\n+        String msg = th.getMessage();\n+        return clsName + \": \" + StringUtils.defaultString(msg);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a short message summarising the root cause exception.\n+     * <p>\n+     * The message returned is of the form\n+     * {ClassNameWithoutPackage}: {ThrowableMessage}\n+     *\n+     * @param th  the throwable to get a message for, null returns empty string\n+     * @return the message, non-null\n+     * @since Commons Lang 2.2\n+     */\n+    public static String getRootCauseMessage(Throwable th) {\n+        Throwable root = ExceptionUtils.getRootCause(th);\n+        root = (root == null ? th : root);\n+        return getMessage(root);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/exception/Nestable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+/**\n+ * An interface to be implemented by {@link java.lang.Throwable}\n+ * extensions which would like to be able to nest root exceptions\n+ * inside themselves.\n+ *\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public interface Nestable {\n+    \n+    /**\n+     * Returns the reference to the exception or error that caused the\n+     * exception implementing the <code>Nestable</code> to be thrown.\n+     *\n+     * @return throwable that caused the original exception\n+     */\n+    public Throwable getCause();\n+\n+    /**\n+     * Returns the error message of this and any nested\n+     * <code>Throwable</code>.\n+     *\n+     * @return the error message\n+     */\n+    public String getMessage();\n+\n+    /**\n+     * Returns the error message of the <code>Throwable</code> in the chain\n+     * of <code>Throwable</code>s at the specified index, numbered from 0.\n+     *\n+     * @param index the index of the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s\n+     * @return the error message, or null if the <code>Throwable</code> at the\n+     * specified index in the chain does not contain a message\n+     * @throws IndexOutOfBoundsException if the <code>index</code> argument is\n+     * negative or not less than the count of <code>Throwable</code>s in the\n+     * chain\n+     */\n+    public String getMessage(int index);\n+\n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s\n+     * in an array of Strings, one element for each message. Any\n+     * <code>Throwable</code> not containing a message is represented in the\n+     * array by a null. This has the effect of cause the length of the returned\n+     * array to be equal to the result of the {@link #getThrowableCount()}\n+     * operation.\n+     *\n+     * @return the error messages\n+     */\n+    public String[] getMessages();\n+\n+    /**\n+     * Returns the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s at the specified index, numbered from 0.\n+     *\n+     * @param index the index, numbered from 0, of the <code>Throwable</code> in\n+     * the chain of <code>Throwable</code>s\n+     * @return the <code>Throwable</code>\n+     * @throws IndexOutOfBoundsException if the <code>index</code> argument is\n+     * negative or not less than the count of <code>Throwable</code>s in the\n+     * chain\n+     */\n+    public Throwable getThrowable(int index);\n+\n+    /**\n+     * Returns the number of nested <code>Throwable</code>s represented by\n+     * this <code>Nestable</code>, including this <code>Nestable</code>.\n+     *\n+     * @return the throwable count\n+     */\n+    public int getThrowableCount();\n+\n+    /**\n+     * Returns this <code>Nestable</code> and any nested <code>Throwable</code>s\n+     * in an array of <code>Throwable</code>s, one element for each\n+     * <code>Throwable</code>.\n+     *\n+     * @return the <code>Throwable</code>s\n+     */\n+    public Throwable[] getThrowables();\n+\n+    /**\n+     * Returns the index, numbered from 0, of the first occurrence of the\n+     * specified type, or a subclass, in the chain of <code>Throwable</code>s.\n+     * The method returns -1 if the specified type is not found in the chain.\n+     * <p>\n+     * NOTE: From v2.1, we have clarified the <code>Nestable</code> interface\n+     * such that this method matches subclasses.\n+     * If you want to NOT match subclasses, please use\n+     * {@link ExceptionUtils#indexOfThrowable(Throwable, Class)}\n+     * (which is avaiable in all versions of lang).\n+     *\n+     * @param type  the type to find, subclasses match, null returns -1\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     */\n+    public int indexOfThrowable(Class type);\n+\n+    /**\n+     * Returns the index, numbered from 0, of the first <code>Throwable</code>\n+     * that matches the specified type, or a subclass, in the chain of <code>Throwable</code>s\n+     * with an index greater than or equal to the specified index.\n+     * The method returns -1 if the specified type is not found in the chain.\n+     * <p>\n+     * NOTE: From v2.1, we have clarified the <code>Nestable</code> interface\n+     * such that this method matches subclasses.\n+     * If you want to NOT match subclasses, please use\n+     * {@link ExceptionUtils#indexOfThrowable(Throwable, Class, int)}\n+     * (which is avaiable in all versions of lang).\n+     *\n+     * @param type  the type to find, subclasses match, null returns -1\n+     * @param fromIndex the index, numbered from 0, of the starting position in\n+     * the chain to be searched\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     * @throws IndexOutOfBoundsException if the <code>fromIndex</code> argument\n+     * is negative or not less than the count of <code>Throwable</code>s in the\n+     * chain\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex);\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified print\n+     * writer.  Includes information from the exception, if any,\n+     * which caused this exception.\n+     *\n+     * @param out <code>PrintWriter</code> to use for output.\n+     */\n+    public void printStackTrace(PrintWriter out);\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified print\n+     * stream.  Includes information from the exception, if any,\n+     * which caused this exception.\n+     *\n+     * @param out <code>PrintStream</code> to use for output.\n+     */\n+    public void printStackTrace(PrintStream out);\n+\n+    /**\n+     * Prints the stack trace for this exception only--root cause not\n+     * included--using the provided writer.  Used by\n+     * {@link org.apache.commons.lang.exception.NestableDelegate} to write\n+     * individual stack traces to a buffer.  The implementation of\n+     * this method should call\n+     * <code>super.printStackTrace(out);</code> in most cases.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out);\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/exception/NestableDelegate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>A shared implementation of the nestable exception functionality.</p>\n+ * <p>\n+ * The code is shared between \n+ * {@link org.apache.commons.lang.exception.NestableError NestableError},\n+ * {@link org.apache.commons.lang.exception.NestableException NestableException} and\n+ * {@link org.apache.commons.lang.exception.NestableRuntimeException NestableRuntimeException}.\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:Rafal.Krzewski@e-point.pl\">Rafal Krzewski</a>\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author Sean C. Sullivan\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class NestableDelegate implements Serializable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Constructor error message.\n+     */\n+    private transient static final String MUST_BE_THROWABLE =\n+        \"The Nestable implementation passed to the NestableDelegate(Nestable) \"\n+            + \"constructor must extend java.lang.Throwable\";\n+\n+    /**\n+     * Holds the reference to the exception or error that we're\n+     * wrapping (which must be a {@link\n+     * org.apache.commons.lang.exception.Nestable} implementation).\n+     */\n+    private Throwable nestable = null;\n+    \n+    /**\n+     * Whether to print the stack trace top-down.\n+     * This public flag may be set by calling code, typically in initialisation.\n+     * This exists for backwards compatability, setting it to false will return\n+     * the library to v1.0 behaviour (but will affect all users of the library\n+     * in the classloader).\n+     * @since 2.0\n+     */\n+    public static boolean topDown = true;\n+    \n+    /**\n+     * Whether to trim the repeated stack trace.\n+     * This public flag may be set by calling code, typically in initialisation.\n+     * This exists for backwards compatability, setting it to false will return\n+     * the library to v1.0 behaviour (but will affect all users of the library\n+     * in the classloader).\n+     * @since 2.0\n+     */\n+    public static boolean trimStackFrames = true;\n+    \n+    /**\n+     * Whether to match subclasses via indexOf.\n+     * This public flag may be set by calling code, typically in initialisation.\n+     * This exists for backwards compatability, setting it to false will return\n+     * the library to v2.0 behaviour (but will affect all users of the library\n+     * in the classloader).\n+     * @since 2.1\n+     */\n+    public static boolean matchSubclasses = true;\n+\n+    /**\n+     * Constructs a new <code>NestableDelegate</code> instance to manage the\n+     * specified <code>Nestable</code>.\n+     *\n+     * @param nestable the Nestable implementation (<i>must</i> extend\n+     * {@link java.lang.Throwable})\n+     * @since 2.0\n+     */\n+    public NestableDelegate(Nestable nestable) {\n+        if (nestable instanceof Throwable) {\n+            this.nestable = (Throwable) nestable;\n+        } else {\n+            throw new IllegalArgumentException(MUST_BE_THROWABLE);\n+        }\n+    }\n+\n+    /**\n+     * Returns the error message of the <code>Throwable</code> in the chain of <code>Throwable</code>s at the\n+     * specified index, numbered from 0.\n+     * \n+     * @param index\n+     *            the index of the <code>Throwable</code> in the chain of <code>Throwable</code>s\n+     * @return the error message, or null if the <code>Throwable</code> at the specified index in the chain does not\n+     *         contain a message\n+     * @throws IndexOutOfBoundsException\n+     *             if the <code>index</code> argument is negative or not less than the count of <code>Throwable</code>s\n+     *             in the chain\n+     * @since 2.0\n+     */\n+    public String getMessage(int index) {\n+        Throwable t = this.getThrowable(index);\n+        if (Nestable.class.isInstance(t)) {\n+            return ((Nestable) t).getMessage(0);\n+        }\n+        return t.getMessage();\n+    }\n+\n+    /**\n+     * Returns the full message contained by the <code>Nestable</code> and any nested <code>Throwable</code>s.\n+     * \n+     * @param baseMsg\n+     *            the base message to use when creating the full message. Should be generally be called via\n+     *            <code>nestableHelper.getMessage(super.getMessage())</code>, where <code>super</code> is an\n+     *            instance of {@link java.lang.Throwable}.\n+     * @return The concatenated message for this and all nested <code>Throwable</code>s\n+     * @since 2.0\n+     */\n+    public String getMessage(String baseMsg) {\n+        Throwable nestedCause = ExceptionUtils.getCause(this.nestable);\n+        String causeMsg = nestedCause == null ? null : nestedCause.getMessage();\n+        if (nestedCause == null || causeMsg == null) {\n+            return baseMsg; // may be null, which is a valid result\n+        }\n+        if (baseMsg == null) {\n+            return causeMsg;\n+        }\n+        return baseMsg + \": \" + causeMsg;\n+    }\n+\n+    /**\n+     * Returns the error message of this and any nested <code>Throwable</code>s in an array of Strings, one element\n+     * for each message. Any <code>Throwable</code> not containing a message is represented in the array by a null.\n+     * This has the effect of cause the length of the returned array to be equal to the result of the\n+     * {@link #getThrowableCount()} operation.\n+     * \n+     * @return the error messages\n+     * @since 2.0\n+     */\n+    public String[] getMessages() {\n+        Throwable[] throwables = this.getThrowables();\n+        String[] msgs = new String[throwables.length];\n+        for (int i = 0; i < throwables.length; i++) {\n+            msgs[i] =\n+                (Nestable.class.isInstance(throwables[i])\n+                    ? ((Nestable) throwables[i]).getMessage(0)\n+                    : throwables[i].getMessage());\n+        }\n+        return msgs;\n+    }\n+\n+    /**\n+     * Returns the <code>Throwable</code> in the chain of\n+     * <code>Throwable</code>s at the specified index, numbered from 0.\n+     *\n+     * @param index the index, numbered from 0, of the <code>Throwable</code> in\n+     * the chain of <code>Throwable</code>s\n+     * @return the <code>Throwable</code>\n+     * @throws IndexOutOfBoundsException if the <code>index</code> argument is\n+     * negative or not less than the count of <code>Throwable</code>s in the\n+     * chain\n+     * @since 2.0\n+     */\n+    public Throwable getThrowable(int index) {\n+        if (index == 0) {\n+            return this.nestable;\n+        }\n+        Throwable[] throwables = this.getThrowables();\n+        return throwables[index];\n+    }\n+\n+    /**\n+     * Returns the number of <code>Throwable</code>s contained in the\n+     * <code>Nestable</code> contained by this delegate.\n+     *\n+     * @return the throwable count\n+     * @since 2.0\n+     */\n+    public int getThrowableCount() {\n+        return ExceptionUtils.getThrowableCount(this.nestable);\n+    }\n+\n+    /**\n+     * Returns this delegate's <code>Nestable</code> and any nested\n+     * <code>Throwable</code>s in an array of <code>Throwable</code>s, one\n+     * element for each <code>Throwable</code>.\n+     *\n+     * @return the <code>Throwable</code>s\n+     * @since 2.0\n+     */\n+    public Throwable[] getThrowables() {\n+        return ExceptionUtils.getThrowables(this.nestable);\n+    }\n+\n+    /**\n+     * Returns the index, numbered from 0, of the first <code>Throwable</code>\n+     * that matches the specified type, or a subclass, in the chain of <code>Throwable</code>s\n+     * with an index greater than or equal to the specified index.\n+     * The method returns -1 if the specified type is not found in the chain.\n+     * <p>\n+     * NOTE: From v2.1, we have clarified the <code>Nestable</code> interface\n+     * such that this method matches subclasses.\n+     * If you want to NOT match subclasses, please use\n+     * {@link ExceptionUtils#indexOfThrowable(Throwable, Class, int)}\n+     * (which is avaiable in all versions of lang).\n+     * An alternative is to use the public static flag {@link #matchSubclasses}\n+     * on <code>NestableDelegate</code>, however this is not recommended.\n+     *\n+     * @param type  the type to find, subclasses match, null returns -1\n+     * @param fromIndex the index, numbered from 0, of the starting position in\n+     * the chain to be searched\n+     * @return index of the first occurrence of the type in the chain, or -1 if\n+     * the type is not found\n+     * @throws IndexOutOfBoundsException if the <code>fromIndex</code> argument\n+     * is negative or not less than the count of <code>Throwable</code>s in the\n+     * chain\n+     * @since 2.0\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex) {\n+        if (type == null) {\n+            return -1;\n+        }\n+        if (fromIndex < 0) {\n+            throw new IndexOutOfBoundsException(\"The start index was out of bounds: \" + fromIndex);\n+        }\n+        Throwable[] throwables = ExceptionUtils.getThrowables(this.nestable);\n+        if (fromIndex >= throwables.length) {\n+            throw new IndexOutOfBoundsException(\"The start index was out of bounds: \"\n+                + fromIndex + \" >= \" + throwables.length);\n+        }\n+        if (matchSubclasses) {\n+            for (int i = fromIndex; i < throwables.length; i++) {\n+                if (type.isAssignableFrom(throwables[i].getClass())) {\n+                    return i;\n+                }\n+            }\n+        } else {\n+            for (int i = fromIndex; i < throwables.length; i++) {\n+                if (type.equals(throwables[i].getClass())) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception the the standar error\n+     * stream.\n+     */\n+    public void printStackTrace() {\n+        printStackTrace(System.err);\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified\n+     * stream.\n+     *\n+     * @param out <code>PrintStream</code> to use for output.\n+     * @see #printStackTrace(PrintWriter)\n+     */\n+    public void printStackTrace(PrintStream out) {\n+        synchronized (out) {\n+            PrintWriter pw = new PrintWriter(out, false);\n+            printStackTrace(pw);\n+            // Flush the PrintWriter before it's GC'ed.\n+            pw.flush();\n+        }\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified\n+     * writer. If the Throwable class has a <code>getCause</code>\n+     * method (i.e. running on jre1.4 or higher), this method just \n+     * uses Throwable's printStackTrace() method. Otherwise, generates\n+     * the stack-trace, by taking into account the 'topDown' and \n+     * 'trimStackFrames' parameters. The topDown and trimStackFrames \n+     * are set to 'true' by default (produces jre1.4-like stack trace).\n+     *\n+     * @param out <code>PrintWriter</code> to use for output.\n+     */\n+    public void printStackTrace(PrintWriter out) {\n+        Throwable throwable = this.nestable;\n+        // if running on jre1.4 or higher, use default printStackTrace\n+        if (ExceptionUtils.isThrowableNested()) {\n+            if (throwable instanceof Nestable) {\n+                ((Nestable)throwable).printPartialStackTrace(out);\n+            } else {\n+                throwable.printStackTrace(out);\n+            }\n+            return;\n+        }\n+\n+        // generating the nested stack trace\n+        List stacks = new ArrayList();\n+        while (throwable != null) {\n+            String[] st = getStackFrames(throwable);\n+            stacks.add(st);\n+            throwable = ExceptionUtils.getCause(throwable);\n+        }\n+\n+        // If NOT topDown, reverse the stack\n+        String separatorLine = \"Caused by: \";\n+        if (!topDown) {\n+            separatorLine = \"Rethrown as: \";\n+            Collections.reverse(stacks);\n+        }\n+\n+        // Remove the repeated lines in the stack\n+        if (trimStackFrames) {\n+          trimStackFrames(stacks);\n+        }\n+\n+        synchronized (out) {\n+            for (Iterator iter=stacks.iterator(); iter.hasNext();) {\n+                String[] st = (String[]) iter.next();\n+                for (int i=0, len=st.length; i < len; i++) {\n+                    out.println(st[i]);\n+                }\n+                if (iter.hasNext()) {\n+                    out.print(separatorLine);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Captures the stack trace associated with the specified\n+     * <code>Throwable</code> object, decomposing it into a list of\n+     * stack frames.\n+     *\n+     * @param t The <code>Throwable</code>.\n+     * @return  An array of strings describing each stack frame.\n+     * @since 2.0\n+     */\n+    protected String[] getStackFrames(Throwable t) {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw, true);\n+\n+        // Avoid infinite loop between decompose() and printStackTrace().\n+        if (t instanceof Nestable) {\n+            ((Nestable) t).printPartialStackTrace(pw);\n+        } else {\n+            t.printStackTrace(pw);\n+        }\n+        return ExceptionUtils.getStackFrames(sw.getBuffer().toString());\n+    }\n+    \n+    /**\n+     * Trims the stack frames. The first set is left untouched. The rest\n+     * of the frames are truncated from the bottom by comparing with\n+     * one just on top.\n+     *\n+     * @param stacks The list containing String[] elements\n+     * @since 2.0\n+     */\n+    protected void trimStackFrames(List stacks) {\n+         for (int size=stacks.size(), i=size-1; i > 0; i--) {\n+             String[] curr = (String[]) stacks.get(i);\n+             String[] next = (String[]) stacks.get(i-1); \n+             \n+             List currList = new ArrayList(Arrays.asList(curr));\n+             List nextList = new ArrayList(Arrays.asList(next));\n+             ExceptionUtils.removeCommonFrames(currList, nextList);\n+\n+             int trimmed = curr.length - currList.size();\n+             if (trimmed > 0) {\n+                 currList.add(\"\\t... \"+trimmed+\" more\");\n+                 stacks.set(\n+                     i, \n+                     currList.toArray(new String[currList.size()])\n+                 );\n+             }\n+         }\n+     }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/exception/NestableError.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+/**\n+ * The base class of all errors which can contain other exceptions.\n+ *\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @see org.apache.commons.lang.exception.NestableException\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class NestableError extends Error implements Nestable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The helper instance which contains much of the code which we\n+     * delegate to.\n+     */\n+    protected NestableDelegate delegate = new NestableDelegate(this);\n+\n+    /**\n+     * Holds the reference to the exception or error that caused\n+     * this exception to be thrown.\n+     */\n+    private Throwable cause = null;\n+\n+    /**\n+     * Constructs a new <code>NestableError</code> without specified\n+     * detail message.\n+     */\n+    public NestableError() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableError</code> with specified\n+     * detail message.\n+     *\n+     * @param msg The error message.\n+     */\n+    public NestableError(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableError</code> with specified\n+     * nested <code>Throwable</code>.\n+     *\n+     * @param cause the exception or error that caused this exception to be\n+     * thrown\n+     */\n+    public NestableError(Throwable cause) {\n+        super();\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableError</code> with specified\n+     * detail message and nested <code>Throwable</code>.\n+     *\n+     * @param msg    the error message\n+     * @param cause  the exception or error that caused this exception to be\n+     * thrown\n+     */\n+    public NestableError(String msg, Throwable cause) {\n+        super(msg);\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable getCause() {\n+        return cause;\n+    }\n+\n+    /**\n+     * Returns the detail message string of this throwable. If it was\n+     * created with a null message, returns the following:\n+     * (cause==null ? null : cause.toString()).\n+     *\n+     * @return String message string of the throwable\n+     */\n+    public String getMessage() {\n+        if (super.getMessage() != null) {\n+            return super.getMessage();\n+        } else if (cause != null) {\n+            return cause.toString();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String getMessage(int index) {\n+        if (index == 0) {\n+            return super.getMessage();\n+        } else {\n+            return delegate.getMessage(index);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String[] getMessages() {\n+        return delegate.getMessages();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable getThrowable(int index) {\n+        return delegate.getThrowable(index);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int getThrowableCount() {\n+        return delegate.getThrowableCount();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable[] getThrowables() {\n+        return delegate.getThrowables();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOfThrowable(Class type) {\n+        return delegate.indexOfThrowable(type, 0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex) {\n+        return delegate.indexOfThrowable(type, fromIndex);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace() {\n+        delegate.printStackTrace();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace(PrintStream out) {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace(PrintWriter out) {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public final void printPartialStackTrace(PrintWriter out) {\n+        super.printStackTrace(out);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/exception/NestableException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+/**\n+ * The base class of all exceptions which can contain other exceptions.\n+ *\n+ * It is intended to ease the debugging by carrying on the information\n+ * about the exception which was caught and provoked throwing the\n+ * current exception. Catching and rethrowing may occur multiple\n+ * times, and provided that all exceptions except the first one\n+ * are descendants of <code>NestedException</code>, when the\n+ * exception is finally printed out using any of the <code>\n+ * printStackTrace()</code> methods, the stack trace will contain\n+ * the information about all exceptions thrown and caught on\n+ * the way.\n+ * <p> Running the following program\n+ * <p><blockquote><pre>\n+ *  1 import org.apache.commons.lang.exception.NestableException;\n+ *  2\n+ *  3 public class Test {\n+ *  4     public static void main( String[] args ) {\n+ *  5         try {\n+ *  6             a();\n+ *  7         } catch(Exception e) {\n+ *  8             e.printStackTrace();\n+ *  9         }\n+ * 10      }\n+ * 11\n+ * 12      public static void a() throws Exception {\n+ * 13          try {\n+ * 14              b();\n+ * 15          } catch(Exception e) {\n+ * 16              throw new NestableException(\"foo\", e);\n+ * 17          }\n+ * 18      }\n+ * 19\n+ * 20      public static void b() throws Exception {\n+ * 21          try {\n+ * 22              c();\n+ * 23          } catch(Exception e) {\n+ * 24              throw new NestableException(\"bar\", e);\n+ * 25          }\n+ * 26      }\n+ * 27\n+ * 28      public static void c() throws Exception {\n+ * 29          throw new Exception(\"baz\");\n+ * 30      }\n+ * 31 }\n+ * </pre></blockquote>\n+ * <p>Yields the following stack trace:\n+ * <p><blockquote><pre>\n+ * org.apache.commons.lang.exception.NestableException: foo\n+ *         at Test.a(Test.java:16)\n+ *         at Test.main(Test.java:6)\n+ * Caused by: org.apache.commons.lang.exception.NestableException: bar\n+ *         at Test.b(Test.java:24)\n+ *         at Test.a(Test.java:14)\n+ *         ... 1 more\n+ * Caused by: java.lang.Exception: baz\n+ *         at Test.c(Test.java:29)\n+ *         at Test.b(Test.java:22)\n+ *         ... 2 more\n+ * </pre></blockquote><br>\n+ *\n+ * @author <a href=\"mailto:Rafal.Krzewski@e-point.pl\">Rafal Krzewski</a>\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class NestableException extends Exception implements Nestable {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The helper instance which contains much of the code which we\n+     * delegate to.\n+     */\n+    protected NestableDelegate delegate = new NestableDelegate(this);\n+\n+    /**\n+     * Holds the reference to the exception or error that caused\n+     * this exception to be thrown.\n+     */\n+    private Throwable cause = null;\n+\n+    /**\n+     * Constructs a new <code>NestableException</code> without specified\n+     * detail message.\n+     */\n+    public NestableException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg The error message.\n+     */\n+    public NestableException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableException</code> with specified\n+     * nested <code>Throwable</code>.\n+     *\n+     * @param cause the exception or error that caused this exception to be\n+     * thrown\n+     */\n+    public NestableException(Throwable cause) {\n+        super();\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableException</code> with specified\n+     * detail message and nested <code>Throwable</code>.\n+     *\n+     * @param msg    the error message\n+     * @param cause  the exception or error that caused this exception to be\n+     * thrown\n+     */\n+    public NestableException(String msg, Throwable cause) {\n+        super(msg);\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable getCause() {\n+        return cause;\n+    }\n+\n+    /**\n+     * Returns the detail message string of this throwable. If it was\n+     * created with a null message, returns the following:\n+     * (cause==null ? null : cause.toString()).\n+     *\n+     * @return String message string of the throwable\n+     */\n+    public String getMessage() {\n+        if (super.getMessage() != null) {\n+            return super.getMessage();\n+        } else if (cause != null) {\n+            return cause.toString();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String getMessage(int index) {\n+        if (index == 0) {\n+            return super.getMessage();\n+        } else {\n+            return delegate.getMessage(index);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String[] getMessages() {\n+        return delegate.getMessages();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable getThrowable(int index) {\n+        return delegate.getThrowable(index);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int getThrowableCount() {\n+        return delegate.getThrowableCount();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable[] getThrowables() {\n+        return delegate.getThrowables();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOfThrowable(Class type) {\n+        return delegate.indexOfThrowable(type, 0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex) {\n+        return delegate.indexOfThrowable(type, fromIndex);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace() {\n+        delegate.printStackTrace();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace(PrintStream out) {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace(PrintWriter out) {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public final void printPartialStackTrace(PrintWriter out) {\n+        super.printStackTrace(out);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/exception/NestableRuntimeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+/**\n+ * The base class of all runtime exceptions which can contain other\n+ * exceptions.\n+ *\n+ * @see org.apache.commons.lang.exception.NestableException\n+ * @author <a href=\"mailto:Rafal.Krzewski@e-point.pl\">Rafal Krzewski</a>\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class NestableRuntimeException extends RuntimeException implements Nestable {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * The helper instance which contains much of the code which we\n+     * delegate to.\n+     */\n+    protected NestableDelegate delegate = new NestableDelegate(this);\n+\n+    /**\n+     * Holds the reference to the exception or error that caused\n+     * this exception to be thrown.\n+     */\n+    private Throwable cause = null;\n+\n+    /**\n+     * Constructs a new <code>NestableRuntimeException</code> without specified\n+     * detail message.\n+     */\n+    public NestableRuntimeException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableRuntimeException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg the error message\n+     */\n+    public NestableRuntimeException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableRuntimeException</code> with specified\n+     * nested <code>Throwable</code>.\n+     *\n+     * @param cause the exception or error that caused this exception to be\n+     * thrown\n+     */\n+    public NestableRuntimeException(Throwable cause) {\n+        super();\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * Constructs a new <code>NestableRuntimeException</code> with specified\n+     * detail message and nested <code>Throwable</code>.\n+     *\n+     * @param msg    the error message\n+     * @param cause  the exception or error that caused this exception to be\n+     * thrown\n+     */\n+    public NestableRuntimeException(String msg, Throwable cause) {\n+        super(msg);\n+        this.cause = cause;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable getCause() {\n+        return cause;\n+    }\n+\n+    /**\n+     * Returns the detail message string of this throwable. If it was\n+     * created with a null message, returns the following:\n+     * (cause==null ? null : cause.toString()).\n+     *\n+     * @return String message string of the throwable\n+     */\n+    public String getMessage() {\n+        if (super.getMessage() != null) {\n+            return super.getMessage();\n+        } else if (cause != null) {\n+            return cause.toString();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String getMessage(int index) {\n+        if (index == 0) {\n+            return super.getMessage();\n+        } else {\n+            return delegate.getMessage(index);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String[] getMessages() {\n+        return delegate.getMessages();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable getThrowable(int index) {\n+        return delegate.getThrowable(index);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int getThrowableCount() {\n+        return delegate.getThrowableCount();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Throwable[] getThrowables() {\n+        return delegate.getThrowables();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOfThrowable(Class type) {\n+        return delegate.indexOfThrowable(type, 0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex) {\n+        return delegate.indexOfThrowable(type, fromIndex);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace() {\n+        delegate.printStackTrace();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace(PrintStream out) {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void printStackTrace(PrintWriter out) {\n+        delegate.printStackTrace(out);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public final void printPartialStackTrace(PrintWriter out) {\n+        super.printStackTrace(out);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/DoubleRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p><code>DoubleRange</code> represents an inclusive range of <code>double</code>s.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public final class DoubleRange extends Range implements Serializable {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 71849363892740L;\n+\n+    /**\n+     * The minimum number in this range (inclusive).\n+     */\n+    private final double min;\n+    /**\n+     * The maximum number in this range (inclusive).\n+     */\n+    private final double max;\n+    \n+    /**\n+     * Cached output minObject (class is immutable).\n+     */\n+    private transient Double minObject = null;\n+    /**\n+     * Cached output maxObject (class is immutable).\n+     */\n+    private transient Double maxObject = null;\n+    /**\n+     * Cached output hashCode (class is immutable).\n+     */\n+    private transient int hashCode = 0;\n+    /**\n+     * Cached output toString (class is immutable).\n+     */\n+    private transient String toString = null;\n+    \n+    /**\n+     * <p>Constructs a new <code>DoubleRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param number  the number to use for this range\n+     * @throws IllegalArgumentException if the number is <code>NaN</code>\n+     */\n+    public DoubleRange(double number) {\n+        super();\n+        if (Double.isNaN(number)) {\n+            throw new IllegalArgumentException(\"The number must not be NaN\");\n+        }\n+        this.min = number;\n+        this.max = number;\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>DoubleRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param number  the number to use for this range, must not\n+     *  be <code>null</code>\n+     * @throws IllegalArgumentException if the number is <code>null</code>\n+     * @throws IllegalArgumentException if the number is <code>NaN</code>\n+     */\n+    public DoubleRange(Number number) {\n+        super();\n+        if (number == null) {\n+            throw new IllegalArgumentException(\"The number must not be null\");\n+        }\n+        this.min = number.doubleValue();\n+        this.max = number.doubleValue();\n+        if (Double.isNaN(min) || Double.isNaN(max)) {\n+            throw new IllegalArgumentException(\"The number must not be NaN\");\n+        }\n+        if (number instanceof Double) {\n+            this.minObject = (Double) number;\n+            this.maxObject = (Double) number;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>DoubleRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     * \n+     * @param number1  first number that defines the edge of the range, inclusive\n+     * @param number2  second number that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either number is <code>NaN</code>\n+     */\n+    public DoubleRange(double number1, double number2) {\n+        super();\n+        if (Double.isNaN(number1) || Double.isNaN(number2)) {\n+            throw new IllegalArgumentException(\"The numbers must not be NaN\");\n+        }\n+        if (number2 < number1) {\n+            this.min = number2;\n+            this.max = number1;\n+        } else {\n+            this.min = number1;\n+            this.max = number2;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>DoubleRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param number1  first number that defines the edge of the range, inclusive\n+     * @param number2  second number that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either number is <code>null</code>\n+     * @throws IllegalArgumentException if either number is <code>NaN</code>\n+     */\n+    public DoubleRange(Number number1, Number number2) {\n+        super();\n+        if (number1 == null || number2 == null) {\n+            throw new IllegalArgumentException(\"The numbers must not be null\");\n+        }\n+        double number1val = number1.doubleValue();\n+        double number2val = number2.doubleValue();\n+        if (Double.isNaN(number1val) || Double.isNaN(number2val)) {\n+            throw new IllegalArgumentException(\"The numbers must not be NaN\");\n+        }\n+        if (number2val < number1val) {\n+            this.min = number2val;\n+            this.max = number1val;\n+            if (number2 instanceof Double) {\n+                this.minObject = (Double) number2;\n+            }\n+            if (number1 instanceof Double) {\n+                this.maxObject = (Double) number1;\n+            }\n+        } else {\n+            this.min = number1val;\n+            this.max = number2val;\n+            if (number1 instanceof Double) {\n+                this.minObject = (Double) number1;\n+            }\n+            if (number2 instanceof Double) {\n+                this.maxObject = (Double) number2;\n+            }\n+        }\n+    }\n+\n+    // Accessors\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Returns the minimum number in this range.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public Number getMinimumNumber() {\n+        if (minObject == null) {\n+            minObject = new Double(min);            \n+        }\n+        return minObject;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>long</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values or decimals.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public long getMinimumLong() {\n+        return (long) min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>int</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values or decimals.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public int getMinimumInteger() {\n+        return (int) min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>double</code>.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public double getMinimumDouble() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>float</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public float getMinimumFloat() {\n+        return (float) min;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum number in this range.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public Number getMaximumNumber() {\n+        if (maxObject == null) {\n+            maxObject = new Double(max);            \n+        }\n+        return maxObject;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>long</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values or decimals.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public long getMaximumLong() {\n+        return (long) max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>int</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values or decimals.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public int getMaximumInteger() {\n+        return (int) max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>double</code>.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public double getMaximumDouble() {\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>float</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public float getMaximumFloat() {\n+        return (float) max;\n+    }\n+\n+    // Tests\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Tests whether the specified <code>number</code> occurs within\n+     * this range using <code>double</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param number  the number to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this range\n+     */\n+    public boolean containsNumber(Number number) {\n+        if (number == null) {\n+            return false;\n+        }\n+        return containsDouble(number.doubleValue());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>double</code> occurs within\n+     * this range using <code>double</code> comparison.</p>\n+     * \n+     * <p>This implementation overrides the superclass for performance as it is\n+     * the most common case.</p>\n+     * \n+     * @param value  the double to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>double</code> comparison\n+     */\n+    public boolean containsDouble(double value) {\n+        return value >= min && value <= max;\n+    }\n+\n+    // Range tests\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Tests whether the specified range occurs entirely within this range\n+     * using <code>double</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range occurs entirely within this range\n+     * @throws IllegalArgumentException if the range is not of this type\n+     */\n+    public boolean containsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return containsDouble(range.getMinimumDouble())\n+            && containsDouble(range.getMaximumDouble());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range overlaps with this range\n+     * using <code>double</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range overlaps with this range\n+     */\n+    public boolean overlapsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return range.containsDouble(min)\n+            || range.containsDouble(max)\n+            || containsDouble(range.getMinimumDouble());\n+    }\n+\n+    // Basics\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this range to another object to test if they are equal.</p>.\n+     * \n+     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof DoubleRange == false) {\n+            return false;\n+        }\n+        DoubleRange range = (DoubleRange) obj;\n+        return (Double.doubleToLongBits(min) == Double.doubleToLongBits(range.min) &&\n+                Double.doubleToLongBits(max) == Double.doubleToLongBits(range.max));\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the range.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (hashCode == 0) {\n+            hashCode = 17;\n+            hashCode = 37 * hashCode + getClass().hashCode();\n+            long lng = Double.doubleToLongBits(min);\n+            hashCode = 37 * hashCode + ((int) (lng ^ (lng >> 32)));\n+            lng = Double.doubleToLongBits(max);\n+            hashCode = 37 * hashCode + ((int) (lng ^ (lng >> 32)));\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * <p>Gets the range as a <code>String</code>.</p>\n+     *\n+     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     *\n+     * @return the <code>String</code> representation of this range\n+     */\n+    public String toString() {\n+        if (toString == null) {\n+            StringBuffer buf = new StringBuffer(32);\n+            buf.append(\"Range[\");\n+            buf.append(min);\n+            buf.append(',');\n+            buf.append(max);\n+            buf.append(']');\n+            toString = buf.toString();\n+        }\n+        return toString;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/FloatRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p><code>FloatRange</code> represents an inclusive range of <code>float</code>s.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public final class FloatRange extends Range implements Serializable {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 71849363892750L;\n+\n+    /**\n+     * The minimum number in this range (inclusive).\n+     */\n+    private final float min;\n+    /**\n+     * The maximum number in this range (inclusive).\n+     */\n+    private final float max;\n+    \n+    /**\n+     * Cached output minObject (class is immutable).\n+     */\n+    private transient Float minObject = null;\n+    /**\n+     * Cached output maxObject (class is immutable).\n+     */\n+    private transient Float maxObject = null;\n+    /**\n+     * Cached output hashCode (class is immutable).\n+     */\n+    private transient int hashCode = 0;\n+    /**\n+     * Cached output toString (class is immutable).\n+     */\n+    private transient String toString = null;\n+    \n+    /**\n+     * <p>Constructs a new <code>FloatRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param number  the number to use for this range\n+     * @throws IllegalArgumentException if the number is <code>NaN</code>\n+     */\n+    public FloatRange(float number) {\n+        super();\n+        if (Float.isNaN(number)) {\n+            throw new IllegalArgumentException(\"The number must not be NaN\");\n+        }\n+        this.min = number;\n+        this.max = number;\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>FloatRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param number  the number to use for this range, must not\n+     *  be <code>null</code>\n+     * @throws IllegalArgumentException if the number is <code>null</code>\n+     * @throws IllegalArgumentException if the number is <code>NaN</code>\n+     */\n+    public FloatRange(Number number) {\n+        super();\n+        if (number == null) {\n+            throw new IllegalArgumentException(\"The number must not be null\");\n+        }\n+        this.min = number.floatValue();\n+        this.max = number.floatValue();\n+        if (Float.isNaN(min) || Float.isNaN(max)) {\n+            throw new IllegalArgumentException(\"The number must not be NaN\");\n+        }\n+        if (number instanceof Float) {\n+            this.minObject = (Float) number;\n+            this.maxObject = (Float) number;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>FloatRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     * \n+     * @param number1  first number that defines the edge of the range, inclusive\n+     * @param number2  second number that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either number is <code>NaN</code>\n+     */\n+    public FloatRange(float number1, float number2) {\n+        super();\n+        if (Float.isNaN(number1) || Float.isNaN(number2)) {\n+            throw new IllegalArgumentException(\"The numbers must not be NaN\");\n+        }\n+        if (number2 < number1) {\n+            this.min = number2;\n+            this.max = number1;\n+        } else {\n+            this.min = number1;\n+            this.max = number2;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>FloatRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param number1  first number that defines the edge of the range, inclusive\n+     * @param number2  second number that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either number is <code>null</code>\n+     * @throws IllegalArgumentException if either number is <code>NaN</code>\n+     */\n+    public FloatRange(Number number1, Number number2) {\n+        super();\n+        if (number1 == null || number2 == null) {\n+            throw new IllegalArgumentException(\"The numbers must not be null\");\n+        }\n+        float number1val = number1.floatValue();\n+        float number2val = number2.floatValue();\n+        if (Float.isNaN(number1val) || Float.isNaN(number2val)) {\n+            throw new IllegalArgumentException(\"The numbers must not be NaN\");\n+        }\n+        if (number2val < number1val) {\n+            this.min = number2val;\n+            this.max = number1val;\n+            if (number2 instanceof Float) {\n+                this.minObject = (Float) number2;\n+            }\n+            if (number1 instanceof Float) {\n+                this.maxObject = (Float) number1;\n+            }\n+        } else {\n+            this.min = number1val;\n+            this.max = number2val;\n+            if (number1 instanceof Float) {\n+                this.minObject = (Float) number1;\n+            }\n+            if (number2 instanceof Float) {\n+                this.maxObject = (Float) number2;\n+            }\n+        }\n+    }\n+\n+    // Accessors\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Returns the minimum number in this range.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public Number getMinimumNumber() {\n+        if (minObject == null) {\n+            minObject = new Float(min);            \n+        }\n+        return minObject;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>long</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values or decimals.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public long getMinimumLong() {\n+        return (long) min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>int</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values or decimals.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public int getMinimumInteger() {\n+        return (int) min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>double</code>.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public double getMinimumDouble() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>float</code>.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public float getMinimumFloat() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum number in this range.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public Number getMaximumNumber() {\n+        if (maxObject == null) {\n+            maxObject = new Float(max);            \n+        }\n+        return maxObject;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>long</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values or decimals.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public long getMaximumLong() {\n+        return (long) max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>int</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values or decimals.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public int getMaximumInteger() {\n+        return (int) max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>double</code>.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public double getMaximumDouble() {\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>float</code>.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public float getMaximumFloat() {\n+        return max;\n+    }\n+\n+    // Tests\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Tests whether the specified <code>number</code> occurs within\n+     * this range using <code>float</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param number  the number to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this range\n+     */\n+    public boolean containsNumber(Number number) {\n+        if (number == null) {\n+            return false;\n+        }\n+        return containsFloat(number.floatValue());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>float</code> occurs within\n+     * this range using <code>float</code> comparison.</p>\n+     * \n+     * <p>This implementation overrides the superclass for performance as it is\n+     * the most common case.</p>\n+     * \n+     * @param value  the float to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>float</code> comparison\n+     */\n+    public boolean containsFloat(float value) {\n+        return value >= min && value <= max;\n+    }\n+\n+    // Range tests\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Tests whether the specified range occurs entirely within this range\n+     * using <code>float</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range occurs entirely within this range\n+     * @throws IllegalArgumentException if the range is not of this type\n+     */\n+    public boolean containsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return containsFloat(range.getMinimumFloat()) &&\n+               containsFloat(range.getMaximumFloat());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range overlaps with this range\n+     * using <code>float</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range overlaps with this range\n+     */\n+    public boolean overlapsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return range.containsFloat(min) ||\n+               range.containsFloat(max) || \n+               containsFloat(range.getMinimumFloat());\n+    }\n+\n+    // Basics\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this range to another object to test if they are equal.</p>.\n+     * \n+     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof FloatRange == false) {\n+            return false;\n+        }\n+        FloatRange range = (FloatRange) obj;\n+        return (Float.floatToIntBits(min) == Float.floatToIntBits(range.min) &&\n+                Float.floatToIntBits(max) == Float.floatToIntBits(range.max));\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the range.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (hashCode == 0) {\n+            hashCode = 17;\n+            hashCode = 37 * hashCode + getClass().hashCode();\n+            hashCode = 37 * hashCode + Float.floatToIntBits(min);\n+            hashCode = 37 * hashCode + Float.floatToIntBits(max);\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * <p>Gets the range as a <code>String</code>.</p>\n+     *\n+     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     *\n+     * @return the <code>String</code> representation of this range\n+     */\n+    public String toString() {\n+        if (toString == null) {\n+            StringBuffer buf = new StringBuffer(32);\n+            buf.append(\"Range[\");\n+            buf.append(min);\n+            buf.append(',');\n+            buf.append(max);\n+            buf.append(']');\n+            toString = buf.toString();\n+        }\n+        return toString;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/Fraction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.io.Serializable;\n+import java.math.BigInteger;\n+\n+/**\n+ * <p><code>Fraction</code> is a <code>Number</code> implementation that\n+ * stores fractions accurately.</p>\n+ *\n+ * <p>This class is immutable, and interoperable with most methods that accept\n+ * a <code>Number</code>.</p>\n+ *\n+ * @author Travis Reeder\n+ * @author Stephen Colebourne\n+ * @author Tim O'Brien\n+ * @author Pete Gieser\n+ * @author C. Scott Ananian\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public final class Fraction extends Number implements Serializable, Comparable {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 65382027393090L;\n+\n+    /**\n+     * <code>Fraction</code> representation of 0.\n+     */\n+    public static final Fraction ZERO = new Fraction(0, 1);\n+    /**\n+     * <code>Fraction</code> representation of 1.\n+     */\n+    public static final Fraction ONE = new Fraction(1, 1);\n+    /**\n+     * <code>Fraction</code> representation of 1/2.\n+     */\n+    public static final Fraction ONE_HALF = new Fraction(1, 2);\n+    /**\n+     * <code>Fraction</code> representation of 1/3.\n+     */\n+    public static final Fraction ONE_THIRD = new Fraction(1, 3);\n+    /**\n+     * <code>Fraction</code> representation of 2/3.\n+     */\n+    public static final Fraction TWO_THIRDS = new Fraction(2, 3);\n+    /**\n+     * <code>Fraction</code> representation of 1/4.\n+     */\n+    public static final Fraction ONE_QUARTER = new Fraction(1, 4);\n+    /**\n+     * <code>Fraction</code> representation of 2/4.\n+     */\n+    public static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n+    /**\n+     * <code>Fraction</code> representation of 3/4.\n+     */\n+    public static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n+    /**\n+     * <code>Fraction</code> representation of 1/5.\n+     */\n+    public static final Fraction ONE_FIFTH = new Fraction(1, 5);\n+    /**\n+     * <code>Fraction</code> representation of 2/5.\n+     */\n+    public static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n+    /**\n+     * <code>Fraction</code> representation of 3/5.\n+     */\n+    public static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n+    /**\n+     * <code>Fraction</code> representation of 4/5.\n+     */\n+    public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n+\n+\n+    /**\n+     * The numerator number part of the fraction (the three in three sevenths).\n+     */\n+    private final int numerator;\n+    /**\n+     * The denominator number part of the fraction (the seven in three sevenths).\n+     */\n+    private final int denominator;\n+\n+    /**\n+     * Cached output hashCode (class is immutable).\n+     */\n+    private transient int hashCode = 0;\n+    /**\n+     * Cached output toString (class is immutable).\n+     */\n+    private transient String toString = null;\n+    /**\n+     * Cached output toProperString (class is immutable).\n+     */\n+    private transient String toProperString = null;\n+\n+    /**\n+     * <p>Constructs a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     */\n+    private Fraction(int numerator, int denominator) {\n+        super();\n+        this.numerator = numerator;\n+        this.denominator = denominator;\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance\n+     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     */\n+    public static Fraction getFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        return new Fraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 3 parts\n+     * of a fraction X Y/Z.</p>\n+     *\n+     * <p>The negative sign must be passed in on the whole number part.</p>\n+     *\n+     * @param whole  the whole number, for example the one in 'one and three sevenths'\n+     * @param numerator  the numerator, for example the three in 'one and three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'one and three sevenths'\n+     * @return a new fraction instance\n+     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     * @throws ArithmeticException if the denominator is negative\n+     * @throws ArithmeticException if the numerator is negative\n+     * @throws ArithmeticException if the resulting numerator exceeds \n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public static Fraction getFraction(int whole, int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (denominator < 0) {\n+            throw new ArithmeticException(\"The denominator must not be negative\");\n+        }\n+        if (numerator < 0) {\n+            throw new ArithmeticException(\"The numerator must not be negative\");\n+        }\n+        long numeratorValue;\n+        if (whole < 0) {\n+            numeratorValue = whole * (long)denominator - numerator;\n+        } else {\n+            numeratorValue = whole * (long)denominator + numerator;\n+        }\n+        if (numeratorValue < Integer.MIN_VALUE ||\n+                numeratorValue > Integer.MAX_VALUE)  {\n+            throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n+        }\n+        return new Fraction((int) numeratorValue, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>For example, if the input parameters represent 2/4, then the created\n+     * fraction will be 1/2.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance, with the numerator and denominator reduced\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     */\n+    public static Fraction getReducedFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (numerator==0) {\n+            return ZERO; // normalize zero.\n+        }\n+        // allow 2^k/-2^31 as a valid fraction (where k>0)\n+        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n+            numerator/=2; denominator/=2;\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        // simplify fraction.\n+        int gcd = greatestCommonDivisor(numerator, denominator);\n+        numerator /= gcd;\n+        denominator /= gcd;\n+        return new Fraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n+     *\n+     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n+     *  continued fraction algorithm</a>, computing a maximum of\n+     *  25 convergents and bounding the denominator by 10,000.</p>\n+     *\n+     * @param value  the double value to convert\n+     * @return a new fraction instance that is close to the value\n+     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n+     *  or <code>value = NaN</code>\n+     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n+     * @throws ArithmeticException if the the algorithm does not converge\n+     */\n+    public static Fraction getFraction(double value) {\n+        int sign = (value < 0 ? -1 : 1);\n+        value = Math.abs(value);\n+        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n+            throw new ArithmeticException\n+                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n+        }\n+        int wholeNumber = (int) value;\n+        value -= wholeNumber;\n+        \n+        int numer0 = 0;  // the pre-previous\n+        int denom0 = 1;  // the pre-previous\n+        int numer1 = 1;  // the previous\n+        int denom1 = 0;  // the previous\n+        int numer2 = 0;  // the current, setup in calculation\n+        int denom2 = 0;  // the current, setup in calculation\n+        int a1 = (int) value;\n+        int a2 = 0;\n+        double x1 = 1;\n+        double x2 = 0;\n+        double y1 = value - a1;\n+        double y2 = 0;\n+        double delta1, delta2 = Double.MAX_VALUE;\n+        double fraction;\n+        int i = 1;\n+//        System.out.println(\"---\");\n+        do {\n+            delta1 = delta2;\n+            a2 = (int) (x1 / y1);\n+            x2 = y1;\n+            y2 = x1 - a2 * y1;\n+            numer2 = a1 * numer1 + numer0;\n+            denom2 = a1 * denom1 + denom0;\n+            fraction = (double) numer2 / (double) denom2;\n+            delta2 = Math.abs(value - fraction);\n+//            System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n+            a1 = a2;\n+            x1 = x2;\n+            y1 = y2;\n+            numer0 = numer1;\n+            denom0 = denom1;\n+            numer1 = numer2;\n+            denom1 = denom2;\n+            i++;\n+//            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n+        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n+        if (i == 25) {\n+            throw new ArithmeticException(\"Unable to convert double to fraction\");\n+        }\n+        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n+    }\n+\n+    /**\n+     * <p>Creates a Fraction from a <code>String</code>.</p>\n+     *\n+     * <p>The formats accepted are:</p>\n+     *\n+     * <ol>\n+     *  <li><code>double</code> String containing a dot</li>\n+     *  <li>'X Y/Z'</li>\n+     *  <li>'Y/Z'</li>\n+     *  <li>'X' (a simple whole number)</li>\n+     * </ol>\n+     * and a .</p>\n+     *\n+     * @param str  the string to parse, must not be <code>null</code>\n+     * @return the new <code>Fraction</code> instance\n+     * @throws IllegalArgumentException if the string is <code>null</code>\n+     * @throws NumberFormatException if the number format is invalid\n+     */\n+    public static Fraction getFraction(String str) {\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"The string must not be null\");\n+        }\n+        // parse double format\n+        int pos = str.indexOf('.');\n+        if (pos >= 0) {\n+            return getFraction(Double.parseDouble(str));\n+        }\n+\n+        // parse X Y/Z format\n+        pos = str.indexOf(' ');\n+        if (pos > 0) {\n+            int whole = Integer.parseInt(str.substring(0, pos));\n+            str = str.substring(pos + 1);\n+            pos = str.indexOf('/');\n+            if (pos < 0) {\n+                throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n+            } else {\n+                int numer = Integer.parseInt(str.substring(0, pos));\n+                int denom = Integer.parseInt(str.substring(pos + 1));\n+                return getFraction(whole, numer, denom);\n+            }\n+        }\n+\n+        // parse Y/Z format\n+        pos = str.indexOf('/');\n+        if (pos < 0) {\n+            // simple whole number\n+            return getFraction(Integer.parseInt(str), 1);\n+        } else {\n+            int numer = Integer.parseInt(str.substring(0, pos));\n+            int denom = Integer.parseInt(str.substring(pos + 1));\n+            return getFraction(numer, denom);\n+        }\n+    }\n+\n+    // Accessors\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the numerator part of the fraction.</p>\n+     *\n+     * <p>This method may return a value greater than the denominator, an\n+     * improper fraction, such as the seven in 7/4.</p>\n+     *\n+     * @return the numerator fraction part\n+     */\n+    public int getNumerator() {\n+        return numerator;\n+    }\n+\n+    /**\n+     * <p>Gets the denominator part of the fraction.</p>\n+     *\n+     * @return the denominator fraction part\n+     */\n+    public int getDenominator() {\n+        return denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the proper numerator, always positive.</p>\n+     *\n+     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n+     * This method returns the 3 from the proper fraction.</p>\n+     *\n+     * <p>If the fraction is negative such as -7/4, it can be resolved into\n+     * -1 3/4, so this method returns the positive proper numerator, 3.</p>\n+     *\n+     * @return the numerator fraction part of a proper fraction, always positive\n+     */\n+    public int getProperNumerator() {\n+        return Math.abs(numerator % denominator);\n+    }\n+\n+    /**\n+     * <p>Gets the proper whole part of the fraction.</p>\n+     *\n+     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n+     * This method returns the 1 from the proper fraction.</p>\n+     *\n+     * <p>If the fraction is negative such as -7/4, it can be resolved into\n+     * -1 3/4, so this method returns the positive whole part -1.</p>\n+     *\n+     * @return the whole fraction part of a proper fraction, that includes the sign\n+     */\n+    public int getProperWhole() {\n+        return numerator / denominator;\n+    }\n+\n+    // Number methods\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the fraction as an <code>int</code>. This returns the whole number\n+     * part of the fraction.</p>\n+     *\n+     * @return the whole number fraction part\n+     */\n+    public int intValue() {\n+        return numerator / denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>long</code>. This returns the whole number\n+     * part of the fraction.</p>\n+     *\n+     * @return the whole number fraction part\n+     */\n+    public long longValue() {\n+        return (long) numerator / denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>float</code>. This calculates the fraction\n+     * as the numerator divided by denominator.</p>\n+     *\n+     * @return the fraction as a <code>float</code>\n+     */\n+    public float floatValue() {\n+        return ((float) numerator) / ((float) denominator);\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>double</code>. This calculates the fraction\n+     * as the numerator divided by denominator.</p>\n+     *\n+     * @return the fraction as a <code>double</code>\n+     */\n+    public double doubleValue() {\n+        return ((double) numerator) / ((double) denominator);\n+    }\n+\n+    // Calculations\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Reduce the fraction to the smallest values for the numerator and\n+     * denominator, returning the result.</p>\n+     * \n+     * <p>For example, if this fraction represents 2/4, then the result\n+     * will be 1/2.</p>\n+     *\n+     * @return a new reduced fraction instance, or this if no simplification possible\n+     */\n+    public Fraction reduce() {\n+        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n+        if (gcd == 1) {\n+            return this;\n+        }\n+        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the inverse (1/fraction) of this one.</p>\n+     * \n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return a new fraction instance with the numerator and denominator\n+     *         inverted.\n+     * @throws ArithmeticException if the fraction represents zero.\n+     */\n+    public Fraction invert() {\n+        if (numerator == 0) {\n+            throw new ArithmeticException(\"Unable to invert zero.\");\n+        }\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: can't negate numerator\");\n+        }\n+        if (numerator<0) {\n+            return new Fraction(-denominator, -numerator);\n+        } else {\n+            return new Fraction(denominator, numerator);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the negative (-fraction) of this one.</p>\n+     *\n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return a new fraction instance with the opposite signed numerator\n+     */\n+    public Fraction negate() {\n+        // the positive range is one smaller than the negative range of an int.\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: too large to negate\");\n+        }\n+        return new Fraction(-numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the positive equivalent of this one.</p>\n+     * <p>More precisely: <code>(fraction >= 0 ? this : -fraction)</code></p>\n+     *\n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return <code>this</code> if it is positive, or a new positive fraction\n+     *  instance with the opposite signed numerator\n+     */\n+    public Fraction abs() {\n+        if (numerator >= 0) {\n+            return this;\n+        }\n+        return negate();\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is raised to the passed in power.</p>\n+     *\n+     * <p>The returned fraction is in reduced form.</p>\n+     *\n+     * @param power  the power to raise the fraction to\n+     * @return <code>this</code> if the power is one, <code>ONE</code> if the power\n+     * is zero (even if the fraction equals ZERO) or a new fraction instance \n+     * raised to the appropriate power\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction pow(int power) {\n+        if (power == 1) {\n+            return this;\n+        } else if (power == 0) {\n+            return ONE;\n+        } else if (power < 0) {\n+            if (power==Integer.MIN_VALUE) { // MIN_VALUE can't be negated.\n+                return this.invert().pow(2).pow(-(power/2));\n+            }\n+            return this.invert().pow(-power);\n+        } else {\n+            Fraction f = this.multiplyBy(this);\n+            if ((power % 2) == 0) { // if even...\n+                return f.pow(power/2);\n+            } else { // if odd...\n+                return f.pow(power/2).multiplyBy(this);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the greatest common divisor of the absolute value of\n+     * two numbers, using the \"binary gcd\" method which avoids\n+     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n+     * This algorithm is due to Josef Stein (1961).</p>\n+     *\n+     * @param u  a non-zero number\n+     * @param v  a non-zero number\n+     * @return the greatest common divisor, never zero\n+     */\n+    private static int greatestCommonDivisor(int u, int v) {\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u>0) { u=-u; } // make u negative\n+        if (v>0) { v=-v; } // make v negative\n+        // B1. [Find power of 2]\n+        int k=0;\n+        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n+            u/=2; v/=2; k++; // cast out twos.\n+        }\n+        if (k==31) {\n+            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        //     one is odd.\n+        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t&1)==0) { // while t is even..\n+                t/=2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t>0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u)/2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t!=0);\n+        return -u*(1<<k); // gcd is u*2^k\n+    }\n+\n+    // Arithmetic\n+    //-------------------------------------------------------------------\n+\n+    /** \n+     * Multiply two integers, checking for overflow.\n+     * \n+     * @param x a factor\n+     * @param y a factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     *                             an int\n+     */\n+    private static int mulAndCheck(int x, int y) {\n+        long m = ((long)x)*((long)y);\n+        if (m < Integer.MIN_VALUE ||\n+            m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mul\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /**\n+     *  Multiply two non-negative integers, checking for overflow.\n+     * \n+     * @param x a non-negative factor\n+     * @param y a non-negative factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int mulPosAndCheck(int x, int y) {\n+        /* assert x>=0 && y>=0; */\n+        long m = ((long)x)*((long)y);\n+        if (m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mulPos\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /** \n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int addAndCheck(int x, int y) {\n+        long s = (long)x+(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+            s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /** \n+     * Subtract two integers, checking for overflow.\n+     * \n+     * @param x the minuend\n+     * @param y the subtrahend\n+     * @return the difference <code>x-y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int subAndCheck(int x, int y) {\n+        long s = (long)x-(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+            s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /**\n+     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n+     * The algorithm follows Knuth, 4.5.1.</p>\n+     *\n+     * @param fraction  the fraction to add, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction add(Fraction fraction) {\n+        return addSub(fraction, true /* add */);\n+    }\n+\n+    /**\n+     * <p>Subtracts the value of another fraction from the value of this one, \n+     * returning the result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to subtract, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    public Fraction subtract(Fraction fraction) {\n+        return addSub(fraction, false /* subtract */);\n+    }\n+\n+    /** \n+     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n+     * \n+     * @param fraction the fraction to subtract, must not be <code>null</code>\n+     * @param isAdd true to add, false to subtract\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    private Fraction addSub(Fraction fraction, boolean isAdd) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        // zero is identity for addition.\n+        if (numerator == 0) {\n+            return isAdd ? fraction : fraction.negate();\n+        }\n+        if (fraction.numerator == 0) {\n+            return this;\n+        }     \n+        // if denominators are randomly distributed, d1 will be 1 about 61%\n+        // of the time.\n+        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n+        if (d1==1) {\n+            // result is ( (u*v' +/- u'v) / u'v')\n+            int uvp = mulAndCheck(numerator, fraction.denominator);\n+            int upv = mulAndCheck(fraction.numerator, denominator);\n+            return new Fraction\n+                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n+                 mulPosAndCheck(denominator, fraction.denominator));\n+        }\n+        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n+        // exercise 7.  we're going to use a BigInteger.\n+        // t = u(v'/d1) +/- v(u'/d1)\n+        BigInteger uvp = BigInteger.valueOf(numerator)\n+            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n+        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n+            .multiply(BigInteger.valueOf(denominator/d1));\n+        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n+        // but d2 doesn't need extra precision because\n+        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n+        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n+        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n+\n+        // result is (t/d2) / (u'/d1)(v'/d2)\n+        BigInteger w = t.divide(BigInteger.valueOf(d2));\n+        if (w.bitLength() > 31) {\n+            throw new ArithmeticException\n+                (\"overflow: numerator too large after multiply\");\n+        }\n+        return new Fraction\n+            (w.intValue(),\n+             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n+    }\n+\n+    /**\n+     * <p>Multiplies the value of this fraction by another, returning the \n+     * result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction multiplyBy(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (numerator == 0 || fraction.numerator == 0) {\n+            return ZERO;\n+        }\n+        // knuth 4.5.1\n+        // make sure we don't overflow unless the result *must* overflow.\n+        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n+        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n+        return getReducedFraction\n+            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n+             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n+    }\n+\n+    /**\n+     * <p>Divide the value of this fraction by another.</p>\n+     *\n+     * @param fraction  the fraction to divide by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the fraction to divide by is zero\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction divideBy(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (fraction.numerator == 0) {\n+            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n+        }\n+        return multiplyBy(fraction.invert());\n+    }\n+\n+    // Basics\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this fraction to another object to test if they are equal.</p>.\n+     *\n+     * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Fraction == false) {\n+            return false;\n+        }\n+        Fraction other = (Fraction) obj;\n+        return (getNumerator() == other.getNumerator() &&\n+                getDenominator() == other.getDenominator());\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the fraction.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (hashCode == 0) {\n+            // hashcode update should be atomic.\n+            hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * <p>Compares this object to another based on size.</p>\n+     *\n+     * <p>Note: this class has a natural ordering that is inconsistent\n+     * with equals, because, for example, equals treats 1/2 and 2/4 as\n+     * different, whereas compareTo treats them as equal.\n+     *\n+     * @param object  the object to compare to\n+     * @return -1 if this is less, 0 if equal, +1 if greater\n+     * @throws ClassCastException if the object is not a <code>Fraction</code>\n+     * @throws NullPointerException if the object is <code>null</code>\n+     */\n+    public int compareTo(Object object) {\n+        Fraction other = (Fraction) object;\n+        if (this==other) {\n+            return 0;\n+        }\n+        if (numerator == other.numerator && denominator == other.denominator) {\n+            return 0;\n+        }\n+\n+        // otherwise see which is less\n+        long first = (long) numerator * (long) other.denominator;\n+        long second = (long) other.numerator * (long) denominator;\n+        if (first == second) {\n+            return 0;\n+        } else if (first < second) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>String</code>.</p>\n+     *\n+     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n+     *\n+     * @return a <code>String</code> form of the fraction\n+     */\n+    public String toString() {\n+        if (toString == null) {\n+            toString = new StringBuffer(32)\n+                .append(getNumerator())\n+                .append('/')\n+                .append(getDenominator()).toString();\n+        }\n+        return toString;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\n+     *\n+     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\n+     * If the whole number is zero it will be ommitted. If the numerator is zero,\n+     * only the whole number is returned.</p>\n+     *\n+     * @return a <code>String</code> form of the fraction\n+     */\n+    public String toProperString() {\n+        if (toProperString == null) {\n+            if (numerator == 0) {\n+                toProperString = \"0\";\n+            } else if (numerator == denominator) {\n+                toProperString = \"1\";\n+            } else if (numerator == -1 * denominator) {\n+                toProperString = \"-1\";\n+            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n+                // note that we do the magnitude comparison test above with\n+                // NEGATIVE (not positive) numbers, since negative numbers\n+                // have a larger range.  otherwise numerator==Integer.MIN_VALUE\n+                // is handled incorrectly.\n+                int properNumerator = getProperNumerator();\n+                if (properNumerator == 0) {\n+                    toProperString = Integer.toString(getProperWhole());\n+                } else {\n+                    toProperString = new StringBuffer(32)\n+                        .append(getProperWhole()).append(' ')\n+                        .append(properNumerator).append('/')\n+                        .append(getDenominator()).toString();\n+                }\n+            } else {\n+                toProperString = new StringBuffer(32)\n+                    .append(getNumerator()).append('/')\n+                    .append(getDenominator()).toString();\n+            }\n+        }\n+        return toProperString;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/IntRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p><code>IntRange</code> represents an inclusive range of <code>int</code>s.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public final class IntRange extends Range implements Serializable {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 71849363892730L;\n+\n+    /**\n+     * The minimum number in this range (inclusive).\n+     */\n+    private final int min;\n+    /**\n+     * The maximum number in this range (inclusive).\n+     */\n+    private final int max;\n+    \n+    /**\n+     * Cached output minObject (class is immutable).\n+     */\n+    private transient Integer minObject = null;\n+    /**\n+     * Cached output maxObject (class is immutable).\n+     */\n+    private transient Integer maxObject = null;\n+    /**\n+     * Cached output hashCode (class is immutable).\n+     */\n+    private transient int hashCode = 0;\n+    /**\n+     * Cached output toString (class is immutable).\n+     */\n+    private transient String toString = null;\n+    \n+    /**\n+     * <p>Constructs a new <code>IntRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param number  the number to use for this range\n+     */\n+    public IntRange(int number) {\n+        super();\n+        this.min = number;\n+        this.max = number;\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>IntRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param number  the number to use for this range, must not be <code>null</code>\n+     * @throws IllegalArgumentException if the number is <code>null</code>\n+     */\n+    public IntRange(Number number) {\n+        super();\n+        if (number == null) {\n+            throw new IllegalArgumentException(\"The number must not be null\");\n+        }\n+        this.min = number.intValue();\n+        this.max = number.intValue();\n+        if (number instanceof Integer) {\n+            this.minObject = (Integer) number;\n+            this.maxObject = (Integer) number;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>IntRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     * \n+     * @param number1  first number that defines the edge of the range, inclusive\n+     * @param number2  second number that defines the edge of the range, inclusive\n+     */\n+    public IntRange(int number1, int number2) {\n+        super();\n+        if (number2 < number1) {\n+            this.min = number2;\n+            this.max = number1;\n+        } else {\n+            this.min = number1;\n+            this.max = number2;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>IntRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param number1  first number that defines the edge of the range, inclusive\n+     * @param number2  second number that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either number is <code>null</code>\n+     */\n+    public IntRange(Number number1, Number number2) {\n+        super();\n+        if (number1 == null || number2 == null) {\n+            throw new IllegalArgumentException(\"The numbers must not be null\");\n+        }\n+        int number1val = number1.intValue();\n+        int number2val = number2.intValue();\n+        if (number2val < number1val) {\n+            this.min = number2val;\n+            this.max = number1val;\n+            if (number2 instanceof Integer) {\n+                this.minObject = (Integer) number2;\n+            }\n+            if (number1 instanceof Integer) {\n+                this.maxObject = (Integer) number1;\n+            }\n+        } else {\n+            this.min = number1val;\n+            this.max = number2val;\n+            if (number1 instanceof Integer) {\n+                this.minObject = (Integer) number1;\n+            }\n+            if (number2 instanceof Integer) {\n+                this.maxObject = (Integer) number2;\n+            }\n+        }\n+    }\n+\n+    // Accessors\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Returns the minimum number in this range.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public Number getMinimumNumber() {\n+        if (minObject == null) {\n+            minObject = new Integer(min);            \n+        }\n+        return minObject;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>long</code>.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public long getMinimumLong() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>int</code>.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public int getMinimumInteger() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>double</code>.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public double getMinimumDouble() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>float</code>.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public float getMinimumFloat() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum number in this range.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public Number getMaximumNumber() {\n+        if (maxObject == null) {\n+            maxObject = new Integer(max);            \n+        }\n+        return maxObject;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>long</code>.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public long getMaximumLong() {\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>int</code>.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public int getMaximumInteger() {\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>double</code>.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public double getMaximumDouble() {\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>float</code>.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public float getMaximumFloat() {\n+        return max;\n+    }\n+\n+    // Tests\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Tests whether the specified <code>number</code> occurs within\n+     * this range using <code>int</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param number  the number to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this range\n+     */\n+    public boolean containsNumber(Number number) {\n+        if (number == null) {\n+            return false;\n+        }\n+        return containsInteger(number.intValue());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>int</code> occurs within\n+     * this range using <code>int</code> comparison.</p>\n+     * \n+     * <p>This implementation overrides the superclass for performance as it is\n+     * the most common case.</p>\n+     * \n+     * @param value  the int to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>int</code> comparison\n+     */\n+    public boolean containsInteger(int value) {\n+        return value >= min && value <= max;\n+    }\n+\n+    // Range tests\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Tests whether the specified range occurs entirely within this range\n+     * using <code>int</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range occurs entirely within this range\n+     * @throws IllegalArgumentException if the range is not of this type\n+     */\n+    public boolean containsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return containsInteger(range.getMinimumInteger()) &&\n+               containsInteger(range.getMaximumInteger());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range overlaps with this range\n+     * using <code>int</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range overlaps with this range\n+     */\n+    public boolean overlapsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return range.containsInteger(min) ||\n+               range.containsInteger(max) || \n+               containsInteger(range.getMinimumInteger());\n+    }\n+\n+    // Basics\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this range to another object to test if they are equal.</p>.\n+     * \n+     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof IntRange == false) {\n+            return false;\n+        }\n+        IntRange range = (IntRange) obj;\n+        return min == range.min && max == range.max;\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the range.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (hashCode == 0) {\n+            hashCode = 17;\n+            hashCode = 37 * hashCode + getClass().hashCode();\n+            hashCode = 37 * hashCode + min;\n+            hashCode = 37 * hashCode + max;\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * <p>Gets the range as a <code>String</code>.</p>\n+     *\n+     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     *\n+     * @return the <code>String</code> representation of this range\n+     */\n+    public String toString() {\n+        if (toString == null) {\n+            StringBuffer buf = new StringBuffer(32);\n+            buf.append(\"Range[\");\n+            buf.append(min);\n+            buf.append(',');\n+            buf.append(max);\n+            buf.append(']');\n+            toString = buf.toString();\n+        }\n+        return toString;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/JVMRandom.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.util.Random;\n+\n+/**\n+ * <p><code>JVMRandom</code> is a wrapper that supports all possible \n+ * Random methods via the {@link java.lang.Math#random()} method\n+ * and its system-wide {@link Random} object.</p>\n+ * \n+ * @author Henri Yandell\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public final class JVMRandom extends Random {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Ensures that only the constructor can call reseed.\n+     */\n+    private boolean constructed = false;\n+\n+    /**\n+     * Constructs a new instance.\n+     */\n+    public JVMRandom() {\n+        this.constructed = true;\n+    }\n+    \n+    /**\n+     * Unsupported in 2.0.\n+     * \n+     * @param seed ignored\n+     * @throws UnsupportedOperationException\n+     */\n+    public synchronized void setSeed(long seed) {\n+        if (this.constructed) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Unsupported in 2.0.\n+     * \n+     * @return Nothing, this method always throws an UnsupportedOperationException.\n+     * @throws UnsupportedOperationException\n+     */\n+    public synchronized double nextGaussian() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Unsupported in 2.0.\n+     * \n+     * @param byteArray ignored\n+     * @throws UnsupportedOperationException\n+     */\n+    public void nextBytes(byte[] byteArray) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed int value\n+     * from the Math.random() sequence.</p>\n+     *\n+     * @return the random int\n+     */\n+    public int nextInt() {\n+        return nextInt(Integer.MAX_VALUE);\n+    }\n+    /**\n+     * <p>Returns a pseudorandom, uniformly distributed int value between\n+     * <code>0</code> (inclusive) and the specified value (exclusive), from\n+     * the Math.random() sequence.</p>\n+     *\n+     * @param n  the specified exclusive max-value\n+     * @return the random int\n+     * @throws IllegalArgumentException when <code>n &lt;= 0</code>\n+     */\n+    public int nextInt(int n) {\n+        if (n <= 0) {\n+            throw new IllegalArgumentException(\n+                \"Upper bound for nextInt must be positive\"\n+            );\n+        }\n+        // TODO: check this cannot return 'n'\n+        return (int)(Math.random() * n);\n+    }\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed long value\n+     * from the Math.random() sequence.</p>\n+     * @return the random long\n+     */\n+    public long nextLong() {\n+        // possible loss of precision?\n+        return nextLong(Long.MAX_VALUE);\n+    }\n+\n+\n+    /**\n+     * <p>Returns a pseudorandom, uniformly distributed long value between\n+     * <code>0</code> (inclusive) and the specified value (exclusive), from\n+     * the Math.random() sequence.</p>\n+     *\n+     * @param n  the specified exclusive max-value\n+     * @return the random long\n+     * @throws IllegalArgumentException when <code>n &lt;= 0</code>\n+     */\n+    public static long nextLong(long n) {\n+        if (n <= 0) {\n+            throw new IllegalArgumentException(\n+                \"Upper bound for nextInt must be positive\"\n+            );\n+        }\n+        // TODO: check this cannot return 'n'\n+        return (long)(Math.random() * n);\n+     }\n+\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed boolean value\n+     * from the Math.random() sequence.</p>\n+     *\n+     * @return the random boolean\n+     */\n+    public boolean nextBoolean() {\n+        return Math.random() > 0.5;\n+    }\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed float value\n+     * between <code>0.0</code> and <code>1.0</code> from the Math.random()\n+     * sequence.</p>\n+     *\n+     * @return the random float\n+     */\n+    public float nextFloat() {\n+        return (float)Math.random();\n+    }\n+    /**\n+     * <p>Synonymous to the Math.random() call.</p>\n+     *\n+     * @return the random double\n+     */\n+    public double nextDouble() {\n+        return Math.random();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/LongRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p><code>LongRange</code> represents an inclusive range of <code>long</code>s.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public final class LongRange extends Range implements Serializable {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 71849363892720L;\n+\n+    /**\n+     * The minimum number in this range (inclusive).\n+     */\n+    private final long min;\n+    /**\n+     * The maximum number in this range (inclusive).\n+     */\n+    private final long max;\n+    \n+    /**\n+     * Cached output minObject (class is immutable).\n+     */\n+    private transient Long minObject = null;\n+    /**\n+     * Cached output maxObject (class is immutable).\n+     */\n+    private transient Long maxObject = null;\n+    /**\n+     * Cached output hashCode (class is immutable).\n+     */\n+    private transient int hashCode = 0;\n+    /**\n+     * Cached output toString (class is immutable).\n+     */\n+    private transient String toString = null;\n+    \n+    /**\n+     * <p>Constructs a new <code>LongRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param number  the number to use for this range\n+     */\n+    public LongRange(long number) {\n+        super();\n+        this.min = number;\n+        this.max = number;\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>LongRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param number  the number to use for this range, must not\n+     *  be <code>null</code>\n+     * @throws IllegalArgumentException if the number is <code>null</code>\n+     */\n+    public LongRange(Number number) {\n+        super();\n+        if (number == null) {\n+            throw new IllegalArgumentException(\"The number must not be null\");\n+        }\n+        this.min = number.longValue();\n+        this.max = number.longValue();\n+        if (number instanceof Long) {\n+            this.minObject = (Long) number;\n+            this.maxObject = (Long) number;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>LongRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     * \n+     * @param number1  first number that defines the edge of the range, inclusive\n+     * @param number2  second number that defines the edge of the range, inclusive\n+     */\n+    public LongRange(long number1, long number2) {\n+        super();\n+        if (number2 < number1) {\n+            this.min = number2;\n+            this.max = number1;\n+        } else {\n+            this.min = number1;\n+            this.max = number2;\n+        }\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>LongRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param number1  first number that defines the edge of the range, inclusive\n+     * @param number2  second number that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either number is <code>null</code>\n+     */\n+    public LongRange(Number number1, Number number2) {\n+        super();\n+        if (number1 == null || number2 == null) {\n+            throw new IllegalArgumentException(\"The numbers must not be null\");\n+        }\n+        long number1val = number1.longValue();\n+        long number2val = number2.longValue();\n+        if (number2val < number1val) {\n+            this.min = number2val;\n+            this.max = number1val;\n+            if (number2 instanceof Long) {\n+                this.minObject = (Long) number2;\n+            }\n+            if (number1 instanceof Long) {\n+                this.maxObject = (Long) number1;\n+            }\n+        } else {\n+            this.min = number1val;\n+            this.max = number2val;\n+            if (number1 instanceof Long) {\n+                this.minObject = (Long) number1;\n+            }\n+            if (number2 instanceof Long) {\n+                this.maxObject = (Long) number2;\n+            }\n+        }\n+    }\n+\n+    // Accessors\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Returns the minimum number in this range.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public Number getMinimumNumber() {\n+        if (minObject == null) {\n+            minObject = new Long(min);            \n+        }\n+        return minObject;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>long</code>.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public long getMinimumLong() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>int</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public int getMinimumInteger() {\n+        return (int) min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>double</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public double getMinimumDouble() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>float</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public float getMinimumFloat() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum number in this range.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public Number getMaximumNumber() {\n+        if (maxObject == null) {\n+            maxObject = new Long(max);            \n+        }\n+        return maxObject;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>long</code>.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public long getMaximumLong() {\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range cast to an <code>int</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values.</p>\n+     * \n+     * @return the maximum number in this range cast to an <code>int</code>.\n+     */\n+    public int getMaximumInteger() {\n+        return (int) max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>double</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values.</p>\n+     * \n+     * @return The maximum number in this range as a <code>double</code>.\n+     */\n+    public double getMaximumDouble() {\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>float</code>.</p>\n+     * \n+     * <p>This conversion can lose information for large values.</p>\n+     * \n+     * @return The maximum number in this range as a <code>float</code>.\n+     */\n+    public float getMaximumFloat() {\n+        return max;\n+    }\n+\n+    // Tests\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Tests whether the specified <code>number</code> occurs within\n+     * this range using <code>long</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param number  the number to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this range\n+     */\n+    public boolean containsNumber(Number number) {\n+        if (number == null) {\n+            return false;\n+        }\n+        return containsLong(number.longValue());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>long</code> occurs within\n+     * this range using <code>long</code> comparison.</p>\n+     * \n+     * <p>This implementation overrides the superclass for performance as it is\n+     * the most common case.</p>\n+     * \n+     * @param value  the long to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>long</code> comparison\n+     */\n+    public boolean containsLong(long value) {\n+        return value >= min && value <= max;\n+    }\n+\n+    // Range tests\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Tests whether the specified range occurs entirely within this range\n+     * using <code>long</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range occurs entirely within this range\n+     * @throws IllegalArgumentException if the range is not of this type\n+     */\n+    public boolean containsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return containsLong(range.getMinimumLong()) &&\n+               containsLong(range.getMaximumLong());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range overlaps with this range\n+     * using <code>long</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range overlaps with this range\n+     */\n+    public boolean overlapsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return range.containsLong(min) ||\n+               range.containsLong(max) || \n+               containsLong(range.getMinimumLong());\n+    }\n+\n+    // Basics\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this range to another object to test if they are equal.</p>.\n+     * \n+     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof LongRange == false) {\n+            return false;\n+        }\n+        LongRange range = (LongRange) obj;\n+        return min == range.min && max == range.max;\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the range.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (hashCode == 0) {\n+            hashCode = 17;\n+            hashCode = 37 * hashCode + getClass().hashCode();\n+            hashCode = 37 * hashCode + ((int) (min ^ (min >> 32)));\n+            hashCode = 37 * hashCode + ((int) (max ^ (max >> 32)));\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * <p>Gets the range as a <code>String</code>.</p>\n+     *\n+     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     *\n+     * @return the <code>String</code> representation of this range\n+     */\n+    public String toString() {\n+        if (toString == null) {\n+            StringBuffer buf = new StringBuffer(32);\n+            buf.append(\"Range[\");\n+            buf.append(min);\n+            buf.append(',');\n+            buf.append(max);\n+            buf.append(']');\n+            toString = buf.toString();\n+        }\n+        return toString;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/NumberRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p><code>NumberRange</code> represents an inclusive range of \n+ * {@link java.lang.Number} objects of the same type.</p>\n+ *\n+ * @author <a href=\"mailto:chrise@esha.com\">Christopher Elkins</a>\n+ * @author Stephen Colebourne\n+ * @since 2.0 (previously in org.apache.commons.lang)\n+ * @version $Id$\n+ */\n+public final class NumberRange extends Range implements Serializable {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 71849363892710L;\n+\n+    /**\n+     * The minimum number in this range.\n+     */\n+    private final Number min;\n+    /**\n+     * The maximum number in this range.\n+     */\n+    private final Number max;\n+    \n+    /**\n+     * Cached output hashCode (class is immutable).\n+     */\n+    private transient int hashCode = 0;\n+    /**\n+     * Cached output toString (class is immutable).\n+     */\n+    private transient String toString = null;\n+\n+    /**\n+     * <p>Constructs a new <code>NumberRange</code> using the specified\n+     * number as both the minimum and maximum in this range.</p>\n+     *\n+     * @param num the number to use for this range\n+     * @throws IllegalArgumentException if the number is <code>null</code>\n+     * @throws IllegalArgumentException if the number doesn't implement <code>Comparable</code>\n+     * @throws IllegalArgumentException if the number is <code>Double.NaN</code> or <code>Float.NaN</code>\n+     */\n+    public NumberRange(Number num) {\n+        if (num == null) {\n+            throw new IllegalArgumentException(\"The number must not be null\");\n+        }\n+        if (num instanceof Comparable == false) {\n+            throw new IllegalArgumentException(\"The number must implement Comparable\");\n+        }\n+        if (num instanceof Double && ((Double) num).isNaN()) {\n+            throw new IllegalArgumentException(\"The number must not be NaN\");\n+        }\n+        if (num instanceof Float && ((Float) num).isNaN()) {\n+            throw new IllegalArgumentException(\"The number must not be NaN\");\n+        }\n+\n+        this.min = num;\n+        this.max = num;\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>NumberRange</code> with the specified\n+     * minimum and maximum numbers (both inclusive).</p>\n+     * \n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * {@link #getMinimumNumber()} and {@link #getMaximumNumber()} methods will return the\n+     * correct value.</p>\n+     * \n+     * <p>This constructor is designed to be used with two <code>Number</code>\n+     * objects of the same type. If two objects of different types are passed in,\n+     * an exception is thrown.</p>\n+     *\n+     * @param num1  first number that defines the edge of the range, inclusive\n+     * @param num2  second number that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either number is <code>null</code>\n+     * @throws IllegalArgumentException if the numbers are of different types\n+     * @throws IllegalArgumentException if the numbers don't implement <code>Comparable</code>\n+     */\n+    public NumberRange(Number num1, Number num2) {\n+        if (num1 == null || num2 == null) {\n+            throw new IllegalArgumentException(\"The numbers must not be null\");\n+        }\n+        if (num1.getClass() != num2.getClass()) {\n+            throw new IllegalArgumentException(\"The numbers must be of the same type\");\n+        }\n+        if (num1 instanceof Comparable == false) {\n+            throw new IllegalArgumentException(\"The numbers must implement Comparable\");\n+        }\n+        if (num1 instanceof Double) {\n+            if (((Double) num1).isNaN() || ((Double) num2).isNaN()) {\n+                throw new IllegalArgumentException(\"The number must not be NaN\");\n+            }\n+        } else if (num1 instanceof Float) {\n+            if (((Float) num1).isNaN() || ((Float) num2).isNaN()) {\n+                throw new IllegalArgumentException(\"The number must not be NaN\");\n+            }\n+        }\n+        \n+        int compare = ((Comparable) num1).compareTo(num2);\n+        if (compare == 0) {\n+            this.min = num1;\n+            this.max = num1;\n+        } else if (compare > 0) {\n+            this.min = num2;\n+            this.max = num1;\n+        } else {\n+            this.min = num1;\n+            this.max = num2;\n+        }\n+    }\n+    \n+    // Accessors\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Returns the minimum number in this range.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public Number getMinimumNumber() {\n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum number in this range.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public Number getMaximumNumber() {\n+        return max;\n+    }\n+\n+    // Tests\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Tests whether the specified <code>number</code> occurs within\n+     * this range.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param number  the number to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this range\n+     * @throws IllegalArgumentException if the number is of a different type to the range\n+     */\n+    public boolean containsNumber(Number number) {\n+        if (number == null) {\n+            return false;\n+        }\n+        if (number.getClass() != min.getClass()) {\n+            throw new IllegalArgumentException(\"The number must be of the same type as the range numbers\");\n+        }\n+        int compareMin = ((Comparable) min).compareTo(number);\n+        int compareMax = ((Comparable) max).compareTo(number);\n+        return compareMin <= 0 && compareMax >= 0;\n+    }\n+\n+    // Range tests\n+    //--------------------------------------------------------------------\n+    // use Range implementations\n+\n+    // Basics\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this range to another object to test if they are equal.</p>.\n+     * \n+     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof NumberRange == false) {\n+            return false;\n+        }\n+        NumberRange range = (NumberRange) obj;\n+        return min.equals(range.min) && max.equals(range.max);\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the range.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (hashCode == 0) {\n+            hashCode = 17;\n+            hashCode = 37 * hashCode + getClass().hashCode();\n+            hashCode = 37 * hashCode + min.hashCode();\n+            hashCode = 37 * hashCode + max.hashCode();\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * <p>Gets the range as a <code>String</code>.</p>\n+     *\n+     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     *\n+     * @return the <code>String</code> representation of this range\n+     */\n+    public String toString() {\n+        if (toString == null) {\n+            StringBuffer buf = new StringBuffer(32);\n+            buf.append(\"Range[\");\n+            buf.append(min);\n+            buf.append(',');\n+            buf.append(max);\n+            buf.append(']');\n+            toString = buf.toString();\n+        }\n+        return toString;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/NumberUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * <p>Provides extra functionality for Java Number classes.</p>\n+ *\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Eric Pugh\n+ * @author Phil Steitz\n+ * @author Matthew Hawthorne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class NumberUtils {\n+    \n+    /** Reusable Long constant for zero. */\n+    public static final Long LONG_ZERO = new Long(0L);\n+    /** Reusable Long constant for one. */\n+    public static final Long LONG_ONE = new Long(1L);\n+    /** Reusable Long constant for minus one. */\n+    public static final Long LONG_MINUS_ONE = new Long(-1L);\n+    /** Reusable Integer constant for zero. */\n+    public static final Integer INTEGER_ZERO = new Integer(0);\n+    /** Reusable Integer constant for one. */\n+    public static final Integer INTEGER_ONE = new Integer(1);\n+    /** Reusable Integer constant for minus one. */\n+    public static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n+    /** Reusable Short constant for zero. */\n+    public static final Short SHORT_ZERO = new Short((short) 0);\n+    /** Reusable Short constant for one. */\n+    public static final Short SHORT_ONE = new Short((short) 1);\n+    /** Reusable Short constant for minus one. */\n+    public static final Short SHORT_MINUS_ONE = new Short((short) -1);\n+    /** Reusable Byte constant for zero. */\n+    public static final Byte BYTE_ZERO = new Byte((byte) 0);\n+    /** Reusable Byte constant for one. */\n+    public static final Byte BYTE_ONE = new Byte((byte) 1);\n+    /** Reusable Byte constant for minus one. */\n+    public static final Byte BYTE_MINUS_ONE = new Byte((byte) -1);\n+    /** Reusable Double constant for zero. */\n+    public static final Double DOUBLE_ZERO = new Double(0.0d);\n+    /** Reusable Double constant for one. */\n+    public static final Double DOUBLE_ONE = new Double(1.0d);\n+    /** Reusable Double constant for minus one. */\n+    public static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n+    /** Reusable Float constant for zero. */\n+    public static final Float FLOAT_ZERO = new Float(0.0f);\n+    /** Reusable Float constant for one. */\n+    public static final Float FLOAT_ONE = new Float(1.0f);\n+    /** Reusable Float constant for minus one. */\n+    public static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n+\n+    /**\n+     * <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>NumberUtils.stringToInt(\"6\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public NumberUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     * \n+     * <pre>\n+     *   NumberUtils.stringToInt(null) = 0\n+     *   NumberUtils.stringToInt(\"\")   = 0\n+     *   NumberUtils.stringToInt(\"1\")  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the int represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     * @deprecated Use {@link #toInt(String)}\n+     *  This method will be removed in Commons Lang 3.0\n+     */\n+    public static int stringToInt(String str) {\n+        return toInt(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toInt(null) = 0\n+     *   NumberUtils.toInt(\"\")   = 0\n+     *   NumberUtils.toInt(\"1\")  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the int represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     * @since 2.1\n+     */\n+    public static int toInt(String str) {\n+        return toInt(str, 0);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     * \n+     * <pre>\n+     *   NumberUtils.stringToInt(null, 1) = 1\n+     *   NumberUtils.stringToInt(\"\", 1)   = 1\n+     *   NumberUtils.stringToInt(\"1\", 0)  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the int represented by the string, or the default if conversion fails\n+     * @deprecated Use {@link #toInt(String, int)}\n+     *  This method will be removed in Commons Lang 3.0\n+     */\n+    public static int stringToInt(String str, int defaultValue) {\n+        return toInt(str, defaultValue);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toInt(null, 1) = 1\n+     *   NumberUtils.toInt(\"\", 1)   = 1\n+     *   NumberUtils.toInt(\"1\", 0)  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the int represented by the string, or the default if conversion fails\n+     * @since 2.1\n+     */\n+    public static int toInt(String str, int defaultValue) {\n+        if(str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>long</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toLong(null) = 0L\n+     *   NumberUtils.toLong(\"\")   = 0L\n+     *   NumberUtils.toLong(\"1\")  = 1L\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the long represented by the string, or <code>0</code> if\n+     *  conversion fails\n+     * @since 2.1\n+     */\n+    public static long toLong(String str) {\n+        return toLong(str, 0L);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>long</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toLong(null, 1L) = 1L\n+     *   NumberUtils.toLong(\"\", 1L)   = 1L\n+     *   NumberUtils.toLong(\"1\", 0L)  = 1L\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the long represented by the string, or the default if conversion fails\n+     * @since 2.1\n+     */\n+    public static long toLong(String str, long defaultValue) {\n+        if (str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Long.parseLong(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>float</code>, returning\n+     * <code>0.0f</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>,\n+     * <code>0.0f</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toFloat(null)   = 0.0f\n+     *   NumberUtils.toFloat(\"\")     = 0.0f\n+     *   NumberUtils.toFloat(\"1.5\")  = 1.5f\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @return the float represented by the string, or <code>0.0f</code>\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static float toFloat(String str) {\n+        return toFloat(str, 0.0f);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>float</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>, the default\n+     * value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toFloat(null, 1.1f)   = 1.0f\n+     *   NumberUtils.toFloat(\"\", 1.1f)     = 1.1f\n+     *   NumberUtils.toFloat(\"1.5\", 0.0f)  = 1.5f\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @param defaultValue the default value\n+     * @return the float represented by the string, or defaultValue\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static float toFloat(String str, float defaultValue) {\n+      if (str == null) {\n+          return defaultValue;\n+      }     \n+      try {\n+          return Float.parseFloat(str);\n+      } catch (NumberFormatException nfe) {\n+          return defaultValue;\n+      }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>double</code>, returning\n+     * <code>0.0d</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>,\n+     * <code>0.0d</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toDouble(null)   = 0.0d\n+     *   NumberUtils.toDouble(\"\")     = 0.0d\n+     *   NumberUtils.toDouble(\"1.5\")  = 1.5d\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @return the double represented by the string, or <code>0.0d</code>\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static double toDouble(String str) {\n+        return toDouble(str, 0.0d);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>double</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>, the default\n+     * value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toDouble(null, 1.1d)   = 1.1d\n+     *   NumberUtils.toDouble(\"\", 1.1d)     = 1.1d\n+     *   NumberUtils.toDouble(\"1.5\", 0.0d)  = 1.5d\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @param defaultValue the default value\n+     * @return the double represented by the string, or defaultValue\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static double toDouble(String str, double defaultValue) {\n+      if (str == null) {\n+          return defaultValue;\n+      }\n+      try {\n+          return Double.parseDouble(str);\n+      } catch (NumberFormatException nfe) {\n+          return defaultValue;\n+      }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // must handle Long, Float, Integer, Float, Short,\n+    //                  BigDecimal, BigInteger and Byte\n+    // useful methods:\n+    // Byte.decode(String)\n+    // Byte.valueOf(String,int radix)\n+    // Byte.valueOf(String)\n+    // Double.valueOf(String)\n+    // Float.valueOf(String)\n+    // new Float(String)\n+    // Integer.valueOf(String,int radix)\n+    // Integer.valueOf(String)\n+    // Integer.decode(String)\n+    // Integer.getInteger(String)\n+    // Integer.getInteger(String,int val)\n+    // Integer.getInteger(String,Integer val)\n+    // new Integer(String)\n+    // new Double(String)\n+    // new Byte(String)\n+    // new Long(String)\n+    // Long.getLong(String)\n+    // Long.getLong(String,int)\n+    // Long.getLong(String,Integer)\n+    // Long.valueOf(String,int)\n+    // Long.valueOf(String)\n+    // new Short(String)\n+    // Short.decode(String)\n+    // Short.valueOf(String,int)\n+    // Short.valueOf(String)\n+    // new BigDecimal(String)\n+    // new BigInteger(String)\n+    // new BigInteger(String,int radix)\n+    // Possible inputs:\n+    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n+    // plus minus everything. Prolly more. A lot are not separable.\n+\n+    /**\n+     * <p>Turns a string value into a java.lang.Number.</p>\n+     *\n+     * <p>First, the value is examined for a type qualifier on the end\n+     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n+     * trying to create successively larger types from the type specified\n+     * until one is found that can represent the value.</p>\n+     *\n+     * <p>If a type specifier is not found, it will check for a decimal point\n+     * and then try successively larger types from <code>Integer</code> to\n+     * <code>BigInteger</code> and from <code>Float</code> to\n+     * <code>BigDecimal</code>.</p>\n+     *\n+     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n+     * will be interpreted as a hexadecimal integer.  Values with leading\n+     * <code>0</code>'s will not be interpreted as octal.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * <p>This method does not trim the input string, i.e., strings with leading\n+     * or trailing spaces will generate NumberFormatExceptions.</p>\n+     *\n+     * @param str  String containing a number, may be null\n+     * @return Number created from the string\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Number createNumber(String str) throws NumberFormatException {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (StringUtils.isBlank(str)) {\n+            throw new NumberFormatException(\"A blank string is not a valid number\");\n+        }  \n+        if (str.startsWith(\"--\")) {\n+            // this is protection for poorness in java.lang.BigDecimal.\n+            // it accepts this as a legal value, but it does not appear \n+            // to be in specification of class. OS X Java parses it to \n+            // a wrong value.\n+            return null;\n+        }\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+            return createInteger(str);\n+        }   \n+        char lastChar = str.charAt(str.length() - 1);\n+        String mant;\n+        String dec;\n+        String exp;\n+        int decPos = str.indexOf('.');\n+        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n+\n+        if (decPos > -1) {\n+\n+            if (expPos > -1) {\n+                if (expPos < decPos) {\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                }\n+                dec = str.substring(decPos + 1, expPos);\n+            } else {\n+                dec = str.substring(decPos + 1);\n+            }\n+            mant = str.substring(0, decPos);\n+        } else {\n+            if (expPos > -1) {\n+                mant = str.substring(0, expPos);\n+            } else {\n+                mant = str;\n+            }\n+            dec = null;\n+        }\n+        if (!Character.isDigit(lastChar)) {\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length() - 1);\n+            } else {\n+                exp = null;\n+            }\n+            //Requesting a specific type..\n+            String numeric = str.substring(0, str.length() - 1);\n+            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+            switch (lastChar) {\n+                case 'l' :\n+                case 'L' :\n+                    if (dec == null\n+                        && exp == null\n+                        && isDigits(numeric.substring(1))\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        try {\n+                            return createLong(numeric);\n+                        } catch (NumberFormatException nfe) {\n+                            //Too big for a long\n+                        }\n+                        return createBigInteger(numeric);\n+\n+                    }\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                case 'f' :\n+                case 'F' :\n+                    try {\n+                        Float f = NumberUtils.createFloat(numeric);\n+                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                            //If it's too big for a float or the float value = 0 and the string\n+                            //has non-zeros in it, then float does not have the precision we want\n+                            return f;\n+                        }\n+\n+                    } catch (NumberFormatException nfe) {\n+                        // ignore the bad number\n+                    }\n+                    //Fall through\n+                case 'd' :\n+                case 'D' :\n+                    try {\n+                        Double d = NumberUtils.createDouble(numeric);\n+                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n+                            return d;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // ignore the bad number\n+                    }\n+                    try {\n+                        return createBigDecimal(numeric);\n+                    } catch (NumberFormatException e) {\n+                        // ignore the bad number\n+                    }\n+                    //Fall through\n+                default :\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+\n+            }\n+        } else {\n+            //User doesn't have a preference on the return type, so let's start\n+            //small and go from there...\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length());\n+            } else {\n+                exp = null;\n+            }\n+            if (dec == null && exp == null) {\n+                //Must be an int,long,bigint\n+                try {\n+                    return createInteger(str);\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                try {\n+                    return createLong(str);\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                return createBigInteger(str);\n+\n+            } else {\n+                //Must be a float,double,BigDec\n+                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+                try {\n+                    Float f = createFloat(str);\n+                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                        return f;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                try {\n+                    Double d = createDouble(str);\n+                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+\n+                return createBigDecimal(str);\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>\n+     *\n+     * <p>Returns <code>true</code> if s is <code>null</code>.</p>\n+     * \n+     * @param str  the String to check\n+     * @return if it is all zeros or <code>null</code>\n+     */\n+    private static boolean isAllZeros(String str) {\n+        if (str == null) {\n+            return true;\n+        }\n+        for (int i = str.length() - 1; i >= 0; i--) {\n+            if (str.charAt(i) != '0') {\n+                return false;\n+            }\n+        }\n+        return str.length() > 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Float</code>.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Float</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Float createFloat(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Float.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Double</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Double</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Double createDouble(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Double.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n+     * hex and octal notations.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Integer</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Integer createInteger(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n+        return Integer.decode(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Long</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Long</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Long createLong(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Long.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>BigInteger</code>.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>BigInteger</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigInteger createBigInteger(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return new BigInteger(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>BigDecimal</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigDecimal createBigDecimal(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n+        if (StringUtils.isBlank(str)) {\n+            throw new NumberFormatException(\"A blank string is not a valid number\");\n+        }  \n+        return new BigDecimal(str);\n+    }\n+\n+    // Min in array\n+    //--------------------------------------------------------------------\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static long min(long[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        long min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static int min(int[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        int min = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] < min) {\n+                min = array[j];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static short min(short[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        short min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+     /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static double min(double[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        double min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static float min(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        float min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    // Max in array\n+    //--------------------------------------------------------------------\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static long max(long[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+\n+        // Finds and returns max\n+        long max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static int max(int[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        int max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static short max(short[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        short max = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] > max) {\n+                max = array[i];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static double max(double[] array) {\n+        // Validates input\n+        if (array== null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        double max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static float max(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+\n+        // Finds and returns max\n+        float max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+\n+        return max;\n+    }\n+     \n+    // 3 param min\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the minimum of three <code>long</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static long min(long a, long b, long c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>int</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static int min(int a, int b, int c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>short</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static short min(short a, short b, short c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>byte</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static byte min(byte a, byte b, byte c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>double</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static double min(double a, double b, double c) {\n+        return Math.min(Math.min(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>float</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static float min(float a, float b, float c) {\n+        return Math.min(Math.min(a, b), c);\n+    }\n+\n+    // 3 param max\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the maximum of three <code>long</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static long max(long a, long b, long c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>int</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static int max(int a, int b, int c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>short</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static short max(short a, short b, short c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>byte</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static byte max(byte a, byte b, byte c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>double</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static double max(double a, double b, double c) {\n+        return Math.max(Math.max(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>float</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static float max(float a, float b, float c) {\n+        return Math.max(Math.max(a, b), c);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two <code>doubles</code> for order.</p>\n+     *\n+     * <p>This method is more comprehensive than the standard Java greater\n+     * than, less than and equals operators.</p>\n+     * <ul>\n+     *  <li>It returns <code>-1</code> if the first value is less than the second.</li>\n+     *  <li>It returns <code>+1</code> if the first value is greater than the second.</li>\n+     *  <li>It returns <code>0</code> if the values are equal.</li>\n+     * </ul>\n+     *\n+     * <p>\n+     * The ordering is as follows, largest to smallest:\n+     * <ul>\n+     *  <li>NaN\n+     *  <li>Positive infinity\n+     *  <li>Maximum double\n+     *  <li>Normal positive numbers\n+     *  <li>+0.0\n+     *  <li>-0.0\n+     *  <li>Normal negative numbers\n+     *  <li>Minimum double (<code>-Double.MAX_VALUE</code>)\n+     *  <li>Negative infinity\n+     * </ul>\n+     * </p>\n+     *\n+     * <p>Comparing <code>NaN</code> with <code>NaN</code> will\n+     * return <code>0</code>.</p>\n+     * \n+     * @param lhs  the first <code>double</code>\n+     * @param rhs  the second <code>double</code>\n+     * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,\n+     *  <code>0</code> if equal to rhs\n+     */\n+    public static int compare(double lhs, double rhs) {\n+        if (lhs < rhs) {\n+            return -1;\n+        }\n+        if (lhs > rhs) {\n+            return +1;\n+        }\n+        // Need to compare bits to handle 0.0 == -0.0 being true\n+        // compare should put -0.0 < +0.0\n+        // Two NaNs are also == for compare purposes\n+        // where NaN == NaN is false\n+        long lhsBits = Double.doubleToLongBits(lhs);\n+        long rhsBits = Double.doubleToLongBits(rhs);\n+        if (lhsBits == rhsBits) {\n+            return 0;\n+        }\n+        // Something exotic! A comparison to NaN or 0.0 vs -0.0\n+        // Fortunately NaN's long is > than everything else\n+        // Also negzeros bits < poszero\n+        // NAN: 9221120237041090560\n+        // MAX: 9218868437227405311\n+        // NEGZERO: -9223372036854775808\n+        if (lhsBits < rhsBits) {\n+            return -1;\n+        } else {\n+            return +1;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Compares two floats for order.</p>\n+     *\n+     * <p>This method is more comprehensive than the standard Java greater than,\n+     * less than and equals operators.</p>\n+     * <ul>\n+     *  <li>It returns <code>-1</code> if the first value is less than the second.\n+     *  <li>It returns <code>+1</code> if the first value is greater than the second.\n+     *  <li>It returns <code>0</code> if the values are equal.\n+     * </ul>\n+     *\n+     * <p> The ordering is as follows, largest to smallest:\n+     * <ul>\n+     * <li>NaN\n+     * <li>Positive infinity\n+     * <li>Maximum float\n+     * <li>Normal positive numbers\n+     * <li>+0.0\n+     * <li>-0.0\n+     * <li>Normal negative numbers\n+     * <li>Minimum float (<code>-Float.MAX_VALUE</code>)\n+     * <li>Negative infinity\n+     * </ul>\n+     *\n+     * <p>Comparing <code>NaN</code> with <code>NaN</code> will return\n+     * <code>0</code>.</p>\n+     * \n+     * @param lhs  the first <code>float</code>\n+     * @param rhs  the second <code>float</code>\n+     * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,\n+     *  <code>0</code> if equal to rhs\n+     */\n+    public static int compare(float lhs, float rhs) {\n+        if (lhs < rhs) {\n+            return -1;\n+        }\n+        if (lhs > rhs) {\n+            return +1;\n+        }\n+        //Need to compare bits to handle 0.0 == -0.0 being true\n+        // compare should put -0.0 < +0.0\n+        // Two NaNs are also == for compare purposes\n+        // where NaN == NaN is false\n+        int lhsBits = Float.floatToIntBits(lhs);\n+        int rhsBits = Float.floatToIntBits(rhs);\n+        if (lhsBits == rhsBits) {\n+            return 0;\n+        }\n+        //Something exotic! A comparison to NaN or 0.0 vs -0.0\n+        //Fortunately NaN's int is > than everything else\n+        //Also negzeros bits < poszero\n+        //NAN: 2143289344\n+        //MAX: 2139095039\n+        //NEGZERO: -2147483648\n+        if (lhsBits < rhsBits) {\n+            return -1;\n+        } else {\n+            return +1;\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether the <code>String</code> contains only\n+     * digit characters.</p>\n+     *\n+     * <p><code>Null</code> and empty String will return\n+     * <code>false</code>.</p>\n+     *\n+     * @param str  the <code>String</code> to check\n+     * @return <code>true</code> if str contains only unicode numeric\n+     */\n+    public static boolean isDigits(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return false;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            if (!Character.isDigit(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether the String a valid Java number.</p>\n+     *\n+     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n+     * qualifier, scientific notation and numbers marked with a type\n+     * qualifier (e.g. 123L).</p>\n+     *\n+     * <p><code>Null</code> and empty String will return\n+     * <code>false</code>.</p>\n+     *\n+     * @param str  the <code>String</code> to check\n+     * @return <code>true</code> if the string is a correctly formatted number\n+     */\n+    public static boolean isNumber(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return false;\n+        }\n+        char[] chars = str.toCharArray();\n+        int sz = chars.length;\n+        boolean hasExp = false;\n+        boolean hasDecPoint = false;\n+        boolean allowSigns = false;\n+        boolean foundDigit = false;\n+        // deal with any possible sign up front\n+        int start = (chars[0] == '-') ? 1 : 0;\n+        if (sz > start + 1) {\n+            if (chars[start] == '0' && chars[start + 1] == 'x') {\n+                int i = start + 2;\n+                if (i == sz) {\n+                    return false; // str == \"0x\"\n+                }\n+                // checking hex (it can't be anything else)\n+                for (; i < chars.length; i++) {\n+                    if ((chars[i] < '0' || chars[i] > '9')\n+                        && (chars[i] < 'a' || chars[i] > 'f')\n+                        && (chars[i] < 'A' || chars[i] > 'F')) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        sz--; // don't want to loop to the last char, check it afterwords\n+              // for type qualifiers\n+        int i = start;\n+        // loop to the next to last char or to the last char if we need another digit to\n+        // make a valid number (e.g. chars[0..5] = \"1234E\")\n+        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                foundDigit = true;\n+                allowSigns = false;\n+\n+            } else if (chars[i] == '.') {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent   \n+                    return false;\n+                }\n+                hasDecPoint = true;\n+            } else if (chars[i] == 'e' || chars[i] == 'E') {\n+                // we've already taken care of hex.\n+                if (hasExp) {\n+                    // two E's\n+                    return false;\n+                }\n+                if (!foundDigit) {\n+                    return false;\n+                }\n+                hasExp = true;\n+                allowSigns = true;\n+            } else if (chars[i] == '+' || chars[i] == '-') {\n+                if (!allowSigns) {\n+                    return false;\n+                }\n+                allowSigns = false;\n+                foundDigit = false; // we need a digit after the E\n+            } else {\n+                return false;\n+            }\n+            i++;\n+        }\n+        if (i < chars.length) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                // no type qualifier, OK\n+                return true;\n+            }\n+            if (chars[i] == 'e' || chars[i] == 'E') {\n+                // can't have an E at the last byte\n+                return false;\n+            }\n+            if (!allowSigns\n+                && (chars[i] == 'd'\n+                    || chars[i] == 'D'\n+                    || chars[i] == 'f'\n+                    || chars[i] == 'F')) {\n+                return foundDigit;\n+            }\n+            if (chars[i] == 'l'\n+                || chars[i] == 'L') {\n+                // not allowing L with an exponent\n+                return foundDigit && !hasExp;\n+            }\n+            // last character is illegal\n+            return false;\n+        }\n+        // allowSigns is true iff the val ends in 'E'\n+        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n+        return !allowSigns && foundDigit;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/RandomUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.util.Random;\n+\n+/**\n+ * <p><code>RandomUtils</code> is a wrapper that supports all possible \n+ * {@link java.util.Random} methods via the {@link java.lang.Math#random()}\n+ * method and its system-wide <code>Random</code> object.\n+ * \n+ * @author Henri Yandell\n+ * @author Gary D. Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class RandomUtils {\n+\n+    /**\n+     * An instance of {@link JVMRandom}.\n+     */\n+    public static final Random JVM_RANDOM = new JVMRandom();\n+\n+// should be possible for JVM_RANDOM?\n+//    public static void nextBytes(byte[]) {\n+//    public synchronized double nextGaussian();\n+//    }\n+\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed int value\n+     * from the Math.random() sequence.</p>\n+     *\n+     * @return the random int\n+     */\n+    public static int nextInt() {\n+        return nextInt(JVM_RANDOM);\n+    }\n+    \n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed int value\n+     * from the given <code>random</code> sequence.</p>\n+     *\n+     * @param random the Random sequence generator.\n+     * @return the random int\n+     */\n+    public static int nextInt(Random random) {\n+        return random.nextInt();\n+    }\n+    \n+    /**\n+     * <p>Returns a pseudorandom, uniformly distributed int value\n+     * between <code>0</code> (inclusive) and the specified value\n+     * (exclusive), from the Math.random() sequence.</p>\n+     *\n+     * @param n  the specified exclusive max-value\n+     * @return the random int\n+     */\n+    public static int nextInt(int n) {\n+        return nextInt(JVM_RANDOM, n);\n+    }\n+    \n+    /**\n+     * <p>Returns a pseudorandom, uniformly distributed int value\n+     * between <code>0</code> (inclusive) and the specified value\n+     * (exclusive), from the given Random sequence.</p>\n+     *\n+     * @param random the Random sequence generator.\n+     * @param n  the specified exclusive max-value\n+     * @return the random int\n+     */\n+    public static int nextInt(Random random, int n) {\n+        // check this cannot return 'n'\n+        return random.nextInt(n);\n+    }\n+    \n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed long value\n+     * from the Math.random() sequence.</p>\n+     *\n+     * @return the random long\n+     */\n+    public static long nextLong() {\n+        return nextLong(JVM_RANDOM);\n+    }\n+\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed long value\n+     * from the given Random sequence.</p>\n+     *\n+     * @param random the Random sequence generator.\n+     * @return the random long\n+     */\n+    public static long nextLong(Random random) {\n+        return random.nextLong();\n+    }\n+    \n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed boolean value\n+     * from the Math.random() sequence.</p>\n+     *\n+     * @return the random boolean\n+     */\n+    public static boolean nextBoolean() {\n+        return nextBoolean(JVM_RANDOM);\n+    }\n+\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed boolean value\n+     * from the given random sequence.</p>\n+     *\n+     * @param random the Random sequence generator.\n+     * @return the random boolean\n+     */\n+    public static boolean nextBoolean(Random random) {\n+        return random.nextBoolean();\n+    }\n+    \n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed float value\n+     * between <code>0.0</code> and <code>1.0</code> from the Math.random()\n+     * sequence.</p>\n+     *\n+     * @return the random float\n+     */\n+    public static float nextFloat() {\n+        return nextFloat(JVM_RANDOM);\n+    }\n+\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed float value\n+     * between <code>0.0</code> and <code>1.0</code> from the given Random\n+     * sequence.</p>\n+     *\n+     * @param random the Random sequence generator.\n+     * @return the random float\n+     */\n+    public static float nextFloat(Random random) {\n+        return random.nextFloat();\n+    }\n+    \n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed float value\n+     * between <code>0.0</code> and <code>1.0</code> from the Math.random()\n+     * sequence.</p>\n+     *\n+     * @return the random double\n+     */\n+    public static double nextDouble() {\n+        return nextDouble(JVM_RANDOM);\n+    }\n+\n+    /**\n+     * <p>Returns the next pseudorandom, uniformly distributed float value\n+     * between <code>0.0</code> and <code>1.0</code> from the given Random\n+     * sequence.</p>\n+     *\n+     * @param random the Random sequence generator.\n+     * @return the random double\n+     */\n+    public static double nextDouble(Random random) {\n+        return random.nextDouble();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/math/Range.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+/**\n+ * <p><code>Range</code> represents a range of numbers of the same type.</p>\n+ * \n+ * <p>Specific subclasses hold the range values as different types. Each\n+ * subclass should be immutable and {@link java.io.Serializable Serializable}\n+ * if possible.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public abstract class Range {\n+\n+    /**\n+     * <p>Constructs a new range.</p>\n+     */\n+    public Range() {\n+        super();\n+    }\n+\n+    // Accessors\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the minimum number in this range.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public abstract Number getMinimumNumber();\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>long</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumNumber()} method. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public long getMinimumLong() {\n+        return getMinimumNumber().longValue();\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>int</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumNumber()} method. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public int getMinimumInteger() {\n+        return getMinimumNumber().intValue();\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>double</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumNumber()} method. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public double getMinimumDouble() {\n+        return getMinimumNumber().doubleValue();\n+    }\n+\n+    /**\n+     * <p>Gets the minimum number in this range as a <code>float</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumNumber()} method. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the minimum number in this range\n+     */\n+    public float getMinimumFloat() {\n+        return getMinimumNumber().floatValue();\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public abstract Number getMaximumNumber();\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>long</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMaximumNumber()} method. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public long getMaximumLong() {\n+        return getMaximumNumber().longValue();\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>int</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMaximumNumber()} method. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public int getMaximumInteger() {\n+        return getMaximumNumber().intValue();\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>double</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMaximumNumber()} method. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public double getMaximumDouble() {\n+        return getMaximumNumber().doubleValue();\n+    }\n+\n+    /**\n+     * <p>Gets the maximum number in this range as a <code>float</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMaximumNumber()} method. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the maximum number in this range\n+     */\n+    public float getMaximumFloat() {\n+        return getMaximumNumber().floatValue();\n+    }\n+\n+    // Include tests\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Tests whether the specified <code>Number</code> occurs within\n+     * this range.</p>\n+     * \n+     * <p>The exact comparison implementation varies by subclass. It is\n+     * intended that an <code>int</code> specific subclass will compare using\n+     * <code>int</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param number  the number to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this range\n+     * @throws IllegalArgumentException if the <code>Number</code> cannot be compared\n+     */\n+    public abstract boolean containsNumber(Number number);\n+\n+    /**\n+     * <p>Tests whether the specified <code>Number</code> occurs within\n+     * this range using <code>long</code> comparison..</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * <p>This implementation forwards to the {@link #containsLong(long)} method.</p>\n+     *\n+     * @param value  the long to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>long</code> comparison\n+     */\n+    public boolean containsLong(Number value) {\n+        if (value == null) {\n+            return false;\n+        }\n+        return containsLong(value.longValue());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>long</code> occurs within\n+     * this range using <code>long</code> comparison.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumLong()} and \n+     * {@link #getMaximumLong()} methods and should be good for most uses.</p>\n+     * \n+     * @param value  the long to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>long</code> comparison\n+     */\n+    public boolean containsLong(long value) {\n+        return value >= getMinimumLong() && value <= getMaximumLong();\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>Number</code> occurs within\n+     * this range using <code>int</code> comparison..</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * <p>This implementation forwards to the {@link #containsInteger(int)} method.</p>\n+     *\n+     * @param value  the integer to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>int</code> comparison\n+     */\n+    public boolean containsInteger(Number value) {\n+        if (value == null) {\n+            return false;\n+        }\n+        return containsInteger(value.intValue());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>int</code> occurs within\n+     * this range using <code>int</code> comparison.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumInteger()} and \n+     * {@link #getMaximumInteger()} methods and should be good for most uses.</p>\n+     * \n+     * @param value  the int to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>int</code> comparison\n+     */\n+    public boolean containsInteger(int value) {\n+        return value >= getMinimumInteger() && value <= getMaximumInteger();\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>Number</code> occurs within\n+     * this range using <code>double</code> comparison..</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * <p>This implementation forwards to the {@link #containsDouble(double)} method.</p>\n+     *\n+     * @param value  the double to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>double</code> comparison\n+     */\n+    public boolean containsDouble(Number value) {\n+        if (value == null) {\n+            return false;\n+        }\n+        return containsDouble(value.doubleValue());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>double</code> occurs within\n+     * this range using <code>double</code> comparison.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumDouble()} and \n+     * {@link #getMaximumDouble()} methods and should be good for most uses.</p>\n+     * \n+     * @param value  the double to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>double</code> comparison\n+     */\n+    public boolean containsDouble(double value) {\n+        int compareMin = NumberUtils.compare(getMinimumDouble(), value);\n+        int compareMax = NumberUtils.compare(getMaximumDouble(), value);\n+        return compareMin <= 0 && compareMax >= 0;\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>Number</code> occurs within\n+     * this range using <code>float</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * <p>This implementation forwards to the {@link #containsFloat(float)} method.</p>\n+     *\n+     * @param value  the float to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>float</code> comparison\n+     */\n+    public boolean containsFloat(Number value) {\n+        if (value == null) {\n+            return false;\n+        }\n+        return containsFloat(value.floatValue());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified <code>float</code> occurs within\n+     * this range using <code>float</code> comparison.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumFloat()} and \n+     * {@link #getMaximumFloat()} methods and should be good for most uses.</p>\n+     * \n+     * @param value  the float to test\n+     * @return <code>true</code> if the specified number occurs within this\n+     *  range by <code>float</code> comparison\n+     */\n+    public boolean containsFloat(float value) {\n+        int compareMin = NumberUtils.compare(getMinimumFloat(), value);\n+        int compareMax = NumberUtils.compare(getMaximumFloat(), value);\n+        return compareMin <= 0 && compareMax >= 0;\n+    }\n+\n+    // Range tests\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Tests whether the specified range occurs entirely within this range.</p>\n+     * \n+     * <p>The exact comparison implementation varies by subclass. It is\n+     * intended that an <code>int</code> specific subclass will compare using\n+     * <code>int</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #containsNumber(Number)} method.\n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range occurs entirely within\n+     *  this range; otherwise, <code>false</code>\n+     * @throws IllegalArgumentException if the <code>Range</code> cannot be compared\n+     */\n+    public boolean containsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return containsNumber(range.getMinimumNumber()) \n+            && containsNumber(range.getMaximumNumber());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range overlaps with this range.</p>\n+     * \n+     * <p>The exact comparison implementation varies by subclass. It is\n+     * intended that an <code>int</code> specific subclass will compare using\n+     * <code>int</code> comparison.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * <p>This implementation uses the {@link #containsNumber(Number)} and\n+     * {@link #containsRange(Range)} methods.\n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range overlaps with this\n+     *  range; otherwise, <code>false</code>\n+     * @throws IllegalArgumentException if the <code>Range</code> cannot be compared\n+     */\n+    public boolean overlapsRange(Range range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return range.containsNumber(getMinimumNumber())\n+            || range.containsNumber(getMaximumNumber())\n+            || containsNumber(range.getMinimumNumber());\n+    }\n+\n+    // Basics\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this range to another object to test if they are equal.</p>.\n+     * \n+     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumNumber()} and \n+     * {@link #getMaximumNumber()} methods. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        } else if (obj == null || obj.getClass() != getClass()) {\n+            return false;\n+        } else {\n+            Range range = (Range) obj;\n+            return getMinimumNumber().equals(range.getMinimumNumber()) &&\n+                   getMaximumNumber().equals(range.getMaximumNumber());\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the range.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumNumber()} and \n+     * {@link #getMaximumNumber()} methods. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        int result = 17;\n+        result = 37 * result + getClass().hashCode();\n+        result = 37 * result + getMinimumNumber().hashCode();\n+        result = 37 * result + getMaximumNumber().hashCode();\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Gets the range as a <code>String</code>.</p>\n+     *\n+     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     * \n+     * <p>This implementation uses the {@link #getMinimumNumber()} and \n+     * {@link #getMaximumNumber()} methods. \n+     * Subclasses may be able to optimise this.</p>\n+     *\n+     * @return the <code>String</code> representation of this range\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(32);\n+        buf.append(\"Range[\");\n+        buf.append(getMinimumNumber());\n+        buf.append(',');\n+        buf.append(getMaximumNumber());\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/Mutable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * Provides mutable access to a value.\n+ * <p>\n+ * <code>Mutable</code> is used as a generic interface to the implementations in this package.\n+ * <p>\n+ * A typical use case would be to enable a primitive or string to be passed to a method and allow that method to\n+ * effectively change the value of the primitive/string. Another use case is to store a frequently changing primitive in\n+ * a collection (for example a total in a map) without needing to create new Integer/Long wrapper objects.\n+ * \n+ * @author Matthew Hawthorne\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public interface Mutable {\n+\n+    /**\n+     * Gets the value of this mutable.\n+     * \n+     * @return the stored value\n+     */\n+    Object getValue();\n+\n+    /**\n+     * Sets the value of this mutable.\n+     * \n+     * @param value\n+     *            the value to store\n+     * @throws NullPointerException\n+     *             if the object is null and null is invalid\n+     * @throws ClassCastException\n+     *             if the type is invalid\n+     */\n+    void setValue(Object value);\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/MutableBoolean.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A mutable <code>boolean</code> wrapper.\n+ * \n+ * @see Boolean\n+ * @since 2.2\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableBoolean implements Mutable, Serializable, Comparable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -4830728138360036487L;\n+\n+    /** The mutable value. */\n+    private boolean value;\n+\n+    /**\n+     * Constructs a new MutableBoolean with the default value of false.\n+     */\n+    public MutableBoolean() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableBoolean with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     */\n+    public MutableBoolean(boolean value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableBoolean with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     * @throws NullPointerException\n+     *             if the object is null\n+     */\n+    public MutableBoolean(Boolean value) {\n+        super();\n+        this.value = value.booleanValue();\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Returns the value of this MutableBoolean as a boolean.\n+     * \n+     * @return the boolean value represented by this object.\n+     */\n+    public boolean booleanValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param obj\n+     *            the mutable to compare to\n+     * @return zero if this object represents the same boolean value as the argument; a positive value if this object\n+     *         represents true and the argument represents false; and a negative value if this object represents false\n+     *         and the argument represents true\n+     * @throws ClassCastException\n+     *             if the argument is not a MutableInt\n+     */\n+    public int compareTo(Object obj) {\n+        MutableBoolean other = (MutableBoolean) obj;\n+        boolean anotherVal = other.value;\n+        return value == anotherVal ? 0 : (value ? 1 : -1);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is an <code>MutableBoolean</code> object that contains the same\n+     * <code>boolean</code> value as this object.\n+     * \n+     * @param obj\n+     *            the object to compare with.\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableBoolean) {\n+            return value == ((MutableBoolean) obj).booleanValue();\n+        }\n+        return false;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Boolean instance.\n+     * \n+     * @return the value as a Boolean\n+     */\n+    public Object getValue() {\n+        return new Boolean(this.value);\n+    }\n+\n+    /**\n+     * Returns a suitable hashcode for this mutable.\n+     * \n+     * @return the integer <code>1231</code> if this object represents <code>true</code>; returns the integer\n+     *         <code>1237</code> if this object represents <code>false</code>.\n+     */\n+    public int hashCode() {\n+        return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode();\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value\n+     *            the value to set\n+     */\n+    public void setValue(boolean value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Boolean instance.\n+     * \n+     * @param value\n+     *            the value to set\n+     * @throws NullPointerException\n+     *             if the object is null\n+     * @throws ClassCastException\n+     *             if the type is not a {@link Boolean}\n+     */\n+    public void setValue(Object value) {\n+        setValue(((Boolean) value).booleanValue());\n+    }\n+\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/MutableByte.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>byte</code> wrapper.\n+ * \n+ * @see Byte\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class MutableByte extends Number implements Comparable, Mutable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -1585823265L;\n+\n+    /** The mutable value. */\n+    private byte value;\n+\n+    /**\n+     * Constructs a new MutableByte with the default value of zero.\n+     */\n+    public MutableByte() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableByte with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     */\n+    public MutableByte(byte value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableByte with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     * @throws NullPointerException\n+     *             if the object is null\n+     */\n+    public MutableByte(Number value) {\n+        super();\n+        this.value = value.byteValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Byte instance.\n+     * \n+     * @return the value as a Byte\n+     */\n+    public Object getValue() {\n+        return new Byte(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value\n+     *            the value to set\n+     */\n+    public void setValue(byte value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value\n+     *            the value to set\n+     * @throws NullPointerException\n+     *             if the object is null\n+     * @throws ClassCastException\n+     *             if the type is not a {@link Number}\n+     */\n+    public void setValue(Object value) {\n+        setValue(((Number) value).byteValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue relies on Number implementation\n+    /**\n+     * Returns the value of this MutableByte as a byte.\n+     *\n+     * @return the numeric value represented by this object after conversion to type byte.\n+     */\n+    public byte byteValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Byte.\n+     *\n+     * @return a Byte instance containing the value from this mutable\n+     */\n+    public Byte toByte() {\n+        return new Byte(byteValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(byte operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.byteValue();\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(byte operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.byteValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableByte</code> object that contains the same <code>byte</code>\n+     * value as this object.\n+     * \n+     * @param obj\n+     *            the object to compare with.\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableByte) {\n+            return value == ((MutableByte) obj).byteValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hashcode for this mutable.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param obj\n+     *            the mutable to compare to\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the argument is not a MutableByte\n+     */\n+    public int compareTo(Object obj) {\n+        MutableByte other = (MutableByte) obj;\n+        byte anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/MutableDouble.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import org.apache.commons.lang.math.NumberUtils;\n+\n+/**\n+ * A mutable <code>double</code> wrapper.\n+ * \n+ * @see Double\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class MutableDouble extends Number implements Comparable, Mutable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1587163916L;\n+\n+    /** The mutable value. */\n+    private double value;\n+\n+    /**\n+     * Constructs a new MutableDouble with the default value of zero.\n+     */\n+    public MutableDouble() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableDouble with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     */\n+    public MutableDouble(double value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableDouble with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     * @throws NullPointerException\n+     *             if the object is null\n+     */\n+    public MutableDouble(Number value) {\n+        super();\n+        this.value = value.doubleValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Double instance.\n+     * \n+     * @return the value as a Double\n+     */\n+    public Object getValue() {\n+        return new Double(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value\n+     *            the value to set\n+     */\n+    public void setValue(double value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value\n+     *            the value to set\n+     * @throws NullPointerException\n+     *             if the object is null\n+     * @throws ClassCastException\n+     *             if the type is not a {@link Number}\n+     */\n+    public void setValue(Object value) {\n+        setValue(((Number) value).doubleValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableDouble as a int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    public long longValue() {\n+        return (long) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    public float floatValue() {\n+        return (float) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Checks whether the double value is the special NaN value.\n+     * \n+     * @return true if NaN\n+     */\n+    public boolean isNaN() {\n+        return Double.isNaN(value);\n+    }\n+\n+    /**\n+     * Checks whether the double value is infinite.\n+     * \n+     * @return true if infinite\n+     */\n+    public boolean isInfinite() {\n+        return Double.isInfinite(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Double.\n+     *\n+     * @return a Double instance containing the value from this mutable\n+     */\n+    public Double toDouble() {\n+        return new Double(doubleValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(double operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.doubleValue();\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(double operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.doubleValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>Double</code> object that represents a double that has the identical\n+     * bit pattern to the bit pattern of the double represented by this object. For this purpose, two\n+     * <code>double</code> values are considered to be the same if and only if the method\n+     * {@link Double#doubleToLongBits(double)}returns the same long value when applied to each.\n+     * <p>\n+     * Note that in most cases, for two instances of class <code>Double</code>,<code>d1</code> and <code>d2</code>,\n+     * the value of <code>d1.equals(d2)</code> is <code>true</code> if and only if <blockquote>\n+     * \n+     * <pre>\n+     *   d1.doubleValue()&nbsp;== d2.doubleValue()\n+     * </pre>\n+     * \n+     * </blockquote>\n+     * <p>\n+     * also has the value <code>true</code>. However, there are two exceptions:\n+     * <ul>\n+     * <li>If <code>d1</code> and <code>d2</code> both represent <code>Double.NaN</code>, then the\n+     * <code>equals</code> method returns <code>true</code>, even though <code>Double.NaN==Double.NaN</code> has\n+     * the value <code>false</code>.\n+     * <li>If <code>d1</code> represents <code>+0.0</code> while <code>d2</code> represents <code>-0.0</code>,\n+     * or vice versa, the <code>equal</code> test has the value <code>false</code>, even though\n+     * <code>+0.0==-0.0</code> has the value <code>true</code>. This allows hashtables to operate properly.\n+     * </ul>\n+     * \n+     * @param obj\n+     *            the object to compare with.\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(Object obj) {\n+        return (obj instanceof MutableDouble)\n+            && (Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * Returns a suitable hashcode for this mutable.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        long bits = Double.doubleToLongBits(value);\n+        return (int) (bits ^ (bits >>> 32));\n+    }\n+\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param obj\n+     *            the mutable to compare to\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the argument is not a MutableDouble\n+     */\n+    public int compareTo(Object obj) {\n+        MutableDouble other = (MutableDouble) obj;\n+        double anotherVal = other.value;\n+        return NumberUtils.compare(value, anotherVal);\n+    }\n+\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/MutableFloat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import org.apache.commons.lang.math.NumberUtils;\n+\n+/**\n+ * A mutable <code>float</code> wrapper.\n+ * \n+ * @see Float\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class MutableFloat extends Number implements Comparable, Mutable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 5787169186L;\n+\n+    /** The mutable value. */\n+    private float value;\n+\n+    /**\n+     * Constructs a new MutableFloat with the default value of zero.\n+     */\n+    public MutableFloat() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableFloat with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     */\n+    public MutableFloat(float value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableFloat with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     * @throws NullPointerException\n+     *             if the object is null\n+     */\n+    public MutableFloat(Number value) {\n+        super();\n+        this.value = value.floatValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Float instance.\n+     * \n+     * @return the value as a Float\n+     */\n+    public Object getValue() {\n+        return new Float(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value\n+     *            the value to set\n+     */\n+    public void setValue(float value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value\n+     *            the value to set\n+     * @throws NullPointerException\n+     *             if the object is null\n+     * @throws ClassCastException\n+     *             if the type is not a {@link Number}\n+     */\n+    public void setValue(Object value) {\n+        setValue(((Number) value).floatValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(float operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.floatValue();\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(float operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.floatValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableFloat as a int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    public long longValue() {\n+        return (long) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Checks whether the float value is the special NaN value.\n+     * \n+     * @return true if NaN\n+     */\n+    public boolean isNaN() {\n+        return Float.isNaN(value);\n+    }\n+\n+    /**\n+     * Checks whether the float value is infinite.\n+     * \n+     * @return true if infinite\n+     */\n+    public boolean isInfinite() {\n+        return Float.isInfinite(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Float.\n+     *\n+     * @return a Float instance containing the value from this mutable\n+     */\n+    public Float toFloat() {\n+        return new Float(floatValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against some other object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is a <code>Float</code> object that represents a <code>float</code> that has the\n+     * identical bit pattern to the bit pattern of the <code>float</code> represented by this object. For this\n+     * purpose, two float values are considered to be the same if and only if the method\n+     * {@link Float#floatToIntBits(float)}returns the same int value when applied to each.\n+     * <p>\n+     * Note that in most cases, for two instances of class <code>Float</code>,<code>f1</code> and <code>f2</code>,\n+     * the value of <code>f1.equals(f2)</code> is <code>true</code> if and only if <blockquote>\n+     * \n+     * <pre>\n+     *   f1.floatValue() == f2.floatValue()\n+     * </pre>\n+     * \n+     * </blockquote>\n+     * <p>\n+     * also has the value <code>true</code>. However, there are two exceptions:\n+     * <ul>\n+     * <li>If <code>f1</code> and <code>f2</code> both represent <code>Float.NaN</code>, then the\n+     * <code>equals</code> method returns <code>true</code>, even though <code>Float.NaN==Float.NaN</code> has\n+     * the value <code>false</code>.\n+     * <li>If <code>f1</code> represents <code>+0.0f</code> while <code>f2</code> represents <code>-0.0f</code>,\n+     * or vice versa, the <code>equal</code> test has the value <code>false</code>, even though\n+     * <code>0.0f==-0.0f</code> has the value <code>true</code>.\n+     * </ul>\n+     * This definition allows hashtables to operate properly.\n+     * \n+     * @param obj\n+     *            the object to be compared\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     * @see java.lang.Float#floatToIntBits(float)\n+     */\n+    public boolean equals(Object obj) {\n+        return (obj instanceof MutableFloat)\n+            && (Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a suitable hashcode for this mutable.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        return Float.floatToIntBits(value);\n+    }\n+\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param obj\n+     *            the mutable to compare to\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(Object obj) {\n+        MutableFloat other = (MutableFloat) obj;\n+        float anotherVal = other.value;\n+        return NumberUtils.compare(value, anotherVal);\n+    }\n+\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/MutableInt.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>int</code> wrapper.\n+ * \n+ * @see Integer\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class MutableInt extends Number implements Comparable, Mutable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 512176391864L;\n+\n+    /** The mutable value. */\n+    private int value;\n+\n+    /**\n+     * Constructs a new MutableInt with the default value of zero.\n+     */\n+    public MutableInt() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableInt with the specified value.\n+     * \n+     * @param value\n+     *                  a value.\n+     */\n+    public MutableInt(int value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableInt with the specified value.\n+     * \n+     * @param value\n+     *                  a value.\n+     * @throws NullPointerException\n+     *                  if the object is null\n+     */\n+    public MutableInt(Number value) {\n+        super();\n+        this.value = value.intValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Integer instance.\n+     * \n+     * @return the value as a Integer\n+     */\n+    public Object getValue() {\n+        return new Integer(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value\n+     *                  the value to set\n+     */\n+    public void setValue(int value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value\n+     *                  the value to set\n+     * @throws NullPointerException\n+     *                  if the object is null\n+     * @throws ClassCastException\n+     *                  if the type is not a {@link Number}\n+     */\n+    public void setValue(Object value) {\n+        setValue(((Number) value).intValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(int operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.intValue();\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(int operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.intValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableInt as a int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Integer.\n+     *\n+     * @return a Integer instance containing the value from this mutable\n+     */\n+    public Integer toInteger() {\n+        return new Integer(intValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is an <code>MutableInt</code> object that contains the same <code>int</code> value\n+     * as this object.\n+     * \n+     * @param obj\n+     *                  the object to compare with.\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableInt) {\n+            return value == ((MutableInt) obj).intValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hashcode for this mutable.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param obj\n+     *                  the mutable to compare to\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the argument is not a MutableInt\n+     */\n+    public int compareTo(Object obj) {\n+        MutableInt other = (MutableInt) obj;\n+        int anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/MutableLong.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>long</code> wrapper.\n+ * \n+ * @see Long\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class MutableLong extends Number implements Comparable, Mutable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 62986528375L;\n+\n+    /** The mutable value. */\n+    private long value;\n+\n+    /**\n+     * Constructs a new MutableLong with the default value of zero.\n+     */\n+    public MutableLong() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableLong with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     */\n+    public MutableLong(long value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableLong with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     * @throws NullPointerException\n+     *             if the object is null\n+     */\n+    public MutableLong(Number value) {\n+        super();\n+        this.value = value.longValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Long instance.\n+     * \n+     * @return the value as a Long\n+     */\n+    public Object getValue() {\n+        return new Long(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value\n+     *            the value to set\n+     */\n+    public void setValue(long value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value\n+     *            the value to set\n+     * @throws NullPointerException\n+     *             if the object is null\n+     * @throws ClassCastException\n+     *             if the type is not a {@link Number}\n+     */\n+    public void setValue(Object value) {\n+        setValue(((Number) value).longValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(long operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.longValue();\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(long operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.longValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableLong as a int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Long.\n+     *\n+     * @return a Long instance containing the value from this mutable\n+     */\n+    public Long toLong() {\n+        return new Long(longValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableLong</code> object that contains the same <code>long</code>\n+     * value as this object.\n+     * \n+     * @param obj\n+     *            the object to compare with.\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableLong) {\n+            return value == ((MutableLong) obj).longValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hashcode for this mutable.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        return (int) (value ^ (value >>> 32));\n+    }\n+\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param obj\n+     *            the mutable to compare to\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the argument is not a MutableLong\n+     */\n+    public int compareTo(Object obj) {\n+        MutableLong other = (MutableLong) obj;\n+        long anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/MutableObject.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A mutable <code>Object</code> wrapper.\n+ * \n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class MutableObject implements Mutable, Serializable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 86241875189L;\n+\n+    /** The mutable value. */\n+    private Object value;\n+\n+    /**\n+     * Constructs a new MutableObject with the default value of <code>null</code>.\n+     */\n+    public MutableObject() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableObject with the specified value.\n+     * \n+     * @param value\n+     *            a value.\n+     */\n+    public MutableObject(Object value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value.\n+     * \n+     * @return the value\n+     */\n+    public Object getValue() {\n+        return this.value;\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value\n+     *            the value to set\n+     */\n+    public void setValue(Object value) {\n+        this.value = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableObject</code> object that contains the same <code>Object</code>\n+     * value as this object.\n+     * \n+     * @param obj\n+     *            the object to compare with.\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableObject) {\n+            Object other = ((MutableObject) obj).value;\n+            return value == other || (value != null && value.equals(other));\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the value's hash code or <code>0</code> if the value is <code>null</code>.\n+     * \n+     * @return the value's hash code or <code>0</code> if the value is <code>null</code>.\n+     */\n+    public int hashCode() {\n+        return value == null ? 0 : value.hashCode();\n+    }\n+\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    public String toString() {\n+        return value == null ? \"null\" : value.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/mutable/MutableShort.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+/**\n+ * A mutable <code>short</code> wrapper.\n+ * \n+ * @see Short\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class MutableShort extends Number implements Comparable, Mutable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -2135791679L;\n+\n+    /** The mutable value. */\n+    private short value;\n+\n+    /**\n+     * Constructs a new MutableShort with the default value of zero.\n+     */\n+    public MutableShort() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableShort with the specified value.\n+     * \n+     * @param value\n+     *                  a value.\n+     */\n+    public MutableShort(short value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableShort with the specified value.\n+     * \n+     * @param value\n+     *                  a value.\n+     * @throws NullPointerException\n+     *                  if the object is null\n+     */\n+    public MutableShort(Number value) {\n+        super();\n+        this.value = value.shortValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Short instance.\n+     * \n+     * @return the value as a Short\n+     */\n+    public Object getValue() {\n+        return new Short(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value\n+     *                  the value to set\n+     */\n+    public void setValue(short value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value\n+     *                  the value to set\n+     * @throws NullPointerException\n+     *                  if the object is null\n+     * @throws ClassCastException\n+     *                  if the type is not a {@link Number}\n+     */\n+    public void setValue(Object value) {\n+        setValue(((Number) value).shortValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(short operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.shortValue();\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(short operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value.\n+     * \n+     * @param operand\n+     *            the value to add\n+     * @throws NullPointerException\n+     *             if the object is null\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.shortValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // bytValue relies on Number implementation\n+    /**\n+     * Returns the value of this MutableShort as a short.\n+     *\n+     * @return the numeric value represented by this object after conversion to type short.\n+     */\n+    public short shortValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Short.\n+     *\n+     * @return a Short instance containing the value from this mutable\n+     */\n+    public Short toShort() {\n+        return new Short(shortValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableShort</code> object that contains the same <code>short</code>\n+     * value as this object.\n+     * \n+     * @param obj\n+     *                  the object to compare with.\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableShort) {\n+            return value == ((MutableShort) obj).shortValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hashcode for this mutable.\n+     * \n+     * @return a suitable hashcode\n+     */\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param obj\n+     *                  the mutable to compare to\n+     * @return negative if this is less, zero if equal, positive if greater\n+     * @throws ClassCastException if the argument is not a MutableShort\n+     */\n+    public int compareTo(Object obj) {\n+        MutableShort other = (MutableShort) obj;\n+        short anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/text/CompositeFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+\n+/**\n+ * Formats using one formatter and parses using a different formatter.\n+ * An example of use for this would be a webapp where data is taken in one way\n+ * and stored in a database another way.\n+ *\n+ * @author Archimedes Trajano\n+ * @version $Id: $\n+ */\n+public class CompositeFormat extends Format {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -4329119827877627683L;\n+\n+    /** The parser to use. */\n+    private final Format parser;\n+    /** The formatter to use. */\n+    private final Format formatter;\n+\n+    /**\n+     * Create a format that points its parseObject method to one implementation \n+     * and its format method to another. \n+     *\n+     * @param parser implementation\n+     * @param formatter implementation\n+     */\n+    public CompositeFormat(Format parser, Format formatter) {\n+        this.parser = parser;\n+        this.formatter = formatter;\n+    }\n+\n+    /**\n+     * Uses the formatter Format instance. \n+     *\n+     * @see Format#format(Object, StringBuffer, FieldPosition)\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        return formatter.format(obj,toAppendTo,pos);\n+    }\n+\n+    /**\n+     * Uses the parser Format instance. \n+     *\n+     * @see Format#parseObject(String, ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parser.parseObject(source,pos);\n+    }\n+\n+    /**\n+     * Provides access to the parser Format implementation. \n+     *\n+     * @return parser Format implementation\n+     */\n+    public Format getParser() {\n+        return this.parser;\n+    }\n+\n+    /**\n+     * Provides access to the parser Format implementation. \n+     *\n+     * @return formatter Format implementation\n+     */\n+    public Format getFormatter() {\n+        return this.formatter;\n+    }\n+\n+    /**\n+     * Utility method to parse and then reformat a String. \n+     * \n+     * @param input String to reformat\n+     * @return A reformatted String\n+     * @throws ParseException thrown by parseObject(String) call\n+     */\n+    public String reformat(String input) throws ParseException {\n+        return format(parseObject(input));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/text/StrBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Builds a string from constituent parts providing a more flexible and powerful API\n+ * than StringBuffer.\n+ * <p>\n+ * The main differences from StringBuffer/StringBuilder are:\n+ * <ul>\n+ * <li>Not synchronized</li>\n+ * <li>Not final</li>\n+ * <li>Subclasses have direct access to character array</li>\n+ * <li>Additional methods\n+ *  <ul>\n+ *   <li>appendWithSeparators - adds an array of values, with a separator</li>\n+ *   <li>appendPadding - adds a length padding characters</li>\n+ *   <li>appendFixedLength - adds a fixed width field to the builder</li>\n+ *   <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n+ *   <li>delete - delete char or string</li>\n+ *   <li>replace - search and replace for a char or string</li>\n+ *   <li>leftString/rightString/midString - substring without exceptions</li>\n+ *   <li>contains - whether the builder contains a char or string</li>\n+ *   <li>size/clear/isEmpty - collections style API methods</li>\n+ *  </ul>\n+ * </li>\n+ * </ul>\n+ * <li>Views\n+ *  <ul>\n+ *   <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n+ *   <li>asReader - uses the internal buffer as the source of a Reader</li>\n+ *   <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n+ *  </ul>\n+ * </li>\n+ * </ul>\n+ * <p>\n+ * The aim has been to provide an API that mimics very closely what StringBuffer\n+ * provides, but with additional methods. It should be noted that some edge cases,\n+ * with invalid indices or null input, have been altered - see individual methods.\n+ * The biggest of these changes is that by default, null will not output the text\n+ * 'null'. This can be controlled by a property, {@link #setNullText(String)}.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class StrBuilder implements Cloneable {\n+\n+    /**\n+     * The extra capacity for new builders.\n+     */\n+    static final int CAPACITY = 32;\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 7628716375283629643L;\n+\n+    /** Internal data storage. */\n+    protected char[] buffer;\n+    /** Current size of the buffer. */\n+    protected int size;\n+    /** The new line. */\n+    private String newLine;\n+    /** The null text. */\n+    private String nullText;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates an empty builder initial capacity 32 characters.\n+     */\n+    public StrBuilder() {\n+        this(CAPACITY);\n+    }\n+\n+    /**\n+     * Constructor that creates an empty builder the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n+     */\n+    public StrBuilder(int initialCapacity) {\n+        super();\n+        if (initialCapacity <= 0) {\n+            initialCapacity = CAPACITY;\n+        }\n+        buffer = new char[initialCapacity];\n+    }\n+\n+    /**\n+     * Constructor that creates a builder from the string, allocating\n+     * 32 extra characters for growth.\n+     *\n+     * @param str  the string to copy, null treated as blank string\n+     */\n+    public StrBuilder(String str) {\n+        super();\n+        if (str == null) {\n+            buffer = new char[CAPACITY];\n+        } else {\n+            buffer = new char[str.length() + CAPACITY];\n+            append(str);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the text to be appended when a new line is added.\n+     *\n+     * @return the new line text, null means use system default\n+     */\n+    public String getNewLineText() {\n+        return newLine;\n+    }\n+\n+    /**\n+     * Sets the text to be appended when a new line is added.\n+     *\n+     * @param newLine  the new line text, null means use system default\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder setNewLineText(String newLine) {\n+        this.newLine = newLine;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the text to be appended when null is added.\n+     *\n+     * @return the null text, null means no append\n+     */\n+    public String getNullText() {\n+        return nullText;\n+    }\n+\n+    /**\n+     * Sets the text to be appended when null is added.\n+     *\n+     * @param nullText  the null text, null means no append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder setNullText(String nullText) {\n+        if (nullText != null && nullText.length() == 0) {\n+            nullText = null;\n+        }\n+        this.nullText = nullText;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of the string builder.\n+     *\n+     * @return the length\n+     */\n+    public int length() {\n+        return size;\n+    }\n+\n+    /**\n+     * Updates the length of the builder by either dropping the last characters\n+     * or adding filler of unicode zero.\n+     *\n+     * @param length  the length to set to, must be zero or positive\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the length is negative\n+     */\n+    public StrBuilder setLength(int length) {\n+        if (length < 0) {\n+            throw new StringIndexOutOfBoundsException(length);\n+        }\n+        if (length < size) {\n+            size = length;\n+        } else if (length > size) {\n+            ensureCapacity(length);\n+            int oldEnd = size;\n+            int newEnd = length;\n+            size = length;\n+            for (int i = oldEnd; i < newEnd; i++) {\n+                buffer[i] = '\\0';\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current size of the internal character array buffer.\n+     *\n+     * @return the capacity\n+     */\n+    public int capacity() {\n+        return buffer.length;\n+    }\n+\n+    /**\n+     * Checks the capacity and ensures that it is at least the size specified.\n+     *\n+     * @param capacity  the capacity to ensure\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder ensureCapacity(int capacity) {\n+        if (capacity > buffer.length) {\n+            char[] old = buffer;\n+            buffer = new char[capacity];\n+            System.arraycopy(old, 0, buffer, 0, size);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Minimizes the capacity to the actual length of the string.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder minimizeCapacity() {\n+        if (buffer.length > length()) {\n+            char[] old = buffer;\n+            buffer = new char[length()];\n+            System.arraycopy(old, 0, buffer, 0, size);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of the string builder.\n+     * <p>\n+     * This method is the same as {@link #length()} and is provided to match the\n+     * API of Collections.\n+     *\n+     * @return the length\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Checks is the string builder is empty (convenience Collections API style method).\n+     * <p>\n+     * This method is the same as checking {@link #length()} and is provided to match the\n+     * API of Collections.\n+     *\n+     * @return <code>true</code> if the size is <code>0</code>.\n+     */\n+    public boolean isEmpty() {\n+        return size == 0;\n+    }\n+\n+    /**\n+     * Clears the string builder (convenience Collections API style method).\n+     * <p>\n+     * This method does not reduce the size of the internal character buffer.\n+     * To do that, call <code>clear()</code> followed by {@link #minimizeCapacity()}.\n+     * <p>\n+     * This method is the same as {@link #setLength(int)} called with zero\n+     * and is provided to match the API of Collections.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder clear() {\n+        size = 0;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the character at the specified index.\n+     *\n+     * @see #setCharAt(int, char)\n+     * @see #deleteCharAt(int)\n+     * @param index  the index to retrieve, must be valid\n+     * @return the character at the index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public char charAt(int index) {\n+        if (index < 0 || index >= length()) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        return buffer[index];\n+    }\n+\n+    /**\n+     * Sets the character at the specified index.\n+     *\n+     * @see #charAt(int)\n+     * @see #deleteCharAt(int)\n+     * @param index  the index to set\n+     * @param ch  the new character\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder setCharAt(int index, char ch) {\n+        if (index < 0 || index >= length()) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        buffer[index] = ch;\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the character at the specified index.\n+     *\n+     * @see #charAt(int)\n+     * @see #setCharAt(int, char)\n+     * @param index  the index to delete\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder deleteCharAt(int index) {\n+        if (index < 0 || index >= size) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        deleteImpl(index, index + 1, 1);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Copies the builder's character array into a new character array.\n+     * \n+     * @return a new array that represents the contents of the builder\n+     */\n+    public char[] toCharArray() {\n+        if (size == 0) {\n+            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+        }\n+        char chars[] = new char[size];\n+        System.arraycopy(buffer, 0, chars, 0, size);\n+        return chars;\n+    }\n+\n+    /**\n+     * Copies part of the builder's character array into a new character array.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except that\n+     *  if too large it is treated as end of string\n+     * @return a new array that holds part of the contents of the builder\n+     * @throws IndexOutOfBoundsException if startIndex is invalid,\n+     *  or if endIndex is invalid (but endIndex greater than size is valid)\n+     */\n+    public char[] toCharArray(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int len = endIndex - startIndex;\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+        }\n+        char chars[] = new char[len];\n+        System.arraycopy(buffer, startIndex, chars, 0, len);\n+        return chars;\n+    }\n+\n+    /**\n+     * Copies the character array into the specified array.\n+     * \n+     * @param destination  the destination array, null will cause an array to be created\n+     * @return the input array, unless that was null or too small\n+     */\n+    public char[] getChars(char[] destination) {\n+        int len = length();\n+        if (destination == null || destination.length < len) {\n+            destination = new char[len];\n+        }\n+        System.arraycopy(buffer, 0, destination, 0, len);\n+        return destination;\n+    }\n+\n+    /**\n+     * Copies the character array into the specified array.\n+     *\n+     * @param startIndex  first index to copy, inclusive, must be valid\n+     * @param endIndex  last index, exclusive, must be valid\n+     * @param destination  the destination array, must not be null or too small\n+     * @param destinationIndex  the index to start copying in destination\n+     * @throws NullPointerException if the array is null\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n+        if (startIndex < 0) {\n+            throw new StringIndexOutOfBoundsException(startIndex);\n+        }\n+        if (endIndex < 0 || endIndex > length()) {\n+            throw new StringIndexOutOfBoundsException(endIndex);\n+        }\n+        if (startIndex > endIndex) {\n+            throw new StringIndexOutOfBoundsException(\"end < start\");\n+        }\n+        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends the new line string to this string builder.\n+     * <p>\n+     * The new line string can be altered using {@link #setNewLineText(String)}.\n+     * This might be used to force the output to always use Unix line endings\n+     * even when on Windows.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendNewLine() {\n+        if (newLine == null)  {\n+            append(SystemUtils.LINE_SEPARATOR);\n+            return this;\n+        }\n+        return append(newLine);\n+    }\n+\n+    /**\n+     * Appends the text representing <code>null</code> to this string builder.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendNull() {\n+        if (nullText == null)  {\n+            return this;\n+        }\n+        return append(nullText);\n+    }\n+\n+    /**\n+     * Appends an object to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param obj  the object to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(Object obj) {\n+        if (obj == null) {\n+            return appendNull();\n+        } \n+        return append(obj.toString());        \n+    }\n+\n+    /**\n+     * Appends a string to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(String str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            str.getChars(0, strLen, buffer, len);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(String str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a string buffer to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string buffer to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StringBuffer str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            str.getChars(0, strLen, buffer, len);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string buffer to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StringBuffer str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends another string builder to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string builder to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StrBuilder str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            System.arraycopy(str.buffer, 0, buffer, len, strLen);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string builder to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StrBuilder str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char array to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char[] chars) {\n+        if (chars == null) {\n+            return appendNull();\n+        }\n+        int strLen = chars.length;\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            System.arraycopy(chars, 0, buffer, len, strLen);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char array to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char[] chars, int startIndex, int length) {\n+        if (chars == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n+        }\n+        if (length < 0 || (startIndex + length) > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            System.arraycopy(chars, startIndex, buffer, len, length);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a boolean value to the string builder.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(boolean value) {\n+        if (value) {\n+            ensureCapacity(size + 4);\n+            buffer[size++] = 't';\n+            buffer[size++] = 'r';\n+            buffer[size++] = 'u';\n+            buffer[size++] = 'e';\n+        } else {\n+            ensureCapacity(size + 5);\n+            buffer[size++] = 'f';\n+            buffer[size++] = 'a';\n+            buffer[size++] = 'l';\n+            buffer[size++] = 's';\n+            buffer[size++] = 'e';\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char value to the string builder.\n+     *\n+     * @param ch  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char ch) {\n+        int len = length();\n+        ensureCapacity(len + 1);\n+        buffer[size++] = ch;\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an int value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(int value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a long value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(long value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a float value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(float value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a double value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(double value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an array placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null array will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param array  the array to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n+        if (array != null && array.length > 0) {\n+            separator = (separator == null ? \"\" : separator);\n+            append(array[0]);\n+            for (int i = 1; i < array.length; i++) {\n+                append(separator);\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a collection placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null collection will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param coll  the collection to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Collection coll, String separator) {\n+        if (coll != null && coll.size() > 0) {\n+            separator = (separator == null ? \"\" : separator);\n+            Iterator it = coll.iterator();\n+            while (it.hasNext()) {\n+                append(it.next());\n+                if (it.hasNext()) {\n+                    append(separator);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an iterator placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null iterator will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param it  the iterator to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Iterator it, String separator) {\n+        if (it != null) {\n+            separator = (separator == null ? \"\" : separator);\n+            while (it.hasNext()) {\n+                append(it.next());\n+                if (it.hasNext()) {\n+                    append(separator);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends the pad character to the builder the specified number of times.\n+     * \n+     * @param length  the length to append, negative means no append\n+     * @param padChar  the character to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendPadding(int length, char padChar) {\n+        if (length >= 0) {\n+            ensureCapacity(size + length);\n+            for (int i = 0; i < length; i++) {\n+                buffer[size++] = padChar;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an object to the builder padding on the left to a fixed width.\n+     * The <code>toString</code> of the object is used.\n+     * If the object is larger than the length, the left hand side is lost.\n+     * If the object is null, the null text value is used.\n+     * \n+     * @param obj  the object to append, null uses null text\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n+        if (width > 0) {\n+            ensureCapacity(size + width);\n+            String str = (obj == null ? getNullText() : obj.toString());\n+            int strLen = str.length();\n+            if (strLen >= width) {\n+                str.getChars(strLen - width, strLen, buffer, size);\n+            } else {\n+                int padLen = width - strLen;\n+                for (int i = 0; i < padLen; i++) {\n+                    buffer[size + i] = padChar;\n+                }\n+                str.getChars(0, strLen, buffer, size + padLen);\n+            }\n+            size += width;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the left to a fixed width.\n+     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n+     * If the formatted value is larger than the length, the left hand side is lost.\n+     * \n+     * @param value  the value to append\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {\n+        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the right to a fixed length.\n+     * The <code>toString</code> of the object is used.\n+     * If the object is larger than the length, the right hand side is lost.\n+     * If the object is null, null text value is used.\n+     * \n+     * @param obj  the object to append, null uses null text\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n+        if (width > 0) {\n+            ensureCapacity(size + width);\n+            String str = (obj == null ? getNullText() : obj.toString());\n+            int strLen = str.length();\n+            if (strLen >= width) {\n+                str.getChars(0, strLen, buffer, size);\n+            } else {\n+                int padLen = width - strLen;\n+                str.getChars(0, strLen, buffer, size);\n+                for (int i = 0; i < padLen; i++) {\n+                    buffer[size + strLen + i] = padChar;\n+                }\n+            }\n+            size += width;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the right to a fixed length.\n+     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n+     * If the object is larger than the length, the right hand side is lost.\n+     * \n+     * @param value  the value to append\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar) {\n+        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inserts the string representation of an object into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param obj  the object to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, Object obj) {\n+        if (obj == null) {\n+            return insert(index, nullText);\n+        }\n+        return insert(index, obj.toString());\n+    }\n+\n+    /**\n+     * Inserts the string into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param str  the string to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, String str) {\n+        validateIndex(index);\n+        if (str == null) {\n+            str = nullText;\n+        }\n+        int strLen = (str == null ? 0 : str.length());\n+        if (strLen > 0) {\n+            int newSize = size + strLen;\n+            ensureCapacity(newSize);\n+            System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n+            size = newSize;\n+            str.getChars(0, strLen, buffer, index);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the character array into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param chars  the char array to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, char chars[]) {\n+        validateIndex(index);\n+        if (chars == null) {\n+            return insert(index, nullText);\n+        }\n+        int len = chars.length;\n+        if (len > 0) {\n+            ensureCapacity(size + len);\n+            System.arraycopy(buffer, index, buffer, index + len, size - index);\n+            System.arraycopy(chars, 0, buffer, index, len);\n+            size += len;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts part of the character array into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param chars  the char array to insert\n+     * @param offset  the offset into the character array to start at, must be valid\n+     * @param length  the length of the character array part to copy, must be positive\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    public StrBuilder insert(int index, char chars[], int offset, int length) {\n+        validateIndex(index);\n+        if (chars == null) {\n+            return insert(index, nullText);\n+        }\n+        if (offset < 0 || offset > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n+        }\n+        if (length < 0 || offset + length > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n+        }\n+        if (length > 0) {\n+            ensureCapacity(size + length);\n+            System.arraycopy(buffer, index, buffer, index + length, size - index);\n+            System.arraycopy(chars, offset, buffer, index, length);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, boolean value) {\n+        validateIndex(index);\n+        if (value) {\n+            ensureCapacity(size + 4);\n+            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n+            buffer[index++] = 't';\n+            buffer[index++] = 'r';\n+            buffer[index++] = 'u';\n+            buffer[index] = 'e';\n+            size += 4;\n+        } else {\n+            ensureCapacity(size + 5);\n+            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n+            buffer[index++] = 'f';\n+            buffer[index++] = 'a';\n+            buffer[index++] = 'l';\n+            buffer[index++] = 's';\n+            buffer[index] = 'e';\n+            size += 5;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, char value) {\n+        validateIndex(index);\n+        ensureCapacity(size + 1);\n+        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n+        buffer[index] = value;\n+        size++;\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, int value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, long value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, float value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, double value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method to delete a range without validation.\n+     *\n+     * @param startIndex  the start index, must be valid\n+     * @param endIndex  the end index (exclusive), must be valid\n+     * @param len  the length, must be valid\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private void deleteImpl(int startIndex, int endIndex, int len) {\n+        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n+        size -= len;\n+    }\n+\n+    /**\n+     * Deletes the characters between the two specified indices.\n+     *\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder delete(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int len = endIndex - startIndex;\n+        if (len > 0) {\n+            deleteImpl(startIndex, endIndex, len);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes the character wherever it occurs in the builder.\n+     *\n+     * @param ch  the character to delete\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(char ch) {\n+        for (int i = 0; i < size; i++) {\n+            if (buffer[i] == ch) {\n+                int start = i;\n+                while (++i < size) {\n+                    if (buffer[i] != ch) {\n+                        break;\n+                    }\n+                }\n+                int len = i - start;\n+                deleteImpl(start, i, len);\n+                i -= len;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the character wherever it occurs in the builder.\n+     *\n+     * @param ch  the character to delete\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(char ch) {\n+        for (int i = 0; i < size; i++) {\n+            if (buffer[i] == ch) {\n+                deleteImpl(i, i + 1, 1);\n+                break;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes the string wherever it occurs in the builder.\n+     *\n+     * @param str  the string to delete, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(String str) {\n+        int len = (str == null ? 0 : str.length());\n+        if (len > 0) {\n+            int index = indexOf(str, 0);\n+            while (index >= 0) {\n+                deleteImpl(index, index + len, len);\n+                index = indexOf(str, index);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the string wherever it occurs in the builder.\n+     *\n+     * @param str  the string to delete, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(String str) {\n+        int len = (str == null ? 0 : str.length());\n+        if (len > 0) {\n+            int index = indexOf(str, 0);\n+            if (index >= 0) {\n+                deleteImpl(index, index + len, len);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes all parts of the builder that the matcher matches.\n+     * <p>\n+     * Matchers can be used to perform advanced deletion behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(StrMatcher matcher) {\n+        return replace(matcher, null, 0, size, -1);\n+    }\n+\n+    /**\n+     * Deletes the first match within the builder using the specified matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced deletion behaviour.\n+     * For example you could write a matcher to delete\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(StrMatcher matcher) {\n+        return replace(matcher, null, 0, size, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method to delete a range without validation.\n+     *\n+     * @param startIndex  the start index, must be valid\n+     * @param endIndex  the end index (exclusive), must be valid\n+     * @param removeLen  the length to remove (endIndex - startIndex), must be valid\n+     * @param insertStr  the string to replace with, null means delete range\n+     * @param insertLen  the length of the insert string, must be valid\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen) {\n+        int newSize = size - removeLen + insertLen;\n+        if (insertLen != removeLen) {\n+            ensureCapacity(newSize);\n+            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n+            size = newSize;\n+        }\n+        if (insertLen > 0) {\n+            insertStr.getChars(0, insertLen, buffer, startIndex);\n+        }\n+    }\n+\n+    /**\n+     * Replaces a portion of the string builder with another string.\n+     * The length of the inserted string does not have to match the removed length.\n+     *\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @param replaceStr  the string to replace with, null means delete range\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n+        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the search character with the replace character\n+     * throughout the builder.\n+     *\n+     * @param search  the search character\n+     * @param replace  the replace character\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(char search, char replace) {\n+        if (search != replace) {\n+            for (int i = 0; i < size; i++) {\n+                if (buffer[i] == search) {\n+                    buffer[i] = replace;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces the first instance of the search character with the\n+     * replace character in the builder.\n+     *\n+     * @param search  the search character\n+     * @param replace  the replace character\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(char search, char replace) {\n+        if (search != replace) {\n+            for (int i = 0; i < size; i++) {\n+                if (buffer[i] == search) {\n+                    buffer[i] = replace;\n+                    break;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the search string with the replace string throughout the builder.\n+     *\n+     * @param searchStr  the search string, null causes no action to occur\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(String searchStr, String replaceStr) {\n+        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        if (searchLen > 0) {\n+            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+            int index = indexOf(searchStr, 0);\n+            while (index >= 0) {\n+                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n+                index = indexOf(searchStr, index + replaceLen);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces the first instance of the search string with the replace string.\n+     *\n+     * @param searchStr  the search string, null causes no action to occur\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(String searchStr, String replaceStr) {\n+        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        if (searchLen > 0) {\n+            int index = indexOf(searchStr, 0);\n+            if (index >= 0) {\n+                int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all matches within the builder with the replace string.\n+     * <p>\n+     * Matchers can be used to perform advanced replace behaviour.\n+     * For example you could write a matcher to replace all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(StrMatcher matcher, String replaceStr) {\n+        return replace(matcher, replaceStr, 0, size, -1);\n+    }\n+\n+    /**\n+     * Replaces the first match within the builder with the replace string.\n+     * <p>\n+     * Matchers can be used to perform advanced replace behaviour.\n+     * For example you could write a matcher to replace\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {\n+        return replace(matcher, replaceStr, 0, size, 1);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Advanced search and replaces within the builder using a matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the string to replace the match with, null is a delete\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @param replaceCount  the number of times to replace, -1 for replace all\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if start index is invalid\n+     */\n+    public StrBuilder replace(\n+            StrMatcher matcher, String replaceStr,\n+            int startIndex, int endIndex, int replaceCount) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n+    }\n+\n+    /**\n+     * Replaces within the builder using a matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the string to replace the match with, null is a delete\n+     * @param from  the start index, must be valid\n+     * @param to  the end index (exclusive), must be valid\n+     * @param replaceCount  the number of times to replace, -1 for replace all\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private StrBuilder replaceImpl(\n+            StrMatcher matcher, String replaceStr,\n+            int from, int to, int replaceCount) {\n+        if (matcher == null || size == 0) {\n+            return this;\n+        }\n+        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+        char[] buf = buffer;\n+        for (int i = from; i < to && replaceCount != 0; i++) {\n+            int removeLen = matcher.isMatch(buf, i, from, to);\n+            if (removeLen > 0) {\n+                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n+                to = to - removeLen + replaceLen;\n+                i = i + replaceLen - 1;\n+                if (replaceCount > 0) {\n+                    replaceCount--;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverses the string builder placing each character in the opposite index.\n+     * \n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder reverse() {\n+        if (size == 0) {\n+            return this;\n+        }\n+        \n+        int half = size / 2;\n+        char[] buf = buffer;\n+        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n+            char swap = buf[leftIdx];\n+            buf[leftIdx] = buf[rightIdx];\n+            buf[rightIdx] = swap;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Trims the builder by removing characters less than or equal to a space\n+     * from the beginning and end.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder trim() {\n+        if (size == 0) {\n+            return this;\n+        }\n+        int len = size;\n+        char[] buf = buffer;\n+        int pos = 0;\n+        while (pos < len && buf[pos] <= ' ') {\n+            pos++;\n+        }\n+        while (pos < len && buf[len - 1] <= ' ') {\n+            len--;\n+        }\n+        if (len < size) {\n+            delete(len, size);\n+        }\n+        if (pos > 0) {\n+            delete(0, pos);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether this builder starts with the specified string.\n+     * <p>\n+     * Note that this method handles null input quietly, unlike String.\n+     * \n+     * @param str  the string to search for, null returns false\n+     * @return true if the builder starts with the string\n+     */\n+    public boolean startsWith(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return true;\n+        }\n+        if (len > size) {\n+            return false;\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (buffer[i] != str.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether this builder ends with the specified string.\n+     * <p>\n+     * Note that this method handles null input quietly, unlike String.\n+     * \n+     * @param str  the string to search for, null returns false\n+     * @return true if the builder ends with the string\n+     */\n+    public boolean endsWith(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return true;\n+        }\n+        if (len > size) {\n+            return false;\n+        }\n+        int pos = size - len;\n+        for (int i = 0; i < len; i++,pos++) {\n+            if (buffer[pos] != str.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts a portion of this string builder as a string.\n+     * \n+     * @param start  the start index, inclusive, must be valid\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public String substring(int start) {\n+        return substring(start, size);\n+    }\n+\n+    /**\n+     * Extracts a portion of this string builder as a string.\n+     * <p>\n+     * Note: This method treats an endIndex greater than the length of the\n+     * builder as equal to the length of the builder, and continues\n+     * without error, unlike StringBuffer or String.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public String substring(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        return new String(buffer, startIndex, endIndex - startIndex);\n+    }\n+\n+    /**\n+     * Extracts the leftmost characters from the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts the left <code>length</code> characters from\n+     * the builder. If this many characters are not available, the whole\n+     * builder is returned. Thus the returned string may be shorter than the\n+     * length requested.\n+     * \n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String leftString(int length) {\n+        if (length <= 0) {\n+            return \"\";\n+        } else if (length >= size) {\n+            return new String(buffer, 0, size);\n+        } else {\n+            return new String(buffer, 0, length);\n+        }\n+    }\n+\n+    /**\n+     * Extracts the rightmost characters from the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts the right <code>length</code> characters from\n+     * the builder. If this many characters are not available, the whole\n+     * builder is returned. Thus the returned string may be shorter than the\n+     * length requested.\n+     * \n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String rightString(int length) {\n+        if (length <= 0) {\n+            return \"\";\n+        } else if (length >= size) {\n+            return new String(buffer, 0, size);\n+        } else {\n+            return new String(buffer, size - length, length);\n+        }\n+    }\n+\n+    /**\n+     * Extracts some characters from the middle of the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts <code>length</code> characters from the builder\n+     * at the specified index.\n+     * If the index is negative it is treated as zero.\n+     * If the index is greater than the builder size, it is treated as the builder size.\n+     * If the length is negative, the empty string is returned.\n+     * If insufficient characters are available in the builder, as much as possible is returned.\n+     * Thus the returned string may be shorter than the length requested.\n+     * \n+     * @param index  the index to start at, negative means zero\n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String midString(int index, int length) {\n+        if (index < 0) {\n+            index = 0;\n+        }\n+        if (length <= 0 || index >= size) {\n+            return \"\";\n+        }\n+        if (size <= index + length) {\n+            return new String(buffer, index, size - index);\n+        } else {\n+            return new String(buffer, index, length);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the string builder contains the specified char.\n+     *\n+     * @param ch  the character to find\n+     * @return true if the builder contains the character\n+     */\n+    public boolean contains(char ch) {\n+        char[] thisBuf = buffer;\n+        for (int i = 0; i < thisBuf.length; i++) {\n+            if (thisBuf[i] == ch) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the string builder contains the specified string.\n+     *\n+     * @param str  the string to find\n+     * @return true if the builder contains the string\n+     */\n+    public boolean contains(String str) {\n+        return indexOf(str, 0) >= 0;\n+    }\n+\n+    /**\n+     * Checks if the string builder contains a string matched using the\n+     * specified matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to search for the character\n+     * 'a' followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return true if the matcher finds a match in the builder\n+     */\n+    public boolean contains(StrMatcher matcher) {\n+        return indexOf(matcher, 0) >= 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Searches the string builder to find the first reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return the first index of the character, or -1 if not found\n+     */\n+    public int indexOf(char ch) {\n+        return indexOf(ch, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index of the character, or -1 if not found\n+     */\n+    public int indexOf(char ch, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (startIndex >= size) {\n+            return -1;\n+        }\n+        char[] thisBuf = buffer;\n+        for (int i = startIndex; i < thisBuf.length; i++) {\n+            if (thisBuf[i] == ch) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified string.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @return the first index of the string, or -1 if not found\n+     */\n+    public int indexOf(String str) {\n+        return indexOf(str, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified\n+     * string starting searching from the given index.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index of the string, or -1 if not found\n+     */\n+    public int indexOf(String str, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (str == null || startIndex >= size) {\n+            return -1;\n+        }\n+        int strLen = str.length();\n+        if (strLen == 1) {\n+            return indexOf(str.charAt(0), startIndex);\n+        }\n+        if (strLen == 0) {\n+            return startIndex;\n+        }\n+        if (strLen > size) {\n+            return -1;\n+        }\n+        char[] thisBuf = buffer;\n+        outer:\n+        for (int i = startIndex; i < thisBuf.length - strLen; i++) {\n+            for (int j = 0; j < strLen; j++) {\n+                if (str.charAt(j) != thisBuf[i + j]) {\n+                    continue outer;\n+                }\n+            }\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the first match.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return the first index matched, or -1 if not found\n+     */\n+    public int indexOf(StrMatcher matcher) {\n+        return indexOf(matcher, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the first\n+     * match searching from the given index.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index matched, or -1 if not found\n+     */\n+    public int indexOf(StrMatcher matcher, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (matcher == null || startIndex >= size) {\n+            return -1;\n+        }\n+        int len = size;\n+        char[] buf = buffer;\n+        for (int i = startIndex; i < len; i++) {\n+            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Searches the string builder to find the last reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return the last index of the character, or -1 if not found\n+     */\n+    public int lastIndexOf(char ch) {\n+        return lastIndexOf(ch, size - 1);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index of the character, or -1 if not found\n+     */\n+    public int lastIndexOf(char ch, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (startIndex < 0) {\n+            return -1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (buffer[i] == ch) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified string.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @return the last index of the string, or -1 if not found\n+     */\n+    public int lastIndexOf(String str) {\n+        return lastIndexOf(str, size - 1);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified\n+     * string starting searching from the given index.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index of the string, or -1 if not found\n+     */\n+    public int lastIndexOf(String str, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (str == null || startIndex < 0) {\n+            return -1;\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0 && strLen <= size) {\n+            if (strLen == 1) {\n+                return lastIndexOf(str.charAt(0), startIndex);\n+            }\n+\n+            outer:\n+            for (int i = startIndex - strLen + 1; i >= 0; i--) {\n+                for (int j = 0; j < strLen; j++) {\n+                    if (str.charAt(j) != buffer[i + j]) {\n+                        continue outer;\n+                    }\n+                }\n+                return i;\n+            }\n+            \n+        } else if (strLen == 0) {\n+            return startIndex;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the last match.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return the last index matched, or -1 if not found\n+     */\n+    public int lastIndexOf(StrMatcher matcher) {\n+        return lastIndexOf(matcher, size);\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the last\n+     * match searching from the given index.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index matched, or -1 if not found\n+     */\n+    public int lastIndexOf(StrMatcher matcher, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (matcher == null || startIndex < 0) {\n+            return -1;\n+        }\n+        char[] buf = buffer;\n+        int endIndex = startIndex + 1;\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a tokenizer that can tokenize the contents of this builder.\n+     * <p>\n+     * This method allows the contents of this builder to be tokenized.\n+     * The tokenizer will be setup by default to tokenize on space, tab,\n+     * newline and formfeed (as per StringTokenizer). These values can be\n+     * changed on the tokenizer class, before retrieving the tokens.\n+     * <p>\n+     * The returned tokenizer is linked to this builder. You may intermix\n+     * calls to the buider and tokenizer within certain limits, however\n+     * there is no synchronization. Once the tokenizer has been used once,\n+     * it must be {@link StrTokenizer#reset() reset} to pickup the latest\n+     * changes in the builder. For example:\n+     * <pre>\n+     * StrBuilder b = new StrBuilder();\n+     * b.append(\"a b \");\n+     * StrTokenizer t = b.asTokenizer();\n+     * String[] tokens1 = t.getTokenArray();  // returns a,b\n+     * b.append(\"c d \");\n+     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)\n+     * t.reset();              // reset causes builder changes to be picked up\n+     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d\n+     * </pre>\n+     * In addition to simply intermixing appends and tokenization, you can also\n+     * call the set methods on the tokenizer to alter how it tokenizes. Just\n+     * remember to call reset when you want to pickup builder changes.\n+     * <p>\n+     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}\n+     * with a non-null value will break the link with the builder.\n+     *\n+     * @return a tokenizer that is linked to this builder\n+     */\n+    public StrTokenizer asTokenizer() {\n+        return new StrBuilderTokenizer();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the contents of this builder as a Reader.\n+     * <p>\n+     * This method allows the contents of the builder to be read\n+     * using any standard method that expects a Reader.\n+     * <p>\n+     * To use, simply create a <code>StrBuilder</code>, populate it with\n+     * data, call <code>asReader</code>, and then read away.\n+     * <p>\n+     * The internal character array is shared between the builder and the reader.\n+     * This allows you to append to the builder after creating the reader,\n+     * and the changes will be picked up.\n+     * Note however, that no synchronization occurs, so you must perform\n+     * all operations with the builder and the reader in one thread.\n+     * <p>\n+     * The returned reader supports marking, and ignores the flush method.\n+     *\n+     * @return a reader that reads from this builder\n+     */\n+    public Reader asReader() {\n+        return new StrBuilderReader();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this builder as a Writer that can be written to.\n+     * <p>\n+     * This method allows you to populate the contents of the builder\n+     * using any standard method that takes a Writer.\n+     * <p>\n+     * To use, simply create a <code>StrBuilder</code>,\n+     * call <code>asWriter</code>, and populate away. The data is available\n+     * at any time using the methods of the <code>StrBuilder</code>.\n+     * <p>\n+     * The internal character array is shared between the builder and the writer.\n+     * This allows you to intermix calls that append to the builder and\n+     * write using the writer and the changes will be occur correctly.\n+     * Note however, that no synchronization occurs, so you must perform\n+     * all operations with the builder and the writer in one thread.\n+     * <p>\n+     * The returned writer ignores the close and flush methods.\n+     *\n+     * @return a writer that populates this builder\n+     */\n+    public Writer asWriter() {\n+        return new StrBuilderWriter();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    /**\n+//     * Gets a String version of the string builder by calling the internal\n+//     * constructor of String by reflection.\n+//     * <p>\n+//     * WARNING: You must not use the StrBuilder after calling this method\n+//     * as the buffer is now shared with the String object. To ensure this,\n+//     * the internal character array is set to null, so you will get\n+//     * NullPointerExceptions on all method calls.\n+//     *\n+//     * @return the builder as a String\n+//     */\n+//    public String toSharedString() {\n+//        try {\n+//            Constructor con = String.class.getDeclaredConstructor(\n+//                new Class[] {int.class, int.class, char[].class});\n+//            con.setAccessible(true);\n+//            char[] buffer = buf;\n+//            buf = null;\n+//            size = -1;\n+//            nullText = null;\n+//            return (String) con.newInstance(\n+//                new Object[] {new Integer(0), new Integer(size), buffer});\n+//            \n+//        } catch (Exception ex) {\n+//            ex.printStackTrace();\n+//            throw new UnsupportedOperationException(\"StrBuilder.toSharedString is unsupported: \" + ex.getMessage());\n+//        }\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content ignoring case.\n+     *\n+     * @param other  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    public boolean equalsIgnoreCase(StrBuilder other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (this.size != other.size) {\n+            return false;\n+        }\n+        char thisBuf[] = this.buffer;\n+        char otherBuf[] = other.buffer;\n+        for (int i = size - 1; i >= 0; i--) {\n+            char c1 = thisBuf[i];\n+            char c2 = otherBuf[i];\n+            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content.\n+     *\n+     * @param other  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    public boolean equals(StrBuilder other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (this.size != other.size) {\n+            return false;\n+        }\n+        char thisBuf[] = this.buffer;\n+        char otherBuf[] = other.buffer;\n+        for (int i = size - 1; i >= 0; i--) {\n+            if (thisBuf[i] != otherBuf[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content.\n+     *\n+     * @param obj  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof StrBuilder) {\n+            return equals((StrBuilder) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a suitable hash code for this builder.\n+     *\n+     * @return a hash code\n+     */\n+    public int hashCode() {\n+        char buf[] = buffer;\n+        int hash = 0;\n+        for (int i = size - 1; i >= 0; i--) {\n+            hash = 31 * hash + buf[i];\n+        }\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a String version of the string builder, creating a new instance\n+     * each time the method is called.\n+     * <p>\n+     * Note that unlike StringBuffer, the string version returned is\n+     * independent of the string builder.\n+     *\n+     * @return the builder as a String\n+     */\n+    public String toString() {\n+        return new String(buffer, 0, size);\n+    }\n+\n+    /**\n+     * Gets a StringBuffer version of the string builder, creating a\n+     * new instance each time the method is called.\n+     *\n+     * @return the builder as a StringBuffer\n+     */\n+    public StringBuffer toStringBuffer() {\n+        return new StringBuffer(size).append(buffer, 0, size);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates parameters defining a range of the builder.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected int validateRange(int startIndex, int endIndex) {\n+        if (startIndex < 0) {\n+            throw new StringIndexOutOfBoundsException(startIndex);\n+        }\n+        if (endIndex > size) {\n+            endIndex = size;\n+        }\n+        if (startIndex > endIndex) {\n+            throw new StringIndexOutOfBoundsException(\"end < start\");\n+        }\n+        return endIndex;\n+    }\n+\n+    /**\n+     * Validates parameters defining a single index in the builder.\n+     * \n+     * @param index  the index, must be valid\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void validateIndex(int index) {\n+        if (index < 0 || index > size) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a tokenizer.\n+     */\n+    class StrBuilderTokenizer extends StrTokenizer {\n+\n+        /** {@inheritDoc} */\n+        StrBuilderTokenizer() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        protected List tokenize(char[] chars, int offset, int count) {\n+            if (chars == null) {\n+                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n+            } else {\n+                return super.tokenize(chars, offset, count);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public String getContent() {\n+            String str = super.getContent();\n+            if (str == null) {\n+                return StrBuilder.this.toString();\n+            } else {\n+                return str;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a writer.\n+     */\n+    class StrBuilderReader extends Reader {\n+        /** The current stream position. */\n+        private int pos;\n+        /** The last mark position. */\n+        private int mark;\n+\n+        /** {@inheritDoc} */\n+        StrBuilderReader() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void close() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int read() {\n+            if (ready() == false) {\n+                return -1;\n+            }\n+            return StrBuilder.this.charAt(pos++);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int read(char b[], int off, int len) {\n+            if (off < 0 || len < 0 || off > b.length ||\n+                    (off + len) > b.length || (off + len) < 0) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+            if (len == 0) {\n+                return 0;\n+            }\n+            if (pos >= StrBuilder.this.size()) {\n+                return -1;\n+            }\n+            if (pos + len > size()) {\n+                len = StrBuilder.this.size() - pos;\n+            }\n+            StrBuilder.this.getChars(pos, pos + len, b, off);\n+            pos += len;\n+            return len;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public long skip(long n) {\n+            if (pos + n > StrBuilder.this.size()) {\n+                n = StrBuilder.this.size() - pos;\n+            }\n+            if (n < 0) {\n+                return 0;\n+            }\n+            pos += n;\n+            return n;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean ready() {\n+            return pos < StrBuilder.this.size();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean markSupported() {\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void mark(int readAheadLimit) {\n+            mark = pos;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void reset() {\n+            pos = mark;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a writer.\n+     */\n+    class StrBuilderWriter extends Writer {\n+\n+        /** {@inheritDoc} */\n+        StrBuilderWriter() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void close() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void flush() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void write(int c) {\n+            StrBuilder.this.append((char) c);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void write(char[] cbuf) {\n+            StrBuilder.this.append(cbuf);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void write(char[] cbuf, int off, int len) {\n+            StrBuilder.this.append(cbuf, off, len);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void write(String str) {\n+            StrBuilder.this.append(str);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void write(String str, int off, int len) {\n+            StrBuilder.this.append(str, off, len);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/text/StrLookup.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.Map;\n+\n+/**\n+ * Lookup a String key to a String value.\n+ * <p>\n+ * This class represents the simplest form of a string to string map.\n+ * It has a benefit over a map in that it can create the result on\n+ * demand based on the key.\n+ * <p>\n+ * This class comes complete with various factory methods.\n+ * If these do not suffice, you can subclass and implement your own matcher.\n+ * <p>\n+ * For example, it would be possible to implement a lookup that used the\n+ * key as a primary key, and looked up the value on demand from the database\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public abstract class StrLookup {\n+\n+    /**\n+     * Lookup that always returns null.\n+     */\n+    private static final StrLookup NONE_LOOKUP;\n+    /**\n+     * Lookup that uses System properties.\n+     */\n+    private static final StrLookup SYSTEM_PROPERTIES_LOOKUP;\n+    static {\n+        NONE_LOOKUP = new MapStrLookup(null);\n+        StrLookup lookup = null;\n+        try {\n+            lookup = new MapStrLookup(System.getProperties());\n+        } catch (SecurityException ex) {\n+            lookup = NONE_LOOKUP;\n+        }\n+        SYSTEM_PROPERTIES_LOOKUP = lookup;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a lookup which always returns null.\n+     *\n+     * @return a lookup that always returns null, not null\n+     */\n+    public static StrLookup noneLookup() {\n+        return NONE_LOOKUP;\n+    }\n+\n+    /**\n+     * Returns a lookup which uses {@link System#getProperties() System properties}\n+     * to lookup the key to value.\n+     * <p>\n+     * If a security manager blocked access to system properties, then null will\n+     * be returned from every lookup.\n+     * <p>\n+     * If a null key is used, this lookup will throw a NullPointerException.\n+     *\n+     * @return a lookup using system properties, not null\n+     */\n+    public static StrLookup systemPropertiesLookup() {\n+        return SYSTEM_PROPERTIES_LOOKUP;\n+    }\n+\n+    /**\n+     * Returns a lookup which looks up values using a map.\n+     * <p>\n+     * If the map is null, then null will be returned from every lookup.\n+     * The map result object is converted to a string using toString().\n+     *\n+     * @param map  the map of keys to values, may be null\n+     * @return a lookup using the map, not null\n+     */\n+    public static StrLookup mapLookup(Map map) {\n+        return new MapStrLookup(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected StrLookup() {\n+        super();\n+    }\n+\n+    /**\n+     * Looks up a String key to a String value.\n+     * <p>\n+     * The internal implementation may use any mechanism to return the value.\n+     * The simplest implementation is to use a Map. However, virtually any\n+     * implementation is possible.\n+     * <p>\n+     * For example, it would be possible to implement a lookup that used the\n+     * key as a primary key, and looked up the value on demand from the database\n+     * Or, a numeric based implementation could be created that treats the key\n+     * as an integer, increments the value and return the result as a string -\n+     * converting 1 to 2, 15 to 16 etc.\n+     *\n+     * @param key  the key to be looked up, may be null\n+     * @return the matching value, null if no match\n+     */\n+    public abstract String lookup(String key);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Lookup imnplementation that uses a Map.\n+     */\n+    static class MapStrLookup extends StrLookup {\n+\n+        /** Map keys are variable names and value. */\n+        private final Map map;\n+\n+        /**\n+         * Creates a new instance backed by a Map.\n+         *\n+         * @param map  the map of keys to values, may be null\n+         */\n+        MapStrLookup(Map map) {\n+            this.map = map;\n+        }\n+\n+        /**\n+         * Looks up a String key to a String value using the map.\n+         * <p>\n+         * If the map is null, then null is returned.\n+         * The map result object is converted to a string using toString().\n+         *\n+         * @param key  the key to be looked up, may be null\n+         * @return the matching value, null if no match\n+         */\n+        public String lookup(String key) {\n+            if (map == null) {\n+                return null;\n+            }\n+            Object obj = map.get(key);\n+            if (obj == null) {\n+                return null;\n+            }\n+            return obj.toString();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/text/StrMatcher.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * A matcher class that can be queried to determine if a character array\n+ * portion matches.\n+ * <p>\n+ * This class comes complete with various factory methods.\n+ * If these do not suffice, you can subclass and implement your own matcher.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public abstract class StrMatcher {\n+\n+    /**\n+     * Matches the comma character.\n+     */\n+    private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');\n+    /**\n+     * Matches the tab character.\n+     */\n+    private static final StrMatcher TAB_MATCHER = new CharMatcher('\\t');\n+    /**\n+     * Matches the space character.\n+     */\n+    private static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');\n+    /**\n+     * Matches the same characters as StringTokenizer,\n+     * namely space, tab, newline, formfeed.\n+     */\n+    private static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\".toCharArray());\n+    /**\n+     * Matches the String trim() whitespace characters.\n+     */\n+    private static final StrMatcher TRIM_MATCHER = new TrimMatcher();\n+    /**\n+     * Matches the double quote character.\n+     */\n+    private static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n+    /**\n+     * Matches the double quote character.\n+     */\n+    private static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n+    /**\n+     * Matches the single or double quote character.\n+     */\n+    private static final StrMatcher QUOTE_MATCHER = new CharSetMatcher(\"'\\\"\".toCharArray());\n+    /**\n+     * Matches no characters.\n+     */\n+    private static final StrMatcher NONE_MATCHER = new NoMatcher();\n+\n+    // -----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a matcher which matches the comma character.\n+     *\n+     * @return a matcher for a comma\n+     */\n+    public static StrMatcher commaMatcher() {\n+        return COMMA_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the tab character.\n+     *\n+     * @return a matcher for a tab\n+     */\n+    public static StrMatcher tabMatcher() {\n+        return TAB_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the space character.\n+     *\n+     * @return a matcher for a space\n+     */\n+    public static StrMatcher spaceMatcher() {\n+        return SPACE_MATCHER;\n+    }\n+\n+    /**\n+     * Matches the same characters as StringTokenizer,\n+     * namely space, tab, newline and formfeed.\n+     *\n+     * @return the split matcher\n+     */\n+    public static StrMatcher splitMatcher() {\n+        return SPLIT_MATCHER;\n+    }\n+\n+    /**\n+     * Matches the String trim() whitespace characters.\n+     *\n+     * @return the trim matcher\n+     */\n+    public static StrMatcher trimMatcher() {\n+        return TRIM_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the single quote character.\n+     *\n+     * @return a matcher for a single quote\n+     */\n+    public static StrMatcher singleQuoteMatcher() {\n+        return SINGLE_QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the double quote character.\n+     *\n+     * @return a matcher for a double quote\n+     */\n+    public static StrMatcher doubleQuoteMatcher() {\n+        return DOUBLE_QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the single or double quote character.\n+     *\n+     * @return a matcher for a single or double quote\n+     */\n+    public static StrMatcher quoteMatcher() {\n+        return QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Matches no characters.\n+     *\n+     * @return a matcher that matches nothing\n+     */\n+    public static StrMatcher noneMatcher() {\n+        return NONE_MATCHER;\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a character.\n+     *\n+     * @param ch  the character to match, must not be null\n+     * @return a new Matcher for the given char\n+     */\n+    public static StrMatcher charMatcher(char ch) {\n+        return new CharMatcher(ch);\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a set of characters.\n+     *\n+     * @param chars  the characters to match, null or empty matches nothing\n+     * @return a new matcher for the given char[]\n+     */\n+    public static StrMatcher charSetMatcher(char[] chars) {\n+        if (chars == null || chars.length == 0) {\n+            return NONE_MATCHER;\n+        }\n+        if (chars.length == 1) {\n+            return new CharMatcher(chars[0]);\n+        }\n+        return new CharSetMatcher(chars);\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a string representing a set of characters.\n+     *\n+     * @param chars  the characters to match, null or empty matches nothing\n+     * @return a new Matcher for the given characters\n+     */\n+    public static StrMatcher charSetMatcher(String chars) {\n+        if (chars == null || chars.length() == 0) {\n+            return NONE_MATCHER;\n+        }\n+        if (chars.length() == 1) {\n+            return new CharMatcher(chars.charAt(0));\n+        }\n+        return new CharSetMatcher(chars.toCharArray());\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a string.\n+     *\n+     * @param str  the string to match, null or empty matches nothing\n+     * @return a new Matcher for the given String\n+     */\n+    public static StrMatcher stringMatcher(String str) {\n+        if (str == null || str.length() == 0) {\n+            return NONE_MATCHER;\n+        }\n+        return new StringMatcher(str);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected StrMatcher() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the number of matching characters, zero for no match.\n+     * <p>\n+     * This method is called to check for a match.\n+     * The parameter <code>pos</code> represents the current position to be\n+     * checked in the string <code>buffer</code> (a character array which must\n+     * not be changed).\n+     * The API guarantees that <code>pos</code> is a valid index for <code>buffer</code>.\n+     * <p>\n+     * The character array may be larger than the active area to be matched.\n+     * Only values in the buffer between the specifed indices may be accessed.\n+     * <p>\n+     * The matching code may check one character or many.\n+     * It may check characters preceeding <code>pos</code> as well as those\n+     * after, so long as no checks exceed the bounds specified.\n+     * <p>\n+     * It must return zero for no match, or a positive number if a match was found.\n+     * The number indicates the number of characters that matched.\n+     *\n+     * @param buffer  the text content to match against, do not change\n+     * @param pos  the starting position for the match, valid for buffer\n+     * @param bufferStart  the first active index in the buffer, valid for buffer\n+     * @param bufferEnd  the end index (exclusive) of the active buffer, valid for buffer\n+     * @return the number of matching characters, zero for no match\n+     */\n+    public abstract int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    static final class CharSetMatcher extends StrMatcher {\n+        /** The set of characters to match. */\n+        private char[] chars;\n+\n+        /**\n+         * Constructor that creates a matcher from a character array.\n+         *\n+         * @param chars  the characters to match, must not be null\n+         */\n+        CharSetMatcher(char chars[]) {\n+            super();\n+            this.chars = (char[]) chars.clone();\n+            Arrays.sort(this.chars);\n+        }\n+\n+        /**\n+         * Returns whether or not the given charatcer matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a character for matching purposes.\n+     */\n+    static final class CharMatcher extends StrMatcher {\n+        /** The character to match. */\n+        private char ch;\n+\n+        /**\n+         * Constructor that creates a matcher that matches a single character.\n+         *\n+         * @param ch  the character to match\n+         */\n+        CharMatcher(char ch) {\n+            super();\n+            this.ch = ch;\n+        }\n+\n+        /**\n+         * Returns whether or not the given character matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return ch == buffer[pos] ? 1 : 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    static final class StringMatcher extends StrMatcher {\n+        /** The string to match, as a character array. */\n+        private char[] chars;\n+\n+        /**\n+         * Constructor that creates a matcher from a String.\n+         *\n+         * @param str  the string to match, must not be null\n+         */\n+        StringMatcher(String str) {\n+            super();\n+            chars = str.toCharArray();\n+        }\n+\n+        /**\n+         * Returns whether or not the given text matches the stored string.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            int len = chars.length;\n+            if (pos + len > bufferEnd) {\n+                return 0;\n+            }\n+            for (int i = 0; i < chars.length; i++, pos++) {\n+                if (chars[i] != buffer[pos]) {\n+                    return 0;\n+                }\n+            }\n+            return len;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to match no characters.\n+     */\n+    static final class NoMatcher extends StrMatcher {\n+\n+        /**\n+         * Constructs a new instance of <code>NoMatcher</code>.\n+         */\n+        NoMatcher() {\n+            super();\n+        }\n+\n+        /**\n+         * Always returns <code>false</code>.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to match whitespace as per trim().\n+     */\n+    static final class TrimMatcher extends StrMatcher {\n+\n+        /**\n+         * Constructs a new instance of <code>TrimMatcher</code>.\n+         */\n+        TrimMatcher() {\n+            super();\n+        }\n+\n+        /**\n+         * Returns whether or not the given charatcer matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return buffer[pos] <= 32 ? 1 : 0;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/text/StrSubstitutor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Substitutes variables within a string by values.\n+ * <p>\n+ * This class takes a piece of text and substitutes all the variables within it.\n+ * The default definition of a variable is <code>${variableName}</code>.\n+ * The prefix and suffix can be changed via constructors and set methods.\n+ * <p>\n+ * Variable values are typically resolved from a map, but could also be resolved\n+ * from system properties, or by supplying a custom variable resolver.\n+ * <p>\n+ * The simplest example is to use this class to replace Java System properties. For example:\n+ * <pre>\n+ * StrSubstitutor.replaceSystemProperties(\n+ *      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n+ * </pre>\n+ * <p>\n+ * Typical usage of this class follows the following pattern: First an instance is created\n+ * and initialized with the map that contains the values for the available variables.\n+ * If a prefix and/or suffix for variables should be used other than the default ones,\n+ * the appropriate settings can be performed. After that the <code>replace()</code>\n+ * method can be called passing in the source text for interpolation. In the returned\n+ * text all variable references (as long as their values are known) will be resolved.\n+ * The following example demonstrates this:\n+ * <pre>\n+ * Map valuesMap = HashMap();\n+ * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n+ * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n+ * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n+ * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n+ * String resolvedString = sub.replace(templateString);\n+ * </pre>\n+ * yielding:\n+ * <pre>\n+ *      The quick brown fox jumped over the lazy dog.\n+ * </pre>\n+ * <p>\n+ * In addition to this usage pattern there are some static convenience methods that\n+ * cover the most common use cases. These methods can be used without the need of\n+ * manually creating an instance. However if multiple replace operations are to be\n+ * performed, creating and reusing an instance of this class will be more efficient.\n+ * <p>\n+ * Variable replacement works in a recursive way. Thus, if a variable value contains\n+ * a variable then that variable will also be replaced. Cyclic replacements are\n+ * detected and will cause an exception to be thrown.\n+ * <p>\n+ * Sometimes the interpolation's result must contain a variable prefix. As an example\n+ * take the following source text:\n+ * <pre>\n+ *   The variable ${${name}} must be used.\n+ * </pre>\n+ * Here only the variable's name refered to in the text should be replaced resulting\n+ * in the text (assuming that the value of the <code>name</code> variable is <code>x</code>):\n+ * <pre>\n+ *   The variable ${x} must be used.\n+ * </pre>\n+ * To achieve this effect there are two possibilities: Either set a different prefix\n+ * and suffix for variables which do not conflict with the result text you want to\n+ * produce. The other possibility is to use the escape character, by default '$'.\n+ * If this character is placed before a variable reference, this reference is ignored\n+ * and won't be replaced. For example:\n+ * <pre>\n+ *   The variable $${${name}} must be used.\n+ * </pre>\n+ *\n+ * @author Oliver Heger\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ * @since 2.2\n+ */\n+public class StrSubstitutor {\n+\n+    /**\n+     * Constant for the default escape character.\n+     */\n+    public static final char DEFAULT_ESCAPE = '$';\n+    /**\n+     * Constant for the default variable prefix.\n+     */\n+    public static final StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(\"${\");\n+    /**\n+     * Constant for the default variable suffix.\n+     */\n+    public static final StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(\"}\");\n+\n+    /**\n+     * Stores the escape character.\n+     */\n+    private char escapeChar;\n+    /**\n+     * Stores the variable prefix.\n+     */\n+    private StrMatcher prefixMatcher;\n+    /**\n+     * Stores the variable suffix.\n+     */\n+    private StrMatcher suffixMatcher;\n+    /**\n+     * Variable resolution is delegated to an implementor of VariableResolver.\n+     */\n+    private StrLookup variableResolver;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the map.\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @param valueMap  the map with the values, may be null\n+     * @return the result of the replace operation\n+     */\n+    public static String replace(Object source, Map valueMap) {\n+        return new StrSubstitutor(valueMap).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the map. This method allows to specifiy a\n+     * custom variable prefix and suffix\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @param valueMap  the map with the values, may be null\n+     * @param prefix  the prefix of variables, not null\n+     * @param suffix  the suffix of variables, not null\n+     * @return the result of the replace operation\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public static String replace(Object source, Map valueMap, String prefix, String suffix) {\n+        return new StrSubstitutor(valueMap, prefix, suffix).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the system properties.\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public static String replaceSystemProperties(Object source) {\n+        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance with defaults for variable prefix and suffix\n+     * and the escaping character.\n+     */\n+    public StrSubstitutor() {\n+        this((StrLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it. Uses defaults for variable\n+     * prefix and suffix and the escaping character.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     */\n+    public StrSubstitutor(Map valueMap) {\n+        this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it. Uses a default escaping character.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(Map valueMap, String prefix, String suffix) {\n+        this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(Map valueMap, String prefix, String suffix, char escape) {\n+        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     */\n+    public StrSubstitutor(StrLookup variableResolver) {\n+        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(StrLookup variableResolver, String prefix, String suffix, char escape) {\n+        this.setVariableResolver(variableResolver);\n+        this.setVariablePrefix(prefix);\n+        this.setVariableSuffix(suffix);\n+        this.setEscapeChar(escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     * @param prefixMatcher  the prefix for variables, not null\n+     * @param suffixMatcher  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(\n+            StrLookup variableResolver, StrMatcher prefixMatcher, StrMatcher suffixMatcher, char escape) {\n+        this.setVariableResolver(variableResolver);\n+        this.setVariablePrefixMatcher(prefixMatcher);\n+        this.setVariableSuffixMatcher(suffixMatcher);\n+        this.setEscapeChar(escape);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source string as a template.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source);\n+        if (substitute(buf, 0, source.length()) == false) {\n+            return source;\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source string as a template.\n+     * <p>\n+     * Only the specified portion of the string will be processed.\n+     * The rest of the string is not processed, and is not returned.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return source.substring(offset, offset + length);\n+        }\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source array as a template.\n+     * The array is not altered by this method.\n+     *\n+     * @param source  the character array to replace in, not altered, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length).append(source);\n+        substitute(buf, 0, source.length);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source array as a template.\n+     * The array is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the array will be processed.\n+     * The rest of the array is not processed, and is not returned.\n+     *\n+     * @param source  the character array to replace in, not altered, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source buffer as a template.\n+     * The buffer is not altered by this method.\n+     *\n+     * @param source  the buffer to use as a template, not changed, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StringBuffer source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source buffer as a template.\n+     * The buffer is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the buffer will be processed.\n+     * The rest of the buffer is not processed, and is not returned.\n+     *\n+     * @param source  the buffer to use as a template, not changed, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StringBuffer source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source builder as a template.\n+     * The builder is not altered by this method.\n+     *\n+     * @param source  the builder to use as a template, not changed, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StrBuilder source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source builder as a template.\n+     * The builder is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the builder will be processed.\n+     * The rest of the builder is not processed, and is not returned.\n+     *\n+     * @param source  the builder to use as a template, not changed, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StrBuilder source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the resolver. The input source object is\n+     * converted to a string using <code>toString</code> and is not altered.\n+     *\n+     * @param source  the source to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(Object source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder().append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables within the given source buffer\n+     * with their matching values from the resolver.\n+     * The buffer is updated with the result.\n+     *\n+     * @param source  the buffer to replace in, updated, null returns zero\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StringBuffer source) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return replaceIn(source, 0, source.length());\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables within the given source buffer\n+     * with their matching values from the resolver.\n+     * The buffer is updated with the result.\n+     * <p>\n+     * Only the specified portion of the buffer will be processed.\n+     * The rest of the buffer is not processed, but it is not deleted.\n+     *\n+     * @param source  the buffer to replace in, updated, null returns zero\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the buffer to be processed, must be valid\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StringBuffer source, int offset, int length) {\n+        if (source == null) {\n+            return false;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return false;\n+        }\n+        source.replace(offset, offset + length, buf.toString());\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables within the given source\n+     * builder with their matching values from the resolver.\n+     *\n+     * @param source  the builder to replace in, updated, null returns zero\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StrBuilder source) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return substitute(source, 0, source.length());\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables within the given source\n+     * builder with their matching values from the resolver.\n+     * <p>\n+     * Only the specified portion of the builder will be processed.\n+     * The rest of the builder is not processed, but it is not deleted.\n+     *\n+     * @param source  the builder to replace in, null returns zero\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StrBuilder source, int offset, int length) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return substitute(source, offset, length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method that substitutes the variables.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method will\n+     * be called automatically by another (public) method.\n+     * <p>\n+     * Writers of subclasses can override this method if they need access to\n+     * the substitution process at the start or end.\n+     *\n+     * @param buf  the string builder to substitute into, not null\n+     * @param offset  the start offset within the builder, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @return true if altered\n+     */\n+    protected boolean substitute(StrBuilder buf, int offset, int length) {\n+        return substitute(buf, offset, length, null) > 0;\n+    }\n+\n+    /**\n+     * Recursive handler for multiple levels of interpolation. This is the main\n+     * interpolation method, which resolves the values of all variable references\n+     * contained in the passed in text.\n+     *\n+     * @param buf  the string builder to substitute into, not null\n+     * @param offset  the start offset within the builder, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n+     * @return the length change that occurs, unless priorVariables is null when the int\n+     *  represents a boolean flag as to whether any change occurred.\n+     */\n+    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+        StrMatcher prefixMatcher = getVariablePrefixMatcher();\n+        StrMatcher suffixMatcher = getVariableSuffixMatcher();\n+        char escape = getEscapeChar();\n+        \n+        boolean top = (priorVariables == null);\n+        boolean altered = false;\n+        int lengthChange = 0;\n+        char[] chars = buf.buffer;\n+        int bufEnd = offset + length;\n+        int pos = offset;\n+        while (pos < bufEnd) {\n+            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+            if (startMatchLen == 0) {\n+                pos++;\n+            } else {\n+                // found variable start marker\n+                if (pos > offset && chars[pos - 1] == escape) {\n+                    // escaped\n+                    buf.deleteCharAt(pos - 1);\n+                    chars = buf.buffer;  // in case buffer was altered\n+                    lengthChange--;\n+                    altered = true;\n+                    bufEnd--;\n+                } else {\n+                    // find suffix\n+                    int startPos = pos;\n+                    pos += startMatchLen;\n+                    int endMatchLen = 0;\n+                    while (pos < bufEnd) {\n+                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                        if (endMatchLen == 0) {\n+                            pos++;\n+                        } else {\n+                            // found variable end marker\n+                            String varName = new String(chars, startPos + startMatchLen, \n+                                                        pos - startPos - startMatchLen);\n+                            pos += endMatchLen;\n+                            int endPos = pos;\n+                            \n+                            // on the first call initialize priorVariables\n+                            if (priorVariables == null) {\n+                                priorVariables = new ArrayList();\n+                                priorVariables.add(new String(chars, offset, length));\n+                            }\n+                            \n+                            // handle cyclic substitution\n+                            checkCyclicSubstitution(varName, priorVariables);\n+                            priorVariables.add(varName);\n+                            \n+                            // resolve the variable\n+                            String varValue = resolveVariable(varName, buf, startPos, endPos);\n+                            if (varValue != null) {\n+                                // recursive replace\n+                                int varLen = varValue.length();\n+                                buf.replace(startPos, endPos, varValue);\n+                                altered = true;\n+                                int change = substitute(buf, startPos, varLen, priorVariables);\n+                                change = change + (varLen - (endPos - startPos));\n+                                pos += change;\n+                                bufEnd += change;\n+                                lengthChange += change;\n+                                chars = buf.buffer;  // in case buffer was altered\n+                            }\n+                            \n+                            // remove variable from the cyclic stack\n+                            priorVariables.remove(priorVariables.size() - 1);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (top) {\n+            return (altered ? 1 : 0);\n+        }\n+        return lengthChange;\n+    }\n+\n+    /**\n+     * Checks if the specified variable is already in the stack (list) of variables.\n+     *\n+     * @param varName  the variable name to check\n+     * @param priorVariables  the list of prior variables\n+     */\n+    private void checkCyclicSubstitution(String varName, List priorVariables) {\n+        if (priorVariables.contains(varName) == false) {\n+            return;\n+        }\n+        StrBuilder buf = new StrBuilder(256);\n+        buf.append(\"Infinite loop in property interpolation of \");\n+        buf.append(priorVariables.remove(0));\n+        buf.append(\": \");\n+        buf.appendWithSeparators(priorVariables, \"->\");\n+        throw new IllegalStateException(buf.toString());\n+    }\n+\n+    /**\n+     * Internal method that resolves the value of a variable.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method is\n+     * called automatically by the substitution process.\n+     * <p>\n+     * Writers of subclasses can override this method if they need to alter\n+     * how each substitution occurs. The method is passed the variable's name\n+     * and must return the corresponding value. This implementation uses the\n+     * {@link #getVariableResolver()} with the variable's name as the key.\n+     *\n+     * @param variableName  the name of the variable, not null\n+     * @param buf  the buffer where the substitution is occurring, not null\n+     * @param startPos  the start position of the variable including the prefix, valid\n+     * @param endPos  the end position of the variable including the suffix, valid\n+     * @return the variable's value or <b>null</b> if the variable is unknown\n+     */\n+    protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {\n+        StrLookup resolver = getVariableResolver();\n+        if (resolver == null) {\n+            return null;\n+        }\n+        return resolver.lookup(variableName);\n+    }\n+\n+    // Escape\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the escape character.\n+     *\n+     * @return the character used for escaping variable references\n+     */\n+    public char getEscapeChar() {\n+        return this.escapeChar;\n+    }\n+\n+    /**\n+     * Sets the escape character.\n+     * If this character is placed before a variable reference in the source\n+     * text, this variable will be ignored.\n+     *\n+     * @param escapeCharacter  the escape character (0 for disabling escaping)\n+     */\n+    public void setEscapeChar(char escapeCharacter) {\n+        this.escapeChar = escapeCharacter;\n+    }\n+\n+    // Prefix\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the variable prefix matcher currently in use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This prefix is expressed in terms of a matcher\n+     * allowing advanced prefix matches.\n+     *\n+     * @return the prefix matcher in use\n+     */\n+    public StrMatcher getVariablePrefixMatcher() {\n+        return prefixMatcher;\n+    }\n+\n+    /**\n+     * Sets the variable prefix matcher currently in use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This prefix is expressed in terms of a matcher\n+     * allowing advanced prefix matches.\n+     *\n+     * @param prefixMatcher  the prefix matcher to use, null ignored\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the prefix matcher is null\n+     */\n+    public StrSubstitutor setVariablePrefixMatcher(StrMatcher prefixMatcher) {\n+        if (prefixMatcher == null) {\n+            throw new IllegalArgumentException(\"Variable prefix matcher must not be null!\");\n+        }\n+        this.prefixMatcher = prefixMatcher;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the variable prefix to use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This method allows a single character prefix to\n+     * be easily set.\n+     *\n+     * @param prefix  the prefix character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrSubstitutor setVariablePrefix(char prefix) {\n+        return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));\n+    }\n+\n+    /**\n+     * Sets the variable prefix to use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This method allows a string prefix to be easily set.\n+     *\n+     * @param prefix  the prefix for variables, not null\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the prefix is null\n+     */\n+    public StrSubstitutor setVariablePrefix(String prefix) {\n+       if (prefix == null) {\n+            throw new IllegalArgumentException(\"Variable prefix must not be null!\");\n+        }\n+        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));\n+    }\n+\n+    // Suffix\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the variable suffix matcher currently in use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This suffix is expressed in terms of a matcher\n+     * allowing advanced suffix matches.\n+     *\n+     * @return the suffix matcher in use\n+     */\n+    public StrMatcher getVariableSuffixMatcher() {\n+        return suffixMatcher;\n+    }\n+\n+    /**\n+     * Sets the variable suffix matcher currently in use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This suffix is expressed in terms of a matcher\n+     * allowing advanced suffix matches.\n+     *\n+     * @param suffixMatcher  the suffix matcher to use, null ignored\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the suffix matcher is null\n+     */\n+    public StrSubstitutor setVariableSuffixMatcher(StrMatcher suffixMatcher) {\n+        if (suffixMatcher == null) {\n+            throw new IllegalArgumentException(\"Variable suffix matcher must not be null!\");\n+        }\n+        this.suffixMatcher = suffixMatcher;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the variable suffix to use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This method allows a single character suffix to\n+     * be easily set.\n+     *\n+     * @param suffix  the suffix character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrSubstitutor setVariableSuffix(char suffix) {\n+        return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));\n+    }\n+\n+    /**\n+     * Sets the variable suffix to use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This method allows a string suffix to be easily set.\n+     *\n+     * @param suffix  the suffix for variables, not null\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the suffix is null\n+     */\n+    public StrSubstitutor setVariableSuffix(String suffix) {\n+       if (suffix == null) {\n+            throw new IllegalArgumentException(\"Variable suffix must not be null!\");\n+        }\n+        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));\n+    }\n+\n+    // Resolver\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the VariableResolver that is used to lookup variables.\n+     *\n+     * @return the VariableResolver\n+     */\n+    public StrLookup getVariableResolver() {\n+        return this.variableResolver;\n+    }\n+\n+    /**\n+     * Sets the VariableResolver that is used to lookup variables.\n+     *\n+     * @param variableResolver  the VariableResolver\n+     */\n+    public void setVariableResolver(StrLookup variableResolver) {\n+        this.variableResolver = variableResolver;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Tokenizes a string based based on delimiters (separators)\n+ * and supporting quoting and ignored character concepts.\n+ * <p>\n+ * This class can split a String into many smaller strings. It aims\n+ * to do a similar job to {@link java.util.StringTokenizer StringTokenizer},\n+ * however it offers much more control and flexibility including implementing\n+ * the <code>ListIterator</code> interface. By default, it is setup\n+ * like <code>StringTokenizer</code>.\n+ * <p>\n+ * The input String is split into a number of <i>tokens</i>.\n+ * Each token is separated from the next String by a <i>delimiter</i>.\n+ * One or more delimiter characters must be specified.\n+ * <p>\n+ * Each token may be surrounded by quotes.\n+ * The <i>quote</i> matcher specifies the quote character(s).\n+ * A quote may be escaped within a quoted section by duplicating itself.\n+ * <p>\n+ * Between each token and the delimiter are potentially characters that need trimming.\n+ * The <i>trimmer</i> matcher specifies these characters.\n+ * One usage might be to trim whitespace characters.\n+ * <p>\n+ * At any point outside the quotes there might potentially be invalid characters.\n+ * The <i>ignored</i> matcher specifies these characters to be removed.\n+ * One usage might be to remove new line characters.\n+ * <p>\n+ * Empty tokens may be removed or returned as null.\n+ * <pre>\n+ * \"a,b,c\"         - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n+ * \" a, b , c \"    - Three tokens \"a\",\"b\",\"c\"   (default CSV processing trims whitespace)\n+ * \"a, \", b ,\", c\" - Three tokens \"a, \" , \" b \", \", c\" (quoted text untouched)\n+ * </pre>\n+ * <p>\n+ *\n+ * This tokenizer has the following properties and options:\n+ *\n+ * <table>\n+ *  <tr>\n+ *   <th>Property</th><th>Type</th><th>Default</th>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>delim</td><td>CharSetMatcher</td><td>{ \\t\\n\\r\\f}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>quote</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignore</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>emptyTokenAsNull</td><td>boolean</td><td>false</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignoreEmptyTokens</td><td>boolean</td><td>true</td>\n+ *  </tr>\n+ * </table>\n+ *\n+ * @author Matthew Inger\n+ * @author Stephen Colebourne\n+ * @author Gary D. Gregory\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class StrTokenizer implements ListIterator, Cloneable {\n+\n+    private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;\n+    private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;\n+    static {\n+        CSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n+        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.commaMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+\n+        TSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n+        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.tabMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+    }\n+\n+    /** The text to work on. */\n+    private char chars[];\n+    /** The parsed tokens */\n+    private String tokens[];\n+    /** The current iteration position */\n+    private int tokenPos;\n+\n+    /** The delimiter matcher */\n+    private StrMatcher delimMatcher = StrMatcher.splitMatcher();\n+    /** The quote matcher */\n+    private StrMatcher quoteMatcher = StrMatcher.noneMatcher();\n+    /** The ignored matcher */\n+    private StrMatcher ignoredMatcher = StrMatcher.noneMatcher();\n+    /** The trimmer matcher */\n+    private StrMatcher trimmerMatcher = StrMatcher.noneMatcher();\n+\n+    /** Whether to return empty tokens as null */\n+    private boolean emptyAsNull = false;\n+    /** Whether to ignore empty tokens */\n+    private boolean ignoreEmptyTokens = true;\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a clone of <code>CSV_TOKENIZER_PROTOTYPE</code>.\n+     * \n+     * @return a clone of <code>CSV_TOKENIZER_PROTOTYPE</code>.\n+     */\n+    private static StrTokenizer getCSVClone() {\n+        return (StrTokenizer) CSV_TOKENIZER_PROTOTYPE.clone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Seperated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overriden with\n+     * the setTrimmer method).\n+     * <p>\n+     * You must call a \"reset\" method to set the string which you want to parse.\n+     * @return a new tokenizer instance which parses Comma Seperated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance() {\n+        return getCSVClone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Seperated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overriden with\n+     * the setTrimmer method).\n+     *\n+     * @param input  the text to parse\n+     * @return a new tokenizer instance which parses Comma Seperated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance(String input) {\n+        StrTokenizer tok = getCSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Seperated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overriden with\n+     * the setTrimmer method).\n+     *\n+     * @param input  the text to parse\n+     * @return a new tokenizer instance which parses Comma Seperated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance(char[] input) {\n+        StrTokenizer tok = getCSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Returns a clone of <code>TSV_TOKENIZER_PROTOTYPE</code>.\n+     * \n+     * @return a clone of <code>TSV_TOKENIZER_PROTOTYPE</code>.\n+     */\n+    private static StrTokenizer getTSVClone() {\n+        return (StrTokenizer) TSV_TOKENIZER_PROTOTYPE.clone();\n+    }\n+\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Seperated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overriden with the setTrimmer method).\n+     * <p>\n+     * You must call a \"reset\" method to set the string which you want to parse.\n+     * @return a new tokenizer instance which parses Tab Seperated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance() {\n+        return getTSVClone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Seperated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overriden with the setTrimmer method).\n+     * @param input  the string to parse\n+     * @return a new tokenizer instance which parses Tab Seperated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance(String input) {\n+        StrTokenizer tok = getTSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Seperated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overriden with the setTrimmer method).\n+     * @param input  the string to parse\n+     * @return a new tokenizer instance which parses Tab Seperated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance(char[] input) {\n+        StrTokenizer tok = getTSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer, but with no text to tokenize.\n+     * <p>\n+     * This constructor is normally used with {@link #reset(String)}.\n+     */\n+    public StrTokenizer() {\n+        super();\n+        this.chars = null;\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     *\n+     * @param input  the string which is to be parsed\n+     */\n+    public StrTokenizer(String input) {\n+        super();\n+        if (input != null) {\n+            chars = input.toCharArray();\n+        } else {\n+            chars = null;\n+        }\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     */\n+    public StrTokenizer(String input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter string.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter string\n+     */\n+    public StrTokenizer(String input, String delim) {\n+        this(input);\n+        setDelimiterString(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter matcher\n+     */\n+    public StrTokenizer(String input, StrMatcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character\n+     * and handling quotes using the specified quote character.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(String input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher\n+     * and handling quotes using the specified quote matcher.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter matcher\n+     * @param quote  the field quoted string matcher\n+     */\n+    public StrTokenizer(String input, StrMatcher delim, StrMatcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     * <p>\n+     * The input character array is not cloned, and must not be altered after\n+     * passing in to this method.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     */\n+    public StrTokenizer(char[] input) {\n+        super();\n+        this.chars = input;\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified character.\n+     * <p>\n+     * The input character array is not cloned, and must not be altered after\n+     * passing in to this method.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim the field delimiter character\n+     */\n+    public StrTokenizer(char[] input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified string.\n+     * <p>\n+     * The input character array is not cloned, and must not be altered after\n+     * passing in to this method.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim the field delimiter string\n+     */\n+    public StrTokenizer(char[] input, String delim) {\n+        this(input);\n+        setDelimiterString(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher.\n+     * <p>\n+     * The input character array is not cloned, and must not be altered after\n+     * passing in to this method.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter matcher\n+     */\n+    public StrTokenizer(char[] input, StrMatcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character\n+     * and handling quotes using the specified quote character.\n+     * <p>\n+     * The input character array is not cloned, and must not be altered after\n+     * passing in to this method.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(char[] input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher\n+     * and handling quotes using the specified quote matcher.\n+     * <p>\n+     * The input character array is not cloned, and must not be altered after\n+     * passing in to this method.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(char[] input, StrMatcher delim, StrMatcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    // API\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of tokens found in the String.\n+     *\n+     * @return the number of matched tokens\n+     */\n+    public int size() {\n+        checkTokenized();\n+        return tokens.length;\n+    }\n+\n+    /**\n+     * Gets the next token from the String.\n+     *\n+     * @return the next sequential token, or null when no more tokens are found\n+     */\n+    public String nextToken() {\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous token from the String.\n+     *\n+     * @return the previous sequential token, or null when no more tokens are found\n+     */\n+    public String previousToken() {\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a copy of the full token list as an independent modifiable array.\n+     *\n+     * @return the tokens as a String array\n+     */\n+    public String[] getTokenArray() {\n+        checkTokenized();\n+        return (String[]) tokens.clone();\n+    }\n+\n+    /**\n+     * Gets a copy of the full token list as an independent modifiable list.\n+     *\n+     * @return the tokens as a String array\n+     */\n+    public List getTokenList() {\n+        checkTokenized();\n+        List list = new ArrayList(tokens.length);\n+        for (int i = 0; i < tokens.length; i++) {\n+            list.add(tokens[i]);\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Resets this tokenizer, forgetting all parsing and iteration already completed.\n+     * <p>\n+     * This method allows the same tokenizer to be reused for the same String.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset() {\n+        tokenPos = 0;\n+        tokens = null;\n+        return this;\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     *\n+     * @param input  the new string to tokenize, null sets no text to parse\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset(String input) {\n+        reset();\n+        if (input != null) {\n+            this.chars = input.toCharArray();\n+        } else {\n+            this.chars = null;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     * <p>\n+     * The input character array is not cloned, and must not be altered after\n+     * passing in to this method.\n+     *\n+     * @param input  the new character array to tokenize, not cloned, null sets no text to parse\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset(char[] input) {\n+        reset();\n+        this.chars = input;\n+        return this;\n+    }\n+\n+    // ListIterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there are any more tokens.\n+     *\n+     * @return true if there are more tokens\n+     */\n+    public boolean hasNext() {\n+        checkTokenized();\n+        return tokenPos < tokens.length;\n+    }\n+\n+    /**\n+     * Gets the next token. This method is equivalent to {@link #nextToken()}.\n+     *\n+     * @return the next String token\n+     */\n+    public Object next() {\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        }\n+        throw new NoSuchElementException();\n+    }\n+\n+    /**\n+     * Gets the index of the next token to return.\n+     *\n+     * @return the next token index\n+     */\n+    public int nextIndex() {\n+        return tokenPos;\n+    }\n+\n+    /**\n+     * Checks whether there are any previous tokens that can be iterated to.\n+     *\n+     * @return true if there are previous tokens\n+     */\n+    public boolean hasPrevious() {\n+        checkTokenized();\n+        return tokenPos > 0;\n+    }\n+\n+    /**\n+     * Gets the token previous to the last returned token.\n+     *\n+     * @return the previous token\n+     */\n+    public Object previous() {\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        }\n+        throw new NoSuchElementException();\n+    }\n+\n+    /**\n+     * Gets the index of the previous token.\n+     *\n+     * @return the previous token index\n+     */\n+    public int previousIndex() {\n+        return tokenPos - 1;\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     * @param obj this parameter ignored.\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void set(Object obj) {\n+        throw new UnsupportedOperationException(\"set() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     * @param obj this parameter ignored.\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void add(Object obj) {\n+        throw new UnsupportedOperationException(\"add() is unsupported\");\n+    }\n+\n+    // Implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if tokenization has been done, and if not then do it.\n+     */\n+    private void checkTokenized() {\n+        if (tokens == null) {\n+            if (chars == null) {\n+                // still call tokenize as subclass may do some work\n+                List split = tokenize(null, 0, 0);\n+                tokens = (String[]) split.toArray(new String[split.size()]);\n+            } else {\n+                List split = tokenize(chars, 0, chars.length);\n+                tokens = (String[]) split.toArray(new String[split.size()]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method to performs the tokenization.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method\n+     * will be called automatically by other (public) methods when required.\n+     * <p>\n+     * This method exists to allow subclasses to add code before or after the\n+     * tokenization. For example, a subclass could alter the character array,\n+     * offset or count to be parsed, or call the tokenizer multiple times on\n+     * multiple strings. It is also be possible to filter the results.\n+     * <p>\n+     * <code>StrTokenizer</code> will always pass a zero offset and a count\n+     * equal to the length of the array to this method, however a subclass\n+     * may pass other values, or even an entirely different array.\n+     * \n+     * @param chars  the character array being tokenized, may be null\n+     * @param offset  the start position within the character array, must be valid\n+     * @param count  the number of characters to tokenize, must be valid\n+     * @return the modifiable list of String tokens, unmodifiable if null array or zero count\n+     */\n+    protected List tokenize(char[] chars, int offset, int count) {\n+        if (chars == null || count == 0) {\n+            return Collections.EMPTY_LIST;\n+        }\n+        StrBuilder buf = new StrBuilder();\n+        List tokens = new ArrayList();\n+        int pos = offset;\n+        \n+        // loop around the entire buffer\n+        while (pos >= 0 && pos < count) {\n+            // find next token\n+            pos = readNextToken(chars, pos, count, buf, tokens);\n+            \n+            // handle case where end of string is a delimiter\n+            if (pos >= count) {\n+                addToken(tokens, \"\");\n+            }\n+        }\n+        return tokens;\n+    }\n+\n+    /**\n+     * Adds a token to a list, paying attention to the parameters we've set.\n+     *\n+     * @param list  the list to add to\n+     * @param tok  the token to add\n+     */\n+    private void addToken(List list, String tok) {\n+        if (tok == null || tok.length() == 0) {\n+            if (isIgnoreEmptyTokens()) {\n+                return;\n+            }\n+            if (isEmptyTokenAsNull()) {\n+                tok = null;\n+            }\n+        }\n+        list.add(tok);\n+    }\n+\n+    /**\n+     * Reads character by character through the String to get the next token.\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param start  the first character of field\n+     * @param len  the length of the character array being tokenized\n+     * @param workArea  a temporary work area\n+     * @param tokens  the list of parsed tokens\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter), or -1 if end of string found\n+     */\n+    private int readNextToken(char[] chars, int start, int len, StrBuilder workArea, List tokens) {\n+        // skip all leading whitespace, unless it is the\n+        // field delimiter or the quote character\n+        while (start < len) {\n+            int removeLen = Math.max(\n+                    getIgnoredMatcher().isMatch(chars, start, start, len),\n+                    getTrimmerMatcher().isMatch(chars, start, start, len));\n+            if (removeLen == 0 ||\n+                getDelimiterMatcher().isMatch(chars, start, start, len) > 0 ||\n+                getQuoteMatcher().isMatch(chars, start, start, len) > 0) {\n+                break;\n+            }\n+            start += removeLen;\n+        }\n+        \n+        // handle reaching end\n+        if (start >= len) {\n+            addToken(tokens, \"\");\n+            return -1;\n+        }\n+        \n+        // handle empty token\n+        int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len);\n+        if (delimLen > 0) {\n+            addToken(tokens, \"\");\n+            return start + delimLen;\n+        }\n+        \n+        // handle found token\n+        int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len);\n+        if (quoteLen > 0) {\n+            return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen);\n+        }\n+        return readWithQuotes(chars, start, len, workArea, tokens, 0, 0);\n+    }\n+\n+    /**\n+     * Reads a possibly quoted string token.\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param start  the first character of field\n+     * @param len  the length of the character array being tokenized\n+     * @param workArea  a temporary work area\n+     * @param tokens  the list of parsed tokens\n+     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n+     * @param quoteLen  the length of the matched quote, 0 if no quoting\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter, or if end of string found,\n+     *  then the length of string\n+     */\n+    private int readWithQuotes(char[] chars, int start, int len, StrBuilder workArea, \n+                               List tokens, int quoteStart, int quoteLen) \n+    {\n+        // Loop until we've found the end of the quoted\n+        // string or the end of the input\n+        workArea.clear();\n+        int pos = start;\n+        boolean quoting = (quoteLen > 0);\n+        int trimStart = 0;\n+        \n+        while (pos < len) {\n+            // quoting mode can occur several times throughout a string\n+            // we must switch between quoting and non-quoting until we\n+            // encounter a non-quoted delimiter, or end of string\n+            if (quoting) {\n+                // In quoting mode\n+                \n+                // If we've found a quote character, see if it's\n+                // followed by a second quote.  If so, then we need\n+                // to actually put the quote character into the token\n+                // rather than end the token.\n+                if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n+                    if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) {\n+                        // matched pair of quotes, thus an escaped quote\n+                        workArea.append(chars, pos, quoteLen);\n+                        pos += (quoteLen * 2);\n+                        trimStart = workArea.size();\n+                        continue;\n+                    }\n+                    \n+                    // end of quoting\n+                    quoting = false;\n+                    pos += quoteLen;\n+                    continue;\n+                }\n+                \n+                // copy regular character from inside quotes\n+                workArea.append(chars[pos++]);\n+                trimStart = workArea.size();\n+                \n+            } else {\n+                // Not in quoting mode\n+                \n+                // check for delimiter, and thus end of token\n+                int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len);\n+                if (delimLen > 0) {\n+                    // return condition when end of token found\n+                    addToken(tokens, workArea.substring(0, trimStart));\n+                    return pos + delimLen;\n+                }\n+                \n+                // check for quote, and thus back into quoting mode\n+                if (quoteLen > 0) {\n+                    if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n+                        quoting = true;\n+                        pos += quoteLen;\n+                        continue;\n+                    }\n+                }\n+                \n+                // check for ignored (outside quotes), and ignore\n+                int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len);\n+                if (ignoredLen > 0) {\n+                    pos += ignoredLen;\n+                    continue;\n+                }\n+                \n+                // check for trimmed character\n+                // don't yet know if its at the end, so copy to workArea\n+                // use trimStart to keep track of trim at the end\n+                int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len);\n+                if (trimmedLen > 0) {\n+                    workArea.append(chars, pos, trimmedLen);\n+                    pos += trimmedLen;\n+                    continue;\n+                }\n+                \n+                // copy regular character from outside quotes\n+                workArea.append(chars[pos++]);\n+                trimStart = workArea.size();\n+            }\n+        }\n+        \n+        // return condition when end of string found\n+        addToken(tokens, workArea.substring(0, trimStart));\n+        return -1;\n+    }\n+\n+    /**\n+     * Checks if the characters at the index specified match the quote\n+     * already matched in readNextToken().\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param pos  the position to check for a quote\n+     * @param len  the length of the character array being tokenized\n+     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n+     * @param quoteLen  the length of the matched quote, 0 if no quoting\n+     * @return true if a quote is matched\n+     */\n+    private boolean isQuote(char[] chars, int pos, int len, int quoteStart, int quoteLen) {\n+        for (int i = 0; i < quoteLen; i++) {\n+            if ((pos + i) >= len || chars[pos + i] != chars[quoteStart + i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Delimiter\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field delimiter matcher.\n+     *\n+     * @return the delimiter matcher in use\n+     */\n+    public StrMatcher getDelimiterMatcher() {\n+        return this.delimMatcher;\n+    }\n+\n+    /**\n+     * Sets the field delimiter matcher.\n+     * <p>\n+     * The delimitier is used to separate one token from another.\n+     *\n+     * @param delim  the delimiter matcher to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterMatcher(StrMatcher delim) {\n+        if (delim == null) {\n+            this.delimMatcher = StrMatcher.noneMatcher();\n+        } else {\n+            this.delimMatcher = delim;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the field delimiter character.\n+     *\n+     * @param delim  the delimiter character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterChar(char delim) {\n+        return setDelimiterMatcher(StrMatcher.charMatcher(delim));\n+    }\n+\n+    /**\n+     * Sets the field delimiter string.\n+     *\n+     * @param delim  the delimiter string to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterString(String delim) {\n+        return setDelimiterMatcher(StrMatcher.stringMatcher(delim));\n+    }\n+\n+    // Quote\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the quote matcher currently in use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * The default value is '\"' (double quote).\n+     *\n+     * @return the quote matcher in use\n+     */\n+    public StrMatcher getQuoteMatcher() {\n+        return quoteMatcher;\n+    }\n+\n+    /**\n+     * Set the quote matcher to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     *\n+     * @param quote  the quote matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setQuoteMatcher(StrMatcher quote) {\n+        if (quote != null) {\n+            this.quoteMatcher = quote;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the quote character to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     *\n+     * @param quote  the quote character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setQuoteChar(char quote) {\n+        return setQuoteMatcher(StrMatcher.charMatcher(quote));\n+    }\n+\n+    // Ignored\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the ignored character matcher.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     * The default value is not to ignore anything.\n+     *\n+     * @return the ignored matcher in use\n+     */\n+    public StrMatcher getIgnoredMatcher() {\n+        return ignoredMatcher;\n+    }\n+\n+    /**\n+     * Set the matcher for characters to ignore.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     *\n+     * @param ignored  the ignored matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoredMatcher(StrMatcher ignored) {\n+        if (ignored != null) {\n+            this.ignoredMatcher = ignored;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Set the character to ignore.\n+     * <p>\n+     * This character is ignored when parsing the String, unless it is\n+     * within a quoted region.\n+     *\n+     * @param ignored  the ignored character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoredChar(char ignored) {\n+        return setIgnoredMatcher(StrMatcher.charMatcher(ignored));\n+    }\n+\n+    // Trimmer\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the trimmer character matcher.\n+     * <p>\n+     * These characters are trimmed off on each side of the delimiter\n+     * until the token or quote is found.\n+     * The default value is not to trim anything.\n+     *\n+     * @return the trimmer matcher in use\n+     */\n+    public StrMatcher getTrimmerMatcher() {\n+        return trimmerMatcher;\n+    }\n+\n+    /**\n+     * Sets the matcher for characters to trim.\n+     * <p>\n+     * These characters are trimmed off on each side of the delimiter\n+     * until the token or quote is found.\n+     *\n+     * @param trimmer  the trimmer matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setTrimmerMatcher(StrMatcher trimmer) {\n+        if (trimmer != null) {\n+            this.trimmerMatcher = trimmer;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently returns empty tokens as null.\n+     * The default for this property is false.\n+     *\n+     * @return true if empty tokens are returned as null\n+     */\n+    public boolean isEmptyTokenAsNull() {\n+        return this.emptyAsNull;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should return empty tokens as null.\n+     * The default for this property is false.\n+     *\n+     * @param emptyAsNull  whether empty tokens are returned as null\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setEmptyTokenAsNull(boolean emptyAsNull) {\n+        this.emptyAsNull = emptyAsNull;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently ignores empty tokens.\n+     * The default for this property is false.\n+     *\n+     * @return true if empty tokens are not returned\n+     */\n+    public boolean isIgnoreEmptyTokens() {\n+        return ignoreEmptyTokens;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should ignore and not return empty tokens.\n+     * The default for this property is false.\n+     *\n+     * @param ignoreEmptyTokens  whether empty tokens are not returned\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n+        this.ignoreEmptyTokens = ignoreEmptyTokens;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the String content that the tokenizer is parsing.\n+     *\n+     * @return the string content being parsed\n+     */\n+    public String getContent() {\n+        if (chars == null) {\n+            return null;\n+        }\n+        return new String(chars);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance of this Tokenizer. The new instance is reset so\n+     * that it will be at the start of the token list.\n+     * If a {@link CloneNotSupportedException} is caught, return <code>null</code>.\n+     * \n+     * @return a new instance of this Tokenizer which has been reset.\n+     */\n+    public Object clone() {\n+        try {\n+            return cloneReset();\n+        } catch (CloneNotSupportedException ex) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of this Tokenizer. The new instance is reset so that\n+     * it will be at the start of the token list.\n+     * \n+     * @return a new instance of this Tokenizer which has been reset.\n+     * @throws CloneNotSupportedException if there is a problem cloning\n+     */\n+    Object cloneReset() throws CloneNotSupportedException {\n+        StrTokenizer cloned = (StrTokenizer) super.clone();\n+        if (cloned.chars != null) {\n+            cloned.chars = (char[]) cloned.chars.clone();\n+        }\n+        cloned.reset();\n+        return cloned;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the String content that the tokenizer is parsing.\n+     *\n+     * @return the string content being parsed\n+     */\n+    public String toString() {\n+        if (tokens == null) {\n+            return \"StrTokenizer[not tokenized yet]\";\n+        } else {\n+            return \"StrTokenizer\" + getTokenList();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/time/DateFormatUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>Date and time formatting utilities and constants.</p>\n+ *\n+ * <p>Formatting is performed using the\n+ * {@link org.apache.commons.lang.time.FastDateFormat} class.</p>\n+ *\n+ * @author Apache Ant - DateUtils\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class DateFormatUtils {\n+\n+    /**\n+     * ISO8601 formatter for date-time without time zone.\n+     * The format used is <tt>yyyy-MM-dd'T'HH:mm:ss</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATETIME_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+\n+    /**\n+     * ISO8601 formatter for date-time with time zone.\n+     * The format used is <tt>yyyy-MM-dd'T'HH:mm:ssZZ</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATETIME_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ssZZ\");\n+\n+    /**\n+     * ISO8601 formatter for date without time zone.\n+     * The format used is <tt>yyyy-MM-dd</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd\");\n+\n+    /**\n+     * ISO8601-like formatter for date with time zone.\n+     * The format used is <tt>yyyy-MM-ddZZ</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard does not allow a time zone  without a time.\n+     */\n+    public static final FastDateFormat ISO_DATE_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-ddZZ\");\n+\n+    /**\n+     * ISO8601 formatter for time without time zone.\n+     * The format used is <tt>'T'HH:mm:ss</tt>.\n+     */\n+    public static final FastDateFormat ISO_TIME_FORMAT\n+            = FastDateFormat.getInstance(\"'T'HH:mm:ss\");\n+\n+    /**\n+     * ISO8601 formatter for time with time zone.\n+     * The format used is <tt>'T'HH:mm:ssZZ</tt>.\n+     */\n+    public static final FastDateFormat ISO_TIME_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"'T'HH:mm:ssZZ\");\n+\n+    /**\n+     * ISO8601-like formatter for time without time zone.\n+     * The format used is <tt>HH:mm:ss</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard requires the 'T' prefix for times.\n+     */\n+    public static final FastDateFormat ISO_TIME_NO_T_FORMAT\n+            = FastDateFormat.getInstance(\"HH:mm:ss\");\n+\n+    /**\n+     * ISO8601-like formatter for time with time zone.\n+     * The format used is <tt>HH:mm:ssZZ</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard requires the 'T' prefix for times.\n+     */\n+    public static final FastDateFormat ISO_TIME_NO_T_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"HH:mm:ssZZ\");\n+\n+    /**\n+     * SMTP (and probably other) date headers.\n+     * The format used is <tt>EEE, dd MMM yyyy HH:mm:ss Z</tt> in US locale.\n+     */\n+    public static final FastDateFormat SMTP_DATETIME_FORMAT\n+            = FastDateFormat.getInstance(\"EEE, dd MMM yyyy HH:mm:ss Z\", Locale.US);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>DateFormatUtils instances should NOT be constructed in standard programming.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public DateFormatUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(long millis, String pattern) {\n+        return format(new Date(millis), pattern, DateUtils.UTC_TIME_ZONE, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(Date date, String pattern) {\n+        return format(date, pattern, DateUtils.UTC_TIME_ZONE, null);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(long millis, String pattern, Locale locale) {\n+        return format(new Date(millis), pattern, DateUtils.UTC_TIME_ZONE, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(Date date, String pattern, Locale locale) {\n+        return format(date, pattern, DateUtils.UTC_TIME_ZONE, locale);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern) {\n+        return format(new Date(millis), pattern, null, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern) {\n+        return format(date, pattern, null, null);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone.</p>\n+     * \n+     * @param millis  the time expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, TimeZone timeZone) {\n+        return format(new Date(millis), pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, TimeZone timeZone) {\n+        return format(date, pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a locale.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, Locale locale) {\n+        return format(new Date(millis), pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a locale.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, Locale locale) {\n+        return format(date, pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone  and locale.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, TimeZone timeZone, Locale locale) {\n+        return format(new Date(millis), pattern, timeZone, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone  and locale.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n+        return df.format(date);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/time/DateUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>A suite of utilities surrounding the use of the\n+ * {@link java.util.Calendar} and {@link java.util.Date} object.</p>\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ * @author Stephen Colebourne\n+ * @author Janek Bogucki\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Phil Steitz\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class DateUtils {\n+    \n+    /**\n+     * The UTC time zone  (often referred to as GMT).\n+     */\n+    public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\");\n+    /**\n+     * Number of milliseconds in a standard second.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_SECOND = 1000;\n+    /**\n+     * Number of milliseconds in a standard minute.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n+    /**\n+     * Number of milliseconds in a standard hour.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n+    /**\n+     * Number of milliseconds in a standard day.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n+\n+    /**\n+     * This is half a month, so this represents whether a date is in the top\n+     * or bottom half of the month.\n+     */\n+    public final static int SEMI_MONTH = 1001;\n+\n+    private static final int[][] fields = {\n+            {Calendar.MILLISECOND},\n+            {Calendar.SECOND},\n+            {Calendar.MINUTE},\n+            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n+            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n+                /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n+            },\n+            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n+            {Calendar.YEAR},\n+            {Calendar.ERA}};\n+\n+    /**\n+     * A week range, starting on Sunday.\n+     */\n+    public final static int RANGE_WEEK_SUNDAY = 1;\n+\n+    /**\n+     * A week range, starting on Monday.\n+     */\n+    public final static int RANGE_WEEK_MONDAY = 2;\n+\n+    /**\n+     * A week range, starting on the day focused.\n+     */\n+    public final static int RANGE_WEEK_RELATIVE = 3;\n+\n+    /**\n+     * A week range, centered around the day focused.\n+     */\n+    public final static int RANGE_WEEK_CENTER = 4;\n+\n+    /**\n+     * A month range, the week starting on Sunday.\n+     */\n+    public final static int RANGE_MONTH_SUNDAY = 5;\n+\n+    /**\n+     * A month range, the week starting on Monday.\n+     */\n+    public final static int RANGE_MONTH_MONDAY = 6;\n+\n+    /**\n+     * <p><code>DateUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>DateUtils.parse(str);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public DateUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two date objects are on the same day ignoring time.</p>\n+     *\n+     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n+     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n+     * </p>\n+     * \n+     * @param date1  the first date, not altered, not null\n+     * @param date2  the second date, not altered, not null\n+     * @return true if they represent the same day\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameDay(Date date1, Date date2) {\n+        if (date1 == null || date2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar cal1 = Calendar.getInstance();\n+        cal1.setTime(date1);\n+        Calendar cal2 = Calendar.getInstance();\n+        cal2.setTime(date2);\n+        return isSameDay(cal1, cal2);\n+    }\n+\n+    /**\n+     * <p>Checks if two calendar objects are on the same day ignoring time.</p>\n+     *\n+     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n+     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n+     * </p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same day\n+     * @throws IllegalArgumentException if either calendar is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n+                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n+                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two date objects represent the same instant in time.</p>\n+     *\n+     * <p>This method compares the long millisecond time of the two objects.</p>\n+     * \n+     * @param date1  the first date, not altered, not null\n+     * @param date2  the second date, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameInstant(Date date1, Date date2) {\n+        if (date1 == null || date2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return date1.getTime() == date2.getTime();\n+    }\n+\n+    /**\n+     * <p>Checks if two calendar objects represent the same instant in time.</p>\n+     *\n+     * <p>This method compares the long millisecond time of the two objects.</p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return cal1.getTime().getTime() == cal2.getTime().getTime();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two calendar objects represent the same local time.</p>\n+     *\n+     * <p>This method compares the values of the fields of the two objects.\n+     * In addition, both calendars must be the same of the same type.</p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n+                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n+                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n+                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n+                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n+                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n+                cal1.getClass() == cal2.getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n+     * \n+     * <p>The parse will try each parse pattern in turn.\n+     * A parse is only deemed sucessful if it parses the whole of the input string.\n+     * If no parse patterns match, a ParseException is thrown.</p>\n+     * \n+     * @param str  the date to parse, not null\n+     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date string or pattern array is null\n+     * @throws ParseException if none of the date patterns were suitable\n+     */\n+    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n+        if (str == null || parsePatterns == null) {\n+            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n+        }\n+        \n+        SimpleDateFormat parser = null;\n+        ParsePosition pos = new ParsePosition(0);\n+        for (int i = 0; i < parsePatterns.length; i++) {\n+            if (i == 0) {\n+                parser = new SimpleDateFormat(parsePatterns[0]);\n+            } else {\n+                parser.applyPattern(parsePatterns[i]);\n+            }\n+            pos.setIndex(0);\n+            Date date = parser.parse(str, pos);\n+            if (date != null && pos.getIndex() == str.length()) {\n+                return date;\n+            }\n+        }\n+        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of years to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addYears(Date date, int amount) {\n+        return add(date, Calendar.YEAR, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of months to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMonths(Date date, int amount) {\n+        return add(date, Calendar.MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of weeks to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addWeeks(Date date, int amount) {\n+        return add(date, Calendar.WEEK_OF_YEAR, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of days to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addDays(Date date, int amount) {\n+        return add(date, Calendar.DAY_OF_MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of hours to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addHours(Date date, int amount) {\n+        return add(date, Calendar.HOUR_OF_DAY, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of minutes to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMinutes(Date date, int amount) {\n+        return add(date, Calendar.MINUTE, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of seconds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addSeconds(Date date, int amount) {\n+        return add(date, Calendar.SECOND, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of milliseconds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMilliseconds(Date date, int amount) {\n+        return add(date, Calendar.MILLISECOND, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param calendarField  the calendar field to add to\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date add(Date date, int calendarField, int amount) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar c = Calendar.getInstance();\n+        c.setTime(date);\n+        c.add(calendarField, amount);\n+        return c.getTime();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date round(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify(gval, field, true);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Calendar round(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar rounded = (Calendar) date.clone();\n+        modify(rounded, field, true);\n+        return rounded;\n+    }\n+\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with, either Date or Calendar\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ClassCastException if the object type is not a <code>Date</code>\n+     *  or <code>Calendar</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date round(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return round((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return round((Calendar) date, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not round \" + date);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date truncate(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify(gval, field, false);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Calendar truncate(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar truncated = (Calendar) date.clone();\n+        modify(truncated, field, false);\n+        return truncated;\n+    }\n+\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with, either <code>Date</code>\n+     *  or <code>Calendar</code>\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date\n+     *  is <code>null</code>\n+     * @throws ClassCastException if the object type is not a\n+     *  <code>Date</code> or <code>Calendar</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date truncate(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return truncate((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return truncate((Calendar) date, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not truncate \" + date);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Internal calculation method.</p>\n+     * \n+     * @param val  the calendar\n+     * @param field  the field constant\n+     * @param round  true to round, false to truncate\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    private static void modify(Calendar val, int field, boolean round) {\n+        if (val.get(Calendar.YEAR) > 280000000) {\n+            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n+        }\n+        \n+        if (field == Calendar.MILLISECOND) {\n+            return;\n+        }\n+\n+        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n+        // see http://issues.apache.org/jira/browse/LANG-59\n+        //\n+        // Manually truncate milliseconds, seconds and minutes, rather than using\n+        // Calendar methods.\n+\n+        Date date = val.getTime();\n+        long time = date.getTime();\n+        boolean done = false;\n+\n+        // truncate milliseconds\n+        int millisecs = val.get(Calendar.MILLISECOND);\n+        if (!round || millisecs < 500) {\n+            time = time - millisecs;\n+            if (field == Calendar.SECOND) {\n+                done = true;\n+            }\n+        }\n+\n+        // truncate seconds\n+        int seconds = val.get(Calendar.SECOND);\n+        if (!done && (!round || seconds < 30)) {\n+            time = time - (seconds * 1000L);\n+            if (field == Calendar.MINUTE) {\n+                done = true;\n+            }\n+        }\n+\n+        // truncate minutes\n+        int minutes = val.get(Calendar.MINUTE);\n+        if (!done && (!round || minutes < 30)) {\n+            time = time - (minutes * 60000L);\n+        }\n+\n+        // reset time\n+        if (date.getTime() != time) {\n+            date.setTime(time);\n+            val.setTime(date);\n+        }\n+        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n+\n+        boolean roundUp = false;\n+        for (int i = 0; i < fields.length; i++) {\n+            for (int j = 0; j < fields[i].length; j++) {\n+                if (fields[i][j] == field) {\n+                    //This is our field... we stop looping\n+                    if (round && roundUp) {\n+                        if (field == DateUtils.SEMI_MONTH) {\n+                            //This is a special case that's hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) == 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(fields[i][0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset = 0;\n+            boolean offsetSet = false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case DateUtils.SEMI_MONTH:\n+                    if (fields[i][0] == Calendar.DATE) {\n+                        //If we're going to drop the DATE field's value,\n+                        //  we want to do this our own way.\n+                        //We need to subtrace 1 since the date has a minimum of 1\n+                        offset = val.get(Calendar.DATE) - 1;\n+                        //If we're above 15 days adjustment, that means we're in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset >= 15) {\n+                            offset -= 15;\n+                        }\n+                        //Record whether we're in the top or bottom half of that range\n+                        roundUp = offset > 7;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n+                        //If we're going to drop the HOUR field's value,\n+                        //  we want to do this our own way.\n+                        offset = val.get(Calendar.HOUR_OF_DAY);\n+                        if (offset >= 12) {\n+                            offset -= 12;\n+                        }\n+                        roundUp = offset > 6;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                int min = val.getActualMinimum(fields[i][0]);\n+                int max = val.getActualMaximum(fields[i][0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset = val.get(fields[i][0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp = offset > ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            if (offset != 0) {\n+                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * <p>This method provides an iterator that returns Calendar objects.\n+     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n+     *\n+     * @param focus  the date to work with, not null\n+     * @param rangeStyle  the style constant to use. Must be one of\n+     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n+     * {@link DateUtils#RANGE_MONTH_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n+     * {@link DateUtils#RANGE_WEEK_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n+     * {@link DateUtils#RANGE_WEEK_CENTER}\n+     * @return the date iterator, which always returns Calendar instances\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws IllegalArgumentException if the rangeStyle is invalid\n+     */\n+    public static Iterator iterator(Date focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(focus);\n+        return iterator(gval, rangeStyle);\n+    }\n+\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * <p>This method provides an iterator that returns Calendar objects.\n+     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n+     *\n+     * @param focus  the date to work with\n+     * @param rangeStyle  the style constant to use. Must be one of\n+     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n+     * {@link DateUtils#RANGE_MONTH_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n+     * {@link DateUtils#RANGE_WEEK_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n+     * {@link DateUtils#RANGE_WEEK_CENTER}\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws IllegalArgumentException if the rangeStyle is invalid\n+     */\n+    public static Iterator iterator(Calendar focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar start = null;\n+        Calendar end = null;\n+        int startCutoff = Calendar.SUNDAY;\n+        int endCutoff = Calendar.SATURDAY;\n+        switch (rangeStyle) {\n+            case RANGE_MONTH_SUNDAY:\n+            case RANGE_MONTH_MONDAY:\n+                //Set start to the first of the month\n+                start = truncate(focus, Calendar.MONTH);\n+                //Set end to the last of the month\n+                end = (Calendar) start.clone();\n+                end.add(Calendar.MONTH, 1);\n+                end.add(Calendar.DATE, -1);\n+                //Loop start back to the previous sunday or monday\n+                if (rangeStyle == RANGE_MONTH_MONDAY) {\n+                    startCutoff = Calendar.MONDAY;\n+                    endCutoff = Calendar.SUNDAY;\n+                }\n+                break;\n+            case RANGE_WEEK_SUNDAY:\n+            case RANGE_WEEK_MONDAY:\n+            case RANGE_WEEK_RELATIVE:\n+            case RANGE_WEEK_CENTER:\n+                //Set start and end to the current date\n+                start = truncate(focus, Calendar.DATE);\n+                end = truncate(focus, Calendar.DATE);\n+                switch (rangeStyle) {\n+                    case RANGE_WEEK_SUNDAY:\n+                        //already set by default\n+                        break;\n+                    case RANGE_WEEK_MONDAY:\n+                        startCutoff = Calendar.MONDAY;\n+                        endCutoff = Calendar.SUNDAY;\n+                        break;\n+                    case RANGE_WEEK_RELATIVE:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n+                        endCutoff = startCutoff - 1;\n+                        break;\n+                    case RANGE_WEEK_CENTER:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n+                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n+                        break;\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n+        }\n+        if (startCutoff < Calendar.SUNDAY) {\n+            startCutoff += 7;\n+        }\n+        if (startCutoff > Calendar.SATURDAY) {\n+            startCutoff -= 7;\n+        }\n+        if (endCutoff < Calendar.SUNDAY) {\n+            endCutoff += 7;\n+        }\n+        if (endCutoff > Calendar.SATURDAY) {\n+            endCutoff -= 7;\n+        }\n+        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n+            start.add(Calendar.DATE, -1);\n+        }\n+        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n+            end.add(Calendar.DATE, 1);\n+        }\n+        return new DateIterator(start, end);\n+    }\n+\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * @param focus  the date to work with, either\n+     *  <code>Date</code> or <code>Calendar</code>\n+     * @param rangeStyle  the style constant to use. Must be one of the range\n+     * styles listed for the {@link #iterator(Calendar, int)} method.\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date\n+     *  is <code>null</code>\n+     * @throws ClassCastException if the object type is\n+     *  not a <code>Date</code> or <code>Calendar</code>\n+     */\n+    public static Iterator iterator(Object focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (focus instanceof Date) {\n+            return iterator((Date) focus, rangeStyle);\n+        } else if (focus instanceof Calendar) {\n+            return iterator((Calendar) focus, rangeStyle);\n+        } else {\n+            throw new ClassCastException(\"Could not iterate based on \" + focus);\n+        }\n+    }\n+\n+    /**\n+     * <p>Date iterator.</p>\n+     */\n+    static class DateIterator implements Iterator {\n+        private final Calendar endFinal;\n+        private final Calendar spot;\n+        \n+        /**\n+         * Constructs a DateIterator that ranges from one date to another. \n+         *\n+         * @param startFinal start date (inclusive)\n+         * @param endFinal end date (not inclusive)\n+         */\n+        DateIterator(Calendar startFinal, Calendar endFinal) {\n+            super();\n+            this.endFinal = endFinal;\n+            spot = startFinal;\n+            spot.add(Calendar.DATE, -1);\n+        }\n+\n+        /**\n+         * Has the iterator not reached the end date yet?\n+         *\n+         * @return <code>true</code> if the iterator has yet to reach the end date\n+         */\n+        public boolean hasNext() {\n+            return spot.before(endFinal);\n+        }\n+\n+        /**\n+         * Return the next calendar in the iteration\n+         *\n+         * @return Object calendar for the next date\n+         */\n+        public Object next() {\n+            if (spot.equals(endFinal)) {\n+                throw new NoSuchElementException();\n+            }\n+            spot.add(Calendar.DATE, 1);\n+            return spot.clone();\n+        }\n+\n+        /**\n+         * Always throws UnsupportedOperationException.\n+         * \n+         * @throws UnsupportedOperationException\n+         * @see java.util.Iterator#remove()\n+         */\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+    \n+    //------------------------------------------------------------------------- \n+    // Deprecated int constants\n+    // TODO: Remove in 3.0\n+    \n+    /**\n+     * Number of milliseconds in a standard second.\n+     * \n+     * @deprecated Use MILLIS_PER_SECOND. This will be removed in Commons Lang 3.0.\n+     */\n+    public static final int MILLIS_IN_SECOND = 1000;\n+    /**\n+     * Number of milliseconds in a standard minute.\n+     * \n+     * @deprecated Use MILLIS_PER_MINUTE. This will be removed in Commons Lang 3.0.\n+     */\n+    public static final int MILLIS_IN_MINUTE = 60 * 1000;\n+    /**\n+     * Number of milliseconds in a standard hour.\n+     * \n+     * @deprecated Use MILLIS_PER_HOUR. This will be removed in Commons Lang 3.0.\n+     */\n+    public static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n+    /**\n+     * Number of milliseconds in a standard day.\n+     * \n+     * @deprecated Use MILLIS_PER_DAY. This will be removed in Commons Lang 3.0.\n+     */\n+    public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>Duration formatting utilities and constants. The following table describes the tokens \n+ * used in the pattern language for formatting. </p>\n+ * <table border=\"1\">\n+ *  <tr><th>character</th><th>duration element</th></tr>\n+ *  <tr><td>y</td><td>years</td></tr>\n+ *  <tr><td>M</td><td>months</td></tr>\n+ *  <tr><td>d</td><td>days</td></tr>\n+ *  <tr><td>H</td><td>hours</td></tr>\n+ *  <tr><td>m</td><td>minutes</td></tr>\n+ *  <tr><td>s</td><td>seconds</td></tr>\n+ *  <tr><td>S</td><td>milliseconds</td></tr>\n+ * </table>\n+ *\n+ * @author Apache Ant - DateUtils\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Henri Yandell\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class DurationFormatUtils {\n+\n+    /**\n+     * <p>DurationFormatUtils instances should NOT be constructed in standard programming.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public DurationFormatUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n+     * for the ISO8601 period format used in durations.</p>\n+     * \n+     * @see org.apache.commons.lang.time.FastDateFormat\n+     * @see java.text.SimpleDateFormat\n+     */\n+    public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\";\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is ISO8601-like:\n+     * <i>H</i>:<i>m</i>:<i>s</i>.<i>S</i>.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatDurationHMS(long durationMillis) {\n+        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is the ISO8601 period format.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * ISO format pattern, such as P7D6TH5M4.321S.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatDurationISO(long durationMillis) {\n+        return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format, and padding with zeros and \n+     * using the default timezone.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @param format  the way in which to format the duration\n+     * @return the time as a String\n+     */\n+    public static String formatDuration(long durationMillis, String format) {\n+        return formatDuration(durationMillis, format, true);\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional and \n+     * the timezone may be specified.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @param format  the way in which to format the duration\n+     * @param padWithZeros  whether to pad the left hand side of numbers with 0's\n+     * @return the time as a String\n+     */\n+    public static String formatDuration(long durationMillis, String format, boolean padWithZeros) {\n+\n+        Token[] tokens = lexx(format);\n+\n+        int days         = 0;\n+        int hours        = 0;\n+        int minutes      = 0;\n+        int seconds      = 0;\n+        int milliseconds = 0;\n+        \n+        if (Token.containsTokenWithValue(tokens, d) ) {\n+            days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);\n+            durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);\n+        }\n+        if (Token.containsTokenWithValue(tokens, H) ) {\n+            hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);\n+            durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);\n+        }\n+        if (Token.containsTokenWithValue(tokens, m) ) {\n+            minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);\n+            durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n+        }\n+        if (Token.containsTokenWithValue(tokens, s) ) {\n+            seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);\n+            durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);\n+        }\n+        if (Token.containsTokenWithValue(tokens, S) ) {\n+            milliseconds = (int) durationMillis;\n+        }\n+\n+        return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    /**\n+     * <p>Formats an elapsed time into a plurialization correct string.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the elapsed time to report in milliseconds\n+     * @param suppressLeadingZeroElements  suppresses leading 0 elements\n+     * @param suppressTrailingZeroElements  suppresses trailing 0 elements\n+     * @return the formatted text in days/hours/minutes/seconds\n+     */\n+    public static String formatDurationWords(\n+        long durationMillis,\n+        boolean suppressLeadingZeroElements,\n+        boolean suppressTrailingZeroElements) {\n+\n+        // This method is generally replacable by the format method, but \n+        // there are a series of tweaks and special cases that require \n+        // trickery to replicate.\n+        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n+        if (suppressLeadingZeroElements) {\n+            // this is a temporary marker on the front. Like ^ in regexp.\n+            duration = \" \" + duration;\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n+            if (tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                if (tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                    duration = tmp;\n+                    if (tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n+                    }\n+                }\n+            }\n+            if (duration.length() != 0) {\n+                // strip the space off again\n+                duration = duration.substring(1);\n+            }\n+        }\n+        if (suppressTrailingZeroElements) {\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n+            if (tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                if (tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                    if (tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n+                    }\n+                }\n+            }\n+        }\n+        // handle plurals\n+        duration = \" \" + duration;\n+        duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n+        return duration.trim();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is the ISO8601 period format.</p>\n+     * \n+     * @param startMillis  the start of the duration to format\n+     * @param endMillis  the end of the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatPeriodISO(long startMillis, long endMillis) {\n+        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional.\n+     * \n+     * @param startMillis  the start of the duration\n+     * @param endMillis  the end of the duration\n+     * @param format  the way in which to format the duration\n+     * @return the time as a String\n+     */\n+    public static String formatPeriod(long startMillis, long endMillis, String format) {\n+        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional and \n+     * the timezone may be specified. \n+     * \n+     * @param startMillis  the start of the duration\n+     * @param endMillis  the end of the duration\n+     * @param format  the way in which to format the duration\n+     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n+     * @param timezone the millis are defined in\n+     * @return the time as a String\n+     */\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n+            TimeZone timezone) {\n+\n+        long millis = endMillis - startMillis;\n+        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n+            return formatDuration(millis, format, padWithZeros);\n+        }\n+\n+        Token[] tokens = lexx(format);\n+\n+        // timezones get funky around 0, so normalizing everything to GMT \n+        // stops the hours being off\n+        Calendar start = Calendar.getInstance(timezone);\n+        start.setTime(new Date(startMillis));\n+        Calendar end = Calendar.getInstance(timezone);\n+        end.setTime(new Date(endMillis));\n+\n+        // initial estimates\n+        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n+        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n+        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n+        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n+        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n+        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+\n+        // each initial estimate is adjusted in case it is under 0\n+        while (milliseconds < 0) {\n+            milliseconds += 1000;\n+            seconds -= 1;\n+        }\n+        while (seconds < 0) {\n+            seconds += 60;\n+            minutes -= 1;\n+        }\n+        while (minutes < 0) {\n+            minutes += 60;\n+            hours -= 1;\n+        }\n+        while (hours < 0) {\n+            hours += 24;\n+            days -= 1;\n+        }\n+        while (days < 0) {\n+            days += 31; // such overshooting is taken care of later on\n+            months -= 1;\n+        }\n+        while (months < 0) {\n+            months += 12;\n+            years -= 1;\n+        }\n+\n+        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n+        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n+        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n+        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n+        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n+        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n+\n+        // This next block of code adds in values that \n+        // aren't requested. This allows the user to ask for the \n+        // number of months and get the real count and not just 0->11.\n+        if (!Token.containsTokenWithValue(tokens, y)) {\n+            if (Token.containsTokenWithValue(tokens, M)) {\n+                months += 12 * years;\n+                years = 0;\n+            } else {\n+                // TODO: this is a bit weak, needs work to know about leap years\n+                days += 365 * years;\n+                years = 0;\n+            }\n+        }\n+        if (!Token.containsTokenWithValue(tokens, M)) {\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+            months = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, d)) {\n+            hours += 24 * days;\n+            days = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, H)) {\n+            minutes += 60 * hours;\n+            hours = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, m)) {\n+            seconds += 60 * minutes;\n+            minutes = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, s)) {\n+            milliseconds += 1000 * seconds;\n+            seconds = 0;\n+        }\n+\n+        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>The internal method to do the formatting.</p>\n+     * \n+     * @param tokens  the tokens\n+     * @param years  the number of years\n+     * @param months  the number of months\n+     * @param days  the number of days\n+     * @param hours  the number of hours\n+     * @param minutes  the number of minutes\n+     * @param seconds  the number of seconds\n+     * @param milliseconds  the number of millis\n+     * @param padWithZeros  whether to pad\n+     * @return the formetted string\n+     */\n+    static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,\n+            int milliseconds, boolean padWithZeros) {\n+        StringBuffer buffer = new StringBuffer();\n+        boolean lastOutputSeconds = false;\n+        int sz = tokens.length;\n+        for (int i = 0; i < sz; i++) {\n+            Token token = tokens[i];\n+            Object value = token.getValue();\n+            int count = token.getCount();\n+            if (value instanceof StringBuffer) {\n+                buffer.append(value.toString());\n+            } else {\n+                if (value == y) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n+                            .toString(years));\n+                    lastOutputSeconds = false;\n+                } else if (value == M) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n+                            .toString(months));\n+                    lastOutputSeconds = false;\n+                } else if (value == d) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n+                            .toString(days));\n+                    lastOutputSeconds = false;\n+                } else if (value == H) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n+                            .toString(hours));\n+                    lastOutputSeconds = false;\n+                } else if (value == m) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n+                            .toString(minutes));\n+                    lastOutputSeconds = false;\n+                } else if (value == s) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n+                            .toString(seconds));\n+                    lastOutputSeconds = true;\n+                } else if (value == S) {\n+                    if (lastOutputSeconds) {\n+                        milliseconds += 1000;\n+                        String str = padWithZeros\n+                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n+                                : Integer.toString(milliseconds);\n+                        buffer.append(str.substring(1));\n+                    } else {\n+                        buffer.append(padWithZeros\n+                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n+                                : Integer.toString(milliseconds));\n+                    }\n+                    lastOutputSeconds = false;\n+                }\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Reduces by difference, then if it overshot, calculates the overshot amount and \n+     * fixes and returns the amount to change by.\n+     *\n+     * @param start Start of period being formatted\n+     * @param end End of period being formatted\n+     * @param field Field to reduce, as per constants in {@link java.util.Calendar}\n+     * @param difference amount to reduce by\n+     * @return int reduced value\n+     */\n+    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n+        end.add( field, -1 * difference );\n+        int endValue = end.get(field);\n+        int startValue = start.get(field);\n+        if (endValue < startValue) {\n+            int newdiff = startValue - endValue;\n+            end.add( field, newdiff );\n+            return newdiff;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    static final Object y = \"y\";\n+    static final Object M = \"M\";\n+    static final Object d = \"d\";\n+    static final Object H = \"H\";\n+    static final Object m = \"m\";\n+    static final Object s = \"s\";\n+    static final Object S = \"S\";\n+    \n+    /**\n+     * Parses a classic date format string into Tokens\n+     *\n+     * @param format to parse\n+     * @return Token[] of tokens\n+     */\n+    static Token[] lexx(String format) {\n+        char[] array = format.toCharArray();\n+        java.util.ArrayList list = new java.util.ArrayList(array.length);\n+\n+        boolean inLiteral = false;\n+        StringBuffer buffer = null;\n+        Token previous = null;\n+        int sz = array.length;\n+        for(int i=0; i<sz; i++) {\n+            char ch = array[i];\n+            if(inLiteral && ch != '\\'') {\n+                buffer.append(ch);\n+                continue;\n+            }\n+            Object value = null;\n+            switch(ch) {\n+                // TODO: Need to handle escaping of '\n+                case '\\'' : \n+                  if(inLiteral) {\n+                      buffer = null;\n+                      inLiteral = false;\n+                  } else {\n+                      buffer = new StringBuffer();\n+                      list.add(new Token(buffer));\n+                      inLiteral = true;\n+                  }\n+                  break;\n+                case 'y'  : value = y; break;\n+                case 'M'  : value = M; break;\n+                case 'd'  : value = d; break;\n+                case 'H'  : value = H; break;\n+                case 'm'  : value = m; break;\n+                case 's'  : value = s; break;\n+                case 'S'  : value = S; break;\n+                default   : \n+                  if(buffer == null) {\n+                      buffer = new StringBuffer();\n+                      list.add(new Token(buffer));\n+                  }\n+                  buffer.append(ch);\n+            }\n+\n+            if(value != null) {\n+                if(previous != null && previous.getValue() == value) {\n+                    previous.increment();\n+                } else {\n+                    Token token = new Token(value);\n+                    list.add(token); \n+                    previous = token;\n+                }\n+                buffer = null; \n+            }\n+        }\n+        return (Token[]) list.toArray( new Token[0] );\n+    }\n+\n+    /**\n+     * Element that is parsed from the format pattern.\n+     */\n+    static class Token {\n+\n+        /**\n+         * Helper method to determine if a set of tokens contain a value\n+         *\n+         * @param tokens set to look in\n+         * @param value to look for\n+         * @return boolean <code>true</code> if contained\n+         */\n+        static boolean containsTokenWithValue(Token[] tokens, Object value) {\n+            int sz = tokens.length;\n+            for (int i = 0; i < sz; i++) {\n+                if (tokens[i].getValue() == value) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private Object value;\n+        private int count;\n+\n+        /**\n+         * Wraps a token around a value. A value would be something like a 'Y'.\n+         *\n+         * @param value to wrap\n+         */\n+        Token(Object value) {\n+            this.value = value;\n+            this.count = 1;\n+        }\n+\n+        /**\n+         * Wraps a token around a repeated number of a value, for example it would \n+         * store 'yyyy' as a value for y and a count of 4.\n+         *\n+         * @param value to wrap\n+         * @param count to wrap\n+         */\n+        Token(Object value, int count) {\n+            this.value = value;\n+            this.count = count;\n+        }\n+\n+        /**\n+         * Adds another one of the value\n+         */\n+        void increment() { \n+            count++;\n+        }\n+\n+        /**\n+         * Gets the current number of values represented\n+         *\n+         * @return int number of values represented\n+         */\n+        int getCount() {\n+            return count;\n+        }\n+\n+        /**\n+         * Gets the particular value this token represents.\n+         * \n+         * @return Object value\n+         */\n+        Object getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Supports equality of this Token to another Token.\n+         *\n+         * @param obj2 Object to consider equality of\n+         * @return boolean <code>true</code> if equal\n+         */\n+        public boolean equals(Object obj2) {\n+            if (obj2 instanceof Token) {\n+                Token tok2 = (Token) obj2;\n+                if (this.value.getClass() != tok2.value.getClass()) {\n+                    return false;\n+                }\n+                if (this.count != tok2.count) {\n+                    return false;\n+                }\n+                if (this.value instanceof StringBuffer) {\n+                    return this.value.toString().equals(tok2.value.toString());\n+                } else if (this.value instanceof Number) {\n+                    return this.value.equals(tok2.value);\n+                } else {\n+                    return this.value == tok2.value;\n+                }\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        /**\n+         * Returns a hashcode for the token equal to the \n+         * hashcode for the token's value. Thus 'TT' and 'TTTT' \n+         * will have the same hashcode. \n+         *\n+         * @return The hashcode for the token\n+         */\n+        public int hashCode() {\n+            return this.value.hashCode();\n+        }\n+\n+        /**\n+         * Represents this token as a String.\n+         *\n+         * @return String representation of the token\n+         */\n+        public String toString() {\n+            return StringUtils.repeat(this.value.toString(), this.count);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.lang.Validate;\n+\n+/**\n+ * <p>FastDateFormat is a fast and thread-safe version of\n+ * {@link java.text.SimpleDateFormat}.</p>\n+ * \n+ * <p>This class can be used as a direct replacement to\n+ * <code>SimpleDateFormat</code> in most formatting situations.\n+ * This class is especially useful in multi-threaded server environments.\n+ * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n+ * nor will it be as Sun have closed the bug/RFE.\n+ * </p>\n+ *\n+ * <p>Only formatting is supported, but all patterns are compatible with\n+ * SimpleDateFormat (except time zones - see below).</p>\n+ *\n+ * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent\n+ * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).\n+ * This pattern letter can be used here (on all JDK versions).</p>\n+ *\n+ * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent\n+ * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).\n+ * This introduces a minor incompatibility with Java 1.4, but at a gain of\n+ * useful functionality.</p>\n+ *\n+ * @author TeaTrove project\n+ * @author Brian S O'Neill\n+ * @author Sean Schofield\n+ * @author Gary Gregory\n+ * @author Stephen Colebourne\n+ * @author Nikolay Metchev\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class FastDateFormat extends Format {\n+    // A lot of the speed in this class comes from caching, but some comes\n+    // from the special int to StringBuffer conversion.\n+    //\n+    // The following produces a padded 2 digit number:\n+    //   buffer.append((char)(value / 10 + '0'));\n+    //   buffer.append((char)(value % 10 + '0'));\n+    //\n+    // Note that the fastest append to StringBuffer is a single char (used here).\n+    // Note that Integer.toString() is not called, the conversion is simply\n+    // taking the value and adding (mathematically) the ASCII value for '0'.\n+    // So, don't change this code! It works and is very fast.\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * FULL locale dependent date or time style.\n+     */\n+    public static final int FULL = DateFormat.FULL;\n+    /**\n+     * LONG locale dependent date or time style.\n+     */\n+    public static final int LONG = DateFormat.LONG;\n+    /**\n+     * MEDIUM locale dependent date or time style.\n+     */\n+    public static final int MEDIUM = DateFormat.MEDIUM;\n+    /**\n+     * SHORT locale dependent date or time style.\n+     */\n+    public static final int SHORT = DateFormat.SHORT;\n+    \n+    private static String cDefaultPattern;\n+\n+    private static Map cInstanceCache = new HashMap(7);\n+    private static Map cDateInstanceCache = new HashMap(7);\n+    private static Map cTimeInstanceCache = new HashMap(7);\n+    private static Map cDateTimeInstanceCache = new HashMap(7);\n+    private static Map cTimeZoneDisplayCache = new HashMap(7);\n+\n+    /**\n+     * The pattern.\n+     */\n+    private final String mPattern;\n+    /**\n+     * The time zone.\n+     */\n+    private final TimeZone mTimeZone;\n+    /**\n+     * Whether the time zone overrides any on Calendars.\n+     */\n+    private final boolean mTimeZoneForced;\n+    /**\n+     * The locale.\n+     */\n+    private final Locale mLocale;\n+    /**\n+     * Whether the locale overrides the default.\n+     */\n+    private final boolean mLocaleForced;\n+    /**\n+     * The parsed rules.\n+     */\n+    private Rule[] mRules;\n+    /**\n+     * The estimated maximum length.\n+     */\n+    private int mMaxLengthEstimate;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a formatter instance using the default pattern in the\n+     * default locale.</p>\n+     * \n+     * @return a date/time formatter\n+     */\n+    public static FastDateFormat getInstance() {\n+        return getInstance(getDefaultPattern(), null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern in the\n+     * default locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern) {\n+        return getInstance(pattern, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern and\n+     * time zone.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n+        return getInstance(pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern and\n+     * locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param locale  optional locale, overrides system locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern, Locale locale) {\n+        return getInstance(pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern, time zone\n+     * and locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     *  or <code>null</code>\n+     */\n+    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n+        FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);\n+        if (format == null) {\n+            format = emptyFormat;\n+            format.init();  // convert shell format into usable one\n+            cInstanceCache.put(format, format);  // this is OK!\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a date formatter instance using the specified style in the\n+     * default time zone and locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style) {\n+        return getDateInstance(style, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a date formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style, Locale locale) {\n+        return getDateInstance(style, null, locale);\n+    }\n+\n+    /**\n+     * <p>Gets a date formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n+        return getDateInstance(style, timeZone, null);\n+    }\n+    /**\n+     * <p>Gets a date formatter instance using the specified style, time\n+     * zone and locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = new Integer(style);\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n+        if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateInstanceCache.put(key, format);\n+                \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a time formatter instance using the specified style in the\n+     * default time zone and locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style) {\n+        return getTimeInstance(style, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a time formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style, Locale locale) {\n+        return getTimeInstance(style, null, locale);\n+    }\n+    \n+    /**\n+     * <p>Gets a time formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted time\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n+        return getTimeInstance(style, timeZone, null);\n+    }\n+    \n+    /**\n+     * <p>Gets a time formatter instance using the specified style, time\n+     * zone and locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted time\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = new Integer(style);\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);\n+        if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cTimeInstanceCache.put(key, format);\n+            \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style\n+     * in the default time zone and locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle) {\n+        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n+    }\n+    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle, Locale locale) {\n+        return getDateTimeInstance(dateStyle, timeStyle, null, locale);\n+    }\n+    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle, TimeZone timeZone) {\n+        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n+    }    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style,\n+     * time zone and locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n+            Locale locale) {\n+\n+        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n+        if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n+                        locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateTimeInstanceCache.put(key, format);\n+\n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the time zone display name, using a cache for performance.</p>\n+     * \n+     * @param tz  the zone to query\n+     * @param daylight  true if daylight savings\n+     * @param style  the style to use <code>TimeZone.LONG</code>\n+     *  or <code>TimeZone.SHORT</code>\n+     * @param locale  the locale to use\n+     * @return the textual name of the time zone\n+     */\n+    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n+        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n+        String value = (String) cTimeZoneDisplayCache.get(key);\n+        if (value == null) {\n+            // This is a very slow call, so cache the results.\n+            value = tz.getDisplayName(daylight, style, locale);\n+            cTimeZoneDisplayCache.put(key, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * <p>Gets the default pattern.</p>\n+     * \n+     * @return the default pattern\n+     */\n+    private static synchronized String getDefaultPattern() {\n+        if (cDefaultPattern == null) {\n+            cDefaultPattern = new SimpleDateFormat().toPattern();\n+        }\n+        return cDefaultPattern;\n+    }\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Constructs a new FastDateFormat.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  time zone to use, <code>null</code> means use\n+     *  default for <code>Date</code> and value within for\n+     *  <code>Calendar</code>\n+     * @param locale  locale, <code>null</code> means use system\n+     *  default\n+     * @throws IllegalArgumentException if pattern is invalid or\n+     *  <code>null</code>\n+     */\n+    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n+        super();\n+        if (pattern == null) {\n+            throw new IllegalArgumentException(\"The pattern must not be null\");\n+        }\n+        mPattern = pattern;\n+        \n+        mTimeZoneForced = (timeZone != null);\n+        if (timeZone == null) {\n+            timeZone = TimeZone.getDefault();\n+        }\n+        mTimeZone = timeZone;\n+        \n+        mLocaleForced = (locale != null);\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        mLocale = locale;\n+    }\n+\n+    /**\n+     * <p>Initializes the instance for first use.</p>\n+     */\n+    protected void init() {\n+        List rulesList = parsePattern();\n+        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n+\n+        int len = 0;\n+        for (int i=mRules.length; --i >= 0; ) {\n+            len += mRules[i].estimateLength();\n+        }\n+\n+        mMaxLengthEstimate = len;\n+    }\n+\n+    // Parse the pattern\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a list of Rules given a pattern.</p>\n+     * \n+     * @return a <code>List</code> of Rule objects\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    protected List parsePattern() {\n+        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n+        List rules = new ArrayList();\n+\n+        String[] ERAs = symbols.getEras();\n+        String[] months = symbols.getMonths();\n+        String[] shortMonths = symbols.getShortMonths();\n+        String[] weekdays = symbols.getWeekdays();\n+        String[] shortWeekdays = symbols.getShortWeekdays();\n+        String[] AmPmStrings = symbols.getAmPmStrings();\n+\n+        int length = mPattern.length();\n+        int[] indexRef = new int[1];\n+\n+        for (int i = 0; i < length; i++) {\n+            indexRef[0] = i;\n+            String token = parseToken(mPattern, indexRef);\n+            i = indexRef[0];\n+\n+            int tokenLen = token.length();\n+            if (tokenLen == 0) {\n+                break;\n+            }\n+\n+            Rule rule;\n+            char c = token.charAt(0);\n+\n+            switch (c) {\n+            case 'G': // era designator (text)\n+                rule = new TextField(Calendar.ERA, ERAs);\n+                break;\n+            case 'y': // year (number)\n+                if (tokenLen >= 4) {\n+                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n+                } else {\n+                    rule = TwoDigitYearField.INSTANCE;\n+                }\n+                break;\n+            case 'M': // month in year (text and number)\n+                if (tokenLen >= 4) {\n+                    rule = new TextField(Calendar.MONTH, months);\n+                } else if (tokenLen == 3) {\n+                    rule = new TextField(Calendar.MONTH, shortMonths);\n+                } else if (tokenLen == 2) {\n+                    rule = TwoDigitMonthField.INSTANCE;\n+                } else {\n+                    rule = UnpaddedMonthField.INSTANCE;\n+                }\n+                break;\n+            case 'd': // day in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n+                break;\n+            case 'h': // hour in am/pm (number, 1..12)\n+                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n+                break;\n+            case 'H': // hour in day (number, 0..23)\n+                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n+                break;\n+            case 'm': // minute in hour (number)\n+                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n+                break;\n+            case 's': // second in minute (number)\n+                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n+                break;\n+            case 'S': // millisecond (number)\n+                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n+                break;\n+            case 'E': // day in week (text)\n+                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n+                break;\n+            case 'D': // day in year (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n+                break;\n+            case 'F': // day of week in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n+                break;\n+            case 'w': // week in year (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n+                break;\n+            case 'W': // week in month (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n+                break;\n+            case 'a': // am/pm marker (text)\n+                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n+                break;\n+            case 'k': // hour in day (1..24)\n+                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n+                break;\n+            case 'K': // hour in am/pm (0..11)\n+                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n+                break;\n+            case 'z': // time zone (text)\n+                if (tokenLen >= 4) {\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n+                } else {\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n+                }\n+                break;\n+            case 'Z': // time zone (value)\n+                if (tokenLen == 1) {\n+                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n+                } else {\n+                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n+                }\n+                break;\n+            case '\\'': // literal text\n+                String sub = token.substring(1);\n+                if (sub.length() == 1) {\n+                    rule = new CharacterLiteral(sub.charAt(0));\n+                } else {\n+                    rule = new StringLiteral(sub);\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n+            }\n+\n+            rules.add(rule);\n+        }\n+\n+        return rules;\n+    }\n+\n+    /**\n+     * <p>Performs the parsing of tokens.</p>\n+     * \n+     * @param pattern  the pattern\n+     * @param indexRef  index references\n+     * @return parsed token\n+     */\n+    protected String parseToken(String pattern, int[] indexRef) {\n+        StringBuffer buf = new StringBuffer();\n+\n+        int i = indexRef[0];\n+        int length = pattern.length();\n+\n+        char c = pattern.charAt(i);\n+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+            // Scan a run of the same character, which indicates a time\n+            // pattern.\n+            buf.append(c);\n+\n+            while (i + 1 < length) {\n+                char peek = pattern.charAt(i + 1);\n+                if (peek == c) {\n+                    buf.append(c);\n+                    i++;\n+                } else {\n+                    break;\n+                }\n+            }\n+        } else {\n+            // This will identify token as text.\n+            buf.append('\\'');\n+\n+            boolean inLiteral = false;\n+\n+            for (; i < length; i++) {\n+                c = pattern.charAt(i);\n+\n+                if (c == '\\'') {\n+                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n+                        // '' is treated as escaped '\n+                        i++;\n+                        buf.append(c);\n+                    } else {\n+                        inLiteral = !inLiteral;\n+                    }\n+                } else if (!inLiteral &&\n+                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n+                    i--;\n+                    break;\n+                } else {\n+                    buf.append(c);\n+                }\n+            }\n+        }\n+\n+        indexRef[0] = i;\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Gets an appropriate rule for the padding required.</p>\n+     * \n+     * @param field  the field to get a rule for\n+     * @param padding  the padding required\n+     * @return a new rule with the correct padding\n+     */\n+    protected NumberRule selectNumberRule(int field, int padding) {\n+        switch (padding) {\n+        case 1:\n+            return new UnpaddedNumberField(field);\n+        case 2:\n+            return new TwoDigitNumberField(field);\n+        default:\n+            return new PaddedNumberField(field, padding);\n+        }\n+    }\n+\n+    // Format methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats a <code>Date</code>, <code>Calendar</code> or\n+     * <code>Long</code> (milliseconds) object.</p>\n+     * \n+     * @param obj  the object to format\n+     * @param toAppendTo  the buffer to append to\n+     * @param pos  the position - ignored\n+     * @return the buffer passed in\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo);\n+        } else if (obj instanceof Calendar) {\n+            return format((Calendar) obj, toAppendTo);\n+        } else if (obj instanceof Long) {\n+            return format(((Long) obj).longValue(), toAppendTo);\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown class: \" +\n+                (obj == null ? \"<null>\" : obj.getClass().getName()));\n+        }\n+    }\n+\n+    /**\n+     * <p>Formats a millisecond <code>long</code> value.</p>\n+     * \n+     * @param millis  the millisecond value to format\n+     * @return the formatted string\n+     * @since 2.1\n+     */\n+    public String format(long millis) {\n+        return format(new Date(millis));\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Date</code> object.</p>\n+     * \n+     * @param date  the date to format\n+     * @return the formatted string\n+     */\n+    public String format(Date date) {\n+        Calendar c = new GregorianCalendar(mTimeZone);\n+        c.setTime(date);\n+        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Calendar</code> object.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @return the formatted string\n+     */\n+    public String format(Calendar calendar) {\n+        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /**\n+     * <p>Formats a milliseond <code>long</code> value into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param millis  the millisecond value to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     * @since 2.1\n+     */\n+    public StringBuffer format(long millis, StringBuffer buf) {\n+        return format(new Date(millis), buf);\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Date</code> object into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param date  the date to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(Date date, StringBuffer buf) {\n+        Calendar c = new GregorianCalendar(mTimeZone);\n+        c.setTime(date);\n+        return applyRules(c, buf);\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Calendar</code> object into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n+        if (mTimeZoneForced) {\n+            calendar = (Calendar) calendar.clone();\n+            calendar.setTimeZone(mTimeZone);\n+        }\n+        return applyRules(calendar, buf);\n+    }\n+\n+    /**\n+     * <p>Performs the formatting by applying the rules to the\n+     * specified calendar.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+        Rule[] rules = mRules;\n+        int len = mRules.length;\n+        for (int i = 0; i < len; i++) {\n+            rules[i].appendTo(buf, calendar);\n+        }\n+        return buf;\n+    }\n+\n+    // Parsing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parsing is not supported.</p>\n+     * \n+     * @param source  the string to parse\n+     * @param pos  the parsing position\n+     * @return <code>null</code> as not supported\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        pos.setIndex(0);\n+        pos.setErrorIndex(0);\n+        return null;\n+    }\n+    \n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the pattern used by this formatter.</p>\n+     * \n+     * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n+     */\n+    public String getPattern() {\n+        return mPattern;\n+    }\n+\n+    /**\n+     * <p>Gets the time zone used by this formatter.</p>\n+     *\n+     * <p>This zone is always used for <code>Date</code> formatting.\n+     * If a <code>Calendar</code> is passed in to be formatted, the\n+     * time zone on that may be used depending on\n+     * {@link #getTimeZoneOverridesCalendar()}.</p>\n+     * \n+     * @return the time zone\n+     */\n+    public TimeZone getTimeZone() {\n+        return mTimeZone;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the time zone of the\n+     * calendar overrides the time zone of the formatter.</p>\n+     * \n+     * @return <code>true</code> if time zone of formatter\n+     *  overridden for calendars\n+     */\n+    public boolean getTimeZoneOverridesCalendar() {\n+        return mTimeZoneForced;\n+    }\n+\n+    /**\n+     * <p>Gets the locale used by this formatter.</p>\n+     * \n+     * @return the locale\n+     */\n+    public Locale getLocale() {\n+        return mLocale;\n+    }\n+\n+    /**\n+     * <p>Gets an estimate for the maximum string length that the\n+     * formatter will produce.</p>\n+     *\n+     * <p>The actual formatted length will almost always be less than or\n+     * equal to this amount.</p>\n+     * \n+     * @return the maximum formatted length\n+     */\n+    public int getMaxLengthEstimate() {\n+        return mMaxLengthEstimate;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two objects for equality.</p>\n+     * \n+     * @param obj  the object to compare to\n+     * @return <code>true</code> if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof FastDateFormat == false) {\n+            return false;\n+        }\n+        FastDateFormat other = (FastDateFormat) obj;\n+        if (\n+            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n+            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n+            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n+            (mTimeZoneForced == other.mTimeZoneForced) &&\n+            (mLocaleForced == other.mLocaleForced)\n+            ) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Returns a hashcode compatible with equals.</p>\n+     * \n+     * @return a hashcode compatible with equals\n+     */\n+    public int hashCode() {\n+        int total = 0;\n+        total += mPattern.hashCode();\n+        total += mTimeZone.hashCode();\n+        total += (mTimeZoneForced ? 1 : 0);\n+        total += mLocale.hashCode();\n+        total += (mLocaleForced ? 1 : 0);\n+        return total;\n+    }\n+\n+    /**\n+     * <p>Gets a debugging string version of this formatter.</p>\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        return \"FastDateFormat[\" + mPattern + \"]\";\n+    }\n+    \n+    // Rules\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Inner class defining a rule.</p>\n+     */\n+    private interface Rule {\n+        /**\n+         * Returns the estimated lentgh of the result.\n+         * \n+         * @return the estimated length\n+         */\n+        int estimateLength();\n+        \n+        /**\n+         * Appends the value of the specified calendar to the output buffer based on the rule implementation.\n+         * \n+         * @param buffer the output buffer\n+         * @param calendar calendar to be appended\n+         */\n+        void appendTo(StringBuffer buffer, Calendar calendar);\n+    }\n+\n+    /**\n+     * <p>Inner class defining a numeric rule.</p>\n+     */\n+    private interface NumberRule extends Rule {\n+        /**\n+         * Appends the specified value to the output buffer based on the rule implementation.\n+         * \n+         * @param buffer the output buffer\n+         * @param value the value to be appended\n+         */\n+        void appendTo(StringBuffer buffer, int value);\n+    }\n+\n+    /**\n+     * <p>Inner class to output a constant single character.</p>\n+     */\n+    private static class CharacterLiteral implements Rule {\n+        private final char mValue;\n+\n+        /**\n+         * Constructs a new instance of <code>CharacterLiteral</code>\n+         * to hold the specified value.\n+         * \n+         * @param value the character literal\n+         */\n+        CharacterLiteral(char value) {\n+            mValue = value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 1;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a constant string.</p>\n+     */\n+    private static class StringLiteral implements Rule {\n+        private final String mValue;\n+\n+        /**\n+         * Constructs a new instance of <code>StringLiteral</code>\n+         * to hold the specified value.\n+         * \n+         * @param value the string literal\n+         */\n+        StringLiteral(String value) {\n+            mValue = value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mValue.length();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output one of a set of values.</p>\n+     */\n+    private static class TextField implements Rule {\n+        private final int mField;\n+        private final String[] mValues;\n+\n+        /**\n+         * Constructs an instance of <code>TextField</code>\n+         * with the specified field and values.\n+         * \n+         * @param field the field\n+         * @param values the field values\n+         */\n+        TextField(int field, String[] values) {\n+            mField = field;\n+            mValues = values;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            int max = 0;\n+            for (int i=mValues.length; --i >= 0; ) {\n+                int len = mValues[i].length();\n+                if (len > max) {\n+                    max = len;\n+                }\n+            }\n+            return max;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValues[calendar.get(mField)]);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output an unpadded number.</p>\n+     */\n+    private static class UnpaddedNumberField implements NumberRule {\n+        static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);\n+        \n+        private final int mField;\n+\n+        /**\n+         * Constructs an instance of <code>UnpadedNumberField</code> with the specified field.\n+         * \n+         * @param field the field\n+         */\n+        UnpaddedNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            } else if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output an unpadded month.</p>\n+     */\n+    private static class UnpaddedMonthField implements NumberRule {\n+        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n+\n+        /**\n+         * Constructs an instance of <code>UnpaddedMonthField</code>.\n+         *\n+         */\n+        UnpaddedMonthField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            } else {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a padded number.</p>\n+     */\n+    private static class PaddedNumberField implements NumberRule {\n+        private final int mField;\n+        private final int mSize;\n+\n+        /**\n+         * Constructs an instance of <code>PaddedNumberField</code>.\n+         * \n+         * @param field the field\n+         * @param size size of the output field\n+         */\n+        PaddedNumberField(int field, int size) {\n+            if (size < 3) {\n+                // Should use UnpaddedNumberField or TwoDigitNumberField.\n+                throw new IllegalArgumentException();\n+            }\n+            mField = field;\n+            mSize = size;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                for (int i = mSize; --i >= 2; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                int digits;\n+                if (value < 1000) {\n+                    digits = 3;\n+                } else {\n+                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n+                    digits = Integer.toString(value).length();\n+                }\n+                for (int i = mSize; --i >= digits; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit number.</p>\n+     */\n+    private static class TwoDigitNumberField implements NumberRule {\n+        private final int mField;\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitNumberField</code> with the specified field.\n+         * \n+         * @param field the field\n+         */\n+        TwoDigitNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit year.</p>\n+     */\n+    private static class TwoDigitYearField implements NumberRule {\n+        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitYearField</code>.\n+         */\n+        TwoDigitYearField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit month.</p>\n+     */\n+    private static class TwoDigitMonthField implements NumberRule {\n+        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitMonthField</code>.\n+         */\n+        TwoDigitMonthField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output the twelve hour field.</p>\n+     */\n+    private static class TwelveHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        /**\n+         * Constructs an instance of <code>TwelveHourField</code> with the specified\n+         * <code>NumberRule</code>.\n+         * \n+         * @param rule the rule\n+         */\n+        TwelveHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR);\n+            if (value == 0) {\n+                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output the twenty four hour field.</p>\n+     */\n+    private static class TwentyFourHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        /**\n+         * Constructs an instance of <code>TwentyFourHourField</code> with the specified\n+         * <code>NumberRule</code>.\n+         * \n+         * @param rule the rule\n+         */\n+        TwentyFourHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR_OF_DAY);\n+            if (value == 0) {\n+                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a time zone name.</p>\n+     */\n+    private static class TimeZoneNameRule implements Rule {\n+        private final TimeZone mTimeZone;\n+        private final boolean mTimeZoneForced;\n+        private final Locale mLocale;\n+        private final int mStyle;\n+        private final String mStandard;\n+        private final String mDaylight;\n+\n+        /**\n+         * Constructs an instance of <code>TimeZoneNameRule</code> with the specified properties.\n+         * \n+         * @param timeZone the time zone\n+         * @param timeZoneForced if <code>true</code> the time zone is forced into standard and daylight\n+         * @param locale the locale\n+         * @param style the style\n+         */\n+        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n+            mTimeZone = timeZone;\n+            mTimeZoneForced = timeZoneForced;\n+            mLocale = locale;\n+            mStyle = style;\n+\n+            if (timeZoneForced) {\n+                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n+                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n+            } else {\n+                mStandard = null;\n+                mDaylight = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            if (mTimeZoneForced) {\n+                return Math.max(mStandard.length(), mDaylight.length());\n+            } else if (mStyle == TimeZone.SHORT) {\n+                return 4;\n+            } else {\n+                return 40;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            if (mTimeZoneForced) {\n+                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                    buffer.append(mDaylight);\n+                } else {\n+                    buffer.append(mStandard);\n+                }\n+            } else {\n+                TimeZone timeZone = calendar.getTimeZone();\n+                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n+                } else {\n+                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a time zone as a number <code>+/-HHMM</code>\n+     * or <code>+/-HH:MM</code>.</p>\n+     */\n+    private static class TimeZoneNumberRule implements Rule {\n+        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n+        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n+        \n+        final boolean mColon;\n+        \n+        /**\n+         * Constructs an instance of <code>TimeZoneNumberRule</code> with the specified properties.\n+         * \n+         * @param colon add colon between HH and MM in the output if <code>true</code>\n+         */\n+        TimeZoneNumberRule(boolean colon) {\n+            mColon = colon;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 5;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n+            \n+            if (offset < 0) {\n+                buffer.append('-');\n+                offset = -offset;\n+            } else {\n+                buffer.append('+');\n+            }\n+            \n+            int hours = offset / (60 * 60 * 1000);\n+            buffer.append((char)(hours / 10 + '0'));\n+            buffer.append((char)(hours % 10 + '0'));\n+            \n+            if (mColon) {\n+                buffer.append(':');\n+            }\n+            \n+            int minutes = offset / (60 * 1000) - 60 * hours;\n+            buffer.append((char)(minutes / 10 + '0'));\n+            buffer.append((char)(minutes % 10 + '0'));\n+        }            \n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Inner class that acts as a compound key for time zone names.</p>\n+     */\n+    private static class TimeZoneDisplayKey {\n+        private final TimeZone mTimeZone;\n+        private final int mStyle;\n+        private final Locale mLocale;\n+\n+        /**\n+         * Constructs an instance of <code>TimeZoneDisplayKey</code> with the specified properties.\n+         *  \n+         * @param timeZone the time zone\n+         * @param daylight adjust the style for daylight saving time if <code>true</code>\n+         * @param style the timezone style\n+         * @param locale the timezone locale\n+         */\n+        TimeZoneDisplayKey(TimeZone timeZone,\n+                           boolean daylight, int style, Locale locale) {\n+            mTimeZone = timeZone;\n+            if (daylight) {\n+                style |= 0x80000000;\n+            }\n+            mStyle = style;\n+            mLocale = locale;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int hashCode() {\n+            return mStyle * 31 + mLocale.hashCode();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof TimeZoneDisplayKey) {\n+                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n+                return\n+                    mTimeZone.equals(other.mTimeZone) &&\n+                    mStyle == other.mStyle &&\n+                    mLocale.equals(other.mLocale);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Helper class for creating compound objects.</p>\n+     *\n+     * <p>One use for this class is to create a hashtable key\n+     * out of multiple objects.</p>\n+     */\n+    private static class Pair {\n+        private final Object mObj1;\n+        private final Object mObj2;\n+\n+        /**\n+         * Constructs an instance of <code>Pair</code> to hold the specified objects.\n+         * @param obj1 one object in the pair\n+         * @param obj2 second object in the pair\n+         */\n+        public Pair(Object obj1, Object obj2) {\n+            mObj1 = obj1;\n+            mObj2 = obj2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+\n+            if (!(obj instanceof Pair)) {\n+                return false;\n+            }\n+\n+            Pair key = (Pair)obj;\n+\n+            return\n+                (mObj1 == null ?\n+                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n+                (mObj2 == null ?\n+                 key.mObj2 == null : mObj2.equals(key.mObj2));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int hashCode() {\n+            return\n+                (mObj1 == null ? 0 : mObj1.hashCode()) +\n+                (mObj2 == null ? 0 : mObj2.hashCode());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public String toString() {\n+            return \"[\" + mObj1 + ':' + mObj2 + ']';\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/java/org/apache/commons/lang/time/StopWatch.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+/**\n+ * <p><code>StopWatch</code> provides a convenient API for timings.</p>\n+ * \n+ * <p>To start the watch, call {@link #start()}. At this point you can:</p>\n+ * <ul>\n+ *  <li>{@link #split()} the watch to get the time whilst the watch continues in the\n+ *   background. {@link #unsplit()} will remove the effect of the split. At this point,\n+ *   these three options are available again.</li>\n+ *  <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch\n+ *   to continue. Any time between the suspend and resume will not be counted in\n+ *   the total. At this point, these three options are available again.</li>\n+ *  <li>{@link #stop()} the watch to complete the timing session.</li>\n+ * </ul>\n+ *\n+ * <p>It is intended that the output methods {@link #toString()} and {@link #getTime()}\n+ * should only be called after stop, split or suspend, however a suitable result will\n+ * be returned at other points.</p>\n+ *\n+ * <p>NOTE: As from v2.1, the methods protect against inappropriate calls.\n+ * Thus you cannot now call stop before start, resume before suspend or\n+ * unsplit before split.</p>\n+ *\n+ * <p>1. split(), suspend(), or stop() cannot be invoked twice<br />\n+ * 2. unsplit() may only be called if the watch has been split()<br />\n+ * 3. resume() may only be called if the watch has been suspend()<br />\n+ * 4. start() cannot be called twice without calling reset()</p>\n+ *\n+ * @author Henri Yandell\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class StopWatch {\n+\n+    // running states\n+    private static final int STATE_UNSTARTED = 0;\n+    private static final int STATE_RUNNING   = 1;\n+    private static final int STATE_STOPPED   = 2;\n+    private static final int STATE_SUSPENDED = 3;\n+\n+    // split state\n+    private static final int STATE_UNSPLIT = 10;\n+    private static final int STATE_SPLIT   = 11;\n+\n+    /**\n+     *  The current running state of the StopWatch. \n+     */\n+    private int runningState = STATE_UNSTARTED;\n+\n+    /**\n+     * Whether the stopwatch has a split time recorded. \n+     */\n+    private int splitState   = STATE_UNSPLIT;\n+\n+    /**\n+     * The start time.\n+     */\n+    private long startTime = -1;\n+    /**\n+     * The stop time.\n+     */\n+    private long stopTime = -1;\n+\n+    /**\n+     * <p>Constructor.</p>\n+     */\n+    public StopWatch() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Start the stopwatch.</p>\n+     * \n+     * <p>This method starts a new timing session, clearing any previous values.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch is already running.\n+     */\n+    public void start() {\n+        if(this.runningState == STATE_STOPPED) {\n+            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n+        }\n+        if(this.runningState != STATE_UNSTARTED) {\n+            throw new IllegalStateException(\"Stopwatch already started. \");\n+        }\n+        stopTime = -1;\n+        startTime = System.currentTimeMillis();\n+        this.runningState = STATE_RUNNING;\n+    }\n+\n+    /**\n+     * <p>Stop the stopwatch.</p>\n+     * \n+     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch is not running.\n+     */\n+    public void stop() {\n+        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n+            throw new IllegalStateException(\"Stopwatch is not running. \");\n+        }\n+        stopTime = System.currentTimeMillis();\n+        this.runningState = STATE_STOPPED;\n+    }\n+\n+    /**\n+     * <p>Resets the stopwatch. Stops it if need be. </p>\n+     * \n+     * <p>This method clears the internal values to allow the object to be reused.</p>\n+     */\n+    public void reset() {\n+        this.runningState = STATE_UNSTARTED;\n+        this.splitState   = STATE_UNSPLIT;\n+        startTime = -1;\n+        stopTime = -1;\n+    }\n+\n+    /**\n+     * <p>Split the time.</p>\n+     * \n+     * <p>This method sets the stop time of the watch to allow a time to be extracted.\n+     * The start time is unaffected, enabling {@link #unsplit()} to continue the \n+     * timing from the original start point.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch is not running.\n+     */\n+    public void split() {\n+        if(this.runningState != STATE_RUNNING) {\n+            throw new IllegalStateException(\"Stopwatch is not running. \");\n+        }\n+        stopTime = System.currentTimeMillis();\n+        this.splitState = STATE_SPLIT;\n+    }\n+\n+    /**\n+     * <p>Remove a split.</p>\n+     * \n+     * <p>This method clears the stop time. The start time is unaffected, enabling \n+     * timing from the original start point to continue.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch has not been split.\n+     */\n+    public void unsplit() {\n+        if(this.splitState != STATE_SPLIT) {\n+            throw new IllegalStateException(\"Stopwatch has not been split. \");\n+        }\n+        stopTime = -1;\n+        this.splitState = STATE_UNSPLIT;\n+    }\n+\n+    /**\n+     * <p>Suspend the stopwatch for later resumption.</p>\n+     * \n+     * <p>This method suspends the watch until it is resumed. The watch will not include\n+     * time between the suspend and resume calls in the total time.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch is not currently running.\n+     */\n+    public void suspend() {\n+        if(this.runningState != STATE_RUNNING) {\n+            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n+        }\n+        stopTime = System.currentTimeMillis();\n+        this.runningState = STATE_SUSPENDED;\n+    }\n+\n+    /**\n+     * <p>Resume the stopwatch after a suspend.</p>\n+     * \n+     * <p>This method resumes the watch after it was suspended. The watch will not include\n+     * time between the suspend and resume calls in the total time.</p>\n+     *\n+     * @throws IllegalStateException if the StopWatch has not been suspended. \n+     */\n+    public void resume() {\n+        if(this.runningState != STATE_SUSPENDED) {\n+            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n+        }\n+        startTime += (System.currentTimeMillis() - stopTime);\n+        stopTime = -1;\n+        this.runningState = STATE_RUNNING;\n+    }\n+\n+    /**\n+     * <p>Get the time on the stopwatch.</p>\n+     * \n+     * <p>This is either the time between the start and the moment this method \n+     * is called, or the amount of time between start and stop.</p>\n+     * \n+     * @return the time in milliseconds\n+     */\n+    public long getTime() {\n+        if(this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {\n+            return this.stopTime - this.startTime;\n+        } else\n+        if(this.runningState == STATE_UNSTARTED) {\n+            return 0;\n+        } else\n+        if(this.runningState == STATE_RUNNING) {\n+            return System.currentTimeMillis() - this.startTime;\n+        }\n+        throw new RuntimeException(\"Illegal running state has occured. \");\n+    }\n+\n+    /**\n+     * <p>Get the split time on the stopwatch.</p>\n+     * \n+     * <p>This is the time between start and latest split. </p>\n+     * \n+     * @return the split time in milliseconds\n+     *\n+     * @throws IllegalStateException if the StopWatch has not yet been split.\n+     * @since 2.1\n+     */\n+    public long getSplitTime() {\n+        if(this.splitState != STATE_SPLIT) {\n+            throw new IllegalStateException(\"Stopwatch must be split to get the split time. \");\n+        }\n+        return this.stopTime - this.startTime;\n+    }\n+\n+    /**\n+     * <p>Gets a summary of the time that the stopwatch recorded as a string.</p>\n+     * \n+     * <p>The format used is ISO8601-like,\n+     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n+     * \n+     * @return the time as a String\n+     */\n+    public String toString() {\n+        return DurationFormatUtils.formatDurationHMS(getTime());\n+    }\n+\n+    /**\n+     * <p>Gets a summary of the split time that the stopwatch recorded as a string.</p>\n+     * \n+     * <p>The format used is ISO8601-like,\n+     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n+     * \n+     * @return the split time as a String\n+     * @since 2.1\n+     */\n+    public String toSplitString() {\n+        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/pending/CalendarUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+// package org.apache.commons.lang;\n+\n+import java.text.*;\n+import java.util.*;\n+\n+/**\n+ * A suite of utilities surrounding the use of the Calendar and Date object.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ */\n+public class CalendarUtils {\n+\n+    /**\n+     * This is half a month, so this represents whether a date is in the top\n+     * or bottom half of the month.\n+     */\n+    public final static int SEMI_MONTH = 1001;\n+\n+    private static final int[][] fields = {\n+            {Calendar.MILLISECOND},\n+            {Calendar.SECOND},\n+            {Calendar.MINUTE},\n+            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n+            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */},\n+            {Calendar.MONTH, CalendarUtils.SEMI_MONTH},\n+            {Calendar.YEAR},\n+            {Calendar.ERA}};\n+\n+    private static DateFormat[] dateFormats = {\n+        //3/31/92 10:00:07 PST\n+        new SimpleDateFormat(\"M/dd/yy h:mm:ss z\"),\n+        //January 23, 1987 10:05pm\n+        new SimpleDateFormat(\"MMM d, yyyy h:mm a\"),\n+        //22:00 GMT\n+        new SimpleDateFormat(\"h:mm z\")};\n+\n+    /**\n+     * A week range, starting on Sunday.\n+     */\n+    public final static int RANGE_WEEK_SUNDAY = 1;\n+\n+    /**\n+     * A week range, starting on Monday.\n+     */\n+    public final static int RANGE_WEEK_MONDAY = 2;\n+\n+    /**\n+     * A week range, starting on the day focused.\n+     */\n+    public final static int RANGE_WEEK_RELATIVE = 3;\n+\n+    /**\n+     * A week range, centered around the day focused.\n+     */\n+    public final static int RANGE_WEEK_CENTER = 4;\n+\n+    /**\n+     * A month range, the week starting on Sunday.\n+     */\n+    public final static int RANGE_MONTH_SUNDAY = 5;\n+\n+    /**\n+     * A month range, the week starting on Monday.\n+     */\n+    public final static int RANGE_MONTH_MONDAY = 6;\n+\n+    /**\n+     * See the other round method.  Works with a Date object.\n+     */\n+    public static Date round(Date val, int field) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(val);\n+        modify(gval, field, true);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Round this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return 28 Mar\n+     * 2002 14:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 April 2002 0:00:00.000.\n+     */\n+    public static Calendar round(Calendar val, int field) {\n+        Calendar rounded = (Calendar) val.clone();\n+        modify(rounded, field, true);\n+        return rounded;\n+    }\n+\n+    /**\n+     * See the other round method.  Works with an Object, trying to\n+     * use it as either a Date or Calendar.\n+     */\n+    public static Date round(Object val, int field) {\n+        if (val instanceof Date) {\n+            return round((Date) val, field);\n+        } else if (val instanceof Calendar) {\n+            return round((Calendar) val, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not round \" + val);\n+        }\n+    }\n+\n+    /**\n+     * See the other trunc method.  Works with a Date.\n+     */\n+    public static Date trunc(Date val, int field) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(val);\n+        modify(gval, field, false);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Truncate this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 Mar 2002 0:00:00.000.\n+     */\n+    public static Calendar trunc(Calendar val, int field) {\n+        Calendar truncated = (Calendar) val.clone();\n+        modify(truncated, field, false);\n+        return truncated;\n+    }\n+\n+    /**\n+     * See the other trunc method.  Works with an Object, trying to\n+     * use it as either a Date or Calendar.\n+     */\n+    public static Date trunc(Object val, int field) {\n+        if (val instanceof Date) {\n+            return trunc((Date) val, field);\n+        } else if (val instanceof Calendar) {\n+            return trunc((Calendar) val, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not trunc \" + val);\n+        }\n+    }\n+\n+    private static void modify(Calendar val, int field, boolean round) {\n+        boolean roundUp = false;\n+        for (int i = 0; i < fields.length; i++) {\n+            for (int j = 0; j < fields[i].length; j++) {\n+                if (fields[i][j] == field) {\n+                    //This is our field... we stop looping\n+                    if (round && roundUp) {\n+                        if (field == CalendarUtils.SEMI_MONTH) {\n+                            //This is a special case that's hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) == 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(fields[i][0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset = 0;\n+            boolean offsetSet = false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case CalendarUtils.SEMI_MONTH:\n+                    if (fields[i][0] == Calendar.DATE) {\n+                        //If we're going to drop the DATE field's value,\n+                        //  we want to do this our own way.\n+                        //We need to subtrace 1 since the date has a minimum of 1\n+                        offset = val.get(Calendar.DATE) - 1;\n+                        //If we're above 15 days adjustment, that means we're in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset >= 15) {\n+                            offset -= 15;\n+                        }\n+                        //Record whether we're in the top or bottom half of that range\n+                        roundUp = offset > 7;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (fields[i][0] == Calendar.HOUR) {\n+                        //If we're going to drop the HOUR field's value,\n+                        //  we want to do this our own way.\n+                        offset = val.get(Calendar.HOUR);\n+                        if (offset >= 12) {\n+                            offset -= 12;\n+                        }\n+                        roundUp = offset > 6;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                int min = val.getActualMinimum(fields[i][0]);\n+                int max = val.getActualMaximum(fields[i][0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset = val.get(fields[i][0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp = offset > ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            val.add(fields[i][0], -offset);\n+        }\n+        throw new RuntimeException(\"We do not support that field.\");\n+\n+    }\n+\n+    /**\n+     * Parses strings the way that CVS supports it... very human readable\n+     */\n+    public static Calendar parse(String original) {\n+        return parse(original, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Parses strings the way that CVS supports it... very human readable\n+     */\n+    public static Calendar parse(String original, Locale locale) {\n+        //Get the symbol names\n+        DateFormatSymbols symbols = new DateFormatSymbols(locale);\n+\n+        //Prep the string to parse\n+        String value = original.toLowerCase().trim();\n+\n+        //Get the current date/time\n+        Calendar now = Calendar.getInstance();\n+        if (value.endsWith(\" ago\")) {\n+            //If this was a date that was \"ago\" the current time...\n+            //Strip out the ' ago' part\n+            value = value.substring(0, value.length() - 4);\n+\n+            //Split the value and unit\n+            int start = value.indexOf(\" \");\n+            if (start < 0) {\n+                throw new RuntimeException(\"Could not find space in between value and unit\");\n+            }\n+            String unit = value.substring(start + 1);\n+            value = value.substring(0, start);\n+            //We support \"a week\", so we need to parse the value as \"a\"\n+            int val = 0;\n+            if (value.equals(\"a\") || value.equals(\"an\")) {\n+                val = 1;\n+            } else {\n+                val = Integer.parseInt(value);\n+            }\n+\n+            //Determine the unit\n+            if (unit.equals(\"milliseconds\") || unit.equals(\"millisecond\")) {\n+                now.add(Calendar.MILLISECOND, -val);\n+            } else if (unit.equals(\"seconds\") || unit.equals(\"second\")) {\n+                now.add(Calendar.SECOND, -val);\n+            } else if (unit.equals(\"minutes\") || unit.equals(\"minute\")) {\n+                now.add(Calendar.MINUTE, -val);\n+            } else if (unit.equals(\"hours\") || unit.equals(\"hour\")) {\n+                now.add(Calendar.HOUR, -val);\n+            } else if (unit.equals(\"days\") || unit.equals(\"day\")) {\n+                now.add(Calendar.DATE, -val);\n+            } else if (unit.equals(\"weeks\") || unit.equals(\"week\")) {\n+                now.add(Calendar.DATE, -val * 7);\n+            } else if (unit.equals(\"fortnights\") || unit.equals(\"fortnight\")) {\n+                now.add(Calendar.DATE, -val * 14);\n+            } else if (unit.equals(\"months\") || unit.equals(\"month\")) {\n+                now.add(Calendar.MONTH, -val);\n+            } else if (unit.equals(\"years\") || unit.equals(\"year\")) {\n+                now.add(Calendar.YEAR, -val);\n+            } else {\n+                throw new RuntimeException(\"We do not understand that many units ago\");\n+            }\n+            return now;\n+        } else if (value.startsWith(\"last \")) {\n+            //If this was the last time a certain field was met\n+            //Strip out the 'last ' part\n+            value = value.substring(5);\n+            //Get the current date/time\n+            String[] strings = symbols.getWeekdays();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after Sunday\n+                    int daysAgo = now.get(Calendar.DAY_OF_WEEK) - i;\n+                    if (daysAgo <= 0) {\n+                        daysAgo += 7;\n+                    }\n+                    now.add(Calendar.DATE, -daysAgo);\n+                    return now;\n+                }\n+            }\n+            strings = symbols.getMonths();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after January\n+                    int monthsAgo = now.get(Calendar.MONTH) - i;\n+                    if (monthsAgo <= 0) {\n+                        monthsAgo += 12;\n+                    }\n+                    now.add(Calendar.MONTH, -monthsAgo);\n+                    return now;\n+                }\n+            }\n+            if (value.equals(\"week\")) {\n+                now.add(Calendar.DATE, -7);\n+                return now;\n+            }\n+        } else if (value.equals(\"yesterday\")) {\n+            now.add(Calendar.DATE, -1);\n+            return now;\n+        } else if (value.equals(\"tomorrow\")) {\n+            now.add(Calendar.DATE, 1);\n+            return now;\n+        }\n+        //Try to parse the date a number of different ways\n+        for (int i = 0; i < dateFormats.length; i++) {\n+            try {\n+                Date datetime = dateFormats[i].parse(original);\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(datetime);\n+                return cal;\n+            } catch (ParseException pe) {\n+                //we ignore this and just keep trying\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Unable to parse '\" + original + \"'.\");\n+    }\n+\n+    /**\n+     * This constructs an Iterator that will start and stop over a date\n+     * range based on the focused date and the range style.  For instance,\n+     * passing Thursday, July 4, 2002 and a RANGE_MONTH_SUNDAY will return\n+     * an Iterator that starts with Sunday, June 30, 2002 and ends with\n+     * Saturday, August 3, 2002.\n+     */\n+    public static Iterator getCalendarIterator(Calendar focus, int rangeStyle) {\n+        Calendar start = null;\n+        Calendar end = null;\n+        int startCutoff = Calendar.SUNDAY;\n+        int endCutoff = Calendar.SATURDAY;\n+        switch (rangeStyle) {\n+            case RANGE_MONTH_SUNDAY:\n+            case RANGE_MONTH_MONDAY:\n+                //Set start to the first of the month\n+                start = trunc(focus, Calendar.MONTH);\n+                //Set end to the last of the month\n+                end = (Calendar) start.clone();\n+                end.add(Calendar.MONTH, 1);\n+                end.add(Calendar.DATE, -1);\n+                //Loop start back to the previous sunday or monday\n+                if (rangeStyle == RANGE_MONTH_MONDAY) {\n+                    startCutoff = Calendar.MONDAY;\n+                    endCutoff = Calendar.SUNDAY;\n+                }\n+                break;\n+            case RANGE_WEEK_SUNDAY:\n+            case RANGE_WEEK_MONDAY:\n+            case RANGE_WEEK_RELATIVE:\n+            case RANGE_WEEK_CENTER:\n+                //Set start and end to the current date\n+                start = trunc(focus, Calendar.DATE);\n+                end = trunc(focus, Calendar.DATE);\n+                switch (rangeStyle) {\n+                    case RANGE_WEEK_SUNDAY:\n+                        //already set by default\n+                        break;\n+                    case RANGE_WEEK_MONDAY:\n+                        startCutoff = Calendar.MONDAY;\n+                        endCutoff = Calendar.SUNDAY;\n+                        break;\n+                    case RANGE_WEEK_RELATIVE:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n+                        endCutoff = startCutoff - 1;\n+                        break;\n+                    case RANGE_WEEK_CENTER:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n+                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n+                        break;\n+                }\n+                break;\n+            default:\n+                throw new RuntimeException(\"The range style \" + rangeStyle + \" is not valid.\");\n+        }\n+        if (startCutoff < Calendar.SUNDAY) {\n+            startCutoff += 7;\n+        }\n+        if (endCutoff > Calendar.SATURDAY) {\n+            endCutoff -= 7;\n+        }\n+        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n+            start.add(Calendar.DATE, -1);\n+        }\n+        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n+            end.add(Calendar.DATE, 1);\n+        }\n+        final Calendar startFinal = start;\n+        final Calendar endFinal = end;\n+        Iterator it = new Iterator() {\n+            Calendar spot = null;\n+            {\n+                spot = startFinal;\n+                spot.add(Calendar.DATE, -1);\n+            }\n+\n+            public boolean hasNext() {\n+                return spot.before(endFinal);\n+            }\n+\n+            public Object next() {\n+                if (spot.equals(endFinal)) {\n+                    throw new NoSuchElementException();\n+                }\n+                spot.add(Calendar.DATE, 1);\n+                return spot.clone();\n+            }\n+\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        return it;\n+    }\n+\n+    /**\n+     * See the other getCalendarIterator.  Works with a Date.\n+     */\n+    public static Iterator getCalendarIterator(Date focus, int rangeStyle) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(focus);\n+        return getCalendarIterator(gval, rangeStyle);\n+    }\n+\n+    /**\n+     * See the other getCalendarIterator.  Works with an Object, trying\n+     * to use it as a Date or Calendar.\n+     */\n+    public static Iterator getCalendarIterator(Object focus, int rangeStyle) {\n+        if (focus instanceof Date) {\n+            return getCalendarIterator((Date) focus, rangeStyle);\n+        } else if (focus instanceof Calendar) {\n+            return getCalendarIterator((Calendar) focus, rangeStyle);\n+        } else {\n+            throw new ClassCastException(\"Could not iterate based on \" + focus);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/pending/CalendarUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+// package org.apache.commons.lang;\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CalendarUtils}.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ */\n+public class CalendarUtilsTest extends TestCase {\n+    DateFormat parser = null;\n+    Date date1 = null;\n+    Date date2 = null;\n+\n+    public CalendarUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(CalendarUtilsTest.class);\n+    \tsuite.setName(\"CalendarUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        parser = new java.text.SimpleDateFormat(\"MMM dd, yyyy H:mm:ss.SSS\");\n+\n+        date1 = parser.parse(\"February 12, 2002 12:34:56.789\");\n+        date2 = parser.parse(\"November 18, 2001 1:23:11.321\");\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+\n+    /**\n+     * Tests various values with the round method\n+     */\n+    public void testRound() throws Exception {\n+        assertEquals(\"round year-1 failed\",\n+                new Date(\"2002 January 1\"),\n+                CalendarUtils.round(date1, Calendar.YEAR));\n+        assertEquals(\"round year-2 failed\",\n+                new Date(\"2002 January 1\"),\n+                CalendarUtils.round(date2, Calendar.YEAR));\n+        assertEquals(\"round month-1 failed\",\n+                new Date(\"2002 February 1\"),\n+                CalendarUtils.round(date1, Calendar.MONTH));\n+        assertEquals(\"round month-2 failed\",\n+                new Date(\"2001 December 1\"),\n+                CalendarUtils.round(date2, Calendar.MONTH));\n+        assertEquals(\"round semimonth-1 failed\",\n+                new Date(\"2002 February 16\"),\n+                CalendarUtils.round(date1, CalendarUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-2 failed\",\n+                new Date(\"2001 November 16\"),\n+                CalendarUtils.round(date2, CalendarUtils.SEMI_MONTH));\n+        assertEquals(\"round date-1 failed\",\n+                new Date(\"2002 February 13\"),\n+                CalendarUtils.round(date1, Calendar.DATE));\n+        assertEquals(\"round date-2 failed\",\n+                new Date(\"2001 November 18\"),\n+                CalendarUtils.round(date2, Calendar.DATE));\n+        assertEquals(\"round hour-1 failed\",\n+                parser.parse(\"February 12, 2002 13:00:00.000\"),\n+                CalendarUtils.round(date1, Calendar.HOUR));\n+        assertEquals(\"round hour-2 failed\",\n+                parser.parse(\"November 18, 2001 1:00:00.000\"),\n+                CalendarUtils.round(date2, Calendar.HOUR));\n+        assertEquals(\"round minute-1 failed\",\n+                parser.parse(\"February 12, 2002 12:35:00.000\"),\n+                CalendarUtils.round(date1, Calendar.MINUTE));\n+        assertEquals(\"round minute-2 failed\",\n+                parser.parse(\"November 18, 2001 1:23:00.000\"),\n+                CalendarUtils.round(date2, Calendar.MINUTE));\n+        assertEquals(\"round second-1 failed\",\n+                parser.parse(\"February 12, 2002 12:34:57.000\"),\n+                CalendarUtils.round(date1, Calendar.SECOND));\n+        assertEquals(\"round second-2 failed\",\n+                parser.parse(\"November 18, 2001 1:23:11.000\"),\n+                CalendarUtils.round(date2, Calendar.SECOND));\n+    }\n+\n+    /**\n+     * Tests various values with the trunc method\n+     */\n+    public void testTrunc() throws Exception {\n+        assertEquals(\"trunc year-1 failed\",\n+                new Date(\"2002 January 1\"),\n+                CalendarUtils.trunc(date1, Calendar.YEAR));\n+        assertEquals(\"trunc year-2 failed\",\n+                new Date(\"2001 January 1\"),\n+                CalendarUtils.trunc(date2, Calendar.YEAR));\n+        assertEquals(\"trunc month-1 failed\",\n+                new Date(\"2002 February 1\"),\n+                CalendarUtils.trunc(date1, Calendar.MONTH));\n+        assertEquals(\"trunc month-2 failed\",\n+                new Date(\"2001 November 1\"),\n+                CalendarUtils.trunc(date2, Calendar.MONTH));\n+        assertEquals(\"trunc semimonth-1 failed\",\n+                new Date(\"2002 February 1\"),\n+                CalendarUtils.trunc(date1, CalendarUtils.SEMI_MONTH));\n+        assertEquals(\"trunc semimonth-2 failed\",\n+                new Date(\"2001 November 16\"),\n+                CalendarUtils.trunc(date2, CalendarUtils.SEMI_MONTH));\n+        assertEquals(\"trunc date-1 failed\",\n+                new Date(\"2002 February 12\"),\n+                CalendarUtils.trunc(date1, Calendar.DATE));\n+        assertEquals(\"trunc date-2 failed\",\n+                new Date(\"2001 November 18\"),\n+                CalendarUtils.trunc(date2, Calendar.DATE));\n+        assertEquals(\"trunc hour-1 failed\",\n+                parser.parse(\"February 12, 2002 12:00:00.000\"),\n+                CalendarUtils.trunc(date1, Calendar.HOUR));\n+        assertEquals(\"trunc hour-2 failed\",\n+                parser.parse(\"November 18, 2001 1:00:00.000\"),\n+                CalendarUtils.trunc(date2, Calendar.HOUR));\n+        assertEquals(\"trunc minute-1 failed\",\n+                parser.parse(\"February 12, 2002 12:34:00.000\"),\n+                CalendarUtils.trunc(date1, Calendar.MINUTE));\n+        assertEquals(\"trunc minute-2 failed\",\n+                parser.parse(\"November 18, 2001 1:23:00.000\"),\n+                CalendarUtils.trunc(date2, Calendar.MINUTE));\n+        assertEquals(\"trunc second-1 failed\",\n+                parser.parse(\"February 12, 2002 12:34:56.000\"),\n+                CalendarUtils.trunc(date1, Calendar.SECOND));\n+        assertEquals(\"trunc second-2 failed\",\n+                parser.parse(\"November 18, 2001 1:23:11.000\"),\n+                CalendarUtils.trunc(date2, Calendar.SECOND));\n+\n+    }\n+\n+    /**\n+     * Tests the parse method, which is supposed to handle various strings\n+     * as flexibly as CVS supports.\n+     */\n+    public void testParse() throws Exception {\n+        //This is difficult to test since the \"now\" used in the\n+        //  parse function cannot be controlled.  We could possibly control\n+        //  it by trying before and after and making sure the value we expect\n+        //  is between the two values calculated.\n+        //For now we're just using the custom assertEquals that takes a delta\n+\n+        Calendar now = null;\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MINUTE, -1);\n+        assertEquals(\"parse 1 minute ago\",\n+                now, CalendarUtils.parse(\"1 minute ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MINUTE, -8);\n+        assertEquals(\"parse 8 minutes ago\",\n+                now, CalendarUtils.parse(\"8 minutes ago\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, -1);\n+        assertEquals(\"parse yesterday\",\n+                now, CalendarUtils.parse(\"yesterday\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, 1);\n+        assertEquals(\"parse tomorrow\",\n+                now, CalendarUtils.parse(\"tomorrow\"), 50);\n+\n+        now = Calendar.getInstance();\n+        //Sunday would be 1, Saturday would be 7, so we walk back up to 6 days.\n+        if (now.get(Calendar.DATE) == 1) {\n+            //If Sunday already, we go back a full week\n+            now.add(Calendar.DATE, -7);\n+        } else {\n+            now.add(Calendar.DATE, 1 - now.get(Calendar.DAY_OF_WEEK));\n+        }\n+        assertEquals(\"parse last Sunday\",\n+                now, CalendarUtils.parse(\"last Sunday\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, -7);\n+        assertEquals(\"parse last week\",\n+                now, CalendarUtils.parse(\"last week\"), 50);\n+\n+        now = Calendar.getInstance();\n+        //January would be 0, December would be 11, so we walk back up to 11 months\n+        if (now.get(Calendar.MONTH) == 0) {\n+            //If January already, we go back a full year\n+            now.add(Calendar.MONTH, -12);\n+        } else {\n+            now.add(Calendar.MONTH, 0 - now.get(Calendar.MONTH));\n+        }\n+        assertEquals(\"parse last January\",\n+                now, CalendarUtils.parse(\"last January\"), 50);\n+    }\n+\n+    /**\n+     * Tests the calendar iterator for week ranges\n+     */\n+    public void testWeekIterator() throws Exception {\n+        Calendar now = Calendar.getInstance();\n+        Calendar today = CalendarUtils.trunc(now, Calendar.DATE);\n+        Calendar sunday = CalendarUtils.trunc(now, Calendar.DATE);\n+        sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));\n+        Calendar monday = CalendarUtils.trunc(now, Calendar.DATE);\n+        if (monday.get(Calendar.DATE) == 1) {\n+            //This is sunday... roll back 6 days\n+            monday.add(Calendar.DATE, -6);\n+        } else {\n+            monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));\n+        }\n+        Calendar centered = CalendarUtils.trunc(now, Calendar.DATE);\n+        centered.add(Calendar.DATE, -3);\n+\n+        Iterator it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_SUNDAY);\n+        assertWeekIterator(it, sunday);\n+        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_MONDAY);\n+        assertWeekIterator(it, monday);\n+        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_RELATIVE);\n+        assertWeekIterator(it, today);\n+        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_CENTER);\n+        assertWeekIterator(it, centered);\n+    }\n+\n+    /**\n+     * Tests the calendar iterator for month-based ranges\n+     */\n+    public void testMonthIterator() throws Exception {\n+        Iterator it = CalendarUtils.getCalendarIterator(date1, CalendarUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                new Date(\"January 27, 2002\"),\n+                new Date(\"March 2, 2002\"));\n+\n+        it = CalendarUtils.getCalendarIterator(date1, CalendarUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                new Date(\"January 28, 2002\"),\n+                new Date(\"March 3, 2002\"));\n+\n+        it = CalendarUtils.getCalendarIterator(date2, CalendarUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                new Date(\"October 28, 2001\"),\n+                new Date(\"December 1, 2001\"));\n+\n+        it = CalendarUtils.getCalendarIterator(date2, CalendarUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                new Date(\"October 29, 2001\"),\n+                new Date(\"December 2, 2001\"));\n+    }\n+\n+    /**\n+     * This checks that this is a 7 element iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other.\n+     */\n+    private static void assertWeekIterator(Iterator it, Calendar start) {\n+        Calendar end = (Calendar) start.clone();\n+        end.add(Calendar.DATE, 6);\n+\n+        assertWeekIterator(it, start, end);\n+    }\n+\n+    /**\n+     * Convenience method for when working with Date objects\n+     */\n+    private static void assertWeekIterator(Iterator it, Date start, Date end) {\n+        Calendar calStart = Calendar.getInstance();\n+        calStart.setTime(start);\n+        Calendar calEnd = Calendar.getInstance();\n+        calEnd.setTime(end);\n+\n+        assertWeekIterator(it, calStart, calEnd);\n+    }\n+\n+    /**\n+     * This checks that this is a 7 divisble iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other\n+     * (in addition to the proper start and stop dates)\n+     */\n+    private static void assertWeekIterator(Iterator it, Calendar start, Calendar end) {\n+        Calendar cal = (Calendar) it.next();\n+        assertEquals(\"\", start, cal, 0);\n+        Calendar last = null;\n+        int count = 1;\n+        while (it.hasNext()) {\n+            //Check this is just a date (no time component)\n+            assertEquals(\"\", cal, CalendarUtils.trunc(cal, Calendar.DATE), 0);\n+\n+            last = cal;\n+            cal = (Calendar) it.next();\n+            count++;\n+\n+            //Check that this is one day more than the last date\n+            last.add(Calendar.DATE, 1);\n+            assertEquals(\"\", last, cal, 0);\n+        }\n+        if (count % 7 != 0) {\n+            throw new AssertionFailedError(\"There were \" + count + \" days in this iterator\");\n+        }\n+        assertEquals(\"\", end, cal, 0);\n+    }\n+\n+    /**\n+     * Used to check that Calendar objects are close enough\n+     * delta is in milliseconds\n+     */\n+    public static void assertEquals(String message, Calendar cal1, Calendar cal2, long delta) {\n+        if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) {\n+            throw new AssertionFailedError(\n+                    message + \" expected \" + cal1.getTime() + \" but got \" + cal2.getTime());\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/pending/DateFormatter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.ParseException;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+/*\n+ * This class was created to hold the parseCVS method extracted from DateUtils in commons-lang.\n+ * The code was originally submitted by Serge Knystautas sergek@lokitech.com. It was never\n+ * fully implemented, and has been moved to the sandbox for further development. Recent discussion\n+ * from the commons-dev mailing list:\n+ * http://marc.theaimsgroup.com/?l=jakarta-commons-dev&m=108904098032038&w=2\n+ * Moving the code to the sandbox satisfies bug is a temporary solution to\n+ * http://issues.apache.org/bugzilla/show_bug.cgi?id=22172 but this issue needs to be considered\n+ * when the class/method is further developed.\n+ */\n+public class DateFormatter {\n+\n+    /**\n+     * <p>Parses a date string formatted in CVS format.</p>\n+     * \n+     * @param dateStr  the date to parse\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date cannot be parsed\n+     */\n+    public static Calendar parseCVS(String dateStr) {\n+        if (dateStr == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        //Get the symbol names\n+        DateFormatSymbols symbols = new DateFormatSymbols(Locale.ENGLISH);\n+\n+        DateFormat[] dateFormats = new DateFormat[0];\n+\n+        //Prep the string to parse\n+        String value = dateStr.toLowerCase().trim();\n+\n+        //Get the current date/time\n+        Calendar now = Calendar.getInstance();\n+        if (value.endsWith(\" ago\")) {\n+            //If this was a date that was \"ago\" the current time...\n+            //Strip out the ' ago' part\n+            value = value.substring(0, value.length() - 4);\n+\n+            //Split the value and unit\n+            int start = value.indexOf(\" \");\n+            if (start < 0) {\n+                throw new IllegalArgumentException(\"Could not find space in between value and unit\");\n+            }\n+            String unit = value.substring(start + 1);\n+            value = value.substring(0, start);\n+            //We support \"a week\", so we need to parse the value as \"a\"\n+            int val = 0;\n+            if (value.equals(\"a\") || value.equals(\"an\")) {\n+                val = 1;\n+            } else {\n+                val = Integer.parseInt(value);\n+            }\n+\n+            //Determine the unit\n+            if (unit.equals(\"milliseconds\") || unit.equals(\"millisecond\")) {\n+                now.add(Calendar.MILLISECOND, -val);\n+            } else if (unit.equals(\"seconds\") || unit.equals(\"second\")) {\n+                now.add(Calendar.SECOND, -val);\n+            } else if (unit.equals(\"minutes\") || unit.equals(\"minute\")) {\n+                now.add(Calendar.MINUTE, -val);\n+            } else if (unit.equals(\"hours\") || unit.equals(\"hour\")) {\n+                now.add(Calendar.HOUR, -val);\n+            } else if (unit.equals(\"days\") || unit.equals(\"day\")) {\n+                now.add(Calendar.DATE, -val);\n+            } else if (unit.equals(\"weeks\") || unit.equals(\"week\")) {\n+                now.add(Calendar.DATE, -val * 7);\n+            } else if (unit.equals(\"fortnights\") || unit.equals(\"fortnight\")) {\n+                now.add(Calendar.DATE, -val * 14);\n+            } else if (unit.equals(\"months\") || unit.equals(\"month\")) {\n+                now.add(Calendar.MONTH, -val);\n+            } else if (unit.equals(\"years\") || unit.equals(\"year\")) {\n+                now.add(Calendar.YEAR, -val);\n+            } else {\n+                throw new IllegalArgumentException(\"We do not understand that many units ago\");\n+            }\n+            return now;\n+        } else if (value.startsWith(\"last \")) {\n+            //If this was the last time a certain field was met\n+            //Strip out the 'last ' part\n+            value = value.substring(5);\n+            //Get the current date/time\n+            String[] strings = symbols.getWeekdays();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after Sunday\n+                    int daysAgo = now.get(Calendar.DAY_OF_WEEK) - i;\n+                    if (daysAgo <= 0) {\n+                        daysAgo += 7;\n+                    }\n+                    now.add(Calendar.DATE, -daysAgo);\n+                    return now;\n+                }\n+            }\n+            strings = symbols.getMonths();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after January\n+                    int monthsAgo = now.get(Calendar.MONTH) - i;\n+                    if (monthsAgo <= 0) {\n+                        monthsAgo += 12;\n+                    }\n+                    now.add(Calendar.MONTH, -monthsAgo);\n+                    return now;\n+                }\n+            }\n+            if (value.equals(\"week\")) {\n+                now.add(Calendar.DATE, -7);\n+                return now;\n+            }\n+            throw new IllegalArgumentException(\"We do not understand that last units\");\n+        } else if (value.equals(\"yesterday\")) {\n+            now.add(Calendar.DATE, -1);\n+            return now;\n+        } else if (value.equals(\"tomorrow\")) {\n+            now.add(Calendar.DATE, 1);\n+            return now;\n+        }\n+        //Try to parse the date a number of different ways\n+        for (int i = 0; i < dateFormats.length; i++) {\n+            try {\n+                Date datetime = dateFormats[i].parse(dateStr);\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(datetime);\n+                return cal;\n+            } catch (ParseException pe) {\n+                //we ignore this and just keep trying\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\"Unable to parse '\" + dateStr + \"'.\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/pending/DateFormatterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import junit.framework.AssertionFailedError;\n+import junit.framework.TestCase;\n+\n+/*\n+ * This class was created to hold test cases for the parseCVS method extracted from DateUtilsTest in commons-lang.\n+ * The code was originally submitted by Serge Knystautas sergek@lokitech.com. It was never\n+ * fully implemented, and has been moved to the sandbox for further development. Recent discussion\n+ * from the commons-dev mailing list:\n+ * http://marc.theaimsgroup.com/?l=jakarta-commons-dev&m=108904098032038&w=2\n+ * Moving the code to the sandbox satisfies bug is a temporary solution to\n+ * http://issues.apache.org/bugzilla/show_bug.cgi?id=22172 but this issue needs to be considered\n+ * when the class/method is further developed.\n+ */\n+public class DateFormatterTest extends TestCase {\n+\n+    /*\n+     * Tests the parse method, which is supposed to handle various strings\n+     * as flexibly as CVS supports.\n+     */\n+    public void testParseCVS() throws Exception {\n+        try {\n+            DateFormatter.parseCVS(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateFormatter.parseCVS(\"gobbledegook\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateFormatter.parseCVS(\"ago\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateFormatter.parseCVS(\"1 junk ago\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateFormatter.parseCVS(\"1month ago\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateFormatter.parseCVS(\"last month\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+\n+        //This is difficult to test since the \"now\" used in the\n+        //  parse function cannot be controlled.  We could possibly control\n+        //  it by trying before and after and making sure the value we expect\n+        //  is between the two values calculated.\n+        //For now we're just using the custom assertEquals that takes a delta\n+\n+        Calendar now = null;\n+\n+        // M/dd/yy H:mm:ss z\n+        now = Calendar.getInstance();\n+        now.set(Calendar.MILLISECOND, 0);\n+        assertEquals(\"parseCVS format M/dd/yy H:mm:ss z\",\n+                  now, DateFormatter.parseCVS(new SimpleDateFormat(\"M/dd/yy H:mm:ss z\").format(now.getTime())), 50);\n+        // MMM d, yyyy h:mm a\n+        now = Calendar.getInstance();\n+        now.set(Calendar.MILLISECOND, 0);\n+        now.set(Calendar.SECOND, 0);\n+        assertEquals(\"parseCVS format MMM d, yyyy h:mm a\",\n+                  now, DateFormatter.parseCVS(new SimpleDateFormat(\"MMM d, yyyy h:mm a\").format(now.getTime())), 50);\n+        // h:mm z\n+        //\n+        // This format is difficult to test using the current time because the\n+        // parseCVS method applies the default date of January 1, 1970 to the\n+        // parsed time. The most straightforward way to test the parse is to\n+        // pass in a known value, and test the output against this know value.\n+        // \n+        now = Calendar.getInstance();\n+        now.setTime(new SimpleDateFormat(\"h:mm z\").parse(\"16:30 GMT\"));\n+        assertEquals(\"parseCVS format h:mm z 16:30 GMT\", \n+                  now, DateFormatter.parseCVS(\"16:30 GMT\"), 50);\n+        now = Calendar.getInstance();\n+        now.setTime(new SimpleDateFormat(\"h:mm z\").parse(\"16:30 EST\"));\n+        assertEquals(\"parseCVS format h:mm z 16:30 EST\", \n+                  now, DateFormatter.parseCVS(\"16:30 EST\"), 50);\n+        now = Calendar.getInstance();\n+        now.setTime(new SimpleDateFormat(\"h:mm z\").parse(\"16:30 GMT-05:00\"));\n+        assertEquals(\"parseCVS format h:mm z 16:30 GMT-05:00\", \n+                  now, DateFormatter.parseCVS(\"16:30 GMT-05:00\"), 50);\n+        now = Calendar.getInstance();\n+        now.setTime(new SimpleDateFormat(\"h:mm z\").parse(\"16:30 GMT+01:00\"));\n+        assertEquals(\"parseCVS format h:mm z 16:30 GMT+01:00\", \n+                  now, DateFormatter.parseCVS(\"16:30 GMT+01:00\"), 50);\n+        \n+        now = Calendar.getInstance();\n+        now.setTime(new SimpleDateFormat(\"h:mm z\").parse(\"06:30 GMT\"));\n+        assertEquals(\"parseCVS format h:mm z 06:30 GMT\", \n+                  now, DateFormatter.parseCVS(\"06:30 GMT\"), 50);\n+        now = Calendar.getInstance();\n+        now.setTime(new SimpleDateFormat(\"h:mm z\").parse(\"06:30 EST\"));\n+        assertEquals(\"parseCVS format h:mm z 06:30 EST\", \n+                  now, DateFormatter.parseCVS(\"06:30 EST\"), 50);\n+        now = Calendar.getInstance();\n+        now.setTime(new SimpleDateFormat(\"h:mm z\").parse(\"06:30 GMT-05:00\"));\n+        assertEquals(\"parseCVS format h:mm z 06:30 GMT-05:00\", \n+                  now, DateFormatter.parseCVS(\"06:30 GMT-05:00\"), 50);\n+        now = Calendar.getInstance();\n+        now.setTime(new SimpleDateFormat(\"h:mm z\").parse(\"06:30 GMT+01:00\"));\n+        assertEquals(\"parseCVS format h:mm z 06:30 GMT+01:00\", \n+                  now, DateFormatter.parseCVS(\"06:30 GMT+01:00\"), 50);\n+        \n+        now = Calendar.getInstance();\n+        now.add(Calendar.WEEK_OF_MONTH, -1);\n+        assertEquals(\"parseCVS a week ago\",\n+                now, DateFormatter.parseCVS(\"a week ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.WEEK_OF_MONTH, -1);\n+        assertEquals(\"parseCVS an week ago\",\n+                now, DateFormatter.parseCVS(\"an week ago\"), 50);\n+        \n+        now = Calendar.getInstance();\n+        now.add(Calendar.DAY_OF_MONTH, -14);\n+        assertEquals(\"parseCVS 1 fortnight ago\",\n+                now, DateFormatter.parseCVS(\"1 fortnight ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DAY_OF_MONTH, -14);\n+        assertEquals(\"parseCVS 1 fortnights ago\",\n+                now, DateFormatter.parseCVS(\"1 fortnights ago\"), 50);\n+        \n+        now = Calendar.getInstance();\n+        now.add(Calendar.MINUTE, -1);\n+        assertEquals(\"parseCVS 1 minute ago\",\n+                now, DateFormatter.parseCVS(\"1 minute ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MINUTE, -8);\n+        assertEquals(\"parseCVS 8 minutes ago\",\n+                now, DateFormatter.parseCVS(\"8 minutes ago\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MILLISECOND, -1);\n+        assertEquals(\"parseCVS 1 millisecond ago\",\n+                now, DateFormatter.parseCVS(\"1 millisecond ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MILLISECOND, -100);\n+        assertEquals(\"parseCVS 1 milliseconds ago\",\n+                now, DateFormatter.parseCVS(\"100 milliseconds ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.SECOND, -30);\n+        assertEquals(\"parseCVS 30 second ago\",\n+                now, DateFormatter.parseCVS(\"30 second ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.SECOND, -30);\n+        assertEquals(\"parseCVS 30 seconds ago\",\n+                now, DateFormatter.parseCVS(\"30 seconds ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.HOUR, -2);\n+        assertEquals(\"parseCVS 2 hour ago\",\n+                now, DateFormatter.parseCVS(\"2 hour ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.HOUR, -2);\n+        assertEquals(\"parseCVS 2 hours ago\",\n+                now, DateFormatter.parseCVS(\"2 hours ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DAY_OF_MONTH, -2);\n+        assertEquals(\"parseCVS 2 day ago\",\n+                now, DateFormatter.parseCVS(\"2 day ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DAY_OF_MONTH, -2);\n+        assertEquals(\"parseCVS 2 days ago\",\n+                now, DateFormatter.parseCVS(\"2 days ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MONTH, -2);\n+        assertEquals(\"parseCVS 2 month ago\",\n+                now, DateFormatter.parseCVS(\"2 month ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MONTH, -2);\n+        assertEquals(\"parseCVS 2 months ago\",\n+                now, DateFormatter.parseCVS(\"2 months ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.YEAR, -2);\n+        assertEquals(\"parseCVS 2 year ago\",\n+                now, DateFormatter.parseCVS(\"2 year ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.YEAR, -2);\n+        assertEquals(\"parseCVS 2 years ago\",\n+                now, DateFormatter.parseCVS(\"2 years ago\"), 50);\n+        \n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, -1);\n+        assertEquals(\"parseCVS yesterday\",\n+                now, DateFormatter.parseCVS(\"yesterday\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, 1);\n+        assertEquals(\"parseCVS tomorrow\",\n+                now, DateFormatter.parseCVS(\"tomorrow\"), 50);\n+\n+        now = Calendar.getInstance();\n+        //Sunday would be 1, Saturday would be 7, so we walk back up to 6 days.\n+        if (now.get(Calendar.DAY_OF_WEEK) == 1) {\n+            //If Sunday already, we go back a full week\n+            now.add(Calendar.DATE, -7);\n+        } else {\n+            now.add(Calendar.DATE, 1 - now.get(Calendar.DAY_OF_WEEK));\n+        }\n+        assertEquals(\"parseCVS last Sunday\",\n+                now, DateFormatter.parseCVS(\"last Sunday\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, -7);\n+        assertEquals(\"parseCVS last week\",\n+                now, DateFormatter.parseCVS(\"last week\"), 50);\n+        \n+        now = Calendar.getInstance();\n+        //January would be 0, December would be 11, so we walk back up to 11 months\n+        if (now.get(Calendar.MONTH) == 0) {\n+            //If January already, we go back a full year\n+            now.add(Calendar.MONTH, -12);\n+        } else {\n+            now.add(Calendar.MONTH, 0 - now.get(Calendar.MONTH));\n+        }\n+        assertEquals(\"parseCVS last January\",\n+                now, DateFormatter.parseCVS(\"last January\"), 50);\n+    }\n+\n+    /**\n+     * Used to check that Calendar objects are close enough\n+     * delta is in milliseconds\n+     */\n+    public static void assertEquals(String message, Calendar cal1, Calendar cal2, long delta) {\n+        if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) {\n+            throw new AssertionFailedError(\n+                    message + \" expected \" + cal1.getTime() + \" but got \" + cal2.getTime());\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/AllLangTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.builder.BuilderTestSuite;\n+import org.apache.commons.lang.enums.EnumTestSuite;\n+import org.apache.commons.lang.exception.ExceptionTestSuite;\n+import org.apache.commons.lang.math.MathTestSuite;\n+import org.apache.commons.lang.mutable.MutableTestSuite;\n+import org.apache.commons.lang.text.TextTestSuite;\n+import org.apache.commons.lang.time.TimeTestSuite;\n+\n+/**\n+ * Test suite for [lang].\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class AllLangTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public AllLangTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang (all) Tests\");\n+        suite.addTest(LangTestSuite.suite());\n+        suite.addTest(BuilderTestSuite.suite());\n+        suite.addTest(EnumTestSuite.suite());\n+        suite.addTest(org.apache.commons.lang.enum.EnumTestSuite.suite());\n+        suite.addTest(ExceptionTestSuite.suite());\n+        suite.addTest(MathTestSuite.suite());\n+        suite.addTest(MutableTestSuite.suite());\n+        suite.addTest(TextTestSuite.suite());\n+        suite.addTest(TimeTestSuite.suite());\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/ArrayUtilsAddTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests ArrayUtils add methods.\n+ * \n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class ArrayUtilsAddTest extends TestCase {\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayUtilsAddTest.class);\n+        suite.setName(\"ArrayUtils add Tests\");\n+        return suite;\n+    }\n+\n+    public void testAddObjectArrayBoolean() {\n+        boolean[] newArray;\n+        newArray = ArrayUtils.add((boolean[])null, false);\n+        assertTrue(Arrays.equals(new boolean[]{false}, newArray));\n+        assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((boolean[])null, true);\n+        assertTrue(Arrays.equals(new boolean[]{true}, newArray));\n+        assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());\n+        boolean[] array1 = new boolean[]{true, false, true};\n+        newArray = ArrayUtils.add(array1, false);\n+        assertTrue(Arrays.equals(new boolean[]{true, false, true, false}, newArray));\n+        assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());\n+    }\n+    \n+    public void testAddObjectArrayByte() {\n+        byte[] newArray;\n+        newArray = ArrayUtils.add((byte[])null, (byte)0);\n+        assertTrue(Arrays.equals(new byte[]{0}, newArray));\n+        assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((byte[])null, (byte)1);\n+        assertTrue(Arrays.equals(new byte[]{1}, newArray));\n+        assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n+        byte[] array1 = new byte[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, (byte)0);\n+        assertTrue(Arrays.equals(new byte[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, (byte)4);\n+        assertTrue(Arrays.equals(new byte[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Byte.TYPE, newArray.getClass().getComponentType());        \n+    }\n+    \n+    public void testAddObjectArrayChar() {\n+        char[] newArray;\n+        newArray = ArrayUtils.add((char[])null, (char)0);\n+        assertTrue(Arrays.equals(new char[]{0}, newArray));\n+        assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((char[])null, (char)1);\n+        assertTrue(Arrays.equals(new char[]{1}, newArray));\n+        assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n+        char[] array1 = new char[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, (char)0);\n+        assertTrue(Arrays.equals(new char[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, (char)4);\n+        assertTrue(Arrays.equals(new char[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Character.TYPE, newArray.getClass().getComponentType());        \n+    }\n+    \n+    public void testAddObjectArrayDouble() {\n+        double[] newArray;\n+        newArray = ArrayUtils.add((double[])null, 0);\n+        assertTrue(Arrays.equals(new double[]{0}, newArray));\n+        assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((double[])null, 1);\n+        assertTrue(Arrays.equals(new double[]{1}, newArray));\n+        assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n+        double[] array1 = new double[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, 0);\n+        assertTrue(Arrays.equals(new double[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, 4);\n+        assertTrue(Arrays.equals(new double[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Double.TYPE, newArray.getClass().getComponentType());        \n+    }\n+    \n+    public void testAddObjectArrayFloat() {\n+        float[] newArray;\n+        newArray = ArrayUtils.add((float[])null, 0);\n+        assertTrue(Arrays.equals(new float[]{0}, newArray));\n+        assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((float[])null, 1);\n+        assertTrue(Arrays.equals(new float[]{1}, newArray));\n+        assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n+        float[] array1 = new float[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, 0);\n+        assertTrue(Arrays.equals(new float[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, 4);\n+        assertTrue(Arrays.equals(new float[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Float.TYPE, newArray.getClass().getComponentType());        \n+    }\n+    \n+    public void testAddObjectArrayInt() {\n+        int[] newArray;\n+        newArray = ArrayUtils.add((int[])null, 0);\n+        assertTrue(Arrays.equals(new int[]{0}, newArray));\n+        assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((int[])null, 1);\n+        assertTrue(Arrays.equals(new int[]{1}, newArray));\n+        assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n+        int[] array1 = new int[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, 0);\n+        assertTrue(Arrays.equals(new int[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, 4);\n+        assertTrue(Arrays.equals(new int[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Integer.TYPE, newArray.getClass().getComponentType());        \n+    }\n+    \n+    public void testAddObjectArrayLong() {\n+        long[] newArray;\n+        newArray = ArrayUtils.add((long[])null, 0);\n+        assertTrue(Arrays.equals(new long[]{0}, newArray));\n+        assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((long[])null, 1);\n+        assertTrue(Arrays.equals(new long[]{1}, newArray));\n+        assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n+        long[] array1 = new long[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, 0);\n+        assertTrue(Arrays.equals(new long[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, 4);\n+        assertTrue(Arrays.equals(new long[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Long.TYPE, newArray.getClass().getComponentType());        \n+    }\n+    \n+    public void testAddObjectArrayShort() {\n+        short[] newArray;\n+        newArray = ArrayUtils.add((short[])null, (short)0);\n+        assertTrue(Arrays.equals(new short[]{0}, newArray));\n+        assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((short[])null, (short)1);\n+        assertTrue(Arrays.equals(new short[]{1}, newArray));\n+        assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n+        short[] array1 = new short[]{1, 2, 3};\n+        newArray = ArrayUtils.add(array1, (short)0);\n+        assertTrue(Arrays.equals(new short[]{1, 2, 3, 0}, newArray));\n+        assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(array1, (short)4);\n+        assertTrue(Arrays.equals(new short[]{1, 2, 3, 4}, newArray));\n+        assertEquals(Short.TYPE, newArray.getClass().getComponentType());        \n+    }\n+    \n+    public void testAddObjectArrayObject() {\n+        Object[] newArray;\n+        newArray = ArrayUtils.add((Object[])null, null);\n+        assertTrue(Arrays.equals((new Object[]{null}), newArray));\n+        assertEquals(Object.class, newArray.getClass().getComponentType());\n+        \n+        newArray = ArrayUtils.add((Object[])null, \"a\");\n+        assertTrue(Arrays.equals((new String[]{\"a\"}), newArray));\n+        assertTrue(Arrays.equals((new Object[]{\"a\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        \n+        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        newArray = ArrayUtils.add(stringArray1, null);\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", null}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        \n+        newArray = ArrayUtils.add(stringArray1, \"d\");\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"d\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        \n+        Number[] numberArray1 = new Number[]{new Integer(1), new Double(2)};\n+        newArray = ArrayUtils.add(numberArray1, new Float(3));\n+        assertTrue(Arrays.equals((new Number[]{new Integer(1), new Double(2), new Float(3)}), newArray));\n+        assertEquals(Number.class, newArray.getClass().getComponentType());\n+        \n+        numberArray1 = null;\n+        newArray = ArrayUtils.add(numberArray1, new Float(3));\n+        assertTrue(Arrays.equals((new Float[]{new Float(3)}), newArray));\n+        assertEquals(Float.class, newArray.getClass().getComponentType());\n+        \n+        numberArray1 = null;\n+        newArray = ArrayUtils.add(numberArray1, null);\n+        assertTrue(Arrays.equals((new Object[]{null}), newArray));\n+        assertEquals(Object.class, newArray.getClass().getComponentType());\n+    }\n+    \n+    public void testAddObjectArrayToObjectArray() {\n+        assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null));\n+        Object[] newArray;\n+        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        String[] stringArray2 = new String[]{\"1\", \"2\", \"3\"};\n+        newArray = ArrayUtils.addAll(stringArray1, null);\n+        assertNotSame(stringArray1, newArray);\n+        assertTrue(Arrays.equals(stringArray1, newArray));\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(null, stringArray2);\n+        assertNotSame(stringArray2, newArray);\n+        assertTrue(Arrays.equals(stringArray2, newArray));\n+        assertTrue(Arrays.equals((new String[]{\"1\", \"2\", \"3\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(stringArray1, stringArray2);\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, null);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n+        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n+        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n+        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        String[] stringArrayNull = new String []{null};\n+        newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull);        \n+        assertTrue(Arrays.equals((new String[]{null, null}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+\n+        // boolean\n+        assertTrue( Arrays.equals( new boolean[] { true, false, false, true }, \n+            ArrayUtils.addAll( new boolean[] { true, false }, new boolean[] { false, true } ) ) );\n+\n+        assertTrue( Arrays.equals( new boolean[] { false, true }, \n+            ArrayUtils.addAll( null, new boolean[] { false, true } ) ) );\n+\n+        assertTrue( Arrays.equals( new boolean[] { true, false }, \n+            ArrayUtils.addAll( new boolean[] { true, false }, null ) ) );\n+\n+        // char\n+        assertTrue( Arrays.equals( new char[] { 'a', 'b', 'c', 'd' }, \n+            ArrayUtils.addAll( new char[] { 'a', 'b' }, new char[] { 'c', 'd' } ) ) );\n+\n+        assertTrue( Arrays.equals( new char[] { 'c', 'd' }, \n+            ArrayUtils.addAll( null, new char[] { 'c', 'd' } ) ) );\n+\n+        assertTrue( Arrays.equals( new char[] { 'a', 'b' }, \n+            ArrayUtils.addAll( new char[] { 'a', 'b' }, null ) ) );\n+\n+        // byte\n+        assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1, (byte) 2, (byte) 3 }, \n+            ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, new byte[] { (byte) 2, (byte) 3 } ) ) );\n+\n+        assertTrue( Arrays.equals( new byte[] { (byte) 2, (byte) 3 }, \n+            ArrayUtils.addAll( null, new byte[] { (byte) 2, (byte) 3 } ) ) );\n+\n+        assertTrue( Arrays.equals( new byte[] { (byte) 0, (byte) 1 }, \n+            ArrayUtils.addAll( new byte[] { (byte) 0, (byte) 1 }, null ) ) );\n+\n+        // short\n+        assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20, (short) 30, (short) 40 }, \n+            ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, new short[] { (short) 30, (short) 40 } ) ) );\n+\n+        assertTrue( Arrays.equals( new short[] { (short) 30, (short) 40 }, \n+            ArrayUtils.addAll( null, new short[] { (short) 30, (short) 40 } ) ) );\n+\n+        assertTrue( Arrays.equals( new short[] { (short) 10, (short) 20 }, \n+            ArrayUtils.addAll( new short[] { (short) 10, (short) 20 }, null ) ) );\n+\n+        // int\n+        assertTrue( Arrays.equals( new int[] { 1, 1000, -1000, -1 }, \n+            ArrayUtils.addAll( new int[] { 1, 1000 }, new int[] { -1000, -1 } ) ) );\n+\n+        assertTrue( Arrays.equals( new int[] { -1000, -1 }, \n+            ArrayUtils.addAll( null, new int[] { -1000, -1 } ) ) );\n+\n+        assertTrue( Arrays.equals( new int[] { 1, 1000 }, \n+            ArrayUtils.addAll( new int[] { 1, 1000 }, null ) ) );\n+\n+        // long\n+        assertTrue( Arrays.equals( new long[] { 1L, -1L, 1000L, -1000L }, \n+            ArrayUtils.addAll( new long[] { 1L, -1L }, new long[] { 1000L, -1000L } ) ) );\n+\n+        assertTrue( Arrays.equals( new long[] { 1000L, -1000L }, \n+            ArrayUtils.addAll( null, new long[] { 1000L, -1000L } ) ) );\n+        \n+        assertTrue( Arrays.equals( new long[] { 1L, -1L }, \n+            ArrayUtils.addAll( new long[] { 1L, -1L }, null ) ) );\n+\n+        // float\n+        assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f, 1.6f, 0.01f }, \n+            ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, new float[] { 1.6f, 0.01f } ) ) );\n+\n+        assertTrue( Arrays.equals( new float[] { 1.6f, 0.01f }, \n+            ArrayUtils.addAll( null, new float[] { 1.6f, 0.01f } ) ) );\n+\n+        assertTrue( Arrays.equals( new float[] { 10.5f, 10.1f }, \n+            ArrayUtils.addAll( new float[] { 10.5f, 10.1f }, null ) ) );\n+\n+        // double\n+        assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI, 0, 9.99 }, \n+            ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, new double[] { 0, 9.99 } ) ) );\n+\n+        assertTrue( Arrays.equals( new double[] { 0, 9.99 }, \n+            ArrayUtils.addAll( null, new double[] { 0, 9.99 } ) ) );\n+\n+        assertTrue( Arrays.equals( new double[] { Math.PI, -Math.PI }, \n+            ArrayUtils.addAll( new double[] { Math.PI, -Math.PI }, null ) ) );\n+\n+    }    \n+    \n+    public void testAddObjectAtIndex() {\n+        Object[] newArray;\n+        newArray = ArrayUtils.add((Object[])null, 0, null);\n+        assertTrue(Arrays.equals((new Object[]{null}), newArray));\n+        assertEquals(Object.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add((Object[])null, 0, \"a\");\n+        assertTrue(Arrays.equals((new String[]{\"a\"}), newArray));\n+        assertTrue(Arrays.equals((new Object[]{\"a\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        newArray = ArrayUtils.add(stringArray1, 0, null);\n+        assertTrue(Arrays.equals((new String[]{null, \"a\", \"b\", \"c\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(stringArray1, 1, null);\n+        assertTrue(Arrays.equals((new String[]{\"a\", null, \"b\", \"c\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(stringArray1, 3, null);\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", null}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+        newArray = ArrayUtils.add(stringArray1, 3, \"d\");\n+        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"d\"}), newArray));\n+        assertEquals(String.class, newArray.getClass().getComponentType());        \n+        assertEquals(String.class, newArray.getClass().getComponentType());\n+\n+        Object[] o = new Object[] {\"1\", \"2\", \"4\"};\n+        Object[] result = ArrayUtils.add(o, 2, \"3\");\n+        Object[] result2 = ArrayUtils.add(o, 3, \"5\");\n+        \n+        assertNotNull(result);\n+        assertEquals(4, result.length);\n+        assertEquals(\"1\", result[0]);\n+        assertEquals(\"2\", result[1]);\n+        assertEquals(\"3\", result[2]);\n+        assertEquals(\"4\", result[3]);\n+        assertNotNull(result2);\n+        assertEquals(4, result2.length);\n+        assertEquals(\"1\", result2[0]);\n+        assertEquals(\"2\", result2[1]);\n+        assertEquals(\"4\", result2[2]);\n+        assertEquals(\"5\", result2[3]);\n+\n+        // boolean tests\n+        boolean[] booleanArray = ArrayUtils.add( null, 0, true );\n+        assertTrue( Arrays.equals( new boolean[] { true }, booleanArray ) );\n+        try {\n+            booleanArray = ArrayUtils.add( null, -1, true );\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        booleanArray = ArrayUtils.add( new boolean[] { true }, 0, false);\n+        assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) );\n+        booleanArray = ArrayUtils.add( new boolean[] { false }, 1, true);\n+        assertTrue( Arrays.equals( new boolean[] { false, true }, booleanArray ) );\n+        booleanArray = ArrayUtils.add( new boolean[] { true, false }, 1, true);\n+        assertTrue( Arrays.equals( new boolean[] { true, true, false }, booleanArray ) );\n+        try {\n+            booleanArray = ArrayUtils.add( new boolean[] { true, false }, 4, true);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            booleanArray = ArrayUtils.add( new boolean[] { true, false }, -1, true);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // char tests\n+        char[] charArray = ArrayUtils.add( (char[]) null, 0, 'a' );\n+        assertTrue( Arrays.equals( new char[] { 'a' }, charArray ) );\n+        try {\n+            charArray = ArrayUtils.add( (char[]) null, -1, 'a' );\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        charArray = ArrayUtils.add( new char[] { 'a' }, 0, 'b');\n+        assertTrue( Arrays.equals( new char[] { 'b', 'a' }, charArray ) );\n+        charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 0, 'c');\n+        assertTrue( Arrays.equals( new char[] { 'c', 'a', 'b' }, charArray ) );\n+        charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 1, 'k');\n+        assertTrue( Arrays.equals( new char[] { 'a', 'k', 'b' }, charArray ) );\n+        charArray = ArrayUtils.add( new char[] { 'a', 'b', 'c' }, 1, 't');\n+        assertTrue( Arrays.equals( new char[] { 'a', 't', 'b', 'c' }, charArray ) );\n+        try {\n+            charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 4, 'c');\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            charArray = ArrayUtils.add( new char[] { 'a', 'b' }, -1, 'c');\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // short tests\n+        short[] shortArray = ArrayUtils.add( new short[] { 1 }, 0, (short) 2);\n+        assertTrue( Arrays.equals( new short[] { 2, 1 }, shortArray ) );\n+        try {\n+            shortArray = ArrayUtils.add( (short[]) null, -1, (short) 2);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        shortArray = ArrayUtils.add( new short[] { 2, 6 }, 2, (short) 10);\n+        assertTrue( Arrays.equals( new short[] { 2, 6, 10 }, shortArray ) );\n+        shortArray = ArrayUtils.add( new short[] { 2, 6 }, 0, (short) -4);\n+        assertTrue( Arrays.equals( new short[] { -4, 2, 6 }, shortArray ) );\n+        shortArray = ArrayUtils.add( new short[] { 2, 6, 3 }, 2, (short) 1);\n+        assertTrue( Arrays.equals( new short[] { 2, 6, 1, 3 }, shortArray ) );\n+        try {\n+            shortArray = ArrayUtils.add( new short[] { 2, 6 }, 4, (short) 10);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            shortArray = ArrayUtils.add( new short[] { 2, 6 }, -1, (short) 10);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // byte tests\n+        byte[] byteArray = ArrayUtils.add( new byte[] { 1 }, 0, (byte) 2);\n+        assertTrue( Arrays.equals( new byte[] { 2, 1 }, byteArray ) );\n+        try {\n+            byteArray = ArrayUtils.add( (byte[]) null, -1, (byte) 2);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 2, (byte) 3);\n+        assertTrue( Arrays.equals( new byte[] { 2, 6, 3 }, byteArray ) );\n+        byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 0, (byte) 1);\n+        assertTrue( Arrays.equals( new byte[] { 1, 2, 6 }, byteArray ) );\n+        byteArray = ArrayUtils.add( new byte[] { 2, 6, 3 }, 2, (byte) 1);\n+        assertTrue( Arrays.equals( new byte[] { 2, 6, 1, 3 }, byteArray ) );\n+        try {\n+            byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 4, (byte) 3);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            byteArray = ArrayUtils.add( new byte[] { 2, 6 }, -1, (byte) 3);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // int tests\n+        int[] intArray = ArrayUtils.add( new int[] { 1 }, 0, 2);\n+        assertTrue( Arrays.equals( new int[] { 2, 1 }, intArray ) );\n+        try {\n+            intArray = ArrayUtils.add( (int[]) null, -1, 2);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        intArray = ArrayUtils.add( new int[] { 2, 6 }, 2, 10);\n+        assertTrue( Arrays.equals( new int[] { 2, 6, 10 }, intArray ) );\n+        intArray = ArrayUtils.add( new int[] { 2, 6 }, 0, -4);\n+        assertTrue( Arrays.equals( new int[] { -4, 2, 6 }, intArray ) );\n+        intArray = ArrayUtils.add( new int[] { 2, 6, 3 }, 2, 1);\n+        assertTrue( Arrays.equals( new int[] { 2, 6, 1, 3 }, intArray ) );\n+        try {\n+            intArray = ArrayUtils.add( new int[] { 2, 6 }, 4, 10);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            intArray = ArrayUtils.add( new int[] { 2, 6 }, -1, 10);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // long tests\n+        long[] longArray = ArrayUtils.add( new long[] { 1L }, 0, 2L);\n+        assertTrue( Arrays.equals( new long[] { 2L, 1L }, longArray ) );\n+        try {\n+            longArray = ArrayUtils.add( (long[]) null, -1, 2L);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        longArray = ArrayUtils.add( new long[] { 2L, 6L }, 2, 10L);\n+        assertTrue( Arrays.equals( new long[] { 2L, 6L, 10L }, longArray ) );\n+        longArray = ArrayUtils.add( new long[] { 2L, 6L }, 0, -4L);\n+        assertTrue( Arrays.equals( new long[] { -4L, 2L, 6L }, longArray ) );\n+        longArray = ArrayUtils.add( new long[] { 2L, 6L, 3L }, 2, 1L);\n+        assertTrue( Arrays.equals( new long[] { 2L, 6L, 1L, 3L }, longArray ) );\n+        try {\n+            longArray = ArrayUtils.add( new long[] { 2L, 6L }, 4, 10L);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            longArray = ArrayUtils.add( new long[] { 2L, 6L }, -1, 10L);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // float tests\n+        float[] floatArray = ArrayUtils.add( new float[] { 1.1f }, 0, 2.2f);\n+        assertTrue( Arrays.equals( new float[] { 2.2f, 1.1f }, floatArray ) );\n+        try {\n+            floatArray = ArrayUtils.add( (float[]) null, -1, 2.2f);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 2, 10.5f);\n+        assertTrue( Arrays.equals( new float[] { 2.3f, 6.4f, 10.5f }, floatArray ) );\n+        floatArray = ArrayUtils.add( new float[] { 2.6f, 6.7f }, 0, -4.8f);\n+        assertTrue( Arrays.equals( new float[] { -4.8f, 2.6f, 6.7f }, floatArray ) );\n+        floatArray = ArrayUtils.add( new float[] { 2.9f, 6.0f, 0.3f }, 2, 1.0f);\n+        assertTrue( Arrays.equals( new float[] { 2.9f, 6.0f, 1.0f, 0.3f }, floatArray ) );\n+        try {\n+            floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 4, 10.5f);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, -1, 10.5f);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+\n+        // double tests\n+        double[] doubleArray = ArrayUtils.add( new double[] { 1.1 }, 0, 2.2);\n+        assertTrue( Arrays.equals( new double[] { 2.2, 1.1 }, doubleArray ) );\n+        try {\n+          doubleArray = ArrayUtils.add( (double[]) null, -1, 2.2);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n+        }\n+        doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 2, 10.5);\n+        assertTrue( Arrays.equals( new double[] { 2.3, 6.4, 10.5 }, doubleArray ) );\n+        doubleArray = ArrayUtils.add( new double[] { 2.6, 6.7 }, 0, -4.8);\n+        assertTrue( Arrays.equals( new double[] { -4.8, 2.6, 6.7 }, doubleArray ) );\n+        doubleArray = ArrayUtils.add( new double[] { 2.9, 6.0, 0.3 }, 2, 1.0);\n+        assertTrue( Arrays.equals( new double[] { 2.9, 6.0, 1.0, 0.3 }, doubleArray ) );\n+        try {\n+            doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 4, 10.5);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n+        }\n+        try {\n+            doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, -1, 10.5);\n+        } catch(IndexOutOfBoundsException e) {\n+            assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/ArrayUtilsRemoveTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests ArrayUtils remove and removeElement methods.\n+ * \n+ * @author Maarten Coene\n+ * @version $Id$\n+ */\n+public class ArrayUtilsRemoveTest extends TestCase {\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayUtilsRemoveTest.class);\n+        suite.setName(\"ArrayUtils remove Tests\");\n+        return suite;\n+    }\n+\n+    public void testRemoveObjectArray() {\n+        Object[] array;\n+        array = ArrayUtils.remove(new Object[] {\"a\"}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 0);\n+        assertTrue(Arrays.equals(new Object[] {\"b\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 1);\n+        assertTrue(Arrays.equals(new Object[] {\"a\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new Object[] {\"a\", \"b\", \"c\"}, 1);\n+        assertTrue(Arrays.equals(new Object[] {\"a\", \"c\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new Object[] {\"a\", \"b\"}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((Object[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveBooleanArray() {\n+        boolean[] array;\n+        array = ArrayUtils.remove(new boolean[] {true}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false}, 0);\n+        assertTrue(Arrays.equals(new boolean[] {false}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false}, 1);\n+        assertTrue(Arrays.equals(new boolean[] {true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new boolean[] {true, false, true}, 1);\n+        assertTrue(Arrays.equals(new boolean[] {true, true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new boolean[] {true, false}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new boolean[] {true, false}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((boolean[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveByteArray() {\n+        byte[] array;\n+        array = ArrayUtils.remove(new byte[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new byte[] {2}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new byte[] {1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new byte[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new byte[] {1, 1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new byte[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new byte[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((byte[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveCharArray() {\n+        char[] array;\n+        array = ArrayUtils.remove(new char[] {'a'}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b'}, 0);\n+        assertTrue(Arrays.equals(new char[] {'b'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b'}, 1);\n+        assertTrue(Arrays.equals(new char[] {'a'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new char[] {'a', 'b', 'c'}, 1);\n+        assertTrue(Arrays.equals(new char[] {'a', 'c'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new char[] {'a', 'b'}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new char[] {'a', 'b'}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((char[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveDoubleArray() {\n+        double[] array;\n+        array = ArrayUtils.remove(new double[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new double[] {2}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new double[] {1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new double[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new double[] {1, 1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new double[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new double[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((double[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveFloatArray() {\n+        float[] array;\n+        array = ArrayUtils.remove(new float[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new float[] {2}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new float[] {1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new float[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new float[] {1, 1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new float[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new float[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((float[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveIntArray() {\n+        int[] array;\n+        array = ArrayUtils.remove(new int[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new int[] {2}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new int[] {1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new int[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new int[] {1, 1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new int[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new int[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((int[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveLongArray() {\n+        long[] array;\n+        array = ArrayUtils.remove(new long[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new long[] {2}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new long[] {1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new long[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new long[] {1, 1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new long[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new long[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((long[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveShortArray() {\n+        short[] array;\n+        array = ArrayUtils.remove(new short[] {1}, 0);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2}, 0);\n+        assertTrue(Arrays.equals(new short[] {2}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new short[] {1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.remove(new short[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new short[] {1, 1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        try {\n+            ArrayUtils.remove(new short[] {1, 2}, -1);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove(new short[] {1, 2}, 2);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            ArrayUtils.remove((short[]) null, 0);\n+            fail(\"IndexOutOfBoundsException expected\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+    \n+    public void testRemoveElementObjectArray() {\n+        Object[] array;\n+        array = ArrayUtils.removeElement((Object[]) null, \"a\");\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_OBJECT_ARRAY, \"a\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\"}, \"a\");\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_OBJECT_ARRAY, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\", \"b\"}, \"a\");\n+        assertTrue(Arrays.equals(new Object[] {\"b\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new Object[] {\"a\", \"b\", \"a\"}, \"a\");\n+        assertTrue(Arrays.equals(new Object[] {\"b\", \"a\"}, array));\n+        assertEquals(Object.class, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementBooleanArray() {\n+        boolean[] array;\n+        array = ArrayUtils.removeElement((boolean[]) null, true);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BOOLEAN_ARRAY, true);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true}, true);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true, false}, true);\n+        assertTrue(Arrays.equals(new boolean[] {false}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new boolean[] {true, false, true}, true);\n+        assertTrue(Arrays.equals(new boolean[] {false, true}, array));\n+        assertEquals(Boolean.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementByteArray() {\n+        byte[] array;\n+        array = ArrayUtils.removeElement((byte[]) null, (byte) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_BYTE_ARRAY, (byte) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1}, (byte) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_BYTE_ARRAY, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1, 2}, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] {2}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new byte[] {1, 2, 1}, (byte) 1);\n+        assertTrue(Arrays.equals(new byte[] {2, 1}, array));\n+        assertEquals(Byte.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementCharArray() {\n+        char[] array;\n+        array = ArrayUtils.removeElement((char[]) null, 'a');\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_CHAR_ARRAY, 'a');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a'}, 'a');\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_CHAR_ARRAY, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a', 'b'}, 'a');\n+        assertTrue(Arrays.equals(new char[] {'b'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new char[] {'a', 'b', 'a'}, 'a');\n+        assertTrue(Arrays.equals(new char[] {'b', 'a'}, array));\n+        assertEquals(Character.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementDoubleArray() {\n+        double[] array;\n+        array = ArrayUtils.removeElement((double[]) null, (double) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_DOUBLE_ARRAY, (double) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1}, (double) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_DOUBLE_ARRAY, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1, 2}, (double) 1);\n+        assertTrue(Arrays.equals(new double[] {2}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new double[] {1, 2, 1}, (double) 1);\n+        assertTrue(Arrays.equals(new double[] {2, 1}, array));\n+        assertEquals(Double.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementFloatArray() {\n+        float[] array;\n+        array = ArrayUtils.removeElement((float[]) null, (float) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_FLOAT_ARRAY, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1}, (float) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_FLOAT_ARRAY, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1, 2}, (float) 1);\n+        assertTrue(Arrays.equals(new float[] {2}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new float[] {1, 2, 1}, (float) 1);\n+        assertTrue(Arrays.equals(new float[] {2, 1}, array));\n+        assertEquals(Float.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementIntArray() {\n+        int[] array;\n+        array = ArrayUtils.removeElement((int[]) null, 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_INT_ARRAY, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1}, 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_INT_ARRAY, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1, 2}, 1);\n+        assertTrue(Arrays.equals(new int[] {2}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new int[] {1, 2, 1}, 1);\n+        assertTrue(Arrays.equals(new int[] {2, 1}, array));\n+        assertEquals(Integer.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementLongArray() {\n+        long[] array;\n+        array = ArrayUtils.removeElement((long[]) null, (long) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_LONG_ARRAY, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1}, (long) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_LONG_ARRAY, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1, 2}, (long) 1);\n+        assertTrue(Arrays.equals(new long[] {2}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new long[] {1, 2, 1}, (long) 1);\n+        assertTrue(Arrays.equals(new long[] {2, 1}, array));\n+        assertEquals(Long.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+    public void testRemoveElementShortArray() {\n+        short[] array;\n+        array = ArrayUtils.removeElement((short[]) null, (short) 1);\n+        assertNull(array);\n+        array = ArrayUtils.removeElement(ArrayUtils.EMPTY_SHORT_ARRAY, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1}, (short) 1);\n+        assertTrue(Arrays.equals(ArrayUtils.EMPTY_SHORT_ARRAY, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1, 2}, (short) 1);\n+        assertTrue(Arrays.equals(new short[] {2}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+        array = ArrayUtils.removeElement(new short[] {1, 2, 1}, (short) 1);\n+        assertTrue(Arrays.equals(new short[] {2, 1}, array));\n+        assertEquals(Short.TYPE, array.getClass().getComponentType());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/ArrayUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.ArrayUtils}.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Moritz Petersen\n+ * @author Nikolay Metchev\n+ * @author Matthew Hawthorne\n+ * @author Tim O'Brien\n+ * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n+ * @author Fredrik Westermarck\n+ * @author Gary Gregory\n+ * @author Maarten Coene\n+ * @version $Id$\n+ */\n+public class ArrayUtilsTest extends TestCase {\n+\n+    public ArrayUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayUtilsTest.class);\n+        suite.setName(\"ArrayUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new ArrayUtils());\n+        Constructor[] cons = ArrayUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(ArrayUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(ArrayUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        assertEquals(\"{}\", ArrayUtils.toString(null));\n+        assertEquals(\"{}\", ArrayUtils.toString(new Object[0]));\n+        assertEquals(\"{}\", ArrayUtils.toString(new String[0]));\n+        assertEquals(\"{<null>}\", ArrayUtils.toString(new String[] {null}));\n+        assertEquals(\"{pink,blue}\", ArrayUtils.toString(new String[] {\"pink\",\"blue\"}));\n+        \n+        assertEquals(\"<empty>\", ArrayUtils.toString(null, \"<empty>\"));\n+        assertEquals(\"{}\", ArrayUtils.toString(new Object[0], \"<empty>\"));\n+        assertEquals(\"{}\", ArrayUtils.toString(new String[0], \"<empty>\"));\n+        assertEquals(\"{<null>}\", ArrayUtils.toString(new String[] {null}, \"<empty>\"));\n+        assertEquals(\"{pink,blue}\", ArrayUtils.toString(new String[] {\"pink\",\"blue\"}, \"<empty>\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testHashCode() {\n+        long[][] array1 = new long[][] {{2,5}, {4,5}};\n+        long[][] array2 = new long[][] {{2,5}, {4,6}};\n+        assertEquals(true, ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1));\n+        assertEquals(false, ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2));\n+        \n+        Object[] array3 = new Object[] {new String(new char[] {'A', 'B'})};\n+        Object[] array4 = new Object[] {\"AB\"};\n+        assertEquals(true, ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3));\n+        assertEquals(true, ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array4));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void assertIsEquals(Object array1, Object array2, Object array3) {\n+        assertEquals(true, ArrayUtils.isEquals(array1, array1));\n+        assertEquals(true, ArrayUtils.isEquals(array2, array2));\n+        assertEquals(true, ArrayUtils.isEquals(array3, array3));\n+        assertEquals(false, ArrayUtils.isEquals(array1, array2));\n+        assertEquals(false, ArrayUtils.isEquals(array2, array1));\n+        assertEquals(false, ArrayUtils.isEquals(array1, array3));\n+        assertEquals(false, ArrayUtils.isEquals(array3, array1));\n+        assertEquals(false, ArrayUtils.isEquals(array1, array2));\n+        assertEquals(false, ArrayUtils.isEquals(array2, array1));\n+    }\n+\n+    public void testIsEquals() {\n+        long[][] larray1 = new long[][]{{2, 5}, {4, 5}};\n+        long[][] larray2 = new long[][]{{2, 5}, {4, 6}};\n+        long[] larray3 = new long[]{2, 5};\n+        this.assertIsEquals(larray1, larray2, larray3);\n+\n+        int[][] iarray1 = new int[][]{{2, 5}, {4, 5}};\n+        int[][] iarray2 = new int[][]{{2, 5}, {4, 6}};\n+        int[] iarray3 = new int[]{2, 5};\n+        this.assertIsEquals(iarray1, iarray2, iarray3);\n+\n+        short[][] sarray1 = new short[][]{{2, 5}, {4, 5}};\n+        short[][] sarray2 = new short[][]{{2, 5}, {4, 6}};\n+        short[] sarray3 = new short[]{2, 5};\n+        this.assertIsEquals(sarray1, sarray2, sarray3);\n+\n+        float[][] farray1 = new float[][]{{2, 5}, {4, 5}};\n+        float[][] farray2 = new float[][]{{2, 5}, {4, 6}};\n+        float[] farray3 = new float[]{2, 5};\n+        this.assertIsEquals(farray1, farray2, farray3);\n+\n+        double[][] darray1 = new double[][]{{2, 5}, {4, 5}};\n+        double[][] darray2 = new double[][]{{2, 5}, {4, 6}};\n+        double[] darray3 = new double[]{2, 5};\n+        this.assertIsEquals(darray1, darray2, darray3);\n+\n+        byte[][] byteArray1 = new byte[][]{{2, 5}, {4, 5}};\n+        byte[][] byteArray2 = new byte[][]{{2, 5}, {4, 6}};\n+        byte[] byteArray3 = new byte[]{2, 5};\n+        this.assertIsEquals(byteArray1, byteArray2, byteArray3);\n+\n+        char[][] charArray1 = new char[][]{{2, 5}, {4, 5}};\n+        char[][] charArray2 = new char[][]{{2, 5}, {4, 6}};\n+        char[] charArray3 = new char[]{2, 5};\n+        this.assertIsEquals(charArray1, charArray2, charArray3);\n+\n+        boolean[][] barray1 = new boolean[][]{{true, false}, {true, true}};\n+        boolean[][] barray2 = new boolean[][]{{true, false}, {true, false}};\n+        boolean[] barray3 = new boolean[]{false, true};\n+        this.assertIsEquals(barray1, barray2, barray3);\n+\n+        Object[] array3 = new Object[]{new String(new char[]{'A', 'B'})};\n+        Object[] array4 = new Object[]{\"AB\"};\n+        assertEquals(true, ArrayUtils.isEquals(array3, array3));\n+        assertEquals(true, ArrayUtils.isEquals(array3, array4));\n+\n+        assertEquals(true, ArrayUtils.isEquals(null, null));\n+        assertEquals(false, ArrayUtils.isEquals(null, array4));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToMap() {\n+        Map map = ArrayUtils.toMap(new String[][] {{\"foo\", \"bar\"}, {\"hello\", \"world\"}});\n+        \n+        assertEquals(\"bar\", map.get(\"foo\"));\n+        assertEquals(\"world\", map.get(\"hello\"));\n+        \n+        assertEquals(null, ArrayUtils.toMap(null));\n+        try {\n+            ArrayUtils.toMap(new String[][] {{\"foo\", \"bar\"}, {\"short\"}});\n+            fail(\"exception expected\");\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ArrayUtils.toMap(new Object[] {new Object[] {\"foo\", \"bar\"}, \"illegal type\"});\n+            fail(\"exception expected\");\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ArrayUtils.toMap(new Object[] {new Object[] {\"foo\", \"bar\"}, null});\n+            fail(\"exception expected\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        map = ArrayUtils.toMap(new Object[] {new Map.Entry() {\n+            public Object getKey() {\n+                return \"foo\";\n+            }\n+            public Object getValue() {\n+                return \"bar\";\n+            }\n+            public Object setValue(Object value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            public boolean equals(Object o) {\n+                throw new UnsupportedOperationException();\n+            }\n+            public int hashCode() {\n+                throw new UnsupportedOperationException();\n+            }\n+        }});\n+        assertEquals(\"bar\", map.get(\"foo\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClone() {\n+        assertEquals(null, ArrayUtils.clone((Object[]) null));\n+        Object[] original1 = new Object[0];\n+        Object[] cloned1 = ArrayUtils.clone(original1);\n+        assertTrue(Arrays.equals(original1, cloned1));\n+        assertTrue(original1 != cloned1);\n+        \n+        StringBuffer buf = new StringBuffer(\"pick\");\n+        original1 = new Object[] {buf, \"a\", new String[] {\"stick\"}};\n+        cloned1 = ArrayUtils.clone(original1);\n+        assertTrue(Arrays.equals(original1, cloned1));\n+        assertTrue(original1 != cloned1);\n+        assertSame(original1[0], cloned1[0]);\n+        assertSame(original1[1], cloned1[1]);\n+        assertSame(original1[2], cloned1[2]);\n+    }\n+\n+    public void testCloneBoolean() {\n+        assertEquals(null, ArrayUtils.clone((boolean[]) null));\n+        boolean[] original = new boolean[] {true, false};\n+        boolean[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneLong() {\n+        assertEquals(null, ArrayUtils.clone((long[]) null));\n+        long[] original = new long[] {0L, 1L};\n+        long[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneInt() {\n+        assertEquals(null, ArrayUtils.clone((int[]) null));\n+        int[] original = new int[] {5, 8};\n+        int[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneShort() {\n+        assertEquals(null, ArrayUtils.clone((short[]) null));\n+        short[] original = new short[] {1, 4};\n+        short[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneChar() {\n+        assertEquals(null, ArrayUtils.clone((char[]) null));\n+        char[] original = new char[] {'a', '4'};\n+        char[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneByte() {\n+        assertEquals(null, ArrayUtils.clone((byte[]) null));\n+        byte[] original = new byte[] {1, 6};\n+        byte[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneDouble() {\n+        assertEquals(null, ArrayUtils.clone((double[]) null));\n+        double[] original = new double[] {2.4d, 5.7d};\n+        double[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+    \n+    public void testCloneFloat() {\n+        assertEquals(null, ArrayUtils.clone((float[]) null));\n+        float[] original = new float[] {2.6f, 6.4f};\n+        float[] cloned = ArrayUtils.clone(original);\n+        assertTrue(Arrays.equals(original, cloned));\n+        assertTrue(original != cloned);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testSubarrayObject() {\n+        Object[] nullArray = null;\n+        Object[] objectArray = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n+\n+        assertEquals(\"0 start, mid end\", \"abcd\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4)));\n+        assertEquals(\"0 start, length end\", \"abcdef\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 0, objectArray.length)));\n+        assertEquals(\"mid start, mid end\", \"bcd\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 1, 4)));\n+        assertEquals(\"mid start, length end\", \"bcdef\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 1, objectArray.length)));\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+        assertEquals(\"empty array\", \"\",\n+            StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2)));\n+        assertEquals(\"start > end\", \"\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2)));\n+        assertEquals(\"start == end\", \"\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3)));\n+        assertEquals(\"start undershoot, normal end\", \"abcd\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4)));\n+        assertEquals(\"start overshoot, any end\", \"\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4)));\n+        assertEquals(\"normal start, end overshoot\", \"cdef\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, 2, 33)));\n+        assertEquals(\"start undershoot, end overshoot\", \"abcdef\",\n+            StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12)));\n+            \n+        // array type tests\n+        Date[] dateArray = { new java.sql.Date(new Date().getTime()),\n+            new Date(), new Date(), new Date(), new Date() };\n+\n+        assertSame(\"Object type\", Object.class,\n+            ArrayUtils.subarray(objectArray, 2, 4).getClass().getComponentType());\n+        assertSame(\"java.util.Date type\", java.util.Date.class,\n+            ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType());\n+        assertNotSame(\"java.sql.Date type\", java.sql.Date.class,\n+            ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType());\n+        try {\n+            Object dummy = (java.sql.Date[])ArrayUtils.subarray(dateArray, 1,3);\n+            fail(\"Invalid downcast\");\n+        } catch (ClassCastException e) {}\n+    }\n+\n+    public void testSubarrayLong() {\n+        long[] nullArray = null;\n+        long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 };\n+        long[] leftSubarray     = { 999910, 999911, 999912, 999913 };\n+        long[] midSubarray      = { 999911, 999912, 999913, 999914 };\n+        long[] rightSubarray    = { 999912, 999913, 999914, 999915 };\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_LONG_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_LONG_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_LONG_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_LONG_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_LONG_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"long type\", long.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayInt() {\n+        int[] nullArray = null;\n+        int[] array = { 10, 11, 12, 13, 14, 15 };\n+        int[] leftSubarray  = { 10, 11, 12, 13 };\n+        int[] midSubarray   = { 11, 12, 13, 14 };\n+        int[] rightSubarray = { 12, 13, 14, 15 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_INT_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_INT_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_INT_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_INT_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"int type\", int.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayShort() {\n+        short[] nullArray = null;\n+        short[] array = { 10, 11, 12, 13, 14, 15 };\n+        short[] leftSubarray    = { 10, 11, 12, 13 };\n+        short[] midSubarray     = { 11, 12, 13, 14 };\n+        short[] rightSubarray   = { 12, 13, 14, 15 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_SHORT_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_SHORT_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_SHORT_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_SHORT_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"short type\", short.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrChar() {\n+        char[] nullArray = null;\n+        char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' };\n+        char[] leftSubarray     = { 'a', 'b', 'c', 'd', };\n+        char[] midSubarray      = { 'b', 'c', 'd', 'e', };\n+        char[] rightSubarray    = { 'c', 'd', 'e', 'f', };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_CHAR_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_CHAR_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_CHAR_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_CHAR_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"char type\", char.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayByte() {\n+        byte[] nullArray = null;\n+        byte[] array = { 10, 11, 12, 13, 14, 15 };\n+        byte[] leftSubarray     = { 10, 11, 12, 13 };\n+        byte[] midSubarray      = { 11, 12, 13, 14 };\n+        byte[] rightSubarray = { 12, 13, 14, 15 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_BYTE_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_BYTE_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_BYTE_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_BYTE_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"byte type\", byte.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayDouble() {\n+        double[] nullArray = null;\n+        double[] array = { 10.123, 11.234, 12.345, 13.456, 14.567, 15.678 };\n+        double[] leftSubarray   = { 10.123, 11.234, 12.345, 13.456, };\n+        double[] midSubarray    = { 11.234, 12.345, 13.456, 14.567, };\n+        double[] rightSubarray  = { 12.345, 13.456, 14.567, 15.678 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_DOUBLE_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"double type\", double.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayFloat() {\n+        float[] nullArray = null;\n+        float[] array = { 10, 11, 12, 13, 14, 15 };\n+        float[] leftSubarray    = { 10, 11, 12, 13 };\n+        float[] midSubarray     = { 11, 12, 13, 14 };\n+        float[] rightSubarray   = { 12, 13, 14, 15 };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_FLOAT_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_FLOAT_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_FLOAT_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_FLOAT_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"float type\", float.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+\n+    public void testSubarrayBoolean() {\n+        boolean[] nullArray = null;\n+        boolean[] array = { true, true, false, true, false, true };\n+        boolean[] leftSubarray  = { true, true, false, true  };\n+        boolean[] midSubarray   = { true, false, true, false };\n+        boolean[] rightSubarray = { false, true, false, true };\n+\n+\n+        assertTrue(\"0 start, mid end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, 0, 4)));\n+\n+        assertTrue(\"0 start, length end\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, 0, array.length)));\n+\n+        assertTrue(\"mid start, mid end\",\n+            ArrayUtils.isEquals(midSubarray,\n+                ArrayUtils.subarray(array, 1, 5)));\n+\n+        assertTrue(\"mid start, length end\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, array.length)));\n+\n+\n+        assertNull(\"null input\", ArrayUtils.subarray(nullArray, 0, 3));\n+\n+        assertEquals(\"empty array\", ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+            ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2));\n+\n+        assertEquals(\"start > end\", ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+            ArrayUtils.subarray(array, 4, 2));\n+\n+        assertEquals(\"start == end\", ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+            ArrayUtils.subarray(array, 3, 3));\n+\n+        assertTrue(\"start undershoot, normal end\",\n+            ArrayUtils.isEquals(leftSubarray,\n+                ArrayUtils.subarray(array, -2, 4)));\n+\n+        assertEquals(\"start overshoot, any end\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(array, 33, 4));\n+\n+        assertTrue(\"normal start, end overshoot\",\n+            ArrayUtils.isEquals(rightSubarray,\n+                ArrayUtils.subarray(array, 2, 33)));\n+\n+        assertTrue(\"start undershoot, end overshoot\",\n+            ArrayUtils.isEquals(array,\n+                ArrayUtils.subarray(array, -2, 12)));\n+\n+        // empty-return tests\n+\n+        assertSame(\"empty array, object test\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2));\n+\n+        assertSame(\"start > end, object test\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(array, 4, 1));\n+\n+        assertSame(\"start == end, object test\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(array, 3, 3));\n+\n+        assertSame(\"start overshoot, any end, object test\",\n+            ArrayUtils.EMPTY_BOOLEAN_ARRAY,\n+                ArrayUtils.subarray(array, 8733, 4));\n+\n+        // array type tests\n+\n+        assertSame(\"boolean type\", boolean.class,\n+            ArrayUtils.subarray(array, 2, 4).getClass().getComponentType());\n+\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSameLength() {\n+        Object[] nullArray = null;\n+        Object[] emptyArray = new Object[0];\n+        Object[] oneArray = new Object[] {\"pick\"};\n+        Object[] twoArray = new Object[] {\"pick\", \"stick\"};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+\n+    public void testSameLengthBoolean() {\n+        boolean[] nullArray = null;\n+        boolean[] emptyArray = new boolean[0];\n+        boolean[] oneArray = new boolean[] {true};\n+        boolean[] twoArray = new boolean[] {true, false};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthLong() {\n+        long[] nullArray = null;\n+        long[] emptyArray = new long[0];\n+        long[] oneArray = new long[] {0L};\n+        long[] twoArray = new long[] {0L, 76L};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthInt() {\n+        int[] nullArray = null;\n+        int[] emptyArray = new int[0];\n+        int[] oneArray = new int[] {4};\n+        int[] twoArray = new int[] {5, 7};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthShort() {\n+        short[] nullArray = null;\n+        short[] emptyArray = new short[0];\n+        short[] oneArray = new short[] {4};\n+        short[] twoArray = new short[] {6, 8};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthChar() {\n+        char[] nullArray = null;\n+        char[] emptyArray = new char[0];\n+        char[] oneArray = new char[] {'f'};\n+        char[] twoArray = new char[] {'d', 't'};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthByte() {\n+        byte[] nullArray = null;\n+        byte[] emptyArray = new byte[0];\n+        byte[] oneArray = new byte[] {3};\n+        byte[] twoArray = new byte[] {4, 6};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthDouble() {\n+        double[] nullArray = null;\n+        double[] emptyArray = new double[0];\n+        double[] oneArray = new double[] {1.3d};\n+        double[] twoArray = new double[] {4.5d, 6.3d};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    public void testSameLengthFloat() {\n+        float[] nullArray = null;\n+        float[] emptyArray = new float[0];\n+        float[] oneArray = new float[] {2.5f};\n+        float[] twoArray = new float[] {6.4f, 5.8f};\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));\n+        \n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));\n+        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));\n+        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));\n+        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));\n+        \n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));\n+        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));\n+        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSameType() {\n+        try {\n+            ArrayUtils.isSameType(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ArrayUtils.isSameType(null, new Object[0]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ArrayUtils.isSameType(new Object[0], null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(true, ArrayUtils.isSameType(new Object[0], new Object[0]));\n+        assertEquals(false, ArrayUtils.isSameType(new String[0], new Object[0]));\n+        assertEquals(true, ArrayUtils.isSameType(new String[0][0], new String[0][0]));\n+        assertEquals(false, ArrayUtils.isSameType(new String[0], new String[0][0]));\n+        assertEquals(false, ArrayUtils.isSameType(new String[0][0], new String[0]));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testReverse() {\n+        StringBuffer str1 = new StringBuffer(\"pick\");\n+        String str2 = \"a\";\n+        String[] str3 = new String[] {\"stick\"};\n+        String str4 = \"up\";\n+        \n+        Object[] array = new Object[] {str1, str2, str3};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], str3);\n+        assertEquals(array[1], str2);\n+        assertEquals(array[2], str1);\n+        \n+        array = new Object[] {str1, str2, str3, str4};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], str4);\n+        assertEquals(array[1], str3);\n+        assertEquals(array[2], str2);\n+        assertEquals(array[3], str1);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+\n+    public void testReverseLong() {\n+        long[] array = new long[] {1L, 2L, 3L};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 3L);\n+        assertEquals(array[1], 2L);\n+        assertEquals(array[2], 1L);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseInt() {\n+        int[] array = new int[] {1, 2, 3};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 3);\n+        assertEquals(array[1], 2);\n+        assertEquals(array[2], 1);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseShort() {\n+        short[] array = new short[] {1, 2, 3};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 3);\n+        assertEquals(array[1], 2);\n+        assertEquals(array[2], 1);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseChar() {\n+        char[] array = new char[] {'a', 'f', 'C'};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 'C');\n+        assertEquals(array[1], 'f');\n+        assertEquals(array[2], 'a');\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseByte() {\n+        byte[] array = new byte[] {2, 3, 4};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 4);\n+        assertEquals(array[1], 3);\n+        assertEquals(array[2], 2);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseDouble() {\n+        double[] array = new double[] {0.3d, 0.4d, 0.5d};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 0.5d, 0.0d);\n+        assertEquals(array[1], 0.4d, 0.0d);\n+        assertEquals(array[2], 0.3d, 0.0d);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseFloat() {\n+        float[] array = new float[] {0.3f, 0.4f, 0.5f};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], 0.5f, 0.0f);\n+        assertEquals(array[1], 0.4f, 0.0f);\n+        assertEquals(array[2], 0.3f, 0.0f);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    public void testReverseBoolean() {\n+        boolean[] array = new boolean[] {false, false, true};\n+        ArrayUtils.reverse(array);\n+        assertEquals(array[0], true);\n+        assertEquals(array[1], false);\n+        assertEquals(array[2], false);\n+\n+        array = null;\n+        ArrayUtils.reverse(array);\n+        assertEquals(null, array);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOf() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(-1, ArrayUtils.indexOf(null, null));\n+        assertEquals(-1, ArrayUtils.indexOf(null, \"0\"));\n+        assertEquals(-1, ArrayUtils.indexOf(new Object[0], \"0\"));\n+        assertEquals(0, ArrayUtils.indexOf(array, \"0\"));\n+        assertEquals(1, ArrayUtils.indexOf(array, \"1\"));\n+        assertEquals(2, ArrayUtils.indexOf(array, \"2\"));\n+        assertEquals(3, ArrayUtils.indexOf(array, \"3\"));\n+        assertEquals(4, ArrayUtils.indexOf(array, null));\n+        assertEquals(-1, ArrayUtils.indexOf(array, \"notInArray\"));\n+    }\n+\n+    public void testIndexOfWithStartIndex() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(-1, ArrayUtils.indexOf(null, null, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(new Object[0], \"0\", 0));\n+        assertEquals(-1, ArrayUtils.indexOf(null, \"0\", 2));\n+        assertEquals(5, ArrayUtils.indexOf(array, \"0\", 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, \"1\", 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, \"2\", 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, \"3\", 2));\n+        assertEquals(4, ArrayUtils.indexOf(array, null, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, \"notInArray\", 2));\n+        \n+        assertEquals(4, ArrayUtils.indexOf(array, null, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, null, 8));\n+        assertEquals(-1, ArrayUtils.indexOf(array, \"0\", 8));\n+    }\n+\n+    public void testLastIndexOf() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(null, null));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(null, \"0\"));\n+        assertEquals(5, ArrayUtils.lastIndexOf(array, \"0\"));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, \"1\"));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, \"2\"));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, \"3\"));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, null));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, \"notInArray\"));\n+    }\n+\n+    public void testLastIndexOfWithStartIndex() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(null, null, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(null, \"0\", 2));\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, \"0\", 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, \"1\", 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, \"2\", 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, \"3\", 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, \"3\", -1));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, null, 5));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, null, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, \"notInArray\", 5));\n+        \n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, null, -1));\n+        assertEquals(5, ArrayUtils.lastIndexOf(array, \"0\", 88));\n+    }\n+\n+    public void testContains() {\n+        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        assertEquals(false, ArrayUtils.contains(null, null));\n+        assertEquals(false, ArrayUtils.contains(null, \"1\"));\n+        assertEquals(true, ArrayUtils.contains(array, \"0\"));\n+        assertEquals(true, ArrayUtils.contains(array, \"1\"));\n+        assertEquals(true, ArrayUtils.contains(array, \"2\"));\n+        assertEquals(true, ArrayUtils.contains(array, \"3\"));\n+        assertEquals(true, ArrayUtils.contains(array, null));\n+        assertEquals(false, ArrayUtils.contains(array, \"notInArray\"));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfLong() {\n+        long[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 99));\n+    }\n+\n+    public void testIndexOfLongWithStartIndex() {\n+        long[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0, 2));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0, 6));\n+    }\n+\n+    public void testLastIndexOfLong() {\n+        long[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 0));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));\n+    }\n+\n+    public void testLastIndexOfLongWithStartIndex() {\n+        long[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 99, 4));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88));\n+    }\n+\n+    public void testContainsLong() {\n+        long[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, 1));\n+        array = new long[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, 0));\n+        assertEquals(true, ArrayUtils.contains(array, 1));\n+        assertEquals(true, ArrayUtils.contains(array, 2));\n+        assertEquals(true, ArrayUtils.contains(array, 3));\n+        assertEquals(false, ArrayUtils.contains(array, 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfInt() {\n+        int[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 99));\n+    }\n+\n+    public void testIndexOfIntWithStartIndex() {\n+        int[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0, 2));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 0, 6));\n+    }\n+\n+    public void testLastIndexOfInt() {\n+        int[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 0));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));\n+    }\n+\n+    public void testLastIndexOfIntWithStartIndex() {\n+        int[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 0, 2));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 0, 88));\n+    }\n+\n+    public void testContainsInt() {\n+        int[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, 1));\n+        array = new int[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, 0));\n+        assertEquals(true, ArrayUtils.contains(array, 1));\n+        assertEquals(true, ArrayUtils.contains(array, 2));\n+        assertEquals(true, ArrayUtils.contains(array, 3));\n+        assertEquals(false, ArrayUtils.contains(array, 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfShort() {\n+        short[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 0));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (short) 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (short) 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, (short) 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (short) 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 99));\n+    }\n+\n+    public void testIndexOfShortWithStartIndex() {\n+        short[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 2));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, (short) 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, (short) 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (short) 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (short) 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (short) 0, 6));\n+    }\n+\n+    public void testLastIndexOfShort() {\n+        short[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (short) 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99));\n+    }\n+\n+    public void testLastIndexOfShortWithStartIndex() {\n+        short[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 0, 2));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (short) 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (short) 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (short) 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (short) 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (short) 0, 88));\n+    }\n+\n+    public void testContainsShort() {\n+        short[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (short) 1));\n+        array = new short[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, (short) 0));\n+        assertEquals(true, ArrayUtils.contains(array, (short) 1));\n+        assertEquals(true, ArrayUtils.contains(array, (short) 2));\n+        assertEquals(true, ArrayUtils.contains(array, (short) 3));\n+        assertEquals(false, ArrayUtils.contains(array, (short) 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfChar() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(0, ArrayUtils.indexOf(array, 'a'));\n+        assertEquals(1, ArrayUtils.indexOf(array, 'b'));\n+        assertEquals(2, ArrayUtils.indexOf(array, 'c'));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd'));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'e'));\n+    }\n+\n+    public void testIndexOfCharWithStartIndex() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a', 2));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(4, ArrayUtils.indexOf(array, 'a', 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'b', 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, 'c', 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd', 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, 'd', -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'e', 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, 'a', 6));\n+    }\n+\n+    public void testLastIndexOfChar() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 'a'));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 'b'));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 'c'));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, 'd'));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e'));\n+    }\n+\n+    public void testLastIndexOfCharWithStartIndex() {\n+        char[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'a', 2));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, 'a', 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, 'b', 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, 'c', 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'd', -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, 'e'));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, 'a', 88));\n+    }\n+\n+    public void testContainsChar() {\n+        char[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, 'b'));\n+        array = new char[] { 'a', 'b', 'c', 'd', 'a' };\n+        assertEquals(true, ArrayUtils.contains(array, 'a'));\n+        assertEquals(true, ArrayUtils.contains(array, 'b'));\n+        assertEquals(true, ArrayUtils.contains(array, 'c'));\n+        assertEquals(true, ArrayUtils.contains(array, 'd'));\n+        assertEquals(false, ArrayUtils.contains(array, 'e'));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfByte() {\n+        byte[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (byte) 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (byte) 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, (byte) 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (byte) 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99));\n+    }\n+\n+    public void testIndexOfByteWithStartIndex() {\n+        byte[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 2));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, (byte) 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, (byte) 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (byte) 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (byte) 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (byte) 0, 6));\n+    }\n+\n+    public void testLastIndexOfByte() {\n+        byte[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 0));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (byte) 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (byte) 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (byte) 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (byte) 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 99));\n+    }\n+\n+    public void testLastIndexOfByteWithStartIndex() {\n+        byte[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 0, 2));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (byte) 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (byte) 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (byte) 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (byte) 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (byte) 0, 88));\n+    }\n+\n+    public void testContainsByte() {\n+        byte[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (byte) 1));\n+        array = new byte[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, (byte) 0));\n+        assertEquals(true, ArrayUtils.contains(array, (byte) 1));\n+        assertEquals(true, ArrayUtils.contains(array, (byte) 2));\n+        assertEquals(true, ArrayUtils.contains(array, (byte) 3));\n+        assertEquals(false, ArrayUtils.contains(array, (byte) 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfDouble() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (double) 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (double) 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, (double) 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 3));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 99));\n+    }\n+\n+    public void testIndexOfDoubleTolerance() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (double) 0, (double) 0.3));\n+        assertEquals(2, ArrayUtils.indexOf(array, (double) 2.2, (double) 0.35));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, (double) 2.0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, (double) 0.0001));\n+    }\n+\n+    public void testIndexOfDoubleWithStartIndex() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, (double) 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, (double) 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 3, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 6));\n+    }\n+    \n+    public void testIndexOfDoubleWithStartIndexTolerance() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 2, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, 99, (double) 0.3));\n+        assertEquals(0, ArrayUtils.indexOf(array, (double) 0, 0, (double) 0.3));\n+        assertEquals(4, ArrayUtils.indexOf(array, (double) 0, 3, (double) 0.3));\n+        assertEquals(2, ArrayUtils.indexOf(array, (double) 2.2, 0, (double) 0.35));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, 0, (double) 2.0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, 0, (double) 0.0001));\n+        assertEquals(3, ArrayUtils.indexOf(array, (double) 4.15, -1, (double) 2.0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (double) 1.00001324, -300, (double) 0.0001));\n+    }\n+\n+    public void testLastIndexOfDouble() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 99));\n+    }\n+\n+    public void testLastIndexOfDoubleTolerance() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, (double) 0.3));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2.2, (double) 0.35));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 4.15, (double) 2.0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1.00001324, (double) 0.0001));\n+    }\n+\n+    public void testLastIndexOfDoubleWithStartIndex() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (double) 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 88));\n+    }\n+\n+    public void testLastIndexOfDoubleWithStartIndexTolerance() {\n+        double[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2, (double) 0));\n+        array = new double[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 0, 2, (double) 0));\n+        array = new double[] { (double) 3 };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 1, 0, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (double) 0, 99, (double) 0.3));\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (double) 0, 3, (double) 0.3));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (double) 2.2, 3, (double) 0.35));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (double) 4.15, array.length, (double) 2.0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (double) 1.00001324, array.length, (double) 0.0001));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (double) 4.15, -200, (double) 2.0));\n+    }\n+\n+    public void testContainsDouble() {\n+        double[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (double) 1));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, (double) 0));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 1));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 2));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 3));\n+        assertEquals(false, ArrayUtils.contains(array, (double) 99));\n+    }\n+\n+    public void testContainsDoubleTolerance() {\n+        double[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (double) 1, (double) 0));\n+        array = new double[] { 0, 1, 2, 3, 0 };\n+        assertEquals(false, ArrayUtils.contains(array, (double) 4.0, (double) 0.33));\n+        assertEquals(false, ArrayUtils.contains(array, (double) 2.5, (double) 0.49));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 2.5, (double) 0.50));\n+        assertEquals(true, ArrayUtils.contains(array, (double) 2.5, (double) 0.51));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfFloat() {\n+        float[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0));\n+        array = new float[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.indexOf(array, (float) 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, (float) 1));\n+        assertEquals(2, ArrayUtils.indexOf(array, (float) 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (float) 3));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 99));\n+    }\n+\n+    public void testIndexOfFloatWithStartIndex() {\n+        float[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 2));\n+        array = new float[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 2));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.indexOf(array, (float) 0, 2));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 1, 2));\n+        assertEquals(2, ArrayUtils.indexOf(array, (float) 2, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (float) 3, 2));\n+        assertEquals(3, ArrayUtils.indexOf(array, (float) 3, -1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 99, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, (float) 0, 6));\n+    }\n+\n+    public void testLastIndexOfFloat() {\n+        float[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0));\n+        array = new float[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2));\n+        assertEquals(3, ArrayUtils.lastIndexOf(array, (float) 3));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99));\n+    }\n+\n+    public void testLastIndexOfFloatWithStartIndex() {\n+        float[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2));\n+        array = new float[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 0, 2));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, (float) 0, 2));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, (float) 1, 2));\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, (float) 2, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 3, -1));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, (float) 99));\n+        assertEquals(4, ArrayUtils.lastIndexOf(array, (float) 0, 88));\n+    }\n+\n+    public void testContainsFloat() {\n+        float[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, (float) 1));\n+        array = new float[] { 0, 1, 2, 3, 0 };\n+        assertEquals(true, ArrayUtils.contains(array, (float) 0));\n+        assertEquals(true, ArrayUtils.contains(array, (float) 1));\n+        assertEquals(true, ArrayUtils.contains(array, (float) 2));\n+        assertEquals(true, ArrayUtils.contains(array, (float) 3));\n+        assertEquals(false, ArrayUtils.contains(array, (float) 99));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIndexOfBoolean() {\n+        boolean[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, true));\n+        array = new boolean[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, true));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(0, ArrayUtils.indexOf(array, true));\n+        assertEquals(1, ArrayUtils.indexOf(array, false));\n+        array = new boolean[] { true, true };\n+        assertEquals(-1, ArrayUtils.indexOf(array, false));\n+    }\n+\n+    public void testIndexOfBooleanWithStartIndex() {\n+        boolean[] array = null;\n+        assertEquals(-1, ArrayUtils.indexOf(array, true, 2));\n+        array = new boolean[0];\n+        assertEquals(-1, ArrayUtils.indexOf(array, true, 2));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(2, ArrayUtils.indexOf(array, true, 1));\n+        assertEquals(-1, ArrayUtils.indexOf(array, false, 2));\n+        assertEquals(1, ArrayUtils.indexOf(array, false, 0));\n+        assertEquals(1, ArrayUtils.indexOf(array, false, -1));\n+        array = new boolean[] { true, true };\n+        assertEquals(-1, ArrayUtils.indexOf(array, false, 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, false, -1));\n+    }\n+\n+    public void testLastIndexOfBoolean() {\n+        boolean[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true));\n+        array = new boolean[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, true));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, false));\n+        array = new boolean[] { true, true };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, false));\n+    }\n+\n+    public void testLastIndexOfBooleanWithStartIndex() {\n+        boolean[] array = null;\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2));\n+        array = new boolean[0];\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true, 2));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(2, ArrayUtils.lastIndexOf(array, true, 2));\n+        assertEquals(0, ArrayUtils.lastIndexOf(array, true, 1));\n+        assertEquals(1, ArrayUtils.lastIndexOf(array, false, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true, -1));\n+        array = new boolean[] { true, true };\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, false, 2));\n+        assertEquals(-1, ArrayUtils.lastIndexOf(array, true, -1));\n+    }\n+\n+    public void testContainsBoolean() {\n+        boolean[] array = null;\n+        assertEquals(false, ArrayUtils.contains(array, true));\n+        array = new boolean[] { true, false, true };\n+        assertEquals(true, ArrayUtils.contains(array, true));\n+        assertEquals(true, ArrayUtils.contains(array, false));\n+        array = new boolean[] { true, true };\n+        assertEquals(true, ArrayUtils.contains(array, true));\n+        assertEquals(false, ArrayUtils.contains(array, false));\n+    }\n+    \n+    // testToPrimitive/Object for boolean\n+    //  -----------------------------------------------------------------------\n+    public void testToPrimitive_boolean() {\n+        final Boolean[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b));\n+        assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0]));\n+        assertTrue(Arrays.equals(\n+            new boolean[] {true, false, true},\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}))\n+        );\n+\n+        try {\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null});\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testToPrimitive_boolean_boolean() {\n+        assertEquals(null, ArrayUtils.toPrimitive(null, false));\n+        assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.toPrimitive(new Boolean[0], false));\n+        assertTrue(Arrays.equals(\n+            new boolean[] {true, false, true},\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE}, false))\n+        );\n+        assertTrue(Arrays.equals(\n+            new boolean[] {true, false, false},\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, false))\n+        );\n+        assertTrue(Arrays.equals(\n+            new boolean[] {true, true, false},\n+            ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null, Boolean.FALSE}, true))\n+        );\n+    }\n+\n+    public void testToObject_boolean() {\n+        final boolean[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+        assertSame(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.toObject(new boolean[0]));\n+        assertTrue(Arrays.equals(\n+            new Boolean[] {Boolean.TRUE, Boolean.FALSE, Boolean.TRUE},\n+            ArrayUtils.toObject(new boolean[] {true, false, true}))\n+        );\n+    }\n+\n+    // testToPrimitive/Object for byte\n+    //  -----------------------------------------------------------------------\n+    public void testToPrimitive_char() {\n+        final Character[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.toPrimitive(new Character[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'},\n+            ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), \n+                new Character(Character.MAX_VALUE), new Character('0')}))\n+        );\n+\n+        try {\n+            ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null});\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testToPrimitive_char_char() {\n+        final Character[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b, Character.MIN_VALUE));\n+        \n+        assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, \n+            ArrayUtils.toPrimitive(new Character[0], (char)0));\n+        \n+        assertTrue(Arrays.equals(\n+            new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'},\n+            ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), \n+                new Character(Character.MAX_VALUE), new Character('0')}, \n+                Character.MIN_VALUE))\n+        );\n+        \n+        assertTrue(Arrays.equals(\n+            new char[] {Character.MIN_VALUE, Character.MAX_VALUE, '0'},\n+            ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null, \n+                new Character('0')}, Character.MAX_VALUE))\n+        );\n+    }\n+\n+    public void testToObject_char() {\n+        final char[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, \n+            ArrayUtils.toObject(new char[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new Character[] {new Character(Character.MIN_VALUE), \n+                new Character(Character.MAX_VALUE), new Character('0')},\n+                ArrayUtils.toObject(new char[] {Character.MIN_VALUE, Character.MAX_VALUE, \n+                '0'} ))\n+        );\n+    }\n+    \n+    // testToPrimitive/Object for byte\n+    //  -----------------------------------------------------------------------\n+    public void testToPrimitive_byte() {\n+        final Byte[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.toPrimitive(new Byte[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999},\n+            ArrayUtils.toPrimitive(new Byte[] {new Byte(Byte.MIN_VALUE), \n+                new Byte(Byte.MAX_VALUE), new Byte((byte)9999999)}))\n+        );\n+\n+        try {\n+            ArrayUtils.toPrimitive(new Byte[] {new Byte(Byte.MIN_VALUE), null});\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testToPrimitive_byte_byte() {\n+        final Byte[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b, Byte.MIN_VALUE));\n+        \n+        assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, \n+            ArrayUtils.toPrimitive(new Byte[0], (byte)1));\n+        \n+        assertTrue(Arrays.equals(\n+            new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999},\n+            ArrayUtils.toPrimitive(new Byte[] {new Byte(Byte.MIN_VALUE), \n+                new Byte(Byte.MAX_VALUE), new Byte((byte)9999999)}, \n+                Byte.MIN_VALUE))\n+        );\n+        \n+        assertTrue(Arrays.equals(\n+            new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, (byte)9999999},\n+            ArrayUtils.toPrimitive(new Byte[] {new Byte(Byte.MIN_VALUE), null, \n+                new Byte((byte)9999999)}, Byte.MAX_VALUE))\n+        );\n+    }\n+\n+    public void testToObject_byte() {\n+        final byte[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, \n+            ArrayUtils.toObject(new byte[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new Byte[] {new Byte(Byte.MIN_VALUE), \n+                new Byte(Byte.MAX_VALUE), new Byte((byte)9999999)},\n+                ArrayUtils.toObject(new byte[] {Byte.MIN_VALUE, Byte.MAX_VALUE, \n+                (byte)9999999}))\n+        );\n+    }\n+\n+    // testToPrimitive/Object for short\n+    //  -----------------------------------------------------------------------\n+    public void testToPrimitive_short() {\n+        final Short[] b = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999},\n+            ArrayUtils.toPrimitive(new Short[] {new Short(Short.MIN_VALUE), \n+                new Short(Short.MAX_VALUE), new Short((short)9999999)}))\n+        );\n+\n+        try {\n+            ArrayUtils.toPrimitive(new Short[] {new Short(Short.MIN_VALUE), null});\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testToPrimitive_short_short() {\n+        final Short[] s = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(s, Short.MIN_VALUE));\n+        \n+        assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.toPrimitive(new Short[0], \n+        Short.MIN_VALUE));\n+        \n+        assertTrue(Arrays.equals(\n+            new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999},\n+            ArrayUtils.toPrimitive(new Short[] {new Short(Short.MIN_VALUE), \n+                new Short(Short.MAX_VALUE), new Short((short)9999999)}, Short.MIN_VALUE))\n+        );\n+        \n+        assertTrue(Arrays.equals(\n+            new short[] {Short.MIN_VALUE, Short.MAX_VALUE, (short)9999999},\n+            ArrayUtils.toPrimitive(new Short[] {new Short(Short.MIN_VALUE), null, \n+                new Short((short)9999999)}, Short.MAX_VALUE))\n+        );\n+    }\n+\n+    public void testToObject_short() {\n+        final short[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+        \n+        assertSame(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, \n+        ArrayUtils.toObject(new short[0]));\n+        \n+        assertTrue(Arrays.equals(\n+            new Short[] {new Short(Short.MIN_VALUE), new Short(Short.MAX_VALUE), \n+                new Short((short)9999999)},\n+            ArrayUtils.toObject(new short[] {Short.MIN_VALUE, Short.MAX_VALUE, \n+                (short)9999999}))\n+        );\n+    }\n+\n+    //  testToPrimitive/Object for int\n+    //  -----------------------------------------------------------------------\n+     public void testToPrimitive_int() {\n+         final Integer[] b = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(b));\n+         assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.toPrimitive(new Integer[0]));\n+         assertTrue(Arrays.equals(\n+             new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Integer[] {new Integer(Integer.MIN_VALUE), \n+                 new Integer(Integer.MAX_VALUE), new Integer(9999999)}))\n+         );\n+\n+         try {\n+             ArrayUtils.toPrimitive(new Integer[] {new Integer(Integer.MIN_VALUE), null});\n+             fail();\n+         } catch (NullPointerException ex) {}\n+     }\n+\n+     public void testToPrimitive_int_int() {\n+         final Long[] l = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(l, Integer.MIN_VALUE));\n+         assertSame(ArrayUtils.EMPTY_INT_ARRAY, \n+         ArrayUtils.toPrimitive(new Integer[0], 1));\n+         assertTrue(Arrays.equals(\n+             new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Integer[] {new Integer(Integer.MIN_VALUE), \n+                 new Integer(Integer.MAX_VALUE), new Integer(9999999)},1)));\n+         assertTrue(Arrays.equals(\n+             new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Integer[] {new Integer(Integer.MIN_VALUE), \n+                 null, new Integer(9999999)}, Integer.MAX_VALUE))\n+         );\n+     }\n+     \n+    public void testToPrimitive_intNull() {\n+        Integer[] iArray = null;\n+        assertEquals(null, ArrayUtils.toPrimitive(iArray, Integer.MIN_VALUE));\n+    }\n+\n+    public void testToObject_int() {\n+        final int[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+    \n+        assertSame(\n+            ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY,\n+            ArrayUtils.toObject(new int[0]));\n+    \n+        assertTrue(\n+            Arrays.equals(\n+                new Integer[] {\n+                    new Integer(Integer.MIN_VALUE),\n+                    new Integer(Integer.MAX_VALUE),\n+                    new Integer(9999999)},\n+            ArrayUtils.toObject(\n+                new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 9999999 })));\n+    }\n+\n+    //  testToPrimitive/Object for long\n+    //  -----------------------------------------------------------------------\n+     public void testToPrimitive_long() {\n+         final Long[] b = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(b));\n+         \n+         assertSame(ArrayUtils.EMPTY_LONG_ARRAY, \n+            ArrayUtils.toPrimitive(new Long[0]));\n+         \n+         assertTrue(Arrays.equals(\n+             new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Long[] {new Long(Long.MIN_VALUE), \n+                 new Long(Long.MAX_VALUE), new Long(9999999)}))\n+         );\n+\n+         try {\n+             ArrayUtils.toPrimitive(new Long[] {new Long(Long.MIN_VALUE), null});\n+             fail();\n+         } catch (NullPointerException ex) {}\n+     }\n+\n+     public void testToPrimitive_long_long() {\n+         final Long[] l = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(l, Long.MIN_VALUE));\n+         \n+         assertSame(ArrayUtils.EMPTY_LONG_ARRAY, \n+         ArrayUtils.toPrimitive(new Long[0], 1));\n+         \n+         assertTrue(Arrays.equals(\n+             new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Long[] {new Long(Long.MIN_VALUE), \n+                 new Long(Long.MAX_VALUE), new Long(9999999)},1)));\n+         \n+         assertTrue(Arrays.equals(\n+             new long[] {Long.MIN_VALUE, Long.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Long[] {new Long(Long.MIN_VALUE), \n+                 null, new Long(9999999)}, Long.MAX_VALUE))\n+         );\n+     }\n+     \n+    public void testToObject_long() {\n+        final long[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+    \n+        assertSame(\n+            ArrayUtils.EMPTY_LONG_OBJECT_ARRAY,\n+            ArrayUtils.toObject(new long[0]));\n+    \n+        assertTrue(\n+            Arrays.equals(\n+                new Long[] {\n+                    new Long(Long.MIN_VALUE),\n+                    new Long(Long.MAX_VALUE),\n+                    new Long(9999999)},\n+            ArrayUtils.toObject(\n+                new long[] { Long.MIN_VALUE, Long.MAX_VALUE, 9999999 })));\n+    }\n+\n+    //  testToPrimitive/Object for float\n+    //  -----------------------------------------------------------------------\n+     public void testToPrimitive_float() {\n+         final Float[] b = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(b));\n+         \n+         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, \n+            ArrayUtils.toPrimitive(new Float[0]));\n+         \n+         assertTrue(Arrays.equals(\n+             new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), \n+                 new Float(Float.MAX_VALUE), new Float(9999999)}))\n+         );\n+\n+         try {\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), null});\n+             fail();\n+         } catch (NullPointerException ex) {}\n+     }\n+\n+     public void testToPrimitive_float_float() {\n+         final Float[] l = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(l, Float.MIN_VALUE));\n+         \n+         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, \n+         ArrayUtils.toPrimitive(new Float[0], 1));\n+         \n+         assertTrue(Arrays.equals(\n+             new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), \n+                 new Float(Float.MAX_VALUE), new Float(9999999)},1)));\n+         \n+         assertTrue(Arrays.equals(\n+             new float[] {Float.MIN_VALUE, Float.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), \n+                 null, new Float(9999999)}, Float.MAX_VALUE))\n+         );\n+     }\n+     \n+    public void testToObject_float() {\n+        final float[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+    \n+        assertSame(\n+            ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY,\n+            ArrayUtils.toObject(new float[0]));\n+    \n+        assertTrue(\n+            Arrays.equals(\n+                new Float[] {\n+                    new Float(Float.MIN_VALUE),\n+                    new Float(Float.MAX_VALUE),\n+                    new Float(9999999)},\n+            ArrayUtils.toObject(\n+                new float[] { Float.MIN_VALUE, Float.MAX_VALUE, 9999999 })));\n+    }\n+\n+    //  testToPrimitive/Object for double\n+    //  -----------------------------------------------------------------------\n+     public void testToPrimitive_double() {\n+         final Double[] b = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(b));\n+         \n+         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, \n+            ArrayUtils.toPrimitive(new Double[0]));\n+         \n+         assertTrue(Arrays.equals(\n+             new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Double[] {new Double(Double.MIN_VALUE), \n+                 new Double(Double.MAX_VALUE), new Double(9999999)}))\n+         );\n+\n+         try {\n+             ArrayUtils.toPrimitive(new Float[] {new Float(Float.MIN_VALUE), null});\n+             fail();\n+         } catch (NullPointerException ex) {}\n+     }\n+\n+     public void testToPrimitive_double_double() {\n+         final Double[] l = null;\n+         assertEquals(null, ArrayUtils.toPrimitive(l, Double.MIN_VALUE));\n+         \n+         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, \n+         ArrayUtils.toPrimitive(new Double[0], 1));\n+         \n+         assertTrue(Arrays.equals(\n+             new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Double[] {new Double(Double.MIN_VALUE), \n+                 new Double(Double.MAX_VALUE), new Double(9999999)},1)));\n+         \n+         assertTrue(Arrays.equals(\n+             new double[] {Double.MIN_VALUE, Double.MAX_VALUE, 9999999},\n+             ArrayUtils.toPrimitive(new Double[] {new Double(Double.MIN_VALUE), \n+                 null, new Double(9999999)}, Double.MAX_VALUE))\n+         );\n+     }\n+     \n+    public void testToObject_double() {\n+        final double[] b = null;\n+        assertEquals(null, ArrayUtils.toObject(b));\n+    \n+        assertSame(\n+            ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY,\n+            ArrayUtils.toObject(new double[0]));\n+    \n+        assertTrue(\n+            Arrays.equals(\n+                new Double[] {\n+                    new Double(Double.MIN_VALUE),\n+                    new Double(Double.MAX_VALUE),\n+                    new Double(9999999)},\n+            ArrayUtils.toObject(\n+                new double[] { Double.MIN_VALUE, Double.MAX_VALUE, 9999999 })));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test for {@link ArrayUtils#isEmpty(java.lang.Object[])}.\n+     */\n+    public void testIsEmptyObject() {\n+        Object[] emptyArray = new Object[] {};\n+        Object[] notEmptyArray = new Object[] { new String(\"Value\") };\n+        assertEquals(true, ArrayUtils.isEmpty((Object[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyArray));\n+    }\n+\n+    /**\n+     * Tests for {@link ArrayUtils#isEmpty(long[])},\n+     * {@link ArrayUtils#isEmpty(int[])},\n+     * {@link ArrayUtils#isEmpty(short[])},\n+     * {@link ArrayUtils#isEmpty(char[])},\n+     * {@link ArrayUtils#isEmpty(byte[])},\n+     * {@link ArrayUtils#isEmpty(double[])},\n+     * {@link ArrayUtils#isEmpty(float[])} and\n+     * {@link ArrayUtils#isEmpty(boolean[])}.\n+     */\n+    public void testIsEmptyPrimitives() {\n+        long[] emptyLongArray = new long[] {};\n+        long[] notEmptyLongArray = new long[] { 1L };\n+        assertEquals(true, ArrayUtils.isEmpty((long[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyLongArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyLongArray));\n+\n+        int[] emptyIntArray = new int[] {};\n+        int[] notEmptyIntArray = new int[] { 1 };\n+        assertEquals(true, ArrayUtils.isEmpty((int[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyIntArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyIntArray));\n+\n+        short[] emptyShortArray = new short[] {};\n+        short[] notEmptyShortArray = new short[] { 1 };\n+        assertEquals(true, ArrayUtils.isEmpty((short[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyShortArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyShortArray));\n+\n+        char[] emptyCharArray = new char[] {};\n+        char[] notEmptyCharArray = new char[] { 1 };\n+        assertEquals(true, ArrayUtils.isEmpty((char[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyCharArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyCharArray));\n+\n+        byte[] emptyByteArray = new byte[] {};\n+        byte[] notEmptyByteArray = new byte[] { 1 };\n+        assertEquals(true, ArrayUtils.isEmpty((byte[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyByteArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyByteArray));\n+\n+        double[] emptyDoubleArray = new double[] {};\n+        double[] notEmptyDoubleArray = new double[] { 1.0 };\n+        assertEquals(true, ArrayUtils.isEmpty((double[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyDoubleArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyDoubleArray));\n+\n+        float[] emptyFloatArray = new float[] {};\n+        float[] notEmptyFloatArray = new float[] { 1.0F };\n+        assertEquals(true, ArrayUtils.isEmpty((float[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyFloatArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyFloatArray));\n+\n+        boolean[] emptyBooleanArray = new boolean[] {};\n+        boolean[] notEmptyBooleanArray = new boolean[] { true };\n+        assertEquals(true, ArrayUtils.isEmpty((boolean[])null));\n+        assertEquals(true, ArrayUtils.isEmpty(emptyBooleanArray));\n+        assertEquals(false, ArrayUtils.isEmpty(notEmptyBooleanArray));\n+    }\n+    \n+    // ------------------------------------------------------------------------\n+    public void testGetLength() {\n+        assertEquals(0, ArrayUtils.getLength(null));\n+        \n+        Object[] emptyObjectArray = new Object[0];\n+        Object[] notEmptyObjectArray = new Object[] {\"aValue\"};\n+        assertEquals(0, ArrayUtils.getLength((Object[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyObjectArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyObjectArray));\n+ \n+        int[] emptyIntArray = new int[] {};\n+        int[] notEmptyIntArray = new int[] { 1 };\n+        assertEquals(0, ArrayUtils.getLength((int[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyIntArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyIntArray));\n+\n+        short[] emptyShortArray = new short[] {};\n+        short[] notEmptyShortArray = new short[] { 1 };\n+        assertEquals(0, ArrayUtils.getLength((short[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyShortArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyShortArray));\n+\n+        char[] emptyCharArray = new char[] {};\n+        char[] notEmptyCharArray = new char[] { 1 };\n+        assertEquals(0, ArrayUtils.getLength((char[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyCharArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyCharArray));\n+\n+        byte[] emptyByteArray = new byte[] {};\n+        byte[] notEmptyByteArray = new byte[] { 1 };\n+        assertEquals(0, ArrayUtils.getLength((byte[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyByteArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyByteArray));\n+\n+        double[] emptyDoubleArray = new double[] {};\n+        double[] notEmptyDoubleArray = new double[] { 1.0 };\n+        assertEquals(0, ArrayUtils.getLength((double[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyDoubleArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyDoubleArray));\n+\n+        float[] emptyFloatArray = new float[] {};\n+        float[] notEmptyFloatArray = new float[] { 1.0F };\n+        assertEquals(0, ArrayUtils.getLength((float[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyFloatArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyFloatArray));\n+\n+        boolean[] emptyBooleanArray = new boolean[] {};\n+        boolean[] notEmptyBooleanArray = new boolean[] { true };\n+        assertEquals(0, ArrayUtils.getLength((boolean[]) null));\n+        assertEquals(0, ArrayUtils.getLength(emptyBooleanArray));\n+        assertEquals(1, ArrayUtils.getLength(notEmptyBooleanArray));\n+        \n+        try {\n+            ArrayUtils.getLength(\"notAnArray\");\n+            fail(\"IllegalArgumentException should have been thrown\");\n+        } catch (IllegalArgumentException e) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/BitFieldTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Class to test BitField functionality\n+ *\n+ * @author Scott Sanders\n+ * @author Marc Johnson\n+ * @author Glen Stampoultzis\n+ * @version $Id$\n+ */\n+public class BitFieldTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BitFieldTest.class);\n+        suite.setName(\"BitField Tests\");\n+        return suite;\n+    }\n+\n+    private static BitField bf_multi  = new BitField(0x3F80);\n+    private static BitField bf_single = new BitField(0x4000);\n+    private static BitField bf_zero = new BitField(0);\n+\n+    /**\n+     * Constructor BitFieldTest\n+     *\n+     * @param name\n+     */\n+    public BitFieldTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * test the getValue() method\n+     */\n+    public void testGetValue() {\n+        assertEquals(bf_multi.getValue(-1), 127);\n+        assertEquals(bf_multi.getValue(0), 0);\n+        assertEquals(bf_single.getValue(-1), 1);\n+        assertEquals(bf_single.getValue(0), 0);\n+        assertEquals(bf_zero.getValue(-1), 0);\n+        assertEquals(bf_zero.getValue(0), 0);\n+    }\n+\n+    /**\n+     * test the getShortValue() method\n+     */\n+    public void testGetShortValue() {\n+        assertEquals(bf_multi.getShortValue((short) - 1), (short) 127);\n+        assertEquals(bf_multi.getShortValue((short) 0), (short) 0);\n+        assertEquals(bf_single.getShortValue((short) - 1), (short) 1);\n+        assertEquals(bf_single.getShortValue((short) 0), (short) 0);\n+        assertEquals(bf_zero.getShortValue((short) -1), (short) 0);\n+        assertEquals(bf_zero.getShortValue((short) 0), (short) 0);\n+    }\n+\n+    /**\n+     * test the getRawValue() method\n+     */\n+    public void testGetRawValue() {\n+        assertEquals(bf_multi.getRawValue(-1), 0x3F80);\n+        assertEquals(bf_multi.getRawValue(0), 0);\n+        assertEquals(bf_single.getRawValue(-1), 0x4000);\n+        assertEquals(bf_single.getRawValue(0), 0);\n+        assertEquals(bf_zero.getRawValue(-1), 0);\n+        assertEquals(bf_zero.getRawValue(0), 0);\n+    }\n+\n+    /**\n+     * test the getShortRawValue() method\n+     */\n+    public void testGetShortRawValue() {\n+        assertEquals(bf_multi.getShortRawValue((short) - 1), (short) 0x3F80);\n+        assertEquals(bf_multi.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(bf_single.getShortRawValue((short) - 1), (short) 0x4000);\n+        assertEquals(bf_single.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(bf_zero.getShortRawValue((short) -1), (short) 0);\n+        assertEquals(bf_zero.getShortRawValue((short) 0), (short) 0);\n+    }\n+\n+    /**\n+     * test the isSet() method\n+     */\n+    public void testIsSet() {\n+        assertTrue(!bf_multi.isSet(0));\n+        assertTrue(!bf_zero.isSet(0));\n+        for (int j = 0x80; j <= 0x3F80; j += 0x80) {\n+            assertTrue(bf_multi.isSet(j));\n+        }\n+        for (int j = 0x80; j <= 0x3F80; j += 0x80) {\n+            assertTrue(!bf_zero.isSet(j));\n+        }\n+        assertTrue(!bf_single.isSet(0));\n+        assertTrue(bf_single.isSet(0x4000));\n+    }\n+\n+    /**\n+     * test the isAllSet() method\n+     */\n+    public void testIsAllSet() {\n+        for (int j = 0; j < 0x3F80; j += 0x80) {\n+            assertTrue(!bf_multi.isAllSet(j));\n+            assertTrue(bf_zero.isAllSet(j));\n+        }\n+        assertTrue(bf_multi.isAllSet(0x3F80));\n+        assertTrue(!bf_single.isAllSet(0));\n+        assertTrue(bf_single.isAllSet(0x4000));\n+    }\n+\n+    /**\n+     * test the setValue() method\n+     */\n+    public void testSetValue() {\n+        for (int j = 0; j < 128; j++) {\n+            assertEquals(bf_multi.getValue(bf_multi.setValue(0, j)), j);\n+            assertEquals(bf_multi.setValue(0, j), j << 7);\n+        }\n+        for (int j = 0; j < 128; j++) {\n+          assertEquals(bf_zero.getValue(bf_zero.setValue(0, j)), 0);\n+          assertEquals(bf_zero.setValue(0, j), 0);\n+      }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_multi.setValue(0x3f80, 128), 0);\n+        for (int j = 0; j < 2; j++) {\n+            assertEquals(bf_single.getValue(bf_single.setValue(0, j)), j);\n+            assertEquals(bf_single.setValue(0, j), j << 14);\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_single.setValue(0x4000, 2), 0);\n+    }\n+\n+    /**\n+     * test the setShortValue() method\n+     */\n+    public void testSetShortValue() {\n+        for (int j = 0; j < 128; j++) {\n+            assertEquals(bf_multi.getShortValue(bf_multi.setShortValue((short) 0, (short) j)), (short) j);\n+            assertEquals(bf_multi.setShortValue((short) 0, (short) j), (short) (j << 7));\n+        }\n+        for (int j = 0; j < 128; j++) {\n+            assertEquals(bf_zero.getShortValue(bf_zero.setShortValue((short) 0, (short) j)), (short) 0);\n+            assertEquals(bf_zero.setShortValue((short) 0, (short) j), (short) (0));\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_multi.setShortValue((short) 0x3f80, (short) 128), (short) 0);\n+        for (int j = 0; j < 2; j++) {\n+            assertEquals(bf_single.getShortValue(bf_single.setShortValue((short) 0, (short) j)), (short) j);\n+            assertEquals(bf_single.setShortValue((short) 0, (short) j), (short) (j << 14));\n+        }\n+\n+        // verify that excess bits are stripped off\n+        assertEquals(bf_single.setShortValue((short) 0x4000, (short) 2), (short) 0);\n+    }\n+\n+    public void testByte() {\n+        assertEquals(0, new BitField(0).setByteBoolean((byte) 0, true));\n+        assertEquals(1, new BitField(1).setByteBoolean((byte) 0, true));\n+        assertEquals(2, new BitField(2).setByteBoolean((byte) 0, true));\n+        assertEquals(4, new BitField(4).setByteBoolean((byte) 0, true));\n+        assertEquals(8, new BitField(8).setByteBoolean((byte) 0, true));\n+        assertEquals(16, new BitField(16).setByteBoolean((byte) 0, true));\n+        assertEquals(32, new BitField(32).setByteBoolean((byte) 0, true));\n+        assertEquals(64, new BitField(64).setByteBoolean((byte) 0, true));\n+        assertEquals(-128, new BitField(128).setByteBoolean((byte) 0, true));\n+        assertEquals(1, new BitField(0).setByteBoolean((byte) 1, false));\n+        assertEquals(0, new BitField(1).setByteBoolean((byte) 1, false));\n+        assertEquals(0, new BitField(2).setByteBoolean((byte) 2, false));\n+        assertEquals(0, new BitField(4).setByteBoolean((byte) 4, false));\n+        assertEquals(0, new BitField(8).setByteBoolean((byte) 8, false));\n+        assertEquals(0, new BitField(16).setByteBoolean((byte) 16, false));\n+        assertEquals(0, new BitField(32).setByteBoolean((byte) 32, false));\n+        assertEquals(0, new BitField(64).setByteBoolean((byte) 64, false));\n+        assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false));\n+        assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false));\n+        byte clearedBit = new BitField(0x40).setByteBoolean((byte) - 63, false);\n+\n+        assertEquals(false, new BitField(0x40).isSet(clearedBit));\n+    }\n+\n+    /**\n+     * test the clear() method\n+     */\n+    public void testClear() {\n+        assertEquals(bf_multi.clear(-1), 0xFFFFC07F);\n+        assertEquals(bf_single.clear(-1), 0xFFFFBFFF);\n+        assertEquals(bf_zero.clear(-1), 0xFFFFFFFF);\n+    }\n+\n+    /**\n+     * test the clearShort() method\n+     */\n+    public void testClearShort() {\n+        assertEquals(bf_multi.clearShort((short) - 1), (short) 0xC07F);\n+        assertEquals(bf_single.clearShort((short) - 1), (short) 0xBFFF);\n+        assertEquals(bf_zero.clearShort((short) -1), (short) 0xFFFF);\n+    }\n+\n+    /**\n+     * test the set() method\n+     */\n+    public void testSet() {\n+        assertEquals(bf_multi.set(0), 0x3F80);\n+        assertEquals(bf_single.set(0), 0x4000);\n+        assertEquals(bf_zero.set(0), 0);\n+    }\n+\n+    /**\n+     * test the setShort() method\n+     */\n+    public void testSetShort() {\n+        assertEquals(bf_multi.setShort((short) 0), (short) 0x3F80);\n+        assertEquals(bf_single.setShort((short) 0), (short) 0x4000);\n+        assertEquals(bf_zero.setShort((short) 0), (short) 0);\n+    }\n+\n+    /**\n+     * test the setBoolean() method\n+     */\n+    public void testSetBoolean() {\n+        assertEquals(bf_multi.set(0), bf_multi.setBoolean(0, true));\n+        assertEquals(bf_single.set(0), bf_single.setBoolean(0, true));\n+        assertEquals(bf_zero.set(0), bf_zero.setBoolean(0, true));\n+        assertEquals(bf_multi.clear(-1), bf_multi.setBoolean(-1, false));\n+        assertEquals(bf_single.clear(-1), bf_single.setBoolean(-1, false));\n+        assertEquals(bf_zero.clear(-1), bf_zero.setBoolean(-1, false));\n+    }\n+\n+    /**\n+     * test the setShortBoolean() method\n+     */\n+    public void testSetShortBoolean() {\n+        assertEquals(bf_multi.setShort((short) 0), bf_multi.setShortBoolean((short) 0, true));\n+        assertEquals(bf_single.setShort((short) 0), bf_single.setShortBoolean((short) 0, true));\n+        assertEquals(bf_zero.setShort((short) 0), bf_zero.setShortBoolean((short) 0, true));\n+        assertEquals(bf_multi.clearShort((short) - 1), bf_multi.setShortBoolean((short) - 1, false));\n+        assertEquals(bf_single.clearShort((short) - 1), bf_single.setShortBoolean((short) - 1, false));\n+        assertEquals(bf_zero.clearShort((short) -1), bf_zero.setShortBoolean((short) -1, false));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/BooleanUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.BooleanUtils}.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matthew Hawthorne\n+ * @version $Id$\n+ */\n+public class BooleanUtilsTest extends TestCase {\n+\n+    public BooleanUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BooleanUtilsTest.class);\n+        suite.setName(\"BooleanUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new BooleanUtils());\n+        Constructor[] cons = BooleanUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(BooleanUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(BooleanUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_negate_Boolean() {\n+        assertSame(null, BooleanUtils.negate(null));\n+        assertSame(Boolean.TRUE, BooleanUtils.negate(Boolean.FALSE));\n+        assertSame(Boolean.FALSE, BooleanUtils.negate(Boolean.TRUE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_isTrue_Boolean() {\n+        assertEquals(true, BooleanUtils.isTrue(Boolean.TRUE));\n+        assertEquals(false, BooleanUtils.isTrue(Boolean.FALSE));\n+        assertEquals(false, BooleanUtils.isTrue((Boolean) null));\n+    }\n+\n+    public void test_isFalse_Boolean() {\n+        assertEquals(false, BooleanUtils.isFalse(Boolean.TRUE));\n+        assertEquals(true, BooleanUtils.isFalse(Boolean.FALSE));\n+        assertEquals(false, BooleanUtils.isFalse((Boolean) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_toBooleanObject_boolean() {\n+        assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject(true));\n+        assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject(false));\n+    }\n+\n+    public void test_toBoolean_Boolean() {\n+        assertEquals(true, BooleanUtils.toBoolean(Boolean.TRUE));\n+        assertEquals(false, BooleanUtils.toBoolean(Boolean.FALSE));\n+        assertEquals(false, BooleanUtils.toBoolean((Boolean) null));\n+    }\n+\n+    public void test_toBooleanDefaultIfNull_Boolean_boolean() {\n+        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, true));\n+        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false));\n+        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true));\n+        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, false));\n+        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull((Boolean) null, true));\n+        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull((Boolean) null, false));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void test_toBoolean_int() {\n+        assertEquals(true, BooleanUtils.toBoolean(1));\n+        assertEquals(true, BooleanUtils.toBoolean(-1));\n+        assertEquals(false, BooleanUtils.toBoolean(0));\n+    }\n+    \n+    public void test_toBooleanObject_int() {\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(1));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(-1));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(0));\n+    }\n+    \n+    public void test_toBooleanObject_Integer() {\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(1)));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(-1)));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(new Integer(0)));\n+        assertEquals(null, BooleanUtils.toBooleanObject((Integer) null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toBoolean_int_int_int() {\n+        assertEquals(true, BooleanUtils.toBoolean(6, 6, 7));\n+        assertEquals(false, BooleanUtils.toBoolean(7, 6, 7));\n+        try {\n+            BooleanUtils.toBoolean(8, 6, 7);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void test_toBoolean_Integer_Integer_Integer() {\n+        Integer six = new Integer(6);\n+        Integer seven = new Integer(7);\n+\n+        assertEquals(true, BooleanUtils.toBoolean((Integer) null, null, seven));\n+        assertEquals(false, BooleanUtils.toBoolean((Integer) null, six, null));\n+        try {\n+            BooleanUtils.toBoolean(null, six, seven);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(true, BooleanUtils.toBoolean(new Integer(6), six, seven));\n+        assertEquals(false, BooleanUtils.toBoolean(new Integer(7), six, seven));\n+        try {\n+            BooleanUtils.toBoolean(new Integer(8), six, seven);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toBooleanObject_int_int_int() {\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(6, 6, 7, 8));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(7, 6, 7, 8));\n+        assertEquals(null, BooleanUtils.toBooleanObject(8, 6, 7, 8));\n+        try {\n+            BooleanUtils.toBooleanObject(9, 6, 7, 8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void test_toBooleanObject_Integer_Integer_Integer_Integer() {\n+        Integer six = new Integer(6);\n+        Integer seven = new Integer(7);\n+        Integer eight = new Integer(8);\n+\n+        assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject((Integer) null, null, seven, eight));\n+        assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject((Integer) null, six, null, eight));\n+        assertSame(null, BooleanUtils.toBooleanObject((Integer) null, six, seven, null));\n+        try {\n+            BooleanUtils.toBooleanObject(null, six, seven, eight);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(6), six, seven, eight));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(new Integer(7), six, seven, eight));\n+        assertEquals(null, BooleanUtils.toBooleanObject(new Integer(8), six, seven, eight));\n+        try {\n+            BooleanUtils.toBooleanObject(new Integer(9), six, seven, eight);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toInteger_boolean() {\n+        assertEquals(1, BooleanUtils.toInteger(true));\n+        assertEquals(0, BooleanUtils.toInteger(false));\n+    }\n+    \n+    public void test_toIntegerObject_boolean() {\n+        assertEquals(new Integer(1), BooleanUtils.toIntegerObject(true));\n+        assertEquals(new Integer(0), BooleanUtils.toIntegerObject(false));\n+    }\n+    \n+    public void test_toIntegerObject_Boolean() {\n+        assertEquals(new Integer(1), BooleanUtils.toIntegerObject(Boolean.TRUE));\n+        assertEquals(new Integer(0), BooleanUtils.toIntegerObject(Boolean.FALSE));\n+        assertEquals(null, BooleanUtils.toIntegerObject((Boolean) null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toInteger_boolean_int_int() {\n+        assertEquals(6, BooleanUtils.toInteger(true, 6, 7));\n+        assertEquals(7, BooleanUtils.toInteger(false, 6, 7));\n+    }\n+    \n+    public void test_toInteger_Boolean_int_int_int() {\n+        assertEquals(6, BooleanUtils.toInteger(Boolean.TRUE, 6, 7, 8));\n+        assertEquals(7, BooleanUtils.toInteger(Boolean.FALSE, 6, 7, 8));\n+        assertEquals(8, BooleanUtils.toInteger(null, 6, 7, 8));\n+    }\n+    \n+    public void test_toIntegerObject_boolean_Integer_Integer() {\n+        Integer six = new Integer(6);\n+        Integer seven = new Integer(7);\n+        assertEquals(six, BooleanUtils.toIntegerObject(true, six, seven));\n+        assertEquals(seven, BooleanUtils.toIntegerObject(false, six, seven));\n+    }\n+    \n+    public void test_toIntegerObject_Boolean_Integer_Integer_Integer() {\n+        Integer six = new Integer(6);\n+        Integer seven = new Integer(7);\n+        Integer eight = new Integer(8);\n+        assertEquals(six, BooleanUtils.toIntegerObject(Boolean.TRUE, six, seven, eight));\n+        assertEquals(seven, BooleanUtils.toIntegerObject(Boolean.FALSE, six, seven, eight));\n+        assertEquals(eight, BooleanUtils.toIntegerObject((Boolean) null, six, seven, eight));\n+        assertEquals(null, BooleanUtils.toIntegerObject((Boolean) null, six, seven, null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void test_toBooleanObject_String() {\n+        assertEquals(null, BooleanUtils.toBooleanObject((String) null));\n+        assertEquals(null, BooleanUtils.toBooleanObject(\"\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"false\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"no\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"off\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"FALSE\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"NO\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"OFF\"));\n+        assertEquals(null, BooleanUtils.toBooleanObject(\"oof\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"true\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"yes\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"on\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"TRUE\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"ON\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"YES\"));\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"TruE\"));\n+    }\n+    \n+    public void test_toBooleanObject_String_String_String_String() {\n+        assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject((String) null, null, \"N\", \"U\"));\n+        assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject((String) null, \"Y\", null, \"U\"));\n+        assertSame(null, BooleanUtils.toBooleanObject((String) null, \"Y\", \"N\", null));\n+        try {\n+            BooleanUtils.toBooleanObject((String) null, \"Y\", \"N\", \"U\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(\"Y\", \"Y\", \"N\", \"U\"));\n+        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(\"N\", \"Y\", \"N\", \"U\"));\n+        assertEquals(null, BooleanUtils.toBooleanObject(\"U\", \"Y\", \"N\", \"U\"));\n+        try {\n+            BooleanUtils.toBooleanObject(null, \"Y\", \"N\", \"U\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            BooleanUtils.toBooleanObject(\"X\", \"Y\", \"N\", \"U\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_toBoolean_String() {\n+        assertEquals(false, BooleanUtils.toBoolean((String) null));\n+        assertEquals(false, BooleanUtils.toBoolean(\"\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"off\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"oof\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"yep\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"trux\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"false\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"a\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"true\")); // interned handled differently\n+        assertEquals(true, BooleanUtils.toBoolean(new StringBuffer(\"tr\").append(\"ue\").toString()));\n+        assertEquals(true, BooleanUtils.toBoolean(\"truE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"trUe\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"trUE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"tRue\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"tRuE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"tRUe\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"tRUE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TRUE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TRUe\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TRuE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TRue\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TrUE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TrUe\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"TruE\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"True\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"on\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"oN\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"On\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"ON\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"yes\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"yeS\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"yEs\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"yES\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"Yes\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"YeS\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"YEs\"));\n+        assertEquals(true, BooleanUtils.toBoolean(\"YES\"));\n+    }\n+\n+    public void test_toBoolean_String_String_String() {\n+        assertEquals(true, BooleanUtils.toBoolean((String) null, null, \"N\"));\n+        assertEquals(false, BooleanUtils.toBoolean((String) null, \"Y\", null));\n+        try {\n+            BooleanUtils.toBooleanObject((String) null, \"Y\", \"N\", \"U\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(true, BooleanUtils.toBoolean(\"Y\", \"Y\", \"N\"));\n+        assertEquals(false, BooleanUtils.toBoolean(\"N\", \"Y\", \"N\"));\n+        try {\n+            BooleanUtils.toBoolean(null, \"Y\", \"N\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            BooleanUtils.toBoolean(\"X\", \"Y\", \"N\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void test_toStringTrueFalse_Boolean() {\n+        assertEquals(null, BooleanUtils.toStringTrueFalse((Boolean) null));\n+        assertEquals(\"true\", BooleanUtils.toStringTrueFalse(Boolean.TRUE));\n+        assertEquals(\"false\", BooleanUtils.toStringTrueFalse(Boolean.FALSE));\n+    }\n+    \n+    public void test_toStringOnOff_Boolean() {\n+        assertEquals(null, BooleanUtils.toStringOnOff((Boolean) null));\n+        assertEquals(\"on\", BooleanUtils.toStringOnOff(Boolean.TRUE));\n+        assertEquals(\"off\", BooleanUtils.toStringOnOff(Boolean.FALSE));\n+    }\n+    \n+    public void test_toStringYesNo_Boolean() {\n+        assertEquals(null, BooleanUtils.toStringYesNo((Boolean) null));\n+        assertEquals(\"yes\", BooleanUtils.toStringYesNo(Boolean.TRUE));\n+        assertEquals(\"no\", BooleanUtils.toStringYesNo(Boolean.FALSE));\n+    }\n+    \n+    public void test_toString_Boolean_String_String_String() {\n+        assertEquals(\"U\", BooleanUtils.toString((Boolean) null, \"Y\", \"N\", \"U\"));\n+        assertEquals(\"Y\", BooleanUtils.toString(Boolean.TRUE, \"Y\", \"N\", \"U\"));\n+        assertEquals(\"N\", BooleanUtils.toString(Boolean.FALSE, \"Y\", \"N\", \"U\"));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void test_toStringTrueFalse_boolean() {\n+        assertEquals(\"true\", BooleanUtils.toStringTrueFalse(true));\n+        assertEquals(\"false\", BooleanUtils.toStringTrueFalse(false));\n+    }\n+    \n+    public void test_toStringOnOff_boolean() {\n+        assertEquals(\"on\", BooleanUtils.toStringOnOff(true));\n+        assertEquals(\"off\", BooleanUtils.toStringOnOff(false));\n+    }\n+    \n+    public void test_toStringYesNo_boolean() {\n+        assertEquals(\"yes\", BooleanUtils.toStringYesNo(true));\n+        assertEquals(\"no\", BooleanUtils.toStringYesNo(false));\n+    }\n+    \n+    public void test_toString_boolean_String_String_String() {\n+        assertEquals(\"Y\", BooleanUtils.toString(true, \"Y\", \"N\"));\n+        assertEquals(\"N\", BooleanUtils.toString(false, \"Y\", \"N\"));\n+    }\n+    \n+    //  testXor\n+    //  -----------------------------------------------------------------------\n+    public void testXor_primitive_nullInput() {\n+        final boolean[] b = null;\n+        try {\n+            BooleanUtils.xor(b);\n+            fail(\"Exception was not thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testXor_primitive_emptyInput() {\n+        try {\n+            BooleanUtils.xor(new boolean[] {});\n+            fail(\"Exception was not thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testXor_primitive_validInput_2items() {\n+        assertTrue(\n+            \"True result for (true, true)\",\n+            ! BooleanUtils.xor(new boolean[] { true, true }));\n+\n+        assertTrue(\n+            \"True result for (false, false)\",\n+            ! BooleanUtils.xor(new boolean[] { false, false }));\n+\n+        assertTrue(\n+            \"False result for (true, false)\",\n+            BooleanUtils.xor(new boolean[] { true, false }));\n+\n+        assertTrue(\n+            \"False result for (false, true)\",\n+            BooleanUtils.xor(new boolean[] { false, true }));\n+    }\n+\n+    public void testXor_primitive_validInput_3items() {\n+        assertTrue(\n+            \"False result for (false, false, true)\",\n+            BooleanUtils.xor(new boolean[] { false, false, true }));\n+\n+        assertTrue(\n+            \"False result for (false, true, false)\",\n+            BooleanUtils.xor(new boolean[] { false, true, false }));\n+\n+        assertTrue(\n+            \"False result for (true, false, false)\",\n+            BooleanUtils.xor(new boolean[] { true, false, false }));\n+\n+        assertTrue(\n+            \"True result for (true, true, true)\",\n+            ! BooleanUtils.xor(new boolean[] { true, true, true }));\n+\n+        assertTrue(\n+            \"True result for (false, false)\",\n+            ! BooleanUtils.xor(new boolean[] { false, false, false }));\n+\n+        assertTrue(\n+            \"True result for (true, true, false)\",\n+            ! BooleanUtils.xor(new boolean[] { true, true, false }));\n+\n+        assertTrue(\n+            \"True result for (true, false, true)\",\n+            ! BooleanUtils.xor(new boolean[] { true, false, true }));\n+\n+        assertTrue(\n+            \"False result for (false, true, true)\",\n+            ! BooleanUtils.xor(new boolean[] { false, true, true }));\n+    }\n+\n+    public void testXor_object_nullInput() {\n+        final Boolean[] b = null;\n+        try {\n+            BooleanUtils.xor(b);\n+            fail(\"Exception was not thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testXor_object_emptyInput() {\n+        try {\n+            BooleanUtils.xor(new Boolean[] {});\n+            fail(\"Exception was not thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testXor_object_nullElementInput() {\n+        try {\n+            BooleanUtils.xor(new Boolean[] {null});\n+            fail(\"Exception was not thrown for null element input.\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testXor_object_validInput_2items() {\n+        assertTrue(\n+            \"True result for (true, true)\",\n+            ! BooleanUtils\n+                .xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (false, false)\",\n+            ! BooleanUtils\n+                .xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (true, false)\",\n+            BooleanUtils\n+                .xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (false, true)\",\n+            BooleanUtils\n+                .xor(new Boolean[] { Boolean.FALSE, Boolean.TRUE })\n+                .booleanValue());\n+    }\n+\n+    public void testXor_object_validInput_3items() {\n+        assertTrue(\n+            \"False result for (false, false, true)\",\n+            BooleanUtils\n+                .xor(\n+                    new Boolean[] {\n+                        Boolean.FALSE,\n+                        Boolean.FALSE,\n+                        Boolean.TRUE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (false, true, false)\",\n+            BooleanUtils\n+                .xor(\n+                    new Boolean[] {\n+                        Boolean.FALSE,\n+                        Boolean.TRUE,\n+                        Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (true, false, false)\",\n+            BooleanUtils\n+                .xor(\n+                    new Boolean[] {\n+                        Boolean.TRUE,\n+                        Boolean.FALSE,\n+                        Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (true, true, true)\",\n+            ! BooleanUtils\n+                .xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE, Boolean.TRUE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (false, false)\",\n+            ! BooleanUtils.xor(\n+                    new Boolean[] {\n+                        Boolean.FALSE,\n+                        Boolean.FALSE,\n+                        Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (true, true, false)\",\n+            ! BooleanUtils.xor(\n+                    new Boolean[] {\n+                        Boolean.TRUE,\n+                        Boolean.TRUE,\n+                        Boolean.FALSE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"True result for (true, false, true)\",\n+            ! BooleanUtils.xor(\n+                    new Boolean[] {\n+                        Boolean.TRUE,\n+                        Boolean.FALSE,\n+                        Boolean.TRUE })\n+                .booleanValue());\n+\n+        assertTrue(\n+            \"False result for (false, true, true)\",\n+            ! BooleanUtils.xor(\n+                    new Boolean[] {\n+                        Boolean.FALSE,\n+                        Boolean.TRUE,\n+                        Boolean.TRUE })\n+                .booleanValue());\n+                \n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/CharEncodingTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests CharEncoding.\n+ * \n+ * @see CharEncoding\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class CharEncodingTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharEncodingTest.class);\n+        suite.setName(\"CharEncoding Tests\");\n+        return suite;\n+    }\n+\n+    private void assertSupportedEncoding(String name) {\n+        assertTrue(\"Encoding should be supported: \" + name, CharEncoding.isSupported(name));\n+    }\n+\n+    /**\n+     * The class can be instantiated.\n+     */\n+    public void testConstructor() {\n+        new CharEncoding();\n+    }\n+\n+    public void testMustBeSupportedJava1_3_1() {\n+        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n+            this.assertSupportedEncoding(CharEncoding.ISO_8859_1);\n+            this.assertSupportedEncoding(CharEncoding.US_ASCII);\n+            this.assertSupportedEncoding(CharEncoding.UTF_16);\n+            this.assertSupportedEncoding(CharEncoding.UTF_16BE);\n+            this.assertSupportedEncoding(CharEncoding.UTF_16LE);\n+            this.assertSupportedEncoding(CharEncoding.UTF_8);\n+        } else {\n+            this.warn(\"Java 1.3 tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+    }\n+\n+    public void testNotSupported() {\n+        assertFalse(CharEncoding.isSupported(null));\n+        assertFalse(CharEncoding.isSupported(\"\"));\n+        assertFalse(CharEncoding.isSupported(\" \"));\n+        assertFalse(CharEncoding.isSupported(\"\\t\\r\\n\"));\n+        assertFalse(CharEncoding.isSupported(\"DOESNOTEXIST\"));\n+        assertFalse(CharEncoding.isSupported(\"this is not a valid encoding name\"));\n+    }\n+\n+    public void testWorksOnJava1_1_8() {\n+        //\n+        // In this test, I simply deleted the encodings from the 1.3.1 list.\n+        // The Javadoc do not specify which encodings are required.\n+        //\n+        if (SystemUtils.isJavaVersionAtLeast(1.1f)) {\n+            this.assertSupportedEncoding(CharEncoding.ISO_8859_1);\n+            this.assertSupportedEncoding(CharEncoding.US_ASCII);\n+            this.assertSupportedEncoding(CharEncoding.UTF_8);\n+        } else {\n+            this.warn(\"Java 1.1 tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+    }\n+\n+    public void testWorksOnJava1_2_2() {\n+        //\n+        // In this test, I simply deleted the encodings from the 1.3.1 list.\n+        // The Javadoc do not specify which encodings are required.\n+        //\n+        if (SystemUtils.isJavaVersionAtLeast(1.2f)) {\n+            this.assertSupportedEncoding(CharEncoding.ISO_8859_1);\n+            this.assertSupportedEncoding(CharEncoding.US_ASCII);\n+            this.assertSupportedEncoding(CharEncoding.UTF_8);\n+        } else {\n+            this.warn(\"Java 1.2 tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+    }\n+\n+    void warn(String msg) {\n+        System.err.println(msg);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/CharRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharRange}.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class CharRangeTest extends TestCase {\n+    \n+    public CharRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharRangeTest.class);\n+        suite.setName(\"CharRange Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClass() {\n+        assertEquals(true, Modifier.isPublic(CharRange.class.getModifiers()));\n+        assertEquals(true, Modifier.isFinal(CharRange.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testConstructorAccessors_Char() {\n+        CharRange rangea = new CharRange('a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharBoolean_Normal() {\n+        CharRange rangea = new CharRange('a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharBoolean_Negated() {\n+        CharRange rangea = new CharRange('a', true);\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(true, rangea.isNegated());\n+        assertEquals(\"^a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharChar_Same() {\n+        CharRange rangea = new CharRange('a', 'a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharChar_Normal() {\n+        CharRange rangea = new CharRange('a', 'e');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a-e\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharChar_Reversed() {\n+        CharRange rangea = new CharRange('e', 'a');\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a-e\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharCharBoolean_Same() {\n+        CharRange rangea = new CharRange('a', 'a', false);\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharCharBoolean_Normal() {\n+        CharRange rangea = new CharRange('a', 'e', false);\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a-e\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharCharBoolean_Reversed() {\n+        CharRange rangea = new CharRange('e', 'a', false);\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(false, rangea.isNegated());\n+        assertEquals(\"a-e\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharCharBoolean_SameNegated() {\n+        CharRange rangea = new CharRange('a', 'a', true);\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('a', rangea.getEnd());\n+        assertEquals(true, rangea.isNegated());\n+        assertEquals(\"^a\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharCharBoolean_NormalNegated() {\n+        CharRange rangea = new CharRange('a', 'e', true);\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(true, rangea.isNegated());\n+        assertEquals(\"^a-e\", rangea.toString());\n+    }\n+    \n+    public void testConstructorAccessors_CharCharBoolean_ReversedNegated() {\n+        CharRange rangea = new CharRange('e', 'a', true);\n+        assertEquals('a', rangea.getStart());\n+        assertEquals('e', rangea.getEnd());\n+        assertEquals(true, rangea.isNegated());\n+        assertEquals(\"^a-e\", rangea.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testEquals_Object() {\n+        CharRange rangea = new CharRange('a');\n+        CharRange rangeae = new CharRange('a', 'e');\n+        CharRange rangenotbf = new CharRange('b', 'f', false);\n+        \n+        assertEquals(false, rangea.equals(null));\n+        \n+        assertEquals(true, rangea.equals(rangea));\n+        assertEquals(true, rangea.equals(new CharRange('a')));\n+        assertEquals(true, rangeae.equals(rangeae));\n+        assertEquals(true, rangeae.equals(new CharRange('a', 'e')));\n+        assertEquals(true, rangenotbf.equals(rangenotbf));\n+        assertEquals(true, rangenotbf.equals(new CharRange('b', 'f', false)));\n+        \n+        assertEquals(false, rangea.equals(rangeae));\n+        assertEquals(false, rangea.equals(rangenotbf));\n+        assertEquals(false, rangeae.equals(rangea));\n+        assertEquals(false, rangeae.equals(rangenotbf));\n+        assertEquals(false, rangenotbf.equals(rangea));\n+        assertEquals(false, rangenotbf.equals(rangeae));\n+    }\n+            \n+    public void testHashCode() {\n+        CharRange rangea = new CharRange('a');\n+        CharRange rangeae = new CharRange('a', 'e');\n+        CharRange rangenotbf = new CharRange('b', 'f', false);\n+        \n+        assertEquals(true, rangea.hashCode() == rangea.hashCode());\n+        assertEquals(true, rangea.hashCode() == new CharRange('a').hashCode());\n+        assertEquals(true, rangeae.hashCode() == rangeae.hashCode());\n+        assertEquals(true, rangeae.hashCode() == new CharRange('a', 'e').hashCode());\n+        assertEquals(true, rangenotbf.hashCode() == rangenotbf.hashCode());\n+        assertEquals(true, rangenotbf.hashCode() == new CharRange('b', 'f', false).hashCode());\n+        \n+        assertEquals(false, rangea.hashCode() == rangeae.hashCode());\n+        assertEquals(false, rangea.hashCode() == rangenotbf.hashCode());\n+        assertEquals(false, rangeae.hashCode() == rangea.hashCode());\n+        assertEquals(false, rangeae.hashCode() == rangenotbf.hashCode());\n+        assertEquals(false, rangenotbf.hashCode() == rangea.hashCode());\n+        assertEquals(false, rangenotbf.hashCode() == rangeae.hashCode());\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testContains_Char() {\n+        CharRange range = new CharRange('c');\n+        assertEquals(false, range.contains('b'));\n+        assertEquals(true, range.contains('c'));\n+        assertEquals(false, range.contains('d'));\n+        assertEquals(false, range.contains('e'));\n+        \n+        range = new CharRange('c', 'd');\n+        assertEquals(false, range.contains('b'));\n+        assertEquals(true, range.contains('c'));\n+        assertEquals(true, range.contains('d'));\n+        assertEquals(false, range.contains('e'));\n+        \n+        range = new CharRange('d', 'c');\n+        assertEquals(false, range.contains('b'));\n+        assertEquals(true, range.contains('c'));\n+        assertEquals(true, range.contains('d'));\n+        assertEquals(false, range.contains('e'));\n+        \n+        range = new CharRange('c', 'd', false);\n+        assertEquals(false, range.contains('b'));\n+        assertEquals(true, range.contains('c'));\n+        assertEquals(true, range.contains('d'));\n+        assertEquals(false, range.contains('e'));\n+        \n+        range = new CharRange('c', 'd', true);\n+        assertEquals(true, range.contains('b'));\n+        assertEquals(false, range.contains('c'));\n+        assertEquals(false, range.contains('d'));\n+        assertEquals(true, range.contains('e'));\n+        assertEquals(true, range.contains((char) 0));\n+        assertEquals(true, range.contains(Character.MAX_VALUE));\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testContains_Charrange() {\n+        CharRange a = new CharRange('a');\n+        CharRange b = new CharRange('b');\n+        CharRange c = new CharRange('c');\n+        CharRange c2 = new CharRange('c');\n+        CharRange d = new CharRange('d');\n+        CharRange e = new CharRange('e');\n+        CharRange cd = new CharRange('c', 'd');\n+        CharRange bd = new CharRange('b', 'd');\n+        CharRange bc = new CharRange('b', 'c');\n+        CharRange ab = new CharRange('a', 'b');\n+        CharRange de = new CharRange('d', 'e');\n+        CharRange ef = new CharRange('e', 'f');\n+        CharRange ae = new CharRange('a', 'e');\n+        \n+        // normal/normal\n+        assertEquals(false, c.contains(b));\n+        assertEquals(true, c.contains(c));\n+        assertEquals(true, c.contains(c2));\n+        assertEquals(false, c.contains(d));\n+        \n+        assertEquals(false, c.contains(cd));\n+        assertEquals(false, c.contains(bd));\n+        assertEquals(false, c.contains(bc));\n+        assertEquals(false, c.contains(ab));\n+        assertEquals(false, c.contains(de));\n+        \n+        assertEquals(true, cd.contains(c));\n+        assertEquals(true, bd.contains(c));\n+        assertEquals(true, bc.contains(c));\n+        assertEquals(false, ab.contains(c));\n+        assertEquals(false, de.contains(c));\n+\n+        assertEquals(true, ae.contains(b));\n+        assertEquals(true, ae.contains(ab));\n+        assertEquals(true, ae.contains(bc));\n+        assertEquals(true, ae.contains(cd));\n+        assertEquals(true, ae.contains(de));\n+        \n+        CharRange notb = new CharRange('b', 'b', true);\n+        CharRange notc = new CharRange('c', 'c', true);\n+        CharRange notd = new CharRange('d', 'd', true);\n+        CharRange notab = new CharRange('a', 'b', true);\n+        CharRange notbc = new CharRange('b', 'c', true);\n+        CharRange notbd = new CharRange('b', 'd', true);\n+        CharRange notcd = new CharRange('c', 'd', true);\n+        CharRange notde = new CharRange('d', 'e', true);\n+        CharRange notae = new CharRange('a', 'e', true);\n+        CharRange all = new CharRange((char) 0, Character.MAX_VALUE);\n+        CharRange allbutfirst = new CharRange((char) 1, Character.MAX_VALUE);\n+        \n+        // normal/negated\n+        assertEquals(false, c.contains(notc));\n+        assertEquals(false, c.contains(notbd));\n+        assertEquals(true, all.contains(notc));\n+        assertEquals(true, all.contains(notbd));\n+        assertEquals(false, allbutfirst.contains(notc));\n+        assertEquals(false, allbutfirst.contains(notbd));\n+        \n+        // negated/normal\n+        assertEquals(true, notc.contains(a));\n+        assertEquals(true, notc.contains(b));\n+        assertEquals(false, notc.contains(c));\n+        assertEquals(true, notc.contains(d));\n+        assertEquals(true, notc.contains(e));\n+        \n+        assertEquals(true, notc.contains(ab));\n+        assertEquals(false, notc.contains(bc));\n+        assertEquals(false, notc.contains(bd));\n+        assertEquals(false, notc.contains(cd));\n+        assertEquals(true, notc.contains(de));\n+        assertEquals(false, notc.contains(ae));\n+        assertEquals(false, notc.contains(all));\n+        assertEquals(false, notc.contains(allbutfirst));\n+        \n+        assertEquals(true, notbd.contains(a));\n+        assertEquals(false, notbd.contains(b));\n+        assertEquals(false, notbd.contains(c));\n+        assertEquals(false, notbd.contains(d));\n+        assertEquals(true, notbd.contains(e));\n+        \n+        assertEquals(true, notcd.contains(ab));\n+        assertEquals(false, notcd.contains(bc));\n+        assertEquals(false, notcd.contains(bd));\n+        assertEquals(false, notcd.contains(cd));\n+        assertEquals(false, notcd.contains(de));\n+        assertEquals(false, notcd.contains(ae));\n+        assertEquals(true, notcd.contains(ef));\n+        assertEquals(false, notcd.contains(all));\n+        assertEquals(false, notcd.contains(allbutfirst));\n+        \n+        // negated/negated\n+        assertEquals(false, notc.contains(notb));\n+        assertEquals(true, notc.contains(notc));\n+        assertEquals(false, notc.contains(notd));\n+        \n+        assertEquals(false, notc.contains(notab));\n+        assertEquals(true, notc.contains(notbc));\n+        assertEquals(true, notc.contains(notbd));\n+        assertEquals(true, notc.contains(notcd));\n+        assertEquals(false, notc.contains(notde));\n+        \n+        assertEquals(false, notbd.contains(notb));\n+        assertEquals(false, notbd.contains(notc));\n+        assertEquals(false, notbd.contains(notd));\n+        \n+        assertEquals(false, notbd.contains(notab));\n+        assertEquals(false, notbd.contains(notbc));\n+        assertEquals(true, notbd.contains(notbd));\n+        assertEquals(false, notbd.contains(notcd));\n+        assertEquals(false, notbd.contains(notde));\n+        assertEquals(true, notbd.contains(notae));\n+    }\n+    \n+    public void testContainsNullArg() {\n+        CharRange range = new CharRange('a');\n+        try {\n+            boolean contains = range.contains(null);\n+        } catch(IllegalArgumentException e) {\n+            assertEquals(\"The Range must not be null\", e.getMessage());\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testSerialization() {\n+        CharRange range = new CharRange('a');\n+        assertEquals(range, SerializationUtils.clone(range)); \n+        range = new CharRange('a', 'e');\n+        assertEquals(range, SerializationUtils.clone(range)); \n+        range = new CharRange('a', 'e', true);\n+        assertEquals(range, SerializationUtils.clone(range)); \n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/CharSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharSet}.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public class CharSetTest extends TestCase {\n+    \n+    public CharSetTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharSetTest.class);\n+        suite.setName(\"CharSet Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClass() {\n+        assertEquals(true, Modifier.isPublic(CharSet.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(CharSet.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testGetInstance() {\n+        assertSame(CharSet.EMPTY, CharSet.getInstance(null));\n+        assertSame(CharSet.EMPTY, CharSet.getInstance(\"\"));\n+        assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"a-zA-Z\"));\n+        assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"A-Za-z\"));\n+        assertSame(CharSet.ASCII_ALPHA_LOWER, CharSet.getInstance(\"a-z\"));\n+        assertSame(CharSet.ASCII_ALPHA_UPPER, CharSet.getInstance(\"A-Z\"));\n+        assertSame(CharSet.ASCII_NUMERIC, CharSet.getInstance(\"0-9\"));\n+    }\n+            \n+    //-----------------------------------------------------------------------\n+    public void testConstructor_String_simple() {\n+        CharSet set;\n+        CharRange[] array;\n+        \n+        set = CharSet.getInstance((String) null);\n+        array = set.getCharRanges();\n+        assertEquals(\"[]\", set.toString());\n+        assertEquals(0, array.length);\n+        \n+        set = CharSet.getInstance(\"\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[]\", set.toString());\n+        assertEquals(0, array.length);\n+        \n+        set = CharSet.getInstance(\"a\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[a]\", set.toString());\n+        assertEquals(1, array.length);\n+        assertEquals(\"a\", array[0].toString());\n+        \n+        set = CharSet.getInstance(\"^a\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[^a]\", set.toString());\n+        assertEquals(1, array.length);\n+        assertEquals(\"^a\", array[0].toString());\n+        \n+        set = CharSet.getInstance(\"a-e\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[a-e]\", set.toString());\n+        assertEquals(1, array.length);\n+        assertEquals(\"a-e\", array[0].toString());\n+        \n+        set = CharSet.getInstance(\"^a-e\");\n+        array = set.getCharRanges();\n+        assertEquals(\"[^a-e]\", set.toString());\n+        assertEquals(1, array.length);\n+        assertEquals(\"^a-e\", array[0].toString());\n+    }\n+    \n+    public void testConstructor_String_combo() {\n+        CharSet set;\n+        CharRange[] array;\n+        \n+        set = CharSet.getInstance(\"abc\");\n+        array = set.getCharRanges();\n+        assertEquals(3, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('b')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('c')));\n+        \n+        set = CharSet.getInstance(\"a-ce-f\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'c')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('e', 'f')));\n+        \n+        set = CharSet.getInstance(\"ae-f\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('e', 'f')));\n+        \n+        set = CharSet.getInstance(\"e-fa\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('e', 'f')));\n+        \n+        set = CharSet.getInstance(\"ae-fm-pz\");\n+        array = set.getCharRanges();\n+        assertEquals(4, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('e', 'f')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('m', 'p')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('z')));\n+    }\n+    \n+    public void testConstructor_String_comboNegated() {\n+        CharSet set;\n+        CharRange[] array;\n+        \n+        set = CharSet.getInstance(\"^abc\");\n+        array = set.getCharRanges();\n+        assertEquals(3, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'a', true)));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('b')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('c')));\n+        \n+        set = CharSet.getInstance(\"b^ac\");\n+        array = set.getCharRanges();\n+        assertEquals(3, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('b')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'a', true)));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('c')));\n+        \n+        set = CharSet.getInstance(\"db^ac\");\n+        array = set.getCharRanges();\n+        assertEquals(4, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('d')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('b')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'a', true)));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('c')));\n+        \n+        set = CharSet.getInstance(\"^b^a\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('b', 'b', true)));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'a', true)));\n+        \n+        set = CharSet.getInstance(\"b^a-c^z\");\n+        array = set.getCharRanges();\n+        assertEquals(3, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'c', true)));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('z', 'z', true)));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('b')));\n+    }\n+        \n+    public void testConstructor_String_oddDash() {\n+        CharSet set;\n+        CharRange[] array;\n+        \n+        set = CharSet.getInstance(\"-\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-')));\n+        \n+        set = CharSet.getInstance(\"--\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-')));\n+        \n+        set = CharSet.getInstance(\"---\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-')));\n+        \n+        set = CharSet.getInstance(\"----\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-')));\n+        \n+        set = CharSet.getInstance(\"-a\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a')));\n+        \n+        set = CharSet.getInstance(\"a-\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-')));\n+        \n+        set = CharSet.getInstance(\"a--\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', '-')));\n+        \n+        set = CharSet.getInstance(\"--a\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-', 'a')));\n+    }\n+    \n+    public void testConstructor_String_oddNegate() {\n+        CharSet set;\n+        CharRange[] array;\n+        set = CharSet.getInstance(\"^\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^'))); // \"^\"\n+        \n+        set = CharSet.getInstance(\"^^\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^', '^', true))); // \"^^\"\n+        \n+        set = CharSet.getInstance(\"^^^\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^', '^', true))); // \"^^\"\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^', '^'))); // \"^\"\n+        \n+        set = CharSet.getInstance(\"^^^^\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^', '^', true))); // \"^^\" x2\n+        \n+        set = CharSet.getInstance(\"a^\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a'))); // \"a\"\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^'))); // \"^\"\n+        \n+        set = CharSet.getInstance(\"^a-\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'a', true))); // \"^a\"\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-'))); // \"-\"\n+        \n+        set = CharSet.getInstance(\"^^-c\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^', 'c', true))); // \"^^-c\"\n+        \n+        set = CharSet.getInstance(\"^c-^\");\n+        array = set.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('c', '^', true))); // \"^c-^\"\n+        \n+        set = CharSet.getInstance(\"^c-^d\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('c', '^', true))); // \"^c-^\"\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('d'))); // \"d\"\n+        \n+        set = CharSet.getInstance(\"^^-\");\n+        array = set.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^', '^', true))); // \"^^\"\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-'))); // \"-\"\n+    }\n+    \n+    public void testConstructor_String_oddCombinations() {\n+        CharSet set;\n+        CharRange[] array = null;\n+        \n+        set = CharSet.getInstance(\"a-^c\");\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', '^'))); // \"a-^\"\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('c'))); // \"c\"\n+        assertEquals(false, set.contains('b'));\n+        assertEquals(true, set.contains('^'));  \n+        assertEquals(true, set.contains('_')); // between ^ and a\n+        assertEquals(true, set.contains('c'));  \n+        \n+        set = CharSet.getInstance(\"^a-^c\");\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', '^', true))); // \"^a-^\"\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('c'))); // \"c\"\n+        assertEquals(true, set.contains('b'));\n+        assertEquals(false, set.contains('^'));  \n+        assertEquals(false, set.contains('_')); // between ^ and a\n+        \n+        set = CharSet.getInstance(\"a- ^-- \"); //contains everything\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', ' '))); // \"a- \"\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('-', ' ', true))); // \"^-- \"\n+        assertEquals(true, set.contains('#'));\n+        assertEquals(true, set.contains('^'));\n+        assertEquals(true, set.contains('a'));\n+        assertEquals(true, set.contains('*'));\n+        assertEquals(true, set.contains('A'));\n+        \n+        set = CharSet.getInstance(\"^-b\");\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^','b'))); // \"^-b\"\n+        assertEquals(true, set.contains('b'));\n+        assertEquals(true, set.contains('_')); // between ^ and a\n+        assertEquals(false, set.contains('A'));\n+        assertEquals(true, set.contains('^')); \n+        \n+        set = CharSet.getInstance(\"b-^\");\n+        array = set.getCharRanges();\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('^','b'))); // \"b-^\"\n+        assertEquals(true, set.contains('b'));\n+        assertEquals(true, set.contains('^'));\n+        assertEquals(true, set.contains('a')); // between ^ and b\n+        assertEquals(false, set.contains('c')); \n+    }\n+        \n+    //-----------------------------------------------------------------------    \n+    public void testEquals_Object() {\n+        CharSet abc = CharSet.getInstance(\"abc\");\n+        CharSet abc2 = CharSet.getInstance(\"abc\");\n+        CharSet atoc = CharSet.getInstance(\"a-c\");\n+        CharSet atoc2 = CharSet.getInstance(\"a-c\");\n+        CharSet notatoc = CharSet.getInstance(\"^a-c\");\n+        CharSet notatoc2 = CharSet.getInstance(\"^a-c\");\n+        \n+        assertEquals(false, abc.equals(null));\n+        \n+        assertEquals(true, abc.equals(abc));\n+        assertEquals(true, abc.equals(abc2));\n+        assertEquals(false, abc.equals(atoc));\n+        assertEquals(false, abc.equals(notatoc));\n+        \n+        assertEquals(false, atoc.equals(abc));\n+        assertEquals(true, atoc.equals(atoc));\n+        assertEquals(true, atoc.equals(atoc2));\n+        assertEquals(false, atoc.equals(notatoc));\n+        \n+        assertEquals(false, notatoc.equals(abc));\n+        assertEquals(false, notatoc.equals(atoc));\n+        assertEquals(true, notatoc.equals(notatoc));\n+        assertEquals(true, notatoc.equals(notatoc2));\n+    }\n+            \n+    public void testHashCode() {\n+        CharSet abc = CharSet.getInstance(\"abc\");\n+        CharSet abc2 = CharSet.getInstance(\"abc\");\n+        CharSet atoc = CharSet.getInstance(\"a-c\");\n+        CharSet atoc2 = CharSet.getInstance(\"a-c\");\n+        CharSet notatoc = CharSet.getInstance(\"^a-c\");\n+        CharSet notatoc2 = CharSet.getInstance(\"^a-c\");\n+        \n+        assertEquals(abc.hashCode(), abc.hashCode());\n+        assertEquals(abc.hashCode(), abc2.hashCode());\n+        assertEquals(atoc.hashCode(), atoc.hashCode());\n+        assertEquals(atoc.hashCode(), atoc2.hashCode());\n+        assertEquals(notatoc.hashCode(), notatoc.hashCode());\n+        assertEquals(notatoc.hashCode(), notatoc2.hashCode());\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testContains_Char() {\n+        CharSet btod = CharSet.getInstance(\"b-d\");\n+        CharSet dtob = CharSet.getInstance(\"d-b\");\n+        CharSet bcd = CharSet.getInstance(\"bcd\");\n+        CharSet bd = CharSet.getInstance(\"bd\");\n+        CharSet notbtod = CharSet.getInstance(\"^b-d\");\n+        \n+        assertEquals(false, btod.contains('a'));\n+        assertEquals(true, btod.contains('b'));\n+        assertEquals(true, btod.contains('c'));\n+        assertEquals(true, btod.contains('d'));\n+        assertEquals(false, btod.contains('e'));\n+        \n+        assertEquals(false, bcd.contains('a'));\n+        assertEquals(true, bcd.contains('b'));\n+        assertEquals(true, bcd.contains('c'));\n+        assertEquals(true, bcd.contains('d'));\n+        assertEquals(false, bcd.contains('e'));\n+        \n+        assertEquals(false, bd.contains('a'));\n+        assertEquals(true, bd.contains('b'));\n+        assertEquals(false, bd.contains('c'));\n+        assertEquals(true, bd.contains('d'));\n+        assertEquals(false, bd.contains('e'));\n+        \n+        assertEquals(true, notbtod.contains('a'));\n+        assertEquals(false, notbtod.contains('b'));\n+        assertEquals(false, notbtod.contains('c'));\n+        assertEquals(false, notbtod.contains('d'));\n+        assertEquals(true, notbtod.contains('e'));\n+        \n+        assertEquals(false, dtob.contains('a'));\n+        assertEquals(true, dtob.contains('b'));\n+        assertEquals(true, dtob.contains('c'));\n+        assertEquals(true, dtob.contains('d'));\n+        assertEquals(false, dtob.contains('e'));\n+      \n+        CharRange[] array = dtob.getCharRanges();\n+        assertEquals(\"[b-d]\", dtob.toString());\n+        assertEquals(1, array.length);\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testSerialization() {\n+        CharSet set = CharSet.getInstance(\"a\");\n+        assertEquals(set, SerializationUtils.clone(set)); \n+        set = CharSet.getInstance(\"a-e\");\n+        assertEquals(set, SerializationUtils.clone(set)); \n+        set = CharSet.getInstance(\"be-f^a-z\");\n+        assertEquals(set, SerializationUtils.clone(set)); \n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testStatics() {\n+        CharRange[] array;\n+        \n+        array = CharSet.EMPTY.getCharRanges();\n+        assertEquals(0, array.length);\n+        \n+        array = CharSet.ASCII_ALPHA.getCharRanges();\n+        assertEquals(2, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'z')));\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('A', 'Z')));\n+        \n+        array = CharSet.ASCII_ALPHA_LOWER.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('a', 'z')));\n+        \n+        array = CharSet.ASCII_ALPHA_UPPER.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('A', 'Z')));\n+        \n+        array = CharSet.ASCII_NUMERIC.getCharRanges();\n+        assertEquals(1, array.length);\n+        assertEquals(true, ArrayUtils.contains(array, new CharRange('0', '9')));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/CharSetUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharSetUtils}.\n+ *\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Stephen Colebourne\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class CharSetUtilsTest extends TestCase {\n+    \n+    public CharSetUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharSetUtilsTest.class);\n+        suite.setName(\"CharSetUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new CharSetUtils());\n+        Constructor[] cons = CharSetUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(CharSetUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(CharSetUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testEvaluateSet_Stringarray() {\n+        assertEquals(null, CharSetUtils.evaluateSet((String[]) null));\n+        assertEquals(\"[]\", CharSetUtils.evaluateSet(new String[0]).toString());\n+        assertEquals(\"[]\", CharSetUtils.evaluateSet(new String[] {null}).toString());\n+        assertEquals(\"[a-e]\", CharSetUtils.evaluateSet(new String[] {\"a-e\"}).toString());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSqueeze_StringString() {\n+        assertEquals(null, CharSetUtils.squeeze(null, (String) null));\n+        assertEquals(null, CharSetUtils.squeeze(null, \"\"));\n+        \n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", (String) null));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", \"\"));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", \"a-e\"));\n+        \n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", (String) null));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", \"\"));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", \"a-e\"));\n+        assertEquals(\"helo\", CharSetUtils.squeeze(\"hello\", \"l-p\"));\n+        assertEquals(\"heloo\", CharSetUtils.squeeze(\"helloo\", \"l\"));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"helloo\", \"^l\"));\n+    }\n+    \n+    public void testSqueeze_StringStringarray() {\n+        assertEquals(null, CharSetUtils.squeeze(null, (String[]) null));\n+        assertEquals(null, CharSetUtils.squeeze(null, new String[0]));\n+        assertEquals(null, CharSetUtils.squeeze(null, new String[] {null}));\n+        assertEquals(null, CharSetUtils.squeeze(null, new String[] {\"el\"}));\n+        \n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", (String[]) null));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", new String[0]));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", new String[] {null}));\n+        assertEquals(\"\", CharSetUtils.squeeze(\"\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", (String[]) null));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", new String[0]));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", new String[] {null}));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"helo\", CharSetUtils.squeeze(\"hello\", new String[] { \"el\" }));\n+        assertEquals(\"hello\", CharSetUtils.squeeze(\"hello\", new String[] { \"e\" }));\n+        assertEquals(\"fofof\", CharSetUtils.squeeze(\"fooffooff\", new String[] { \"of\" }));\n+        assertEquals(\"fof\", CharSetUtils.squeeze(\"fooooff\", new String[] { \"fo\" }));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCount_StringString() {\n+        assertEquals(0, CharSetUtils.count(null, (String) null));\n+        assertEquals(0, CharSetUtils.count(null, \"\"));\n+        \n+        assertEquals(0, CharSetUtils.count(\"\", (String) null));\n+        assertEquals(0, CharSetUtils.count(\"\", \"\"));\n+        assertEquals(0, CharSetUtils.count(\"\", \"a-e\"));\n+        \n+        assertEquals(0, CharSetUtils.count(\"hello\", (String) null));\n+        assertEquals(0, CharSetUtils.count(\"hello\", \"\"));\n+        assertEquals(1, CharSetUtils.count(\"hello\", \"a-e\"));\n+        assertEquals(3, CharSetUtils.count(\"hello\", \"l-p\"));\n+    }\n+    \n+    public void testCount_StringStringarray() {\n+        assertEquals(0, CharSetUtils.count(null, (String[]) null));\n+        assertEquals(0, CharSetUtils.count(null, new String[0]));\n+        assertEquals(0, CharSetUtils.count(null, new String[] {null}));\n+        assertEquals(0, CharSetUtils.count(null, new String[] {\"a-e\"}));\n+        \n+        assertEquals(0, CharSetUtils.count(\"\", (String[]) null));\n+        assertEquals(0, CharSetUtils.count(\"\", new String[0]));\n+        assertEquals(0, CharSetUtils.count(\"\", new String[] {null}));\n+        assertEquals(0, CharSetUtils.count(\"\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(0, CharSetUtils.count(\"hello\", (String[]) null));\n+        assertEquals(0, CharSetUtils.count(\"hello\", new String[0]));\n+        assertEquals(0, CharSetUtils.count(\"hello\", new String[] {null}));\n+        assertEquals(1, CharSetUtils.count(\"hello\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(3, CharSetUtils.count(\"hello\", new String[] { \"el\" }));\n+        assertEquals(0, CharSetUtils.count(\"hello\", new String[] { \"x\" }));\n+        assertEquals(2, CharSetUtils.count(\"hello\", new String[] { \"e-i\" }));\n+        assertEquals(5, CharSetUtils.count(\"hello\", new String[] { \"a-z\" }));\n+        assertEquals(0, CharSetUtils.count(\"hello\", new String[] { \"\" }));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testKeep_StringString() {\n+        assertEquals(null, CharSetUtils.keep(null, (String) null));\n+        assertEquals(null, CharSetUtils.keep(null, \"\"));\n+        \n+        assertEquals(\"\", CharSetUtils.keep(\"\", (String) null));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", \"\"));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", \"a-e\"));\n+        \n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", (String) null));\n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", \"\"));\n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", \"xyz\"));\n+        assertEquals(\"hello\", CharSetUtils.keep(\"hello\", \"a-z\"));\n+        assertEquals(\"hello\", CharSetUtils.keep(\"hello\", \"oleh\"));\n+        assertEquals(\"ell\", CharSetUtils.keep(\"hello\", \"el\"));\n+    }\n+    \n+    public void testKeep_StringStringarray() {\n+        assertEquals(null, CharSetUtils.keep(null, (String[]) null));\n+        assertEquals(null, CharSetUtils.keep(null, new String[0]));\n+        assertEquals(null, CharSetUtils.keep(null, new String[] {null}));\n+        assertEquals(null, CharSetUtils.keep(null, new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"\", CharSetUtils.keep(\"\", (String[]) null));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", new String[0]));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", new String[] {null}));\n+        assertEquals(\"\", CharSetUtils.keep(\"\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", (String[]) null));\n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", new String[0]));\n+        assertEquals(\"\", CharSetUtils.keep(\"hello\", new String[] {null}));\n+        assertEquals(\"e\", CharSetUtils.keep(\"hello\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"e\", CharSetUtils.keep(\"hello\", new String[] { \"a-e\" }));\n+        assertEquals(\"ell\", CharSetUtils.keep(\"hello\", new String[] { \"el\" }));\n+        assertEquals(\"hello\", CharSetUtils.keep(\"hello\", new String[] { \"elho\" }));\n+        assertEquals(\"hello\", CharSetUtils.keep(\"hello\", new String[] { \"a-z\" }));\n+        assertEquals(\"----\", CharSetUtils.keep(\"----\", new String[] { \"-\" }));\n+        assertEquals(\"ll\", CharSetUtils.keep(\"hello\", new String[] { \"l\" }));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDelete_StringString() {\n+        assertEquals(null, CharSetUtils.delete(null, (String) null));\n+        assertEquals(null, CharSetUtils.delete(null, \"\"));\n+        \n+        assertEquals(\"\", CharSetUtils.delete(\"\", (String) null));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", \"\"));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", \"a-e\"));\n+        \n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", (String) null));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", \"\"));\n+        assertEquals(\"hllo\", CharSetUtils.delete(\"hello\", \"a-e\"));\n+        assertEquals(\"he\", CharSetUtils.delete(\"hello\", \"l-p\"));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", \"z\"));\n+    }\n+    \n+    public void testDelete_StringStringarray() {\n+        assertEquals(null, CharSetUtils.delete(null, (String[]) null));\n+        assertEquals(null, CharSetUtils.delete(null, new String[0]));\n+        assertEquals(null, CharSetUtils.delete(null, new String[] {null}));\n+        assertEquals(null, CharSetUtils.delete(null, new String[] {\"el\"}));\n+        \n+        assertEquals(\"\", CharSetUtils.delete(\"\", (String[]) null));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", new String[0]));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", new String[] {null}));\n+        assertEquals(\"\", CharSetUtils.delete(\"\", new String[] {\"a-e\"}));\n+        \n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", (String[]) null));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", new String[0]));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", new String[] {null}));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", new String[] {\"xyz\"}));\n+\n+        assertEquals(\"ho\", CharSetUtils.delete(\"hello\", new String[] { \"el\" }));\n+        assertEquals(\"\", CharSetUtils.delete(\"hello\", new String[] { \"elho\" }));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", new String[] { \"\" }));\n+        assertEquals(\"hello\", CharSetUtils.delete(\"hello\", \"\"));\n+        assertEquals(\"\", CharSetUtils.delete(\"hello\", new String[] { \"a-z\" }));\n+        assertEquals(\"\", CharSetUtils.delete(\"----\", new String[] { \"-\" }));\n+        assertEquals(\"heo\", CharSetUtils.delete(\"hello\", new String[] { \"l\" }));\n+    }\n+    \n+    \n+    public void testTranslate() {\n+        assertEquals(null, CharSetUtils.translate(null, null, null));\n+        assertEquals(\"\", CharSetUtils.translate(\"\", \"a\", \"b\"));\n+        assertEquals(\"jelly\", CharSetUtils.translate(\"hello\", \"ho\", \"jy\"));\n+        assertEquals(\"jellj\", CharSetUtils.translate(\"hello\", \"ho\", \"j\"));\n+        assertEquals(\"jelly\", CharSetUtils.translate(\"hello\", \"ho\", \"jyx\"));\n+        assertEquals(\"\\rhello\\r\", CharSetUtils.translate(\"\\nhello\\n\", \"\\n\", \"\\r\"));\n+        assertEquals(\"hello\", CharSetUtils.translate(\"hello\", \"\", \"x\"));\n+        assertEquals(\"hello\", CharSetUtils.translate(\"hello\", \"\", \"\"));\n+        assertEquals(\"hello\", CharSetUtils.translate(\"hello\", \"\", \"\"));\n+        // From http://issues.apache.org/bugzilla/show_bug.cgi?id=25454\n+        assertEquals(\"q651.506bera\", CharSetUtils.translate(\"d216.102oren\", \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\",\n+                \"nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM567891234\"));\n+    }\n+\n+    public void testTranslateNullPointerException() {\n+        try {\n+            CharSetUtils.translate(\"hello\", null, null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+        try {\n+            CharSetUtils.translate(\"hello\", \"h\", null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+        try {\n+            CharSetUtils.translate(\"hello\", null, \"a\");\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+        }\n+        try {\n+            CharSetUtils.translate(\"hello\", \"h\", \"\");\n+            fail(\"Expecting ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+        }\n+    }\n+         \n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/CharUtilsPerfTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.text.NumberFormat;\n+import java.util.Calendar;\n+\n+/**\n+ * Tests the difference in performance between CharUtils and CharSet.\n+ * \n+ * Sample runs:\n+\n+Now: Thu Mar 18 14:29:48 PST 2004\n+Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.3.1_10-b03\n+Sun Microsystems Inc. Java HotSpot(TM) Client VM 1.3.1_10-b03\n+Windows XP 5.1 x86 pentium i486 i386\n+Do nohting: 0 milliseconds.\n+run_CharUtils_isAsciiNumeric: 4,545 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 3,417 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 85,679 milliseconds.\n+\n+\n+Now: Thu Mar 18 14:24:51 PST 2004\n+Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.4.2_04-b05\n+Sun Microsystems Inc. Java HotSpot(TM) Client VM 1.4.2_04-b05\n+Windows XP 5.1 x86 pentium i486 i386\n+Do nohting: 0 milliseconds.\n+run_CharUtils_isAsciiNumeric: 2,578 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 2,477 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 114,429 milliseconds.\n+\n+Now: Thu Mar 18 14:27:55 PST 2004\n+Sun Microsystems Inc. Java(TM) 2 Runtime Environment, Standard Edition 1.4.2_04-b05\n+Sun Microsystems Inc. Java HotSpot(TM) Server VM 1.4.2_04-b05\n+Windows XP 5.1 x86 pentium i486 i386\n+Do nohting: 0 milliseconds.\n+run_CharUtils_isAsciiNumeric: 630 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 709 milliseconds.\n+run_inlined_CharUtils_isAsciiNumeric: 84,420 milliseconds.\n+\n+\n+ * @version $Id$\n+ */\n+public class CharUtilsPerfTest {\n+    final static String VERSION = \"$Id$\";\n+\n+    final static int WARM_UP = 100;\n+\n+    final static int COUNT = 5000;\n+\n+    final static char[] CHAR_SAMPLES;\n+    static {\n+        CHAR_SAMPLES = new char[Character.MAX_VALUE];\n+        for (char i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) {\n+            CHAR_SAMPLES[i] = i;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new CharUtilsPerfTest().run();\n+    }\n+\n+    private void printSysInfo() {\n+        System.out.println(VERSION);\n+        System.out.println(\"Now: \" + Calendar.getInstance().getTime());\n+        System.out.println(System.getProperty(\"java.vendor\")\n+                + \" \"\n+                + System.getProperty(\"java.runtime.name\")\n+                + \" \"\n+                + System.getProperty(\"java.runtime.version\"));\n+        System.out.println(System.getProperty(\"java.vm.vendor\")\n+                + \" \"\n+                + System.getProperty(\"java.vm.name\")\n+                + \" \"\n+                + System.getProperty(\"java.vm.version\"));\n+        System.out.println(System.getProperty(\"os.name\")\n+            + \" \"\n+            + System.getProperty(\"os.version\")\n+            + \" \"\n+            + System.getProperty(\"os.arch\")\n+            + \" \"\n+            + System.getProperty(\"sun.cpu.isalist\"));\n+    }\n+\n+    private void run() {\n+        this.printSysInfo();\n+        long start;\n+        start = System.currentTimeMillis();\n+        this.printlnTotal(\"Do nohting\", start);\n+        //System.out.println(\"Warming up...\");\n+        run_CharUtils_isAsciiNumeric(WARM_UP);\n+        //System.out.println(\"Measuring...\");\n+        start = System.currentTimeMillis();\n+        run_CharUtils_isAsciiNumeric(COUNT);\n+        this.printlnTotal(\"run_CharUtils_isAsciiNumeric\", start);\n+        //System.out.println(\"Warming up...\");\n+        run_inlined_CharUtils_isAsciiNumeric(WARM_UP);\n+        //System.out.println(\"Measuring...\");\n+        start = System.currentTimeMillis();\n+        run_inlined_CharUtils_isAsciiNumeric(COUNT);\n+        this.printlnTotal(\"run_inlined_CharUtils_isAsciiNumeric\", start);\n+        //System.out.println(\"Warming up...\");\n+        run_CharSet(WARM_UP);\n+        //System.out.println(\"Measuring...\");\n+        start = System.currentTimeMillis();\n+        run_CharSet(COUNT);\n+        this.printlnTotal(\"run_CharSet\", start);\n+    }\n+\n+    private int run_CharSet(int loopCount) {\n+        int t = 0;\n+        for (int i = 0; i < loopCount; i++) {\n+            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n+                char ch = CHAR_SAMPLES[j];\n+                boolean b = CharSet.ASCII_NUMERIC.contains(ch);\n+                t += b ? 1 : 0;\n+            }\n+        }\n+        return t;\n+    }\n+\n+    private int run_CharUtils_isAsciiNumeric(int loopCount) {\n+        int t = 0;\n+        for (int i = 0; i < loopCount; i++) {\n+            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n+                char ch = CHAR_SAMPLES[j];\n+                boolean b = CharUtils.isAsciiNumeric(ch);\n+                t += b ? 1 : 0;\n+            }\n+        }\n+        return t;\n+    }\n+\n+    private int run_inlined_CharUtils_isAsciiNumeric(int loopCount) {\n+        int t = 0;\n+        for (int i = 0; i < loopCount; i++) {\n+            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n+                char ch = CHAR_SAMPLES[j];\n+                boolean b = (ch >= '0' && ch <= '9');\n+                t += b ? 1 : 0;\n+            }\n+        }\n+        return t;\n+    }\n+\n+    private void printlnTotal(String prefix, long start) {\n+        long total = System.currentTimeMillis() - start;\n+        System.out.println(prefix + \": \" + NumberFormat.getInstance().format(total) + \" milliseconds.\");\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/CharUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.CharUtils}.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class CharUtilsTest extends TestCase {\n+\n+    private static final Character CHARACTER_A = new Character('A');\n+    private static final Character CHARACTER_B = new Character('B');\n+    private static final char CHAR_COPY = '\\u00a9';\n+    \n+    public CharUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CharUtilsTest.class);\n+        suite.setName(\"CharUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new CharUtils());\n+        Constructor[] cons = CharUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(BooleanUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(BooleanUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToCharacterObject_char() {\n+        assertEquals(new Character('a'), CharUtils.toCharacterObject('a'));\n+        assertSame(CharUtils.toCharacterObject('a'), CharUtils.toCharacterObject('a'));\n+       \n+        for (int i = 0; i < 128; i++) {\n+            Character ch = CharUtils.toCharacterObject((char) i);\n+            Character ch2 = CharUtils.toCharacterObject((char) i);\n+            assertSame(ch, ch2);\n+            assertEquals(i, ch.charValue());\n+        }\n+        for (int i = 128; i < 196; i++) {\n+            Character ch = CharUtils.toCharacterObject((char) i);\n+            Character ch2 = CharUtils.toCharacterObject((char) i);\n+            assertEquals(ch, ch2);\n+            assertTrue(ch != ch2);\n+            assertEquals(i, ch.charValue());\n+            assertEquals(i, ch2.charValue());\n+        }\n+    }\n+    \n+    public void testToCharacterObject_String() {\n+        assertEquals(null, CharUtils.toCharacterObject(null));\n+        assertEquals(null, CharUtils.toCharacterObject(\"\"));\n+        assertEquals(new Character('a'), CharUtils.toCharacterObject(\"a\"));\n+        assertEquals(new Character('a'), CharUtils.toCharacterObject(\"abc\"));\n+        assertSame(CharUtils.toCharacterObject(\"a\"), CharUtils.toCharacterObject(\"a\"));\n+        assertSame(CharUtils.toCharacterObject(\"a\"), CharUtils.toCharacterObject('a'));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToChar_Character() {\n+        assertEquals('A', CharUtils.toChar(CHARACTER_A));\n+        assertEquals('B', CharUtils.toChar(CHARACTER_B));\n+        try {\n+            CharUtils.toChar((Character) null);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testToChar_Character_char() {\n+        assertEquals('A', CharUtils.toChar(CHARACTER_A, 'X'));\n+        assertEquals('B', CharUtils.toChar(CHARACTER_B, 'X'));\n+        assertEquals('X', CharUtils.toChar((Character) null, 'X'));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToChar_String() {\n+        assertEquals('A', CharUtils.toChar(\"A\"));\n+        assertEquals('B', CharUtils.toChar(\"BA\"));\n+        try {\n+            CharUtils.toChar((String) null);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            CharUtils.toChar(\"\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testToChar_String_char() {\n+        assertEquals('A', CharUtils.toChar(\"A\", 'X'));\n+        assertEquals('B', CharUtils.toChar(\"BA\", 'X'));\n+        assertEquals('X', CharUtils.toChar(\"\", 'X'));\n+        assertEquals('X', CharUtils.toChar((String) null, 'X'));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToIntValue_char() {\n+        assertEquals(0, CharUtils.toIntValue('0'));\n+        assertEquals(1, CharUtils.toIntValue('1'));\n+        assertEquals(2, CharUtils.toIntValue('2'));\n+        assertEquals(3, CharUtils.toIntValue('3'));\n+        assertEquals(4, CharUtils.toIntValue('4'));\n+        assertEquals(5, CharUtils.toIntValue('5'));\n+        assertEquals(6, CharUtils.toIntValue('6'));\n+        assertEquals(7, CharUtils.toIntValue('7'));\n+        assertEquals(8, CharUtils.toIntValue('8'));\n+        assertEquals(9, CharUtils.toIntValue('9'));\n+        try {\n+            CharUtils.toIntValue('a');\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testToIntValue_char_int() {\n+        assertEquals(0, CharUtils.toIntValue('0', -1));\n+        assertEquals(3, CharUtils.toIntValue('3', -1));\n+        assertEquals(-1, CharUtils.toIntValue('a', -1));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToIntValue_Character() {\n+        assertEquals(0, CharUtils.toIntValue(new Character('0')));\n+        assertEquals(3, CharUtils.toIntValue(new Character('3')));\n+        try {\n+            CharUtils.toIntValue(null);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            CharUtils.toIntValue(CHARACTER_A);\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testToIntValue_Character_int() {\n+        assertEquals(0, CharUtils.toIntValue(new Character('0'), -1));\n+        assertEquals(3, CharUtils.toIntValue(new Character('3'), -1));\n+        assertEquals(-1, CharUtils.toIntValue(new Character('A'), -1));\n+        assertEquals(-1, CharUtils.toIntValue(null, -1));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToString_char() {\n+        assertEquals(\"a\", CharUtils.toString('a'));\n+        assertSame(CharUtils.toString('a'), CharUtils.toString('a'));\n+       \n+        for (int i = 0; i < 128; i++) {\n+            String str = CharUtils.toString((char) i);\n+            String str2 = CharUtils.toString((char) i);\n+            assertSame(str, str2);\n+            assertEquals(1, str.length());\n+            assertEquals(i, str.charAt(0));\n+        }\n+        for (int i = 128; i < 196; i++) {\n+            String str = CharUtils.toString((char) i);\n+            String str2 = CharUtils.toString((char) i);\n+            assertEquals(str, str2);\n+            assertTrue(str != str2);\n+            assertEquals(1, str.length());\n+            assertEquals(i, str.charAt(0));\n+            assertEquals(1, str2.length());\n+            assertEquals(i, str2.charAt(0));\n+        }\n+    }\n+    \n+    public void testToString_Character() {\n+        assertEquals(null, CharUtils.toString(null));\n+        assertEquals(\"A\", CharUtils.toString(CHARACTER_A));\n+        assertSame(CharUtils.toString(CHARACTER_A), CharUtils.toString(CHARACTER_A));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToUnicodeEscaped_char() {\n+        assertEquals(\"\\\\u0041\", CharUtils.unicodeEscaped('A'));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            String str = CharUtils.unicodeEscaped((char) i);\n+            assertEquals(6, str.length());\n+            int val = Integer.parseInt(str.substring(2), 16);\n+            assertEquals(i, val);\n+        }\n+        assertEquals(\"\\\\u0999\", CharUtils.unicodeEscaped((char) 0x999));\n+        assertEquals(\"\\\\u1001\", CharUtils.unicodeEscaped((char) 0x1001));\n+    }\n+    \n+    public void testToUnicodeEscaped_Character() {\n+        assertEquals(null, CharUtils.unicodeEscaped(null));\n+        assertEquals(\"\\\\u0041\", CharUtils.unicodeEscaped(CHARACTER_A));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAscii_char() {\n+        assertEquals(true, CharUtils.isAscii('a'));\n+        assertEquals(true, CharUtils.isAscii('A'));\n+        assertEquals(true, CharUtils.isAscii('3'));\n+        assertEquals(true, CharUtils.isAscii('-'));\n+        assertEquals(true, CharUtils.isAscii('\\n'));\n+        assertEquals(false, CharUtils.isAscii(CHAR_COPY));\n+       \n+        for (int i = 0; i < 128; i++) {\n+            if (i < 128) {\n+                assertEquals(true, CharUtils.isAscii((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAscii((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiPrintable_char() {\n+        assertEquals(true, CharUtils.isAsciiPrintable('a'));\n+        assertEquals(true, CharUtils.isAsciiPrintable('A'));\n+        assertEquals(true, CharUtils.isAsciiPrintable('3'));\n+        assertEquals(true, CharUtils.isAsciiPrintable('-'));\n+        assertEquals(false, CharUtils.isAsciiPrintable('\\n'));\n+        assertEquals(false, CharUtils.isAscii(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i >= 32 && i <= 126) {\n+                assertEquals(true, CharUtils.isAsciiPrintable((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiPrintable((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiControl_char() {\n+        assertEquals(false, CharUtils.isAsciiControl('a'));\n+        assertEquals(false, CharUtils.isAsciiControl('A'));\n+        assertEquals(false, CharUtils.isAsciiControl('3'));\n+        assertEquals(false, CharUtils.isAsciiControl('-'));\n+        assertEquals(true, CharUtils.isAsciiControl('\\n'));\n+        assertEquals(false, CharUtils.isAsciiControl(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i < 32 || i == 127) {\n+                assertEquals(true, CharUtils.isAsciiControl((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiControl((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiAlpha_char() {\n+        assertEquals(true, CharUtils.isAsciiAlpha('a'));\n+        assertEquals(true, CharUtils.isAsciiAlpha('A'));\n+        assertEquals(false, CharUtils.isAsciiAlpha('3'));\n+        assertEquals(false, CharUtils.isAsciiAlpha('-'));\n+        assertEquals(false, CharUtils.isAsciiAlpha('\\n'));\n+        assertEquals(false, CharUtils.isAsciiAlpha(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z')) {\n+                assertEquals(true, CharUtils.isAsciiAlpha((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiAlpha((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiAlphaUpper_char() {\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper('a'));\n+        assertEquals(true, CharUtils.isAsciiAlphaUpper('A'));\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper('3'));\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper('-'));\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper('\\n'));\n+        assertEquals(false, CharUtils.isAsciiAlphaUpper(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i >= 'A' && i <= 'Z') {\n+                assertEquals(true, CharUtils.isAsciiAlphaUpper((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiAlphaUpper((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiAlphaLower_char() {\n+        assertEquals(true, CharUtils.isAsciiAlphaLower('a'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower('A'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower('3'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower('-'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower('\\n'));\n+        assertEquals(false, CharUtils.isAsciiAlphaLower(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i >= 'a' && i <= 'z') {\n+                assertEquals(true, CharUtils.isAsciiAlphaLower((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiAlphaLower((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiNumeric_char() {\n+        assertEquals(false, CharUtils.isAsciiNumeric('a'));\n+        assertEquals(false, CharUtils.isAsciiNumeric('A'));\n+        assertEquals(true, CharUtils.isAsciiNumeric('3'));\n+        assertEquals(false, CharUtils.isAsciiNumeric('-'));\n+        assertEquals(false, CharUtils.isAsciiNumeric('\\n'));\n+        assertEquals(false, CharUtils.isAsciiNumeric(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if (i >= '0' && i <= '9') {\n+                assertEquals(true, CharUtils.isAsciiNumeric((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiNumeric((char) i));\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsAsciiAlphanumeric_char() {\n+        assertEquals(true, CharUtils.isAsciiAlphanumeric('a'));\n+        assertEquals(true, CharUtils.isAsciiAlphanumeric('A'));\n+        assertEquals(true, CharUtils.isAsciiAlphanumeric('3'));\n+        assertEquals(false, CharUtils.isAsciiAlphanumeric('-'));\n+        assertEquals(false, CharUtils.isAsciiAlphanumeric('\\n'));\n+        assertEquals(false, CharUtils.isAsciiAlphanumeric(CHAR_COPY));\n+       \n+        for (int i = 0; i < 196; i++) {\n+            if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z') || (i >= '0' && i <= '9')) {\n+                assertEquals(true, CharUtils.isAsciiAlphanumeric((char) i));\n+            } else {\n+                assertEquals(false, CharUtils.isAsciiAlphanumeric((char) i));\n+            }\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/ClassUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Collections;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.ClassUtils}.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class ClassUtilsTest extends TestCase {\n+\n+    public ClassUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ClassUtilsTest.class);\n+        suite.setName(\"ClassUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    private static class Inner {\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new ClassUtils());\n+        Constructor[] cons = ClassUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(ClassUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(ClassUtils.class.getModifiers()));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_getShortClassName_Object() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(new ClassUtils(), \"<null>\"));\n+        assertEquals(\"ClassUtilsTest.Inner\", ClassUtils.getShortClassName(new Inner(), \"<null>\"));\n+        assertEquals(\"String\", ClassUtils.getShortClassName(\"hello\", \"<null>\"));\n+        assertEquals(\"<null>\", ClassUtils.getShortClassName(null, \"<null>\"));\n+    }\n+    \n+    public void test_getShortClassName_Class() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class));\n+        assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class));\n+        assertEquals(\"\", ClassUtils.getShortClassName((Class) null));\n+    }\n+    \n+    public void test_getShortClassName_String() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class.getName()));\n+        assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class.getName()));\n+        assertEquals(\"\", ClassUtils.getShortClassName((String) null));\n+        assertEquals(\"\", ClassUtils.getShortClassName(\"\"));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_getPackageName_Object() {\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(new ClassUtils(), \"<null>\"));\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(new Inner(), \"<null>\"));\n+        assertEquals(\"<null>\", ClassUtils.getPackageName(null, \"<null>\"));\n+    }\n+    \n+    public void test_getPackageName_Class() {\n+        assertEquals(\"java.lang\", ClassUtils.getPackageName(String.class));\n+        assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class));\n+        assertEquals(\"\", ClassUtils.getPackageName((Class)null));\n+    }\n+    \n+    public void test_getPackageName_String() {\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(ClassUtils.class.getName()));\n+        assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class.getName()));\n+        assertEquals(\"\", ClassUtils.getPackageName((String)null));\n+        assertEquals(\"\", ClassUtils.getPackageName(\"\"));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_getAllSuperclasses_Class() {\n+        List list = ClassUtils.getAllSuperclasses(CY.class);\n+        assertEquals(2, list.size());\n+        assertEquals(CX.class, list.get(0));\n+        assertEquals(Object.class, list.get(1));\n+        \n+        assertEquals(null, ClassUtils.getAllSuperclasses(null));\n+    }\n+    \n+    public void test_getAllInterfaces_Class() {\n+        List list = ClassUtils.getAllInterfaces(CY.class);\n+        assertEquals(6, list.size());\n+        assertEquals(IB.class, list.get(0));\n+        assertEquals(IC.class, list.get(1));\n+        assertEquals(ID.class, list.get(2));\n+        assertEquals(IE.class, list.get(3));\n+        assertEquals(IF.class, list.get(4));\n+        assertEquals(IA.class, list.get(5));\n+        \n+        assertEquals(null, ClassUtils.getAllInterfaces(null));\n+    }\n+    \n+    private static interface IA {\n+    }\n+    private static interface IB {\n+    }\n+    private static interface IC extends ID, IE {\n+    }\n+    private static interface ID {\n+    }\n+    private static interface IE extends IF {\n+    }\n+    private static interface IF {\n+    }\n+    private static class CX implements IB, IA, IE {\n+    }\n+    private static class CY extends CX implements IB, IC {\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_convertClassNamesToClasses_List() {\n+        List list = new ArrayList();\n+        List result = ClassUtils.convertClassNamesToClasses(list);\n+        assertEquals(0, result.size());\n+        \n+        list.add(\"java.lang.String\");\n+        list.add(\"java.lang.xxx\");\n+        list.add(\"java.lang.Object\");\n+        result = ClassUtils.convertClassNamesToClasses(list);\n+        assertEquals(3, result.size());\n+        assertEquals(String.class, result.get(0));\n+        assertEquals(null, result.get(1));\n+        assertEquals(Object.class, result.get(2));\n+\n+        list.add(new Object());\n+        try {\n+            ClassUtils.convertClassNamesToClasses(list);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        assertEquals(null, ClassUtils.convertClassNamesToClasses(null));\n+    }\n+    \n+    public void test_convertClassesToClassNames_List() {\n+        List list = new ArrayList();\n+        List result = ClassUtils.convertClassesToClassNames(list);\n+        assertEquals(0, result.size());\n+        \n+        list.add(String.class);\n+        list.add(null);\n+        list.add(Object.class);\n+        result = ClassUtils.convertClassesToClassNames(list);\n+        assertEquals(3, result.size());\n+        assertEquals(\"java.lang.String\", result.get(0));\n+        assertEquals(null, result.get(1));\n+        assertEquals(\"java.lang.Object\", result.get(2));\n+\n+        list.add(new Object());\n+        try {\n+            ClassUtils.convertClassesToClassNames(list);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        assertEquals(null, ClassUtils.convertClassesToClassNames(null));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_isInnerClass_Class() {\n+        assertEquals(true, ClassUtils.isInnerClass(Inner.class));\n+        assertEquals(true, ClassUtils.isInnerClass(Map.Entry.class));\n+        assertEquals(true, ClassUtils.isInnerClass(new Cloneable() {\n+        }.getClass()));\n+        assertEquals(false, ClassUtils.isInnerClass(this.getClass()));\n+        assertEquals(false, ClassUtils.isInnerClass(String.class));\n+        assertEquals(false, ClassUtils.isInnerClass(null));\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_isAssignable_ClassArray_ClassArray() throws Exception {\n+        Class[] array2 = new Class[] {Object.class, Object.class};\n+        Class[] array1 = new Class[] {Object.class};\n+        Class[] array1s = new Class[] {String.class};\n+        Class[] array0 = new Class[] {};\n+\n+        assertEquals(false, ClassUtils.isAssignable(array1, array2));\n+        assertEquals(false, ClassUtils.isAssignable(null, array2));\n+        assertEquals(true, ClassUtils.isAssignable(null, array0));\n+        assertEquals(true, ClassUtils.isAssignable(array0, array0));\n+        assertEquals(true, ClassUtils.isAssignable(array0, null));\n+        assertEquals(true, ClassUtils.isAssignable((Class[]) null, (Class[]) null));\n+        \n+        assertEquals(false, ClassUtils.isAssignable(array1, array1s));\n+        assertEquals(true, ClassUtils.isAssignable(array1s, array1s));\n+        assertEquals(true, ClassUtils.isAssignable(array1s, array1));\n+    }\n+    \n+    public void test_isAssignable() throws Exception {\n+        assertEquals(false, ClassUtils.isAssignable((Class) null, null));\n+        assertEquals(false, ClassUtils.isAssignable(String.class, null));\n+        \n+        assertEquals(true, ClassUtils.isAssignable(null, Object.class));\n+        assertEquals(true, ClassUtils.isAssignable(null, Integer.class));\n+        assertEquals(false, ClassUtils.isAssignable(null, Integer.TYPE));\n+        assertEquals(true, ClassUtils.isAssignable(String.class, Object.class));\n+        assertEquals(true, ClassUtils.isAssignable(String.class, String.class));\n+        assertEquals(false, ClassUtils.isAssignable(Object.class, String.class));\n+        assertEquals(false, ClassUtils.isAssignable(Integer.TYPE, Integer.class));\n+        assertEquals(false, ClassUtils.isAssignable(Integer.class, Integer.TYPE));\n+        assertEquals(true, ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));\n+        assertEquals(true, ClassUtils.isAssignable(Integer.class, Integer.class));\n+    }\n+    \n+    public void test_isAssignable_Widening() throws Exception {\n+        // test byte conversions\n+        assertEquals(\"byte -> char\", false, ClassUtils.isAssignable(Byte.TYPE, Character.TYPE));\n+        assertEquals(\"byte -> byte\", true, ClassUtils.isAssignable(Byte.TYPE, Byte.TYPE));\n+        assertEquals(\"byte -> short\", true, ClassUtils.isAssignable(Byte.TYPE, Short.TYPE));\n+        assertEquals(\"byte -> int\", true, ClassUtils.isAssignable(Byte.TYPE, Integer.TYPE));\n+        assertEquals(\"byte -> long\", true, ClassUtils.isAssignable(Byte.TYPE, Long.TYPE));\n+        assertEquals(\"byte -> float\", true, ClassUtils.isAssignable(Byte.TYPE, Float.TYPE));\n+        assertEquals(\"byte -> double\", true, ClassUtils.isAssignable(Byte.TYPE, Double.TYPE));\n+        assertEquals(\"byte -> boolean\", false, ClassUtils.isAssignable(Byte.TYPE, Boolean.TYPE));\n+        \n+        // test short conversions\n+        assertEquals(\"short -> char\", false, ClassUtils.isAssignable(Short.TYPE, Character.TYPE));\n+        assertEquals(\"short -> byte\", false, ClassUtils.isAssignable(Short.TYPE, Byte.TYPE));\n+        assertEquals(\"short -> short\", true, ClassUtils.isAssignable(Short.TYPE, Short.TYPE));\n+        assertEquals(\"short -> int\", true, ClassUtils.isAssignable(Short.TYPE, Integer.TYPE));\n+        assertEquals(\"short -> long\", true, ClassUtils.isAssignable(Short.TYPE, Long.TYPE));\n+        assertEquals(\"short -> float\", true, ClassUtils.isAssignable(Short.TYPE, Float.TYPE));\n+        assertEquals(\"short -> double\", true, ClassUtils.isAssignable(Short.TYPE, Double.TYPE));\n+        assertEquals(\"short -> boolean\", false, ClassUtils.isAssignable(Short.TYPE, Boolean.TYPE));\n+        \n+        // test char conversions\n+        assertEquals(\"char -> char\", true, ClassUtils.isAssignable(Character.TYPE, Character.TYPE));\n+        assertEquals(\"char -> byte\", false, ClassUtils.isAssignable(Character.TYPE, Byte.TYPE));\n+        assertEquals(\"char -> short\", false, ClassUtils.isAssignable(Character.TYPE, Short.TYPE));\n+        assertEquals(\"char -> int\", true, ClassUtils.isAssignable(Character.TYPE, Integer.TYPE));\n+        assertEquals(\"char -> long\", true, ClassUtils.isAssignable(Character.TYPE, Long.TYPE));\n+        assertEquals(\"char -> float\", true, ClassUtils.isAssignable(Character.TYPE, Float.TYPE));\n+        assertEquals(\"char -> double\", true, ClassUtils.isAssignable(Character.TYPE, Double.TYPE));\n+        assertEquals(\"char -> boolean\", false, ClassUtils.isAssignable(Character.TYPE, Boolean.TYPE));\n+        \n+        // test int conversions\n+        assertEquals(\"int -> char\", false, ClassUtils.isAssignable(Integer.TYPE, Character.TYPE));\n+        assertEquals(\"int -> byte\", false, ClassUtils.isAssignable(Integer.TYPE, Byte.TYPE));\n+        assertEquals(\"int -> short\", false, ClassUtils.isAssignable(Integer.TYPE, Short.TYPE));\n+        assertEquals(\"int -> int\", true, ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));\n+        assertEquals(\"int -> long\", true, ClassUtils.isAssignable(Integer.TYPE, Long.TYPE));\n+        assertEquals(\"int -> float\", true, ClassUtils.isAssignable(Integer.TYPE, Float.TYPE));\n+        assertEquals(\"int -> double\", true, ClassUtils.isAssignable(Integer.TYPE, Double.TYPE));\n+        assertEquals(\"int -> boolean\", false, ClassUtils.isAssignable(Integer.TYPE, Boolean.TYPE));\n+ \n+        // test long conversions\n+        assertEquals(\"long -> char\", false, ClassUtils.isAssignable(Long.TYPE, Character.TYPE));\n+        assertEquals(\"long -> byte\", false, ClassUtils.isAssignable(Long.TYPE, Byte.TYPE));\n+        assertEquals(\"long -> short\", false, ClassUtils.isAssignable(Long.TYPE, Short.TYPE));\n+        assertEquals(\"long -> int\", false, ClassUtils.isAssignable(Long.TYPE, Integer.TYPE));\n+        assertEquals(\"long -> long\", true, ClassUtils.isAssignable(Long.TYPE, Long.TYPE));\n+        assertEquals(\"long -> float\", true, ClassUtils.isAssignable(Long.TYPE, Float.TYPE));\n+        assertEquals(\"long -> double\", true, ClassUtils.isAssignable(Long.TYPE, Double.TYPE));\n+        assertEquals(\"long -> boolean\", false, ClassUtils.isAssignable(Long.TYPE, Boolean.TYPE));\n+ \n+        // test float conversions\n+        assertEquals(\"float -> char\", false, ClassUtils.isAssignable(Float.TYPE, Character.TYPE));\n+        assertEquals(\"float -> byte\", false, ClassUtils.isAssignable(Float.TYPE, Byte.TYPE));\n+        assertEquals(\"float -> short\", false, ClassUtils.isAssignable(Float.TYPE, Short.TYPE));\n+        assertEquals(\"float -> int\", false, ClassUtils.isAssignable(Float.TYPE, Integer.TYPE));\n+        assertEquals(\"float -> long\", false, ClassUtils.isAssignable(Float.TYPE, Long.TYPE));\n+        assertEquals(\"float -> float\", true, ClassUtils.isAssignable(Float.TYPE, Float.TYPE));\n+        assertEquals(\"float -> double\", true, ClassUtils.isAssignable(Float.TYPE, Double.TYPE));\n+        assertEquals(\"float -> boolean\", false, ClassUtils.isAssignable(Float.TYPE, Boolean.TYPE));\n+        \n+        // test float conversions\n+        assertEquals(\"double -> char\", false, ClassUtils.isAssignable(Double.TYPE, Character.TYPE));\n+        assertEquals(\"double -> byte\", false, ClassUtils.isAssignable(Double.TYPE, Byte.TYPE));\n+        assertEquals(\"double -> short\", false, ClassUtils.isAssignable(Double.TYPE, Short.TYPE));\n+        assertEquals(\"double -> int\", false, ClassUtils.isAssignable(Double.TYPE, Integer.TYPE));\n+        assertEquals(\"double -> long\", false, ClassUtils.isAssignable(Double.TYPE, Long.TYPE));\n+        assertEquals(\"double -> float\", false, ClassUtils.isAssignable(Double.TYPE, Float.TYPE));\n+        assertEquals(\"double -> double\", true, ClassUtils.isAssignable(Double.TYPE, Double.TYPE));\n+        assertEquals(\"double -> boolean\", false, ClassUtils.isAssignable(Double.TYPE, Boolean.TYPE));\n+        \n+        // test float conversions\n+        assertEquals(\"boolean -> char\", false, ClassUtils.isAssignable(Boolean.TYPE, Character.TYPE));\n+        assertEquals(\"boolean -> byte\", false, ClassUtils.isAssignable(Boolean.TYPE, Byte.TYPE));\n+        assertEquals(\"boolean -> short\", false, ClassUtils.isAssignable(Boolean.TYPE, Short.TYPE));\n+        assertEquals(\"boolean -> int\", false, ClassUtils.isAssignable(Boolean.TYPE, Integer.TYPE));\n+        assertEquals(\"boolean -> long\", false, ClassUtils.isAssignable(Boolean.TYPE, Long.TYPE));\n+        assertEquals(\"boolean -> float\", false, ClassUtils.isAssignable(Boolean.TYPE, Float.TYPE));\n+        assertEquals(\"boolean -> double\", false, ClassUtils.isAssignable(Boolean.TYPE, Double.TYPE));\n+        assertEquals(\"boolean -> boolean\", true, ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE));\n+    }\n+    \n+    public void testPrimitiveToWrapper() {\n+       \n+        // test primitive classes\n+        assertEquals(\"boolean -> Boolean.class\", \n+            Boolean.class, ClassUtils.primitiveToWrapper(Boolean.TYPE));   \n+        assertEquals(\"byte -> Byte.class\",\n+            Byte.class, ClassUtils.primitiveToWrapper(Byte.TYPE));\n+        assertEquals(\"char -> Character.class\",\n+            Character.class, ClassUtils.primitiveToWrapper(Character.TYPE));\n+        assertEquals(\"short -> Short.class\",\n+            Short.class, ClassUtils.primitiveToWrapper(Short.TYPE));\n+        assertEquals(\"int -> Integer.class\",\n+            Integer.class, ClassUtils.primitiveToWrapper(Integer.TYPE));\n+        assertEquals(\"long -> Long.class\",\n+            Long.class, ClassUtils.primitiveToWrapper(Long.TYPE));\n+        assertEquals(\"double -> Double.class\",\n+            Double.class, ClassUtils.primitiveToWrapper(Double.TYPE));\n+        assertEquals(\"float -> Float.class\",\n+            Float.class, ClassUtils.primitiveToWrapper(Float.TYPE));\n+        \n+        // test a few other classes\n+        assertEquals(\"String.class -> String.class\",\n+            String.class, ClassUtils.primitiveToWrapper(String.class));\n+        assertEquals(\"ClassUtils.class -> ClassUtils.class\",\n+            org.apache.commons.lang.ClassUtils.class, \n+            ClassUtils.primitiveToWrapper(org.apache.commons.lang.ClassUtils.class));\n+        assertEquals(\"Void.TYPE -> Void.TYPE\",\n+            Void.TYPE, ClassUtils.primitiveToWrapper(Void.TYPE));\n+            \n+        // test null     \n+        assertNull(\"null -> null\",\n+            ClassUtils.primitiveToWrapper(null));\n+    }\n+\n+    public void testPrimitivesToWrappers() {\n+        // test null\n+        assertNull(\"null -> null\",\n+            ClassUtils.primitivesToWrappers(null));\n+        // test empty array\n+        assertEquals(\"empty -> empty\",\n+                ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers(ArrayUtils.EMPTY_CLASS_ARRAY));\n+\n+        // test an array of various classes\n+        final Class[] primitives = new Class[] {\n+                Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, \n+                Integer.TYPE, Long.TYPE, Double.TYPE, Float.TYPE,\n+                String.class, ClassUtils.class\n+        };\n+        Class[] wrappers= ClassUtils.primitivesToWrappers(primitives);\n+        \n+        for (int i=0; i < primitives.length; i++) {\n+            // test each returned wrapper\n+            Class primitive = primitives[i];\n+            Class expectedWrapper = ClassUtils.primitiveToWrapper(primitive);\n+            \n+            assertEquals(primitive + \" -> \" + expectedWrapper, expectedWrapper, wrappers[i]);\n+        }\n+\n+        // test an array of no primitive classes\n+        final Class[] noPrimitives = new Class[] {\n+                String.class, ClassUtils.class, Void.TYPE\n+        };\n+        // This used to return the exact same array, but no longer does.\n+        assertNotSame(\"unmodified\", noPrimitives, ClassUtils.primitivesToWrappers(noPrimitives));\n+    }\n+\n+    public void testGetClassClassNotFound() throws Exception {\n+        assertGetClassThrowsClassNotFound( \"bool\" );\n+        assertGetClassThrowsClassNotFound( \"bool[]\" );\n+        assertGetClassThrowsClassNotFound( \"integer[]\" );\n+    }\n+\n+    public void testGetClassInvalidArguments() throws Exception {\n+        assertGetClassThrowsIllegalArgument( null );\n+        assertGetClassThrowsClassNotFound( \"[][][]\" );\n+        assertGetClassThrowsClassNotFound( \"[[]\" );\n+        assertGetClassThrowsClassNotFound( \"[\" );\n+        assertGetClassThrowsClassNotFound( \"java.lang.String][\" );\n+        assertGetClassThrowsClassNotFound( \".hello.world\" );\n+        assertGetClassThrowsClassNotFound( \"hello..world\" );\n+    }\n+\n+    public void testWithInterleavingWhitespace() throws ClassNotFoundException {\n+        assertEquals( int[].class, ClassUtils.getClass( \" int [ ] \" ) );\n+        assertEquals( long[].class, ClassUtils.getClass( \"\\rlong\\t[\\n]\\r\" ) );\n+        assertEquals( short[].class, ClassUtils.getClass( \"\\tshort                \\t\\t[]\" ) );\n+        assertEquals( byte[].class, ClassUtils.getClass( \"byte[\\t\\t\\n\\r]   \" ) );\n+    }\n+\n+    public void testGetClassByNormalNameArrays() throws ClassNotFoundException {\n+        assertEquals( int[].class, ClassUtils.getClass( \"int[]\" ) );\n+        assertEquals( long[].class, ClassUtils.getClass( \"long[]\" ) );\n+        assertEquals( short[].class, ClassUtils.getClass( \"short[]\" ) );\n+        assertEquals( byte[].class, ClassUtils.getClass( \"byte[]\" ) );\n+        assertEquals( char[].class, ClassUtils.getClass( \"char[]\" ) );\n+        assertEquals( float[].class, ClassUtils.getClass( \"float[]\" ) );\n+        assertEquals( double[].class, ClassUtils.getClass( \"double[]\" ) );\n+        assertEquals( boolean[].class, ClassUtils.getClass( \"boolean[]\" ) );\n+        assertEquals( String[].class, ClassUtils.getClass( \"java.lang.String[]\" ) );\n+    }\n+\n+    public void testGetClassByNormalNameArrays2D() throws ClassNotFoundException {\n+        assertEquals( int[][].class, ClassUtils.getClass( \"int[][]\" ) );\n+        assertEquals( long[][].class, ClassUtils.getClass( \"long[][]\" ) );\n+        assertEquals( short[][].class, ClassUtils.getClass( \"short[][]\" ) );\n+        assertEquals( byte[][].class, ClassUtils.getClass( \"byte[][]\" ) );\n+        assertEquals( char[][].class, ClassUtils.getClass( \"char[][]\" ) );\n+        assertEquals( float[][].class, ClassUtils.getClass( \"float[][]\" ) );\n+        assertEquals( double[][].class, ClassUtils.getClass( \"double[][]\" ) );\n+        assertEquals( boolean[][].class, ClassUtils.getClass( \"boolean[][]\" ) );\n+        assertEquals( String[][].class, ClassUtils.getClass( \"java.lang.String[][]\" ) );\n+    }\n+\n+    public void testGetClassWithArrayClasses2D() throws Exception {\n+        assertGetClassReturnsClass( String[][].class );\n+        assertGetClassReturnsClass( int[][].class );\n+        assertGetClassReturnsClass( long[][].class );\n+        assertGetClassReturnsClass( short[][].class );\n+        assertGetClassReturnsClass( byte[][].class );\n+        assertGetClassReturnsClass( char[][].class );\n+        assertGetClassReturnsClass( float[][].class );\n+        assertGetClassReturnsClass( double[][].class );\n+        assertGetClassReturnsClass( boolean[][].class );\n+    }\n+\n+    public void testGetClassWithArrayClasses() throws Exception {\n+        assertGetClassReturnsClass( String[].class );\n+        assertGetClassReturnsClass( int[].class );\n+        assertGetClassReturnsClass( long[].class );\n+        assertGetClassReturnsClass( short[].class );\n+        assertGetClassReturnsClass( byte[].class );\n+        assertGetClassReturnsClass( char[].class );\n+        assertGetClassReturnsClass( float[].class );\n+        assertGetClassReturnsClass( double[].class );\n+        assertGetClassReturnsClass( boolean[].class );\n+    }\n+\n+    public void testGetClassRawPrimitives() throws ClassNotFoundException {\n+        assertEquals( int.class, ClassUtils.getClass( \"int\" ) );\n+        assertEquals( long.class, ClassUtils.getClass( \"long\" ) );\n+        assertEquals( short.class, ClassUtils.getClass( \"short\" ) );\n+        assertEquals( byte.class, ClassUtils.getClass( \"byte\" ) );\n+        assertEquals( char.class, ClassUtils.getClass( \"char\" ) );\n+        assertEquals( float.class, ClassUtils.getClass( \"float\" ) );\n+        assertEquals( double.class, ClassUtils.getClass( \"double\" ) );\n+        assertEquals( boolean.class, ClassUtils.getClass( \"boolean\" ) );\n+    }\n+\n+    private void assertGetClassReturnsClass( Class c ) throws Exception {\n+        assertEquals( c, ClassUtils.getClass( c.getName() ) );\n+    }\n+\n+    private void assertGetClassThrowsException( String className, Class exceptionType ) throws Exception {\n+        try {\n+            ClassUtils.getClass( className );\n+            fail( \"ClassUtils.getClass() should fail with an exception of type \" + exceptionType.getName() + \" when given class name \\\"\" + className + \"\\\".\" );\n+        }\n+        catch( Exception e ) {\n+            assertTrue( exceptionType.isAssignableFrom( e.getClass() ) );\n+        }\n+    }\n+\n+    private void assertGetClassThrowsIllegalArgument( String className ) throws Exception {\n+        assertGetClassThrowsException( className, IllegalArgumentException.class );\n+    }\n+\n+    private void assertGetClassThrowsClassNotFound( String className ) throws Exception {\n+        assertGetClassThrowsException( className, ClassNotFoundException.class );\n+    }\n+\n+    /**\n+     * Creates a new instance of URLClassLoader with the system class loader's URLs and a <code>null</code> parent\n+     * class loader.\n+     * \n+     * @see ClassLoader#getSystemClassLoader()\n+     * @see URLClassLoader#newInstance(URL[], ClassLoader)\n+     * @return the resulting class loader\n+     */\n+    public static ClassLoader newSystemClassLoader() throws SecurityException, IllegalArgumentException {\n+        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n+        ClassLoader myClassLoader = ClassUtilsTest.class.getClassLoader();\n+        if (!(myClassLoader instanceof URLClassLoader)) {\n+            fail(\"Need a better test set up.\");\n+        }\n+        if (!(systemClassLoader instanceof URLClassLoader)) {\n+            fail(\"Need a better test set up.\");\n+        }\n+        if (!myClassLoader.equals(systemClassLoader)) {\n+            fail(\"Need a better test set up?\");            \n+        }\n+        URLClassLoader urlScl = (URLClassLoader) myClassLoader;\n+        return URLClassLoader.newInstance(urlScl.getURLs(), null);\n+    }\n+\n+    // Show the Java bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957\n+    // We may have to delete this if a JDK fixes the bug.\n+    public void testShowJavaBug() throws Exception {\n+        // Tests with Collections$UnmodifiableSet\n+        Set set = Collections.unmodifiableSet(new HashSet());\n+        Method isEmptyMethod = set.getClass().getMethod(\"isEmpty\",  new Class[0]);\n+        try {\n+            isEmptyMethod.invoke(set, new Object[0]);\n+            fail(\"Failed to throw IllegalAccessException as expected\");\n+        } catch(IllegalAccessException iae) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetPublicMethod() throws Exception {\n+        // Tests with Collections$UnmodifiableSet\n+        Set set = Collections.unmodifiableSet(new HashSet());\n+        Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n+            assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers()));\n+ \n+        try {\n+            isEmptyMethod.invoke(set, new Object[0]);\n+        } catch(java.lang.IllegalAccessException iae) {\n+            fail(\"Should not have thrown IllegalAccessException\");\n+        }\n+               \n+        // Tests with a public Class\n+        Method toStringMethod = ClassUtils.getPublicMethod(Object.class, \"toString\",  new Class[0]);\n+            assertEquals(Object.class.getMethod(\"toString\", new Class[0]), toStringMethod);\n+    }\n+ \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/EntitiesPerformanceTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+public class EntitiesPerformanceTest extends TestCase {\n+    private int COUNT = 10000;\n+    private int STRING_LENGTH = 1000;\n+\n+    private static String stringWithUnicode;\n+    private static String stringWithEntities;\n+    private static Entities treeEntities;\n+    private static Entities hashEntities;\n+    private static Entities arrayEntities;\n+    private static Entities binaryEntities;\n+    private static Entities primitiveEntities;\n+    private static Entities lookupEntities;\n+\n+    public EntitiesPerformanceTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EntitiesPerformanceTest.class);\n+        return suite;\n+    }\n+\n+    public void setUp() {\n+        if (stringWithUnicode == null) {\n+            StringBuffer buf = new StringBuffer(STRING_LENGTH);\n+            for (int i = 0; i < STRING_LENGTH / 5; ++i) {\n+                buf.append(\"xxxx\");\n+                char ch = isovalue(i);\n+                buf.append(ch);\n+            }\n+            stringWithUnicode = buf.toString();\n+            stringWithEntities = Entities.HTML40.unescape(stringWithUnicode);\n+        }\n+    }\n+\n+    private char html40value(int i) {\n+        String entityValue = Entities.HTML40_ARRAY[i % Entities.HTML40_ARRAY.length][1];\n+        char ch = (char) Integer.parseInt(entityValue);\n+        return ch;\n+    }\n+\n+    private char isovalue(int i) {\n+        String entityValue = Entities.ISO8859_1_ARRAY[i % Entities.ISO8859_1_ARRAY.length][1];\n+        char ch = (char) Integer.parseInt(entityValue);\n+        return ch;\n+    }\n+\n+    public void testBuildHash() throws Exception {\n+        for (int i = 0; i < COUNT; ++i) {\n+            hashEntities = build(new Entities.HashEntityMap());\n+        }\n+    }\n+\n+\n+    public void testBuildTree() throws Exception {\n+        for (int i = 0; i < COUNT; ++i) {\n+            treeEntities = build(new Entities.TreeEntityMap());\n+        }\n+    }\n+\n+    public void testBuildArray() throws Exception {\n+        for (int i = 0; i < COUNT; ++i) {\n+            arrayEntities = build(new Entities.ArrayEntityMap());\n+        }\n+    }\n+\n+    public void testBuildBinary() throws Exception {\n+        for (int i = 0; i < COUNT; ++i) {\n+            binaryEntities = build(new Entities.BinaryEntityMap());\n+        }\n+    }\n+\n+    public void testBuildPrimitive() throws Exception {\n+        for (int i = 0; i < COUNT; ++i) {\n+            buildPrimitive();\n+        }\n+    }\n+\n+    private void buildPrimitive()\n+    {\n+        primitiveEntities = build(new Entities.PrimitiveEntityMap());\n+    }\n+\n+    public void testBuildLookup() throws Exception {\n+        for (int i = 0; i < COUNT; ++i) {\n+            buildLookup();\n+        }\n+    }\n+\n+    private void buildLookup()\n+    {\n+        lookupEntities = build(new Entities.LookupEntityMap());\n+    }\n+\n+    private Entities build(Entities.EntityMap intMap) {\n+        Entities entities;\n+        entities = new Entities();\n+        entities.map = intMap;\n+        Entities.fillWithHtml40Entities(entities);\n+        return entities;\n+    }\n+\n+    public void testLookupHash() throws Exception {\n+        lookup(hashEntities);\n+    }\n+\n+    public void testLookupTree() throws Exception {\n+        lookup(treeEntities);\n+    }\n+\n+    public void testLookupArray() throws Exception {\n+        lookup(arrayEntities);\n+    }\n+\n+    public void testLookupBinary() throws Exception {\n+        lookup(binaryEntities);\n+    }\n+\n+    public void testLookupPrimitive() throws Exception {\n+        if (primitiveEntities == null) buildPrimitive();\n+        lookup(primitiveEntities);\n+    }\n+\n+    public void testLookupLookup() throws Exception {\n+        if (lookupEntities == null) buildLookup();\n+        lookup(lookupEntities);\n+    }\n+\n+    public void testEscapeHash() throws Exception {\n+        escapeIt(hashEntities);\n+    }\n+\n+    public void testEscapeTree() throws Exception {\n+        escapeIt(treeEntities);\n+    }\n+\n+    public void testEscapeArray() throws Exception {\n+        escapeIt(arrayEntities);\n+    }\n+\n+    public void testEscapeBinary() throws Exception {\n+        escapeIt(binaryEntities);\n+    }\n+\n+    public void testEscapePrimitive() throws Exception {\n+        escapeIt(primitiveEntities);\n+    }\n+\n+    public void testEscapeLookup() throws Exception {\n+        escapeIt(lookupEntities);\n+    }\n+\n+    public void testUnescapeHash() throws Exception {\n+        unescapeIt(hashEntities);\n+    }\n+\n+    public void testUnescapeTree() throws Exception {\n+        unescapeIt(treeEntities);\n+    }\n+\n+    public void testUnescapeArray() throws Exception {\n+        unescapeIt(arrayEntities);\n+    }\n+\n+    public void testUnescapeBinary() throws Exception {\n+        unescapeIt(binaryEntities);\n+    }\n+\n+    private void lookup(Entities entities) {\n+        for (int i = 0; i < COUNT * 1000; ++i) {\n+            entities.entityName(isovalue(i));\n+        }\n+    }\n+\n+    private void escapeIt(Entities entities) {\n+        for (int i = 0; i < COUNT; ++i) {\n+            String escaped = entities.escape(stringWithUnicode);\n+            assertEquals(\"xxxx&nbsp;\", escaped.substring(0, 10));\n+        }\n+    }\n+\n+    private void unescapeIt(Entities entities) {\n+        for (int i = 0; i < COUNT; ++i) {\n+            String unescaped = entities.unescape(stringWithEntities);\n+            assertEquals(\"xxxx\\u00A0\", unescaped.substring(0, 5));\n+        }\n+    }\n+\n+\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/EntitiesTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.StringWriter;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link StringEscapeUtils}.\n+ *\n+ * @author of original StringUtilsTest.testEscape = ?\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class EntitiesTest extends TestCase\n+{\n+    public EntitiesTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EntitiesTest.class);\n+        suite.setName(\"EntitiesTest Tests\");\n+        return suite;\n+    }\n+\n+    Entities entities;\n+\n+    public void setUp()\n+    {\n+        entities = new Entities();\n+        entities.addEntity(\"foo\", 161);\n+        entities.addEntity(\"bar\", 162);\n+    }\n+\n+    public void testEscapeNamedEntity() throws Exception\n+    {\n+        doTestEscapeNamedEntity(\"&foo;\", \"\\u00A1\");\n+        doTestEscapeNamedEntity(\"x&foo;\", \"x\\u00A1\");\n+        doTestEscapeNamedEntity(\"&foo;x\", \"\\u00A1x\");\n+        doTestEscapeNamedEntity(\"x&foo;x\", \"x\\u00A1x\");\n+        doTestEscapeNamedEntity(\"&foo;&bar;\", \"\\u00A1\\u00A2\");\n+    }\n+\n+    private void doTestEscapeNamedEntity(final String expected, final String entity) throws Exception\n+    {\n+        assertEquals(expected, entities.escape(entity));\n+        StringWriter writer = new StringWriter();\n+        entities.escape(writer, entity);\n+        assertEquals(expected, writer.toString());\n+    }\n+    \n+    public void testUnescapeNamedEntity() throws Exception\n+    {\n+        assertEquals(\"\\u00A1\", entities.unescape(\"&foo;\"));\n+        assertEquals(\"x\\u00A1\", entities.unescape(\"x&foo;\"));\n+        assertEquals(\"\\u00A1x\", entities.unescape(\"&foo;x\"));\n+        assertEquals(\"x\\u00A1x\", entities.unescape(\"x&foo;x\"));\n+        assertEquals(\"\\u00A1\\u00A2\", entities.unescape(\"&foo;&bar;\"));\n+    }\n+\n+    public void testUnescapeUnknownEntity() throws Exception\n+    {\n+        doTestUnescapeEntity(\"&zzzz;\", \"&zzzz;\");\n+    }\n+\n+    public void testUnescapeMiscellaneous() throws Exception\n+    {\n+      doTestUnescapeEntity(\"&hello\", \"&hello\");\n+      doTestUnescapeEntity(\"&;\", \"&;\");\n+      doTestUnescapeEntity(\"&#;\", \"&#;\");\n+      doTestUnescapeEntity(\"&#invalid;\", \"&#invalid;\");\n+      doTestUnescapeEntity(\"A\", \"&#X41;\");\n+    }\n+    \n+    private void doTestUnescapeEntity(final String expected, final String entity) throws Exception\n+    {\n+        assertEquals(expected, entities.unescape(entity));\n+        StringWriter writer = new StringWriter();\n+        entities.unescape(writer, entity);\n+        assertEquals(expected, writer.toString());\n+    }\n+    \n+    public void testAddEntitiesArray() throws Exception\n+    {\n+        String[][] array = {{\"foo\", \"100\"}, {\"bar\", \"101\"}};\n+        Entities e = new Entities();\n+        e.addEntities(array);\n+        assertEquals(\"foo\", e.entityName(100));\n+        assertEquals(\"bar\", e.entityName(101));\n+        assertEquals(100, e.entityValue(\"foo\"));\n+        assertEquals(101, e.entityValue(\"bar\"));\n+    }\n+\n+    public void testEntitiesXmlObject() throws Exception\n+    {\n+        assertEquals(\"gt\", Entities.XML.entityName('>'));\n+        assertEquals('>', Entities.XML.entityValue(\"gt\"));\n+        assertEquals(-1, Entities.XML.entityValue(\"xyzzy\"));\n+    }\n+\n+    public void testArrayIntMap() throws Exception\n+    {\n+        Entities.ArrayEntityMap map = new Entities.ArrayEntityMap(2);\n+        checkSomeEntityMap(map);\n+        Entities.ArrayEntityMap map1 = new Entities.ArrayEntityMap();\n+        checkSomeEntityMap(map1);\n+        assertEquals(-1, map.value(\"null\"));\n+        assertNull(map.name(-1));\n+    }\n+\n+    public void testTreeIntMap() throws Exception\n+    {\n+        Entities.EntityMap map = new Entities.TreeEntityMap();\n+        checkSomeEntityMap(map);\n+    }\n+\n+    public void testHashIntMap() throws Exception\n+    {\n+        Entities.EntityMap map = new Entities.HashEntityMap();\n+        checkSomeEntityMap(map);\n+        assertEquals(-1, map.value(\"noname\"));\n+    }\n+\n+    public void testBinaryIntMap() throws Exception\n+    {\n+        Entities.BinaryEntityMap map = new Entities.BinaryEntityMap(2);\n+        checkSomeEntityMap(map);\n+        Entities.BinaryEntityMap map1 = new Entities.BinaryEntityMap();\n+        checkSomeEntityMap(map1);\n+        \n+        // value cannot be added twice\n+        map1.add(\"baz4a\", 4);\n+        map1.add(\"baz4b\", 4);\n+        assertEquals(-1, map1.value(\"baz4b\"));\n+        assertEquals(\"baz4a\", map1.name(4));\n+        assertNull(map1.name(99));\n+        \n+        Entities.BinaryEntityMap map2 = new Entities.BinaryEntityMap();\n+        map2.add(\"val1\", 1);\n+        map2.add(\"val2\", 2);\n+        map2.add(\"val3\", 3);\n+        map2.add(\"val4\", 4);\n+        map2.add(\"val5\", 5);\n+        assertEquals(\"val5\", map2.name(5));\n+        assertEquals(\"val4\", map2.name(4));\n+        assertEquals(\"val3\", map2.name(3));\n+        assertEquals(\"val2\", map2.name(2));\n+        assertEquals(\"val1\", map2.name(1));\n+    }\n+\n+    public void testPrimitiveIntMap() throws Exception\n+    {\n+        Entities.PrimitiveEntityMap map = new Entities.PrimitiveEntityMap();\n+        checkSomeEntityMap(map);\n+    }\n+\n+    private void checkSomeEntityMap(Entities.EntityMap map) {\n+        map.add(\"foo\", 1);\n+        assertEquals(1, map.value(\"foo\"));\n+        assertEquals(\"foo\", map.name(1));\n+        map.add(\"bar\", 2);\n+        map.add(\"baz\", 3);\n+        assertEquals(3, map.value(\"baz\"));\n+        assertEquals(\"baz\", map.name(3));\n+    }\n+    \n+    public void testHtml40Nbsp() throws Exception\n+    {\n+        assertEquals(\"&nbsp;\", Entities.HTML40.escape(\"\\u00A0\"));\n+        Entities e = new Entities();\n+        e.map = new Entities.PrimitiveEntityMap();\n+        Entities.fillWithHtml40Entities(e);\n+        assertEquals(\"&nbsp;\", e.escape(\"\\u00A0\"));\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/IllegalClassExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @author Matthew Hawthorne\n+ * @version $Id$\n+ * @see IllegalClassException\n+ */\n+public class IllegalClassExceptionTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(IllegalClassExceptionTest.class);\n+    }\n+\n+    public IllegalClassExceptionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    // testConstructor_classArgs\n+\n+    public void testConstructor_classArgs_allNullInput() {\n+        new IllegalClassException(null, null);\n+    }\n+\n+    public void testConstructor_classArgs_nullExpected() {\n+        new IllegalClassException(null, String.class);\n+    }\n+\n+    public void testConstructor_classArgs_nullActual() {\n+        new IllegalClassException(String.class, null);\n+    }\n+\n+    //  testConstructor_stringArg\n+\n+    public void testConstructor_stringArg_nullInput() {\n+        new IllegalClassException(null);\n+    }\n+\n+    // testConstructor_classObjectArgs\n+\n+    public void testConstructor_classObjectArgs_allNullInput() {\n+        new IllegalClassException(null, (Object) null);\n+    }\n+\n+    public void testConstructor_classObjectArgs_nullExpected() {\n+        new IllegalClassException(null, new Object());\n+    }\n+\n+    public void testConstructor_classObjectArgs_nullActual() {\n+        new IllegalClassException(String.class, (Object) null);\n+    }\n+\n+    // testGetMessage\n+\n+    public void testGetMessage_classArgs_nullInput() {\n+        final Throwable t = new IllegalClassException(null, null);\n+        assertEquals(\"Expected: null, actual: null\", t.getMessage());\n+    }\n+\n+    public void testGetMessage_classArgs_normalInput() {\n+        final Throwable t =\n+            new IllegalClassException(String.class, Integer.class);\n+        assertEquals(\n+            \"Expected: java.lang.String, actual: java.lang.Integer\",\n+            t.getMessage());\n+    }\n+\n+    public void testGetMessage_classObjectArgs_nullInput() {\n+        final Throwable t = new IllegalClassException(null, (Object) null);\n+        assertEquals(\"Expected: null, actual: null\", t.getMessage());\n+    }\n+\n+    public void testGetMessage_classObjectArgs_normalInput() {\n+        final Throwable t =\n+            new IllegalClassException(String.class, new Object());\n+        assertEquals(\n+            \"Expected: java.lang.String, actual: java.lang.Object\",\n+            t.getMessage());\n+    }\n+\n+    public void testGetMessage_stringArg_nullInput() {\n+        final Throwable t = new IllegalClassException(null);\n+        assertEquals(null, t.getMessage());\n+    }\n+\n+    public void testGetMessage_stringArg_validInput() {\n+        final String message = \"message\";\n+        final Throwable t = new IllegalClassException(message);\n+        assertEquals(message, t.getMessage());\n+    }\n+\n+} // IllegalClassExceptionTest\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/IncompleteArgumentExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @author Matthew Hawthorne\n+ * @version $Id$\n+ * @see IncompleteArgumentException\n+ */\n+public class IncompleteArgumentExceptionTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(IncompleteArgumentExceptionTest.class);\n+    }\n+\n+    public IncompleteArgumentExceptionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    // testConstructor\n+\n+    public void test1arg_nullInput() {\n+        final Throwable t = new IncompleteArgumentException(null);\n+        assertEquals(\"null is incomplete.\", t.getMessage());\n+    }\n+\n+    public void test1arg_validInput() {\n+        final String name = \"argument\";\n+        final Throwable t = new IncompleteArgumentException(name);\n+        assertEquals(name + \" is incomplete.\", t.getMessage());\n+    }\n+\n+    public void test2arg_allNullInput() {\n+        final Throwable t = new IncompleteArgumentException(null, null);\n+        assertEquals(\n+            \"null is missing the following items: null\",\n+            t.getMessage());\n+    }\n+\n+    public void test2arg_nullString() {\n+        final Throwable t =\n+            new IncompleteArgumentException(\n+                null,\n+                new String[] { \"one\", \"two\" });\n+        assertEquals(\n+            \"null is missing the following items: [one, two]\",\n+            t.getMessage());\n+    }\n+\n+    public void test2arg_nullArray() {\n+        final String name = \"one\";\n+        final Throwable t = new IncompleteArgumentException(name, null);\n+        assertEquals(\n+            name + \" is missing the following items: null\",\n+            t.getMessage());\n+    }\n+\n+    public void test2arg_validInput() {\n+        final String name = \"input\";\n+        final Throwable t =\n+            new IncompleteArgumentException(\n+                name,\n+                new String[] { \"one\", \"two\" });\n+        assertEquals(\n+            name + \" is missing the following items: [one, two]\",\n+            t.getMessage());\n+    }\n+\n+} // IncompleteArgumentExceptionTest\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/IntHashMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests for the IntHashMap class.\n+ *\n+ * @author  Steven Caswell\n+ * @version $Id$\n+ */\n+public class IntHashMapTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(IntHashMapTest.class);\n+        suite.setName(\"IntHashMapTest Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructor() {\n+        try {\n+            new IntHashMap(-1, 0.0f);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Illegal Capacity: -1\", e.getMessage());\n+        }\n+        try {\n+            new IntHashMap(1, 0.0f);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Illegal Load: 0.0\", e.getMessage());\n+        }\n+        new IntHashMap(0, 1.0f);\n+        \n+        try {\n+            new IntHashMap(-1);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+           assertEquals(\"Illegal Capacity: -1\", e.getMessage());\n+        }\n+        IntHashMap map1 = new IntHashMap(0);\n+        assertEquals(0, map1.size());\n+    }\n+    \n+    public void testClear() {\n+        IntHashMap map = new IntHashMap();\n+        assertNull(map.put(1, \"hello\"));\n+        assertNull(map.put(2, \"world\"));\n+        assertEquals(2, map.size());\n+        map.clear();\n+        assertEquals(0, map.size());\n+    }\n+  \n+    public void testContainsKey() {\n+        IntHashMap map = new IntHashMap();\n+        assertNull(map.put(1, \"hello\"));\n+        assertNull(map.put(2, \"world\"));\n+        assertEquals(2, map.size());\n+        assertTrue(map.containsKey(1));\n+        assertTrue(map.containsKey(2));\n+        assertFalse(map.containsKey(3));\n+    }\n+\n+    public void testContains() {\n+        IntHashMap map = new IntHashMap();\n+        assertNull(map.put(1, \"hello\"));\n+        assertNull(map.put(2, \"world\"));\n+        assertEquals(2, map.size());\n+        assertTrue(map.containsValue(\"hello\"));\n+        assertTrue(map.containsValue(\"world\"));\n+        assertFalse(map.containsValue(\"goodbye\"));\n+        try {\n+            map.containsValue(null);\n+            fail();\n+        } catch(NullPointerException e) {\n+      }\n+    }\n+\n+    public void testContainsValue() {\n+        IntHashMap map = new IntHashMap();\n+        assertNull(map.put(1, \"hello\"));\n+        assertNull(map.put(2, \"world\"));\n+        assertEquals(2, map.size());\n+        assertTrue(map.containsValue(\"hello\"));\n+        assertTrue(map.containsValue(\"world\"));\n+        assertFalse(map.containsValue(\"goodbye\"));\n+        try {\n+            map.containsValue(null);\n+            fail();\n+        } catch(NullPointerException e) {\n+        }\n+    }\n+\n+    public void testIsEmpty() {\n+        IntHashMap map = new IntHashMap();\n+        assertTrue(map.isEmpty());\n+        assertNull(map.put(1, \"hello\"));\n+        assertEquals(1, map.size());\n+        assertFalse(map.isEmpty());\n+    }\n+  \n+    public void testPut() {\n+        IntHashMap map = new IntHashMap();\n+        assertNull(map.put(1, \"hello\"));\n+        assertNull(map.put(2, \"world\"));\n+        assertEquals(2, map.size());\n+        assertEquals(\"hello\", map.put(1, \"hellooooo\"));\n+    }\n+    \n+    public void testRemove() {\n+        IntHashMap map = new IntHashMap();\n+        assertNull(map.put(1, \"hello\"));\n+        assertNull(map.put(2, \"world\"));\n+        assertEquals(2, map.size());\n+        assertEquals(\"hello\", map.remove(1));\n+        assertEquals(1, map.size());\n+        assertNull(map.remove(3));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/LangTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test suite for the Lang package.\n+ *\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Matthew Hawthorne\n+ * @version $Id$\n+ */\n+public class LangTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public LangTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang Tests\");\n+        suite.addTest(ArrayUtilsTest.suite());\n+        suite.addTest(ArrayUtilsAddTest.suite());\n+        suite.addTest(ArrayUtilsRemoveTest.suite());\n+        suite.addTest(BitFieldTest.suite());\n+        suite.addTest(BooleanUtilsTest.suite());\n+        suite.addTest(CharEncodingTest.suite());\n+        suite.addTest(CharRangeTest.suite());\n+        suite.addTest(CharSetTest.suite());\n+        suite.addTest(CharSetUtilsTest.suite());\n+        suite.addTest(CharUtilsTest.suite());\n+        suite.addTest(ClassUtilsTest.suite());\n+        suite.addTest(EntitiesTest.suite());\n+        suite.addTest(IllegalClassExceptionTest.suite());\n+        suite.addTest(IncompleteArgumentExceptionTest.suite());\n+        suite.addTest(IntHashMapTest.suite());\n+        suite.addTest(LocaleUtilsTest.suite());\n+        suite.addTest(NotImplementedExceptionTest.suite());\n+        suite.addTest(NullArgumentExceptionTest.suite());\n+        suite.addTest(NumberRangeTest.suite());\n+        suite.addTest(NumberUtilsTest.suite());\n+        suite.addTest(ObjectUtilsTest.suite());\n+        suite.addTest(RandomStringUtilsTest.suite());\n+        suite.addTest(SerializationUtilsTest.suite());\n+        suite.addTest(StringUtilsTest.suite());\n+        suite.addTest(StringUtilsTrimEmptyTest.suite());\n+        suite.addTest(StringUtilsSubstringTest.suite());\n+        suite.addTest(StringUtilsEqualsIndexOfTest.suite());\n+        suite.addTest(StringUtilsIsTest.suite());\n+        suite.addTest(StringEscapeUtilsTest.suite());\n+        suite.addTest(SystemUtilsTest.suite());\n+        suite.addTest(UnhandledExceptionTest.suite());\n+        suite.addTest(ValidateTest.suite());\n+        suite.addTest(WordUtilsTest.suite());\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/LocaleUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link LocaleUtils}.\n+ *\n+ * @author Chris Hyzer\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class LocaleUtilsTest extends TestCase {\n+\n+    private static final Locale LOCALE_EN = new Locale(\"en\", \"\");\n+    private static final Locale LOCALE_EN_US = new Locale(\"en\", \"US\");\n+    private static final Locale LOCALE_EN_US_ZZZZ = new Locale(\"en\", \"US\", \"ZZZZ\");\n+    private static final Locale LOCALE_FR = new Locale(\"fr\", \"\");\n+    private static final Locale LOCALE_FR_CA = new Locale(\"fr\", \"CA\");\n+    private static final Locale LOCALE_QQ = new Locale(\"qq\", \"\");\n+    private static final Locale LOCALE_QQ_ZZ = new Locale(\"qq\", \"ZZ\");\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param name\n+     */\n+    public LocaleUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Main.\n+     * @param args\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Run the test cases as a suite.\n+     * @return the Test\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LocaleUtilsTest.class);\n+        suite.setName(\"LocaleUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that constructors are public, and work, etc.\n+     */\n+    public void testConstructor() {\n+        assertNotNull(new LocaleUtils());\n+        Constructor[] cons = LocaleUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(LocaleUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(LocaleUtils.class.getModifiers()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param language  the language string\n+     */\n+    private void assertValidToLocale(String language) {\n+        Locale locale = LocaleUtils.toLocale(language);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        //country and variant are empty\n+        assertTrue(locale.getCountry() == null || locale.getCountry().length() == 0);\n+        assertTrue(locale.getVariant() == null || locale.getVariant().length() == 0);\n+    }\n+\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param localeString to pass to toLocale()\n+     * @param language of the resulting Locale\n+     * @param country of the resulting Locale\n+     */\n+    private void assertValidToLocale(String localeString, String language, String country) {\n+        Locale locale = LocaleUtils.toLocale(localeString);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        assertEquals(country, locale.getCountry());\n+        //variant is empty\n+        assertTrue(locale.getVariant() == null || locale.getVariant().length() == 0);\n+    }\n+\n+    /**\n+     * Pass in a valid language, test toLocale.\n+     *\n+     * @param localeString to pass to toLocale()\n+     * @param language of the resulting Locale\n+     * @param country of the resulting Locale\n+     * @param variant of the resulting Locale\n+     */\n+    private void assertValidToLocale(\n+            String localeString, String language, \n+            String country, String variant) {\n+        Locale locale = LocaleUtils.toLocale(localeString);\n+        assertNotNull(\"valid locale\", locale);\n+        assertEquals(language, locale.getLanguage());\n+        assertEquals(country, locale.getCountry());\n+        assertEquals(variant, locale.getVariant());\n+        \n+    }\n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_1Part() {\n+        assertEquals(null, LocaleUtils.toLocale((String) null));\n+        \n+        assertValidToLocale(\"us\");\n+        assertValidToLocale(\"fr\");\n+        assertValidToLocale(\"de\");\n+        assertValidToLocale(\"zh\");\n+        // Valid format but lang doesnt exist, should make instance anyway\n+        assertValidToLocale(\"qq\");\n+        \n+        try {\n+            LocaleUtils.toLocale(\"Us\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"US\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uS\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"u#\");\n+            fail(\"Should fail if not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        \n+        try {\n+            LocaleUtils.toLocale(\"u\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+       \n+        try {\n+            LocaleUtils.toLocale(\"uuu\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+\n+        try {\n+            LocaleUtils.toLocale(\"uu_U\");\n+            fail(\"Must be 2 chars if less than 5\");\n+        } catch (IllegalArgumentException iae) {}\n+    }        \n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_2Part() {\n+        assertValidToLocale(\"us_EN\", \"us\", \"EN\");\n+        //valid though doesnt exist\n+        assertValidToLocale(\"us_ZH\", \"us\", \"ZH\");\n+        \n+        try {\n+            LocaleUtils.toLocale(\"us-EN\");\n+            fail(\"Should fail as not underscore\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_En\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_en\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_eN\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uS_EN\");\n+            fail(\"Should fail first part not lowercase\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"us_E3\");\n+            fail(\"Should fail second part not uppercase\");\n+        } catch (IllegalArgumentException iae) {}\n+    }        \n+\n+    /**\n+     * Test toLocale() method.\n+     */\n+    public void testToLocale_3Part() {\n+        assertValidToLocale(\"us_EN_A\", \"us\", \"EN\", \"A\");\n+        // this isn't pretty, but was caused by a jdk bug it seems\n+        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525\n+        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"a\");\n+            assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFsafdFDsdfF\");\n+        } else {\n+            assertValidToLocale(\"us_EN_a\", \"us\", \"EN\", \"A\");\n+            assertValidToLocale(\"us_EN_SFsafdFDsdfF\", \"us\", \"EN\", \"SFSAFDFDSDFF\");\n+        }\n+        \n+        try {\n+            LocaleUtils.toLocale(\"us_EN-a\");\n+            fail(\"Should fail as not underscore\");\n+        } catch (IllegalArgumentException iae) {}\n+        try {\n+            LocaleUtils.toLocale(\"uu_UU_\");\n+            fail(\"Must be 3, 5 or 7+ in length\");\n+        } catch (IllegalArgumentException iae) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Helper method for local lookups.\n+     *\n+     * @param locale  the input locale\n+     * @param defaultLocale  the input default locale\n+     * @param expected  expected results\n+     */\n+    private void assertLocaleLookupList(Locale locale, Locale defaultLocale, Locale[] expected) {\n+        List localeList = defaultLocale == null ?\n+                LocaleUtils.localeLookupList(locale) :\n+                LocaleUtils.localeLookupList(locale, defaultLocale);\n+        \n+        assertEquals(expected.length, localeList.size());\n+        assertEquals(Arrays.asList(expected), localeList);\n+        assertUnmodifiableCollection(localeList);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test localeLookupList() method.\n+     */\n+    public void testLocaleLookupList_Locale() {\n+        assertLocaleLookupList(null, null, new Locale[0]);\n+        assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US, null,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+    }        \n+\n+    /**\n+     * Test localeLookupList() method.\n+     */\n+    public void testLocaleLookupList_LocaleLocale() {\n+        assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, \n+                new Locale[]{LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN, LOCALE_EN, \n+                new Locale[]{LOCALE_EN});\n+        \n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, \n+            new Locale[]{\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ,\n+            new Locale[] {\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ_ZZ});\n+        \n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ});\n+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ,\n+            new Locale[] {\n+                LOCALE_EN_US_ZZZZ,\n+                LOCALE_EN_US,\n+                LOCALE_EN,\n+                LOCALE_QQ_ZZ});\n+        assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN,\n+            new Locale[] {\n+                LOCALE_FR_CA,\n+                LOCALE_FR,\n+                LOCALE_EN});\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleList() method.\n+     */\n+    public void testAvailableLocaleList() {\n+        List list = LocaleUtils.availableLocaleList();\n+        List list2 = LocaleUtils.availableLocaleList();\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        assertUnmodifiableCollection(list);\n+        \n+        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n+        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n+        assertEquals(jdkLocaleList, list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleSet() method.\n+     */\n+    public void testAvailableLocaleSet() {\n+        Set set = LocaleUtils.availableLocaleSet();\n+        Set set2 = LocaleUtils.availableLocaleSet();\n+        assertNotNull(set);\n+        assertSame(set, set2);\n+        assertUnmodifiableCollection(set);\n+        \n+        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n+        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n+        Set jdkLocaleSet = new HashSet(jdkLocaleList);\n+        assertEquals(jdkLocaleSet, set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test availableLocaleSet() method.\n+     */\n+    public void testIsAvailableLocale() {\n+        Set set = LocaleUtils.availableLocaleSet();\n+        assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));\n+        assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));\n+        assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));\n+        assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));\n+        assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));\n+        assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));\n+        assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make sure the language by country is correct.\n+     *\n+     * @param country\n+     * @param languages array of languages that should be returned\n+     */\n+    private void assertLanguageByCountry(String country, String[] languages) {\n+        List list = LocaleUtils.languagesByCountry(country);\n+        List list2 = LocaleUtils.languagesByCountry(country);\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        assertEquals(languages.length, list.size());\n+        //search through langauges\n+        for (int i = 0; i < languages.length; i++) {\n+            Iterator iterator = list.iterator();\n+            boolean found = false;\n+            // see if it was returned by the set\n+            while (iterator.hasNext()) {\n+                Locale locale = (Locale) iterator.next();\n+                // should have an en empty variant\n+                assertTrue(locale.getVariant() == null\n+                        || locale.getVariant().length() == 0);\n+                assertEquals(country, locale.getCountry());\n+                if (languages[i].equals(locale.getLanguage())) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                fail(\"Cound not find language: \" + languages[i]\n+                        + \" for country: \" + country);\n+            }\n+        }\n+        assertUnmodifiableCollection(list);\n+    }\n+\n+    /**\n+     * Test languagesByCountry() method.\n+     */\n+    public void testLanguagesByCountry() {\n+        assertLanguageByCountry(null, new String[0]);\n+        assertLanguageByCountry(\"GB\", new String[]{\"en\"});\n+        assertLanguageByCountry(\"ZZ\", new String[0]);\n+        assertLanguageByCountry(\"CH\", new String[]{\"fr\", \"de\", \"it\"});\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make sure the language by country is correct.\n+     *\n+     * @param language\n+     * @param countries array of countries that should be returned\n+     */\n+    private void assertCountriesByLanguage(String language, String[] countries) {\n+        List list = LocaleUtils.countriesByLanguage(language);\n+        List list2 = LocaleUtils.countriesByLanguage(language);\n+        assertNotNull(list);\n+        assertSame(list, list2);\n+        assertEquals(countries.length, list.size());\n+        //search through langauges\n+        for (int i = 0; i < countries.length; i++) {\n+            Iterator iterator = list.iterator();\n+            boolean found = false;\n+            // see if it was returned by the set\n+            while (iterator.hasNext()) {\n+                Locale locale = (Locale) iterator.next();\n+                // should have an en empty variant\n+                assertTrue(locale.getVariant() == null\n+                        || locale.getVariant().length() == 0);\n+                assertEquals(language, locale.getLanguage());\n+                if (countries[i].equals(locale.getCountry())) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found) {\n+                fail(\"Cound not find language: \" + countries[i]\n+                        + \" for country: \" + language);\n+            }\n+        }\n+        assertUnmodifiableCollection(list);\n+    }\n+\n+    /**\n+     * Test languagesByCountry() method.\n+     */\n+    public void testCountriesByLanguage() {\n+        assertCountriesByLanguage(null, new String[0]);\n+        assertCountriesByLanguage(\"de\", new String[]{\"DE\", \"CH\", \"AT\", \"LU\"});\n+        assertCountriesByLanguage(\"zz\", new String[0]);\n+        assertCountriesByLanguage(\"it\", new String[]{\"IT\", \"CH\"});\n+    }\n+\n+    /**\n+     * @param coll  the collection to check\n+     */\n+    private static void assertUnmodifiableCollection(Collection coll) {\n+        try {\n+            coll.add(\"Unmodifiable\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/NotImplementedExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Constructor;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.exception.NestableException;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @author Matthew Hawthorne\n+ * @version $Id$\n+ * @see NotImplementedException\n+ */\n+public class NotImplementedExceptionTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(NotImplementedExceptionTest.class);\n+    }\n+\n+    public NotImplementedExceptionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_() {\n+        NotImplementedException ex = new NotImplementedException();\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+        assertEquals(null, ex.getCause());\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+    }\n+\n+    public void testConstructor_String1() {\n+        NotImplementedException ex = new NotImplementedException((String) null);\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+        assertEquals(null, ex.getCause());\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+    }        \n+    public void testConstructor_String2() {\n+        NotImplementedException ex = new NotImplementedException(\"msg\");\n+        assertEquals(\"msg\", ex.getMessage());\n+        assertEquals(null, ex.getCause());\n+        assertEquals(\"msg\", ex.getMessage());\n+    }\n+\n+    public void testConstructor_Throwable1() {\n+        NotImplementedException ex = new NotImplementedException((Throwable) null);\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+        assertEquals(null, ex.getCause());\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+    }        \n+    public void testConstructor_Throwable2() {\n+        Exception npe = new NullPointerException();\n+        NotImplementedException ex = new NotImplementedException(npe);\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+        assertSame(npe, ex.getCause());\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+    }\n+\n+    public void testConstructor_StringThrowable1() {\n+        NotImplementedException ex = new NotImplementedException((String) null, (Throwable) null);\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+        assertEquals(null, ex.getCause());\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+    }\n+    public void testConstructor_StringThrowable2() {\n+        Exception npe = new NullPointerException();\n+        NotImplementedException ex = new NotImplementedException(\"msg\", npe);\n+        assertEquals(\"msg\", ex.getMessage());\n+        assertSame(npe, ex.getCause());\n+        assertEquals(\"msg\", ex.getMessage());\n+    }\n+\n+    public void testConstructor_Class1() {\n+        NotImplementedException ex = new NotImplementedException((Class) null);\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+        assertEquals(null, ex.getCause());\n+        assertEquals(\"Code is not implemented\", ex.getMessage());\n+    }\n+    public void testConstructor_Class2() {\n+        NotImplementedException ex = new NotImplementedException(String.class);\n+        assertEquals(\"Code is not implemented in class java.lang.String\", ex.getMessage());\n+        assertEquals(null, ex.getCause());\n+        assertEquals(\"Code is not implemented in class java.lang.String\", ex.getMessage());\n+    }\n+\n+    public void testGetMessage_Indexed() throws Exception {\n+        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            Exception ex1 = new Exception(\"nested 2\");\n+            Constructor con = Exception.class.getConstructor(new Class[] {String.class, Throwable.class});\n+            Exception ex2 = (Exception) con.newInstance(new Object[] {\"nested 1\", ex1});\n+            NotImplementedException ex = new NotImplementedException(ex2);\n+            assertEquals(\"Code is not implemented\", ex.getMessage());\n+            assertEquals(\"Code is not implemented\", ex.getMessage(0));\n+            assertEquals(\"nested 1\", ex.getMessage(1));\n+            assertEquals(\"nested 2\", ex.getMessage(2));\n+            \n+            String[] messages = ex.getMessages();\n+            assertEquals(3, messages.length);\n+            assertEquals(\"Code is not implemented\", messages[0]);\n+            assertEquals(\"nested 1\", messages[1]);\n+            assertEquals(\"nested 2\", messages[2]);\n+        }\n+    }\n+    \n+    public void testGetThrowable() {\n+        NotImplementedException ex = new NotImplementedException(new NestableException(\"nested 1\", new NestableException(\"nested 2\")));\n+        \n+        assertEquals(3, ex.getThrowableCount());\n+        \n+        assertEquals(NotImplementedException.class, ex.getThrowable(0).getClass());\n+        assertEquals(\"Code is not implemented\", ex.getThrowable(0).getMessage());\n+        assertEquals(NestableException.class, ex.getThrowable(1).getClass());\n+        assertEquals(\"nested 1\", ex.getThrowable(1).getMessage());\n+        assertEquals(NestableException.class, ex.getThrowable(2).getClass());\n+        assertEquals(\"nested 2\", ex.getThrowable(2).getMessage());\n+        \n+        assertEquals(3, ex.getThrowables().length);\n+        assertEquals(NotImplementedException.class, ex.getThrowables()[0].getClass());\n+        assertEquals(\"Code is not implemented\", ex.getThrowables()[0].getMessage());\n+        assertEquals(NestableException.class, ex.getThrowables()[1].getClass());\n+        assertEquals(\"nested 1\", ex.getThrowables()[1].getMessage());\n+        assertEquals(NestableException.class, ex.getThrowables()[2].getClass());\n+        assertEquals(\"nested 2\", ex.getThrowables()[2].getMessage());\n+    }\n+    \n+    public void testIndexOfThrowable() {\n+        NotImplementedException ex = new NotImplementedException(new NestableException(\"nested 1\", new NestableException(\"nested 2\")));\n+        assertEquals(0, ex.indexOfThrowable(NotImplementedException.class));\n+        assertEquals(1, ex.indexOfThrowable(NestableException.class));\n+    }\n+    \n+    public void testIndexOfThrowable_Index() {\n+        NotImplementedException ex = new NotImplementedException(new NestableException(\"nested 1\", new NestableException(\"nested 2\")));\n+        assertEquals(1, ex.indexOfThrowable(NestableException.class, 1));\n+    }\n+    \n+    public void testPrintStackTrace() {\n+        NotImplementedException ex = new NotImplementedException(new NestableException(\"nested 1\", new NestableException(\"nested 2\")));\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(baos);\n+        PrintStream errStream = System.err;\n+        System.setErr(ps);\n+        ex.printStackTrace();\n+        System.setErr(errStream);\n+        assertTrue(baos.toString().length() > 0);\n+    }\n+    \n+    public void testPrintStackTrace_Stream() {\n+        NotImplementedException ex = new NotImplementedException(new NestableException(\"nested 1\", new NestableException(\"nested 2\")));\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(baos);\n+        ex.printStackTrace(ps);\n+        assertTrue(baos.toString().length() > 0);\n+    }\n+    \n+    public void testPrintStackTrace_Writer() {\n+        NotImplementedException ex = new NotImplementedException(new NestableException(\"nested 1\", new NestableException(\"nested 2\")));\n+        StringWriter stringWriter = new StringWriter();\n+        PrintWriter writer = new PrintWriter(stringWriter);\n+        ex.printStackTrace(writer);\n+        assertTrue(stringWriter.toString().length() > 0);\n+    }\n+    \n+    public void testPrintPartialStackTrace_Writer() {\n+      NotImplementedException ex = new NotImplementedException(new NestableException(\"nested 1\", new NestableException(\"nested 2\")));\n+      StringWriter stringWriter = new StringWriter();\n+      PrintWriter writer = new PrintWriter(stringWriter);\n+      ex.printPartialStackTrace(writer);\n+      assertTrue(stringWriter.toString().length() > 0);\n+  }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/NullArgumentExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ * @see NullArgumentException\n+ */\n+public class NullArgumentExceptionTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(NullArgumentExceptionTest.class);\n+    }\n+\n+    public NullArgumentExceptionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    // testConstructor\n+\n+    public void testConstructor_nullInput() {\n+        new NullArgumentException(null);\n+    }\n+\n+    // testGetMessage\n+\n+    public void testGetMessage_nullConstructorInput() {\n+        final Throwable t = new NullArgumentException(null);\n+        assertEquals(\"Argument must not be null.\", t.getMessage());\n+    }\n+\n+    public void testGetMessage_validConstructorInput() {\n+        final String argName = \"name\";\n+        final Throwable t = new NullArgumentException(argName);\n+        assertEquals(argName + \" must not be null.\", t.getMessage());\n+    }\n+\n+} // NullArgumentExceptionTest\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/NumberRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link NumberRange} class.\n+ *\n+ * @author <a href=\"mailto:chrise@esha.com\">Christopher Elkins</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Tim O'Brien\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class NumberRangeTest extends TestCase {\n+\n+\n+    private NumberRange tenToTwenty;\n+    private NumberRange fifteenToTwentyFive;\n+    private NumberRange fiveToNine;\n+    private Number five;\n+    private Number nine;\n+    private Number ten;\n+    private Number fifteen;\n+    private Number twenty;\n+    private Number twentyFive;\n+\n+    public NumberRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        five       = new Integer(5);\n+        nine      = new Double(9.0);\n+        ten        = new Integer(10);\n+        fifteen    = new Integer(15);\n+        twenty     = new Integer(20);\n+        twentyFive = new Integer(25);\n+\n+        tenToTwenty = new NumberRange(ten, twenty);\n+        fifteenToTwentyFive = new NumberRange( fifteen, twentyFive);\n+        fiveToNine = new NumberRange( five, nine );\n+    }\n+\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NumberRangeTest.class);\n+        suite.setName(\"NumberRange Tests\");\n+        return suite;\n+    }\n+\n+    public void testMaxMin() {\n+        boolean expected = true;\n+        boolean result = tenToTwenty.getMaximum().equals(twenty);\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.getMinimum().equals(ten);\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testEquals() {\n+        boolean expected = false;\n+        boolean result = tenToTwenty.equals(new NumberRange(five, ten));\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.equals(new NumberRange(ten, twenty));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = tenToTwenty.equals(new NumberRange(ten, fifteen));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = tenToTwenty.equals(new NumberRange(fifteen, twenty));\n+        assertEquals(expected, result);\n+    }\n+    \n+    public void testEqualsWithOtherObject() {\n+        assertEquals( \"A NumberRange should not equals a String object\", false, fiveToNine.equals(\"TEST\"));\n+    }\n+\n+    public void testEqualsWithSameReference() {\n+        assertEquals( \"A NumberRange should equal itself\", true, fiveToNine.equals(fiveToNine));\n+    }\n+\n+    public void testEqualsNull() {\n+        assertEquals( \"A NumberRange should not equal null\", false, fiveToNine.equals(null));\n+    }\n+\n+    public void testHashCode() {\n+        NumberRange nr = new NumberRange( new Integer(5), new Double(9.0));\n+        assertEquals( \"The hashCode of 5-9 should equals the hashcode of another NumberRange of the same min/max\",\n+                                fiveToNine.hashCode(), nr.hashCode());\n+        assertTrue( \"The hashCode of 10-20 should not equal the hashCode of 5-9\", \n+                            fiveToNine.hashCode() != tenToTwenty.hashCode());                        \n+    }\n+\n+    public void testIncludesNumber() {\n+        boolean expected = false;\n+        boolean result = tenToTwenty.includesNumber(five);\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesNumber(ten);\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesNumber(fifteen);\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesNumber(twenty);\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = tenToTwenty.includesNumber(twentyFive);\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testIncludesNumberNull() {\n+        boolean result = tenToTwenty.includesNumber(null);\n+        assertEquals(\"Includes number should return false for null values\", false, result);\n+    }\n+\n+    public void testIncludesRange() {\n+        boolean expected = false;\n+        boolean result = tenToTwenty.includesRange(new NumberRange(five, ten));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = tenToTwenty.includesRange(new NumberRange(five, fifteen));\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesRange(new NumberRange(ten, fifteen));\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesRange(new NumberRange(ten, twenty));\n+        assertEquals(expected, result);\n+\n+        expected = true;\n+        result = tenToTwenty.includesRange(new NumberRange(fifteen, twenty));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = \n+            tenToTwenty.includesRange(new NumberRange(fifteen, twentyFive));\n+        assertEquals(expected, result);\n+\n+        expected = false;\n+        result = \n+            tenToTwenty.includesRange(new NumberRange(twenty, twentyFive));\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testIncludesRangeNull() {\n+        boolean result = tenToTwenty.includesRange(null);\n+        assertEquals(\"Includes range should return false for null values\", false, result);\n+    }\n+\n+    public void testConstructor() {\n+        NumberRange nr = new NumberRange( new Double(2.0));\n+        assertEquals(\"Unexpected min on NumberRange\", 2.0, nr.getMinimum().doubleValue(), Double.MIN_VALUE);\n+        assertEquals(\"Unexpected max on NumberRange\", 2.0, nr.getMaximum().doubleValue(), Double.MIN_VALUE);\n+    }\n+\n+    public void testConstructorNullParameters() {\n+        try {\n+            NumberRange nr = new NumberRange(null);\n+            fail(\"NumberRange(null) did not throw an exception.\");\n+        } catch (Exception e) {\n+            assertTrue(    \"NumberRange(null)\", e instanceof NullPointerException);\n+        }\n+\n+        try {\n+            NumberRange nr = new NumberRange(five, null);\n+            fail(\"NumberRange(five, null) did not throw an exception.\");\n+        } catch (Exception e) {\n+            assertTrue(\"NumberRange(five, null)\", e instanceof NullPointerException);\n+        }\n+\n+        try {\n+            NumberRange nr = new NumberRange(null, five);\n+            fail(\"NumberRange(null, five) did not throw an exception.\");\n+        } catch (Exception e) {\n+            assertTrue(\"NumberRange(null, five)\", e instanceof NullPointerException);\n+        }\n+    }\n+\n+    public void testConstructorWithMaxLessThanMin() {\n+        NumberRange nr = new NumberRange( new Double(2.0), new Double(1.0));\n+        assertEquals(\"Unexpected min on NumberRange\", 2.0, nr.getMinimum().doubleValue(), Double.MIN_VALUE);\n+        assertEquals(\"Unexpected max on NumberRange\", 2.0, nr.getMaximum().doubleValue(), Double.MIN_VALUE);\n+    }\n+\n+    public void testOverlap() {\n+        assertEquals( \"5-9 should not overlap 10-20\", false, fiveToNine.overlaps( tenToTwenty ));\n+        assertEquals( \"10-20 should overlap 15-25\", true, tenToTwenty.overlaps( fifteenToTwentyFive ));\n+    }\n+\n+    public void testOverlapNull() {\n+        assertEquals( \"5-9 should not overlap null\", false, fiveToNine.overlaps( null ));\n+    }\n+\n+    public void testToString() {\n+        String expected = \"10-20\";\n+        String result = tenToTwenty.toString();\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testToStringWithNegatives() {\n+        String expected = \"(-20)-(-10)\";\n+        NumberRange nr = new NumberRange( new Integer(-20), new Integer(-10));\n+        String result = nr.toString();\n+        assertEquals(expected, result);\n+\n+        expected = \"(-20)-10\";\n+        nr = new NumberRange( new Integer(-20), new Integer(10));\n+        result = nr.toString();\n+        assertEquals(expected, result);\n+    }\n+\n+\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/NumberUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.NumberUtils}.\n+ *\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Eric Pugh\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class NumberUtilsTest extends TestCase {\n+\n+    public NumberUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NumberUtilsTest.class);\n+        suite.setName(\"NumberUtils Tests\");\n+        return suite;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * Test for int stringToInt(String)\n+     */\n+    public void testStringToIntString() {\n+        assertTrue(\"stringToInt(String) 1 failed\", NumberUtils.stringToInt(\"12345\") == 12345);\n+        assertTrue(\"stringToInt(String) 2 failed\", NumberUtils.stringToInt(\"abc\") == 0);\n+    }\n+\n+    /**\n+     * Test for int stringToInt(String, int)\n+     */\n+    public void testStringToIntStringI() {\n+        assertTrue(\"stringToInt(String,int) 1 failed\", NumberUtils.stringToInt(\"12345\", 5) == 12345);\n+        assertTrue(\"stringToInt(String,int) 2 failed\", NumberUtils.stringToInt(\"1234.5\", 5) == 5);\n+    }\n+\n+    public void testCreateNumber() {\n+        //a lot of things can go wrong\n+        assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n+        assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n+        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n+        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n+        assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\" + (Integer.MAX_VALUE + 1L)));\n+        assertEquals(\"createNumber(String) 6 failed\", new BigInteger(Long.MAX_VALUE + \"0\"), NumberUtils.createNumber(Long.MAX_VALUE + \"0L\"));\n+        assertEquals(\"createNumber(String) 7 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n+        assertEquals(\"createNumber(String) 8 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n+        assertEquals(\"createNumber(String) 9 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n+        assertTrue(\"createNumber(String) 10 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n+        assertTrue(\"createNumber(String) 11 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n+        assertEquals(\"createNumber(String) 12 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n+        assertEquals(\"createNumber(String) 13 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n+        assertEquals(\"createNumber(String) 14 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n+        assertEquals(\"createNumber(String) 15 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n+        assertEquals(\"createNumber(String) 16 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n+\n+        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n+        if(SystemUtils.isJavaVersionAtLeast(1.3f)) { \n+            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils.createNumber(\"1.1E-700F\"));\n+        }\n+        assertEquals(\n+            \"createNumber(String) 16 failed\",\n+            new Long(\"10\" + Integer.MAX_VALUE),\n+            NumberUtils.createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n+        assertEquals(\n+            \"createNumber(String) 17 failed\",\n+            new Long(\"10\" + Integer.MAX_VALUE),\n+            NumberUtils.createNumber(\"10\" + Integer.MAX_VALUE));\n+        assertEquals(\n+            \"createNumber(String) 18 failed\",\n+            new BigInteger(\"10\" + Long.MAX_VALUE),\n+            NumberUtils.createNumber(\"10\" + Long.MAX_VALUE));\n+\n+    }\n+\n+    public void testCreateFloat() {\n+        assertEquals(\"createFloat(String) failed\", new Float(\"1234.5\"), NumberUtils.createFloat(\"1234.5\"));\n+    }\n+\n+    public void testCreateDouble() {\n+        assertEquals(\"createDouble(String) failed\", new Double(\"1234.5\"), NumberUtils.createDouble(\"1234.5\"));\n+    }\n+\n+    public void testCreateInteger() {\n+        assertEquals(\"createInteger(String) failed\", new Integer(\"12345\"), NumberUtils.createInteger(\"12345\"));\n+    }\n+\n+    public void testCreateLong() {\n+        assertEquals(\"createInteger(String) failed\", new Long(\"12345\"), NumberUtils.createLong(\"12345\"));\n+    }\n+\n+    public void testCreateBigInteger() {\n+        assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"12345\"), NumberUtils.createBigInteger(\"12345\"));\n+    }\n+\n+    public void testCreateBigDecimal() {\n+        assertEquals(\"createBigDecimal(String) failed\", new BigDecimal(\"1234.5\"), NumberUtils.createBigDecimal(\"1234.5\"));\n+    }\n+\n+    public void testMinimumLong() {\n+        assertEquals(\"minimum(long,long,long) 1 failed\", 12345L, NumberUtils.minimum(12345L, 12345L + 1L, 12345L + 2L));\n+        assertEquals(\"minimum(long,long,long) 2 failed\", 12345L, NumberUtils.minimum(12345L + 1L, 12345L, 12345 + 2L));\n+        assertEquals(\"minimum(long,long,long) 3 failed\", 12345L, NumberUtils.minimum(12345L + 1L, 12345L + 2L, 12345L));\n+        assertEquals(\"minimum(long,long,long) 4 failed\", 12345L, NumberUtils.minimum(12345L + 1L, 12345L, 12345L));\n+        assertEquals(\"minimum(long,long,long) 5 failed\", 12345L, NumberUtils.minimum(12345L, 12345L, 12345L));\n+\n+    }\n+\n+    public void testMinimumInt() {\n+        assertEquals(\"minimum(int,int,int) 1 failed\", 12345, NumberUtils.minimum(12345, 12345 + 1, 12345 + 2));\n+        assertEquals(\"minimum(int,int,int) 2 failed\", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345 + 2));\n+        assertEquals(\"minimum(int,int,int) 3 failed\", 12345, NumberUtils.minimum(12345 + 1, 12345 + 2, 12345));\n+        assertEquals(\"minimum(int,int,int) 4 failed\", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345));\n+        assertEquals(\"minimum(int,int,int) 5 failed\", 12345, NumberUtils.minimum(12345, 12345, 12345));\n+\n+    }\n+\n+    public void testMaximumLong() {\n+        assertEquals(\"maximum(long,long,long) 1 failed\", 12345L, NumberUtils.maximum(12345L, 12345L - 1L, 12345L - 2L));\n+        assertEquals(\"maximum(long,long,long) 2 failed\", 12345L, NumberUtils.maximum(12345L - 1L, 12345L, 12345L - 2L));\n+        assertEquals(\"maximum(long,long,long) 3 failed\", 12345L, NumberUtils.maximum(12345L - 1L, 12345L - 2L, 12345L));\n+        assertEquals(\"maximum(long,long,long) 4 failed\", 12345L, NumberUtils.maximum(12345L - 1L, 12345L, 12345L));\n+        assertEquals(\"maximum(long,long,long) 5 failed\", 12345L, NumberUtils.maximum(12345L, 12345L, 12345L));\n+\n+    }\n+\n+    public void testMaximumInt() {\n+        assertEquals(\"maximum(int,int,int) 1 failed\", 12345, NumberUtils.maximum(12345, 12345 - 1, 12345 - 2));\n+        assertEquals(\"maximum(int,int,int) 2 failed\", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345 - 2));\n+        assertEquals(\"maximum(int,int,int) 3 failed\", 12345, NumberUtils.maximum(12345 - 1, 12345 - 2, 12345));\n+        assertEquals(\"maximum(int,int,int) 4 failed\", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345));\n+        assertEquals(\"maximum(int,int,int) 5 failed\", 12345, NumberUtils.maximum(12345, 12345, 12345));\n+\n+    }\n+\n+    public void testCompareDouble() {\n+        assertTrue(NumberUtils.compare(Double.NaN, Double.NaN) == 0);\n+        assertTrue(NumberUtils.compare(Double.NaN, Double.POSITIVE_INFINITY) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, 1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, 0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY) == 0);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, 1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, 0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.MAX_VALUE) == 0);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, 1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, 0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(1.2d, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(1.2d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(1.2d, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(1.2d, 1.2d) == 0);\n+        assertTrue(NumberUtils.compare(1.2d, 0.0d) == +1);\n+        assertTrue(NumberUtils.compare(1.2d, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(1.2d, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(1.2d, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(1.2d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(0.0d, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(0.0d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(0.0d, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(0.0d, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(0.0d, 0.0d) == 0);\n+        assertTrue(NumberUtils.compare(0.0d, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(0.0d, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(0.0d, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(0.0d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-0.0d, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, 0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, -0.0d) == 0);\n+        assertTrue(NumberUtils.compare(-0.0d, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(-0.0d, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(-0.0d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-1.2d, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, 0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, -0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, -1.2d) == 0);\n+        assertTrue(NumberUtils.compare(-1.2d, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(-1.2d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, 0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -1.2d) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -Double.MAX_VALUE) == 0);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, 0.0d) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -0.0d) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -1.2d) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) == 0);\n+    }\n+\n+    public void testCompareFloat() {\n+        assertTrue(NumberUtils.compare(Float.NaN, Float.NaN) == 0);\n+        assertTrue(NumberUtils.compare(Float.NaN, Float.POSITIVE_INFINITY) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, 1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, 0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY) == 0);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, 1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, 0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.MAX_VALUE) == 0);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, 1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, 0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(1.2f, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(1.2f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(1.2f, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(1.2f, 1.2f) == 0);\n+        assertTrue(NumberUtils.compare(1.2f, 0.0f) == +1);\n+        assertTrue(NumberUtils.compare(1.2f, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(1.2f, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(1.2f, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(1.2f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(0.0f, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(0.0f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(0.0f, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(0.0f, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(0.0f, 0.0f) == 0);\n+        assertTrue(NumberUtils.compare(0.0f, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(0.0f, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(0.0f, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(0.0f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-0.0f, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, 0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, -0.0f) == 0);\n+        assertTrue(NumberUtils.compare(-0.0f, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(-0.0f, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(-0.0f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-1.2f, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, 0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, -0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, -1.2f) == 0);\n+        assertTrue(NumberUtils.compare(-1.2f, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(-1.2f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, 0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -1.2f) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -Float.MAX_VALUE) == 0);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, 0.0f) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -0.0f) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -1.2f) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY) == 0);\n+    }\n+\n+    public void testIsDigits() {\n+        assertEquals(\"isDigits(null) failed\", false, NumberUtils.isDigits(null));\n+        assertEquals(\"isDigits('') failed\", false, NumberUtils.isDigits(\"\"));\n+        assertEquals(\"isDigits(String) failed\", true, NumberUtils.isDigits(\"12345\"));\n+        assertEquals(\"isDigits(String) neg 1 failed\", false, NumberUtils.isDigits(\"1234.5\"));\n+        assertEquals(\"isDigits(String) neg 3 failed\", false, NumberUtils.isDigits(\"1ab\"));\n+        assertEquals(\"isDigits(String) neg 4 failed\", false, NumberUtils.isDigits(\"abc\"));\n+    }\n+    \n+    /**\n+     * Tests isNumber(String) and tests that createNumber(String) returns\n+     * a valid number iff isNumber(String) returns false.\n+     */\n+    public void testIsNumber() {\n+        String val = \"12345\";\n+        assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n+        val = \"1234.5\";\n+        assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n+        val = \".12345\";\n+        assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n+        val = \"1234E5\";\n+        assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n+        val = \"1234E+5\";\n+        assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n+        val = \"1234E-5\";\n+        assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n+        val = \"123.4E5\";\n+        assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n+        val = \"-1234\";\n+        assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n+        val = \"-1234.5\";\n+        assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n+        val = \"-.12345\";\n+        assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n+        val = \"-1234E5\";\n+        assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n+        val = \"0\";\n+        assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n+        val = \"-0\";\n+        assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n+        val = \"01234\";\n+        assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n+        val = \"-01234\";\n+        assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n+        val = \"0xABC123\";\n+        assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n+        val = \"0x0\";\n+        assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n+        val = \"123.4E21D\";\n+        assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n+        val = \"-221.23F\";\n+        assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n+        val = \"22338L\";\n+        assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n+        val = null;\n+        assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n+        val = \"\";\n+        assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n+        val = \"--2.3\";\n+        assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n+        val = \".12.3\";\n+        assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E\";\n+        assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E+-212\";\n+        assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E2.12\";\n+        assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n+        val = \"0xGF\";\n+        assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n+        val = \"0xFAE-1\";\n+        assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n+        val = \".\";\n+        assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n+        val = \"-0ABC123\";\n+        assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n+        val = \"123.4E-D\";\n+        assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n+        val = \"123.4ED\";\n+        assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n+        val = \"1234E5l\";\n+        assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n+        val = \"11a\";\n+        assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n+        val = \"1a\";\n+        assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n+        val = \"a\";\n+        assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11g\";\n+        assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11z\";\n+        assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11def\";\n+        assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11d11\";\n+        assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n+\n+    }\n+    \n+    public void testIsNumberInvalidInput() {\n+        String val = \"0x\";\n+        assertEquals(\"isNumber() with 0x wasn't false\",  false, NumberUtils.isNumber(val));\n+        val = \"0x3x3\";\n+        assertEquals(\"isNumber() with 0x3x3 wasn't false\",  false, NumberUtils.isNumber(val));\n+        val = \"20EE-3\";\n+        assertEquals(\"isNumber() with 20EE-3 wasn't false\",  false, NumberUtils.isNumber(val));\n+        val = \"2435q\";\n+        assertEquals(\"isNumber() with 2435q wasn't false\",  false, NumberUtils.isNumber(val));\n+        val = \".\";\n+        assertEquals(\"isNumber() with . wasn't false\",  false, NumberUtils.isNumber(val));\n+\n+    }\n+\n+    private boolean checkCreateNumber(String val) {\n+        try {\n+            Object obj = NumberUtils.createNumber(val);\n+            if (obj == null) {\n+                return false;\n+            }\n+            return true;\n+        } catch (NumberFormatException e) {\n+            return false;\n+        } catch (NullPointerException e) {\n+            return false;\n+        }\n+    }\n+\n+    public void testPublicNoArgConstructor() {\n+        try {\n+            NumberUtils nu = new NumberUtils();\n+        } catch( Exception e ) {\n+            fail( \"Error calling public no-arg constructor\" );\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/ObjectUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.ObjectUtils}.\n+ *\n+ * @author <a href=\"mailto:jmcnally@collab.net\">John McNally</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class ObjectUtilsTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+\n+    public ObjectUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ObjectUtilsTest.class);\n+        suite.setName(\"ObjectUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new ObjectUtils());\n+        Constructor[] cons = ObjectUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(ObjectUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(ObjectUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsNull() {\n+        Object o = FOO;\n+        Object dflt = BAR;\n+        assertSame(\"dflt was not returned when o was null\", dflt, ObjectUtils.defaultIfNull(null, dflt));\n+        assertSame(\"dflt was returned when o was not null\", o, ObjectUtils.defaultIfNull(o, dflt));\n+    }\n+\n+    public void testEquals() {\n+        assertTrue(\"ObjectUtils.equals(null, null) returned false\", ObjectUtils.equals(null, null));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", null) returned true\", !ObjectUtils.equals(FOO, null));\n+        assertTrue(\"ObjectUtils.equals(null, \\\"bar\\\") returned true\", !ObjectUtils.equals(null, BAR));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", \\\"bar\\\") returned true\", !ObjectUtils.equals(FOO, BAR));\n+        assertTrue(\"ObjectUtils.equals(\\\"foo\\\", \\\"foo\\\") returned false\", ObjectUtils.equals(FOO, FOO));\n+    }\n+\n+    public void testHashCode() {\n+        assertEquals(0, ObjectUtils.hashCode(null));\n+        assertEquals(\"a\".hashCode(), ObjectUtils.hashCode(\"a\"));\n+    }\n+\n+//    /**\n+//     * Show that java.util.Date and java.sql.Timestamp are apples and oranges.\n+//     * Prompted by an email discussion. \n+//     * \n+//     * The behavior is different b/w Sun Java 1.3.1_10 and 1.4.2_03.\n+//     */\n+//    public void testDateEqualsJava() {\n+//        long now = 1076957313284L; // Feb 16, 2004 10:49... PST\n+//        java.util.Date date = new java.util.Date(now);\n+//        java.sql.Timestamp realTimestamp = new java.sql.Timestamp(now);\n+//        java.util.Date timestamp = realTimestamp;\n+//        // sanity check 1:\n+//        assertEquals(284000000, realTimestamp.getNanos());\n+//        assertEquals(1076957313284L, date.getTime());\n+//        //\n+//        // On Sun 1.3.1_10:\n+//        //junit.framework.AssertionFailedError: expected:<1076957313284> but was:<1076957313000>\n+//        //\n+//        //assertEquals(1076957313284L, timestamp.getTime());\n+//        //\n+//        //junit.framework.AssertionFailedError: expected:<1076957313284> but was:<1076957313000>\n+//        //\n+//        //assertEquals(1076957313284L, realTimestamp.getTime());\n+//        // sanity check 2:        \n+//        assertEquals(date.getDay(), realTimestamp.getDay());\n+//        assertEquals(date.getHours(), realTimestamp.getHours());\n+//        assertEquals(date.getMinutes(), realTimestamp.getMinutes());\n+//        assertEquals(date.getMonth(), realTimestamp.getMonth());\n+//        assertEquals(date.getSeconds(), realTimestamp.getSeconds());\n+//        assertEquals(date.getTimezoneOffset(), realTimestamp.getTimezoneOffset());\n+//        assertEquals(date.getYear(), realTimestamp.getYear());\n+//        //\n+//        // Time values are == and equals() on Sun 1.4.2_03 but NOT on Sun 1.3.1_10:\n+//        //\n+//        //assertFalse(\"Sanity check failed: date.getTime() == timestamp.getTime()\", date.getTime() == timestamp.getTime());\n+//        //assertFalse(\"Sanity check failed: timestamp.equals(date)\", timestamp.equals(date));\n+//        //assertFalse(\"Sanity check failed: date.equals(timestamp)\", date.equals(timestamp));\n+//        // real test:\n+//        //assertFalse(\"java.util.Date and java.sql.Timestamp should be equal\", ObjectUtils.equals(date, timestamp));\n+//    }\n+    \n+    public void testIdentityToString() {\n+        assertEquals(null, ObjectUtils.identityToString(null));\n+        assertEquals(\n+            \"java.lang.String@\" + Integer.toHexString(System.identityHashCode(FOO)),\n+            ObjectUtils.identityToString(FOO));\n+        Integer i = new Integer(90);\n+        assertEquals(\n+            \"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(i)),\n+            ObjectUtils.identityToString(i));\n+    }\n+\n+    public void testAppendIdentityToString() {\n+        assertEquals(null, ObjectUtils.appendIdentityToString(null, null));\n+        assertEquals(null, ObjectUtils.appendIdentityToString(new StringBuffer(), null));\n+        assertEquals(\n+            \"java.lang.String@\" + Integer.toHexString(System.identityHashCode(FOO)),\n+            ObjectUtils.appendIdentityToString(null, FOO).toString());\n+        assertEquals(\n+            \"java.lang.String@\" + Integer.toHexString(System.identityHashCode(FOO)),\n+            ObjectUtils.appendIdentityToString(new StringBuffer(), FOO).toString());\n+        Integer val = new Integer(90);\n+        assertEquals(\n+            \"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(val)),\n+            ObjectUtils.appendIdentityToString(null, val).toString());\n+        assertEquals(\n+            \"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(val)),\n+            ObjectUtils.appendIdentityToString(new StringBuffer(), val).toString());\n+    }\n+\n+    public void testToString_Object() {\n+        assertEquals(\"\", ObjectUtils.toString((Object) null) );\n+        assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE) );\n+    }\n+            \n+    public void testToString_ObjectString() {\n+        assertEquals(BAR, ObjectUtils.toString((Object) null, BAR) );\n+        assertEquals(Boolean.TRUE.toString(), ObjectUtils.toString(Boolean.TRUE, BAR) );\n+    }\n+\n+    public void testNull() {\n+        assertTrue(ObjectUtils.NULL != null);\n+        assertTrue(ObjectUtils.NULL instanceof ObjectUtils.Null);\n+        assertSame(ObjectUtils.NULL, SerializationUtils.clone(ObjectUtils.NULL));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/RandomStringUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.RandomStringUtils}.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public class RandomStringUtilsTest extends junit.framework.TestCase {\n+    /**\n+     * Construct a new instance of RandomStringUtilsTest with the specified name\n+     */\n+    public RandomStringUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RandomStringUtilsTest.class);\n+        suite.setName(\"RandomStringUtils Tests\");\n+        return suite;\n+    }\n+    \n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp() {\n+    }\n+    \n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown() {\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new RandomStringUtils());\n+        Constructor[] cons = RandomStringUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(RandomStringUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(RandomStringUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test the implementation\n+     */\n+    public void testRandomStringUtils() {\n+        String r1 = RandomStringUtils.random(50);\n+        assertEquals(\"random(50) length\", 50, r1.length());\n+        String r2 = RandomStringUtils.random(50);\n+        assertEquals(\"random(50) length\", 50, r2.length());\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomAscii(50);\n+        assertEquals(\"randomAscii(50) length\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"char between 32 and 127\", r1.charAt(i) >= 32 && r1.charAt(i) <= 127);\n+        }        \n+        r2 = RandomStringUtils.randomAscii(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+\n+        r1 = RandomStringUtils.randomAlphabetic(50);\n+        assertEquals(\"randomAlphabetic(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains alphabetic\", true, Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomAlphabetic(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomAlphanumeric(50);\n+        assertEquals(\"randomAlphanumeric(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains alphanumeric\", true, Character.isLetterOrDigit(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomAlphabetic(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.randomNumeric(50);\n+        assertEquals(\"randomNumeric(50)\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertEquals(\"r1 contains numeric\", true, Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)));\n+        }\n+        r2 = RandomStringUtils.randomNumeric(50);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        String set = \"abcdefg\";\n+        r1 = RandomStringUtils.random(50, set);\n+        assertEquals(\"random(50, \\\"abcdefg\\\")\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"random char in set\", set.indexOf(r1.charAt(i)) > -1);\n+        }\n+        r2 = RandomStringUtils.random(50, set);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.random(50, (String) null);\n+        assertEquals(\"random(50) length\", 50, r1.length());\n+        r2 = RandomStringUtils.random(50, (String) null);\n+        assertEquals(\"random(50) length\", 50, r2.length());\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        set = \"stuvwxyz\";\n+        r1 = RandomStringUtils.random(50, set.toCharArray());\n+        assertEquals(\"random(50, \\\"stuvwxyz\\\")\", 50, r1.length());\n+        for(int i = 0; i < r1.length(); i++) {\n+            assertTrue(\"random char in set\", set.indexOf(r1.charAt(i)) > -1);\n+        }\n+        r2 = RandomStringUtils.random(50, set);\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+        \n+        r1 = RandomStringUtils.random(50, (char[]) null);\n+        assertEquals(\"random(50) length\", 50, r1.length());\n+        r2 = RandomStringUtils.random(50, (char[]) null);\n+        assertEquals(\"random(50) length\", 50, r2.length());\n+        assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n+\n+        long seed = System.currentTimeMillis();\n+        r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));\n+        r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));\n+        assertEquals(\"r1.equals(r2)\", r1, r2);\n+\n+        r1 = RandomStringUtils.random(0);\n+        assertEquals(\"random(0).equals(\\\"\\\")\", \"\", r1);\n+\n+    }\n+    public void testExceptions() {\n+        try {\n+            RandomStringUtils.random(-1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, true, true);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, new char[0]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, \"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, 'a', 'z', false, false);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, 'a', 'z', false, false, new char[0]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            RandomStringUtils.random(-1, 'a', 'z', false, false, new char[0], new Random());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    /**\n+     * Make sure boundary alphanumeric characters are generated by randomAlphaNumeric\n+     * This test will fail randomly with probability = 6 * (61/62)**1000 ~ 5.2E-7\n+     */  \n+    public void testRandomAlphaNumeric() {\n+        char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'};\n+        boolean[] found = {false, false, false, false, false, false};\n+        for (int i = 0; i < 100; i++) {\n+            String randString = RandomStringUtils.randomAlphanumeric(10);\n+            for (int j = 0; j < testChars.length; j++) {\n+                if (randString.indexOf(testChars[j]) > 0) {\n+                    found[j] = true;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < testChars.length; i++) {\n+            if (!found[i]) {\n+                fail(\"alphanumeric character not generated in 1000 attempts: \" \n+                   + testChars[i] +\" -- repeated failures indicate a problem \");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Make sure '0' and '9' are generated by randomNumeric\n+     * This test will fail randomly with probability = 2 * (9/10)**1000 ~ 3.5E-46\n+     */  \n+    public void testRandomNumeric() {\n+        char[] testChars = {'0','9'};\n+        boolean[] found = {false, false};\n+        for (int i = 0; i < 100; i++) {\n+            String randString = RandomStringUtils.randomNumeric(10);\n+            for (int j = 0; j < testChars.length; j++) {\n+                if (randString.indexOf(testChars[j]) > 0) {\n+                    found[j] = true;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < testChars.length; i++) {\n+            if (!found[i]) {\n+                fail(\"digit not generated in 1000 attempts: \" \n+                   + testChars[i] +\" -- repeated failures indicate a problem \");\n+            }\n+        }  \n+    }\n+    \n+    /**\n+     * Make sure boundary alpha characters are generated by randomAlphabetic\n+     * This test will fail randomly with probability = 4 * (51/52)**1000 ~ 1.58E-8\n+     */  \n+    public void testRandomAlphabetic() {\n+        char[] testChars = {'a', 'z', 'A', 'Z'};\n+        boolean[] found = {false, false, false, false};\n+        for (int i = 0; i < 100; i++) {\n+            String randString = RandomStringUtils.randomAlphabetic(10);\n+            for (int j = 0; j < testChars.length; j++) {\n+                if (randString.indexOf(testChars[j]) > 0) {\n+                    found[j] = true;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < testChars.length; i++) {\n+            if (!found[i]) {\n+                fail(\"alphanumeric character not generated in 1000 attempts: \" \n+                   + testChars[i] +\" -- repeated failures indicate a problem \");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Make sure 32 and 127 are generated by randomNumeric\n+     * This test will fail randomly with probability = 2*(95/96)**1000 ~ 5.7E-5\n+     */  \n+    public void testRandomAscii() {\n+        char[] testChars = {(char) 32, (char) 126};\n+        boolean[] found = {false, false};\n+        for (int i = 0; i < 100; i++) {\n+            String randString = RandomStringUtils.randomAscii(10);\n+            for (int j = 0; j < testChars.length; j++) {\n+                if (randString.indexOf(testChars[j]) > 0) {\n+                    found[j] = true;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < testChars.length; i++) {\n+            if (!found[i]) {\n+                fail(\"ascii character not generated in 1000 attempts: \" \n+                + (int) testChars[i] + \n+                 \" -- repeated failures indicate a problem\");\n+            }\n+        }  \n+    }\n+    \n+    /** \n+     * Test homogeneity of random strings generated --\n+     * i.e., test that characters show up with expected frequencies\n+     * in generated strings.  Will fail randomly about 1 in 1000 times.\n+     * Repeated failures indicate a problem.\n+     */\n+    public void testRandomStringUtilsHomog() {\n+        String set = \"abc\";\n+        char[] chars = set.toCharArray();\n+        String gen = \"\";\n+        int[] counts = {0,0,0};\n+        int[] expected = {200,200,200};\n+        for (int i = 0; i< 100; i++) {\n+           gen = RandomStringUtils.random(6,chars);\n+           for (int j = 0; j < 6; j++) {\n+               switch (gen.charAt(j)) {\n+                   case 'a': {counts[0]++; break;}\n+                   case 'b': {counts[1]++; break;}\n+                   case 'c': {counts[2]++; break;}\n+                   default: {fail(\"generated character not in set\");}\n+               }\n+           }\n+        } \n+        // Perform chi-square test with df = 3-1 = 2, testing at .001 level\n+        assertTrue(\"test homogeneity -- will fail about 1 in 1000 times\",\n+            chiSquare(expected,counts) < 13.82);  \n+    }\n+    \n+    /**\n+     * Computes Chi-Square statistic given observed and expected counts\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     */\n+    private double chiSquare(int[] expected, int[] observed) {\n+        double sumSq = 0.0d;\n+        double dev = 0.0d;\n+        for (int i = 0; i < observed.length; i++) {\n+            dev = (double) (observed[i] - expected[i]);\n+            sumSq += dev * dev / (double) expected[i];\n+        }\n+        return sumSq;\n+    }           \n+\n+    /**\n+     * Checks if the string got by {@link RandomStringUtils#random(int)}\n+     * can be converted to UTF-8 and back without loss.\n+     *\n+     * @author stefanhoehne@fastmail.fm\n+     * @throws Exception\n+     */\n+    public void testLang100() throws Exception {\n+        int size = 5000;\n+        String encoding = \"UTF-8\";\n+        String orig = RandomStringUtils.random(size);\n+        byte[] bytes = orig.getBytes(encoding);\n+        String copy = new String(bytes, encoding);\n+\n+        // for a verbose compare:\n+        for (int i=0; i < orig.length() && i < copy.length(); i++) {\n+            char o = orig.charAt(i);\n+            char c = copy.charAt(i);\n+            assertEquals(\"differs at \" + i + \"(\" + Integer.toHexString((new Character(o)).hashCode()) + \",\" +\n+            Integer.toHexString((new Character(c)).hashCode()) + \")\", o, c);\n+        }\n+        // compare length also\n+        assertEquals(orig.length(), copy.length());\n+        // just to be complete\n+        assertEquals(orig, copy);\n+    }\n+\n+    public static void main(String args[]) {\n+        TestRunner.run(suite());\n+    }\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/SerializationUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.SerializationUtils}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id$\n+ */\n+public class SerializationUtilsTest extends TestCase {\n+\n+  static final String CLASS_NOT_FOUND_MESSAGE = \"ClassNotFoundSerializationTest.readObject fake exception\";\n+    protected static final String SERIALIZE_IO_EXCEPTION_MESSAGE = \"Anonymous OutputStream I/O exception\";\n+  \n+    private String iString;\n+    private Integer iInteger;\n+    private HashMap iMap;\n+\n+    public SerializationUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SerializationUtilsTest.class);\n+        suite.setName(\"SerializationUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        iString = \"foo\";\n+        iInteger = new Integer(7);\n+        iMap = new HashMap();\n+        iMap.put(\"FOO\", iString);\n+        iMap.put(\"BAR\", iInteger);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new SerializationUtils());\n+        Constructor[] cons = SerializationUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(SerializationUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(SerializationUtils.class.getModifiers()));\n+    }\n+    \n+    public void testException() {\n+        SerializationException serEx;\n+        Exception ex = new Exception();\n+        \n+        serEx = new SerializationException();\n+        assertSame(null, serEx.getMessage());\n+        assertSame(null, serEx.getCause());\n+        \n+        serEx = new SerializationException(\"Message\");\n+        assertSame(\"Message\", serEx.getMessage());\n+        assertSame(null, serEx.getCause());\n+        \n+        serEx = new SerializationException(ex);\n+        assertEquals(\"java.lang.Exception\", serEx.getMessage());\n+        assertSame(ex, serEx.getCause());\n+        \n+        serEx = new SerializationException(\"Message\", ex);\n+        assertSame(\"Message\", serEx.getMessage());\n+        assertSame(ex, serEx.getCause());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSerializeStream() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        SerializationUtils.serialize(iMap, streamTest);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] testBytes = streamTest.toByteArray();\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeStreamUnserializable() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.serialize(iMap, streamTest);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeStreamNullObj() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        SerializationUtils.serialize(null, streamTest);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] testBytes = streamTest.toByteArray();\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeStreamObjNull() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        try {\n+            SerializationUtils.serialize(iMap, null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeStreamNullNull() throws Exception {\n+        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        try {\n+            SerializationUtils.serialize(null, null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSerializeIOException() throws Exception {\n+        // forces an IOException when the ObjectOutputStream is created, to test not closing the stream\n+        // in the finally block\n+        OutputStream streamTest = new OutputStream() {\n+            public void write(int arg0) throws IOException {\n+                throw new IOException(SERIALIZE_IO_EXCEPTION_MESSAGE);\n+            }\n+        };\n+        try {\n+            SerializationUtils.serialize(iMap, streamTest);\n+        }\n+        catch(SerializationException e) {\n+            assertEquals(\"java.io.IOException: \" + SERIALIZE_IO_EXCEPTION_MESSAGE, e.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testDeserializeStream() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        Object test = SerializationUtils.deserialize(inTest);\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap);\n+        assertTrue(test != iMap);\n+        HashMap testMap = (HashMap) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testDeserializeStreamOfNull() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        Object test = SerializationUtils.deserialize(inTest);\n+        assertNull(test);\n+    }\n+\n+    public void testDeserializeStreamNull() throws Exception {\n+        try {\n+            SerializationUtils.deserialize((InputStream) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testDeserializeStreamBadStream() throws Exception {\n+        try {\n+            SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0]));\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testDeserializeStreamClassNotFound() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(new ClassNotFoundSerializationTest());\n+        oos.flush();\n+        oos.close();\n+\n+        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        try {\n+            Object test = SerializationUtils.deserialize(inTest);\n+        } catch(SerializationException se) {\n+            assertEquals(\"java.lang.ClassNotFoundException: \" + CLASS_NOT_FOUND_MESSAGE, se.getMessage());\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+\n+    public void testSerializeBytes() throws Exception {\n+        byte[] testBytes = SerializationUtils.serialize(iMap);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    public void testSerializeBytesUnserializable() throws Exception {\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.serialize(iMap);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSerializeBytesNull() throws Exception {\n+        byte[] testBytes = SerializationUtils.serialize(null);\n+\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        byte[] realBytes = streamReal.toByteArray();\n+        assertEquals(testBytes.length, realBytes.length);\n+        for (int i = 0; i < realBytes.length; i++) {\n+            assertEquals(realBytes[i], testBytes[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testDeserializeBytes() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(iMap);\n+        oos.flush();\n+        oos.close();\n+\n+        Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap);\n+        assertTrue(test != iMap);\n+        HashMap testMap = (HashMap) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testDeserializeBytesOfNull() throws Exception {\n+        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        oos.writeObject(null);\n+        oos.flush();\n+        oos.close();\n+\n+        Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n+        assertNull(test);\n+    }\n+\n+    public void testDeserializeBytesNull() throws Exception {\n+        try {\n+            SerializationUtils.deserialize((byte[]) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testDeserializeBytesBadStream() throws Exception {\n+        try {\n+            SerializationUtils.deserialize(new byte[0]);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testClone() throws Exception {\n+        Object test = SerializationUtils.clone(iMap);\n+        assertNotNull(test);\n+        assertTrue(test instanceof HashMap);\n+        assertTrue(test != iMap);\n+        HashMap testMap = (HashMap) test;\n+        assertEquals(iString, testMap.get(\"FOO\"));\n+        assertTrue(iString != testMap.get(\"FOO\"));\n+        assertEquals(iInteger, testMap.get(\"BAR\"));\n+        assertTrue(iInteger != testMap.get(\"BAR\"));\n+        assertEquals(iMap, testMap);\n+    }\n+\n+    public void testCloneNull() throws Exception {\n+        Object test = SerializationUtils.clone(null);\n+        assertNull(test);\n+    }\n+\n+    public void testCloneUnserializable() throws Exception {\n+        try {\n+            iMap.put(new Object(), new Object());\n+            SerializationUtils.clone(iMap);\n+        } catch (SerializationException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+}\n+\n+class ClassNotFoundSerializationTest implements Serializable\n+{\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException    {\n+        throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/StringEscapeUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link StringEscapeUtils}.\n+ *\n+ * @author of original StringUtilsTest.testEscape = ?\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @version $Id$\n+ */\n+public class StringEscapeUtilsTest extends TestCase {\n+    private final static String FOO = \"foo\";\n+\n+    public StringEscapeUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringEscapeUtilsTest.class);\n+        suite.setName(\"StringEscapeUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new StringEscapeUtils());\n+        Constructor[] cons = StringEscapeUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(StringEscapeUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(StringEscapeUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testEscapeJava() throws IOException {\n+        assertEquals(null, StringEscapeUtils.escapeJava(null));\n+        try {\n+            StringEscapeUtils.escapeJava(null, null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringEscapeUtils.escapeJava(null, \"\");\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        \n+        assertEscapeJava(\"empty string\", \"\", \"\");\n+        assertEscapeJava(FOO, FOO);\n+        assertEscapeJava(\"tab\", \"\\\\t\", \"\\t\");\n+        assertEscapeJava(\"backslash\", \"\\\\\\\\\", \"\\\\\");\n+        assertEscapeJava(\"single quote should not be escaped\", \"'\", \"'\");\n+        assertEscapeJava(\"\\\\\\\\\\\\b\\\\t\\\\r\", \"\\\\\\b\\t\\r\");\n+        assertEscapeJava(\"\\\\u1234\", \"\\u1234\");\n+        assertEscapeJava(\"\\\\u0234\", \"\\u0234\");\n+        assertEscapeJava(\"\\\\u00EF\", \"\\u00ef\");\n+        assertEscapeJava(\"\\\\u0001\", \"\\u0001\");\n+        assertEscapeJava(\"Should use capitalized unicode hex\", \"\\\\uABCD\", \"\\uabcd\");\n+\n+        assertEscapeJava(\"He didn't say, \\\\\\\"stop!\\\\\\\"\",\n+                \"He didn't say, \\\"stop!\\\"\");\n+        assertEscapeJava(\"non-breaking space\", \"This space is non-breaking:\" + \"\\\\u00A0\",\n+                \"This space is non-breaking:\\u00a0\");\n+        assertEscapeJava(\"\\\\uABCD\\\\u1234\\\\u012C\",\n+                \"\\uABCD\\u1234\\u012C\");\n+    }\n+\n+    private void assertEscapeJava(String escaped, String original) throws IOException {\n+        assertEscapeJava(null, escaped, original);\n+    }\n+\n+    private void assertEscapeJava(String message, String expected, String original) throws IOException {\n+        String converted = StringEscapeUtils.escapeJava(original);\n+        message = \"escapeJava(String) failed\" + (message == null ? \"\" : (\": \" + message));\n+        assertEquals(message, expected, converted);\n+\n+        StringWriter writer = new StringWriter();\n+        StringEscapeUtils.escapeJava(writer, original);\n+        assertEquals(expected, writer.toString());\n+    }\n+\n+    public void testUnescapeJava() throws IOException {\n+        assertEquals(null, StringEscapeUtils.unescapeJava(null));\n+        try {\n+            StringEscapeUtils.unescapeJava(null, null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringEscapeUtils.unescapeJava(null, \"\");\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringEscapeUtils.unescapeJava(\"\\\\u02-3\");\n+            fail();\n+        } catch (RuntimeException ex) {\n+        }\n+        \n+        assertUnescapeJava(\"\", \"\");\n+        assertUnescapeJava(\"test\", \"test\");\n+        assertUnescapeJava(\"\\ntest\\b\", \"\\\\ntest\\\\b\");\n+        assertUnescapeJava(\"\\u123425foo\\ntest\\b\", \"\\\\u123425foo\\\\ntest\\\\b\");\n+        assertUnescapeJava(\"'\\foo\\teste\\r\", \"\\\\'\\\\foo\\\\teste\\\\r\");\n+        assertUnescapeJava(\"\\\\\", \"\\\\\");\n+        //foo\n+        assertUnescapeJava(\"lowercase unicode\", \"\\uABCDx\", \"\\\\uabcdx\");\n+        assertUnescapeJava(\"uppercase unicode\", \"\\uABCDx\", \"\\\\uABCDx\");\n+        assertUnescapeJava(\"unicode as final character\", \"\\uABCD\", \"\\\\uabcd\");\n+    }\n+\n+    private void assertUnescapeJava(String unescaped, String original) throws IOException {\n+        assertUnescapeJava(null, unescaped, original);\n+    }\n+\n+    private void assertUnescapeJava(String message, String unescaped, String original) throws IOException {\n+        String expected = unescaped;\n+        String actual = StringEscapeUtils.unescapeJava(original);\n+\n+        assertEquals(\"unescape(String) failed\" +\n+                (message == null ? \"\" : (\": \" + message)) +\n+                \": expected '\" + StringEscapeUtils.escapeJava(expected) +\n+                // we escape this so we can see it in the error message\n+                \"' actual '\" + StringEscapeUtils.escapeJava(actual) + \"'\",\n+                expected, actual);\n+\n+        StringWriter writer = new StringWriter();\n+        StringEscapeUtils.unescapeJava(writer, original);\n+        assertEquals(unescaped, writer.toString());\n+\n+    }\n+\n+    public void testEscapeJavaScript() {\n+        assertEquals(null, StringEscapeUtils.escapeJavaScript(null));\n+        try {\n+            StringEscapeUtils.escapeJavaScript(null, null);\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringEscapeUtils.escapeJavaScript(null, \"\");\n+            fail();\n+        } catch (IOException ex) {\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        \n+        assertEquals(\"He didn\\\\'t say, \\\\\\\"stop!\\\\\\\"\", StringEscapeUtils.escapeJavaScript(\"He didn't say, \\\"stop!\\\"\"));\n+    }\n+\n+\n+    // HTML and XML\n+    //--------------------------------------------------------------\n+\n+    String[][] htmlEscapes = {\n+        {\"no escaping\", \"plain text\", \"plain text\"},\n+        {\"no escaping\", \"plain text\", \"plain text\"},\n+        {\"empty string\", \"\", \"\"},\n+        {\"null\", null, null},\n+        {\"ampersand\", \"bread &amp; butter\", \"bread & butter\"},\n+        {\"quotes\", \"&quot;bread&quot; &amp; butter\", \"\\\"bread\\\" & butter\"},\n+        {\"final character only\", \"greater than &gt;\", \"greater than >\"},\n+        {\"first character only\", \"&lt; less than\", \"< less than\"},\n+        {\"apostrophe\", \"Huntington's chorea\", \"Huntington's chorea\"},\n+        {\"languages\", \"English,Fran&ccedil;ais,&#26085;&#26412;&#35486; (nihongo)\", \"English,Fran\\u00E7ais,\\u65E5\\u672C\\u8A9E (nihongo)\"},\n+        {\"8-bit ascii doesn't number-escape\", \"~\\u007F\", \"\\u007E\\u007F\"},\n+        {\"8-bit ascii does number-escape\", \"&#128;&#159;\", \"\\u0080\\u009F\"},\n+    };\n+\n+    public void testEscapeHtml() {\n+        for (int i = 0; i < htmlEscapes.length; ++i) {\n+            String message = htmlEscapes[i][0];\n+            String expected = htmlEscapes[i][1];\n+            String original = htmlEscapes[i][2];\n+            assertEquals(message, expected, StringEscapeUtils.escapeHtml(original));\n+            StringWriter sw = new StringWriter();\n+            try {\n+            StringEscapeUtils.escapeHtml(sw, original);\n+            } catch (IOException e) {\n+            }\n+            String actual = original == null ? null : sw.toString();\n+            assertEquals(message, expected, actual);\n+        }\n+    }\n+\n+    public void testUnescapeHtml() {\n+        for (int i = 0; i < htmlEscapes.length; ++i) {\n+            String message = htmlEscapes[i][0];\n+            String expected = htmlEscapes[i][2];\n+            String original = htmlEscapes[i][1];\n+            assertEquals(message, expected, StringEscapeUtils.unescapeHtml(original));\n+            \n+            StringWriter sw = new StringWriter();\n+            try {\n+            StringEscapeUtils.unescapeHtml(sw, original);\n+            } catch (IOException e) {\n+            }\n+            String actual = original == null ? null : sw.toString();\n+            assertEquals(message, expected, actual);\n+        }\n+        // \\u00E7 is a cedilla (c with wiggle under)\n+        // note that the test string must be 7-bit-clean (unicode escaped) or else it will compile incorrectly\n+        // on some locales        \n+        assertEquals(\"funny chars pass through OK\", \"Fran\\u00E7ais\", StringEscapeUtils.unescapeHtml(\"Fran\\u00E7ais\"));\n+        \n+        assertEquals(\"Hello&;World\", StringEscapeUtils.unescapeHtml(\"Hello&;World\"));\n+        assertEquals(\"Hello&#;World\", StringEscapeUtils.unescapeHtml(\"Hello&#;World\"));\n+        assertEquals(\"Hello&# ;World\", StringEscapeUtils.unescapeHtml(\"Hello&# ;World\"));\n+        assertEquals(\"Hello&##;World\", StringEscapeUtils.unescapeHtml(\"Hello&##;World\"));\n+    }\n+\n+    public void testUnescapeHexCharsHtml() {\n+        // Simple easy to grok test \n+        assertEquals(\"hex number unescape\", \"\\u0080\\u009F\", StringEscapeUtils.unescapeHtml(\"&#x80;&#x9F;\"));\n+        assertEquals(\"hex number unescape\", \"\\u0080\\u009F\", StringEscapeUtils.unescapeHtml(\"&#X80;&#X9F;\"));\n+        // Test all Character values:\n+        for (char i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) {\n+            Character c1 = new Character(i);\n+            Character c2 = new Character((char)(i+1));\n+            String expected = c1.toString() + c2.toString();\n+            String escapedC1 = \"&#x\" + Integer.toHexString((c1.charValue())) + \";\";\n+            String escapedC2 = \"&#x\" + Integer.toHexString((c2.charValue())) + \";\";\n+            assertEquals(\"hex number unescape index \" + (int)i, expected, StringEscapeUtils.unescapeHtml(escapedC1 + escapedC2));\n+        }\n+    }\n+\n+    public void testUnescapeUnknownEntity() throws Exception\n+    {\n+        assertEquals(\"&zzzz;\", StringEscapeUtils.unescapeHtml(\"&zzzz;\"));\n+    }\n+\n+    public void testEscapeHtmlVersions() throws Exception\n+    {\n+        assertEquals(\"&Beta;\", StringEscapeUtils.escapeHtml(\"\\u0392\"));\n+        assertEquals(\"\\u0392\", StringEscapeUtils.unescapeHtml(\"&Beta;\"));\n+\n+        //todo: refine API for escaping/unescaping specific HTML versions\n+\n+    }\n+\n+    public void testEscapeXml() throws Exception {\n+        assertEquals(\"&lt;abc&gt;\", StringEscapeUtils.escapeXml(\"<abc>\"));\n+        assertEquals(\"<abc>\", StringEscapeUtils.unescapeXml(\"&lt;abc&gt;\"));\n+\n+        assertEquals(\"XML should use numbers, not names for HTML entities\",\n+                \"&#161;\", StringEscapeUtils.escapeXml(\"\\u00A1\"));\n+        assertEquals(\"XML should use numbers, not names for HTML entities\",\n+                \"\\u00A0\", StringEscapeUtils.unescapeXml(\"&#160;\"));\n+\n+        assertEquals(\"ain't\", StringEscapeUtils.unescapeXml(\"ain&apos;t\"));\n+        assertEquals(\"ain&apos;t\", StringEscapeUtils.escapeXml(\"ain't\"));\n+        assertEquals(\"\", StringEscapeUtils.escapeXml(\"\"));\n+        assertEquals(null, StringEscapeUtils.escapeXml(null));\n+        assertEquals(null, StringEscapeUtils.unescapeXml(null));\n+\n+        StringWriter sw = new StringWriter();\n+        try {\n+            StringEscapeUtils.escapeXml(sw, \"<abc>\");\n+        } catch (IOException e) {\n+        }\n+        assertEquals(\"XML was escaped incorrectly\", \"&lt;abc&gt;\", sw.toString() );\n+\n+        sw = new StringWriter();\n+        try {\n+            StringEscapeUtils.unescapeXml(sw, \"&lt;abc&gt;\");\n+        } catch (IOException e) {\n+        }\n+        assertEquals(\"XML was unescaped incorrectly\", \"<abc>\", sw.toString() );\n+    }\n+\n+    // SQL\n+    // see http://www.jguru.com/faq/view.jsp?EID=8881\n+    //--------------------\n+\n+    public void testEscapeSql() throws Exception\n+    {\n+        assertEquals(\"don''t stop\", StringEscapeUtils.escapeSql(\"don't stop\"));\n+        assertEquals(\"\", StringEscapeUtils.escapeSql(\"\"));\n+        assertEquals(null, StringEscapeUtils.escapeSql(null));\n+    }\n+\n+    // Tests issue #38569\n+    // http://issues.apache.org/bugzilla/show_bug.cgi?id=38569\n+    public void testStandaloneAmphersand() {\n+        assertEquals(\"<P&O>\", StringEscapeUtils.unescapeHtml(\"&lt;P&O&gt;\"));\n+        assertEquals(\"test & <\", StringEscapeUtils.unescapeHtml(\"test & &lt;\"));\n+        assertEquals(\"<P&O>\", StringEscapeUtils.unescapeXml(\"&lt;P&O&gt;\"));\n+        assertEquals(\"test & <\", StringEscapeUtils.unescapeXml(\"test & &lt;\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/StringUtilsEqualsIndexOfTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public class StringUtilsEqualsIndexOfTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+    private static final String FOOBAR = \"foobar\";\n+    private static final String[] FOOBAR_SUB_ARRAY = new String[] {\"ob\", \"ba\"};\n+\n+    public StringUtilsEqualsIndexOfTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsEqualsIndexOfTest.class);\n+        suite.setName(\"StringUtilsEqualsIndexOf Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testEquals() {\n+        assertEquals(true, StringUtils.equals(null, null));\n+        assertEquals(true, StringUtils.equals(FOO, FOO));\n+        assertEquals(true, StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));\n+        assertEquals(false, StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));\n+        assertEquals(false, StringUtils.equals(FOO, BAR));\n+        assertEquals(false, StringUtils.equals(FOO, null));\n+        assertEquals(false, StringUtils.equals(null, FOO));\n+    }\n+\n+    public void testEqualsIgnoreCase() {\n+        assertEquals(true, StringUtils.equalsIgnoreCase(null, null));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, FOO));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' })));\n+        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' })));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, BAR));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, null));\n+        assertEquals(false, StringUtils.equalsIgnoreCase(null, FOO));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOf_char() {\n+        assertEquals(-1, StringUtils.indexOf(null, ' '));\n+        assertEquals(-1, StringUtils.indexOf(\"\", ' '));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", 'a'));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b'));\n+    }\n+\n+    public void testIndexOf_charInt() {\n+        assertEquals(-1, StringUtils.indexOf(null, ' ', 0));\n+        assertEquals(-1, StringUtils.indexOf(null, ' ', -1));\n+        assertEquals(-1, StringUtils.indexOf(\"\", ' ', 0));\n+        assertEquals(-1, StringUtils.indexOf(\"\", ' ', -1));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", 'a', 0));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b', 0));\n+        assertEquals(5, StringUtils.indexOf(\"aabaabaa\", 'b', 3));\n+        assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", 'b', 9));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b', -1));\n+    }\n+\n+    public void testIndexOf_String() {\n+        assertEquals(-1, StringUtils.indexOf(null, null));\n+        assertEquals(-1, StringUtils.indexOf(\"\", null));\n+        assertEquals(0, StringUtils.indexOf(\"\", \"\"));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"a\"));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\"));\n+        assertEquals(1, StringUtils.indexOf(\"aabaabaa\", \"ab\"));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"\"));\n+    }\n+\n+    public void testOrdinalIndexOf() {\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", Integer.MIN_VALUE));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", -1));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 0));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1));\n+        assertEquals(2, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 2));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 2));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", 2));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2));\n+        assertEquals(5, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2));\n+        assertEquals(4, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, Integer.MAX_VALUE));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", Integer.MAX_VALUE));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", Integer.MAX_VALUE));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 0));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 1));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 2));\n+        assertEquals(2, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 3));\n+        assertEquals(3, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 4));\n+        assertEquals(4, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 5));\n+        assertEquals(5, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 6));\n+        assertEquals(6, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 7));\n+        assertEquals(7, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 8));\n+        assertEquals(8, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 9));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 10));\n+    }\n+\n+    public void testIndexOf_StringInt() {\n+        assertEquals(-1, StringUtils.indexOf(null, null, 0));\n+        assertEquals(-1, StringUtils.indexOf(null, null, -1));\n+        assertEquals(-1, StringUtils.indexOf(null, \"\", 0));\n+        assertEquals(-1, StringUtils.indexOf(null, \"\", -1));\n+        assertEquals(-1, StringUtils.indexOf(\"\", null, 0));\n+        assertEquals(-1, StringUtils.indexOf(\"\", null, -1));\n+        assertEquals(0, StringUtils.indexOf(\"\", \"\", 0));\n+        assertEquals(0, StringUtils.indexOf(\"\", \"\", -1));\n+        assertEquals(0, StringUtils.indexOf(\"\", \"\", 9));\n+        assertEquals(0, StringUtils.indexOf(\"abc\", \"\", 0));\n+        assertEquals(0, StringUtils.indexOf(\"abc\", \"\", -1));\n+        assertEquals(3, StringUtils.indexOf(\"abc\", \"\", 9));\n+        assertEquals(3, StringUtils.indexOf(\"abc\", \"\", 3));\n+        assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"a\", 0));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\", 0));\n+        assertEquals(1, StringUtils.indexOf(\"aabaabaa\", \"ab\", 0));\n+        assertEquals(5, StringUtils.indexOf(\"aabaabaa\", \"b\", 3));\n+        assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", \"b\", 9));\n+        assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\", -1));\n+        assertEquals(2,StringUtils.indexOf(\"aabaabaa\", \"\", 2)); \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLastIndexOf_char() {\n+        assertEquals(-1, StringUtils.lastIndexOf(null, ' '));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", ' '));\n+        assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", 'a'));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b'));\n+    }\n+\n+    public void testLastIndexOf_charInt() {\n+        assertEquals(-1, StringUtils.lastIndexOf(null, ' ', 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(null, ' ', -1));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", ' ', 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", ' ', -1));\n+        assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", 'a', 8));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 8));\n+        assertEquals(2, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 3));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1));\n+        assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0));\n+    }\n+\n+    public void testLastIndexOf_String() {\n+        assertEquals(-1, StringUtils.lastIndexOf(null, null));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", null));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", \"a\"));\n+        assertEquals(0, StringUtils.lastIndexOf(\"\", \"\"));\n+        assertEquals(8, StringUtils.lastIndexOf(\"aabaabaa\", \"\"));\n+        assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", \"a\"));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\"));\n+        assertEquals(4, StringUtils.lastIndexOf(\"aabaabaa\", \"ab\"));\n+    }\n+\n+    public void testLastIndexOf_StringInt() {\n+        assertEquals(-1, StringUtils.lastIndexOf(null, null, 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(null, null, -1));\n+        assertEquals(-1, StringUtils.lastIndexOf(null, \"\", 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(null, \"\", -1));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", null, 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", null, -1));\n+        assertEquals(0, StringUtils.lastIndexOf(\"\", \"\", 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"\", \"\", -1));\n+        assertEquals(0, StringUtils.lastIndexOf(\"\", \"\", 9));\n+        assertEquals(0, StringUtils.lastIndexOf(\"abc\", \"\", 0));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"abc\", \"\", -1));\n+        assertEquals(3, StringUtils.lastIndexOf(\"abc\", \"\", 9));\n+        assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8));\n+        assertEquals(4, StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8));\n+        assertEquals(2, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 3));\n+        assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1));\n+        assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0));\n+        assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testContainsChar() {\n+        assertEquals(false, StringUtils.contains(null, ' '));\n+        assertEquals(false, StringUtils.contains(\"\", ' '));\n+        assertEquals(false, StringUtils.contains(\"\",null));\n+        assertEquals(false, StringUtils.contains(null,null));\n+        assertEquals(true, StringUtils.contains(\"abc\", 'a'));\n+        assertEquals(true, StringUtils.contains(\"abc\", 'b'));\n+        assertEquals(true, StringUtils.contains(\"abc\", 'c'));\n+        assertEquals(false, StringUtils.contains(\"abc\", 'z'));\n+    }\n+\n+    public void testContainsString() {\n+        assertEquals(false, StringUtils.contains(null, null));\n+        assertEquals(false, StringUtils.contains(null, \"\"));\n+        assertEquals(false, StringUtils.contains(null, \"a\"));\n+        assertEquals(false, StringUtils.contains(\"\", null));\n+        assertEquals(true, StringUtils.contains(\"\", \"\"));\n+        assertEquals(false, StringUtils.contains(\"\", \"a\"));\n+        assertEquals(true, StringUtils.contains(\"abc\", \"a\"));\n+        assertEquals(true, StringUtils.contains(\"abc\", \"b\"));\n+        assertEquals(true, StringUtils.contains(\"abc\", \"c\"));\n+        assertEquals(true, StringUtils.contains(\"abc\", \"abc\"));\n+        assertEquals(false, StringUtils.contains(\"abc\", \"z\"));\n+    }\n+\n+    public void testContainsIgnoreCase_StringString() {\n+        assertFalse(StringUtils.containsIgnoreCase(null, null));\n+        \n+        // Null tests\n+        assertFalse(StringUtils.containsIgnoreCase(null, \"\"));\n+        assertFalse(StringUtils.containsIgnoreCase(null, \"a\"));\n+        assertFalse(StringUtils.containsIgnoreCase(null, \"abc\"));\n+        \n+        assertFalse(StringUtils.containsIgnoreCase(\"\", null));\n+        assertFalse(StringUtils.containsIgnoreCase(\"a\", null));\n+        assertFalse(StringUtils.containsIgnoreCase(\"abc\", null));\n+        \n+        // Match len = 0\n+        assertTrue(StringUtils.containsIgnoreCase(\"\", \"\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"a\", \"\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"abc\", \"\"));\n+\n+        // Match len = 1\n+        assertFalse(StringUtils.containsIgnoreCase(\"\", \"a\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"a\", \"a\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"abc\", \"a\"));\n+        assertFalse(StringUtils.containsIgnoreCase(\"\", \"A\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"a\", \"A\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"abc\", \"A\"));\n+        \n+        // Match len > 1\n+        assertFalse(StringUtils.containsIgnoreCase(\"\", \"abc\"));\n+        assertFalse(StringUtils.containsIgnoreCase(\"a\", \"abc\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"xabcz\", \"abc\"));\n+        assertFalse(StringUtils.containsIgnoreCase(\"\", \"ABC\"));\n+        assertFalse(StringUtils.containsIgnoreCase(\"a\", \"ABC\"));\n+        assertTrue(StringUtils.containsIgnoreCase(\"xabcz\", \"ABC\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOfAny_StringStringarray() {\n+        assertEquals(-1, StringUtils.indexOfAny(null, (String[]) null));\n+        assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, (String[]) null));\n+        assertEquals(2, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(null, new String[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new String[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {\"llll\"}));\n+        assertEquals(0, StringUtils.indexOfAny(FOOBAR, new String[] {\"\"}));\n+        assertEquals(0, StringUtils.indexOfAny(\"\", new String[] {\"\"}));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new String[] {\"a\"}));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new String[] {null}));\n+        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {null}));\n+        assertEquals(-1, StringUtils.indexOfAny(null, new String[] {null}));\n+    }\n+\n+    public void testLastIndexOfAny_StringStringarray() {\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, null));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, null));\n+        assertEquals(3, StringUtils.lastIndexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[0]));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, new String[0]));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(\"\", new String[0]));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {\"llll\"}));\n+        assertEquals(6, StringUtils.lastIndexOfAny(FOOBAR, new String[] {\"\"}));\n+        assertEquals(0, StringUtils.lastIndexOfAny(\"\", new String[] {\"\"}));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(\"\", new String[] {\"a\"}));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(\"\", new String[] {null}));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {null}));\n+        assertEquals(-1, StringUtils.lastIndexOfAny(null, new String[] {null}));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOfAny_StringChararray() {\n+        assertEquals(-1, StringUtils.indexOfAny(null, (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAny(null, new char[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(null, new char[] {'a','b'}));\n+        \n+        assertEquals(-1, StringUtils.indexOfAny(\"\", (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new char[0]));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", new char[] {'a','b'}));\n+        \n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", (char[]) null)); \n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", new char[0])); \n+        assertEquals(0, StringUtils.indexOfAny(\"zzabyycdxx\", new char[] {'z','a'})); \n+        assertEquals(3, StringUtils.indexOfAny(\"zzabyycdxx\", new char[] {'b','y'}));\n+        assertEquals(-1, StringUtils.indexOfAny(\"ab\", new char[] {'z'}));\n+    }\n+\n+    public void testIndexOfAny_StringString() {\n+        assertEquals(-1, StringUtils.indexOfAny(null, (String) null));\n+        assertEquals(-1, StringUtils.indexOfAny(null, \"\"));\n+        assertEquals(-1, StringUtils.indexOfAny(null, \"ab\"));\n+        \n+        assertEquals(-1, StringUtils.indexOfAny(\"\", (String) null));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", \"\"));\n+        assertEquals(-1, StringUtils.indexOfAny(\"\", \"ab\"));\n+        \n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", (String) null)); \n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", \"\")); \n+        assertEquals(0, StringUtils.indexOfAny(\"zzabyycdxx\", \"za\")); \n+        assertEquals(3, StringUtils.indexOfAny(\"zzabyycdxx\", \"by\"));\n+        assertEquals(-1, StringUtils.indexOfAny(\"ab\", \"z\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOfAnyBut_StringChararray() {\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, new char[0]));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, new char[] {'a','b'}));\n+        \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", new char[0]));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", new char[] {'a','b'}));\n+        \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[0]));\n+        assertEquals(3, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'z','a'})); \n+        assertEquals(0, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'b','y'})); \n+        assertEquals(0, StringUtils.indexOfAnyBut(\"ab\", new char[] {'z'}));\n+    }\n+\n+    public void testIndexOfAnyBut_StringString() {\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, (String) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, \"\"));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(null, \"ab\"));\n+        \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", (String) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", \"\"));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"\", \"ab\"));\n+        \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", (String) null)); \n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")); \n+        assertEquals(3, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\")); \n+        assertEquals(0, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"by\"));\n+        assertEquals(0, StringUtils.indexOfAnyBut(\"ab\", \"z\"));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testContainsOnly_String() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab\";\n+        String chars1= \"b\";\n+        String chars2= \"a\";\n+        String chars3= \"ab\";\n+        assertEquals(false, StringUtils.containsOnly(null, (String) null));\n+        assertEquals(false, StringUtils.containsOnly(\"\", (String) null));\n+        assertEquals(false, StringUtils.containsOnly(null, \"\"));\n+        assertEquals(false, StringUtils.containsOnly(str1, \"\"));\n+        assertEquals(true, StringUtils.containsOnly(\"\", \"\"));\n+        assertEquals(true, StringUtils.containsOnly(\"\", chars1));\n+        assertEquals(false, StringUtils.containsOnly(str1, chars1));\n+        assertEquals(true, StringUtils.containsOnly(str1, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str1, chars3));\n+        assertEquals(true, StringUtils.containsOnly(str2, chars1));\n+        assertEquals(false, StringUtils.containsOnly(str2, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str2, chars3));\n+        assertEquals(false, StringUtils.containsOnly(str3, chars1));\n+        assertEquals(false, StringUtils.containsOnly(str3, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str3, chars3));\n+    }\n+\n+    public void testContainsOnly_Chararray() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab\";\n+        char[] chars1= {'b'};\n+        char[] chars2= {'a'};\n+        char[] chars3= {'a', 'b'};\n+        char[] emptyChars = new char[0];\n+        assertEquals(false, StringUtils.containsOnly(null, (char[]) null));\n+        assertEquals(false, StringUtils.containsOnly(\"\", (char[]) null));\n+        assertEquals(false, StringUtils.containsOnly(null, emptyChars));\n+        assertEquals(false, StringUtils.containsOnly(str1, emptyChars));\n+        assertEquals(true, StringUtils.containsOnly(\"\", emptyChars));\n+        assertEquals(true, StringUtils.containsOnly(\"\", chars1));\n+        assertEquals(false, StringUtils.containsOnly(str1, chars1));\n+        assertEquals(true, StringUtils.containsOnly(str1, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str1, chars3));\n+        assertEquals(true, StringUtils.containsOnly(str2, chars1));\n+        assertEquals(false, StringUtils.containsOnly(str2, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str2, chars3));\n+        assertEquals(false, StringUtils.containsOnly(str3, chars1));\n+        assertEquals(false, StringUtils.containsOnly(str3, chars2));\n+        assertEquals(true, StringUtils.containsOnly(str3, chars3));\n+    }\n+\n+    public void testContainsNone_String() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab.\";\n+        String chars1= \"b\";\n+        String chars2= \".\";\n+        String chars3= \"cd\";\n+        assertEquals(true, StringUtils.containsNone(null, (String) null));\n+        assertEquals(true, StringUtils.containsNone(\"\", (String) null));\n+        assertEquals(true, StringUtils.containsNone(null, \"\"));\n+        assertEquals(true, StringUtils.containsNone(str1, \"\"));\n+        assertEquals(true, StringUtils.containsNone(\"\", \"\"));\n+        assertEquals(true, StringUtils.containsNone(\"\", chars1));\n+        assertEquals(true, StringUtils.containsNone(str1, chars1));\n+        assertEquals(true, StringUtils.containsNone(str1, chars2));\n+        assertEquals(true, StringUtils.containsNone(str1, chars3));\n+        assertEquals(false, StringUtils.containsNone(str2, chars1));\n+        assertEquals(true, StringUtils.containsNone(str2, chars2));\n+        assertEquals(true, StringUtils.containsNone(str2, chars3));\n+        assertEquals(false, StringUtils.containsNone(str3, chars1));\n+        assertEquals(false, StringUtils.containsNone(str3, chars2));\n+        assertEquals(true, StringUtils.containsNone(str3, chars3));\n+    }\n+\n+    public void testContainsNone_Chararray() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab.\";\n+        char[] chars1= {'b'};\n+        char[] chars2= {'.'};\n+        char[] chars3= {'c', 'd'};\n+        char[] emptyChars = new char[0];\n+        assertEquals(true, StringUtils.containsNone(null, (char[]) null));\n+        assertEquals(true, StringUtils.containsNone(\"\", (char[]) null));\n+        assertEquals(true, StringUtils.containsNone(null, emptyChars));\n+        assertEquals(true, StringUtils.containsNone(str1, emptyChars));\n+        assertEquals(true, StringUtils.containsNone(\"\", emptyChars));\n+        assertEquals(true, StringUtils.containsNone(\"\", chars1));\n+        assertEquals(true, StringUtils.containsNone(str1, chars1));\n+        assertEquals(true, StringUtils.containsNone(str1, chars2));\n+        assertEquals(true, StringUtils.containsNone(str1, chars3));\n+        assertEquals(false, StringUtils.containsNone(str2, chars1));\n+        assertEquals(true, StringUtils.containsNone(str2, chars2));\n+        assertEquals(true, StringUtils.containsNone(str2, chars3));\n+        assertEquals(false, StringUtils.containsNone(str3, chars1));\n+        assertEquals(false, StringUtils.containsNone(str3, chars2));\n+        assertEquals(true, StringUtils.containsNone(str3, chars3));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/StringUtilsIsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author Michael Davey\n+ * @version $Id$\n+ */\n+public class StringUtilsIsTest extends TestCase {\n+\n+    public StringUtilsIsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsIsTest.class);\n+        suite.setName(\"StringUtilsIsXxx Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testIsAlpha() {\n+        assertEquals(false, StringUtils.isAlpha(null));\n+        assertEquals(true, StringUtils.isAlpha(\"\"));\n+        assertEquals(false, StringUtils.isAlpha(\" \"));\n+        assertEquals(true, StringUtils.isAlpha(\"a\"));\n+        assertEquals(true, StringUtils.isAlpha(\"A\"));\n+        assertEquals(true, StringUtils.isAlpha(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isAlpha(\"ham kso\"));\n+        assertEquals(false, StringUtils.isAlpha(\"1\"));\n+        assertEquals(false, StringUtils.isAlpha(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlpha(\"_\"));\n+        assertEquals(false, StringUtils.isAlpha(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAlphanumeric() {\n+        assertEquals(false, StringUtils.isAlphanumeric(null));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\" \"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"a\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"A\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"ham kso\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"1\"));\n+        assertEquals(true, StringUtils.isAlphanumeric(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"_\"));\n+        assertEquals(false, StringUtils.isAlphanumeric(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsWhitespace() {\n+        assertEquals(false, StringUtils.isWhitespace(null));\n+        assertEquals(true, StringUtils.isWhitespace(\"\"));\n+        assertEquals(true, StringUtils.isWhitespace(\" \"));\n+        assertEquals(true, StringUtils.isWhitespace(\"\\t \\n \\t\"));\n+        assertEquals(false, StringUtils.isWhitespace(\"\\t aa\\n \\t\"));\n+        assertEquals(true, StringUtils.isWhitespace(\" \"));\n+        assertEquals(false, StringUtils.isWhitespace(\" a \"));\n+        assertEquals(false, StringUtils.isWhitespace(\"a  \"));\n+        assertEquals(false, StringUtils.isWhitespace(\"  a\"));\n+        assertEquals(false, StringUtils.isWhitespace(\"aba\"));\n+        assertEquals(true, StringUtils.isWhitespace(StringUtilsTest.WHITESPACE));\n+        assertEquals(false, StringUtils.isWhitespace(StringUtilsTest.NON_WHITESPACE));\n+    }\n+\n+    public void testIsAlphaspace() {\n+        assertEquals(false, StringUtils.isAlphaSpace(null));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\" \"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"a\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"A\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(true, StringUtils.isAlphaSpace(\"ham kso\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"1\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"_\"));\n+        assertEquals(false, StringUtils.isAlphaSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAlphanumericSpace() {\n+        assertEquals(false, StringUtils.isAlphanumericSpace(null));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\" \"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"a\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"A\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"ham kso\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"1\"));\n+        assertEquals(true, StringUtils.isAlphanumericSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isAlphanumericSpace(\"_\"));\n+        assertEquals(false, StringUtils.isAlphanumericSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsAsciiPrintable_String() {\n+        assertEquals(false, StringUtils.isAsciiPrintable(null));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\" \"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"a\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"A\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"1\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"Ceki\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"!ab2c~\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"1000\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"10 00\"));\n+        assertEquals(false, StringUtils.isAsciiPrintable(\"10\\t00\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"10.00\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"10,00\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"!ab-c~\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"hkHK=Hik6i?UGH_KJgU7.tUJgKJ*GI87GI,kug\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"\\u0020\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"\\u0021\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"\\u007e\"));\n+        assertEquals(false, StringUtils.isAsciiPrintable(\"\\u007f\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"G?lc?\"));\n+        assertEquals(true, StringUtils.isAsciiPrintable(\"=?iso-8859-1?Q?G=FClc=FC?=\"));\n+        assertEquals(false, StringUtils.isAsciiPrintable(\"G\\u00fclc\\u00fc\"));\n+    }\n+  \n+    public void testIsNumeric() {\n+        assertEquals(false, StringUtils.isNumeric(null));\n+        assertEquals(true, StringUtils.isNumeric(\"\"));\n+        assertEquals(false, StringUtils.isNumeric(\" \"));\n+        assertEquals(false, StringUtils.isNumeric(\"a\"));\n+        assertEquals(false, StringUtils.isNumeric(\"A\"));\n+        assertEquals(false, StringUtils.isNumeric(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isNumeric(\"ham kso\"));\n+        assertEquals(true, StringUtils.isNumeric(\"1\"));\n+        assertEquals(true, StringUtils.isNumeric(\"1000\"));\n+        assertEquals(false, StringUtils.isNumeric(\"2.3\"));\n+        assertEquals(false, StringUtils.isNumeric(\"10 00\"));\n+        assertEquals(false, StringUtils.isNumeric(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isNumeric(\"_\"));\n+        assertEquals(false, StringUtils.isNumeric(\"hkHKHik*khbkuh\"));\n+    }\n+\n+    public void testIsNumericSpace() {\n+        assertEquals(false, StringUtils.isNumericSpace(null));\n+        assertEquals(true, StringUtils.isNumericSpace(\"\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\" \"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"a\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"A\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"ham kso\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"1\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"1000\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"2.3\"));\n+        assertEquals(true, StringUtils.isNumericSpace(\"10 00\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"hkHKHik6iUGHKJgU7tUJgKJGI87GIkug\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"_\"));\n+        assertEquals(false, StringUtils.isNumericSpace(\"hkHKHik*khbkuh\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/StringUtilsSubstringTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public class StringUtilsSubstringTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+    private static final String BAR = \"bar\";\n+    private static final String BAZ = \"baz\";\n+    private static final String FOOBAR = \"foobar\";\n+    private static final String SENTENCE = \"foo bar baz\";\n+\n+    public StringUtilsSubstringTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsSubstringTest.class);\n+        suite.setName(\"StringUtilsSubstring Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+\n+    public void testSubstring_StringInt() {\n+        assertEquals(null, StringUtils.substring(null, 0));\n+        assertEquals(\"\", StringUtils.substring(\"\", 0));\n+        assertEquals(\"\", StringUtils.substring(\"\", 2));\n+        \n+        assertEquals(\"\", StringUtils.substring(SENTENCE, 80));\n+        assertEquals(BAZ, StringUtils.substring(SENTENCE, 8));\n+        assertEquals(BAZ, StringUtils.substring(SENTENCE, -3));\n+        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0));\n+        assertEquals(\"abc\", StringUtils.substring(\"abc\", -4));\n+        assertEquals(\"abc\", StringUtils.substring(\"abc\", -3));\n+        assertEquals(\"bc\", StringUtils.substring(\"abc\", -2));\n+        assertEquals(\"c\", StringUtils.substring(\"abc\", -1));\n+        assertEquals(\"abc\", StringUtils.substring(\"abc\", 0));\n+        assertEquals(\"bc\", StringUtils.substring(\"abc\", 1));\n+        assertEquals(\"c\", StringUtils.substring(\"abc\", 2));\n+        assertEquals(\"\", StringUtils.substring(\"abc\", 3));\n+        assertEquals(\"\", StringUtils.substring(\"abc\", 4));\n+    }\n+    \n+    public void testSubstring_StringIntInt() {\n+        assertEquals(null, StringUtils.substring(null, 0, 0));\n+        assertEquals(null, StringUtils.substring(null, 1, 2));\n+        assertEquals(\"\", StringUtils.substring(\"\", 0, 0));\n+        assertEquals(\"\", StringUtils.substring(\"\", 1, 2));\n+        assertEquals(\"\", StringUtils.substring(\"\", -2, -1));\n+        \n+        assertEquals(\"\", StringUtils.substring(SENTENCE, 8, 6));\n+        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, 3));\n+        assertEquals(\"o\", StringUtils.substring(SENTENCE, -9, 3));\n+        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, -8));\n+        assertEquals(\"o\", StringUtils.substring(SENTENCE, -9, -8));\n+        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0, 80));\n+        assertEquals(\"\", StringUtils.substring(SENTENCE, 2, 2));\n+        assertEquals(\"b\",StringUtils.substring(\"abc\", -2, -1));\n+    }\n+           \n+    public void testLeft_String() {\n+        assertSame(null, StringUtils.left(null, -1));\n+        assertSame(null, StringUtils.left(null, 0));\n+        assertSame(null, StringUtils.left(null, 2));\n+        \n+        assertEquals(\"\", StringUtils.left(\"\", -1));\n+        assertEquals(\"\", StringUtils.left(\"\", 0));\n+        assertEquals(\"\", StringUtils.left(\"\", 2));\n+        \n+        assertEquals(\"\", StringUtils.left(FOOBAR, -1));\n+        assertEquals(\"\", StringUtils.left(FOOBAR, 0));\n+        assertEquals(FOO, StringUtils.left(FOOBAR, 3));\n+        assertSame(FOOBAR, StringUtils.left(FOOBAR, 80));\n+    }\n+    \n+    public void testRight_String() {\n+        assertSame(null, StringUtils.right(null, -1));\n+        assertSame(null, StringUtils.right(null, 0));\n+        assertSame(null, StringUtils.right(null, 2));\n+        \n+        assertEquals(\"\", StringUtils.right(\"\", -1));\n+        assertEquals(\"\", StringUtils.right(\"\", 0));\n+        assertEquals(\"\", StringUtils.right(\"\", 2));\n+        \n+        assertEquals(\"\", StringUtils.right(FOOBAR, -1));\n+        assertEquals(\"\", StringUtils.right(FOOBAR, 0));\n+        assertEquals(BAR, StringUtils.right(FOOBAR, 3));\n+        assertSame(FOOBAR, StringUtils.right(FOOBAR, 80));\n+    }\n+    \n+    public void testMid_String() {\n+        assertSame(null, StringUtils.mid(null, -1, 0));\n+        assertSame(null, StringUtils.mid(null, 0, -1));\n+        assertSame(null, StringUtils.mid(null, 3, 0));\n+        assertSame(null, StringUtils.mid(null, 3, 2));\n+        \n+        assertEquals(\"\", StringUtils.mid(\"\", 0, -1));\n+        assertEquals(\"\", StringUtils.mid(\"\", 0, 0));\n+        assertEquals(\"\", StringUtils.mid(\"\", 0, 2));\n+        \n+        assertEquals(\"\", StringUtils.mid(FOOBAR, 3, -1));\n+        assertEquals(\"\", StringUtils.mid(FOOBAR, 3, 0));\n+        assertEquals(\"b\", StringUtils.mid(FOOBAR, 3, 1));\n+        assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3));\n+        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3));\n+        assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80));\n+        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80));\n+        assertEquals(\"\", StringUtils.mid(FOOBAR, 9, 3));\n+        assertEquals(FOO, StringUtils.mid(FOOBAR, -1, 3));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSubstringBefore_StringString() {\n+        assertEquals(\"foo\", StringUtils.substringBefore(\"fooXXbarXXbaz\", \"XX\"));\n+\n+        assertEquals(null, StringUtils.substringBefore(null, null));\n+        assertEquals(null, StringUtils.substringBefore(null, \"\"));\n+        assertEquals(null, StringUtils.substringBefore(null, \"XX\"));\n+        assertEquals(\"\", StringUtils.substringBefore(\"\", null));\n+        assertEquals(\"\", StringUtils.substringBefore(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBefore(\"\", \"XX\"));\n+        \n+        assertEquals(\"foo\", StringUtils.substringBefore(\"foo\", null));\n+        assertEquals(\"foo\", StringUtils.substringBefore(\"foo\", \"b\"));\n+        assertEquals(\"f\", StringUtils.substringBefore(\"foot\", \"o\"));\n+        assertEquals(\"\", StringUtils.substringBefore(\"abc\", \"a\"));\n+        assertEquals(\"a\", StringUtils.substringBefore(\"abcba\", \"b\"));\n+        assertEquals(\"ab\", StringUtils.substringBefore(\"abc\", \"c\"));\n+        assertEquals(\"\", StringUtils.substringBefore(\"abc\", \"\"));\n+    }\n+    \n+    public void testSubstringAfter_StringString() {\n+        assertEquals(\"barXXbaz\", StringUtils.substringAfter(\"fooXXbarXXbaz\", \"XX\"));\n+        \n+        assertEquals(null, StringUtils.substringAfter(null, null));\n+        assertEquals(null, StringUtils.substringAfter(null, \"\"));\n+        assertEquals(null, StringUtils.substringAfter(null, \"XX\"));\n+        assertEquals(\"\", StringUtils.substringAfter(\"\", null));\n+        assertEquals(\"\", StringUtils.substringAfter(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringAfter(\"\", \"XX\"));\n+        \n+        assertEquals(\"\", StringUtils.substringAfter(\"foo\", null));\n+        assertEquals(\"ot\", StringUtils.substringAfter(\"foot\", \"o\"));\n+        assertEquals(\"bc\", StringUtils.substringAfter(\"abc\", \"a\"));\n+        assertEquals(\"cba\", StringUtils.substringAfter(\"abcba\", \"b\"));\n+        assertEquals(\"\", StringUtils.substringAfter(\"abc\", \"c\"));\n+        assertEquals(\"abc\", StringUtils.substringAfter(\"abc\", \"\"));\n+        assertEquals(\"\", StringUtils.substringAfter(\"abc\", \"d\"));\n+    }\n+\n+    public void testSubstringBeforeLast_StringString() {\n+        assertEquals(\"fooXXbar\", StringUtils.substringBeforeLast(\"fooXXbarXXbaz\", \"XX\"));\n+\n+        assertEquals(null, StringUtils.substringBeforeLast(null, null));\n+        assertEquals(null, StringUtils.substringBeforeLast(null, \"\"));\n+        assertEquals(null, StringUtils.substringBeforeLast(null, \"XX\"));\n+        assertEquals(\"\", StringUtils.substringBeforeLast(\"\", null));\n+        assertEquals(\"\", StringUtils.substringBeforeLast(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBeforeLast(\"\", \"XX\"));\n+\n+        assertEquals(\"foo\", StringUtils.substringBeforeLast(\"foo\", null));\n+        assertEquals(\"foo\", StringUtils.substringBeforeLast(\"foo\", \"b\"));\n+        assertEquals(\"fo\", StringUtils.substringBeforeLast(\"foo\", \"o\"));\n+        assertEquals(\"abc\\r\\n\", StringUtils.substringBeforeLast(\"abc\\r\\n\", \"d\"));\n+        assertEquals(\"abc\", StringUtils.substringBeforeLast(\"abcdabc\", \"d\"));\n+        assertEquals(\"abcdabc\", StringUtils.substringBeforeLast(\"abcdabcd\", \"d\"));\n+        assertEquals(\"a\", StringUtils.substringBeforeLast(\"abc\", \"b\"));\n+        assertEquals(\"abc \", StringUtils.substringBeforeLast(\"abc \\n\", \"\\n\"));\n+        assertEquals(\"a\", StringUtils.substringBeforeLast(\"a\", null));\n+        assertEquals(\"a\", StringUtils.substringBeforeLast(\"a\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBeforeLast(\"a\", \"a\"));\n+    }\n+    \n+    public void testSubstringAfterLast_StringString() {\n+        assertEquals(\"baz\", StringUtils.substringAfterLast(\"fooXXbarXXbaz\", \"XX\"));\n+\n+        assertEquals(null, StringUtils.substringAfterLast(null, null));\n+        assertEquals(null, StringUtils.substringAfterLast(null, \"\"));\n+        assertEquals(null, StringUtils.substringAfterLast(null, \"XX\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"\", null));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"\", \"a\"));\n+\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"foo\", null));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"foo\", \"b\"));\n+        assertEquals(\"t\", StringUtils.substringAfterLast(\"foot\", \"o\"));\n+        assertEquals(\"bc\", StringUtils.substringAfterLast(\"abc\", \"a\"));\n+        assertEquals(\"a\", StringUtils.substringAfterLast(\"abcba\", \"b\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"abc\", \"c\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"\", \"d\"));\n+        assertEquals(\"\", StringUtils.substringAfterLast(\"abc\", \"\"));\n+    }        \n+        \n+    //-----------------------------------------------------------------------\n+    public void testSubstringBetween_StringString() {\n+        assertEquals(null, StringUtils.substringBetween(null, \"tag\"));\n+        assertEquals(\"\", StringUtils.substringBetween(\"\", \"\"));\n+        assertEquals(null, StringUtils.substringBetween(\"\", \"abc\"));\n+        assertEquals(\"\", StringUtils.substringBetween(\"    \", \" \"));\n+        assertEquals(null, StringUtils.substringBetween(\"abc\", null));\n+        assertEquals(\"\", StringUtils.substringBetween(\"abc\", \"\"));\n+        assertEquals(null, StringUtils.substringBetween(\"abc\", \"a\"));\n+        assertEquals(\"bc\", StringUtils.substringBetween(\"abca\", \"a\"));\n+        assertEquals(\"bc\", StringUtils.substringBetween(\"abcabca\", \"a\"));\n+        assertEquals(\"bar\", StringUtils.substringBetween(\"\\nbar\\n\", \"\\n\"));\n+    }\n+            \n+    public void testSubstringBetween_StringStringString() {\n+        assertEquals(null, StringUtils.substringBetween(null, \"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBetween(\"\", \"\", \"\"));\n+        assertEquals(\"\", StringUtils.substringBetween(\"    \", \" \", \"  \"));\n+        assertEquals(\"bar\", StringUtils.substringBetween(\"<foo>bar</foo>\", \"<foo>\", \"</foo>\") );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCountMatches_String() {\n+        assertEquals(0, StringUtils.countMatches(null, null));\n+        assertEquals(0, StringUtils.countMatches(\"blah\", null));\n+        assertEquals(0, StringUtils.countMatches(null, \"DD\"));\n+\n+        assertEquals(0, StringUtils.countMatches(\"x\", \"\"));\n+        assertEquals(0, StringUtils.countMatches(\"\", \"\"));\n+\n+        assertEquals(3, \n+             StringUtils.countMatches(\"one long someone sentence of one\", \"one\"));\n+        assertEquals(0, \n+             StringUtils.countMatches(\"one long someone sentence of one\", \"two\"));\n+        assertEquals(4, \n+             StringUtils.countMatches(\"oooooooooooo\", \"ooo\"));\n+    }\n+\n+    public void testGetNestedString_StringString() {\n+        assertEquals(null, StringUtils.getNestedString(null, \"tag\"));\n+        assertEquals(\"\", StringUtils.getNestedString(\"\", \"\"));\n+        assertEquals(null, StringUtils.getNestedString(\"\", \"abc\"));\n+        assertEquals(\"\", StringUtils.getNestedString(\"    \", \" \"));\n+        assertEquals(null, StringUtils.getNestedString(\"abc\", null));\n+        assertEquals(\"\", StringUtils.getNestedString(\"abc\", \"\"));\n+        assertEquals(null, StringUtils.getNestedString(\"abc\", \"a\"));\n+        assertEquals(\"bc\", StringUtils.getNestedString(\"abca\", \"a\"));\n+        assertEquals(\"bc\", StringUtils.getNestedString(\"abcabca\", \"a\"));\n+        assertEquals(\"bar\", StringUtils.getNestedString(\"\\nbar\\n\", \"\\n\"));\n+    }\n+            \n+    public void testGetNestedString_StringStringString() {\n+        assertEquals(null, StringUtils.getNestedString(null, \"\", \"\"));\n+        assertEquals(\"\", StringUtils.getNestedString(\"\", \"\", \"\"));\n+        assertEquals(\"\", StringUtils.getNestedString(\"    \", \" \", \"  \"));\n+        assertEquals(\"bar\", StringUtils.getNestedString(\"<foo>bar</foo>\", \"<foo>\", \"</foo>\") );\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/StringUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils}.\n+ *\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:bayard@generationjava.com\">Henri Yandell</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author <a href=\"mailto:fredrik@westermarck.com>Fredrik Westermarck</a>\n+ * @author Holger Krauth\n+ * @author <a href=\"hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Phil Steitz\n+ * @author Gary D. Gregory\n+ * @author Al Chou\n+ * @version $Id$\n+ */\n+public class StringUtilsTest extends TestCase {\n+    \n+    static final String WHITESPACE;\n+    static final String NON_WHITESPACE;\n+    static final String TRIMMABLE;\n+    static final String NON_TRIMMABLE;\n+    static {\n+        String ws = \"\";\n+        String nws = \"\";\n+        String tr = \"\";\n+        String ntr = \"\";\n+        for (int i = 0; i < Character.MAX_VALUE; i++) {\n+            if (Character.isWhitespace((char) i)) {\n+                ws += String.valueOf((char) i);\n+                if (i > 32) {\n+                    ntr += String.valueOf((char) i);\n+                }\n+            } else if (i < 40) {\n+                nws += String.valueOf((char) i);\n+            }\n+        }\n+        for (int i = 0; i <= 32; i++) {\n+            tr += String.valueOf((char) i);\n+        }\n+        WHITESPACE = ws;\n+        NON_WHITESPACE = nws;\n+        TRIMMABLE = tr;\n+        NON_TRIMMABLE = ntr;\n+    }\n+\n+    private static final String[] ARRAY_LIST = { \"foo\", \"bar\", \"baz\" };\n+    private static final String[] EMPTY_ARRAY_LIST = {};\n+    private static final String[] NULL_ARRAY_LIST = {null};\n+    private static final String[] MIXED_ARRAY_LIST = {null, \"\", \"foo\"};\n+    private static final Object[] MIXED_TYPE_LIST = {new String(\"foo\"), new Long(2)};\n+\n+    private static final String SEPARATOR = \",\";\n+    private static final char   SEPARATOR_CHAR = ';';\n+\n+    private static final String TEXT_LIST = \"foo,bar,baz\";\n+    private static final String TEXT_LIST_CHAR = \"foo;bar;baz\";\n+    private static final String TEXT_LIST_NOSEP = \"foobarbaz\";\n+\n+    private static final String FOO_UNCAP = \"foo\";\n+    private static final String FOO_CAP = \"Foo\";\n+\n+    private static final String SENTENCE_UNCAP = \"foo bar baz\";\n+    private static final String SENTENCE_CAP = \"Foo Bar Baz\";\n+\n+    public StringUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsTest.class);\n+        suite.setName(\"StringUtilsTest Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new StringUtils());\n+        Constructor[] cons = StringUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(StringUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(StringUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testCaseFunctions() {\n+        assertEquals(null, StringUtils.upperCase(null));\n+        assertEquals(null, StringUtils.lowerCase(null));\n+        assertEquals(null, StringUtils.capitalize(null));\n+        assertEquals(null, StringUtils.uncapitalise(null));\n+        assertEquals(null, StringUtils.uncapitalize(null));\n+\n+        assertEquals(\"capitalise(String) failed\",\n+                    FOO_CAP, StringUtils.capitalise(FOO_UNCAP) );\n+        assertEquals(\"capitalise(empty-string) failed\",\n+                    \"\", StringUtils.capitalise(\"\") );\n+        assertEquals(\"capitalise(single-char-string) failed\",\n+                    \"X\", StringUtils.capitalise(\"x\") );\n+        assertEquals(\"capitalize(String) failed\",\n+                     FOO_CAP, StringUtils.capitalize(FOO_UNCAP) );\n+        assertEquals(\"capitalize(empty-string) failed\",\n+                     \"\", StringUtils.capitalize(\"\") );\n+        assertEquals(\"capitalize(single-char-string) failed\",\n+                     \"X\", StringUtils.capitalize(\"x\") );\n+        assertEquals(\"uncapitalise(String) failed\",\n+                     FOO_UNCAP, StringUtils.uncapitalise(FOO_CAP) );\n+        assertEquals(\"uncapitalise(empty-string) failed\",\n+                     \"\", StringUtils.uncapitalise(\"\") );\n+        assertEquals(\"uncapitalise(single-char-string) failed\",\n+                     \"x\", StringUtils.uncapitalise(\"X\") );\n+        assertEquals(\"uncapitalize(String) failed\",\n+                     FOO_UNCAP, StringUtils.uncapitalize(FOO_CAP) );\n+        assertEquals(\"uncapitalize(empty-string) failed\",\n+                     \"\", StringUtils.uncapitalize(\"\") );\n+        assertEquals(\"uncapitalize(single-char-string) failed\",\n+                     \"x\", StringUtils.uncapitalize(\"X\") );\n+                     \n+        // reflection type of tests: Sentences.\n+        assertEquals(\"uncapitalise(capitalise(String)) failed\",\n+                     SENTENCE_UNCAP, StringUtils.uncapitalise(StringUtils.capitalise(SENTENCE_UNCAP)) );\n+        assertEquals(\"capitalise(uncapitalise(String)) failed\",\n+                     SENTENCE_CAP, StringUtils.capitalise(StringUtils.uncapitalise(SENTENCE_CAP)) );\n+        assertEquals(\"uncapitalize(capitalize(String)) failed\",\n+                     SENTENCE_UNCAP, StringUtils.uncapitalize(StringUtils.capitalize(SENTENCE_UNCAP)) );\n+        assertEquals(\"capitalize(uncapitalize(String)) failed\",\n+                     SENTENCE_CAP, StringUtils.capitalize(StringUtils.uncapitalize(SENTENCE_CAP)) );\n+\n+        // reflection type of tests: One word.\n+        assertEquals(\"uncapitalise(capitalise(String)) failed\",\n+                     FOO_UNCAP, StringUtils.uncapitalise(StringUtils.capitalise(FOO_UNCAP)) );\n+        assertEquals(\"capitalise(uncapitalise(String)) failed\",\n+                     FOO_CAP, StringUtils.capitalise(StringUtils.uncapitalise(FOO_CAP)) );\n+        assertEquals(\"uncapitalize(capitalize(String)) failed\",\n+                     FOO_UNCAP, StringUtils.uncapitalize(StringUtils.capitalize(FOO_UNCAP)) );\n+        assertEquals(\"capitalize(uncapitalize(String)) failed\",\n+                     FOO_CAP, StringUtils.capitalize(StringUtils.uncapitalize(FOO_CAP)) );\n+\n+        assertEquals(\"upperCase(String) failed\",\n+                     \"FOO TEST THING\", StringUtils.upperCase(\"fOo test THING\") );\n+        assertEquals(\"upperCase(empty-string) failed\",\n+                     \"\", StringUtils.upperCase(\"\") );\n+        assertEquals(\"lowerCase(String) failed\",\n+                     \"foo test thing\", StringUtils.lowerCase(\"fOo test THING\") );\n+        assertEquals(\"lowerCase(empty-string) failed\",\n+                     \"\", StringUtils.lowerCase(\"\") );\n+        \n+    }\n+\n+    public void testSwapCase_String() {\n+        assertEquals(null, StringUtils.swapCase(null));\n+        assertEquals(\"\", StringUtils.swapCase(\"\"));\n+        assertEquals(\"  \", StringUtils.swapCase(\"  \"));\n+        \n+        assertEquals(\"i\", WordUtils.swapCase(\"I\") );\n+        assertEquals(\"I\", WordUtils.swapCase(\"i\") );\n+        assertEquals(\"I AM HERE 123\", StringUtils.swapCase(\"i am here 123\") );\n+        assertEquals(\"i aM hERE 123\", StringUtils.swapCase(\"I Am Here 123\") );\n+        assertEquals(\"I AM here 123\", StringUtils.swapCase(\"i am HERE 123\") );\n+        assertEquals(\"i am here 123\", StringUtils.swapCase(\"I AM HERE 123\") );\n+        \n+        String test = \"This String contains a TitleCase character: \\u01C8\";\n+        String expect = \"tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \\u01C9\";\n+        assertEquals(expect, WordUtils.swapCase(test));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testJoin_Objectarray() {\n+        assertEquals(null, StringUtils.join(null));\n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST));\n+        assertEquals(\"\", StringUtils.join(NULL_ARRAY_LIST));\n+        assertEquals(\"abc\", StringUtils.join(new String[] {\"a\", \"b\", \"c\"}));\n+        assertEquals(\"a\", StringUtils.join(new String[] {null, \"a\", \"\"}));\n+        assertEquals(\"foo\", StringUtils.join(MIXED_ARRAY_LIST));\n+        assertEquals(\"foo2\", StringUtils.join(MIXED_TYPE_LIST));\n+    }\n+        \n+    public void testJoin_ArrayChar() {\n+        assertEquals(null, StringUtils.join((Object[]) null, ','));\n+        assertEquals(TEXT_LIST_CHAR, StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR));\n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR));\n+        assertEquals(\";;foo\", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR_CHAR));\n+        assertEquals(\"foo;2\", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR_CHAR));\n+    }\n+    \n+    public void testJoin_ArrayString() {\n+        assertEquals(null, StringUtils.join((Object[]) null, null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(ARRAY_LIST, \"\"));\n+        \n+        assertEquals(\"\", StringUtils.join(NULL_ARRAY_LIST, null));\n+        \n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, null));\n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, \"\"));\n+        assertEquals(\"\", StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR));\n+\n+        assertEquals(TEXT_LIST, StringUtils.join(ARRAY_LIST, SEPARATOR));\n+        assertEquals(\",,foo\", StringUtils.join(MIXED_ARRAY_LIST, SEPARATOR));\n+        assertEquals(\"foo,2\", StringUtils.join(MIXED_TYPE_LIST, SEPARATOR));\n+    }\n+    \n+    public void testJoin_IteratorChar() {\n+        assertEquals(null, StringUtils.join((Iterator) null, ','));\n+        assertEquals(TEXT_LIST_CHAR, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR_CHAR));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), SEPARATOR_CHAR));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR_CHAR));\n+    }\n+    \n+    public void testJoin_IteratorString() {\n+        assertEquals(null, StringUtils.join((Iterator) null, null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), null));\n+        assertEquals(TEXT_LIST_NOSEP, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), \"\"));\n+        \n+        assertEquals(\"\", StringUtils.join(Arrays.asList(NULL_ARRAY_LIST).iterator(), null));\n+        \n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), null));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), \"\"));\n+        assertEquals(\"\", StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(), SEPARATOR));\n+        \n+        assertEquals(TEXT_LIST, StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(), SEPARATOR));\n+    }\n+    \n+    public void testConcatenate_Objectarray() {\n+        assertEquals(null, StringUtils.concatenate(null));\n+        assertEquals(\"\", StringUtils.concatenate(EMPTY_ARRAY_LIST));\n+        assertEquals(\"\", StringUtils.concatenate(NULL_ARRAY_LIST));\n+        assertEquals(\"foo\", StringUtils.concatenate(MIXED_ARRAY_LIST));\n+        assertEquals(\"foo2\", StringUtils.concatenate(MIXED_TYPE_LIST));\n+    }\n+        \n+    public void testSplit_String() {\n+        assertEquals(null, StringUtils.split(null));\n+        assertEquals(0, StringUtils.split(\"\").length);\n+        \n+        String str = \"a b  .c\";\n+        String[] res = StringUtils.split(str);\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\".c\", res[2]);\n+        \n+        str = \" a \";\n+        res = StringUtils.split(str);\n+        assertEquals(1, res.length);\n+        assertEquals(\"a\", res[0]);\n+        \n+        str = \"a\" + WHITESPACE + \"b\" + NON_WHITESPACE + \"c\";\n+        res = StringUtils.split(str);\n+        assertEquals(2, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\" + NON_WHITESPACE + \"c\", res[1]);                       \n+    }\n+    \n+    public void testSplit_StringChar() {\n+        assertEquals(null, StringUtils.split(null, '.'));\n+        assertEquals(0, StringUtils.split(\"\", '.').length);\n+\n+        String str = \"a.b.. c\";\n+        String[] res = StringUtils.split(str, '.');\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\" c\", res[2]);\n+            \n+        str = \".a.\";\n+        res = StringUtils.split(str, '.');\n+        assertEquals(1, res.length);\n+        assertEquals(\"a\", res[0]);\n+        \n+        str = \"a b c\";\n+        res = StringUtils.split(str,' ');\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"c\", res[2]);\n+    }\n+    \n+    public void testSplit_StringString_StringStringInt() {\n+        assertEquals(null, StringUtils.split(null, \".\"));\n+        assertEquals(null, StringUtils.split(null, \".\", 3));\n+        \n+        assertEquals(0, StringUtils.split(\"\", \".\").length);\n+        assertEquals(0, StringUtils.split(\"\", \".\", 3).length);\n+        \n+        innerTestSplit('.', \".\", ' ');\n+        innerTestSplit('.', \".\", ',');\n+        innerTestSplit('.', \".,\", 'x');\n+        for (int i = 0; i < WHITESPACE.length(); i++) {\n+            for (int j = 0; j < NON_WHITESPACE.length(); j++) {\n+                innerTestSplit(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j));\n+                innerTestSplit(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j));\n+            }\n+        }\n+        \n+        String[] results = null;\n+        String[] expectedResults = {\"ab\", \"de fg\"};\n+        results = StringUtils.split(\"ab   de fg\", null, 2);\n+        assertEquals(expectedResults.length, results.length);\n+        for (int i = 0; i < expectedResults.length; i++) {\n+            assertEquals(expectedResults[i], results[i]);\n+        }\n+        \n+        String[] expectedResults2 = {\"ab\", \"cd:ef\"};\n+        results = StringUtils.split(\"ab:cd:ef\",\":\", 2);\n+        assertEquals(expectedResults2.length, results.length);\n+        for (int i = 0; i < expectedResults2.length; i++) {\n+            assertEquals(expectedResults2[i], results[i]);\n+        }\n+    }\n+    \n+    private void innerTestSplit(char separator, String sepStr, char noMatch) {\n+        String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n+            \"), noMatch hex(\" + Integer.toHexString(noMatch) + \"), sepStr(\" + sepStr + \")\";\n+        \n+        final String str = \"a\" + separator + \"b\" + separator + separator + noMatch + \"c\";\n+        String[] res;\n+        // (str, sepStr)\n+        res = StringUtils.split(str, sepStr);\n+        assertEquals(msg, 3, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, noMatch + \"c\", res[2]);\n+        \n+        final String str2 = separator + \"a\" + separator;\n+        res = StringUtils.split(str2, sepStr);\n+        assertEquals(msg, 1, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+\n+        res = StringUtils.split(str, sepStr, -1);\n+        assertEquals(msg, 3, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, noMatch + \"c\", res[2]);\n+        \n+        res = StringUtils.split(str, sepStr, 0);\n+        assertEquals(msg, 3, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, noMatch + \"c\", res[2]);\n+        \n+        res = StringUtils.split(str, sepStr, 1);\n+        assertEquals(msg, 1, res.length);\n+        assertEquals(msg, str, res[0]);\n+        \n+        res = StringUtils.split(str, sepStr, 2);\n+        assertEquals(msg, 2, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, str.substring(2), res[1]);\n+    }\n+\n+    public void testSplitByWholeString_StringStringBoolean() {\n+        assertEquals( null, StringUtils.splitByWholeSeparator( null, \".\" ) ) ;\n+\n+        assertEquals( 0, StringUtils.splitByWholeSeparator( \"\", \".\" ).length ) ;\n+\n+        String stringToSplitOnNulls = \"ab   de fg\" ;\n+        String[] splitOnNullExpectedResults = { \"ab\", \"de\", \"fg\" } ;\n+\n+        String[] splitOnNullResults = StringUtils.splitByWholeSeparator( \"ab   de fg\", null ) ;\n+        assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ;\n+        for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) {\n+            assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ;\n+        }\n+\n+        String stringToSplitOnCharactersAndString = \"abstemiouslyaeiouyabstemiously\" ;\n+\n+        String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiously\" } ;\n+        String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, \"aeiouy\" ) ;\n+        assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ;\n+        for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) {\n+            assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ;\n+        }\n+\n+        String[] splitWithMultipleSeparatorExpectedResults = {\"ab\", \"cd\", \"ef\"};\n+        String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator(\"ab:cd::ef\", \":\");\n+        assertEquals( splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length );\n+        for( int i = 0; i < splitWithMultipleSeparatorExpectedResults.length ; i++ ) {\n+            assertEquals( splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i] ) ;\n+        }\n+    }\n+\n+    public void testSplitByWholeString_StringStringBooleanInt() {\n+        assertEquals( null, StringUtils.splitByWholeSeparator( null, \".\", 3 ) ) ;\n+\n+        assertEquals( 0, StringUtils.splitByWholeSeparator( \"\", \".\", 3 ).length ) ;\n+\n+        String stringToSplitOnNulls = \"ab   de fg\" ;\n+        String[] splitOnNullExpectedResults = { \"ab\", \"de fg\" } ;\n+        //String[] splitOnNullExpectedResults = { \"ab\", \"de\" } ;\n+\n+        String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null, 2 ) ;\n+        assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ;\n+        for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) {\n+            assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ;\n+        }\n+\n+        String stringToSplitOnCharactersAndString = \"abstemiouslyaeiouyabstemiouslyaeiouyabstemiously\" ;\n+\n+        String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiouslyaeiouyabstemiously\" } ;\n+        //String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiously\" } ;\n+        String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, \"aeiouy\", 2 ) ;\n+        assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ;\n+        for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i++ ) {\n+            assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ;\n+        }\n+    }\n+\n+    \n+    public void testSplitPreserveAllTokens_String() {\n+        assertEquals(null, StringUtils.splitPreserveAllTokens(null));\n+        assertEquals(0, StringUtils.splitPreserveAllTokens(\"\").length);\n+        \n+        String str = \"abc def\";\n+        String[] res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(2, res.length);\n+        assertEquals(\"abc\", res[0]);\n+        assertEquals(\"def\", res[1]);\n+        \n+        str = \"abc  def\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(3, res.length);\n+        assertEquals(\"abc\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"def\", res[2]);\n+        \n+        str = \" abc \";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(3, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"abc\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        \n+        str = \"a b .c\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\".c\", res[2]);\n+        \n+        str = \" a b .c\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\".c\", res[3]);\n+        \n+        str = \"a  b  .c\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(5, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        assertEquals(\".c\", res[4]);\n+        \n+        str = \" a  \";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        assertEquals(\"\", res[3]);\n+\n+        str = \" a  b\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        assertEquals(\"b\", res[3]);\n+\n+        str = \"a\" + WHITESPACE + \"b\" + NON_WHITESPACE + \"c\";\n+        res = StringUtils.splitPreserveAllTokens(str);\n+        assertEquals(WHITESPACE.length() + 1, res.length);\n+        assertEquals(\"a\", res[0]);\n+        for(int i = 1; i < WHITESPACE.length()-1; i++)\n+        {\n+          assertEquals(\"\", res[i]);\n+        }\n+        assertEquals(\"b\" + NON_WHITESPACE + \"c\", res[WHITESPACE.length()]);                       \n+    }\n+    \n+    public void testSplitPreserveAllTokens_StringChar() {\n+        assertEquals(null, StringUtils.splitPreserveAllTokens(null, '.'));\n+        assertEquals(0, StringUtils.splitPreserveAllTokens(\"\", '.').length);\n+\n+        String str = \"a.b. c\";\n+        String[] res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\" c\", res[2]);\n+            \n+        str = \"a.b.. c\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(4, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        assertEquals(\" c\", res[3]);\n+\n+        str = \".a.\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(3, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"\", res[2]);\n+       \n+        str = \".a..\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        \n+        str = \"..a.\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"a\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        \n+        str = \"..a\";\n+        res = StringUtils.splitPreserveAllTokens(str, '.');\n+        assertEquals(3, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"a\", res[2]);\n+        \n+        str = \"a b c\";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(3, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"c\", res[2]);\n+\n+        str = \"a  b  c\";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(5, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        assertEquals(\"c\", res[4]);\n+        \n+        str = \" a b c\";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(4, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"a\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\"c\", res[3]);\n+\n+        str = \"  a b c\";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(5, res.length);\n+        assertEquals(\"\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"a\", res[2]);\n+        assertEquals(\"b\", res[3]);\n+        assertEquals(\"c\", res[4]);\n+\n+        str = \"a b c \";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(4, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"c\", res[2]);\n+        assertEquals(\"\", res[3]);\n+\n+        str = \"a b c  \";\n+        res = StringUtils.splitPreserveAllTokens(str,' ');\n+        assertEquals(5, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"b\", res[1]);\n+        assertEquals(\"c\", res[2]);\n+        assertEquals(\"\", res[3]);\n+        assertEquals(\"\", res[3]);\n+\n+        // Match example in javadoc\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"a\", \"\", \"b\", \"c\"};\n+          results = StringUtils.splitPreserveAllTokens(\"a..b.c\",'.');\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+    }\n+    \n+    public void testSplitPreserveAllTokens_StringString_StringStringInt() {\n+        assertEquals(null, StringUtils.splitPreserveAllTokens(null, \".\"));\n+        assertEquals(null, StringUtils.splitPreserveAllTokens(null, \".\", 3));\n+        \n+        assertEquals(0, StringUtils.splitPreserveAllTokens(\"\", \".\").length);\n+        assertEquals(0, StringUtils.splitPreserveAllTokens(\"\", \".\", 3).length);\n+        \n+        innerTestSplitPreserveAllTokens('.', \".\", ' ');\n+        innerTestSplitPreserveAllTokens('.', \".\", ',');\n+        innerTestSplitPreserveAllTokens('.', \".,\", 'x');\n+        for (int i = 0; i < WHITESPACE.length(); i++) {\n+            for (int j = 0; j < NON_WHITESPACE.length(); j++) {\n+                innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), null, NON_WHITESPACE.charAt(j));\n+                innerTestSplitPreserveAllTokens(WHITESPACE.charAt(i), String.valueOf(WHITESPACE.charAt(i)), NON_WHITESPACE.charAt(j));\n+            }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"de fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"  de fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2);\n+          System.out.println(\"\");\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"::de:fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab:::de:fg\", \":\", 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"\", \" de fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"\", \"\", \"de fg\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] expectedResults = {\"ab\", \"cd:ef\"};\n+          String[] results = null;\n+          results = StringUtils.splitPreserveAllTokens(\"ab:cd:ef\",\":\", 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \":cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab::cd:ef\",\":\", 2);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"\", \":cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab:::cd:ef\",\":\", 3);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"ab\", \"\", \"\", \"cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\"ab:::cd:ef\",\":\", 4);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+\n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"\", \"ab\", \"\", \"\", \"cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\":ab:::cd:ef\",\":\", 5);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+        {\n+          String[] results = null;\n+          String[] expectedResults = {\"\", \"\", \"ab\", \"\", \"\", \"cd:ef\"};\n+          results = StringUtils.splitPreserveAllTokens(\"::ab:::cd:ef\",\":\", 6);\n+          assertEquals(expectedResults.length, results.length);\n+          for (int i = 0; i < expectedResults.length; i++) {\n+              assertEquals(expectedResults[i], results[i]);\n+          }\n+        }\n+        \n+    }\n+    \n+    private void innerTestSplitPreserveAllTokens(char separator, String sepStr, char noMatch) {\n+        String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n+            \"), noMatch hex(\" + Integer.toHexString(noMatch) + \"), sepStr(\" + sepStr + \")\";\n+        \n+        final String str = \"a\" + separator + \"b\" + separator + separator + noMatch + \"c\";\n+        String[] res;\n+        // (str, sepStr)\n+        res = StringUtils.splitPreserveAllTokens(str, sepStr);\n+        assertEquals(msg, 4, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, \"\", res[2]);\n+        assertEquals(msg, noMatch + \"c\", res[3]);\n+        \n+        final String str2 = separator + \"a\" + separator;\n+        res = StringUtils.splitPreserveAllTokens(str2, sepStr);\n+        assertEquals(msg, 3, res.length);\n+        assertEquals(msg, \"\", res[0]);\n+        assertEquals(msg, \"a\", res[1]);\n+        assertEquals(msg, \"\", res[2]);\n+\n+        res = StringUtils.splitPreserveAllTokens(str, sepStr, -1);\n+        assertEquals(msg, 4, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, \"\", res[2]);\n+        assertEquals(msg, noMatch + \"c\", res[3]);\n+        \n+        res = StringUtils.splitPreserveAllTokens(str, sepStr, 0);\n+        assertEquals(msg, 4, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, \"b\", res[1]);\n+        assertEquals(msg, \"\", res[2]);\n+        assertEquals(msg, noMatch + \"c\", res[3]);\n+        \n+        res = StringUtils.splitPreserveAllTokens(str, sepStr, 1);\n+        assertEquals(msg, 1, res.length);\n+        assertEquals(msg, str, res[0]);\n+        \n+        res = StringUtils.splitPreserveAllTokens(str, sepStr, 2);\n+        assertEquals(msg, 2, res.length);\n+        assertEquals(msg, \"a\", res[0]);\n+        assertEquals(msg, str.substring(2), res[1]);\n+    }\n+    \n+    public void testDeleteSpace_String() {\n+        assertEquals(null, StringUtils.deleteSpaces(null));\n+        assertEquals(\"\", StringUtils.deleteSpaces(\"\"));\n+        assertEquals(\"\", StringUtils.deleteSpaces(\"    \\t\\t\\n\\n   \"));\n+        assertEquals(\"test\", StringUtils.deleteSpaces(\"t  \\t\\ne\\rs\\n\\n   \\tt\"));\n+    }\n+    \n+    public void testDeleteWhitespace_String() {\n+        assertEquals(null, StringUtils.deleteWhitespace(null));\n+        assertEquals(\"\", StringUtils.deleteWhitespace(\"\"));\n+        assertEquals(\"\", StringUtils.deleteWhitespace(\"  \\u000C  \\t\\t\\u001F\\n\\n \\u000B  \"));\n+        assertEquals(\"\", StringUtils.deleteWhitespace(StringUtilsTest.WHITESPACE));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, StringUtils.deleteWhitespace(StringUtilsTest.NON_WHITESPACE));\n+        // Note: u-2007 and u-000A both cause problems in the source code\n+        // it should ignore 2007 but delete 000A\n+        assertEquals(\"\\u00A0\\u202F\", StringUtils.deleteWhitespace(\"  \\u00A0  \\t\\t\\n\\n \\u202F  \"));\n+        assertEquals(\"\\u00A0\\u202F\", StringUtils.deleteWhitespace(\"\\u00A0\\u202F\"));\n+        assertEquals(\"test\", StringUtils.deleteWhitespace(\"\\u000Bt  \\t\\n\\u0009e\\rs\\n\\n   \\tt\"));\n+    }\n+\n+    public void testReplace_StringStringString() {\n+        assertEquals(null, StringUtils.replace(null, null, null));\n+        assertEquals(null, StringUtils.replace(null, null, \"any\"));\n+        assertEquals(null, StringUtils.replace(null, \"any\", null));\n+        assertEquals(null, StringUtils.replace(null, \"any\", \"any\"));\n+\n+        assertEquals(\"\", StringUtils.replace(\"\", null, null));\n+        assertEquals(\"\", StringUtils.replace(\"\", null, \"any\"));\n+        assertEquals(\"\", StringUtils.replace(\"\", \"any\", null));\n+        assertEquals(\"\", StringUtils.replace(\"\", \"any\", \"any\"));\n+\n+        assertEquals(\"FOO\", StringUtils.replace(\"FOO\", \"\", \"any\"));\n+        assertEquals(\"FOO\", StringUtils.replace(\"FOO\", null, \"any\"));\n+        assertEquals(\"FOO\", StringUtils.replace(\"FOO\", \"F\", null));\n+        assertEquals(\"FOO\", StringUtils.replace(\"FOO\", null, null));\n+\n+        assertEquals(\"\", StringUtils.replace(\"foofoofoo\", \"foo\", \"\"));\n+        assertEquals(\"barbarbar\", StringUtils.replace(\"foofoofoo\", \"foo\", \"bar\"));\n+        assertEquals(\"farfarfar\", StringUtils.replace(\"foofoofoo\", \"oo\", \"ar\"));\n+       }\n+    \n+    public void testReplace_StringStringStringInt() {\n+        assertEquals(null, StringUtils.replace(null, null, null, 2));\n+        assertEquals(null, StringUtils.replace(null, null, \"any\", 2));\n+        assertEquals(null, StringUtils.replace(null, \"any\", null, 2));\n+        assertEquals(null, StringUtils.replace(null, \"any\", \"any\", 2));\n+\n+        assertEquals(\"\", StringUtils.replace(\"\", null, null, 2));\n+        assertEquals(\"\", StringUtils.replace(\"\", null, \"any\", 2));\n+        assertEquals(\"\", StringUtils.replace(\"\", \"any\", null, 2));\n+        assertEquals(\"\", StringUtils.replace(\"\", \"any\", \"any\", 2));\n+        \n+        String str = new String(new char[] {'o', 'o', 'f', 'o', 'o'});\n+        assertSame(str, StringUtils.replace(str, \"x\", \"\", -1));\n+        \n+        assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", -1));\n+        assertEquals(\"oofoo\", StringUtils.replace(\"oofoo\", \"o\", \"\", 0));\n+        assertEquals(\"ofoo\", StringUtils.replace(\"oofoo\", \"o\", \"\", 1));\n+        assertEquals(\"foo\", StringUtils.replace(\"oofoo\", \"o\", \"\", 2));\n+        assertEquals(\"fo\", StringUtils.replace(\"oofoo\", \"o\", \"\", 3));\n+        assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", 4));\n+        \n+        assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", -5));\n+        assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", 1000));\n+    }\n+    \n+    public void testReplaceOnce_StringStringString() {\n+        assertEquals(null, StringUtils.replaceOnce(null, null, null));\n+        assertEquals(null, StringUtils.replaceOnce(null, null, \"any\"));\n+        assertEquals(null, StringUtils.replaceOnce(null, \"any\", null));\n+        assertEquals(null, StringUtils.replaceOnce(null, \"any\", \"any\"));\n+\n+        assertEquals(\"\", StringUtils.replaceOnce(\"\", null, null));\n+        assertEquals(\"\", StringUtils.replaceOnce(\"\", null, \"any\"));\n+        assertEquals(\"\", StringUtils.replaceOnce(\"\", \"any\", null));\n+        assertEquals(\"\", StringUtils.replaceOnce(\"\", \"any\", \"any\"));\n+\n+        assertEquals(\"FOO\", StringUtils.replaceOnce(\"FOO\", \"\", \"any\"));\n+        assertEquals(\"FOO\", StringUtils.replaceOnce(\"FOO\", null, \"any\"));\n+        assertEquals(\"FOO\", StringUtils.replaceOnce(\"FOO\", \"F\", null));\n+        assertEquals(\"FOO\", StringUtils.replaceOnce(\"FOO\", null, null));\n+\n+        assertEquals(\"foofoo\", StringUtils.replaceOnce(\"foofoofoo\", \"foo\", \"\"));\n+    }\n+\n+    public void testReplaceChars_StringCharChar() {\n+        assertEquals(null, StringUtils.replaceChars(null, 'b', 'z'));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", 'b', 'z'));\n+        assertEquals(\"azcza\", StringUtils.replaceChars(\"abcba\", 'b', 'z'));\n+        assertEquals(\"abcba\", StringUtils.replaceChars(\"abcba\", 'x', 'z'));\n+    }\n+    \n+    public void testReplaceChars_StringStringString() {\n+        assertEquals(null, StringUtils.replaceChars(null, null, null));\n+        assertEquals(null, StringUtils.replaceChars(null, \"\", null));\n+        assertEquals(null, StringUtils.replaceChars(null, \"a\", null));\n+        assertEquals(null, StringUtils.replaceChars(null, null, \"\"));\n+        assertEquals(null, StringUtils.replaceChars(null, null, \"x\"));\n+        \n+        assertEquals(\"\", StringUtils.replaceChars(\"\", null, null));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", \"\", null));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", \"a\", null));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", null, \"\"));\n+        assertEquals(\"\", StringUtils.replaceChars(\"\", null, \"x\"));\n+\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", null, null));\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", null, \"\"));\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", null, \"x\"));\n+        \n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", \"\", null));\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", \"\", \"\"));\n+        assertEquals(\"abc\", StringUtils.replaceChars(\"abc\", \"\", \"x\"));\n+        \n+        assertEquals(\"ac\", StringUtils.replaceChars(\"abc\", \"b\", null));\n+        assertEquals(\"ac\", StringUtils.replaceChars(\"abc\", \"b\", \"\"));\n+        assertEquals(\"axc\", StringUtils.replaceChars(\"abc\", \"b\", \"x\"));\n+        \n+        assertEquals(\"ayzya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\"));\n+        assertEquals(\"ayya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"y\"));\n+        assertEquals(\"ayzya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\"));\n+        \n+        assertEquals(\"abcba\", StringUtils.replaceChars(\"abcba\", \"z\", \"w\"));\n+        assertSame(\"abcba\", StringUtils.replaceChars(\"abcba\", \"z\", \"w\"));\n+        \n+        // Javadoc examples:\n+        assertEquals(\"jelly\", StringUtils.replaceChars(\"hello\", \"ho\", \"jy\"));\n+        assertEquals(\"ayzya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\"));\n+        assertEquals(\"ayya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"y\"));\n+        assertEquals(\"ayzya\", StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\"));\n+        \n+        // From http://issues.apache.org/bugzilla/show_bug.cgi?id=25454\n+        assertEquals(\"bcc\", StringUtils.replaceChars(\"abc\", \"ab\", \"bc\"));\n+        assertEquals(\"q651.506bera\", StringUtils.replaceChars(\"d216.102oren\",\n+            \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\",\n+            \"nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM567891234\"));\n+    }\n+    \n+    public void testOverlayString_StringStringIntInt() {\n+        assertEquals(\"overlayString(String, String, int, int) failed\",\n+                     \"foo foor baz\", StringUtils.overlayString(SENTENCE_UNCAP, FOO_UNCAP, 4, 6) );\n+        assertEquals(\"abef\", StringUtils.overlayString(\"abcdef\", \"\", 2, 4));\n+        assertEquals(\"abzzzzef\", StringUtils.overlayString(\"abcdef\", \"zzzz\", 2, 4));\n+        assertEquals(\"abcdzzzzcdef\", StringUtils.overlayString(\"abcdef\", \"zzzz\", 4, 2));\n+        try {\n+            StringUtils.overlayString(null, \"zzzz\", 2, 4);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            StringUtils.overlayString(\"abcdef\", null, 2, 4);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            StringUtils.overlayString(\"abcdef\", \"zzzz\", -1, 4);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            StringUtils.overlayString(\"abcdef\", \"zzzz\", 2, 8);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testOverlay_StringStringIntInt() {\n+        assertEquals(null, StringUtils.overlay(null, null, 2, 4));\n+        assertEquals(null, StringUtils.overlay(null, null, -2, -4));\n+        \n+        assertEquals(\"\", StringUtils.overlay(\"\", null, 0, 0));\n+        assertEquals(\"\", StringUtils.overlay(\"\", \"\", 0, 0));\n+        assertEquals(\"zzzz\", StringUtils.overlay(\"\", \"zzzz\", 0, 0));\n+        assertEquals(\"zzzz\", StringUtils.overlay(\"\", \"zzzz\", 2, 4));\n+        assertEquals(\"zzzz\", StringUtils.overlay(\"\", \"zzzz\", -2, -4));\n+        \n+        assertEquals(\"abef\", StringUtils.overlay(\"abcdef\", null, 2, 4));\n+        assertEquals(\"abef\", StringUtils.overlay(\"abcdef\", null, 4, 2));\n+        assertEquals(\"abef\", StringUtils.overlay(\"abcdef\", \"\", 2, 4));\n+        assertEquals(\"abef\", StringUtils.overlay(\"abcdef\", \"\", 4, 2));\n+        assertEquals(\"abzzzzef\", StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4));\n+        assertEquals(\"abzzzzef\", StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2));\n+        \n+        assertEquals(\"zzzzef\", StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4));\n+        assertEquals(\"zzzzef\", StringUtils.overlay(\"abcdef\", \"zzzz\", 4, -1));\n+        assertEquals(\"zzzzabcdef\", StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -1));\n+        assertEquals(\"zzzzabcdef\", StringUtils.overlay(\"abcdef\", \"zzzz\", -1, -2));\n+        assertEquals(\"abcdzzzz\", StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 10));\n+        assertEquals(\"abcdzzzz\", StringUtils.overlay(\"abcdef\", \"zzzz\", 10, 4));\n+        assertEquals(\"abcdefzzzz\", StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10));\n+        assertEquals(\"abcdefzzzz\", StringUtils.overlay(\"abcdef\", \"zzzz\", 10, 8));\n+    }\n+\n+    public void testRepeat_StringInt() {\n+        assertEquals(null, StringUtils.repeat(null, 2));\n+        assertEquals(\"\", StringUtils.repeat(\"ab\", 0));\n+        assertEquals(\"\", StringUtils.repeat(\"\", 3));\n+        assertEquals(\"aaa\", StringUtils.repeat(\"a\", 3));\n+        assertEquals(\"ababab\", StringUtils.repeat(\"ab\", 3));\n+        assertEquals(\"abcabcabc\", StringUtils.repeat(\"abc\", 3));\n+        String str = StringUtils.repeat(\"a\", 10000);  // bigger than pad limit\n+        assertEquals(10000, str.length());\n+        assertEquals(true, StringUtils.containsOnly(str, new char[] {'a'}));\n+    }\n+\n+    public void testDeprecatedChompFunctions() {\n+        assertEquals(\"chompLast(String) failed\",\n+                     FOO_UNCAP, StringUtils.chompLast(FOO_UNCAP + \"\\n\") );\n+\n+        assertEquals(\"chompLast(\\\"\\\") failed\",\n+            \"\", StringUtils.chompLast(\"\") );\n+        assertEquals(\"chompLast(\\\"test\\\", \\\"test\\\") failed\",\n+            \"test\", StringUtils.chompLast(\"test\", \"tst\") );\n+        \n+        assertEquals(\"getChomp(String, String) failed\",\n+                     \"\\n\" + FOO_UNCAP, StringUtils.getChomp(FOO_UNCAP + \"\\n\" + FOO_UNCAP, \"\\n\") );\n+        assertEquals(\"getChomp(String, String) failed\",\n+                     FOO_CAP, StringUtils.getChomp(FOO_CAP+FOO_CAP, FOO_CAP));\n+        assertEquals(\"getChomp(String, String) failed\",\n+                     \"\", StringUtils.getChomp(FOO_UNCAP, FOO_CAP));\n+\n+        assertEquals(\"prechomp(String, String) failed\",\n+                     FOO_UNCAP, StringUtils.prechomp(FOO_UNCAP + \"\\n\" + FOO_UNCAP, \"\\n\") );\n+        assertEquals(\"prechomp(String, String) failed\",\n+                     FOO_UNCAP, StringUtils.prechomp(FOO_UNCAP, FOO_CAP));\n+        \n+        assertEquals(\"getPrechomp(String, String) failed\",\n+                     FOO_UNCAP + \"\\n\", StringUtils.getPrechomp(FOO_UNCAP + \"\\n\" + FOO_UNCAP, \"\\n\") );\n+        assertEquals(\"getPrechomp(String, String) failed\",\n+                     \"\", StringUtils.getPrechomp(FOO_CAP, FOO_UNCAP));\n+        \n+        assertEquals(\"chopNewline(String, String) failed\",\n+                     FOO_UNCAP, StringUtils.chopNewline(FOO_UNCAP + \"\\r\\n\") );\n+    }\n+\n+    public void testChop() {\n+\n+        String[][] chopCases = {\n+            { FOO_UNCAP + \"\\r\\n\", FOO_UNCAP } ,\n+            { FOO_UNCAP + \"\\n\" , FOO_UNCAP } ,\n+            { FOO_UNCAP + \"\\r\", FOO_UNCAP },\n+            { FOO_UNCAP + \" \\r\", FOO_UNCAP + \" \" },\n+            { \"foo\", \"fo\"},\n+            { \"foo\\nfoo\", \"foo\\nfo\" },\n+            { \"\\n\", \"\" },\n+            { \"\\r\", \"\" },\n+            { \"\\r\\n\", \"\" },\n+            { null, null },\n+            { \"\", \"\" },\n+            { \"a\", \"\" },\n+        };\n+        for (int i = 0; i < chopCases.length; i++) {\n+            String original = chopCases[i][0];\n+            String expectedResult = chopCases[i][1];\n+            assertEquals(\"chop(String) failed\",\n+                    expectedResult, StringUtils.chop(original));\n+        }\n+    }\n+\n+    public void testChomp() {\n+\n+        String[][] chompCases = {\n+            { FOO_UNCAP + \"\\r\\n\", FOO_UNCAP },\n+            { FOO_UNCAP + \"\\n\" , FOO_UNCAP },\n+            { FOO_UNCAP + \"\\r\", FOO_UNCAP },\n+            { FOO_UNCAP + \" \\r\", FOO_UNCAP + \" \" },\n+            { FOO_UNCAP, FOO_UNCAP },\n+            { FOO_UNCAP + \"\\n\\n\", FOO_UNCAP + \"\\n\"},\n+            { FOO_UNCAP + \"\\r\\n\\r\\n\", FOO_UNCAP + \"\\r\\n\" },\n+            { \"foo\\nfoo\", \"foo\\nfoo\" },\n+            { \"foo\\n\\rfoo\", \"foo\\n\\rfoo\" },\n+            { \"\\n\", \"\" },\n+            { \"\\r\", \"\" },\n+            { \"a\", \"a\" },\n+            { \"\\r\\n\", \"\" },\n+            { \"\", \"\" },\n+            { null, null },\n+            { FOO_UNCAP + \"\\n\\r\", FOO_UNCAP + \"\\n\"}\n+        };\n+        for (int i = 0; i < chompCases.length; i++) {\n+            String original = chompCases[i][0];\n+            String expectedResult = chompCases[i][1];\n+            assertEquals(\"chomp(String) failed\",\n+                    expectedResult, StringUtils.chomp(original));\n+        }\n+\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foo\", StringUtils.chomp(\"foobar\", \"bar\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foobar\", StringUtils.chomp(\"foobar\", \"baz\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foo\", StringUtils.chomp(\"foo\", \"foooo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foobar\", StringUtils.chomp(\"foobar\", \"\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foobar\", StringUtils.chomp(\"foobar\", null));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"\", StringUtils.chomp(\"\", \"foo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"\", StringUtils.chomp(\"\", null));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"\", StringUtils.chomp(\"\", \"\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                null, StringUtils.chomp(null, \"foo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                null, StringUtils.chomp(null, null));\n+        assertEquals(\"chomp(String, String) failed\",\n+                null, StringUtils.chomp(null, \"\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"\", StringUtils.chomp(\"foo\", \"foo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \" \", StringUtils.chomp(\" foo\", \"foo\"));\n+        assertEquals(\"chomp(String, String) failed\",\n+                \"foo \", StringUtils.chomp(\"foo \", \"foo\"));\n+    }\n+\n+    public void testChopNewLine() {\n+\n+        String[][] newLineCases = {\n+            { FOO_UNCAP + \"\\r\\n\", FOO_UNCAP } ,\n+            { FOO_UNCAP + \"\\n\" , FOO_UNCAP } ,\n+            { FOO_UNCAP + \"\\r\", FOO_UNCAP + \"\\r\" },\n+            { FOO_UNCAP, FOO_UNCAP },\n+            { FOO_UNCAP + \"\\n\" + FOO_UNCAP , FOO_UNCAP + \"\\n\" + FOO_UNCAP },\n+            { FOO_UNCAP + \"\\n\\n\", FOO_UNCAP + \"\\n\"},\n+            { \"\\n\", \"\" },\n+            { \"\", \"\" },\n+            { \"\\r\\n\", \"\" }\n+      };\n+\n+      for (int i = 0; i < newLineCases.length; i++) {\n+          String original = newLineCases[i][0];\n+          String expectedResult = newLineCases[i][1];\n+          assertEquals(\"chopNewline(String) failed\",\n+                  expectedResult, StringUtils.chopNewline(original));\n+      }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testRightPad_StringInt() {\n+        assertEquals(null, StringUtils.rightPad(null, 5));\n+        assertEquals(\"     \", StringUtils.rightPad(\"\", 5));\n+        assertEquals(\"abc  \", StringUtils.rightPad(\"abc\", 5));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", 2));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", -1));\n+    }\n+\n+    public void testRightPad_StringIntChar() {\n+        assertEquals(null, StringUtils.rightPad(null, 5, ' '));\n+        assertEquals(\"     \", StringUtils.rightPad(\"\", 5, ' '));\n+        assertEquals(\"abc  \", StringUtils.rightPad(\"abc\", 5, ' '));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", 2, ' '));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", -1, ' '));\n+        assertEquals(\"abcxx\", StringUtils.rightPad(\"abc\", 5, 'x'));\n+        String str = StringUtils.rightPad(\"aaa\", 10000, 'a');  // bigger than pad length\n+        assertEquals(10000, str.length());\n+        assertEquals(true, StringUtils.containsOnly(str, new char[] {'a'}));\n+    }\n+\n+    public void testRightPad_StringIntString() {\n+        assertEquals(null, StringUtils.rightPad(null, 5, \"-+\"));\n+        assertEquals(\"     \", StringUtils.rightPad(\"\", 5, \" \"));\n+        assertEquals(null, StringUtils.rightPad(null, 8, null));\n+        assertEquals(\"abc-+-+\", StringUtils.rightPad(\"abc\", 7, \"-+\"));\n+        assertEquals(\"abc-+~\", StringUtils.rightPad(\"abc\", 6, \"-+~\"));\n+        assertEquals(\"abc-+\", StringUtils.rightPad(\"abc\", 5, \"-+~\"));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", 2, \" \"));\n+        assertEquals(\"abc\", StringUtils.rightPad(\"abc\", -1, \" \"));\n+        assertEquals(\"abc  \", StringUtils.rightPad(\"abc\", 5, null));\n+        assertEquals(\"abc  \", StringUtils.rightPad(\"abc\", 5, \"\"));\n+    }\n+        \n+    //-----------------------------------------------------------------------\n+    public void testLeftPad_StringInt() {\n+        assertEquals(null, StringUtils.leftPad(null, 5));\n+        assertEquals(\"     \", StringUtils.leftPad(\"\", 5));\n+        assertEquals(\"  abc\", StringUtils.leftPad(\"abc\", 5));\n+        assertEquals(\"abc\", StringUtils.leftPad(\"abc\", 2));\n+    }\n+        \n+    public void testLeftPad_StringIntChar() {\n+        assertEquals(null, StringUtils.leftPad(null, 5, ' '));\n+        assertEquals(\"     \", StringUtils.leftPad(\"\", 5, ' '));\n+        assertEquals(\"  abc\", StringUtils.leftPad(\"abc\", 5, ' '));\n+        assertEquals(\"xxabc\", StringUtils.leftPad(\"abc\", 5, 'x'));\n+        assertEquals(\"\\uffff\\uffffabc\", StringUtils.leftPad(\"abc\", 5, '\\uffff'));\n+        assertEquals(\"abc\", StringUtils.leftPad(\"abc\", 2, ' '));\n+        String str = StringUtils.leftPad(\"aaa\", 10000, 'a');  // bigger than pad length\n+        assertEquals(10000, str.length());\n+        assertEquals(true, StringUtils.containsOnly(str, new char[] {'a'}));\n+    }\n+        \n+    public void testLeftPad_StringIntString() {\n+        assertEquals(null, StringUtils.leftPad(null, 5, \"-+\"));\n+        assertEquals(null, StringUtils.leftPad(null, 5, null));\n+        assertEquals(\"     \", StringUtils.leftPad(\"\", 5, \" \"));\n+        assertEquals(\"-+-+abc\", StringUtils.leftPad(\"abc\", 7, \"-+\"));\n+        assertEquals(\"-+~abc\", StringUtils.leftPad(\"abc\", 6, \"-+~\"));\n+        assertEquals(\"-+abc\", StringUtils.leftPad(\"abc\", 5, \"-+~\"));\n+        assertEquals(\"abc\", StringUtils.leftPad(\"abc\", 2, \" \"));\n+        assertEquals(\"abc\", StringUtils.leftPad(\"abc\", -1, \" \"));\n+        assertEquals(\"  abc\", StringUtils.leftPad(\"abc\", 5, null));\n+        assertEquals(\"  abc\", StringUtils.leftPad(\"abc\", 5, \"\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCenter_StringInt() {\n+        assertEquals(null, StringUtils.center(null, -1));\n+        assertEquals(null, StringUtils.center(null, 4));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 0));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", -1));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 1));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4));\n+        assertEquals(\" ab \", StringUtils.center(\"ab\", 4));\n+        assertEquals(\"abcd\", StringUtils.center(\"abcd\", 2));\n+        assertEquals(\" a  \", StringUtils.center(\"a\", 4));\n+        assertEquals(\"  a  \", StringUtils.center(\"a\", 5));\n+    }\n+    \n+    public void testCenter_StringIntChar() {\n+        assertEquals(null, StringUtils.center(null, -1, ' '));\n+        assertEquals(null, StringUtils.center(null, 4, ' '));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, ' '));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 0, ' '));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", -1, ' '));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 1, ' '));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, ' '));\n+        assertEquals(\" ab \", StringUtils.center(\"ab\", 4, ' '));\n+        assertEquals(\"abcd\", StringUtils.center(\"abcd\", 2, ' '));\n+        assertEquals(\" a  \", StringUtils.center(\"a\", 4, ' '));\n+        assertEquals(\"  a  \", StringUtils.center(\"a\", 5, ' '));\n+        assertEquals(\"xxaxx\", StringUtils.center(\"a\", 5, 'x'));\n+    }\n+    \n+    public void testCenter_StringIntString() {\n+        assertEquals(null, StringUtils.center(null, 4, null));\n+        assertEquals(null, StringUtils.center(null, -1, \" \"));\n+        assertEquals(null, StringUtils.center(null, 4, \" \"));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, \" \"));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 0, \" \"));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", -1, \" \"));\n+        assertEquals(\"ab\", StringUtils.center(\"ab\", 1, \" \"));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, \" \"));\n+        assertEquals(\" ab \", StringUtils.center(\"ab\", 4, \" \"));\n+        assertEquals(\"abcd\", StringUtils.center(\"abcd\", 2, \" \"));\n+        assertEquals(\" a  \", StringUtils.center(\"a\", 4, \" \"));\n+        assertEquals(\"yayz\", StringUtils.center(\"a\", 4, \"yz\"));\n+        assertEquals(\"yzyayzy\", StringUtils.center(\"a\", 7, \"yz\"));\n+        assertEquals(\"  abc  \", StringUtils.center(\"abc\", 7, null));\n+        assertEquals(\"  abc  \", StringUtils.center(\"abc\", 7, \"\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReverse_String() {\n+        assertEquals(null, StringUtils.reverse(null) );\n+        assertEquals(\"\", StringUtils.reverse(\"\") );\n+        assertEquals(\"sdrawkcab\", StringUtils.reverse(\"backwards\") );\n+    }\n+        \n+    public void testReverseDelimited_StringChar() {\n+        assertEquals(null, StringUtils.reverseDelimited(null, '.') );\n+        assertEquals(\"\", StringUtils.reverseDelimited(\"\", '.') );\n+        assertEquals(\"c.b.a\", StringUtils.reverseDelimited(\"a.b.c\", '.') );\n+        assertEquals(\"a b c\", StringUtils.reverseDelimited(\"a b c\", '.') );\n+        assertEquals(\"\", StringUtils.reverseDelimited(\"\", '.') );\n+    }\n+\n+    public void testReverseDelimitedString_StringString() {\n+        assertEquals(null, StringUtils.reverseDelimitedString(null, null) );\n+        assertEquals(\"\", StringUtils.reverseDelimitedString(\"\", null) );\n+        assertEquals(\"\", StringUtils.reverseDelimitedString(\"\", \".\") );\n+        assertEquals(\"a.b.c\", StringUtils.reverseDelimitedString(\"a.b.c\", null) );\n+        assertEquals(\"c b a\", StringUtils.reverseDelimitedString(\"a b c\", null) );\n+        assertEquals(\"c.b.a\", StringUtils.reverseDelimitedString(\"a.b.c\", \".\") );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDefault_String() {\n+        assertEquals(\"\", StringUtils.defaultString(null));\n+        assertEquals(\"\", StringUtils.defaultString(\"\"));\n+        assertEquals(\"abc\", StringUtils.defaultString(\"abc\"));\n+    }\n+\n+    public void testDefault_StringString() {\n+        assertEquals(\"NULL\", StringUtils.defaultString(null, \"NULL\"));\n+        assertEquals(\"\", StringUtils.defaultString(\"\", \"NULL\"));\n+        assertEquals(\"abc\", StringUtils.defaultString(\"abc\", \"NULL\"));\n+    }\n+\n+    public void testDefaultIfEmpty_StringString() {\n+        assertEquals(\"NULL\", StringUtils.defaultIfEmpty(null, \"NULL\"));\n+        assertEquals(\"NULL\", StringUtils.defaultIfEmpty(\"\", \"NULL\"));\n+        assertEquals(\"abc\", StringUtils.defaultIfEmpty(\"abc\", \"NULL\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEscapeFunctions_String() {\n+        assertEquals(\"\", StringUtils.escape(\"\") );\n+        assertEquals(\"abc\", StringUtils.escape(\"abc\") );\n+        assertEquals(\"\\\\t\", StringUtils.escape(\"\\t\") );\n+        assertEquals(\"\\\\\\\\\", StringUtils.escape(\"\\\\\") );\n+        assertEquals(\"\\\\\\\\\\\\b\\\\t\\\\r\", StringUtils.escape(\"\\\\\\b\\t\\r\") );\n+        assertEquals(\"\\\\u1234\", StringUtils.escape(\"\\u1234\") );\n+        assertEquals(\"\\\\u0234\", StringUtils.escape(\"\\u0234\") );\n+        assertEquals(\"\\\\u00FD\", StringUtils.escape(\"\\u00fd\") );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAbbreviate_StringInt() {\n+        assertEquals(null, StringUtils.abbreviate(null, 10));\n+        assertEquals(\"\", StringUtils.abbreviate(\"\", 10));\n+        assertEquals(\"short\", StringUtils.abbreviate(\"short\", 10));\n+        assertEquals(\"Now is ...\", StringUtils.abbreviate(\"Now is the time for all good men to come to the aid of their party.\", 10));\n+\n+        String raspberry = \"raspberry peach\";\n+        assertEquals(\"raspberry p...\", StringUtils.abbreviate(raspberry, 14));\n+        assertEquals(\"raspberry peach\", StringUtils.abbreviate(\"raspberry peach\", 15));\n+        assertEquals(\"raspberry peach\", StringUtils.abbreviate(\"raspberry peach\", 16));\n+        assertEquals(\"abc...\", StringUtils.abbreviate(\"abcdefg\", 6));\n+        assertEquals(\"abcdefg\", StringUtils.abbreviate(\"abcdefg\", 7));\n+        assertEquals(\"abcdefg\", StringUtils.abbreviate(\"abcdefg\", 8));\n+        assertEquals(\"a...\", StringUtils.abbreviate(\"abcdefg\", 4));\n+        assertEquals(\"\", StringUtils.abbreviate(\"\", 4));\n+        \n+        try {\n+            String res = StringUtils.abbreviate(\"abc\", 3);\n+            fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // empty\n+        }              \n+    }\n+    \n+    public void testAbbreviate_StringIntInt() {\n+        assertEquals(null, StringUtils.abbreviate(null, 10, 12));\n+        assertEquals(\"\", StringUtils.abbreviate(\"\", 0, 10));\n+        assertEquals(\"\", StringUtils.abbreviate(\"\", 2, 10));\n+        \n+        try {\n+            String res = StringUtils.abbreviate(\"abcdefghij\", 0, 3);\n+            fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // empty\n+        }      \n+        try {\n+            String res = StringUtils.abbreviate(\"abcdefghij\", 5, 6);\n+            fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // empty\n+        }      \n+        \n+\n+        String raspberry = \"raspberry peach\";\n+        assertEquals(\"raspberry peach\", StringUtils.abbreviate(raspberry, 11, 15));\n+\n+        assertEquals(null, StringUtils.abbreviate(null, 7, 14));\n+        assertAbbreviateWithOffset(\"abcdefg...\", -1, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 0, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 1, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 2, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 3, 10);\n+        assertAbbreviateWithOffset(\"abcdefg...\", 4, 10);\n+        assertAbbreviateWithOffset(\"...fghi...\", 5, 10);\n+        assertAbbreviateWithOffset(\"...ghij...\", 6, 10);\n+        assertAbbreviateWithOffset(\"...hijk...\", 7, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 8, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 9, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 10, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 10, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 11, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 12, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 13, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 14, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 15, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", 16, 10);\n+        assertAbbreviateWithOffset(\"...ijklmno\", Integer.MAX_VALUE, 10);\n+    }\n+\n+    private void assertAbbreviateWithOffset(String expected, int offset, int maxWidth) {\n+        String abcdefghijklmno = \"abcdefghijklmno\";\n+        String message = \"abbreviate(String,int,int) failed\";\n+        String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth);\n+        if (offset >= 0 && offset < abcdefghijklmno.length()) {\n+            assertTrue(message + \" -- should contain offset character\",\n+                    actual.indexOf((char)('a'+offset)) != -1);\n+        }\n+        assertTrue(message + \" -- should not be greater than maxWidth\",\n+                actual.length() <= maxWidth);\n+        assertEquals(message, expected, actual);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDifference_StringString() {\n+        assertEquals(null, StringUtils.difference(null, null));\n+        assertEquals(\"\", StringUtils.difference(\"\", \"\"));\n+        assertEquals(\"abc\", StringUtils.difference(\"\", \"abc\"));\n+        assertEquals(\"\", StringUtils.difference(\"abc\", \"\"));\n+        assertEquals(\"i am a robot\", StringUtils.difference(null, \"i am a robot\"));\n+        assertEquals(\"i am a machine\", StringUtils.difference(\"i am a machine\", null));\n+        assertEquals(\"robot\", StringUtils.difference(\"i am a machine\", \"i am a robot\"));\n+        assertEquals(\"\", StringUtils.difference(\"abc\", \"abc\"));\n+        assertEquals(\"you are a robot\", StringUtils.difference(\"i am a robot\", \"you are a robot\"));\n+    }\n+\n+    public void testDifferenceAt_StringString() {\n+        assertEquals(-1, StringUtils.indexOfDifference(null, null));\n+        assertEquals(0, StringUtils.indexOfDifference(null, \"i am a robot\"));\n+        assertEquals(-1, StringUtils.indexOfDifference(\"\", \"\"));\n+        assertEquals(0, StringUtils.indexOfDifference(\"\", \"abc\"));\n+        assertEquals(0, StringUtils.indexOfDifference(\"abc\", \"\"));\n+        assertEquals(0, StringUtils.indexOfDifference(\"i am a machine\", null));\n+        assertEquals(7, StringUtils.indexOfDifference(\"i am a machine\", \"i am a robot\"));\n+        assertEquals(-1, StringUtils.indexOfDifference(\"foo\", \"foo\"));\n+        assertEquals(0, StringUtils.indexOfDifference(\"i am a robot\", \"you are a robot\"));\n+        //System.out.println(\"indexOfDiff: \" + StringUtils.indexOfDifference(\"i am a robot\", \"not machine\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetLevenshteinDistance_StringString() {\n+        assertEquals(0, StringUtils.getLevenshteinDistance(\"\", \"\") );\n+        assertEquals(1, StringUtils.getLevenshteinDistance(\"\", \"a\") );\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"aaapppp\", \"\") );\n+        assertEquals(1, StringUtils.getLevenshteinDistance(\"frog\", \"fog\") );\n+        assertEquals(3, StringUtils.getLevenshteinDistance(\"fly\", \"ant\") );\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") );\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") );\n+        assertEquals(8, StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") );\n+        assertEquals(8, StringUtils.getLevenshteinDistance(\"zzzzzzzz\", \"hippo\") );\n+        assertEquals(1, StringUtils.getLevenshteinDistance(\"hello\", \"hallo\") );\n+        try {\n+            int d = StringUtils.getLevenshteinDistance(\"a\", null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+        try {\n+            int d = StringUtils.getLevenshteinDistance(null, \"a\");\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+    }\n+\n+    /**\n+     * A sanity check for {@link StringUtils.EMPTY}.\n+     */\n+    public void testEMPTY() {\n+        assertNotNull(StringUtils.EMPTY);\n+        assertEquals(\"\", StringUtils.EMPTY);\n+    }\n+    \n+    public void testRemoveStart() {\n+        // StringUtils.removeStart(\"\", *)        = \"\"\n+        assertNull(StringUtils.removeStart(null, null));\n+        assertNull(StringUtils.removeStart(null, \"\"));\n+        assertNull(StringUtils.removeStart(null, \"a\"));\n+        \n+        // StringUtils.removeStart(*, null)      = *\n+        assertEquals(StringUtils.removeStart(\"\", null), \"\");\n+        assertEquals(StringUtils.removeStart(\"\", \"\"), \"\");\n+        assertEquals(StringUtils.removeStart(\"\", \"a\"), \"\");\n+        \n+        // All others:\n+        assertEquals(StringUtils.removeStart(\"www.domain.com\", \"www.\"), \"domain.com\");\n+        assertEquals(StringUtils.removeStart(\"domain.com\", \"www.\"), \"domain.com\");\n+        assertEquals(StringUtils.removeStart(\"domain.com\", \"\"), \"domain.com\");        \n+        assertEquals(StringUtils.removeStart(\"domain.com\", null), \"domain.com\");        \n+    }\n+\n+    public void testRemoveEnd() {\n+        // StringUtils.removeEnd(\"\", *)        = \"\"\n+        assertNull(StringUtils.removeEnd(null, null));\n+        assertNull(StringUtils.removeEnd(null, \"\"));\n+        assertNull(StringUtils.removeEnd(null, \"a\"));\n+        \n+        // StringUtils.removeEnd(*, null)      = *\n+        assertEquals(StringUtils.removeEnd(\"\", null), \"\");\n+        assertEquals(StringUtils.removeEnd(\"\", \"\"), \"\");\n+        assertEquals(StringUtils.removeEnd(\"\", \"a\"), \"\");\n+        \n+        // All others:\n+        assertEquals(StringUtils.removeEnd(\"www.domain.com.\", \".com\"), \"www.domain.com.\");\n+        assertEquals(StringUtils.removeEnd(\"www.domain.com\", \".com\"), \"www.domain\");\n+        assertEquals(StringUtils.removeEnd(\"www.domain\", \".com\"), \"www.domain\");\n+        assertEquals(StringUtils.removeEnd(\"domain.com\", \"\"), \"domain.com\");   \n+        assertEquals(StringUtils.removeEnd(\"domain.com\", null), \"domain.com\");   \n+    }\n+\n+    public void testRemove_String() {\n+        // StringUtils.remove(null, *)        = null\n+        assertEquals(null, StringUtils.remove(null, null));\n+        assertEquals(null, StringUtils.remove(null, \"\"));\n+        assertEquals(null, StringUtils.remove(null, \"a\"));\n+        \n+        // StringUtils.remove(\"\", *)          = \"\"\n+        assertEquals(\"\", StringUtils.remove(\"\", null));\n+        assertEquals(\"\", StringUtils.remove(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.remove(\"\", \"a\"));\n+        \n+        // StringUtils.remove(*, null)        = *\n+        assertEquals(null, StringUtils.remove(null, null));\n+        assertEquals(\"\", StringUtils.remove(\"\", null));\n+        assertEquals(\"a\", StringUtils.remove(\"a\", null));\n+        \n+        // StringUtils.remove(*, \"\")          = *\n+        assertEquals(null, StringUtils.remove(null, \"\"));\n+        assertEquals(\"\", StringUtils.remove(\"\", \"\"));\n+        assertEquals(\"a\", StringUtils.remove(\"a\", \"\"));\n+        \n+        // StringUtils.remove(\"queued\", \"ue\") = \"qd\"\n+        assertEquals(\"qd\", StringUtils.remove(\"queued\", \"ue\"));\n+        \n+        // StringUtils.remove(\"queued\", \"zz\") = \"queued\"\n+        assertEquals(\"queued\", StringUtils.remove(\"queued\", \"zz\"));\n+    }\n+\n+    public void testRemove_char() {\n+        // StringUtils.remove(null, *)       = null\n+        assertEquals(null, StringUtils.remove(null, 'a'));\n+        assertEquals(null, StringUtils.remove(null, 'a'));\n+        assertEquals(null, StringUtils.remove(null, 'a'));\n+        \n+        // StringUtils.remove(\"\", *)          = \"\"\n+        assertEquals(\"\", StringUtils.remove(\"\", 'a'));\n+        assertEquals(\"\", StringUtils.remove(\"\", 'a'));\n+        assertEquals(\"\", StringUtils.remove(\"\", 'a'));\n+        \n+        // StringUtils.remove(\"queued\", 'u') = \"qeed\"\n+        assertEquals(\"qeed\", StringUtils.remove(\"queued\", 'u'));\n+        \n+        // StringUtils.remove(\"queued\", 'z') = \"queued\"\n+        assertEquals(\"queued\", StringUtils.remove(\"queued\", 'z'));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/StringUtilsTrimEmptyTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.StringUtils} - Trim/Empty methods\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @version $Id$\n+ */\n+public class StringUtilsTrimEmptyTest extends TestCase {\n+    private static final String FOO = \"foo\";\n+\n+    public StringUtilsTrimEmptyTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StringUtilsTrimEmptyTest.class);\n+        suite.setName(\"StringUtilsTrimEmpty Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsEmpty() {\n+        assertEquals(true, StringUtils.isEmpty(null));\n+        assertEquals(true, StringUtils.isEmpty(\"\"));\n+        assertEquals(false, StringUtils.isEmpty(\" \"));\n+        assertEquals(false, StringUtils.isEmpty(\"foo\"));\n+        assertEquals(false, StringUtils.isEmpty(\"  foo  \"));\n+    }\n+\n+    public void testIsNotEmpty() {\n+        assertEquals(false, StringUtils.isNotEmpty(null));\n+        assertEquals(false, StringUtils.isNotEmpty(\"\"));\n+        assertEquals(true, StringUtils.isNotEmpty(\" \"));\n+        assertEquals(true, StringUtils.isNotEmpty(\"foo\"));\n+        assertEquals(true, StringUtils.isNotEmpty(\"  foo  \"));\n+    }\n+\n+    public void testIsBlank() {\n+        assertEquals(true, StringUtils.isBlank(null));\n+        assertEquals(true, StringUtils.isBlank(\"\"));\n+        assertEquals(true, StringUtils.isBlank(StringUtilsTest.WHITESPACE));\n+        assertEquals(false, StringUtils.isBlank(\"foo\"));\n+        assertEquals(false, StringUtils.isBlank(\"  foo  \"));\n+    }\n+\n+    public void testIsNotBlank() {\n+        assertEquals(false, StringUtils.isNotBlank(null));\n+        assertEquals(false, StringUtils.isNotBlank(\"\"));\n+        assertEquals(false, StringUtils.isNotBlank(StringUtilsTest.WHITESPACE));\n+        assertEquals(true, StringUtils.isNotBlank(\"foo\"));\n+        assertEquals(true, StringUtils.isNotBlank(\"  foo  \"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClean() {\n+        assertEquals(FOO, StringUtils.clean(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.clean(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.clean(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.clean(FOO + \"\"));\n+        assertEquals(\"\", StringUtils.clean(\" \\t\\r\\n\\b \"));\n+        assertEquals(\"\", StringUtils.clean(\"\"));\n+        assertEquals(\"\", StringUtils.clean(null));\n+    }\n+\n+    public void testTrim() {\n+        assertEquals(FOO, StringUtils.trim(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trim(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trim(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.trim(FOO + \"\"));\n+        assertEquals(\"\", StringUtils.trim(\" \\t\\r\\n\\b \"));\n+        assertEquals(\"\", StringUtils.trim(StringUtilsTest.TRIMMABLE));\n+        assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trim(StringUtilsTest.NON_TRIMMABLE));\n+        assertEquals(\"\", StringUtils.trim(\"\"));\n+        assertEquals(null, StringUtils.trim(null));\n+    }\n+\n+    public void testTrimToNull() {\n+        assertEquals(FOO, StringUtils.trimToNull(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trimToNull(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trimToNull(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.trimToNull(FOO + \"\"));\n+        assertEquals(null, StringUtils.trimToNull(\" \\t\\r\\n\\b \"));\n+        assertEquals(null, StringUtils.trimToNull(StringUtilsTest.TRIMMABLE));\n+        assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToNull(StringUtilsTest.NON_TRIMMABLE));\n+        assertEquals(null, StringUtils.trimToNull(\"\"));\n+        assertEquals(null, StringUtils.trimToNull(null));\n+    }\n+\n+    public void testTrimToEmpty() {\n+        assertEquals(FOO, StringUtils.trimToEmpty(FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trimToEmpty(\" \" + FOO + \"  \"));\n+        assertEquals(FOO, StringUtils.trimToEmpty(\" \" + FOO));\n+        assertEquals(FOO, StringUtils.trimToEmpty(FOO + \"\"));\n+        assertEquals(\"\", StringUtils.trimToEmpty(\" \\t\\r\\n\\b \"));\n+        assertEquals(\"\", StringUtils.trimToEmpty(StringUtilsTest.TRIMMABLE));\n+        assertEquals(StringUtilsTest.NON_TRIMMABLE, StringUtils.trimToEmpty(StringUtilsTest.NON_TRIMMABLE));\n+        assertEquals(\"\", StringUtils.trimToEmpty(\"\"));\n+        assertEquals(\"\", StringUtils.trimToEmpty(null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStrip_String() {\n+        assertEquals(null, StringUtils.strip(null));\n+        assertEquals(\"\", StringUtils.strip(\"\"));\n+        assertEquals(\"\", StringUtils.strip(\"        \"));\n+        assertEquals(\"abc\", StringUtils.strip(\"  abc  \"));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));\n+    }\n+    \n+    public void testStripToNull_String() {\n+        assertEquals(null, StringUtils.stripToNull(null));\n+        assertEquals(null, StringUtils.stripToNull(\"\"));\n+        assertEquals(null, StringUtils.stripToNull(\"        \"));\n+        assertEquals(null, StringUtils.stripToNull(StringUtilsTest.WHITESPACE));\n+        assertEquals(\"ab c\", StringUtils.stripToNull(\"  ab c  \"));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.stripToNull(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));\n+    }\n+    \n+    public void testStripToEmpty_String() {\n+        assertEquals(\"\", StringUtils.stripToEmpty(null));\n+        assertEquals(\"\", StringUtils.stripToEmpty(\"\"));\n+        assertEquals(\"\", StringUtils.stripToEmpty(\"        \"));\n+        assertEquals(\"\", StringUtils.stripToEmpty(StringUtilsTest.WHITESPACE));\n+        assertEquals(\"ab c\", StringUtils.stripToEmpty(\"  ab c  \"));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.stripToEmpty(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE));\n+    }\n+    \n+    public void testStrip_StringString() {\n+        // null strip\n+        assertEquals(null, StringUtils.strip(null, null));\n+        assertEquals(\"\", StringUtils.strip(\"\", null));\n+        assertEquals(\"\", StringUtils.strip(\"        \", null));\n+        assertEquals(\"abc\", StringUtils.strip(\"  abc  \", null));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.strip(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));\n+\n+        // \"\" strip\n+        assertEquals(null, StringUtils.strip(null, \"\"));\n+        assertEquals(\"\", StringUtils.strip(\"\", \"\"));\n+        assertEquals(\"        \", StringUtils.strip(\"        \", \"\"));\n+        assertEquals(\"  abc  \", StringUtils.strip(\"  abc  \", \"\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, \"\"));\n+        \n+        // \" \" strip\n+        assertEquals(null, StringUtils.strip(null, \" \"));\n+        assertEquals(\"\", StringUtils.strip(\"\", \" \"));\n+        assertEquals(\"\", StringUtils.strip(\"        \", \" \"));\n+        assertEquals(\"abc\", StringUtils.strip(\"  abc  \", \" \"));\n+        \n+        // \"ab\" strip\n+        assertEquals(null, StringUtils.strip(null, \"ab\"));\n+        assertEquals(\"\", StringUtils.strip(\"\", \"ab\"));\n+        assertEquals(\"        \", StringUtils.strip(\"        \", \"ab\"));\n+        assertEquals(\"  abc  \", StringUtils.strip(\"  abc  \", \"ab\"));\n+        assertEquals(\"c\", StringUtils.strip(\"abcabab\", \"ab\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.strip(StringUtilsTest.WHITESPACE, \"\"));\n+    }\n+    \n+    public void testStripStart_StringString() {\n+        // null stripStart\n+        assertEquals(null, StringUtils.stripStart(null, null));\n+        assertEquals(\"\", StringUtils.stripStart(\"\", null));\n+        assertEquals(\"\", StringUtils.stripStart(\"        \", null));\n+        assertEquals(\"abc  \", StringUtils.stripStart(\"  abc  \", null));\n+        assertEquals(StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, \n+            StringUtils.stripStart(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));\n+\n+        // \"\" stripStart\n+        assertEquals(null, StringUtils.stripStart(null, \"\"));\n+        assertEquals(\"\", StringUtils.stripStart(\"\", \"\"));\n+        assertEquals(\"        \", StringUtils.stripStart(\"        \", \"\"));\n+        assertEquals(\"  abc  \", StringUtils.stripStart(\"  abc  \", \"\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE, \"\"));\n+        \n+        // \" \" stripStart\n+        assertEquals(null, StringUtils.stripStart(null, \" \"));\n+        assertEquals(\"\", StringUtils.stripStart(\"\", \" \"));\n+        assertEquals(\"\", StringUtils.stripStart(\"        \", \" \"));\n+        assertEquals(\"abc  \", StringUtils.stripStart(\"  abc  \", \" \"));\n+        \n+        // \"ab\" stripStart\n+        assertEquals(null, StringUtils.stripStart(null, \"ab\"));\n+        assertEquals(\"\", StringUtils.stripStart(\"\", \"ab\"));\n+        assertEquals(\"        \", StringUtils.stripStart(\"        \", \"ab\"));\n+        assertEquals(\"  abc  \", StringUtils.stripStart(\"  abc  \", \"ab\"));\n+        assertEquals(\"cabab\", StringUtils.stripStart(\"abcabab\", \"ab\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripStart(StringUtilsTest.WHITESPACE, \"\"));\n+    }\n+    \n+    public void testStripEnd_StringString() {\n+        // null stripEnd\n+        assertEquals(null, StringUtils.stripEnd(null, null));\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", null));\n+        assertEquals(\"\", StringUtils.stripEnd(\"        \", null));\n+        assertEquals(\"  abc\", StringUtils.stripEnd(\"  abc  \", null));\n+        assertEquals(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE, \n+            StringUtils.stripEnd(StringUtilsTest.WHITESPACE + StringUtilsTest.NON_WHITESPACE + StringUtilsTest.WHITESPACE, null));\n+\n+        // \"\" stripEnd\n+        assertEquals(null, StringUtils.stripEnd(null, \"\"));\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", \"\"));\n+        assertEquals(\"        \", StringUtils.stripEnd(\"        \", \"\"));\n+        assertEquals(\"  abc  \", StringUtils.stripEnd(\"  abc  \", \"\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE, \"\"));\n+        \n+        // \" \" stripEnd\n+        assertEquals(null, StringUtils.stripEnd(null, \" \"));\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", \" \"));\n+        assertEquals(\"\", StringUtils.stripEnd(\"        \", \" \"));\n+        assertEquals(\"  abc\", StringUtils.stripEnd(\"  abc  \", \" \"));\n+        \n+        // \"ab\" stripEnd\n+        assertEquals(null, StringUtils.stripEnd(null, \"ab\"));\n+        assertEquals(\"\", StringUtils.stripEnd(\"\", \"ab\"));\n+        assertEquals(\"        \", StringUtils.stripEnd(\"        \", \"ab\"));\n+        assertEquals(\"  abc  \", StringUtils.stripEnd(\"  abc  \", \"ab\"));\n+        assertEquals(\"abc\", StringUtils.stripEnd(\"abcabab\", \"ab\"));\n+        assertEquals(StringUtilsTest.WHITESPACE, StringUtils.stripEnd(StringUtilsTest.WHITESPACE, \"\"));\n+    }\n+\n+    public void testStripAll() {\n+        // test stripAll method, merely an array version of the above strip\n+        String[] empty = new String[0];\n+        String[] fooSpace = new String[] { \"  \"+FOO+\"  \", \"  \"+FOO, FOO+\"  \" };\n+        String[] fooDots = new String[] { \"..\"+FOO+\"..\", \"..\"+FOO, FOO+\"..\" };\n+        String[] foo = new String[] { FOO, FOO, FOO };\n+\n+        assertEquals(null, StringUtils.stripAll(null));\n+        assertArrayEquals(empty, StringUtils.stripAll(empty));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooSpace));\n+        \n+        assertEquals(null, StringUtils.stripAll(null, null));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooSpace, null));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooDots, \".\"));\n+    }\n+\n+    private void assertArrayEquals(Object[] o1, Object[] o2) {\n+        if(o1 == null) {\n+            assertEquals(o1,o2);\n+            return;\n+        }\n+        assertEquals(\"Length not equal. \", o1.length, o2.length);\n+        int sz = o1.length;\n+        for(int i=0; i<sz; i++) {\n+            if(o1[i] instanceof Object[]) {\n+                // do an assert equals on type....\n+                assertArrayEquals( (Object[]) o1[i], (Object[]) o2[i] );\n+            } else {\n+                assertEquals(o1[i], o2[i]);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/SystemUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.lang;\n+\n+import java.io.File;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.SystemUtils}.\n+ * \n+ * Only limited testing can be performed.\n+ * \n+ * @author Stephen Colebourne\n+ * @author Tetsuya Kaneuchi\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+public class SystemUtilsTest extends TestCase {\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SystemUtilsTest.class);\n+        suite.setName(\"SystemUtils Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // COPIED FROM SystemUtils\n+    //-----------------------------------------------------------------------\n+    private String JAVA_VERSION;\n+\n+    private String JAVA_VERSION_TRIMMED;\n+\n+    private String OS_NAME;\n+\n+    private String OS_VERSION;\n+\n+    public SystemUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * <p>Gets the Java version number as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 1.31f for JDK 1.3.1\n+     */\n+    private float getJavaVersionAsFloat() {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return 0f;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        }\n+        try {\n+            return Float.parseFloat(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the Java version number as an <code>int</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>120</code> for JDK 1.2\n+     *  <li><code>131</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 131 for JDK 1.3.1\n+     */\n+    private int getJavaVersionAsInt() {\n+        if (JAVA_VERSION == null) {\n+            return 0;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 1);\n+        str = str + JAVA_VERSION_TRIMMED.substring(2, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        } else {\n+            str = str + \"0\";\n+        }\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Trims the text of the java version to start with numbers.\n+     * \n+     * @return the trimmed java version\n+     */\n+    private String getJavaVersionTrimmed() {\n+        if (JAVA_VERSION != null) {\n+            for (int i = 0; i < JAVA_VERSION.length(); i++) {\n+                char ch = JAVA_VERSION.charAt(i);\n+                if (ch >= '0' && ch <= '9') {\n+                    return JAVA_VERSION.substring(i);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Decides if the java version matches.\n+     * \n+     * @param versionPrefix\n+     *                  the prefix for the java version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private boolean getJavaVersionMatches(String versionPrefix) {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return false;\n+        }\n+        return JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n+    }\n+\n+    /**\n+     * Decides if the operating system matches.\n+     * \n+     * @param osNamePrefix\n+     *                  the prefix for the os name\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private boolean getOSMatches(String osNamePrefix) {\n+        if (OS_NAME == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix);\n+    }\n+\n+    /**\n+     * Decides if the operating system matches.\n+     * \n+     * @param osNamePrefix\n+     *                  the prefix for the os name\n+     * @param osVersionPrefix\n+     *                  the prefix for the version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\n+        if (OS_NAME == null || OS_VERSION == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new SystemUtils());\n+        Constructor[] cons = SystemUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(SystemUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(SystemUtils.class.getModifiers()));\n+    }\n+\n+    /**\n+     * Assums no security manager exists.\n+     */\n+    public void testGetJavaHome() {\n+        File dir = SystemUtils.getJavaHome();\n+        Assert.assertNotNull(dir);\n+        Assert.assertTrue(dir.exists());\n+    }\n+\n+    /**\n+     * Assums no security manager exists.\n+     */\n+    public void testGetJavaIoTmpDir() {\n+        File dir = SystemUtils.getJavaIoTmpDir();\n+        Assert.assertNotNull(dir);\n+        Assert.assertTrue(dir.exists());\n+    }\n+\n+    /**\n+     * Assums no security manager exists.\n+     */\n+    public void testGetUserDir() {\n+        File dir = SystemUtils.getUserDir();\n+        Assert.assertNotNull(dir);\n+        Assert.assertTrue(dir.exists());\n+    }\n+\n+    /**\n+     * Assums no security manager exists.\n+     */\n+    public void testGetUserHome() {\n+        File dir = SystemUtils.getUserHome();\n+        Assert.assertNotNull(dir);\n+        Assert.assertTrue(dir.exists());\n+    }\n+\n+    public void testIS_JAVA() {\n+        String javaVersion = System.getProperty(\"java.version\");\n+        if (javaVersion == null) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.1\")) {\n+            assertEquals(true, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.2\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.3\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.4\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.5\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_6);\n+        } else if (javaVersion.startsWith(\"1.6\")) {\n+            assertEquals(false, SystemUtils.IS_JAVA_1_1);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_2);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_3);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_4);\n+            assertEquals(false, SystemUtils.IS_JAVA_1_5);\n+            assertEquals(true, SystemUtils.IS_JAVA_1_6);\n+        } else {\n+            System.out.println(\"Can't test IS_JAVA value\");\n+        }\n+    }\n+\n+    public void testIS_OS() {\n+        String osName = System.getProperty(\"os.name\");\n+        if (osName == null) {\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+            assertEquals(false, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_SOLARIS);\n+            assertEquals(false, SystemUtils.IS_OS_LINUX);\n+            assertEquals(false, SystemUtils.IS_OS_MAC_OSX);\n+        } else if (osName.startsWith(\"Windows\")) {\n+            assertEquals(false, SystemUtils.IS_OS_UNIX);\n+            assertEquals(true, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.startsWith(\"Solaris\")) {\n+            assertEquals(true, SystemUtils.IS_OS_SOLARIS);\n+            assertEquals(true, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.toLowerCase().startsWith(\"linux\")) {\n+            assertEquals(true, SystemUtils.IS_OS_LINUX);\n+            assertEquals(true, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.startsWith(\"Mac OS X\")) {\n+            assertEquals(true, SystemUtils.IS_OS_MAC_OSX);\n+            assertEquals(true, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.startsWith(\"OS/2\")) {\n+            assertEquals(true, SystemUtils.IS_OS_OS2);\n+            assertEquals(false, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else if (osName.startsWith(\"SunOS\")) {\n+            assertEquals(true, SystemUtils.IS_OS_SUN_OS);\n+            assertEquals(true, SystemUtils.IS_OS_UNIX);\n+            assertEquals(false, SystemUtils.IS_OS_WINDOWS);\n+        } else {\n+            System.out.println(\"Can't test IS_OS value\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testJavaVersion() {\n+        assertEquals(SystemUtils.JAVA_VERSION_FLOAT, SystemUtils.getJavaVersion(), 0f);\n+    }\n+\n+    public void testJavaVersionAsFloat() {\n+        JAVA_VERSION = null;\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(0f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.1f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.2\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.2f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.3.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.3f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.3.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.31f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.4.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.4f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.4.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.41f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.5.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.5f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"1.6.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.6f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"JavaVM-1.3.1\";  //HP-UX\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(1.31f, getJavaVersionAsFloat(), 0.000001f);\n+        JAVA_VERSION = \"XXX-1.3.x\";  //error\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(0.0f, getJavaVersionAsFloat(), 0.000001f);\n+    }\n+\n+    public void testJavaVersionAsInt() {\n+        JAVA_VERSION = null;\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(0, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(110, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.2\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(120, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.3.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(130, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.3.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(131, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.4.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(140, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.4.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(141, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.5.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(150, getJavaVersionAsInt());\n+        JAVA_VERSION = \"1.6.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(160, getJavaVersionAsInt());\n+        JAVA_VERSION = \"JavaVM-1.3.1\";  //HP-UX\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(131, getJavaVersionAsInt());\n+        JAVA_VERSION = \"XXX-1.3.x\";  //error\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(0, getJavaVersionAsInt());\n+    }\n+\n+    public void testJavaVersionAtLeastFloat() {\n+        float version = SystemUtils.JAVA_VERSION_FLOAT;\n+        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));\n+        version -= 0.1f;\n+        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));\n+        version += 0.2f;\n+        assertEquals(false, SystemUtils.isJavaVersionAtLeast(version));\n+    }\n+\n+    public void testJavaVersionAtLeastInt() {\n+        int version = SystemUtils.JAVA_VERSION_INT;\n+        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));\n+        version -= 10;\n+        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));\n+        version += 20;\n+        assertEquals(false, SystemUtils.isJavaVersionAtLeast(version));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testJavaVersionMatches() {\n+        JAVA_VERSION = null;\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(true, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.2\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.3.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.3.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.4.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.4.1\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.5.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(true, getJavaVersionMatches(\"1.5\"));\n+        JAVA_VERSION = \"1.6.0\";\n+        JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+        assertEquals(false, getJavaVersionMatches(\"1.1\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.2\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.3\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.4\"));\n+        assertEquals(false, getJavaVersionMatches(\"1.5\"));\n+    }\n+\n+    public void testOSMatches() {\n+        OS_NAME = null;\n+        assertEquals(false, getOSMatches(\"Windows\"));\n+        OS_NAME = \"Windows 95\";\n+        assertEquals(true, getOSMatches(\"Windows\"));\n+        OS_NAME = \"Windows NT\";\n+        assertEquals(true, getOSMatches(\"Windows\"));\n+        OS_NAME = \"OS/2\";\n+        assertEquals(false, getOSMatches(\"Windows\"));\n+    }\n+\n+    public void testOSMatches2() {\n+        OS_NAME = null;\n+        OS_VERSION = null;\n+        assertEquals(false, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"Windows 95\";\n+        OS_VERSION = \"4.0\";\n+        assertEquals(false, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"Windows 95\";\n+        OS_VERSION = \"4.1\";\n+        assertEquals(true, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"Windows 98\";\n+        OS_VERSION = \"4.1\";\n+        assertEquals(true, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"Windows NT\";\n+        OS_VERSION = \"4.0\";\n+        assertEquals(false, getOSMatches(\"Windows 9\", \"4.1\"));\n+        OS_NAME = \"OS/2\";\n+        OS_VERSION = \"4.0\";\n+        assertEquals(false, getOSMatches(\"Windows 9\", \"4.1\"));\n+    }\n+\n+    public void testJavaAwtHeadless() {\n+        boolean atLeastJava14 = SystemUtils.isJavaVersionAtLeast(140);\n+        String expectedStringValue = System.getProperty(\"java.awt.headless\");\n+        String expectedStringValueWithDefault = System.getProperty(\"java.awt.headless\", \"false\");\n+        assertNotNull(expectedStringValueWithDefault);\n+        if (atLeastJava14) {\n+            boolean expectedValue = Boolean.valueOf(expectedStringValue).booleanValue();\n+            if (expectedStringValue != null) {\n+                assertEquals(expectedStringValue, SystemUtils.JAVA_AWT_HEADLESS);\n+            }\n+            assertEquals(expectedValue, SystemUtils.isJavaAwtHeadless());\n+        } else {\n+            assertNull(expectedStringValue);\n+            assertNull(SystemUtils.JAVA_AWT_HEADLESS);\n+            assertEquals(expectedStringValueWithDefault, \"\" + SystemUtils.isJavaAwtHeadless());\n+        }\n+        assertEquals(expectedStringValueWithDefault, \"\" + SystemUtils.isJavaAwtHeadless());\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/UnhandledExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+import org.apache.commons.lang.exception.Nestable;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @author Matthew Hawthorne\n+ * @version $Id$\n+ * @see UnhandledException\n+ */\n+public class UnhandledExceptionTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(UnhandledExceptionTest.class);\n+    }\n+\n+    public UnhandledExceptionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    // testConstructor\n+\n+    public void testConstructor_throwable_nullInput() {\n+        final Throwable t = null;\n+        new UnhandledException(t);\n+    }\n+\n+    public void testConstructor_stringAndThrowable_nullInput() {\n+        new UnhandledException(null, null);\n+    }\n+\n+    // testGetCause\n+\n+    public void testGetCause() {\n+        final Throwable t = new NullPointerException();\n+        final Nestable n = new UnhandledException(t);\n+        assertEquals(t, n.getCause());\n+    }\n+\n+    public void testGetCauseAndGetMessage() {\n+        final Throwable t = new NullPointerException();\n+        final String msg = \"nullArg\";\n+        final Nestable n = new UnhandledException(msg, t);\n+        assertEquals(t, n.getCause());\n+        assertEquals(msg, n.getMessage());\n+    }\n+\n+} // UnhandledExceptionTest\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/ValidateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Unit tests {@link org.apache.commons.lang.util.Validate}.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Norm Deane\n+ * @version $Id$\n+ */\n+public class ValidateTest extends TestCase {\n+\n+    public ValidateTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ValidateTest.class);\n+        suite.setName(\"Validate Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue1() {\n+        Validate.isTrue(true);\n+        try {\n+            Validate.isTrue(false);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated expression is false\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue2() {\n+        Validate.isTrue(true, \"MSG\");\n+        try {\n+            Validate.isTrue(false, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue3() {\n+        Validate.isTrue(true, \"MSG\", new Integer(6));\n+        try {\n+            Validate.isTrue(false, \"MSG\", new Integer(6));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG6\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue4() {\n+        Validate.isTrue(true, \"MSG\", 7);\n+        try {\n+            Validate.isTrue(false, \"MSG\", 7);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG7\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsTrue5() {\n+        Validate.isTrue(true, \"MSG\", 7.4d);\n+        try {\n+            Validate.isTrue(false, \"MSG\", 7.4d);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG7.4\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotNull1() {\n+        Validate.notNull(new Object());\n+        try {\n+            Validate.notNull(null);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotNull2() {\n+        Validate.notNull(new Object(), \"MSG\");\n+        try {\n+            Validate.notNull(null, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyArray1() {\n+        Validate.notEmpty(new Object[] {null});\n+        try {\n+            Validate.notEmpty((Object[]) null);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated array is empty\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(new Object[0]);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated array is empty\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyArray2() {\n+        Validate.notEmpty(new Object[] {null}, \"MSG\");\n+        try {\n+            Validate.notEmpty((Object[]) null, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(new Object[0], \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyCollection1() {\n+        Collection coll = new ArrayList();\n+        try {\n+            Validate.notEmpty((Collection) null);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated collection is empty\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(coll);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated collection is empty\", ex.getMessage());\n+        }\n+        coll.add(new Integer(8));\n+        Validate.notEmpty(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyCollection2() {\n+        Collection coll = new ArrayList();\n+        try {\n+            Validate.notEmpty((Collection) null, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(coll, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        coll.add(new Integer(8));\n+        Validate.notEmpty(coll, \"MSG\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyMap1() {\n+        Map map = new HashMap();\n+        try {\n+            Validate.notEmpty((Map) null);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated map is empty\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(map);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated map is empty\", ex.getMessage());\n+        }\n+        map.put(\"ll\", new Integer(8));\n+        Validate.notEmpty(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyMap2() {\n+        Map map = new HashMap();\n+        try {\n+            Validate.notEmpty((Map) null, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(map, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        map.put(\"ll\", new Integer(8));\n+        Validate.notEmpty(map, \"MSG\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyString1() {\n+        Validate.notEmpty(\"hjl\");\n+        try {\n+            Validate.notEmpty((String) null);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated string is empty\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(\"\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated string is empty\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNotEmptyString2() {\n+        Validate.notEmpty(\"a\", \"MSG\");\n+        try {\n+            Validate.notEmpty((String) null, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.notEmpty(\"\", \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoNullElementsArray1() {\n+        String[] array = new String[] {\"a\", \"b\"};\n+        Validate.noNullElements(array);\n+        try {\n+            Validate.noNullElements((Object[]) null);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        array[1] = null;\n+        try {\n+            Validate.noNullElements(array);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated array contains null element at index: 1\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoNullElementsArray2() {\n+        String[] array = new String[] {\"a\", \"b\"};\n+        Validate.noNullElements(array, \"MSG\");\n+        try {\n+            Validate.noNullElements((Object[]) null, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        array[1] = null;\n+        try {\n+            Validate.noNullElements(array, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoNullElementsCollection1() {\n+        List coll = new ArrayList();\n+        coll.add(\"a\");\n+        coll.add(\"b\");\n+        Validate.noNullElements(coll);\n+        try {\n+            Validate.noNullElements((Collection) null);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        coll.set(1, null);\n+        try {\n+            Validate.noNullElements(coll);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated collection contains null element at index: 1\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoNullElementsCollection2() {\n+        List coll = new ArrayList();\n+        coll.add(\"a\");\n+        coll.add(\"b\");\n+        Validate.noNullElements(coll, \"MSG\");\n+        try {\n+            Validate.noNullElements((Collection) null, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated object is null\", ex.getMessage());\n+        }\n+        coll.set(1, null);\n+        try {\n+            Validate.noNullElements(coll, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAllElementsOfType() {\n+        List coll = new ArrayList();\n+        coll.add(\"a\");\n+        coll.add(\"b\");\n+        Validate.allElementsOfType(coll, String.class, \"MSG\");\n+        Validate.allElementsOfType(coll, String.class);\n+        try {\n+            Validate.allElementsOfType(coll, Integer.class, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        coll.set(1, Boolean.FALSE);\n+        try {\n+            Validate.allElementsOfType(coll, String.class);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"The validated collection contains an element not of type java.lang.String at index: 1\", ex.getMessage());\n+        }\n+        \n+        coll = new ArrayList();\n+        coll.add(new Integer(5));\n+        coll.add(new Double(2.0d));\n+        Validate.allElementsOfType(coll, Number.class, \"MSG\");\n+        try {\n+            Validate.allElementsOfType(coll, Integer.class, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        try {\n+            Validate.allElementsOfType(coll, Double.class, \"MSG\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+    }\n+\n+    public void testConstructor() {\n+        assertNotNull(new Validate());\n+        Constructor[] cons = Validate.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(Validate.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(Validate.class.getModifiers()));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/WordUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Unit tests for WordUtils class.\n+ * \n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Henri Yandell\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class WordUtilsTest extends TestCase {\n+\n+    public WordUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(WordUtilsTest.class);\n+        suite.setName(\"WordUtilsTests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new WordUtils());\n+        Constructor[] cons = WordUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(WordUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(WordUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testWrap_StringInt() {\n+        assertEquals(null, WordUtils.wrap(null, 20));\n+        assertEquals(null, WordUtils.wrap(null, -1));\n+        \n+        assertEquals(\"\", WordUtils.wrap(\"\", 20));\n+        assertEquals(\"\", WordUtils.wrap(\"\", -1));\n+        \n+        // normal\n+        String systemNewLine = System.getProperty(\"line.separator\");\n+        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n+        String expected = \"Here is one line of\" + systemNewLine + \"text that is going\" \n+            + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20));\n+        \n+        // long word at end\n+        input = \"Click here to jump to the jakarta website - http://jakarta.apache.org\";\n+        expected = \"Click here to jump\" + systemNewLine + \"to the jakarta\" + systemNewLine \n+            + \"website -\" + systemNewLine + \"http://jakarta.apache.org\";\n+        assertEquals(expected, WordUtils.wrap(input, 20));\n+        \n+        // long word in middle\n+        input = \"Click here, http://jakarta.apache.org, to jump to the jakarta website\";\n+        expected = \"Click here,\" + systemNewLine + \"http://jakarta.apache.org,\" + systemNewLine \n+            + \"to jump to the\" + systemNewLine + \"jakarta website\";\n+        assertEquals(expected, WordUtils.wrap(input, 20));\n+    }\n+    \n+    public void testWrap_StringIntStringBoolean() {\n+        assertEquals(null, WordUtils.wrap(null, 20, \"\\n\", false));\n+        assertEquals(null, WordUtils.wrap(null, 20, \"\\n\", true));\n+        assertEquals(null, WordUtils.wrap(null, 20, null, true));\n+        assertEquals(null, WordUtils.wrap(null, 20, null, false));\n+        assertEquals(null, WordUtils.wrap(null, -1, null, true));\n+        assertEquals(null, WordUtils.wrap(null, -1, null, false));\n+        \n+        assertEquals(\"\", WordUtils.wrap(\"\", 20, \"\\n\", false));\n+        assertEquals(\"\", WordUtils.wrap(\"\", 20, \"\\n\", true));\n+        assertEquals(\"\", WordUtils.wrap(\"\", 20, null, false));\n+        assertEquals(\"\", WordUtils.wrap(\"\", 20, null, true));\n+        assertEquals(\"\", WordUtils.wrap(\"\", -1, null, false));\n+        assertEquals(\"\", WordUtils.wrap(\"\", -1, null, true));\n+        \n+        // normal\n+        String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n+        String expected = \"Here is one line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+\n+        // unusual newline char\n+        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n+        expected = \"Here is one line of<br />text that is going<br />to be wrapped after<br />20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"<br />\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"<br />\", true));\n+\n+        // short line length\n+        input = \"Here is one line\";\n+        expected = \"Here\\nis one\\nline\";\n+        assertEquals(expected, WordUtils.wrap(input, 6, \"\\n\", false));\n+        expected = \"Here\\nis\\none\\nline\";\n+        assertEquals(expected, WordUtils.wrap(input, 2, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, -1, \"\\n\", false));\n+\n+        // system newline char\n+        String systemNewLine = System.getProperty(\"line.separator\");\n+        input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n+        expected = \"Here is one line of\" + systemNewLine + \"text that is going\" + systemNewLine \n+            + \"to be wrapped after\" + systemNewLine + \"20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, null, false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, null, true));\n+\n+        // with extra spaces\n+        input = \" Here:  is  one  line  of  text  that  is  going  to  be  wrapped  after  20  columns.\";\n+        expected = \"Here:  is  one  line\\nof  text  that  is \\ngoing  to  be \\nwrapped  after  20 \\ncolumns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+        \n+        // with tab\n+        input = \"Here is\\tone line of text that is going to be wrapped after 20 columns.\";\n+        expected = \"Here is\\tone line of\\ntext that is going\\nto be wrapped after\\n20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+        \n+        // with tab at wrapColumn\n+        input = \"Here is one line of\\ttext that is going to be wrapped after 20 columns.\";\n+        expected = \"Here is one line\\nof\\ttext that is\\ngoing to be wrapped\\nafter 20 columns.\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+        \n+        // difference because of long word\n+        input = \"Click here to jump to the jakarta website - http://jakarta.apache.org\";\n+        expected = \"Click here to jump\\nto the jakarta\\nwebsite -\\nhttp://jakarta.apache.org\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        expected = \"Click here to jump\\nto the jakarta\\nwebsite -\\nhttp://jakarta.apach\\ne.org\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+        \n+        // difference because of long word in middle\n+        input = \"Click here, http://jakarta.apache.org, to jump to the jakarta website\";\n+        expected = \"Click here,\\nhttp://jakarta.apache.org,\\nto jump to the\\njakarta website\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", false));\n+        expected = \"Click here,\\nhttp://jakarta.apach\\ne.org, to jump to\\nthe jakarta website\";\n+        assertEquals(expected, WordUtils.wrap(input, 20, \"\\n\", true));\n+//        System.err.println(expected);\n+//        System.err.println(WordUtils.wrap(input, 20, \"\\n\", false));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testCapitalize_String() {\n+        assertEquals(null, WordUtils.capitalize(null));\n+        assertEquals(\"\", WordUtils.capitalize(\"\"));\n+        assertEquals(\"  \", WordUtils.capitalize(\"  \"));\n+        \n+        assertEquals(\"I\", WordUtils.capitalize(\"I\") );\n+        assertEquals(\"I\", WordUtils.capitalize(\"i\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalize(\"i am here 123\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalize(\"I Am Here 123\") );\n+        assertEquals(\"I Am HERE 123\", WordUtils.capitalize(\"i am HERE 123\") );\n+        assertEquals(\"I AM HERE 123\", WordUtils.capitalize(\"I AM HERE 123\") );\n+    }\n+    \n+    public void testCapitalizeWithDelimiters_String() {\n+        assertEquals(null, WordUtils.capitalize(null, null));\n+        assertEquals(\"\", WordUtils.capitalize(\"\", new char[0]));\n+        assertEquals(\"  \", WordUtils.capitalize(\"  \", new char[0]));\n+        \n+        char[] chars = new char[] { '-', '+', ' ', '@' };\n+        assertEquals(\"I\", WordUtils.capitalize(\"I\", chars) );\n+        assertEquals(\"I\", WordUtils.capitalize(\"i\", chars) );\n+        assertEquals(\"I-Am Here+123\", WordUtils.capitalize(\"i-am here+123\", chars) );\n+        assertEquals(\"I Am+Here-123\", WordUtils.capitalize(\"I Am+Here-123\", chars) );\n+        assertEquals(\"I+Am-HERE 123\", WordUtils.capitalize(\"i+am-HERE 123\", chars) );\n+        assertEquals(\"I-AM HERE+123\", WordUtils.capitalize(\"I-AM HERE+123\", chars) );\n+        chars = new char[] {'.'};\n+        assertEquals(\"I aM.Fine\", WordUtils.capitalize(\"i aM.fine\", chars) );\n+        assertEquals(\"I Am.fine\", WordUtils.capitalize(\"i am.fine\", null) );\n+    }\n+\n+    public void testCapitalizeFully_String() {\n+        assertEquals(null, WordUtils.capitalizeFully(null));\n+        assertEquals(\"\", WordUtils.capitalizeFully(\"\"));\n+        assertEquals(\"  \", WordUtils.capitalizeFully(\"  \"));\n+        \n+        assertEquals(\"I\", WordUtils.capitalizeFully(\"I\") );\n+        assertEquals(\"I\", WordUtils.capitalizeFully(\"i\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalizeFully(\"i am here 123\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalizeFully(\"I Am Here 123\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalizeFully(\"i am HERE 123\") );\n+        assertEquals(\"I Am Here 123\", WordUtils.capitalizeFully(\"I AM HERE 123\") );\n+    }\n+    \n+    public void testCapitalizeFullyWithDelimiters_String() {\n+        assertEquals(null, WordUtils.capitalizeFully(null, null));\n+        assertEquals(\"\", WordUtils.capitalizeFully(\"\", new char[0]));\n+        assertEquals(\"  \", WordUtils.capitalizeFully(\"  \", new char[0]));\n+        \n+        char[] chars = new char[] { '-', '+', ' ', '@' };\n+        assertEquals(\"I\", WordUtils.capitalizeFully(\"I\", chars) );\n+        assertEquals(\"I\", WordUtils.capitalizeFully(\"i\", chars) );\n+        assertEquals(\"I-Am Here+123\", WordUtils.capitalizeFully(\"i-am here+123\", chars) );\n+        assertEquals(\"I Am+Here-123\", WordUtils.capitalizeFully(\"I Am+Here-123\", chars) );\n+        assertEquals(\"I+Am-Here 123\", WordUtils.capitalizeFully(\"i+am-HERE 123\", chars) );\n+        assertEquals(\"I-Am Here+123\", WordUtils.capitalizeFully(\"I-AM HERE+123\", chars) );\n+        chars = new char[] {'.'};\n+        assertEquals(\"I am.Fine\", WordUtils.capitalizeFully(\"i aM.fine\", chars) );\n+        assertEquals(\"I Am.fine\", WordUtils.capitalizeFully(\"i am.fine\", null) );\n+    }\n+\n+    public void testUncapitalize_String() {\n+        assertEquals(null, WordUtils.uncapitalize(null));\n+        assertEquals(\"\", WordUtils.uncapitalize(\"\"));\n+        assertEquals(\"  \", WordUtils.uncapitalize(\"  \"));\n+        \n+        assertEquals(\"i\", WordUtils.uncapitalize(\"I\") );\n+        assertEquals(\"i\", WordUtils.uncapitalize(\"i\") );\n+        assertEquals(\"i am here 123\", WordUtils.uncapitalize(\"i am here 123\") );\n+        assertEquals(\"i am here 123\", WordUtils.uncapitalize(\"I Am Here 123\") );\n+        assertEquals(\"i am hERE 123\", WordUtils.uncapitalize(\"i am HERE 123\") );\n+        assertEquals(\"i aM hERE 123\", WordUtils.uncapitalize(\"I AM HERE 123\") );\n+    }\n+    \n+    public void testUncapitalizeWithDelimiters_String() {\n+        assertEquals(null, WordUtils.uncapitalize(null, null));\n+        assertEquals(\"\", WordUtils.uncapitalize(\"\", new char[0]));\n+        assertEquals(\"  \", WordUtils.uncapitalize(\"  \", new char[0]));\n+        \n+        char[] chars = new char[] { '-', '+', ' ', '@' };\n+        assertEquals(\"i\", WordUtils.uncapitalize(\"I\", chars) );\n+        assertEquals(\"i\", WordUtils.uncapitalize(\"i\", chars) );\n+        assertEquals(\"i am-here+123\", WordUtils.uncapitalize(\"i am-here+123\", chars) );\n+        assertEquals(\"i+am here-123\", WordUtils.uncapitalize(\"I+Am Here-123\", chars) );\n+        assertEquals(\"i-am+hERE 123\", WordUtils.uncapitalize(\"i-am+HERE 123\", chars) );\n+        assertEquals(\"i aM-hERE+123\", WordUtils.uncapitalize(\"I AM-HERE+123\", chars) );\n+        chars = new char[] {'.'};\n+        assertEquals(\"i AM.fINE\", WordUtils.uncapitalize(\"I AM.FINE\", chars) );\n+        assertEquals(\"i aM.FINE\", WordUtils.uncapitalize(\"I AM.FINE\", null) );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInitials_String() {\n+        assertEquals(null, WordUtils.initials(null));\n+        assertEquals(\"\", WordUtils.initials(\"\"));\n+        assertEquals(\"\", WordUtils.initials(\"  \"));\n+\n+        assertEquals(\"I\", WordUtils.initials(\"I\"));\n+        assertEquals(\"i\", WordUtils.initials(\"i\"));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\"));\n+        assertEquals(\"BJ\", WordUtils.initials(\"Ben J.Lee\"));\n+        assertEquals(\"BJ.L\", WordUtils.initials(\" Ben   John  . Lee\"));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\"));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testInitials_String_charArray() {\n+        char[] array = null;\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"I\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"S\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"BJ\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"BJ.L\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"KO\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = new char[0];\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = \" \".toCharArray();\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"I\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"S\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"BJ\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"BJ.L\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"KO\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = \" .\".toCharArray();\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"I\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"S\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"KO\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = \" .'\".toCharArray();\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\"\", WordUtils.initials(\"  \", array));\n+        assertEquals(\"I\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"S\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\"BJL\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"KOM\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"iah1\", WordUtils.initials(\"i am here 123\", array));\n+        \n+        array = \"SIJo1\".toCharArray();\n+        assertEquals(null, WordUtils.initials(null, array));\n+        assertEquals(\"\", WordUtils.initials(\"\", array));\n+        assertEquals(\" \", WordUtils.initials(\"  \", array));\n+        assertEquals(\"\", WordUtils.initials(\"I\", array));\n+        assertEquals(\"i\", WordUtils.initials(\"i\", array));\n+        assertEquals(\"C\", WordUtils.initials(\"SJC\", array));\n+        assertEquals(\"Bh\", WordUtils.initials(\"Ben John Lee\", array));\n+        assertEquals(\"B.\", WordUtils.initials(\"Ben J.Lee\", array));\n+        assertEquals(\" h\", WordUtils.initials(\" Ben   John  . Lee\", array));\n+        assertEquals(\"K\", WordUtils.initials(\"Kay O'Murphy\", array));\n+        assertEquals(\"i2\", WordUtils.initials(\"i am here 123\", array));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testSwapCase_String() {\n+        assertEquals(null, WordUtils.swapCase(null));\n+        assertEquals(\"\", WordUtils.swapCase(\"\"));\n+        assertEquals(\"  \", WordUtils.swapCase(\"  \"));\n+        \n+        assertEquals(\"i\", WordUtils.swapCase(\"I\") );\n+        assertEquals(\"I\", WordUtils.swapCase(\"i\") );\n+        assertEquals(\"I AM HERE 123\", WordUtils.swapCase(\"i am here 123\") );\n+        assertEquals(\"i aM hERE 123\", WordUtils.swapCase(\"I Am Here 123\") );\n+        assertEquals(\"I AM here 123\", WordUtils.swapCase(\"i am HERE 123\") );\n+        assertEquals(\"i am here 123\", WordUtils.swapCase(\"I AM HERE 123\") );\n+\n+        String test = \"This String contains a TitleCase character: \\u01C8\";\n+        String expect = \"tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \\u01C9\";\n+        assertEquals(expect, WordUtils.swapCase(test));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/BuilderTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Test suite for the Lang Builder package.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class BuilderTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public BuilderTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Builder Tests\");\n+        suite.addTestSuite(CompareToBuilderTest.class);\n+        suite.addTestSuite(EqualsBuilderTest.class);\n+        suite.addTestSuite(HashCodeBuilderTest.class);\n+        suite.addTestSuite(HashCodeBuilderAndEqualsBuilderTest.class);\n+        suite.addTestSuite(ToStringBuilderTest.class);\n+        suite.addTestSuite(DefaultToStringStyleTest.class);\n+        suite.addTestSuite(NoFieldNamesToStringStyleTest.class);\n+        suite.addTestSuite(MultiLineToStringStyleTest.class);\n+        suite.addTestSuite(ReflectionToStringBuilderExcludeTest.class);\n+        suite.addTestSuite(SimpleToStringStyleTest.class);\n+        suite.addTestSuite(StandardToStringStyleTest.class);\n+        suite.addTestSuite(ToStringStyleTest.class);\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/CompareToBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.math.BigInteger;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.CompareToBuilder}.\n+ *\n+ * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class CompareToBuilderTest extends TestCase {\n+\n+  public CompareToBuilderTest(String name) {\n+    super(name);\n+  }\n+     public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CompareToBuilderTest.class);\n+        suite.setName(\"CompareToBuilder Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    static class TestObject implements Comparable {\n+        private int a;\n+        public TestObject(int a) {\n+            this.a = a;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestObject)) {\n+                return false;\n+            }\n+            TestObject rhs = (TestObject) o;\n+            return (a == rhs.a);\n+        }\n+\n+        public void setA(int a) {\n+            this.a = a;\n+        }\n+\n+        public int getA() {\n+            return a;\n+        }\n+        public int compareTo(Object o) {\n+            TestObject rhs = (TestObject) o;\n+            return (a < rhs.a) ? -1 : (a > rhs.a) ? +1 : 0;\n+        }\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b) {\n+            super(a);\n+            this.b = b;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestSubObject)) {\n+                return false;\n+            }\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+    }\n+\n+    static class TestTransientSubObject extends TestObject {\n+        private transient int t;\n+        public TestTransientSubObject(int a, int t) {\n+            super(a);\n+            this.t = t;\n+        }\n+    }\n+    \n+    public void testReflectionCompare() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(4);\n+        assertTrue(CompareToBuilder.reflectionCompare(o1, o1) == 0);\n+        assertTrue(CompareToBuilder.reflectionCompare(o1, o2) == 0);\n+        o2.setA(5);\n+        assertTrue(CompareToBuilder.reflectionCompare(o1, o2) < 0);\n+        assertTrue(CompareToBuilder.reflectionCompare(o2, o1) > 0);\n+    }\n+\n+    public void testReflectionCompareEx1() {\n+        TestObject o1 = new TestObject(4);\n+        try {\n+            CompareToBuilder.reflectionCompare(o1, null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionCompareEx2() {\n+        TestObject o1 = new TestObject(4);\n+        Object o2 = new Object();\n+        try {\n+            CompareToBuilder.reflectionCompare(o1, o2);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testReflectionHierarchyCompare() {\n+        testReflectionHierarchyCompare(false, null);\n+    }\n+    \n+    public void testReflectionHierarchyCompareExcludeFields() {\n+        String[] excludeFields = new String[] { \"b\" };\n+        testReflectionHierarchyCompare(true, excludeFields);\n+        \n+        TestSubObject x;\n+        TestSubObject y;\n+        TestSubObject z;\n+        \n+        x = new TestSubObject(1, 1);\n+        y = new TestSubObject(2, 1);\n+        z = new TestSubObject(3, 1);\n+        assertXYZCompareOrder(x, y, z, true, excludeFields);\n+\n+        x = new TestSubObject(1, 3);\n+        y = new TestSubObject(2, 2);\n+        z = new TestSubObject(3, 1);\n+        assertXYZCompareOrder(x, y, z, true, excludeFields);\n+    }\n+    \n+    public void testReflectionHierarchyCompareTransients() {\n+        testReflectionHierarchyCompare(true, null);\n+\n+        TestTransientSubObject x;\n+        TestTransientSubObject y;\n+        TestTransientSubObject z;\n+\n+        x = new TestTransientSubObject(1, 1);\n+        y = new TestTransientSubObject(2, 2);\n+        z = new TestTransientSubObject(3, 3);\n+        assertXYZCompareOrder(x, y, z, true, null);\n+        \n+        x = new TestTransientSubObject(1, 1);\n+        y = new TestTransientSubObject(1, 2);\n+        z = new TestTransientSubObject(1, 3);\n+        assertXYZCompareOrder(x, y, z, true, null);  \n+    }\n+    \n+    private void assertXYZCompareOrder(Object x, Object y, Object z, boolean testTransients, String[] excludeFields) {\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(x, x, testTransients, null, excludeFields));\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(y, y, testTransients, null, excludeFields));\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(z, z, testTransients, null, excludeFields));\n+        \n+        assertTrue(0 > CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields));\n+        assertTrue(0 > CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields));\n+        assertTrue(0 > CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields));\n+        \n+        assertTrue(0 < CompareToBuilder.reflectionCompare(y, x, testTransients, null, excludeFields));\n+        assertTrue(0 < CompareToBuilder.reflectionCompare(z, x, testTransients, null, excludeFields));\n+        assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients, null, excludeFields));\n+    }\n+    \n+    public void testReflectionHierarchyCompare(boolean testTransients, String[] excludeFields) {\n+        TestObject to1 = new TestObject(1);\n+        TestObject to2 = new TestObject(2);\n+        TestObject to3 = new TestObject(3);\n+        TestSubObject tso1 = new TestSubObject(1, 1);\n+        TestSubObject tso2 = new TestSubObject(2, 2);\n+        TestSubObject tso3 = new TestSubObject(3, 3);\n+        \n+        assertReflectionCompareContract(to1, to1, to1, false, excludeFields);\n+        assertReflectionCompareContract(to1, to2, to3, false, excludeFields);\n+        assertReflectionCompareContract(tso1, tso1, tso1, false, excludeFields);\n+        assertReflectionCompareContract(tso1, tso2, tso3, false, excludeFields);\n+        assertReflectionCompareContract(\"1\", \"2\", \"3\", false, excludeFields);\n+        \n+        assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(1, 0), testTransients));\n+        assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(0, 1), testTransients));\n+\n+        // root class\n+        assertXYZCompareOrder(to1, to2, to3, true, null);\n+        // subclass  \n+        assertXYZCompareOrder(tso1, tso2, tso3, true, null);  \n+    }\n+\n+    /**\n+     * See \"Effective Java\" under \"Consider Implementing Comparable\".\n+     *  \n+     * @param x an object to compare \n+     * @param y an object to compare\n+     * @param z an object to compare\n+     * @param testTransients Whether to include transients in the comparison\n+     * @param excludeFields fields to exclude\n+     */\n+    public void assertReflectionCompareContract(Object x, Object y, Object z, boolean testTransients, String[] excludeFields) {\n+\n+        // signum\n+        assertTrue(reflectionCompareSignum(x, y, testTransients, excludeFields) == -reflectionCompareSignum(y, x, testTransients, excludeFields));\n+        \n+        // transitive\n+        if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) > 0 \n+                && CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields) > 0){\n+            assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields) > 0);\n+        }\n+        \n+        // un-named\n+        if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) == 0) {\n+            assertTrue(reflectionCompareSignum(x, z, testTransients, excludeFields) == -reflectionCompareSignum(y, z, testTransients, excludeFields));\n+        }\n+        \n+        // strongly recommended but not strictly required\n+        assertTrue((CompareToBuilder.reflectionCompare(x, y, testTransients) ==0 ) == EqualsBuilder.reflectionEquals(x, y, testTransients));\n+    }\n+    \n+    /**\n+     * Returns the signum of the result of comparing x and y with\n+     * <code>CompareToBuilder.reflectionCompare</code>\n+     * \n+     * @param lhs The \"left-hand-side\" of the comparison.\n+     * @param rhs The \"right-hand-side\" of the comparison.\n+     * @param testTransients Whether to include transients in the comparison\n+     * @param excludeFields fields to exclude\n+     * @return int The signum\n+     */\n+    private int reflectionCompareSignum(Object lhs, Object rhs, boolean testTransients, String[] excludeFields) {\n+        return BigInteger.valueOf(CompareToBuilder.reflectionCompare(lhs, rhs, testTransients)).signum();\n+    }\n+    \n+    public void testAppendSuper() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().appendSuper(0).append(o2, o1).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o1).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o2).toComparison() < 0);\n+        \n+        assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o2).toComparison() > 0);\n+    }\n+    \n+    public void testObject() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(4);\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0);\n+        o2.setA(5);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0);\n+    }\n+\n+    public void testObjectEx2() {\n+        TestObject o1 = new TestObject(4);\n+        Object o2 = new Object();\n+        try {\n+            new CompareToBuilder().append(o1, o2);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testObjectComparator() {\n+        String o1 = \"Fred\";\n+        String o2 = \"Fred\";\n+        assertTrue(new CompareToBuilder().append(o1, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        o2 = \"FRED\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        o2 = \"FREDA\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);\n+    }\n+    \n+    public void testObjectComparatorNull() {\n+        String o1 = \"Fred\";\n+        String o2 = \"Fred\";\n+        assertTrue(new CompareToBuilder().append(o1, o1, null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() == 0);\n+        o2 = \"Zebra\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, null).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null, null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1, null).toComparison() < 0);\n+    }\n+\n+    public void testLong() {\n+        long o1 = 1L;\n+        long o2 = 2L;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Long.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Long.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Long.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Long.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testInt() {\n+        int o1 = 1;\n+        int o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Integer.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Integer.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Integer.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Integer.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testShort() {\n+        short o1 = 1;\n+        short o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Short.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Short.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Short.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Short.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testChar() {\n+        char o1 = 1;\n+        char o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Character.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Character.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Character.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Character.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testByte() {\n+        byte o1 = 1;\n+        byte o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Byte.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Byte.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Byte.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Byte.MIN_VALUE, o1).toComparison() < 0);\n+    }\n+\n+    public void testDouble() {\n+        double o1 = 1;\n+        double o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Double.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Double.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Double.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Double.MIN_VALUE, o1).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Double.NaN, Double.NaN).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(Double.NaN, Double.MAX_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Double.POSITIVE_INFINITY, Double.MAX_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Double.NEGATIVE_INFINITY, Double.MIN_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o1, Double.NaN).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Double.NaN, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);\n+    }\n+\n+    public void testFloat() {\n+        float o1 = 1;\n+        float o2 = 2;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Float.MAX_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Float.MAX_VALUE, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o1, Float.MIN_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Float.MIN_VALUE, o1).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Float.NaN, Float.NaN).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(Float.NaN, Float.MAX_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Float.POSITIVE_INFINITY, Float.MAX_VALUE).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(Float.NEGATIVE_INFINITY, Float.MIN_VALUE).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o1, Float.NaN).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(Float.NaN, o1).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);\n+    }\n+\n+    public void testBoolean() {\n+        boolean o1 = true;\n+        boolean o2 = false;\n+        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o2, o2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() < 0);\n+    }\n+\n+    public void testObjectArray() {\n+        TestObject[] obj1 = new TestObject[2];\n+        obj1[0] = new TestObject(4);\n+        obj1[1] = new TestObject(5);\n+        TestObject[] obj2 = new TestObject[2];\n+        obj2[0] = new TestObject(4);\n+        obj2[1] = new TestObject(5);\n+        TestObject[] obj3 = new TestObject[3];\n+        obj3[0] = new TestObject(4);\n+        obj3[1] = new TestObject(5);\n+        obj3[2] = new TestObject(6);\n+        \n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+        \n+        obj1[1] = new TestObject(7);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testLongArray() {\n+        long[] obj1 = new long[2];\n+        obj1[0] = 5L;\n+        obj1[1] = 6L;\n+        long[] obj2 = new long[2];\n+        obj2[0] = 5L;\n+        obj2[1] = 6L;\n+        long[] obj3 = new long[3];\n+        obj3[0] = 5L;\n+        obj3[1] = 6L;\n+        obj3[2] = 7L;\n+        \n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testIntArray() {\n+        int[] obj1 = new int[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        int[] obj2 = new int[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        int[] obj3 = new int[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((int[]) null, (int[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testShortArray() {\n+        short[] obj1 = new short[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        short[] obj2 = new short[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        short[] obj3 = new short[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((short[]) null, (short[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testCharArray() {\n+        char[] obj1 = new char[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        char[] obj2 = new char[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        char[] obj3 = new char[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testByteArray() {\n+        byte[] obj1 = new byte[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        byte[] obj2 = new byte[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        byte[] obj3 = new byte[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testDoubleArray() {\n+        double[] obj1 = new double[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        double[] obj2 = new double[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        double[] obj3 = new double[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((double[]) null, (double[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testFloatArray() {\n+        float[] obj1 = new float[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        float[] obj2 = new float[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        float[] obj3 = new float[3];\n+        obj3[0] = 5;\n+        obj3[1] = 6;\n+        obj3[2] = 7;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((float[]) null, (float[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testBooleanArray() {\n+        boolean[] obj1 = new boolean[2];\n+        obj1[0] = true;\n+        obj1[1] = false;\n+        boolean[] obj2 = new boolean[2];\n+        obj2[0] = true;\n+        obj2[1] = false;\n+        boolean[] obj3 = new boolean[3];\n+        obj3[0] = true;\n+        obj3[1] = false;\n+        obj3[2] = true;\n+\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        obj1[1] = true;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n+    }\n+\n+    public void testMultiLongArray() {\n+        long[][] array1 = new long[2][2];\n+        long[][] array2 = new long[2][2];\n+        long[][] array3 = new long[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+                array3[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiIntArray() {\n+        int[][] array1 = new int[2][2];\n+        int[][] array2 = new int[2][2];\n+        int[][] array3 = new int[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+                array3[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiShortArray() {\n+        short[][] array1 = new short[2][2];\n+        short[][] array2 = new short[2][2];\n+        short[][] array3 = new short[2][3];\n+        for (short i = 0; i < array1.length; ++i) {\n+            for (short j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (short)((i + 1) * (j + 1));\n+                array2[i][j] = (short)((i + 1) * (j + 1));\n+                array3[i][j] = (short)((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiCharArray() {\n+        char[][] array1 = new char[2][2];\n+        char[][] array2 = new char[2][2];\n+        char[][] array3 = new char[2][3];\n+        for (short i = 0; i < array1.length; ++i) {\n+            for (short j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (char)((i + 1) * (j + 1));\n+                array2[i][j] = (char)((i + 1) * (j + 1));\n+                array3[i][j] = (char)((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiByteArray() {\n+        byte[][] array1 = new byte[2][2];\n+        byte[][] array2 = new byte[2][2];\n+        byte[][] array3 = new byte[2][3];\n+        for (byte i = 0; i < array1.length; ++i) {\n+            for (byte j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (byte)((i + 1) * (j + 1));\n+                array2[i][j] = (byte)((i + 1) * (j + 1));\n+                array3[i][j] = (byte)((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 127;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+    \n+    public void testMultiFloatArray() {\n+        float[][] array1 = new float[2][2];\n+        float[][] array2 = new float[2][2];\n+        float[][] array3 = new float[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = ((i + 1) * (j + 1));\n+                array2[i][j] = ((i + 1) * (j + 1));\n+                array3[i][j] = ((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 127;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiDoubleArray() {\n+        double[][] array1 = new double[2][2];\n+        double[][] array2 = new double[2][2];\n+        double[][] array3 = new double[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = ((i + 1) * (j + 1));\n+                array2[i][j] = ((i + 1) * (j + 1));\n+                array3[i][j] = ((i + 1) * (j + 1));\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 127;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMultiBooleanArray() {\n+        boolean[][] array1 = new boolean[2][2];\n+        boolean[][] array2 = new boolean[2][2];\n+        boolean[][] array3 = new boolean[2][3];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = ((i == 1) ^ (j == 1));\n+                array2[i][j] = ((i == 1) ^ (j == 1));\n+                array3[i][j] = ((i == 1) ^ (j == 1));\n+            }\n+        }\n+        array3[1][2] = false;\n+        array3[1][2] = false;\n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = true;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testRaggedArray() {\n+        long array1[][] = new long[2][];\n+        long array2[][] = new long[2][];\n+        long array3[][] = new long[3][];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            array3[i] = new long[3];\n+            for (int j = 0; j < array1[i].length; ++j) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+                array3[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        array3[1][2] = 100;\n+        array3[1][2] = 100;\n+        \n+        \n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        array1[1][1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testMixedArray() {\n+        Object array1[] = new Object[2];\n+        Object array2[] = new Object[2];\n+        Object array3[] = new Object[2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            array3[i] = new long[3];\n+            for (int j = 0; j < 2; ++j) {\n+                ((long[]) array1[i])[j] = (i + 1) * (j + 1);\n+                ((long[]) array2[i])[j] = (i + 1) * (j + 1);\n+                ((long[]) array3[i])[j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        ((long[]) array3[0])[2] = 1;\n+        ((long[]) array3[1])[2] = 1;\n+        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);\n+        ((long[]) array1[1])[1] = 200;\n+        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);\n+    }\n+\n+    public void testObjectArrayHiddenByObject() {\n+        TestObject[] array1 = new TestObject[2];\n+        array1[0] = new TestObject(4);\n+        array1[1] = new TestObject(5);\n+        TestObject[] array2 = new TestObject[2];\n+        array2[0] = new TestObject(4);\n+        array2[1] = new TestObject(5);\n+        TestObject[] array3 = new TestObject[3];\n+        array3[0] = new TestObject(4);\n+        array3[1] = new TestObject(5);\n+        array3[2] = new TestObject(6);\n+        \n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        \n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = new TestObject(7);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testLongArrayHiddenByObject() {\n+        long[] array1 = new long[2];\n+        array1[0] = 5L;\n+        array1[1] = 6L;\n+        long[] array2 = new long[2];\n+        array2[0] = 5L;\n+        array2[1] = 6L;\n+        long[] array3 = new long[3];\n+        array3[0] = 5L;\n+        array3[1] = 6L;\n+        array3[2] = 7L;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testIntArrayHiddenByObject() {\n+        int[] array1 = new int[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        int[] array2 = new int[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        int[] array3 = new int[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testShortArrayHiddenByObject() {\n+        short[] array1 = new short[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        short[] array2 = new short[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        short[] array3 = new short[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testCharArrayHiddenByObject() {\n+        char[] array1 = new char[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        char[] array2 = new char[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        char[] array3 = new char[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testByteArrayHiddenByObject() {\n+        byte[] array1 = new byte[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        byte[] array2 = new byte[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        byte[] array3 = new byte[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testDoubleArrayHiddenByObject() {\n+        double[] array1 = new double[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        double[] array2 = new double[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        double[] array3 = new double[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testFloatArrayHiddenByObject() {\n+        float[] array1 = new float[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        float[] array2 = new float[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        float[] array3 = new float[3];\n+        array3[0] = 5;\n+        array3[1] = 6;\n+        array3[2] = 7;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = 7;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+\n+    public void testBooleanArrayHiddenByObject() {\n+        boolean[] array1 = new boolean[2];\n+        array1[0] = true;\n+        array1[1] = false;\n+        boolean[] array2 = new boolean[2];\n+        array2[0] = true;\n+        array2[1] = false;\n+        boolean[] array3 = new boolean[3];\n+        array3[0] = true;\n+        array3[1] = false;\n+        array3[2] = true;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        Object obj3 = array3;\n+        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n+\n+        array1[1] = true;\n+        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n+  \n+ }\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/DefaultToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.DefaultToStringStyleTest}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class DefaultToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n+    \n+    public DefaultToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DefaultToStringStyleTest.class);\n+        suite.setName(\"DefaultToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[a=<Integer>]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new HashMap(), false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", new HashMap(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/EqualsBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.EqualsBuilder}.\n+ *\n+ * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Maarten Coene\n+ * @version $Id$\n+ */\n+public class EqualsBuilderTest extends TestCase {\n+\n+    public EqualsBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EqualsBuilderTest.class);\n+        suite.setName(\"EqualsBuilder Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    static class TestObject {\n+        private int a;\n+        public TestObject() {\n+        }\n+        public TestObject(int a) {\n+            this.a = a;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestObject)) {\n+                return false;\n+            }\n+            TestObject rhs = (TestObject) o;\n+            return (a == rhs.a);\n+        }\n+\n+        public void setA(int a) {\n+            this.a = a;\n+        }\n+\n+        public int getA() {\n+            return a;\n+        }\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b) {\n+            super(a);\n+            this.b = b;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestSubObject)) {\n+                return false;\n+            }\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+\n+        public void setB(int b) {\n+            this.b = b;\n+        }\n+\n+        public int getB() {\n+            return b;\n+        }\n+    }\n+    \n+    static class TestEmptySubObject extends TestObject {\n+        public TestEmptySubObject(int a) {\n+            super(a);\n+        }\n+    }\n+\n+    static class TestTSubObject extends TestObject {\n+        private transient int t;\n+        public TestTSubObject(int a, int t) {\n+            super(a);\n+            this.t = t;\n+        }\n+    }\n+\n+    static class TestTTSubObject extends TestTSubObject {\n+        private transient int tt;\n+        public TestTTSubObject(int a, int t, int tt) {\n+            super(a, t);\n+            this.tt = tt;\n+        }\n+    }\n+\n+    static class TestTTLeafObject extends TestTTSubObject {\n+        private int leafValue;\n+        public TestTTLeafObject(int a, int t, int tt, int leafValue) {\n+            super(a, t, tt);\n+            this.leafValue = leafValue;\n+        }\n+    }\n+\n+    static class TestTSubObject2 extends TestObject {\n+        private transient int t;\n+        public TestTSubObject2(int a, int t) {\n+            super(a);\n+        }\n+        public int getT() {\n+            return t;\n+        }\n+        public void setT(int t) {\n+            this.t = t;\n+        }\n+    }\n+\n+    public void testReflectionEquals() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertTrue(EqualsBuilder.reflectionEquals(o1, o1));\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, o2));\n+        o2.setA(4);\n+        assertTrue(EqualsBuilder.reflectionEquals(o1, o2));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, this));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, null));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, o2));\n+        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));\n+    }\n+    \n+    public void testReflectionHierarchyEquals() {\n+        testReflectionHierarchyEquals(false);\n+        testReflectionHierarchyEquals(true);\n+        // Transients\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+    }\n+\n+    public void testReflectionHierarchyEquals(boolean testTransients) {\n+        TestObject to1 = new TestObject(4);\n+        TestObject to1Bis = new TestObject(4);\n+        TestObject to1Ter = new TestObject(4);\n+        TestObject to2 = new TestObject(5);\n+        TestEmptySubObject teso = new TestEmptySubObject(4);\n+        TestTSubObject ttso = new TestTSubObject(4, 1);\n+        TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);\n+        TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);\n+        TestSubObject tso1 = new TestSubObject(1, 4);\n+        TestSubObject tso1bis = new TestSubObject(1, 4);\n+        TestSubObject tso1ter = new TestSubObject(1, 4);\n+        TestSubObject tso2 = new TestSubObject(2, 5);\n+\n+        testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);\n+        testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);\n+\n+        // More sanity checks:\n+\n+        // same values\n+        assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));\n+        // same super values, diff sub values\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));\n+        // diff super values, same sub values\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));\n+\n+        // mix super and sub types: equals\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients));\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert\n+\n+        // mix super and sub types: NOT equals\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(to1, ttlo));\n+        assertTrue(!EqualsBuilder.reflectionEquals(tso1, this));\n+    }\n+\n+    /**\n+     * Equivalence relationship tests inspired by \"Effective Java\":\n+     * <ul>\n+     * <li>reflection</li>\n+     * <li>symmetry</li>\n+     * <li>transitive</li>\n+     * <li>consistency</li>\n+     * <li>non-null reference</li>\n+     * </ul>\n+     * @param to a TestObject\n+     * @param toBis a TestObject, equal to to and toTer\n+     * @param toTer Left hand side, equal to to and toBis\n+     * @param to2 a different TestObject\n+     * @param oToChange a TestObject that will be changed\n+     */\n+    public void testReflectionEqualsEquivalenceRelationship(\n+        TestObject to,\n+        TestObject toBis,\n+        TestObject toTer,\n+        TestObject to2,\n+        TestObject oToChange,\n+        boolean testTransients) {\n+\n+        // reflection test\n+        assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));\n+\n+        // symmetry test\n+        assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));\n+\n+        // transitive test\n+        assertTrue(\n+            EqualsBuilder.reflectionEquals(to, toBis, testTransients)\n+                && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)\n+                && EqualsBuilder.reflectionEquals(to, toTer, testTransients));\n+\n+        // consistency test\n+        oToChange.setA(to.getA());\n+        if (oToChange instanceof TestSubObject) {\n+            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB());\n+        }\n+        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        oToChange.setA(to.getA() + 1);\n+        if (oToChange instanceof TestSubObject) {\n+            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1);\n+        }\n+        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+\n+        // non-null reference test\n+        assertTrue(!EqualsBuilder.reflectionEquals(to, null, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(to2, null, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, to, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, to2, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null, testTransients));\n+    }\n+\n+    public void testSuper() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertEquals(true, new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals());\n+    }\n+\n+    public void testObject() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        o2.setA(4);\n+        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());\n+\n+        assertTrue(!new EqualsBuilder().append(o1, this).isEquals());\n+        \n+        assertTrue(!new EqualsBuilder().append(o1, null).isEquals());\n+        assertTrue(!new EqualsBuilder().append(null, o2).isEquals());\n+        assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals());\n+    }\n+\n+    public void testLong() {\n+        long o1 = 1L;\n+        long o2 = 2L;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testInt() {\n+        int o1 = 1;\n+        int o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testShort() {\n+        short o1 = 1;\n+        short o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testChar() {\n+        char o1 = 1;\n+        char o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testByte() {\n+        byte o1 = 1;\n+        byte o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testDouble() {\n+        double o1 = 1;\n+        double o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());\n+    }\n+\n+    public void testFloat() {\n+        float o1 = 1;\n+        float o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());\n+    }\n+\n+    public void testAccessors() {\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        assertTrue(equalsBuilder.isEquals());\n+        equalsBuilder.setEquals(true);\n+        assertTrue(equalsBuilder.isEquals());\n+        equalsBuilder.setEquals(false);\n+        assertFalse(equalsBuilder.isEquals());\n+    }\n+    \n+    public void testBoolean() {\n+        boolean o1 = true;\n+        boolean o2 = false;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    public void testObjectArray() {\n+        TestObject[] obj1 = new TestObject[3];\n+        obj1[0] = new TestObject(4);\n+        obj1[1] = new TestObject(5);\n+        obj1[2] = null;\n+        TestObject[] obj2 = new TestObject[3];\n+        obj2[0] = new TestObject(4);\n+        obj2[1] = new TestObject(5);\n+        obj2[2] = null;\n+        \n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj2, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1].setA(6);\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1].setA(5);\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[2] = obj1[1];\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[2] = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+                       \n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testLongArray() {\n+        long[] obj1 = new long[2];\n+        obj1[0] = 5L;\n+        obj1[1] = 6L;\n+        long[] obj2 = new long[2];\n+        obj2[0] = 5L;\n+        obj2[1] = 6L;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testIntArray() {\n+        int[] obj1 = new int[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        int[] obj2 = new int[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testShortArray() {\n+        short[] obj1 = new short[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        short[] obj2 = new short[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testCharArray() {\n+        char[] obj1 = new char[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        char[] obj2 = new char[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testByteArray() {\n+        byte[] obj1 = new byte[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        byte[] obj2 = new byte[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testDoubleArray() {\n+        double[] obj1 = new double[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        double[] obj2 = new double[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testFloatArray() {\n+        float[] obj1 = new float[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        float[] obj2 = new float[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testBooleanArray() {\n+        boolean[] obj1 = new boolean[2];\n+        obj1[0] = true;\n+        obj1[1] = false;\n+        boolean[] obj2 = new boolean[2];\n+        obj2[0] = true;\n+        obj2[1] = false;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = true;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testMultiLongArray() {\n+        long[][] array1 = new long[2][2];\n+        long[][] array2 = new long[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiIntArray() {\n+        int[][] array1 = new int[2][2];\n+        int[][] array2 = new int[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiShortArray() {\n+        short[][] array1 = new short[2][2];\n+        short[][] array2 = new short[2][2];\n+        for (short i = 0; i < array1.length; ++i) {\n+            for (short j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiCharArray() {\n+        char[][] array1 = new char[2][2];\n+        char[][] array2 = new char[2][2];\n+        for (char i = 0; i < array1.length; ++i) {\n+            for (char j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiByteArray() {\n+        byte[][] array1 = new byte[2][2];\n+        byte[][] array2 = new byte[2][2];\n+        for (byte i = 0; i < array1.length; ++i) {\n+            for (byte j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+    public void testMultiFloatArray() {\n+        float[][] array1 = new float[2][2];\n+        float[][] array2 = new float[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiDoubleArray() {\n+        double[][] array1 = new double[2][2];\n+        double[][] array2 = new double[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMultiBooleanArray() {\n+        boolean[][] array1 = new boolean[2][2];\n+        boolean[][] array2 = new boolean[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i == 1) || (j == 1);\n+                array2[i][j] = (i == 1) || (j == 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = false;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+        \n+        // compare 1 dim to 2.\n+        boolean[] array3 = new boolean[]{true, true};\n+        assertFalse(new EqualsBuilder().append(array1, array3).isEquals());\n+        assertFalse(new EqualsBuilder().append(array3, array1).isEquals());\n+        assertFalse(new EqualsBuilder().append(array2, array3).isEquals());\n+        assertFalse(new EqualsBuilder().append(array3, array2).isEquals());\n+    }\n+\n+    public void testRaggedArray() {\n+        long array1[][] = new long[2][];\n+        long array2[][] = new long[2][];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            for (int j = 0; j < array1[i].length; ++j) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testMixedArray() {\n+        Object array1[] = new Object[2];\n+        Object array2[] = new Object[2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            for (int j = 0; j < 2; ++j) {\n+                ((long[]) array1[i])[j] = (i + 1) * (j + 1);\n+                ((long[]) array2[i])[j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        ((long[]) array1[1])[1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    public void testObjectArrayHiddenByObject() {\n+        TestObject[] array1 = new TestObject[2];\n+        array1[0] = new TestObject(4);\n+        array1[1] = new TestObject(5);\n+        TestObject[] array2 = new TestObject[2];\n+        array2[0] = new TestObject(4);\n+        array2[1] = new TestObject(5);\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1].setA(6);\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testLongArrayHiddenByObject() {\n+        long[] array1 = new long[2];\n+        array1[0] = 5L;\n+        array1[1] = 6L;\n+        long[] array2 = new long[2];\n+        array2[0] = 5L;\n+        array2[1] = 6L;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testIntArrayHiddenByObject() {\n+        int[] array1 = new int[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        int[] array2 = new int[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testShortArrayHiddenByObject() {\n+        short[] array1 = new short[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        short[] array2 = new short[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testCharArrayHiddenByObject() {\n+        char[] array1 = new char[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        char[] array2 = new char[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testByteArrayHiddenByObject() {\n+        byte[] array1 = new byte[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        byte[] array2 = new byte[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testDoubleArrayHiddenByObject() {\n+        double[] array1 = new double[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        double[] array2 = new double[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testFloatArrayHiddenByObject() {\n+        float[] array1 = new float[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        float[] array2 = new float[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    public void testBooleanArrayHiddenByObject() {\n+        boolean[] array1 = new boolean[2];\n+        array1[0] = true;\n+        array1[1] = false;\n+        boolean[] array2 = new boolean[2];\n+        array2[0] = true;\n+        array2[1] = false;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = true;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+    \n+    public static class TestACanEqualB {\n+        private int a;\n+\n+        public TestACanEqualB(int a) {\n+            this.a = a;\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == this)\n+                return true;\n+            if (o instanceof TestACanEqualB)\n+                return this.a == ((TestACanEqualB) o).getA();\n+            if (o instanceof TestBCanEqualA)\n+                return this.a == ((TestBCanEqualA) o).getB();\n+            return false;\n+        }\n+\n+        public int getA() {\n+            return this.a;\n+        }\n+    }\n+\n+    public static class TestBCanEqualA {\n+        private int b;\n+\n+        public TestBCanEqualA(int b) {\n+            this.b = b;\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == this)\n+                return true;\n+            if (o instanceof TestACanEqualB)\n+                return this.b == ((TestACanEqualB) o).getA();\n+            if (o instanceof TestBCanEqualA)\n+                return this.b == ((TestBCanEqualA) o).getB();\n+            return false;\n+        }\n+\n+        public int getB() {\n+            return this.b;\n+        }\n+    }\n+    \n+    /**\n+     * Tests two instances of classes that can be equal and that are not \"related\". The two classes are not subclasses\n+     * of each other and do not share a parent aside from Object.\n+     * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069\n+     */\n+    public void testUnrelatedClasses() {\n+        Object[] x = new Object[]{new TestACanEqualB(1)};\n+        Object[] y = new Object[]{new TestBCanEqualA(1)};\n+\n+        // sanity checks:\n+        assertTrue(Arrays.equals(x, x));\n+        assertTrue(Arrays.equals(y, y));\n+        assertTrue(Arrays.equals(x, y));\n+        assertTrue(Arrays.equals(y, x));\n+        // real tests:\n+        assertTrue(x[0].equals(x[0]));\n+        assertTrue(y[0].equals(y[0]));\n+        assertTrue(x[0].equals(y[0]));\n+        assertTrue(y[0].equals(x[0]));\n+        assertTrue(new EqualsBuilder().append(x, x).isEquals());\n+        assertTrue(new EqualsBuilder().append(y, y).isEquals());\n+        assertTrue(new EqualsBuilder().append(x, y).isEquals());\n+        assertTrue(new EqualsBuilder().append(y, x).isEquals());\n+    }\n+    \n+    /**\n+     * Test from http://issues.apache.org/bugzilla/show_bug.cgi?id=33067\n+     */\n+    public void testNpeForNullElement() {\n+        Object[] x1 = new Object[] { new Integer(1), null, new Integer(3) };\n+        Object[] x2 = new Object[] { new Integer(1), new Integer(2), new Integer(3) };\n+\n+        // causes an NPE in 2.0 according to:\n+        // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067\n+        new EqualsBuilder().append(x1, x2);\n+    }\n+\n+    public void testReflectionEqualsExcludeFields() throws Exception {\n+        TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);\n+        TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);\n+\n+        // not equal when including all fields\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2));\n+\n+        // doesn't barf on null, empty array, or non-existent field, but still tests as not equal\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, (String[]) null));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {}));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"xxx\"}));\n+\n+        // not equal if only one of the differing fields excluded\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"two\"}));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"three\"}));\n+\n+        // equal if both differing fields excluded\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"two\", \"three\"}));\n+\n+        // still equal as long as both differing fields are among excluded\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"one\", \"two\", \"three\"}));\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"one\", \"two\", \"three\", \"xxx\"}));\n+    }\n+\n+    static class TestObjectWithMultipleFields {\n+        private TestObject one;\n+        private TestObject two;\n+        private TestObject three;\n+\n+        public TestObjectWithMultipleFields(int one, int two, int three) {\n+            this.one = new TestObject(one);\n+            this.two = new TestObject(two);\n+            this.three = new TestObject(three);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/HashCodeBuilderAndEqualsBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests {@link org.apache.commons.lang.builder.HashCodeBuilder} and\n+ * {@link org.apache.commons.lang.builder.EqualsBuilderTest} to insure that equal\n+ * objects must have equal hash codes.\n+ * \n+ * @author Gary Gregory\n+ * @version $Id$\n+ */\n+public class HashCodeBuilderAndEqualsBuilderTest extends TestCase {\n+\n+    /**\n+     * Constructor for HashCodeBuilderAndEqualsBuilderTest.\n+     * @param name\n+     */\n+    public HashCodeBuilderAndEqualsBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(HashCodeBuilderAndEqualsBuilderTest.class);\n+        suite.setName(\"HashCodeBuilderAndEqualsBuilder Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testInteger(boolean testTransients) {\n+        Integer i1 = new Integer(12345);\n+        Integer i2 = new Integer(12345);\n+        assertEqualsAndHashCodeContract(i1, i2, testTransients);\n+    }\n+\n+    public void testInteger() {\n+        testInteger(false);\n+    }\n+\n+    public void testIntegerWithTransients() {\n+        testInteger(true);\n+    }\n+\n+    public void testFixture() {\n+        testFixture(false);\n+    }\n+\n+    public void testFixtureWithTransients() {\n+        testFixture(true);\n+    }\n+\n+    public void testFixture(boolean testTransients) {\n+        assertEqualsAndHashCodeContract(new TestFixture(2, 'c', \"Test\", (short) 2), new TestFixture(2, 'c', \"Test\", (short) 2), testTransients);\n+        assertEqualsAndHashCodeContract(\n+            new AllTransientFixture(2, 'c', \"Test\", (short) 2),\n+            new AllTransientFixture(2, 'c', \"Test\", (short) 2),\n+            testTransients);\n+        assertEqualsAndHashCodeContract(\n+            new SubTestFixture(2, 'c', \"Test\", (short) 2, \"Same\"),\n+            new SubTestFixture(2, 'c', \"Test\", (short) 2, \"Same\"),\n+            testTransients);\n+        assertEqualsAndHashCodeContract(\n+            new SubAllTransientFixture(2, 'c', \"Test\", (short) 2, \"Same\"),\n+            new SubAllTransientFixture(2, 'c', \"Test\", (short) 2, \"Same\"),\n+            testTransients);\n+    }\n+\n+    /**\n+     * Asserts that if <code>lhs</code> equals <code>rhs</code> \n+     * then their hash codes MUST be identical.\n+     * \n+     * @param lhs The Left-Hand-Side of the equals test\n+     * @param rhs The Right-Hand-Side of the equals test\n+     * @param testTransients wether to test transient fields\n+     */\n+    public void assertEqualsAndHashCodeContract(Object lhs, Object rhs, boolean testTransients) {\n+        if (EqualsBuilder.reflectionEquals(lhs, rhs, testTransients)) {\n+            // test a couple of times for consistency.\n+            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n+            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n+            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n+        }\n+    }\n+\n+    static class TestFixture {\n+        int i;\n+        char c;\n+        String string;\n+        short s;\n+\n+        TestFixture(int i, char c, String string, short s) {\n+            this.i = i;\n+            this.c = c;\n+            this.string = string;\n+            this.s = s;\n+        }\n+    }\n+\n+    static class SubTestFixture extends TestFixture {\n+        transient String tString;\n+\n+        SubTestFixture(int i, char c, String string, short s, String tString) {\n+            super(i, c, string, s);\n+            this.tString = tString;\n+        }\n+    }\n+\n+    static class AllTransientFixture {\n+        transient int i;\n+        transient char c;\n+        transient String string;\n+        transient short s;\n+\n+        AllTransientFixture(int i, char c, String string, short s) {\n+            this.i = i;\n+            this.c = c;\n+            this.string = string;\n+            this.s = s;\n+        }\n+    }\n+\n+    static class SubAllTransientFixture extends AllTransientFixture {\n+        transient String tString;\n+\n+        SubAllTransientFixture(int i, char c, String string, short s, String tString) {\n+            super(i, c, string, s);\n+            this.tString = tString;\n+        }\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/HashCodeBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import org.apache.commons.lang.builder.ToStringBuilderTest.ReflectionTestCycleA;\n+import org.apache.commons.lang.builder.ToStringBuilderTest.ReflectionTestCycleB;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.HashCodeBuilder}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class HashCodeBuilderTest extends TestCase {\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleA {\n+        ReflectionTestCycleB b;\n+\n+        public int hashCode() {\n+            return HashCodeBuilder.reflectionHashCode(this);\n+        }\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleB {\n+        ReflectionTestCycleA a;\n+\n+        public int hashCode() {\n+            return HashCodeBuilder.reflectionHashCode(this);\n+        }\n+    }\n+    \n+    public HashCodeBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(HashCodeBuilderTest.class);\n+        suite.setName(\"HashCodeBuilder Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testConstructorEx1() {\n+        try {\n+            new HashCodeBuilder(0, 0);\n+            \n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testConstructorEx2() {\n+        try {\n+            new HashCodeBuilder(2, 2);\n+            \n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    static class TestObject {\n+        private int a;\n+        public TestObject(int a) {\n+            this.a = a;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestObject)) {\n+                return false;\n+            }\n+            TestObject rhs = (TestObject) o;\n+            return (a == rhs.a);\n+        }\n+\n+        public void setA(int a) {\n+            this.a = a;\n+        }\n+\n+        public int getA() {\n+            return a;\n+        }\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        transient private int t;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b, int t) {\n+            super(a);\n+            this.b = b;\n+            this.t = t;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (!(o instanceof TestSubObject)) {\n+                return false;\n+            }\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+    }\n+\n+    public void testReflectionHashCode() {\n+        assertEquals(17 * 37, HashCodeBuilder.reflectionHashCode(new TestObject(0)));\n+        assertEquals(17 * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestObject(123456)));\n+    }\n+\n+    public void testReflectionHierarchyHashCode() {\n+        assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0)));\n+        assertEquals(17 * 37 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0), true));\n+        assertEquals((17 * 37 + 7890) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0)));\n+        assertEquals(((17 * 37 + 7890) * 37 + 0) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0), true));\n+    }\n+\n+    public void testReflectionHierarchyHashCodeEx1() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(0, 0, new TestSubObject(0, 0, 0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHierarchyHashCodeEx2() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(2, 2, new TestSubObject(0, 0, 0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHashCodeEx1() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(0, 0, new TestObject(0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHashCodeEx2() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testReflectionHashCodeEx3() {\n+        try {\n+            HashCodeBuilder.reflectionHashCode(13, 19, null, true);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testSuper() {\n+        Object obj = new Object();\n+        assertEquals(17 * 37 + (19 * 41 + obj.hashCode()), new HashCodeBuilder(17, 37).appendSuper(\n+            new HashCodeBuilder(19, 41).append(obj).toHashCode()\n+        ).toHashCode());\n+    }\n+\n+    public void testObject() {\n+        Object obj = null;\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj = new Object();\n+        assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode());\n+        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append((long) 123456789L).toHashCode());\n+    }\n+\n+    public void testInt() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode());\n+        assertEquals(17 * 37 + 123456, new HashCodeBuilder(17, 37).append((int) 123456).toHashCode());\n+    }\n+\n+    public void testShort() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short) 0).toHashCode());\n+        assertEquals(17 * 37 + 12345, new HashCodeBuilder(17, 37).append((short) 12345).toHashCode());\n+    }\n+\n+    public void testChar() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char) 0).toHashCode());\n+        assertEquals(17 * 37 + 1234, new HashCodeBuilder(17, 37).append((char) 1234).toHashCode());\n+    }\n+\n+    public void testByte() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte) 0).toHashCode());\n+        assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((byte) 123).toHashCode());\n+    }\n+\n+    public void testDouble() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode());\n+        double d = 1234567.89;\n+        long l = Double.doubleToLongBits(d);\n+        assertEquals(17 * 37 + (int) (l ^ (l >> 32)), new HashCodeBuilder(17, 37).append(d).toHashCode());\n+    }\n+\n+    public void testFloat() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float) 0f).toHashCode());\n+        float f = 1234.89f;\n+        int i = Float.floatToIntBits(f);\n+        assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode());\n+    }\n+\n+    public void testBoolean() {\n+        assertEquals(17 * 37 + 0, new HashCodeBuilder(17, 37).append(true).toHashCode());\n+        assertEquals(17 * 37 + 1, new HashCodeBuilder(17, 37).append(false).toHashCode());\n+    }\n+\n+    public void testObjectArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());\n+        Object[] obj = new Object[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = new Object();\n+        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = new Object();\n+        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testObjectArrayAsObject() {\n+        Object[] obj = new Object[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = new Object();\n+        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = new Object();\n+        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testLongArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());\n+        long[] obj = new long[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = 5L;\n+        int h1 = (int) (5L ^ (5L >> 32));\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = 6L;\n+        int h2 = (int) (6L ^ (6L >> 32));\n+        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testLongArrayAsObject() {\n+        long[] obj = new long[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = 5L;\n+        int h1 = (int) (5L ^ (5L >> 32));\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = 6L;\n+        int h2 = (int) (6L ^ (6L >> 32));\n+        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testIntArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());\n+        int[] obj = new int[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = 6;\n+        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testIntArrayAsObject() {\n+        int[] obj = new int[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = 6;\n+        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testShortArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());\n+        short[] obj = new short[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = (short) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = (short) 6;\n+        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testShortArrayAsObject() {\n+        short[] obj = new short[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = (short) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = (short) 6;\n+        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testCharArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());\n+        char[] obj = new char[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = (char) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = (char) 6;\n+        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testCharArrayAsObject() {\n+        char[] obj = new char[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = (char) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = (char) 6;\n+        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testByteArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());\n+        byte[] obj = new byte[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = (byte) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = (byte) 6;\n+        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testByteArrayAsObject() {\n+        byte[] obj = new byte[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = (byte) 5;\n+        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = (byte) 6;\n+        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testDoubleArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());\n+        double[] obj = new double[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = 5.4d;\n+        long l1 = Double.doubleToLongBits(5.4d);\n+        int h1 = (int) (l1 ^ (l1 >> 32));\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = 6.3d;\n+        long l2 = Double.doubleToLongBits(6.3d);\n+        int h2 = (int) (l2 ^ (l2 >> 32));\n+        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testDoubleArrayAsObject() {\n+        double[] obj = new double[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = 5.4d;\n+        long l1 = Double.doubleToLongBits(5.4d);\n+        int h1 = (int) (l1 ^ (l1 >> 32));\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = 6.3d;\n+        long l2 = Double.doubleToLongBits(6.3d);\n+        int h2 = (int) (l2 ^ (l2 >> 32));\n+        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testFloatArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());\n+        float[] obj = new float[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = 5.4f;\n+        int h1 = Float.floatToIntBits(5.4f);\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = 6.3f;\n+        int h2 = Float.floatToIntBits(6.3f);\n+        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testFloatArrayAsObject() {\n+        float[] obj = new float[2];\n+        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = 5.4f;\n+        int h1 = Float.floatToIntBits(5.4f);\n+        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = 6.3f;\n+        int h2 = Float.floatToIntBits(6.3f);\n+        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testBooleanArray() {\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());\n+        boolean[] obj = new boolean[2];\n+        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = true;\n+        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = false;\n+        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testBooleanArrayAsObject() {\n+        boolean[] obj = new boolean[2];\n+        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[0] = true;\n+        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        obj[1] = false;\n+        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+    }\n+\n+    public void testBooleanMultiArray() {\n+        boolean[][] obj = new boolean[2][];\n+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = new boolean[0];\n+        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = new boolean[1];\n+        assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0] = new boolean[2];\n+        assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[0][0] = true;\n+        assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        obj[1] = new boolean[1];\n+        assertEquals( (((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+    }\n+\n+    public void testReflectionHashCodeExcludeFields() throws Exception {\n+        TestObjectWithMultipleFields x = new TestObjectWithMultipleFields(1, 2, 3);\n+\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x));\n+\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, (String[]) null));\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {}));\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {\"xxx\"}));\n+\n+        assertEquals(((17 * 37 + 1) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {\"two\"}));\n+        assertEquals(((17 * 37 + 1) * 37 + 2), HashCodeBuilder.reflectionHashCode(x, new String[] {\"three\"}));\n+\n+        assertEquals((17 * 37 + 1), HashCodeBuilder.reflectionHashCode(x, new String[] {\"two\", \"three\"}));\n+\n+        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[] {\"one\", \"two\", \"three\"}));\n+        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[] {\"one\", \"two\", \"three\", \"xxx\"}));\n+    }\n+\n+    static class TestObjectWithMultipleFields {\n+        private int one = 0;\n+        private int two = 0;\n+        private int three = 0;\n+\n+        public TestObjectWithMultipleFields(int one, int two, int three) {\n+            this.one = one;\n+            this.two = two;\n+            this.three = three;\n+        }\n+    }\n+    \n+    /**\n+     * Test Objects pointing to each other.\n+     */\n+    public void testReflectionObjectCycle() {\n+        ReflectionTestCycleA a = new ReflectionTestCycleA();\n+        ReflectionTestCycleB b = new ReflectionTestCycleB();\n+        a.b = b;\n+        b.a = a;\n+        // Causes:\n+        // java.lang.StackOverflowError\n+        // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n+        // at java.lang.Class.getDeclaredFields(Class.java:992)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n+        // at\n+        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n+        // at\n+        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n+        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n+\n+        // a.hashCode();\n+        // b.hashCode();\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/MultiLineToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.MultiLineToStringStyleTest}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class MultiLineToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n+    \n+    public MultiLineToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MultiLineToStringStyleTest.class);\n+        suite.setName(\"MultiLineToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.MULTI_LINE_STYLE);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[\" + SystemUtils.LINE_SEPARATOR + \"]\").toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\").toString());\n+        \n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=hello\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[\" + SystemUtils.LINE_SEPARATOR + \"]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"  a=hello\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=hello\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=3\" + SystemUtils.LINE_SEPARATOR + \"  b=4\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<Integer>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<size=0>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), false).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=[]\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), true).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<size=0>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", new HashMap(), false).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a={}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", new HashMap(), true).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<size=0>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a={}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=3\" + SystemUtils.LINE_SEPARATOR + \"  b=4\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {<null>,5,{3,6}}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {<null>,5,{3,6}}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {1,2,-3,4}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {1,2,-3,4}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {{1,2},<null>,{5}}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  {{1,2},<null>,{5}}\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/NoFieldNamesToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.NoFieldNamesToStringStyleTest}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class NoFieldNamesToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n+    \n+    public NoFieldNamesToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NoFieldNamesToStringStyleTest.class);\n+        suite.setName(\"NoFieldNamesToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[3,4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[<Integer>]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[<size=0>]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), false).toString());\n+        assertEquals(baseStr + \"[[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), true).toString());\n+        assertEquals(baseStr + \"[<size=0>]\", new ToStringBuilder(base).append(\"a\", new HashMap(), false).toString());\n+        assertEquals(baseStr + \"[{}]\", new ToStringBuilder(base).append(\"a\", new HashMap(), true).toString());\n+        assertEquals(baseStr + \"[<size=0>]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[{}]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[3,4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/ReflectionToStringBuilderExcludeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+\n+/**\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">ggregory</a>\n+ * @version $Id$\n+ */\n+public class ReflectionToStringBuilderExcludeTest extends TestCase {\n+\n+    class TestFixture {\n+        private String secretField = SECRET_VALUE;\n+\n+        private String showField = NOT_SECRET_VALUE;\n+    }\n+\n+    private static final String NOT_SECRET_FIELD = \"showField\";\n+\n+    private static final String NOT_SECRET_VALUE = \"Hello World!\";\n+\n+    private static final String SECRET_FIELD = \"secretField\";\n+\n+    private static final String SECRET_VALUE = \"secret value\";\n+\n+    public void test_toStringExclude() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD);\n+        this.validateSecretFieldAbsent(toString);\n+    }\n+\n+    public void test_toStringExcludeArray() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{SECRET_FIELD});\n+        this.validateSecretFieldAbsent(toString);\n+    }\n+\n+    public void test_toStringExcludeArrayWithNull() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null});\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeArrayWithNulls() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null, null});\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeCollection() {\n+        List excludeList = new ArrayList();\n+        excludeList.add(SECRET_FIELD);\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        this.validateSecretFieldAbsent(toString);\n+    }\n+\n+    public void test_toStringExcludeCollectionWithNull() {\n+        List excludeList = new ArrayList();\n+        excludeList.add(null);\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeCollectionWithNulls() {\n+        List excludeList = new ArrayList();\n+        excludeList.add(null);\n+        excludeList.add(null);\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeEmptyArray() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), ArrayUtils.EMPTY_STRING_ARRAY);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeEmptyCollection() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new ArrayList());\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeNullArray() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    public void test_toStringExcludeNullCollection() {\n+        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (Collection) null);\n+        this.validateSecretFieldPresent(toString);\n+    }\n+\n+    private void validateNonSecretField(String toString) {\n+        Assert.assertTrue(toString.indexOf(NOT_SECRET_FIELD) > ArrayUtils.INDEX_NOT_FOUND);\n+        Assert.assertTrue(toString.indexOf(NOT_SECRET_VALUE) > ArrayUtils.INDEX_NOT_FOUND);\n+    }\n+\n+    private void validateSecretFieldAbsent(String toString) {\n+        Assert.assertEquals(ArrayUtils.INDEX_NOT_FOUND, toString.indexOf(SECRET_VALUE));\n+        this.validateNonSecretField(toString);\n+    }\n+\n+    private void validateSecretFieldPresent(String toString) {\n+        Assert.assertTrue(toString.indexOf(SECRET_VALUE) > 0);\n+        this.validateNonSecretField(toString);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/ShortPrefixToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.ToStringStyle.SHORT_PREFIX_STYLE}.\n+ * \n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class ShortPrefixToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = \"Integer\";\n+    \n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.SHORT_PREFIX_STYLE);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[a=<Integer>]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new HashMap(), false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", new HashMap(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/SimpleToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.SimpleToStringStyleTest}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class SimpleToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    \n+    public SimpleToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SimpleToStringStyleTest.class);\n+        suite.setName(\"SimpleToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.SIMPLE_STYLE);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(\"\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(\"\", new ToStringBuilder(base).appendSuper(\"\").toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).appendSuper(\"<null>\").toString());\n+        \n+        assertEquals(\"hello\", new ToStringBuilder(base).appendSuper(\"\").append(\"a\", \"hello\").toString());\n+        assertEquals(\"<null>,hello\", new ToStringBuilder(base).appendSuper(\"<null>\").append(\"a\", \"hello\").toString());\n+        assertEquals(\"hello\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(\"3\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(\"3\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(\"3,4\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(\"<Integer>\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(\"<size=0>\", new ToStringBuilder(base).append(\"a\", new ArrayList(), false).toString());\n+        assertEquals(\"[]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), true).toString());\n+        assertEquals(\"<size=0>\", new ToStringBuilder(base).append(\"a\", new HashMap(), false).toString());\n+        assertEquals(\"{}\", new ToStringBuilder(base).append(\"a\", new HashMap(), true).toString());\n+        assertEquals(\"<size=0>\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(\"{}\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(\"3\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(\"3\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(\"3,4\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(\"{<null>,5,{3,6}}\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"{<null>,5,{3,6}}\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(\"{1,2,-3,4}\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"{1,2,-3,4}\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(\"{{1,2},<null>,{5}}\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"{{1,2},<null>,{5}}\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/StandardToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.builder.ToStringStyle}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class StandardToStringStyleTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = \"Integer\";\n+    \n+    private static final StandardToStringStyle STYLE = new StandardToStringStyle();\n+    \n+    static {\n+        STYLE.setUseShortClassName(true);\n+        STYLE.setUseIdentityHashCode(false);\n+        STYLE.setArrayStart(\"[\");\n+        STYLE.setArraySeparator(\", \");\n+        STYLE.setArrayEnd(\"]\");\n+        STYLE.setNullText(\"%NULL%\");\n+        STYLE.setSizeStartText(\"%SIZE=\");\n+        STYLE.setSizeEndText(\"%\");\n+        STYLE.setSummaryObjectStartText(\"%\");\n+        STYLE.setSummaryObjectEndText(\"%\");\n+    }\n+    \n+    public StandardToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StandardToStringStyleTest.class);\n+        suite.setName(\"StandardToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        ToStringBuilder.setDefaultStyle(STYLE);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        ToStringBuilder.setDefaultStyle(STYLE);\n+    }\n+\n+    //----------------------------------------------------------------\n+    \n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[%NULL%]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[%NULL%,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[%NULL%]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[a=%NULL%]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[a=%Integer%]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[a=%SIZE=0%]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), true).toString());\n+        assertEquals(baseStr + \"[a=%SIZE=0%]\", new ToStringBuilder(base).append(\"a\", new HashMap(), false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", new HashMap(), true).toString());\n+        assertEquals(baseStr + \"[a=%SIZE=0%]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[[%NULL%, 5, [3, 6]]]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[[%NULL%, 5, [3, 6]]]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[[1, 2, -3, 4]]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[[1, 2, -3, 4]]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[[[1, 2], %NULL%, [5]]]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[[[1, 2], %NULL%, [5]]]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.builder.ToStringBuilder}.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author <a href=\"mailto:alex@apache.org\">Alex Chaffee</a>\n+ * @version $Id$\n+ */\n+public class ToStringBuilderTest extends TestCase {\n+\n+    private final Integer base = new Integer(5);\n+    private final String baseStr = base.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(base));\n+    \n+    public ToStringBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ToStringBuilderTest.class);\n+        suite.setName(\"ToStringBuilder Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testConstructorEx1() {\n+        assertEquals(\"<null>\", new ToStringBuilder(null).toString());\n+    }\n+\n+    public void testConstructorEx2() {\n+        assertEquals(\"<null>\", new ToStringBuilder(null, null).toString());\n+        new ToStringBuilder(this.base, null).toString();\n+    }\n+\n+    public void testConstructorEx3() {\n+        assertEquals(\"<null>\", new ToStringBuilder(null, null, null).toString());\n+        new ToStringBuilder(this.base, null, null);\n+        new ToStringBuilder(this.base, ToStringStyle.DEFAULT_STYLE, null);\n+    }\n+\n+    public void testGetSetDefault() {\n+        try {\n+            ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);\n+            assertSame(ToStringStyle.NO_FIELD_NAMES_STYLE, ToStringBuilder.getDefaultStyle());\n+        } finally {\n+            // reset for other tests\n+            ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);\n+        }\n+    }\n+\n+    public void testSetDefaultEx() {\n+        try {\n+            ToStringBuilder.setDefaultStyle(null);\n+            \n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testBlank() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n+    }\n+    \n+    /**\n+     * Test wrapper for int primitive.\n+     */\n+    public void testReflectionInteger() {\n+        assertEquals(baseStr + \"[value=5]\", ToStringBuilder.reflectionToString(base));\n+    }\n+\n+    /**\n+     * Test wrapper for char primitive.\n+     */\n+    public void testReflectionCharacter() {\n+        Character c = new Character('A');\n+        assertEquals(this.toBaseString(c) + \"[value=A]\", ToStringBuilder.reflectionToString(c));\n+    }\n+\n+    /**\n+     * Test wrapper for char boolean.\n+     */\n+    public void testReflectionBoolean() {\n+        Boolean b;\n+        b = Boolean.TRUE;\n+        assertEquals(this.toBaseString(b) + \"[value=true]\", ToStringBuilder.reflectionToString(b));\n+        b = Boolean.FALSE;\n+        assertEquals(this.toBaseString(b) + \"[value=false]\", ToStringBuilder.reflectionToString(b));\n+    }\n+\n+    /**\n+     * Create the same toString() as Object.toString().\n+     * @param o the object to create the string for.\n+     * @return a String in the Object.toString format.\n+     */\n+    private String toBaseString(Object o) {\n+        return o.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(o));\n+    }\n+    \n+    // Reflection Array tests\n+    \n+    //\n+    // Note on the following line of code repeated in the reflection array tests.\n+    //\n+    // assertReflectionArray(\"<null>\", array);\n+    //\n+    // The expected value is not baseStr + \"[<null>]\" since array==null and is typed as Object.\n+    // The null array does not carry array type information.\n+    // If we added a primitive array type constructor and pile of associated methods, \n+    // then type declaring type information could be carried forward. IMHO, null is null.\n+    //\n+    // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com  \n+    //\n+    \n+    public void assertReflectionArray(String expected, Object actual) {\n+        if (actual == null) {\n+            // Until ToStringBuilder supports null objects.\n+            return;\n+        }\n+        assertEquals(expected, ToStringBuilder.reflectionToString(actual));\n+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null));\n+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, true));\n+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, false));\n+    }\n+\n+    public void testReflectionObjectArray() {\n+        Object[] array = new Object[] { null, base, new int[] { 3, 6 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionLongArray() {\n+        long[] array = new long[] { 1, 2, -3, 4 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionIntArray() {\n+        int[] array = new int[] { 1, 2, -3, 4 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionShortArray() {\n+        short[] array = new short[] { 1, 2, -3, 4 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionyteArray() {\n+        byte[] array = new byte[] { 1, 2, -3, 4 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionCharArray() {\n+        char[] array = new char[] { 'A', '2', '_', 'D' };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionDoubleArray() {\n+        double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionFloatArray() {\n+        float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionBooleanArray() {\n+        boolean[] array = new boolean[] { true, false, false };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+    \n+    // Reflection Array Array tests\n+\n+    public void testReflectionFloatArrayArray() {\n+        float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+\n+    public void testReflectionLongArrayArray() {\n+        long[][] array = new long[][] { { 1, 2 }, null, { 5 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionIntArrayArray() {\n+        int[][] array = new int[][] { { 1, 2 }, null, { 5 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionhortArrayArray() {\n+        short[][] array = new short[][] { { 1, 2 }, null, { 5 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionByteArrayArray() {\n+        byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionCharArrayArray() {\n+        char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionDoubleArrayArray() {\n+        double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionBooleanArrayArray() {\n+        boolean[][] array = new boolean[][] { { true, false }, null, { false } };\n+        String baseStr = this.toBaseString(array);\n+        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n+        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n+        array = null;\n+        assertReflectionArray(\"<null>\", array);\n+        this.validateEmptyReflectionRegistry();\n+    }\n+    \n+    // Reflection hierarchy tests\n+\n+    public void testReflectionHierarchyArrayList() {\n+        List base = new ArrayList();\n+        String baseStr = this.toBaseString(base);\n+        assertEquals(baseStr + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\", ToStringBuilder.reflectionToString(base, null, true));\n+        assertEquals(baseStr + \"[size=0]\", ToStringBuilder.reflectionToString(base, null, false));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionHierarchy() {\n+        ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n+        String baseStr = this.toBaseString(baseA);\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false));\n+        assertEquals(baseStr + \"[a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseA, null, true));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, null));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, List.class));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n+        \n+        ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n+        baseStr = this.toBaseString(baseB);\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false));\n+        assertEquals(baseStr + \"[b=b,transientB=t,a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseB, null, true));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, null));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, List.class));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n+        assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    static class ReflectionTestFixtureA {\n+        private char a='a';\n+        private transient char transientA='t';\n+    }\n+\n+    static class ReflectionTestFixtureB extends ReflectionTestFixtureA {\n+        private char b='b';\n+        private transient char transientB='t';\n+    }\n+\n+    public void testInnerClassReflection() {\n+        Outer outer = new Outer();\n+        assertEquals(toBaseString(outer) + \"[inner=\" + toBaseString(outer.inner) + \"[]]\", outer.toString());\n+    }\n+    \n+    static class Outer {\n+        Inner inner = new Inner();\n+        class Inner {\n+            public String toString() {\n+                return ToStringBuilder.reflectionToString(this);\n+            }\n+        }\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+    \n+    // Reflection cycle tests\n+\n+    /**\n+     * Test an array element pointing to its container.\n+     */\n+    public void testReflectionArrayCycle() throws Exception {\n+        Object[] objects = new Object[1];\n+        objects[0] = objects;\n+        assertEquals(\n+            this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    /**\n+     * Test an array element pointing to its container.\n+     */\n+    public void testReflectionArrayCycleLevel2() throws Exception {\n+        Object[] objects = new Object[1];\n+        Object[] objectsLevel2 = new Object[1];\n+        objects[0] = objectsLevel2;\n+        objectsLevel2[0] = (Object) objects;\n+        assertEquals(\n+            this.toBaseString(objects) + \"[{{\" + this.toBaseString(objects) + \"}}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        assertEquals(\n+            this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n+            ToStringBuilder.reflectionToString(objectsLevel2));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    public void testReflectionArrayArrayCycle() throws Exception {\n+        Object[][] objects = new Object[2][2];\n+        objects[0][0] = objects;\n+        objects[0][1] = objects;\n+        objects[1][0] = objects;\n+        objects[1][1] = objects;\n+        String basicToString = this.toBaseString(objects);\n+        assertEquals(\n+            basicToString\n+                + \"[{{\"\n+                + basicToString\n+                + \",\"\n+                + basicToString\n+                + \"},{\"\n+                + basicToString\n+                + \",\"\n+                + basicToString\n+                + \"}}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleA {\n+        ReflectionTestCycleB b;\n+\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class ReflectionTestCycleB {\n+        ReflectionTestCycleA a;\n+\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    /**\n+     * A reflection test fixture.\n+     */\n+    static class SimpleReflectionTestFixture {\n+        Object o;\n+\n+        public SimpleReflectionTestFixture() {\n+        }\n+\n+        public SimpleReflectionTestFixture(Object o) {\n+            this.o = o;\n+        }\n+\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+\n+    private static class SelfInstanceVarReflectionTestFixture {\n+        private SelfInstanceVarReflectionTestFixture typeIsSelf;\n+\n+        public SelfInstanceVarReflectionTestFixture() {\n+            this.typeIsSelf = this;\n+        }\n+\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+      }\n+    \n+    private static class SelfInstanceTwoVarsReflectionTestFixture {\n+        private SelfInstanceTwoVarsReflectionTestFixture typeIsSelf;\n+        private String otherType = \"The Other Type\";\n+\n+        public SelfInstanceTwoVarsReflectionTestFixture() {\n+            this.typeIsSelf = this;\n+        }\n+        \n+        public String getOtherType(){\n+            return this.otherType;\n+        }\n+\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+      }\n+    \n+    \n+    /**\n+     * Test an Object pointing to itself, the simplest test.\n+     * \n+     * @throws Exception\n+     */\n+    public void testSimpleReflectionObjectCycle() throws Exception {\n+        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n+        simple.o = simple;\n+        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());\n+        assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    /**\n+     * Test a class that defines an ivar pointing to itself.\n+     * \n+     * @throws Exception\n+     */\n+    public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n+        SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n+        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());\n+        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n+        this.validateEmptyReflectionRegistry();\n+    }\n+    \n+    /**\n+     * Test a class that defines an ivar pointing to itself.  This test was \n+     * created to show that handling cyclical object resulted in a missing endFieldSeparator call.\n+     * \n+     * @throws Exception\n+     */\n+    public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n+        SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n+        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());\n+        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n+        this.validateEmptyReflectionRegistry();\n+    }\n+    \n+\n+    /**\n+     * Test Objects pointing to each other.\n+     * \n+     * @throws Exception\n+     */\n+    public void testReflectionObjectCycle() throws Exception {\n+        ReflectionTestCycleA a = new ReflectionTestCycleA();\n+        ReflectionTestCycleB b = new ReflectionTestCycleB();\n+        a.b = b;\n+        b.a = a;\n+        assertEquals(\n+            this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n+            a.toString());\n+        this.validateEmptyReflectionRegistry();\n+    }\n+\n+    /**\n+     * Test a nasty combination of arrays and Objects pointing to each other.\n+     * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]\n+     * \n+     * @throws Exception\n+     */\n+    public void testReflectionArrayAndObjectCycle() throws Exception {\n+        Object[] objects = new Object[1];\n+        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n+        objects[0] = (Object) simple;\n+        assertEquals(\n+            this.toBaseString(objects)\n+                + \"[{\"\n+                + this.toBaseString(simple)\n+                + \"[o=\"\n+                + this.toBaseString(objects)\n+                + \"]\"\n+                + \"}]\",\n+            ToStringBuilder.reflectionToString(objects));\n+        assertEquals(\n+            this.toBaseString(simple)\n+                + \"[o={\"\n+                + this.toBaseString(simple)\n+                + \"}]\",\n+            ToStringBuilder.reflectionToString(simple));\n+        this.validateEmptyReflectionRegistry();\n+    }\n+        \n+    void validateEmptyReflectionRegistry() {\n+        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());        \n+    }\n+    //  End: Reflection cycle tests\n+\n+    public void testAppendSuper() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testAppendToString() {\n+        assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendToString(\"Integer@8888[]\").toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendToString(\"Integer@8888[<null>]\").toString());\n+        \n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendToString(\"Integer@8888[]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[<null>,a=hello]\", new ToStringBuilder(base).appendToString(\"Integer@8888[<null>]\").append(\"a\", \"hello\").toString());\n+        assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendToString(null).append(\"a\", \"hello\").toString());\n+    }\n+    \n+    public void testObject() {\n+        Integer i3 = new Integer(3);\n+        Integer i4 = new Integer(4);\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n+        assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", i3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", i3).append(\"b\", i4).toString());\n+        assertEquals(baseStr + \"[a=<Integer>]\", new ToStringBuilder(base).append(\"a\", i3, false).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), false).toString());\n+        assertEquals(baseStr + \"[a=[]]\", new ToStringBuilder(base).append(\"a\", new ArrayList(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", new HashMap(), false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", new HashMap(), true).toString());\n+        assertEquals(baseStr + \"[a=<size=0>]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], false).toString());\n+        assertEquals(baseStr + \"[a={}]\", new ToStringBuilder(base).append(\"a\", (Object) new String[0], true).toString());\n+    }\n+\n+    public void testLong() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(3L).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", 3L).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", 3L).append(\"b\", 4L).toString());\n+    }\n+\n+    public void testInt() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append((int) 3).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", (int) 3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", (int) 3).append(\"b\", (int) 4).toString());\n+    }\n+\n+    public void testShort() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append((short) 3).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", (short) 3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", (short) 3).append(\"b\", (short) 4).toString());\n+    }\n+\n+    public void testChar() {\n+        assertEquals(baseStr + \"[A]\", new ToStringBuilder(base).append((char) 65).toString());\n+        assertEquals(baseStr + \"[a=A]\", new ToStringBuilder(base).append(\"a\", (char) 65).toString());\n+        assertEquals(baseStr + \"[a=A,b=B]\", new ToStringBuilder(base).append(\"a\", (char) 65).append(\"b\", (char) 66).toString());\n+    }\n+\n+    public void testByte() {\n+        assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append((byte) 3).toString());\n+        assertEquals(baseStr + \"[a=3]\", new ToStringBuilder(base).append(\"a\", (byte) 3).toString());\n+        assertEquals(baseStr + \"[a=3,b=4]\", new ToStringBuilder(base).append(\"a\", (byte) 3).append(\"b\", (byte) 4).toString());\n+    }\n+\n+    public void testDouble() {\n+        assertEquals(baseStr + \"[3.2]\", new ToStringBuilder(base).append((double) 3.2).toString());\n+        assertEquals(baseStr + \"[a=3.2]\", new ToStringBuilder(base).append(\"a\", (double) 3.2).toString());\n+        assertEquals(baseStr + \"[a=3.2,b=4.3]\", new ToStringBuilder(base).append(\"a\", (double) 3.2).append(\"b\", (double) 4.3).toString());\n+    }\n+\n+    public void testFloat() {\n+        assertEquals(baseStr + \"[3.2]\", new ToStringBuilder(base).append((float) 3.2).toString());\n+        assertEquals(baseStr + \"[a=3.2]\", new ToStringBuilder(base).append(\"a\", (float) 3.2).toString());\n+        assertEquals(baseStr + \"[a=3.2,b=4.3]\", new ToStringBuilder(base).append(\"a\", (float) 3.2).append(\"b\", (float) 4.3).toString());\n+    }\n+\n+    public void testBoolean() {\n+        assertEquals(baseStr + \"[true]\", new ToStringBuilder(base).append(true).toString());\n+        assertEquals(baseStr + \"[a=true]\", new ToStringBuilder(base).append(\"a\", true).toString());\n+        assertEquals(baseStr + \"[a=true,b=false]\", new ToStringBuilder(base).append(\"a\", true).append(\"b\", false).toString());\n+    }\n+\n+\n+    public void testObjectArray() {\n+        Object[] array = new Object[] {null, base, new int[] {3, 6}};\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArray() {\n+        long[] array = new long[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testIntArray() {\n+        int[] array = new int[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testShortArray() {\n+        short[] array = new short[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+    \n+    public void testByteArray() {\n+        byte[] array = new byte[] {1, 2, -3, 4};\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1,2,-3,4}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testCharArray() {\n+        char[] array = new char[] {'A', '2', '_', 'D'};\n+        assertEquals(baseStr + \"[{A,2,_,D}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{A,2,_,D}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testDoubleArray() {\n+        double[] array = new double[] {1.0, 2.9876, -3.00001, 4.3};\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testFloatArray() {\n+        float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f};\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+    \n+    public void testBooleanArray() {\n+        boolean[] array = new boolean[] {true, false, false};\n+        assertEquals(baseStr + \"[{true,false,false}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{true,false,false}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testLongArrayArray() {\n+        long[][] array = new long[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testIntArrayArray() {\n+        int[][] array = new int[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testShortArrayArray() {\n+        short[][] array = new short[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testByteArrayArray() {\n+        byte[][] array = new byte[][] {{1, 2}, null, {5}};\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testCharArrayArray() {\n+        char[][] array = new char[][] {{'A', 'B'}, null, {'p'}};\n+        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testDoubleArrayArray() {\n+        double[][] array = new double[][] {{1.0, 2.29686}, null, {Double.NaN}};\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testFloatArrayArray() {\n+        float[][] array = new float[][] {{1.0f, 2.29686f}, null, {Float.NaN}};\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testBooleanArrayArray() {\n+        boolean[][] array = new boolean[][] {{true, false}, null, {false}};\n+        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", new ToStringBuilder(base).append((Object) array).toString());\n+        array = null;\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(array).toString());\n+        assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n+    }\n+\n+    public void testSimpleReflectionStatics() {\n+        SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, true, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    public void testReflectionStatics() {\n+        ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]\",\n+            ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    public void testInheritedReflectionStatics() {\n+        InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code> value which includes static fields.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manager, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>Transient fields are not output.</p>\n+     *\n+     * <p>Superclass fields will be appended up to and including the specified superclass. \n+     * A null superclass is treated as <code>java.lang.Object</code>.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public Object toStringWithStatics(Object object, ToStringStyle style, Class reflectUpToClass) {\n+        return ReflectionToStringBuilder.toString(object, style, false, true, reflectUpToClass);\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class ReflectionStaticFieldsFixture {\n+        static final String staticString = \"staticString\";\n+        static final int staticInt = 12345;\n+        static final transient String staticTransientString = \"staticTransientString\";\n+        static final transient int staticTransientInt = 54321;\n+        String instanceString = \"instanceString\";\n+        int instanceInt = 67890;\n+        transient String transientString = \"transientString\";\n+        transient int transientInt = 98765;\n+    }\n+\n+    /**\n+     * Test fixture for ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class SimpleReflectionStaticFieldsFixture {\n+        static final String staticString = \"staticString\";\n+        static final int staticInt = 12345;\n+    }\n+\n+    /**\n+     * Test fixture for ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture {\n+        static final String staticString2 = \"staticString2\";\n+        static final int staticInt2 = 67890;\n+    }\n+\n+    public void testReflectionNull() {\n+        assertEquals(\"<null>\", ReflectionToStringBuilder.toString(null));\n+    }\n+\n+    /* Unit test for #36061\n+    public void testObjectCycle() {\n+        ObjectCycle a = new ObjectCycle();\n+        ObjectCycle b = new ObjectCycle();\n+        a.obj = b;\n+        b.obj = a;\n+       \n+        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n+        assertEquals(expected, a.toString());\n+        validateEmptyReflectionRegistry();\n+    }\n+    \n+    static class ObjectCycle {\n+        Object obj;\n+       \n+        public String toString() {\n+            return new ToStringBuilder(this).append(obj).toString();\n+        }\n+    }\n+    */\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/builder/ToStringStyleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test case for ToStringStyle.\n+ * \n+ * @author Masato Tezuka\n+ * @version $Id$\n+ */\n+public class ToStringStyleTest extends TestCase {\n+\n+    public ToStringStyleTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ToStringStyleTest.class);\n+        suite.setName(\"ToStringStyle Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    private static class ToStringStyleImpl extends ToStringStyle {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSetArrayStart() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setArrayStart(null);\n+        assertEquals(\"\", style.getArrayStart());\n+    }\n+\n+    public void testSetArrayEnd() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setArrayEnd(null);\n+        assertEquals(\"\", style.getArrayEnd());\n+    }\n+\n+    public void testSetArraySeparator() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setArraySeparator(null);\n+        assertEquals(\"\", style.getArraySeparator());\n+    }\n+\n+    public void testSetContentStart() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setContentStart(null);\n+        assertEquals(\"\", style.getContentStart());\n+    }\n+\n+    public void testSetContentEnd() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setContentEnd(null);\n+        assertEquals(\"\", style.getContentEnd());\n+    }\n+\n+    public void testSetFieldNameValueSeparator() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setFieldNameValueSeparator(null);\n+        assertEquals(\"\", style.getFieldNameValueSeparator());\n+    }\n+\n+    public void testSetFieldSeparator() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setFieldSeparator(null);\n+        assertEquals(\"\", style.getFieldSeparator());\n+    }\n+\n+    public void testSetNullText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setNullText(null);\n+        assertEquals(\"\", style.getNullText());\n+    }\n+\n+    public void testSetSizeStartText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setSizeStartText(null);\n+        assertEquals(\"\", style.getSizeStartText());\n+    }\n+\n+    public void testSetSizeEndText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setSizeEndText(null);\n+        assertEquals(\"\", style.getSizeEndText());\n+    }\n+\n+    public void testSetSummaryObjectStartText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setSummaryObjectStartText(null);\n+        assertEquals(\"\", style.getSummaryObjectStartText());\n+    }\n+\n+    public void testSetSummaryObjectEndText() {\n+        ToStringStyle style = new ToStringStyleImpl();\n+        style.setSummaryObjectEndText(null);\n+        assertEquals(\"\", style.getSummaryObjectEndText());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Broken1Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public final class Broken1Enum extends Enum {\n+    public static final Broken1Enum RED = new Broken1Enum(\"Red\");\n+    public static final Broken1Enum GREEN = new Broken1Enum(\"Green\");\n+    public static final Broken1Enum GREENISH = new Broken1Enum(\"Green\");  // duplicate not allowed\n+\n+    private Broken1Enum(String color) {\n+        super(color);\n+    }\n+\n+    public static Broken1Enum getEnum(String color) {\n+        return (Broken1Enum) getEnum(Broken1Enum.class, color);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken1Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken1Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken1Enum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Broken1OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, null class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken1OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken1OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken1OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken1OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken1OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken1OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return null;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken1OperationEnum getEnum(String name) {\n+        return (Broken1OperationEnum) getEnum(Broken1OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken1OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken1OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken1OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Broken2Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public final class Broken2Enum extends Enum {\n+    public static final Broken2Enum RED = new Broken2Enum(\"Red\");\n+    public static final Broken2Enum GREEN = new Broken2Enum(\"Green\");\n+    public static final Broken2Enum BLUE = new Broken2Enum(\"\");  // blank not allowed\n+\n+    private Broken2Enum(String color) {\n+        super(color);\n+    }\n+\n+    public static Broken2Enum getEnum(String color) {\n+        return (Broken2Enum) getEnum(Broken2Enum.class, color);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken2Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken2Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken2Enum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Broken2OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, getEnumClass() not superclass.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken2OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken2OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken2OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken2OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken2OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken2OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return ColorEnum.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken2OperationEnum getEnum(String name) {\n+        return (Broken2OperationEnum) getEnum(Broken2OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken2OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken2OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken2OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Broken3Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public final class Broken3Enum extends Enum {\n+    public static final Broken3Enum RED = new Broken3Enum(\"Red\");\n+    public static final Broken3Enum GREEN = new Broken3Enum(\"Green\");\n+    public static final Broken3Enum BLUE = new Broken3Enum(null);  // null not allowed\n+\n+    private Broken3Enum(String color) {\n+        super(color);\n+    }\n+\n+    public static Broken3Enum getEnum(String color) {\n+        return (Broken3Enum) getEnum(Broken3Enum.class, color);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken3Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken3Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken3Enum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Broken3OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, getEnumClass() is Enum.class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken3OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken3OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken3OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken3OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken3OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken3OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return Enum.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken3OperationEnum getEnum(String name) {\n+        return (Broken3OperationEnum) getEnum(Broken3OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken3OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken3OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken3OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Broken4OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, getEnumClass() is ValuedEnum.class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken4OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken4OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken4OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken4OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken4OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken4OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return ValuedEnum.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken4OperationEnum getEnum(String name) {\n+        return (Broken4OperationEnum) getEnum(Broken4OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken4OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken4OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken4OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Broken5OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, getEnumClass() is not an Enum class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken5OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken5OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken5OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken5OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken5OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken5OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return String.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken5OperationEnum getEnum(String name) {\n+        return (Broken5OperationEnum) getEnum(Broken5OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken5OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken5OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken5OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/ColorEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+\n+public final class ColorEnum extends Enum {\n+    public static final ColorEnum RED = new ColorEnum(\"Red\");\n+    public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+    public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+\n+    private ColorEnum(String color) {\n+        super(color);\n+    }\n+\n+    public static ColorEnum getEnum(String color) {\n+        return (ColorEnum) getEnum(ColorEnum.class, color);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(ColorEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(ColorEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(ColorEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/DummyEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+/**\n+ * Dummy enumeration - no values.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class DummyEnum extends Enum {\n+\n+    private DummyEnum(String name) {\n+        super(name);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/EnumTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.enum;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.ClassUtilsTest;\n+import org.apache.commons.lang.SerializationUtils;\n+\n+/**\n+ * Test cases for the {@link Enum} class.\n+ * \n+ * @author Stephen Colebourne\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+\n+public final class EnumTest extends TestCase {\n+\n+    private static final String ENUM_CLASS_NAME = \"org.apache.commons.lang.enum.ColorEnum\";\n+\n+    public EnumTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EnumTest.class);\n+        suite.setName(\"Enum Tests\");\n+        return suite;\n+    }\n+\n+    public void testName() {\n+        assertEquals(\"Red\", ColorEnum.RED.getName());\n+        assertEquals(\"Green\", ColorEnum.GREEN.getName());\n+        assertEquals(\"Blue\", ColorEnum.BLUE.getName());\n+    }\n+\n+    public void testCompareTo() {\n+        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.BLUE) == 0);\n+        assertTrue(ColorEnum.RED.compareTo(ColorEnum.BLUE) > 0);\n+        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.RED) < 0);\n+        try {\n+            ColorEnum.RED.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+        try {\n+            ColorEnum.RED.compareTo(new Object());\n+            fail();\n+        } catch (ClassCastException ex) {\n+        }\n+    }\n+\n+    public void testEquals() {\n+        assertSame(ColorEnum.RED, ColorEnum.RED);\n+        assertSame(ColorEnum.getEnum(\"Red\"), ColorEnum.RED);\n+        assertEquals(false, ColorEnum.RED.equals(null));\n+        assertEquals(true, ColorEnum.RED.equals(ColorEnum.RED));\n+        assertEquals(true, ColorEnum.RED.equals(ColorEnum.getEnum(\"Red\")));\n+    }\n+\n+    public void testHashCode() {\n+        assertEquals(ColorEnum.RED.hashCode(), ColorEnum.RED.hashCode());\n+        assertEquals(7 + ColorEnum.class.hashCode() + 3 * \"Red\".hashCode(), ColorEnum.RED.hashCode());\n+    }\n+\n+    public void testToString() {\n+        String toString = ColorEnum.RED.toString();\n+        assertEquals(\"ColorEnum[Red]\", toString);\n+        assertSame(toString, ColorEnum.RED.toString());\n+    }\n+\n+    public void testIterator() {\n+        Iterator it = ColorEnum.iterator();\n+        assertSame(ColorEnum.RED, it.next());\n+        assertSame(ColorEnum.GREEN, it.next());\n+        assertSame(ColorEnum.BLUE, it.next());\n+    }\n+\n+    public void testList() {\n+        List list = new ArrayList(ColorEnum.getEnumList());\n+\n+        assertNotNull(list);\n+\n+        assertEquals(list.size(), ColorEnum.getEnumMap().keySet().size());\n+\n+        Iterator it = list.iterator();\n+        assertSame(ColorEnum.RED, it.next());\n+        assertSame(ColorEnum.GREEN, it.next());\n+        assertSame(ColorEnum.BLUE, it.next());\n+    }\n+\n+    public void testMap() {\n+        Map map = new HashMap(ColorEnum.getEnumMap());\n+\n+        assertNotNull(map);\n+        assertTrue(map.containsValue(ColorEnum.RED));\n+        assertTrue(map.containsValue(ColorEnum.GREEN));\n+        assertTrue(map.containsValue(ColorEnum.BLUE));\n+        assertSame(ColorEnum.RED, map.get(\"Red\"));\n+        assertSame(ColorEnum.GREEN, map.get(\"Green\"));\n+        assertSame(ColorEnum.BLUE, map.get(\"Blue\"));\n+        assertEquals(map.keySet().size(), ColorEnum.getEnumList().size());\n+    }\n+\n+    public void testGet() {\n+        assertSame(ColorEnum.RED, ColorEnum.getEnum(\"Red\"));\n+        assertSame(ColorEnum.GREEN, ColorEnum.getEnum(\"Green\"));\n+        assertSame(ColorEnum.BLUE, ColorEnum.getEnum(\"Blue\"));\n+        assertSame(null, ColorEnum.getEnum(\"Pink\"));\n+    }\n+\n+    public void testSerialization() {\n+        int hashCode = ColorEnum.RED.hashCode();\n+        assertSame(ColorEnum.RED, SerializationUtils.clone(ColorEnum.RED));\n+        assertEquals(hashCode, SerializationUtils.clone(ColorEnum.RED).hashCode());\n+        assertSame(ColorEnum.GREEN, SerializationUtils.clone(ColorEnum.GREEN));\n+        assertSame(ColorEnum.BLUE, SerializationUtils.clone(ColorEnum.BLUE));\n+    }\n+\n+    public void testBroken1() {\n+        try {\n+            Broken1Enum.RED.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken2() {\n+        try {\n+            Broken2Enum.RED.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken3() {\n+        try {\n+            Broken3Enum.RED.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken1Operation() {\n+        try {\n+            Broken1OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken2Operation() {\n+        try {\n+            Broken2OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken3Operation() {\n+        try {\n+            Broken3OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken4Operation() {\n+        try {\n+            Broken4OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken5Operation() {\n+        try {\n+            Broken5OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testOperationGet() {\n+        assertSame(OperationEnum.PLUS, OperationEnum.getEnum(\"Plus\"));\n+        assertSame(OperationEnum.MINUS, OperationEnum.getEnum(\"Minus\"));\n+        assertSame(null, OperationEnum.getEnum(\"Pink\"));\n+    }\n+\n+    public void testOperationSerialization() {\n+        assertSame(OperationEnum.PLUS, SerializationUtils.clone(OperationEnum.PLUS));\n+        assertSame(OperationEnum.MINUS, SerializationUtils.clone(OperationEnum.MINUS));\n+    }\n+\n+    public void testOperationToString() {\n+        assertEquals(\"OperationEnum[Plus]\", OperationEnum.PLUS.toString());\n+    }\n+\n+    public void testOperationList() {\n+        List list = OperationEnum.getEnumList();\n+        assertNotNull(list);\n+        assertEquals(2, list.size());\n+        assertEquals(list.size(), OperationEnum.getEnumMap().keySet().size());\n+\n+        Iterator it = list.iterator();\n+        assertSame(OperationEnum.PLUS, it.next());\n+        assertSame(OperationEnum.MINUS, it.next());\n+    }\n+\n+    public void testOperationMap() {\n+        Map map = OperationEnum.getEnumMap();\n+        assertNotNull(map);\n+        assertEquals(map.keySet().size(), OperationEnum.getEnumList().size());\n+\n+        assertTrue(map.containsValue(OperationEnum.PLUS));\n+        assertTrue(map.containsValue(OperationEnum.MINUS));\n+        assertSame(OperationEnum.PLUS, map.get(\"Plus\"));\n+        assertSame(OperationEnum.MINUS, map.get(\"Minus\"));\n+    }\n+\n+    public void testOperationCalculation() {\n+        assertEquals(3, OperationEnum.PLUS.eval(1, 2));\n+        assertEquals(-1, OperationEnum.MINUS.eval(1, 2));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testExtended1Get() {\n+        assertSame(Extended1Enum.ALPHA, Extended1Enum.getEnum(\"Alpha\"));\n+        assertSame(Extended1Enum.BETA, Extended1Enum.getEnum(\"Beta\"));\n+        assertSame(null, Extended1Enum.getEnum(\"Gamma\"));\n+        assertSame(null, Extended1Enum.getEnum(\"Delta\"));\n+    }\n+\n+    public void testExtended2Get() {\n+        assertSame(Extended1Enum.ALPHA, Extended2Enum.ALPHA);\n+        assertSame(Extended1Enum.BETA, Extended2Enum.BETA);\n+\n+        assertSame(Extended2Enum.ALPHA, Extended2Enum.getEnum(\"Alpha\"));\n+        assertSame(Extended2Enum.BETA, Extended2Enum.getEnum(\"Beta\"));\n+        assertSame(Extended2Enum.GAMMA, Extended2Enum.getEnum(\"Gamma\"));\n+        assertSame(null, Extended2Enum.getEnum(\"Delta\"));\n+    }\n+\n+    public void testExtended3Get() {\n+        assertSame(Extended2Enum.ALPHA, Extended3Enum.ALPHA);\n+        assertSame(Extended2Enum.BETA, Extended3Enum.BETA);\n+        assertSame(Extended2Enum.GAMMA, Extended3Enum.GAMMA);\n+\n+        assertSame(Extended3Enum.ALPHA, Extended3Enum.getEnum(\"Alpha\"));\n+        assertSame(Extended3Enum.BETA, Extended3Enum.getEnum(\"Beta\"));\n+        assertSame(Extended3Enum.GAMMA, Extended3Enum.getEnum(\"Gamma\"));\n+        assertSame(Extended3Enum.DELTA, Extended3Enum.getEnum(\"Delta\"));\n+    }\n+\n+    public void testExtendedSerialization() {\n+        assertSame(Extended1Enum.ALPHA, SerializationUtils.clone(Extended1Enum.ALPHA));\n+        assertSame(Extended1Enum.BETA, SerializationUtils.clone(Extended1Enum.BETA));\n+        assertSame(Extended2Enum.GAMMA, SerializationUtils.clone(Extended2Enum.GAMMA));\n+        assertSame(Extended3Enum.DELTA, SerializationUtils.clone(Extended3Enum.DELTA));\n+    }\n+\n+    public void testExtendedToString() {\n+        assertEquals(\"Extended1Enum[Alpha]\", Extended1Enum.ALPHA.toString());\n+        assertEquals(\"Extended1Enum[Beta]\", Extended1Enum.BETA.toString());\n+\n+        assertEquals(\"Extended1Enum[Alpha]\", Extended2Enum.ALPHA.toString());\n+        assertEquals(\"Extended1Enum[Beta]\", Extended2Enum.BETA.toString());\n+        assertEquals(\"Extended2Enum[Gamma]\", Extended2Enum.GAMMA.toString());\n+\n+        assertEquals(\"Extended1Enum[Alpha]\", Extended3Enum.ALPHA.toString());\n+        assertEquals(\"Extended1Enum[Beta]\", Extended3Enum.BETA.toString());\n+        assertEquals(\"Extended2Enum[Gamma]\", Extended3Enum.GAMMA.toString());\n+        assertEquals(\"Extended3Enum[Delta]\", Extended3Enum.DELTA.toString());\n+    }\n+\n+    public void testExtended1List() {\n+        List list = Extended1Enum.getEnumList();\n+        assertNotNull(list);\n+        assertEquals(2, list.size());\n+        assertEquals(list.size(), Extended1Enum.getEnumMap().keySet().size());\n+\n+        Iterator it = list.iterator();\n+        assertSame(Extended1Enum.ALPHA, it.next());\n+        assertSame(Extended1Enum.BETA, it.next());\n+    }\n+\n+    public void testExtended2List() {\n+        List list = Extended2Enum.getEnumList();\n+        assertNotNull(list);\n+        assertEquals(3, list.size());\n+        assertEquals(list.size(), Extended2Enum.getEnumMap().keySet().size());\n+\n+        Iterator it = list.iterator();\n+        assertSame(Extended2Enum.ALPHA, it.next());\n+        assertSame(Extended2Enum.BETA, it.next());\n+        assertSame(Extended2Enum.GAMMA, it.next());\n+    }\n+\n+    public void testExtended3List() {\n+        List list = Extended3Enum.getEnumList();\n+        assertNotNull(list);\n+        assertEquals(4, list.size());\n+        assertEquals(list.size(), Extended3Enum.getEnumMap().keySet().size());\n+\n+        Iterator it = list.iterator();\n+        assertSame(Extended3Enum.ALPHA, it.next());\n+        assertSame(Extended3Enum.BETA, it.next());\n+        assertSame(Extended3Enum.GAMMA, it.next());\n+        assertSame(Extended3Enum.DELTA, it.next());\n+    }\n+\n+    public void testExtended1Map() {\n+        Map map = Extended1Enum.getEnumMap();\n+        assertNotNull(map);\n+        assertEquals(map.keySet().size(), Extended1Enum.getEnumList().size());\n+\n+        assertTrue(map.containsValue(Extended1Enum.ALPHA));\n+        assertTrue(map.containsValue(Extended1Enum.BETA));\n+        assertSame(Extended1Enum.ALPHA, map.get(\"Alpha\"));\n+        assertSame(Extended1Enum.BETA, map.get(\"Beta\"));\n+    }\n+\n+    public void testExtended2Map() {\n+        Map map = Extended2Enum.getEnumMap();\n+        assertNotNull(map);\n+        assertEquals(map.keySet().size(), Extended2Enum.getEnumList().size());\n+\n+        assertTrue(map.containsValue(Extended2Enum.ALPHA));\n+        assertTrue(map.containsValue(Extended2Enum.BETA));\n+        assertTrue(map.containsValue(Extended2Enum.GAMMA));\n+        assertSame(Extended2Enum.ALPHA, map.get(\"Alpha\"));\n+        assertSame(Extended2Enum.BETA, map.get(\"Beta\"));\n+        assertSame(Extended2Enum.GAMMA, map.get(\"Gamma\"));\n+    }\n+\n+    public void testExtended3Map() {\n+        Map map = Extended3Enum.getEnumMap();\n+        assertNotNull(map);\n+        assertEquals(map.keySet().size(), Extended3Enum.getEnumList().size());\n+\n+        assertTrue(map.containsValue(Extended3Enum.ALPHA));\n+        assertTrue(map.containsValue(Extended3Enum.BETA));\n+        assertTrue(map.containsValue(Extended3Enum.GAMMA));\n+        assertTrue(map.containsValue(Extended3Enum.DELTA));\n+        assertSame(Extended3Enum.ALPHA, map.get(\"Alpha\"));\n+        assertSame(Extended3Enum.BETA, map.get(\"Beta\"));\n+        assertSame(Extended3Enum.GAMMA, map.get(\"Gamma\"));\n+        assertSame(Extended3Enum.DELTA, map.get(\"Delta\"));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testNested() {\n+        List list = new ArrayList(Nest.ColorEnum.getEnumList());\n+        assertEquals(3, list.size()); // all is well\n+        Iterator it = list.iterator();\n+        assertSame(Nest.ColorEnum.RED, it.next());\n+        assertSame(Nest.ColorEnum.GREEN, it.next());\n+        assertSame(Nest.ColorEnum.BLUE, it.next());\n+        // This nesting works because the enum constants are defined in the SAME\n+        // class as the getEnumList(). It just acts as a normal enum.\n+    }\n+\n+    public void testNestedBroken() {\n+        List list = new ArrayList(NestBroken.ColorEnum.getEnumList());\n+        try {\n+            assertEquals(0, list.size()); // no enums!!!\n+            // this is BROKEN because the enum constants are defined in a DIFFERENT\n+            // class from getEnumList(). Once NestBroken class is referenced,\n+            // and thus class loaded with its enum constants, the getEnumList works:\n+        } catch (AssertionFailedError ex) {\n+            // this actually works and isn't broken on Linux SunJDK1.4.1, so...\n+            assertEquals(3, list.size());\n+        }\n+        new NestBroken();\n+        list = new ArrayList(NestBroken.ColorEnum.getEnumList());\n+        assertEquals(3, list.size()); // all is well!!!\n+        Iterator it = list.iterator();\n+        assertSame(NestBroken.RED, it.next());\n+        assertSame(NestBroken.GREEN, it.next());\n+        assertSame(NestBroken.BLUE, it.next());\n+    }\n+\n+    public void testNestedLinked() {\n+        List list = new ArrayList(NestLinked.ColorEnum.getEnumList());\n+        assertEquals(3, list.size()); // all is well\n+        Iterator it = list.iterator();\n+        assertSame(NestLinked.RED, it.next());\n+        assertSame(NestLinked.GREEN, it.next());\n+        assertSame(NestLinked.BLUE, it.next());\n+        // This nesting works because a static block in the enum class forces a\n+        // class load of the outer class which defines the enum constants.\n+    }\n+\n+    public void testNestedReferenced() {\n+        List list = new ArrayList(NestReferenced.ColorEnum.getEnumList());\n+        assertEquals(3, list.size()); // all is well\n+        Iterator it = list.iterator();\n+        assertSame(NestReferenced.RED, it.next());\n+        assertSame(NestReferenced.GREEN, it.next());\n+        assertSame(NestReferenced.BLUE, it.next());\n+        // This nesting works because the enum constants are actually defined in\n+        // the SAME class as the getEnumList(). The references in the outer class\n+        // are just extra references.\n+    }\n+\n+    public void testColorEnumEqualsWithDifferentClassLoaders() throws SecurityException, IllegalArgumentException,\n+            ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        this.testWithDifferentClassLoaders(ColorEnum.BLUE);\n+        this.testWithDifferentClassLoaders(ColorEnum.GREEN);\n+        this.testWithDifferentClassLoaders(ColorEnum.RED);\n+    }\n+\n+    void testWithDifferentClassLoaders(ColorEnum colorEnum) throws ClassNotFoundException, SecurityException,\n+            NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+        // Sanity checks:\n+        assertTrue(colorEnum.equals(colorEnum));\n+        assertNotNull(ColorEnum.class.getClassLoader());\n+        // set up:\n+        ClassLoader classLoader = ClassUtilsTest.newSystemClassLoader();\n+        Object enumObjectFromOtherClassLoader = this.getColorEnum(classLoader, colorEnum.getName());\n+\n+        // the real test, part 1.\n+        try {\n+            ColorEnum testCase = (ColorEnum) enumObjectFromOtherClassLoader;\n+            fail(\"Should have thrown a ClassCastException for \" + testCase);\n+        } catch (ClassCastException e) {\n+            // normal.\n+        }\n+\n+        // the real test, part 2.\n+        assertEquals(\"The two objects should match even though they are from different class loaders\", colorEnum,\n+                enumObjectFromOtherClassLoader);\n+\n+        // the real test, part 3 - testing equals(Object)\n+        int falseCount = 0;\n+        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {\n+            ColorEnum element = (ColorEnum) iter.next();\n+            if (!colorEnum.equals(element)) {\n+                falseCount++;\n+                assertFalse(enumObjectFromOtherClassLoader.equals(element));\n+            }\n+        }\n+        assertEquals(ColorEnum.getEnumList().size() - 1, falseCount);\n+\n+        // the real test, part 4 - testing compareTo(Object) == 0\n+        falseCount = 0;\n+        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {\n+            ColorEnum element = (ColorEnum) iter.next();\n+            if (!colorEnum.equals(element)) {\n+                falseCount++;\n+                assertFalse( ((Comparable)enumObjectFromOtherClassLoader).compareTo(element) == 0);\n+            }\n+        }\n+        assertEquals(ColorEnum.getEnumList().size() - 1, falseCount);\n+    }\n+\n+    Object getColorEnum(ClassLoader classLoader, String color) throws ClassNotFoundException, SecurityException,\n+            NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+        // Sanity check:\n+        ColorEnum.RED.equals(ColorEnum.RED);\n+        assertNotNull(ColorEnum.class.getClassLoader());\n+        // set up:\n+        assertNotNull(classLoader);\n+        assertFalse(classLoader.equals(ColorEnum.class.getClassLoader()));\n+        Class otherColorEnumClass = null;\n+        try {\n+            otherColorEnumClass = classLoader.loadClass(ENUM_CLASS_NAME);\n+        } catch (ClassNotFoundException e) {\n+            // Dump some information to help debug class loader issues under different JREs, Ant, Eclipse.\n+            System.err.println(\"Could not load \" + ENUM_CLASS_NAME + \" from the class loader \" + classLoader);\n+            URLClassLoader urlCl = (URLClassLoader) classLoader;\n+            URL[] urls = urlCl.getURLs();\n+            System.err.println(\"Class loader has \" + urls.length + \" URLs:\");\n+            for (int i = 0; i < urls.length; i++) {\n+                System.err.println(\"URL[\" + i + \"] = \" + urls[i]);\n+            }\n+            e.printStackTrace();\n+            throw e;\n+        }\n+        assertNotNull(otherColorEnumClass);\n+        assertNotNull(otherColorEnumClass.getClassLoader());\n+        assertTrue(classLoader.equals(otherColorEnumClass.getClassLoader()));\n+        assertFalse(otherColorEnumClass.getClassLoader().equals(ColorEnum.class.getClassLoader()));\n+        Method method = otherColorEnumClass.getMethod(\"getEnum\", new Class[]{String.class});\n+        Object enumObject = method.invoke(otherColorEnumClass, new Object[]{color});\n+        assertNotNull(enumObject);\n+        assertFalse(ColorEnum.class.equals(enumObject.getClass()));\n+        assertFalse(ColorEnum.class == enumObject.getClass());\n+        return enumObject;\n+    }\n+\n+    public void testEqualsToWrongInstance() {\n+        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {\n+            ColorEnum element = (ColorEnum) iter.next();\n+            this.testEqualsToWrongInstance(element);\n+        }\n+    }\n+\n+    void testEqualsToWrongInstance(ColorEnum colorEnum) {\n+        assertEquals(false, colorEnum.equals(\"test\"));\n+        assertEquals(false, colorEnum.equals(new Integer(1)));\n+        assertEquals(false, colorEnum.equals(new Boolean(true)));\n+        assertEquals(false, colorEnum.equals(new StringBuffer(\"test\")));\n+        assertEquals(false, colorEnum.equals(new Object()));\n+        assertEquals(false, colorEnum.equals(null));\n+        assertEquals(false, colorEnum.equals(\"\"));\n+        assertEquals(false, colorEnum.equals(ColorEnum.getEnum(null)));\n+        assertEquals(false, colorEnum.equals(ColorEnum.getEnum(\"\")));\n+        assertEquals(false, colorEnum.equals(ColorEnum.getEnum(\"This ColorEnum does not exist.\")));\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/EnumTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test suite for the Enum package.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class EnumTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public EnumTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Enum Tests\");\n+        suite.addTest(EnumTest.suite());\n+        suite.addTest(EnumUtilsTest.suite());\n+        suite.addTest(ValuedEnumTest.suite());\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/EnumUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Enum} class.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+\n+public final class EnumUtilsTest extends TestCase {\n+\n+    public EnumUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EnumUtilsTest.class);\n+        suite.setName(\"EnumUtils Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new EnumUtils());\n+        Constructor[] cons = EnumUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(EnumUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(EnumUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIterator() {\n+        Iterator it = EnumUtils.iterator(ColorEnum.class);\n+        assertSame(ColorEnum.RED, it.next());\n+        assertSame(ColorEnum.GREEN, it.next());\n+        assertSame(ColorEnum.BLUE, it.next());\n+        it = EnumUtils.iterator(DummyEnum.class);\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    public void testIteratorEx() {\n+        try {\n+            EnumUtils.iterator(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.iterator(Object.class);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testList() {\n+        List list = EnumUtils.getEnumList(ColorEnum.class);\n+        Iterator it = list.iterator();\n+        assertSame(ColorEnum.RED, it.next());\n+        assertSame(ColorEnum.GREEN, it.next());\n+        assertSame(ColorEnum.BLUE, it.next());\n+        list = EnumUtils.getEnumList(DummyEnum.class);\n+        assertEquals(0, list.size());\n+    }\n+\n+    public void testListEx() {\n+        try {\n+            EnumUtils.getEnumList(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.getEnumList(Object.class);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMap() {\n+        Map map = EnumUtils.getEnumMap(ColorEnum.class);\n+        assertTrue(map.containsValue(ColorEnum.RED));\n+        assertTrue(map.containsValue(ColorEnum.GREEN));\n+        assertTrue(map.containsValue(ColorEnum.BLUE));\n+        assertSame(ColorEnum.RED, map.get(\"Red\"));\n+        assertSame(ColorEnum.GREEN, map.get(\"Green\"));\n+        assertSame(ColorEnum.BLUE, map.get(\"Blue\"));\n+        map = EnumUtils.getEnumMap(DummyEnum.class);\n+        assertEquals(0, map.size());\n+    }\n+\n+    public void testMapEx() {\n+        try {\n+            EnumUtils.getEnumMap(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.getEnumMap(Object.class);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        assertSame(ColorEnum.RED, EnumUtils.getEnum(ColorEnum.class, \"Red\"));\n+        assertSame(ColorEnum.GREEN, EnumUtils.getEnum(ColorEnum.class, \"Green\"));\n+        assertSame(ColorEnum.BLUE, EnumUtils.getEnum(ColorEnum.class, \"Blue\"));\n+        assertSame(null, EnumUtils.getEnum(ColorEnum.class, \"Pink\"));\n+        assertSame(null, EnumUtils.getEnum(DummyEnum.class, \"Pink\"));\n+    }\n+\n+    public void testGetEx() {\n+        try {\n+            EnumUtils.getEnum(null, \"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.getEnum(Object.class, \"Red\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetValue() {\n+        assertSame(ValuedColorEnum.RED, EnumUtils.getEnum(ValuedColorEnum.class, 1));\n+        assertSame(ValuedColorEnum.GREEN, EnumUtils.getEnum(ValuedColorEnum.class, 2));\n+        assertSame(ValuedColorEnum.BLUE, EnumUtils.getEnum(ValuedColorEnum.class, 3));\n+        assertSame(null, EnumUtils.getEnum(ValuedColorEnum.class, 4));\n+        assertSame(null, EnumUtils.getEnum(DummyEnum.class, 5));\n+    }\n+\n+    public void testGetValueEx() {\n+        try {\n+            EnumUtils.getEnum(null, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.getEnum(Object.class, 2);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Extended1Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Base extended enumeration.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class Extended1Enum extends Enum {\n+    public static final Extended1Enum ALPHA = new Extended1Enum(\"Alpha\");\n+    public static final Extended1Enum BETA = new Extended1Enum(\"Beta\");\n+\n+    protected Extended1Enum(String name) {\n+        super(name);\n+    }\n+\n+    public static Extended1Enum getEnum(String name) {\n+        return (Extended1Enum) getEnum(Extended1Enum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Extended1Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Extended1Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Extended1Enum.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Extended2Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extended enumeration.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class Extended2Enum extends Extended1Enum {\n+    public static final Extended1Enum GAMMA = new Extended2Enum(\"Gamma\");\n+\n+    protected Extended2Enum(String color) {\n+        super(color);\n+    }\n+\n+    public static Extended1Enum getEnum(String name) {\n+        return (Extended1Enum) getEnum(Extended2Enum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Extended2Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Extended2Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Extended2Enum.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Extended3Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extended enumeration.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class Extended3Enum extends Extended2Enum {\n+    public static final Extended1Enum DELTA = new Extended3Enum(\"Delta\");\n+\n+    protected Extended3Enum(String name) {\n+        super(name);\n+    }\n+\n+    public static Extended1Enum getEnum(String name) {\n+        return (Extended1Enum) Enum.getEnum(Extended3Enum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return Enum.getEnumMap(Extended3Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return Enum.getEnumList(Extended3Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return Enum.iterator(Extended3Enum.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/Nest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration demonstrating a normal simple nesting case.\n+ * All is well here as the nested enum class is really no different\n+ * to any other class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+\n+public final class Nest {\n+    \n+    public Nest() {\n+        super();\n+    }\n+    \n+    public static final class ColorEnum extends Enum {\n+        public static final ColorEnum RED = new ColorEnum(\"Red\");\n+        public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+        public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+\n+        private ColorEnum(String color) {\n+            super(color);\n+        }\n+\n+        public static ColorEnum getEnum(String color) {\n+            return (ColorEnum) getEnum(ColorEnum.class, color);\n+        }\n+\n+        public static Map getEnumMap() {\n+            return getEnumMap(ColorEnum.class);\n+        }\n+\n+        public static List getEnumList() {\n+            return getEnumList(ColorEnum.class);\n+        }\n+\n+        public static Iterator iterator() {\n+            return iterator(ColorEnum.class);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/NestBroken.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration which demonstrates how to break the enum system.\n+ * <p>\n+ * The class loader sees the two classes here as independent - the enum\n+ * class is nested, not an inner class. Calling getEnumList() on ColorEnum\n+ * will return an empty list, unless and until the NestBroken class is\n+ * referenced.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+\n+public final class NestBroken {\n+    \n+    public static final ColorEnum RED = new ColorEnum(\"Red\");\n+    public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+    public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+    \n+    public NestBroken() {\n+        super();\n+    }\n+    \n+    public static final class ColorEnum extends Enum {\n+\n+        private ColorEnum(String color) {\n+            super(color);\n+        }\n+\n+        public static ColorEnum getEnum(String color) {\n+            return (ColorEnum) getEnum(ColorEnum.class, color);\n+        }\n+\n+        public static Map getEnumMap() {\n+            return getEnumMap(ColorEnum.class);\n+        }\n+\n+        public static List getEnumList() {\n+            return getEnumList(ColorEnum.class);\n+        }\n+\n+        public static Iterator iterator() {\n+            return iterator(ColorEnum.class);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/NestLinked.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration which demonstrates how to define the constants in a\n+ * different class to the Enum. The extra <code>static{}</code> block is\n+ * needed to ensure that the enum constants are created before the\n+ * static methods on the ColorEnum are used.\n+ * <p>\n+ * The class loader sees the two classes here as independent - the enum\n+ * class is nested, not an inner class. The static block thus forces the\n+ * class load of the outer class, which is needed to initialise the enums.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+\n+public final class NestLinked {\n+    \n+    public static final ColorEnum RED = new ColorEnum(\"Red\");\n+    public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+    public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+    \n+    public NestLinked() {\n+        super();\n+    }\n+    \n+    public static final class ColorEnum extends Enum {\n+\n+        static {\n+            // Explicitly reference the class where the enums are defined\n+            Object obj = NestLinked.RED;\n+        }\n+        \n+        private ColorEnum(String color) {\n+            super(color);\n+        }\n+\n+        public static ColorEnum getEnum(String color) {\n+            return (ColorEnum) getEnum(ColorEnum.class, color);\n+        }\n+\n+        public static Map getEnumMap() {\n+            return getEnumMap(ColorEnum.class);\n+        }\n+\n+        public static List getEnumList() {\n+            return getEnumList(ColorEnum.class);\n+        }\n+\n+        public static Iterator iterator() {\n+            return iterator(ColorEnum.class);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/NestReferenced.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration which demonstrates how to provide a view of the constants\n+ * in a different class to the Enum. This technique is the safest, however it\n+ * is obviously inconvenient as it involves defining two sets of constants.\n+ * See NestedLinked for an alternative.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+\n+public final class NestReferenced {\n+    \n+    public static final ColorEnum RED = ColorEnum.RED;\n+    public static final ColorEnum GREEN = ColorEnum.GREEN;\n+    public static final ColorEnum BLUE = ColorEnum.BLUE;\n+    \n+    public NestReferenced() {\n+        super();\n+    }\n+    \n+    public static final class ColorEnum extends Enum {\n+\n+        // must be defined here, not just in outer class\n+        private static final ColorEnum RED = new ColorEnum(\"Red\");\n+        private static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+        private static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+        \n+        private ColorEnum(String color) {\n+            super(color);\n+        }\n+\n+        public static ColorEnum getEnum(String color) {\n+            return (ColorEnum) getEnum(ColorEnum.class, color);\n+        }\n+\n+        public static Map getEnumMap() {\n+            return getEnumMap(ColorEnum.class);\n+        }\n+\n+        public static List getEnumList() {\n+            return getEnumList(ColorEnum.class);\n+        }\n+\n+        public static Iterator iterator() {\n+            return iterator(ColorEnum.class);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Operator enumeration.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return OperationEnum.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static OperationEnum getEnum(String name) {\n+        return (OperationEnum) getEnum(OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/ValuedColorEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+\n+public final class ValuedColorEnum extends ValuedEnum {\n+    public static final ValuedColorEnum RED = new ValuedColorEnum(\"Red\", 1);\n+    public static final ValuedColorEnum GREEN = new ValuedColorEnum(\"Green\", 2);\n+    public static final ValuedColorEnum BLUE = new ValuedColorEnum(\"Blue\", 3);\n+\n+    private ValuedColorEnum(String color, int value) {\n+        super(color, value);\n+    }\n+\n+    public static ValuedColorEnum getEnum(String color) {\n+        return (ValuedColorEnum) getEnum(ValuedColorEnum.class, color);\n+    }\n+\n+    public static ValuedColorEnum getEnum(int value) {\n+        return (ValuedColorEnum) getEnum(ValuedColorEnum.class, value);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(ValuedColorEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(ValuedColorEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(ValuedColorEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enum/ValuedEnumTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enum;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import org.apache.commons.lang.SerializationUtils;\n+\n+/**\n+ * Test cases for the {@link Enum} class.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+\n+public final class ValuedEnumTest extends TestCase {\n+\n+    public ValuedEnumTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ValuedEnumTest.class);\n+        suite.setName(\"ValuedEnum Tests\");\n+        return suite;\n+    }\n+\n+    public void testName() {\n+        assertEquals(\"Red\", ValuedColorEnum.RED.getName());\n+        assertEquals(\"Green\", ValuedColorEnum.GREEN.getName());\n+        assertEquals(\"Blue\", ValuedColorEnum.BLUE.getName());\n+    }\n+\n+    public void testValue() {\n+        assertEquals(1, ValuedColorEnum.RED.getValue());\n+        assertEquals(2, ValuedColorEnum.GREEN.getValue());\n+        assertEquals(3, ValuedColorEnum.BLUE.getValue());\n+    }\n+\n+    public void testCompareTo() {\n+        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.BLUE) == 0);\n+        assertTrue(ValuedColorEnum.RED.compareTo(ValuedColorEnum.BLUE) < 0);\n+        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.RED) > 0);\n+    }\n+\n+    public void testEquals() {\n+        assertSame(ValuedColorEnum.RED, ValuedColorEnum.RED);\n+        assertSame(ValuedColorEnum.getEnum(\"Red\"), ValuedColorEnum.RED);\n+    }\n+\n+    public void testToString() {\n+        String toString = ValuedColorEnum.RED.toString();\n+        assertEquals(\"ValuedColorEnum[Red=1]\", toString);\n+        assertSame(toString, ValuedColorEnum.RED.toString());\n+    }\n+\n+    public void testIterator() {\n+        Iterator it = ValuedColorEnum.iterator();\n+        assertSame(ValuedColorEnum.RED, it.next());\n+        assertSame(ValuedColorEnum.GREEN, it.next());\n+        assertSame(ValuedColorEnum.BLUE, it.next());\n+    }\n+\n+    public void testList() {\n+        List list = ValuedColorEnum.getEnumList();\n+        \n+        assertNotNull(list);\n+        \n+        assertEquals( list.size(),\n+                     ValuedColorEnum.getEnumMap().keySet().size());\n+        \n+        Iterator it = list.iterator();\n+        assertSame(ValuedColorEnum.RED, it.next());\n+        assertSame(ValuedColorEnum.GREEN, it.next());\n+        assertSame(ValuedColorEnum.BLUE, it.next());\n+    }\n+\n+    public void testMap() {\n+        Map map = ValuedColorEnum.getEnumMap();\n+        \n+        assertNotNull(map);\n+        \n+        assertEquals( map.keySet().size(),\n+                     ValuedColorEnum.getEnumList().size());\n+                     \n+        assertTrue(map.containsValue(ValuedColorEnum.RED));\n+        assertTrue(map.containsValue(ValuedColorEnum.GREEN));\n+        assertTrue(map.containsValue(ValuedColorEnum.BLUE));\n+        assertSame(ValuedColorEnum.RED, map.get(\"Red\"));\n+        assertSame(ValuedColorEnum.GREEN, map.get(\"Green\"));\n+        assertSame(ValuedColorEnum.BLUE, map.get(\"Blue\"));\n+    }\n+\n+    public void testGet() {\n+        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum(\"Red\"));\n+        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum(\"Green\"));\n+        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum(\"Blue\"));\n+        assertSame(null, ValuedColorEnum.getEnum(\"Pink\"));\n+    }\n+\n+    public void testGetValue() {\n+        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum(1));\n+        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum(2));\n+        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum(3));\n+        assertSame(null, ValuedColorEnum.getEnum(4));\n+    }\n+\n+    public void testSerialization() {\n+        assertSame(ValuedColorEnum.RED, SerializationUtils.clone(ValuedColorEnum.RED));\n+        assertSame(ValuedColorEnum.GREEN, SerializationUtils.clone(ValuedColorEnum.GREEN));\n+        assertSame(ValuedColorEnum.BLUE, SerializationUtils.clone(ValuedColorEnum.BLUE));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Broken1Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public final class Broken1Enum extends Enum {\n+    public static final Broken1Enum RED = new Broken1Enum(\"Red\");\n+    public static final Broken1Enum GREEN = new Broken1Enum(\"Green\");\n+    public static final Broken1Enum GREENISH = new Broken1Enum(\"Green\");  // duplicate not allowed\n+\n+    private Broken1Enum(String color) {\n+        super(color);\n+    }\n+\n+    public static Broken1Enum getEnum(String color) {\n+        return (Broken1Enum) getEnum(Broken1Enum.class, color);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken1Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken1Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken1Enum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Broken1OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, null class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken1OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken1OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken1OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken1OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken1OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken1OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return null;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken1OperationEnum getEnum(String name) {\n+        return (Broken1OperationEnum) getEnum(Broken1OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken1OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken1OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken1OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Broken2Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public final class Broken2Enum extends Enum {\n+    public static final Broken2Enum RED = new Broken2Enum(\"Red\");\n+    public static final Broken2Enum GREEN = new Broken2Enum(\"Green\");\n+    public static final Broken2Enum BLUE = new Broken2Enum(\"\");  // blank not allowed\n+\n+    private Broken2Enum(String color) {\n+        super(color);\n+    }\n+\n+    public static Broken2Enum getEnum(String color) {\n+        return (Broken2Enum) getEnum(Broken2Enum.class, color);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken2Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken2Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken2Enum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Broken2OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, getEnumClass() not superclass.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken2OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken2OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken2OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken2OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken2OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken2OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return ColorEnum.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken2OperationEnum getEnum(String name) {\n+        return (Broken2OperationEnum) getEnum(Broken2OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken2OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken2OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken2OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Broken3Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public final class Broken3Enum extends Enum {\n+    public static final Broken3Enum RED = new Broken3Enum(\"Red\");\n+    public static final Broken3Enum GREEN = new Broken3Enum(\"Green\");\n+    public static final Broken3Enum BLUE = new Broken3Enum(null);  // null not allowed\n+\n+    private Broken3Enum(String color) {\n+        super(color);\n+    }\n+\n+    public static Broken3Enum getEnum(String color) {\n+        return (Broken3Enum) getEnum(Broken3Enum.class, color);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken3Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken3Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken3Enum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Broken3OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, getEnumClass() is Enum.class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken3OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken3OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken3OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken3OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken3OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken3OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return Enum.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken3OperationEnum getEnum(String name) {\n+        return (Broken3OperationEnum) getEnum(Broken3OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken3OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken3OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken3OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Broken4OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, getEnumClass() is ValuedEnum.class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken4OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken4OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken4OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken4OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken4OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken4OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return ValuedEnum.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken4OperationEnum getEnum(String name) {\n+        return (Broken4OperationEnum) getEnum(Broken4OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken4OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken4OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken4OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Broken5OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Broken Operator enumeration, getEnumClass() is not an Enum class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class Broken5OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final Broken5OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends Broken5OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final Broken5OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends Broken5OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private Broken5OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return String.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static Broken5OperationEnum getEnum(String name) {\n+        return (Broken5OperationEnum) getEnum(Broken5OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Broken5OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Broken5OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Broken5OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/ColorEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+\n+public final class ColorEnum extends Enum {\n+    public static final ColorEnum RED = new ColorEnum(\"Red\");\n+    public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+    public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+\n+    private ColorEnum(String color) {\n+        super(color);\n+    }\n+\n+    public static ColorEnum getEnum(String color) {\n+        return (ColorEnum) getEnum(ColorEnum.class, color);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(ColorEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(ColorEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(ColorEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/DummyEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+/**\n+ * Dummy enumeration - no values.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class DummyEnum extends Enum {\n+\n+    private DummyEnum(String name) {\n+        super(name);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/EnumEqualsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.net.URLClassLoader;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Enum} class equals method.\n+ *\n+ * @author Matthias Eichel\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public final class EnumEqualsTest extends TestCase {\n+\n+    public EnumEqualsTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EnumEqualsTest.class);\n+        suite.setName(\"Enum equals Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static final class CarColorEnum extends Enum {\n+        public static final CarColorEnum BLACK = new CarColorEnum(\"black\");\n+        public static final CarColorEnum BROWN = new CarColorEnum(\"brown\");\n+        public static final CarColorEnum YELLOW = new CarColorEnum(\"yellow\");\n+        public static final CarColorEnum BLUE = new CarColorEnum(\"blue\");\n+        public static final CarColorEnum RED = new CarColorEnum(\"red\");\n+\n+        private CarColorEnum(String enumAsString) {\n+            super(enumAsString);\n+        }\n+    }\n+\n+    static final class TrafficlightColorEnum extends Enum {\n+        public static final TrafficlightColorEnum RED = new TrafficlightColorEnum(\"red\");\n+        public static final TrafficlightColorEnum YELLOW = new TrafficlightColorEnum(\"yellow\");\n+        public static final TrafficlightColorEnum GREEN = new TrafficlightColorEnum(\"green\");\n+\n+        private TrafficlightColorEnum(String enumAsString) {\n+            super(enumAsString);\n+        }\n+    }\n+\n+    static class TotallyUnrelatedClass {\n+        private final String name;\n+\n+        public TotallyUnrelatedClass(final String name) {\n+            this.name = name;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquals() {\n+        assertEquals(false, CarColorEnum.RED.equals(TrafficlightColorEnum.RED));\n+        assertEquals(false, CarColorEnum.YELLOW.equals(TrafficlightColorEnum.YELLOW));\n+        \n+        assertEquals(false, TrafficlightColorEnum.RED.equals(new TotallyUnrelatedClass(\"red\")));\n+        assertEquals(false, CarColorEnum.RED.equals(new TotallyUnrelatedClass(\"red\")));\n+        \n+        assertEquals(false, TrafficlightColorEnum.RED.equals(new TotallyUnrelatedClass(\"some\")));\n+        assertEquals(false, CarColorEnum.RED.equals(new TotallyUnrelatedClass(\"some\")));\n+    }\n+\n+    public void testEquals_classloader_equal() throws Exception {\n+        ClassLoader cl = ColorEnum.class.getClassLoader();\n+        if (cl instanceof URLClassLoader) {\n+            URLClassLoader urlCL = (URLClassLoader) cl;\n+            URLClassLoader urlCL1 = new URLClassLoader(urlCL.getURLs(), null);\n+            URLClassLoader urlCL2 = new URLClassLoader(urlCL.getURLs(), null);\n+            Class otherEnumClass1 = urlCL1.loadClass(\"org.apache.commons.lang.enums.ColorEnum\");\n+            Class otherEnumClass2 = urlCL2.loadClass(\"org.apache.commons.lang.enums.ColorEnum\");\n+            Object blue1 = otherEnumClass1.getDeclaredField(\"BLUE\").get(null);\n+            Object blue2 = otherEnumClass2.getDeclaredField(\"BLUE\").get(null);\n+            assertEquals(true, blue1.equals(blue2));\n+        }\n+    }\n+\n+    public void testEquals_classloader_different() throws Exception {\n+        ClassLoader cl = ColorEnum.class.getClassLoader();\n+        if (cl instanceof URLClassLoader) {\n+            URLClassLoader urlCL = (URLClassLoader) cl;\n+            URLClassLoader urlCL1 = new URLClassLoader(urlCL.getURLs(), null);\n+            URLClassLoader urlCL2 = new URLClassLoader(urlCL.getURLs(), null);\n+            Class otherEnumClass1 = urlCL1.loadClass(\"org.apache.commons.lang.enums.ColorEnum\");\n+            Class otherEnumClass2 = urlCL2.loadClass(\"org.apache.commons.lang.enums.ColorEnum\");\n+            Object blue1 = otherEnumClass1.getDeclaredField(\"BLUE\").get(null);\n+            Object blue2 = otherEnumClass2.getDeclaredField(\"RED\").get(null);\n+            assertEquals(false, blue1.equals(blue2));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCompareTo() {\n+        try {\n+            CarColorEnum.RED.compareTo(TrafficlightColorEnum.RED);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            CarColorEnum.YELLOW.compareTo(TrafficlightColorEnum.YELLOW);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            TrafficlightColorEnum.RED.compareTo(new TotallyUnrelatedClass(\"red\"));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            CarColorEnum.RED.compareTo(new TotallyUnrelatedClass(\"red\"));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            TrafficlightColorEnum.RED.compareTo(new TotallyUnrelatedClass(\"some\"));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            CarColorEnum.RED.compareTo(new TotallyUnrelatedClass(\"some\"));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/EnumTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import org.apache.commons.lang.ClassUtilsTest;\n+import org.apache.commons.lang.SerializationUtils;\n+\n+/**\n+ * Test cases for the {@link Enum} class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Gary D. Gregory\n+ * @version $Id$\n+ */\n+\n+public final class EnumTest extends TestCase {\n+\n+    private static final String ENUMS_CLASS_NAME = \"org.apache.commons.lang.enums.ColorEnum\";\n+\n+    public EnumTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EnumTest.class);\n+        suite.setName(\"Enum Tests\");\n+        return suite;\n+    }\n+\n+    public void testName() {\n+        assertEquals(\"Red\", ColorEnum.RED.getName());\n+        assertEquals(\"Green\", ColorEnum.GREEN.getName());\n+        assertEquals(\"Blue\", ColorEnum.BLUE.getName());\n+    }\n+\n+    public void testCompareTo() {\n+        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.BLUE) == 0);\n+        assertTrue(ColorEnum.RED.compareTo(ColorEnum.BLUE) > 0);\n+        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.RED) < 0);\n+        try {\n+            ColorEnum.RED.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            ColorEnum.RED.compareTo(new Object());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        assertSame(ColorEnum.RED, ColorEnum.RED);\n+        assertSame(ColorEnum.getEnum(\"Red\"), ColorEnum.RED);\n+        assertEquals(false, ColorEnum.RED.equals(null));\n+        assertEquals(true, ColorEnum.RED.equals(ColorEnum.RED));\n+        assertEquals(true, ColorEnum.RED.equals(ColorEnum.getEnum(\"Red\")));\n+    }\n+\n+    public void testHashCode() {\n+        assertEquals(ColorEnum.RED.hashCode(), ColorEnum.RED.hashCode());\n+        assertEquals(7 + ColorEnum.class.hashCode() + 3 * \"Red\".hashCode(), ColorEnum.RED.hashCode());\n+    }\n+\n+    public void testToString() {\n+        String toString = ColorEnum.RED.toString();\n+        assertEquals(\"ColorEnum[Red]\", toString);\n+        assertSame(toString, ColorEnum.RED.toString());\n+    }\n+\n+    public void testIterator() {\n+        Iterator it = ColorEnum.iterator();\n+        assertSame(ColorEnum.RED, it.next());\n+        assertSame(ColorEnum.GREEN, it.next());\n+        assertSame(ColorEnum.BLUE, it.next());\n+    }\n+\n+    public void testList() {\n+        List list = new ArrayList(ColorEnum.getEnumList());\n+        \n+        assertNotNull(list);\n+        \n+        assertEquals( list.size(),\n+                        ColorEnum.getEnumMap().keySet().size());\n+        \n+        Iterator it = list.iterator();\n+        assertSame(ColorEnum.RED, it.next());\n+        assertSame(ColorEnum.GREEN, it.next());\n+        assertSame(ColorEnum.BLUE, it.next());\n+    }\n+\n+    public void testMap() {\n+        Map map = new HashMap(ColorEnum.getEnumMap());\n+        \n+        assertNotNull(map);\n+        assertTrue(map.containsValue(ColorEnum.RED));\n+        assertTrue(map.containsValue(ColorEnum.GREEN));\n+        assertTrue(map.containsValue(ColorEnum.BLUE));\n+        assertSame(ColorEnum.RED, map.get(\"Red\"));\n+        assertSame(ColorEnum.GREEN, map.get(\"Green\"));\n+        assertSame(ColorEnum.BLUE, map.get(\"Blue\"));\n+        assertEquals( map.keySet().size(),\n+                        ColorEnum.getEnumList().size());\n+    }\n+\n+    public void testGet() {\n+        assertSame(ColorEnum.RED, ColorEnum.getEnum(\"Red\"));\n+        assertSame(ColorEnum.GREEN, ColorEnum.getEnum(\"Green\"));\n+        assertSame(ColorEnum.BLUE, ColorEnum.getEnum(\"Blue\"));\n+        assertSame(null, ColorEnum.getEnum(\"Pink\"));\n+    }\n+\n+    public void testSerialization() {\n+        int hashCode = ColorEnum.RED.hashCode();\n+        assertSame(ColorEnum.RED, SerializationUtils.clone(ColorEnum.RED));\n+        assertEquals(hashCode, SerializationUtils.clone(ColorEnum.RED).hashCode());\n+        assertSame(ColorEnum.GREEN, SerializationUtils.clone(ColorEnum.GREEN));\n+        assertSame(ColorEnum.BLUE, SerializationUtils.clone(ColorEnum.BLUE));\n+    }\n+\n+    public void testBroken1() {\n+        try {\n+            Broken1Enum.RED.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken2() {\n+        try {\n+            Broken2Enum.RED.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken3() {\n+        try {\n+            Broken3Enum.RED.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken1Operation() {\n+        try {\n+            Broken1OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken2Operation() {\n+        try {\n+            Broken2OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken3Operation() {\n+        try {\n+            Broken3OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken4Operation() {\n+        try {\n+            Broken4OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testBroken5Operation() {\n+        try {\n+            Broken5OperationEnum.PLUS.getName();\n+            fail();\n+        } catch (ExceptionInInitializerError ex) {\n+            assertTrue(ex.getException() instanceof IllegalArgumentException);\n+        }\n+    }\n+\n+    public void testOperationGet() {\n+        assertSame(OperationEnum.PLUS, OperationEnum.getEnum(\"Plus\"));\n+        assertSame(OperationEnum.MINUS, OperationEnum.getEnum(\"Minus\"));\n+        assertSame(null, OperationEnum.getEnum(\"Pink\"));\n+    }\n+\n+    public void testOperationSerialization() {\n+        assertSame(OperationEnum.PLUS, SerializationUtils.clone(OperationEnum.PLUS));\n+        assertSame(OperationEnum.MINUS, SerializationUtils.clone(OperationEnum.MINUS));\n+    }\n+\n+    public void testOperationToString() {\n+        assertEquals(\"OperationEnum[Plus]\", OperationEnum.PLUS.toString());\n+    }\n+\n+    public void testOperationList() {\n+        List list = OperationEnum.getEnumList();\n+        assertNotNull(list);\n+        assertEquals(2, list.size());\n+        assertEquals(list.size(), OperationEnum.getEnumMap().keySet().size());\n+        \n+        Iterator it = list.iterator();\n+        assertSame(OperationEnum.PLUS, it.next());\n+        assertSame(OperationEnum.MINUS, it.next());\n+    }\n+\n+    public void testOperationMap() {\n+        Map map = OperationEnum.getEnumMap();\n+        assertNotNull(map);\n+        assertEquals(map.keySet().size(), OperationEnum.getEnumList().size());\n+        \n+        assertTrue(map.containsValue(OperationEnum.PLUS));\n+        assertTrue(map.containsValue(OperationEnum.MINUS));\n+        assertSame(OperationEnum.PLUS, map.get(\"Plus\"));\n+        assertSame(OperationEnum.MINUS, map.get(\"Minus\"));\n+    }\n+\n+    public void testOperationCalculation() {\n+        assertEquals(3, OperationEnum.PLUS.eval(1, 2));\n+        assertEquals(-1, OperationEnum.MINUS.eval(1, 2));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testExtended1Get() {\n+        assertSame(Extended1Enum.ALPHA, Extended1Enum.getEnum(\"Alpha\"));\n+        assertSame(Extended1Enum.BETA, Extended1Enum.getEnum(\"Beta\"));\n+        assertSame(null, Extended1Enum.getEnum(\"Gamma\"));\n+        assertSame(null, Extended1Enum.getEnum(\"Delta\"));\n+    }\n+            \n+    public void testExtended2Get() {\n+        assertSame(Extended1Enum.ALPHA, Extended2Enum.ALPHA);\n+        assertSame(Extended1Enum.BETA, Extended2Enum.BETA);\n+        \n+        assertSame(Extended2Enum.ALPHA, Extended2Enum.getEnum(\"Alpha\"));\n+        assertSame(Extended2Enum.BETA, Extended2Enum.getEnum(\"Beta\"));\n+        assertSame(Extended2Enum.GAMMA, Extended2Enum.getEnum(\"Gamma\"));\n+        assertSame(null, Extended2Enum.getEnum(\"Delta\"));\n+    }\n+\n+    public void testExtended3Get() {\n+        assertSame(Extended2Enum.ALPHA, Extended3Enum.ALPHA);\n+        assertSame(Extended2Enum.BETA, Extended3Enum.BETA);\n+        assertSame(Extended2Enum.GAMMA, Extended3Enum.GAMMA);\n+        \n+        assertSame(Extended3Enum.ALPHA, Extended3Enum.getEnum(\"Alpha\"));\n+        assertSame(Extended3Enum.BETA, Extended3Enum.getEnum(\"Beta\"));\n+        assertSame(Extended3Enum.GAMMA, Extended3Enum.getEnum(\"Gamma\"));\n+        assertSame(Extended3Enum.DELTA, Extended3Enum.getEnum(\"Delta\"));\n+    }\n+\n+    public void testExtendedSerialization() {\n+        assertSame(Extended1Enum.ALPHA, SerializationUtils.clone(Extended1Enum.ALPHA));\n+        assertSame(Extended1Enum.BETA, SerializationUtils.clone(Extended1Enum.BETA));\n+        assertSame(Extended2Enum.GAMMA, SerializationUtils.clone(Extended2Enum.GAMMA));\n+        assertSame(Extended3Enum.DELTA, SerializationUtils.clone(Extended3Enum.DELTA));\n+    }\n+\n+    public void testExtendedToString() {\n+        assertEquals(\"Extended1Enum[Alpha]\", Extended1Enum.ALPHA.toString());\n+        assertEquals(\"Extended1Enum[Beta]\", Extended1Enum.BETA.toString());\n+        \n+        assertEquals(\"Extended1Enum[Alpha]\", Extended2Enum.ALPHA.toString());\n+        assertEquals(\"Extended1Enum[Beta]\", Extended2Enum.BETA.toString());\n+        assertEquals(\"Extended2Enum[Gamma]\", Extended2Enum.GAMMA.toString());\n+        \n+        assertEquals(\"Extended1Enum[Alpha]\", Extended3Enum.ALPHA.toString());\n+        assertEquals(\"Extended1Enum[Beta]\", Extended3Enum.BETA.toString());\n+        assertEquals(\"Extended2Enum[Gamma]\", Extended3Enum.GAMMA.toString());\n+        assertEquals(\"Extended3Enum[Delta]\", Extended3Enum.DELTA.toString());\n+    }\n+\n+    public void testExtended1List() {\n+        List list = Extended1Enum.getEnumList();\n+        assertNotNull(list);\n+        assertEquals(2, list.size());\n+        assertEquals(list.size(), Extended1Enum.getEnumMap().keySet().size());\n+        \n+        Iterator it = list.iterator();\n+        assertSame(Extended1Enum.ALPHA, it.next());\n+        assertSame(Extended1Enum.BETA, it.next());\n+    }\n+\n+    public void testExtended2List() {\n+        List list = Extended2Enum.getEnumList();\n+        assertNotNull(list);\n+        assertEquals(3, list.size());\n+        assertEquals(list.size(), Extended2Enum.getEnumMap().keySet().size());\n+        \n+        Iterator it = list.iterator();\n+        assertSame(Extended2Enum.ALPHA, it.next());\n+        assertSame(Extended2Enum.BETA, it.next());\n+        assertSame(Extended2Enum.GAMMA, it.next());\n+    }\n+\n+    public void testExtended3List() {\n+        List list = Extended3Enum.getEnumList();\n+        assertNotNull(list);\n+        assertEquals(4, list.size());\n+        assertEquals(list.size(), Extended3Enum.getEnumMap().keySet().size());\n+        \n+        Iterator it = list.iterator();\n+        assertSame(Extended3Enum.ALPHA, it.next());\n+        assertSame(Extended3Enum.BETA, it.next());\n+        assertSame(Extended3Enum.GAMMA, it.next());\n+        assertSame(Extended3Enum.DELTA, it.next());\n+    }\n+\n+    public void testExtended1Map() {\n+        Map map = Extended1Enum.getEnumMap();\n+        assertNotNull(map);\n+        assertEquals(map.keySet().size(), Extended1Enum.getEnumList().size());\n+        \n+        assertTrue(map.containsValue(Extended1Enum.ALPHA));\n+        assertTrue(map.containsValue(Extended1Enum.BETA));\n+        assertSame(Extended1Enum.ALPHA, map.get(\"Alpha\"));\n+        assertSame(Extended1Enum.BETA, map.get(\"Beta\"));\n+    }\n+\n+    public void testExtended2Map() {\n+        Map map = Extended2Enum.getEnumMap();\n+        assertNotNull(map);\n+        assertEquals(map.keySet().size(), Extended2Enum.getEnumList().size());\n+        \n+        assertTrue(map.containsValue(Extended2Enum.ALPHA));\n+        assertTrue(map.containsValue(Extended2Enum.BETA));\n+        assertTrue(map.containsValue(Extended2Enum.GAMMA));\n+        assertSame(Extended2Enum.ALPHA, map.get(\"Alpha\"));\n+        assertSame(Extended2Enum.BETA, map.get(\"Beta\"));\n+        assertSame(Extended2Enum.GAMMA, map.get(\"Gamma\"));\n+    }\n+\n+    public void testExtended3Map() {\n+        Map map = Extended3Enum.getEnumMap();\n+        assertNotNull(map);\n+        assertEquals(map.keySet().size(), Extended3Enum.getEnumList().size());\n+        \n+        assertTrue(map.containsValue(Extended3Enum.ALPHA));\n+        assertTrue(map.containsValue(Extended3Enum.BETA));\n+        assertTrue(map.containsValue(Extended3Enum.GAMMA));\n+        assertTrue(map.containsValue(Extended3Enum.DELTA));\n+        assertSame(Extended3Enum.ALPHA, map.get(\"Alpha\"));\n+        assertSame(Extended3Enum.BETA, map.get(\"Beta\"));\n+        assertSame(Extended3Enum.GAMMA, map.get(\"Gamma\"));\n+        assertSame(Extended3Enum.DELTA, map.get(\"Delta\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNested() {\n+        List list = new ArrayList(Nest.ColorEnum.getEnumList());\n+        assertEquals(3, list.size());  // all is well\n+        Iterator it = list.iterator();\n+        assertSame(Nest.ColorEnum.RED, it.next());\n+        assertSame(Nest.ColorEnum.GREEN, it.next());\n+        assertSame(Nest.ColorEnum.BLUE, it.next());\n+        // This nesting works because the enum constants are defined in the SAME\n+        // class as the getEnumList(). It just acts as a normal enum.\n+    }\n+\n+    public void testNestedBroken() {\n+        List list = new ArrayList(NestBroken.ColorEnum.getEnumList());\n+        try {\n+            assertEquals(0, list.size());  // no enums!!! \n+            // this is BROKEN because the enum constants are defined in a DIFFERENT\n+            // class from getEnumList(). Once NestBroken class is referenced,\n+            // and thus class loaded with its enum constants, the getEnumList works:\n+        } catch (AssertionFailedError ex) {\n+            // this actually works and isn't broken on Linux SunJDK1.4.1, so...\n+            assertEquals(3, list.size());\n+        }\n+        new NestBroken();\n+        list = new ArrayList(NestBroken.ColorEnum.getEnumList());\n+        assertEquals(3, list.size());  // all is well!!!\n+        Iterator it = list.iterator();\n+        assertSame(NestBroken.RED, it.next());\n+        assertSame(NestBroken.GREEN, it.next());\n+        assertSame(NestBroken.BLUE, it.next());\n+    }\n+\n+    public void testNestedLinked() {\n+        List list = new ArrayList(NestLinked.ColorEnum.getEnumList());\n+        assertEquals(3, list.size());  // all is well\n+        Iterator it = list.iterator();\n+        assertSame(NestLinked.RED, it.next());\n+        assertSame(NestLinked.GREEN, it.next());\n+        assertSame(NestLinked.BLUE, it.next());\n+        // This nesting works because a static block in the enum class forces a\n+        // class load of the outer class which defines the enum constants.\n+    }\n+\n+    public void testNestedReferenced() {\n+        List list = new ArrayList(NestReferenced.ColorEnum.getEnumList());\n+        assertEquals(3, list.size());  // all is well\n+        Iterator it = list.iterator();\n+        assertSame(NestReferenced.RED, it.next());\n+        assertSame(NestReferenced.GREEN, it.next());\n+        assertSame(NestReferenced.BLUE, it.next());\n+        // This nesting works because the enum constants are actually defined in\n+        // the SAME class as the getEnumList(). The references in the outer class\n+        // are just extra references.\n+    }\n+    \n+    public void testColorEnumEqualsWithDifferentClassLoaders() throws SecurityException, IllegalArgumentException,\n+            ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        this.testWithDifferentClassLoaders(ColorEnum.BLUE);\n+        this.testWithDifferentClassLoaders(ColorEnum.GREEN);\n+        this.testWithDifferentClassLoaders(ColorEnum.RED);\n+    }\n+\n+    void testWithDifferentClassLoaders(ColorEnum colorEnum) throws ClassNotFoundException, SecurityException,\n+            NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+        // Sanity checks:\n+        assertTrue(colorEnum.equals(colorEnum));\n+        assertNotNull(ColorEnum.class.getClassLoader());\n+        // set up:\n+        ClassLoader classLoader = ClassUtilsTest.newSystemClassLoader();\n+        Object enumObjectFromOtherClassLoader = this.getColorEnum(classLoader, colorEnum.getName());\n+\n+        // the real test, part 1.\n+        try {\n+            ColorEnum testCase = (ColorEnum) enumObjectFromOtherClassLoader;\n+            fail(\"Should have thrown a ClassCastException for \" + testCase);\n+        } catch (ClassCastException e) {\n+            // normal.\n+        }\n+\n+        // the real test, part 2.\n+        assertEquals(\"The two objects should match even though they are from different class loaders\", colorEnum,\n+                enumObjectFromOtherClassLoader);\n+\n+        // the real test, part 3 - testing equals(Object)\n+        int falseCount = 0;\n+        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {\n+            ColorEnum element = (ColorEnum) iter.next();\n+            if (!colorEnum.equals(element)) {\n+                falseCount++;\n+                assertFalse(enumObjectFromOtherClassLoader.equals(element));\n+            }\n+        }\n+        assertEquals(ColorEnum.getEnumList().size() - 1, falseCount);\n+\n+        // the real test, part 4 - testing compareTo(Object) == 0\n+        falseCount = 0;\n+        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {\n+            ColorEnum element = (ColorEnum) iter.next();\n+            if (!colorEnum.equals(element)) {\n+                falseCount++;\n+                assertFalse( ((Comparable)enumObjectFromOtherClassLoader).compareTo(element) == 0);\n+            }\n+        }\n+        assertEquals(ColorEnum.getEnumList().size() - 1, falseCount);\n+    }\n+\n+    Object getColorEnum(ClassLoader classLoader, String color) throws ClassNotFoundException, SecurityException,\n+            NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+        // Sanity check:\n+        ColorEnum.RED.equals(ColorEnum.RED);\n+        assertNotNull(ColorEnum.class.getClassLoader());\n+        // set up:\n+        assertNotNull(classLoader);\n+        assertFalse(classLoader.equals(ColorEnum.class.getClassLoader()));\n+        Class otherColorEnumClass = null;\n+        try {\n+            otherColorEnumClass = classLoader.loadClass(ENUMS_CLASS_NAME);\n+        } catch (ClassNotFoundException e) {\n+            // Dump some information to help debug class loader issues under different JREs, Ant, Eclipse.\n+            System.err.println(\"Could not load \" + ENUMS_CLASS_NAME + \" from the class loader \" + classLoader);\n+            URLClassLoader urlCl = (URLClassLoader) classLoader;\n+            URL[] urls = urlCl.getURLs();\n+            System.err.println(\"Class loader has \" + urls.length + \" URLs:\");\n+            for (int i = 0; i < urls.length; i++) {\n+                System.err.println(\"URL[\" + i + \"] = \" + urls[i]);\n+            }\n+            e.printStackTrace();\n+            throw e;\n+        }\n+        assertNotNull(otherColorEnumClass);\n+        assertNotNull(otherColorEnumClass.getClassLoader());\n+        assertTrue(classLoader.equals(otherColorEnumClass.getClassLoader()));\n+        assertFalse(otherColorEnumClass.getClassLoader().equals(ColorEnum.class.getClassLoader()));\n+        Method method = otherColorEnumClass.getMethod(\"getEnum\", new Class[]{String.class});\n+        Object enumObject = method.invoke(otherColorEnumClass, new Object[]{color});\n+        assertNotNull(enumObject);\n+        assertFalse(ColorEnum.class.equals(enumObject.getClass()));\n+        assertFalse(ColorEnum.class == enumObject.getClass());\n+        return enumObject;\n+    }\n+\n+    public void testEqualsToWrongInstance() {\n+        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {\n+            ColorEnum element = (ColorEnum) iter.next();\n+            this.testEqualsToWrongInstance(element);\n+        }\n+    }\n+\n+    void testEqualsToWrongInstance(ColorEnum colorEnum) {\n+        assertEquals(false, colorEnum.equals(\"test\"));\n+        assertEquals(false, colorEnum.equals(new Integer(1)));\n+        assertEquals(false, colorEnum.equals(new Boolean(true)));\n+        assertEquals(false, colorEnum.equals(new StringBuffer(\"test\")));\n+        assertEquals(false, colorEnum.equals(new Object()));\n+        assertEquals(false, colorEnum.equals(null));\n+        assertEquals(false, colorEnum.equals(\"\"));\n+        assertEquals(false, colorEnum.equals(ColorEnum.getEnum(null)));\n+        assertEquals(false, colorEnum.equals(ColorEnum.getEnum(\"\")));\n+        assertEquals(false, colorEnum.equals(ColorEnum.getEnum(\"This ColorEnum does not exist.\")));\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/EnumTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test suite for the Enum package.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public class EnumTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public EnumTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Enum Tests\");\n+        suite.addTest(EnumTest.suite());\n+        suite.addTest(EnumEqualsTest.suite());\n+        suite.addTest(EnumUtilsTest.suite());\n+        suite.addTest(ValuedEnumTest.suite());\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/EnumUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Enum} class.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+\n+public final class EnumUtilsTest extends TestCase {\n+\n+    public EnumUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EnumUtilsTest.class);\n+        suite.setName(\"EnumUtils Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new EnumUtils());\n+        Constructor[] cons = EnumUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(EnumUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(EnumUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIterator() {\n+        Iterator it = EnumUtils.iterator(ColorEnum.class);\n+        assertSame(ColorEnum.RED, it.next());\n+        assertSame(ColorEnum.GREEN, it.next());\n+        assertSame(ColorEnum.BLUE, it.next());\n+        it = EnumUtils.iterator(DummyEnum.class);\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    public void testIteratorEx() {\n+        try {\n+            EnumUtils.iterator(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.iterator(Object.class);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testList() {\n+        List list = EnumUtils.getEnumList(ColorEnum.class);\n+        Iterator it = list.iterator();\n+        assertSame(ColorEnum.RED, it.next());\n+        assertSame(ColorEnum.GREEN, it.next());\n+        assertSame(ColorEnum.BLUE, it.next());\n+        list = EnumUtils.getEnumList(DummyEnum.class);\n+        assertEquals(0, list.size());\n+    }\n+\n+    public void testListEx() {\n+        try {\n+            EnumUtils.getEnumList(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.getEnumList(Object.class);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMap() {\n+        Map map = EnumUtils.getEnumMap(ColorEnum.class);\n+        assertTrue(map.containsValue(ColorEnum.RED));\n+        assertTrue(map.containsValue(ColorEnum.GREEN));\n+        assertTrue(map.containsValue(ColorEnum.BLUE));\n+        assertSame(ColorEnum.RED, map.get(\"Red\"));\n+        assertSame(ColorEnum.GREEN, map.get(\"Green\"));\n+        assertSame(ColorEnum.BLUE, map.get(\"Blue\"));\n+        map = EnumUtils.getEnumMap(DummyEnum.class);\n+        assertEquals(0, map.size());\n+    }\n+\n+    public void testMapEx() {\n+        try {\n+            EnumUtils.getEnumMap(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.getEnumMap(Object.class);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGet() {\n+        assertSame(ColorEnum.RED, EnumUtils.getEnum(ColorEnum.class, \"Red\"));\n+        assertSame(ColorEnum.GREEN, EnumUtils.getEnum(ColorEnum.class, \"Green\"));\n+        assertSame(ColorEnum.BLUE, EnumUtils.getEnum(ColorEnum.class, \"Blue\"));\n+        assertSame(null, EnumUtils.getEnum(ColorEnum.class, \"Pink\"));\n+        assertSame(null, EnumUtils.getEnum(DummyEnum.class, \"Pink\"));\n+    }\n+\n+    public void testGetEx() {\n+        try {\n+            EnumUtils.getEnum(null, \"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.getEnum(Object.class, \"Red\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetValue() {\n+        assertSame(ValuedColorEnum.RED, EnumUtils.getEnum(ValuedColorEnum.class, 1));\n+        assertSame(ValuedColorEnum.GREEN, EnumUtils.getEnum(ValuedColorEnum.class, 2));\n+        assertSame(ValuedColorEnum.BLUE, EnumUtils.getEnum(ValuedColorEnum.class, 3));\n+        assertSame(null, EnumUtils.getEnum(ValuedColorEnum.class, 4));\n+        assertSame(null, EnumUtils.getEnum(DummyEnum.class, 5));\n+    }\n+\n+    public void testGetValueEx() {\n+        try {\n+            EnumUtils.getEnum(null, 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            EnumUtils.getEnum(Object.class, 2);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Extended1Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Base extended enumeration.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class Extended1Enum extends Enum {\n+    public static final Extended1Enum ALPHA = new Extended1Enum(\"Alpha\");\n+    public static final Extended1Enum BETA = new Extended1Enum(\"Beta\");\n+\n+    protected Extended1Enum(String name) {\n+        super(name);\n+    }\n+\n+    public static Extended1Enum getEnum(String name) {\n+        return (Extended1Enum) getEnum(Extended1Enum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Extended1Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Extended1Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Extended1Enum.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Extended2Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extended enumeration.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class Extended2Enum extends Extended1Enum {\n+    public static final Extended1Enum GAMMA = new Extended2Enum(\"Gamma\");\n+\n+    protected Extended2Enum(String color) {\n+        super(color);\n+    }\n+\n+    public static Extended1Enum getEnum(String name) {\n+        return (Extended1Enum) getEnum(Extended2Enum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(Extended2Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(Extended2Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(Extended2Enum.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Extended3Enum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Extended enumeration.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class Extended3Enum extends Extended2Enum {\n+    public static final Extended1Enum DELTA = new Extended3Enum(\"Delta\");\n+\n+    protected Extended3Enum(String name) {\n+        super(name);\n+    }\n+\n+    public static Extended1Enum getEnum(String name) {\n+        return (Extended1Enum) Enum.getEnum(Extended3Enum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return Enum.getEnumMap(Extended3Enum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return Enum.getEnumList(Extended3Enum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return Enum.iterator(Extended3Enum.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/Nest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration demonstrating a normal simple nesting case.\n+ * All is well here as the nested enum class is really no different\n+ * to any other class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+\n+public final class Nest {\n+    \n+    public Nest() {\n+        super();\n+    }\n+    \n+    public static final class ColorEnum extends Enum {\n+        public static final ColorEnum RED = new ColorEnum(\"Red\");\n+        public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+        public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+\n+        private ColorEnum(String color) {\n+            super(color);\n+        }\n+\n+        public static ColorEnum getEnum(String color) {\n+            return (ColorEnum) getEnum(ColorEnum.class, color);\n+        }\n+\n+        public static Map getEnumMap() {\n+            return getEnumMap(ColorEnum.class);\n+        }\n+\n+        public static List getEnumList() {\n+            return getEnumList(ColorEnum.class);\n+        }\n+\n+        public static Iterator iterator() {\n+            return iterator(ColorEnum.class);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/NestBroken.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration which demonstrates how to break the enum system.\n+ * <p>\n+ * The class loader sees the two classes here as independent - the enum\n+ * class is nested, not an inner class. Calling getEnumList() on ColorEnum\n+ * will return an empty list, unless and until the NestBroken class is\n+ * referenced.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+\n+public final class NestBroken {\n+    \n+    public static final ColorEnum RED = new ColorEnum(\"Red\");\n+    public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+    public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+    \n+    public NestBroken() {\n+        super();\n+    }\n+    \n+    public static final class ColorEnum extends Enum {\n+\n+        private ColorEnum(String color) {\n+            super(color);\n+        }\n+\n+        public static ColorEnum getEnum(String color) {\n+            return (ColorEnum) getEnum(ColorEnum.class, color);\n+        }\n+\n+        public static Map getEnumMap() {\n+            return getEnumMap(ColorEnum.class);\n+        }\n+\n+        public static List getEnumList() {\n+            return getEnumList(ColorEnum.class);\n+        }\n+\n+        public static Iterator iterator() {\n+            return iterator(ColorEnum.class);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/NestLinked.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration which demonstrates how to define the constants in a\n+ * different class to the Enum. The extra <code>static{}</code> block is\n+ * needed to ensure that the enum constants are created before the\n+ * static methods on the ColorEnum are used.\n+ * <p>\n+ * The class loader sees the two classes here as independent - the enum\n+ * class is nested, not an inner class. The static block thus forces the\n+ * class load of the outer class, which is needed to initialise the enums.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+\n+public final class NestLinked {\n+    \n+    public static final ColorEnum RED = new ColorEnum(\"Red\");\n+    public static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+    public static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+    \n+    public NestLinked() {\n+        super();\n+    }\n+    \n+    public static final class ColorEnum extends Enum {\n+\n+        static {\n+            // Explicitly reference the class where the enums are defined\n+            Object obj = NestLinked.RED;\n+        }\n+        \n+        private ColorEnum(String color) {\n+            super(color);\n+        }\n+\n+        public static ColorEnum getEnum(String color) {\n+            return (ColorEnum) getEnum(ColorEnum.class, color);\n+        }\n+\n+        public static Map getEnumMap() {\n+            return getEnumMap(ColorEnum.class);\n+        }\n+\n+        public static List getEnumList() {\n+            return getEnumList(ColorEnum.class);\n+        }\n+\n+        public static Iterator iterator() {\n+            return iterator(ColorEnum.class);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/NestReferenced.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration which demonstrates how to provide a view of the constants\n+ * in a different class to the Enum. This technique is the safest, however it\n+ * is obviously inconvenient as it involves defining two sets of constants.\n+ * See NestedLinked for an alternative.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+\n+public final class NestReferenced {\n+    \n+    public static final ColorEnum RED = ColorEnum.RED;\n+    public static final ColorEnum GREEN = ColorEnum.GREEN;\n+    public static final ColorEnum BLUE = ColorEnum.BLUE;\n+    \n+    public NestReferenced() {\n+        super();\n+    }\n+    \n+    public static final class ColorEnum extends Enum {\n+\n+        // must be defined here, not just in outer class\n+        private static final ColorEnum RED = new ColorEnum(\"Red\");\n+        private static final ColorEnum GREEN = new ColorEnum(\"Green\");\n+        private static final ColorEnum BLUE = new ColorEnum(\"Blue\");\n+        \n+        private ColorEnum(String color) {\n+            super(color);\n+        }\n+\n+        public static ColorEnum getEnum(String color) {\n+            return (ColorEnum) getEnum(ColorEnum.class, color);\n+        }\n+\n+        public static Map getEnumMap() {\n+            return getEnumMap(ColorEnum.class);\n+        }\n+\n+        public static List getEnumList() {\n+            return getEnumList(ColorEnum.class);\n+        }\n+\n+        public static Iterator iterator() {\n+            return iterator(ColorEnum.class);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/OperationEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Operator enumeration.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class OperationEnum extends Enum {\n+    // This syntax works for JDK 1.3 and upwards:\n+//    public static final OperationEnum PLUS = new OperationEnum(\"Plus\") {\n+//        public int eval(int a, int b) {\n+//            return (a + b);\n+//        }\n+//    };\n+//    public static final OperationEnum MINUS = new OperationEnum(\"Minus\") {\n+//        public int eval(int a, int b) {\n+//            return (a - b);\n+//        }\n+//    };\n+    // This syntax works for JDK 1.2 and upwards:\n+    public static final OperationEnum PLUS = new PlusOperation();\n+    private static class PlusOperation extends OperationEnum {\n+        private PlusOperation() {\n+            super(\"Plus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a + b);\n+        }\n+    }\n+    public static final OperationEnum MINUS = new MinusOperation();\n+    private static class MinusOperation extends OperationEnum {\n+        private MinusOperation() {\n+            super(\"Minus\");\n+        }\n+        public int eval(int a, int b) {\n+            return (a - b);\n+        }\n+    }\n+\n+    private OperationEnum(String name) {\n+        super(name);\n+    }\n+    \n+    public final Class getEnumClass() {\n+        return OperationEnum.class;\n+    }\n+\n+    public abstract int eval(int a, int b);\n+\n+    public static OperationEnum getEnum(String name) {\n+        return (OperationEnum) getEnum(OperationEnum.class, name);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(OperationEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(OperationEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(OperationEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/ValuedColorEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Color enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+\n+public final class ValuedColorEnum extends ValuedEnum {\n+    public static final ValuedColorEnum RED = new ValuedColorEnum(\"Red\", 1);\n+    public static final ValuedColorEnum GREEN = new ValuedColorEnum(\"Green\", 2);\n+    public static final ValuedColorEnum BLUE = new ValuedColorEnum(\"Blue\", 3);\n+\n+    private ValuedColorEnum(String color, int value) {\n+        super(color, value);\n+    }\n+\n+    public static ValuedColorEnum getEnum(String color) {\n+        return (ValuedColorEnum) getEnum(ValuedColorEnum.class, color);\n+    }\n+\n+    public static ValuedColorEnum getEnum(int value) {\n+        return (ValuedColorEnum) getEnum(ValuedColorEnum.class, value);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(ValuedColorEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(ValuedColorEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(ValuedColorEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/ValuedEnumTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.net.URLClassLoader;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import org.apache.commons.lang.SerializationUtils;\n+\n+/**\n+ * Test cases for the {@link Enum} class.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+\n+public final class ValuedEnumTest extends TestCase {\n+\n+    public ValuedEnumTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ValuedEnumTest.class);\n+        suite.setName(\"ValuedEnum Tests\");\n+        return suite;\n+    }\n+\n+    public void testName() {\n+        assertEquals(\"Red\", ValuedColorEnum.RED.getName());\n+        assertEquals(\"Green\", ValuedColorEnum.GREEN.getName());\n+        assertEquals(\"Blue\", ValuedColorEnum.BLUE.getName());\n+    }\n+\n+    public void testValue() {\n+        assertEquals(1, ValuedColorEnum.RED.getValue());\n+        assertEquals(2, ValuedColorEnum.GREEN.getValue());\n+        assertEquals(3, ValuedColorEnum.BLUE.getValue());\n+    }\n+\n+    public void testCompareTo() {\n+        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.BLUE) == 0);\n+        assertTrue(ValuedColorEnum.RED.compareTo(ValuedColorEnum.BLUE) < 0);\n+        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.RED) > 0);\n+    }\n+\n+    public void testCompareTo_classloader_equal() throws Exception {\n+        ClassLoader cl = ValuedColorEnum.class.getClassLoader();\n+        if (cl instanceof URLClassLoader) {\n+            URLClassLoader urlCL = (URLClassLoader) cl;\n+            URLClassLoader urlCL1 = new URLClassLoader(urlCL.getURLs(), null);\n+            URLClassLoader urlCL2 = new URLClassLoader(urlCL.getURLs(), null);\n+            Class otherEnumClass1 = urlCL1.loadClass(\"org.apache.commons.lang.enums.ValuedColorEnum\");\n+            Class otherEnumClass2 = urlCL2.loadClass(\"org.apache.commons.lang.enums.ValuedColorEnum\");\n+            Object blue1 = otherEnumClass1.getDeclaredField(\"BLUE\").get(null);\n+            Object blue2 = otherEnumClass2.getDeclaredField(\"BLUE\").get(null);\n+            assertTrue(((Comparable) blue1).compareTo(blue2) == 0);\n+        }\n+    }\n+\n+    public void testCompareTo_classloader_different() throws Exception {\n+        ClassLoader cl = ValuedColorEnum.class.getClassLoader();\n+        if (cl instanceof URLClassLoader) {\n+            URLClassLoader urlCL = (URLClassLoader) cl;\n+            URLClassLoader urlCL1 = new URLClassLoader(urlCL.getURLs(), null);\n+            URLClassLoader urlCL2 = new URLClassLoader(urlCL.getURLs(), null);\n+            Class otherEnumClass1 = urlCL1.loadClass(\"org.apache.commons.lang.enums.ValuedColorEnum\");\n+            Class otherEnumClass2 = urlCL2.loadClass(\"org.apache.commons.lang.enums.ValuedColorEnum\");\n+            Object blue1 = otherEnumClass1.getDeclaredField(\"BLUE\").get(null);\n+            Object blue2 = otherEnumClass2.getDeclaredField(\"RED\").get(null);\n+            assertTrue(((Comparable) blue1).compareTo(blue2) != 0);\n+        }\n+    }\n+\n+    public void testCompareTo_nonEnumType() {\n+        try {\n+            ValuedColorEnum.BLUE.compareTo(new TotallyUnrelatedClass(ValuedColorEnum.BLUE.getValue()));\n+            fail();\n+        } catch (ClassCastException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testCompareTo_otherEnumType() {\n+        try {\n+            ValuedColorEnum.BLUE.compareTo(ValuedLanguageEnum.ENGLISH);\n+            fail();\n+        } catch (ClassCastException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testCompareTo_otherType() {\n+        try {\n+            ValuedColorEnum.BLUE.compareTo(\"Blue\");\n+            fail();\n+        } catch (ClassCastException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testCompareTo_null() {\n+        try {\n+            ValuedColorEnum.BLUE.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testEquals() {\n+        assertSame(ValuedColorEnum.RED, ValuedColorEnum.RED);\n+        assertSame(ValuedColorEnum.getEnum(\"Red\"), ValuedColorEnum.RED);\n+    }\n+\n+    public void testEquals_classloader_equal() throws Exception {\n+        ClassLoader cl = ValuedColorEnum.class.getClassLoader();\n+        if (cl instanceof URLClassLoader) {\n+            URLClassLoader urlCL = (URLClassLoader) cl;\n+            URLClassLoader urlCL1 = new URLClassLoader(urlCL.getURLs(), null);\n+            URLClassLoader urlCL2 = new URLClassLoader(urlCL.getURLs(), null);\n+            Class otherEnumClass1 = urlCL1.loadClass(\"org.apache.commons.lang.enums.ValuedColorEnum\");\n+            Class otherEnumClass2 = urlCL2.loadClass(\"org.apache.commons.lang.enums.ValuedColorEnum\");\n+            Object blue1 = otherEnumClass1.getDeclaredField(\"BLUE\").get(null);\n+            Object blue2 = otherEnumClass2.getDeclaredField(\"BLUE\").get(null);\n+            assertEquals(true, blue1.equals(blue2));\n+        }\n+    }\n+\n+    public void testEquals_classloader_different() throws Exception {\n+        ClassLoader cl = ValuedColorEnum.class.getClassLoader();\n+        if (cl instanceof URLClassLoader) {\n+            URLClassLoader urlCL = (URLClassLoader) cl;\n+            URLClassLoader urlCL1 = new URLClassLoader(urlCL.getURLs(), null);\n+            URLClassLoader urlCL2 = new URLClassLoader(urlCL.getURLs(), null);\n+            Class otherEnumClass1 = urlCL1.loadClass(\"org.apache.commons.lang.enums.ValuedColorEnum\");\n+            Class otherEnumClass2 = urlCL2.loadClass(\"org.apache.commons.lang.enums.ValuedColorEnum\");\n+            Object blue1 = otherEnumClass1.getDeclaredField(\"BLUE\").get(null);\n+            Object blue2 = otherEnumClass2.getDeclaredField(\"RED\").get(null);\n+            assertEquals(false, blue1.equals(blue2));\n+        }\n+    }\n+\n+    public void testToString() {\n+        String toString = ValuedColorEnum.RED.toString();\n+        assertEquals(\"ValuedColorEnum[Red=1]\", toString);\n+        assertSame(toString, ValuedColorEnum.RED.toString());\n+    }\n+\n+    public void testIterator() {\n+        Iterator it = ValuedColorEnum.iterator();\n+        assertSame(ValuedColorEnum.RED, it.next());\n+        assertSame(ValuedColorEnum.GREEN, it.next());\n+        assertSame(ValuedColorEnum.BLUE, it.next());\n+    }\n+\n+    public void testList() {\n+        List list = ValuedColorEnum.getEnumList();\n+        \n+        assertNotNull(list);\n+        \n+        assertEquals( list.size(),\n+                     ValuedColorEnum.getEnumMap().keySet().size());\n+        \n+        Iterator it = list.iterator();\n+        assertSame(ValuedColorEnum.RED, it.next());\n+        assertSame(ValuedColorEnum.GREEN, it.next());\n+        assertSame(ValuedColorEnum.BLUE, it.next());\n+    }\n+\n+    public void testMap() {\n+        Map map = ValuedColorEnum.getEnumMap();\n+        \n+        assertNotNull(map);\n+        \n+        assertEquals( map.keySet().size(),\n+                     ValuedColorEnum.getEnumList().size());\n+                     \n+        assertTrue(map.containsValue(ValuedColorEnum.RED));\n+        assertTrue(map.containsValue(ValuedColorEnum.GREEN));\n+        assertTrue(map.containsValue(ValuedColorEnum.BLUE));\n+        assertSame(ValuedColorEnum.RED, map.get(\"Red\"));\n+        assertSame(ValuedColorEnum.GREEN, map.get(\"Green\"));\n+        assertSame(ValuedColorEnum.BLUE, map.get(\"Blue\"));\n+    }\n+\n+    public void testGet() {\n+        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum(\"Red\"));\n+        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum(\"Green\"));\n+        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum(\"Blue\"));\n+        assertSame(null, ValuedColorEnum.getEnum(\"Pink\"));\n+    }\n+\n+    public void testGetValue() {\n+        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum(1));\n+        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum(2));\n+        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum(3));\n+        assertSame(null, ValuedColorEnum.getEnum(4));\n+    }\n+\n+    public void testSerialization() {\n+        assertSame(ValuedColorEnum.RED, SerializationUtils.clone(ValuedColorEnum.RED));\n+        assertSame(ValuedColorEnum.GREEN, SerializationUtils.clone(ValuedColorEnum.GREEN));\n+        assertSame(ValuedColorEnum.BLUE, SerializationUtils.clone(ValuedColorEnum.BLUE));\n+    }\n+\n+    //-----------------------------------------------------------------------s\n+    static class TotallyUnrelatedClass {\n+        private final int value;\n+\n+        public TotallyUnrelatedClass(final int value) {\n+            this.value = value;\n+        }\n+\n+        public int getValue() {\n+            return value;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/enums/ValuedLanguageEnum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.enums;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Language enumeration.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id$\n+ */\n+public final class ValuedLanguageEnum extends ValuedEnum {\n+    public static final ValuedLanguageEnum ENGLISH = new ValuedLanguageEnum(\"English\", 1);\n+    public static final ValuedLanguageEnum FRENCH = new ValuedLanguageEnum(\"French\", 2);\n+    public static final ValuedLanguageEnum GERMAN = new ValuedLanguageEnum(\"German\", 3);\n+\n+    private ValuedLanguageEnum(String color, int value) {\n+        super(color, value);\n+    }\n+\n+    public static ValuedLanguageEnum getEnum(String color) {\n+        return (ValuedLanguageEnum) getEnum(ValuedLanguageEnum.class, color);\n+    }\n+\n+    public static ValuedLanguageEnum getEnum(int value) {\n+        return (ValuedLanguageEnum) getEnum(ValuedLanguageEnum.class, value);\n+    }\n+\n+    public static Map getEnumMap() {\n+        return getEnumMap(ValuedLanguageEnum.class);\n+    }\n+\n+    public static List getEnumList() {\n+        return getEnumList(ValuedLanguageEnum.class);\n+    }\n+\n+    public static Iterator iterator() {\n+        return iterator(ValuedLanguageEnum.class);\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/exception/AbstractNestableTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+import junit.framework.TestCase;\n+/**\n+ * Tests implementations of the org.apache.commons.lang.exception.Nestable\n+ * interface.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id$\n+ */\n+public abstract class AbstractNestableTestCase extends TestCase\n+{\n+\n+    /**\n+     * Constructs an instance of\n+     * <code>AbstractNestableTestCase</code>.\n+     *\n+     * @param name the test name\n+     */\n+    public AbstractNestableTestCase(String name)\n+    {\n+        super(name);\n+    }\n+    \n+    /**\n+     * Tests the getCause() operation.\n+     */\n+    public void testGetCause()\n+    {\n+        Nestable ne1 = getNestable();\n+        assertNull(\"nestable exception() cause is null\", ne1.getCause()); \n+        \n+        Nestable ne2 = getNestable(\"ne2\");\n+        assertNull(\"nestable exception(\\\"ne2\\\") cause is null\", ne2.getCause());\n+        \n+        Nestable ne3 = getNestable(getThrowable(\"ne3 exception\"));\n+        assertNotNull(\"nestable exception(Throwable(\\\"ne3 exception\\\") cause is not null\",\n+            ne3.getCause()); \n+        assertTrue(\"nestable exception(Throwable(\\\"ne3 exception\\\") cause message == ne3 exception\",\n+            ne3.getCause().getMessage().equals(\"ne3 exception\")); \n+        \n+        Nestable ne4 = getNestable(\"ne4\", getThrowable(\"ne4 exception\"));\n+        assertNotNull(\"nestable exception(\\\"ne4\\\", Throwable(\\\"ne4 exception\\\") cause is not null\", \n+            ne4.getCause()); \n+        \n+        Nestable ne5 = getNestable(\"ne5\", (Throwable) null);\n+        assertNull(\"nestable exception(\\\"ne5\\\", null) cause is null\", \n+            ne5.getCause()); \n+        \n+        Nestable ne6 = getNestable(null, getThrowable(\"ne6 exception\"));\n+        assertNotNull(\"nestable exception(null, Throwable(\\\"ne6 exception\\\") cause is not null\", \n+            ne6.getCause()); \n+    }\n+\n+    /**\n+     * Tests the getThrowableCount() operation.\n+     */\n+    public void testGetThrowableCount()\n+    {\n+        Nestable ne1 = getNestable();\n+        assertEquals(\"ne1 throwable count\", 1, ne1.getThrowableCount());\n+\n+        Nestable ne2 = getNestable(\"ne2\");\n+        assertEquals(\"ne2 throwable count\", 1, ne2.getThrowableCount());\n+        \n+        Nestable ne3 = getNestable(getThrowable(\"ne3 exception\"));\n+        assertEquals(\"ne3 throwable count\", 2, ne3.getThrowableCount());\n+        \n+        Nestable ne4 = getNestable(\"ne4\", getThrowable(\"ne4 exception\"));\n+        assertEquals(\"ne4 throwable count\", 2, ne4.getThrowableCount());\n+        \n+        Nestable ne5 = getNestable(\"ne5\", (Throwable) null);\n+        assertEquals(\"ne 5 throwable count\", 1, ne5.getThrowableCount());\n+        \n+        Nestable ne6 = getNestable(null, getThrowable(\"ne6 exception\"));\n+        assertEquals(\"ne 6 throwable count\", 2, ne6.getThrowableCount());\n+        \n+        Nestable ne7 = getNestable(\"ne7o\", getNestable(\"ne7i\", getThrowable(\"ne7 exception\")));\n+        assertEquals(\"ne 7 throwable count\", 3, ne7.getThrowableCount());\n+\n+        Nestable ne8 = getNestable(\"level 1\", getNestable(\"level 2\", getNestable(getNestable(\"level 4\", getThrowable(\"level 5\")))));\n+        assertEquals(\"ne 8 throwable count\", 5, ne8.getThrowableCount());\n+    }\n+    \n+    /**\n+     * Tests the getMessage() operation.\n+     */\n+    public void testGetMessage()\n+    {\n+        Nestable ne1 = getNestable();\n+        assertNull(\"nestable exception() message is null\", ne1.getMessage()); \n+\n+        Nestable ne2 = getNestable(\"ne2\");\n+        assertNotNull(\"nestable exception(\\\"ne2\\\") message is not null\", ne2.getMessage());\n+        assertEquals(\"nestable exception(\\\"ne2\\\") message == ne2\", ne2.getMessage(), \"ne2\");\n+        \n+        Nestable ne3 = getNestable(getThrowable(\"ne3 exception\"));\n+        assertNotNull(\"nestable exception(Throwable(\\\"ne3 exception\\\") message is not null\",\n+            ne3.getMessage()); \n+        assertEquals(\"nestable exception(Throwable(\\\"ne3 exception\\\") message equals cause.toString()\",\n+            ne3.getMessage(), ne3.getCause().toString()); \n+        \n+        Nestable ne4 = getNestable(\"ne4\", getThrowable(\"ne4 exception\"));\n+        assertNotNull(\"nestable exception(\\\"ne4\\\", Throwable(\\\"ne4 exception\\\") message is not null\", \n+            ne4.getMessage()); \n+        assertEquals(\"nestable exception(\\\"ne4\\\", Throwable(\\\"ne4 exception\\\") message == ne4\", \n+            ne4.getMessage(), \"ne4\"); \n+        \n+        Nestable ne5 = getNestable(\"ne5\", (Throwable) null);\n+        assertNotNull(\"nestable exception(\\\"ne5\\\", null) message is not null\", \n+            ne5.getMessage()); \n+        assertEquals(\"nestable exception(\\\"ne5\\\", null) message == ne5\", \n+            ne5.getMessage(), \"ne5\"); \n+        \n+        Throwable t6 = getThrowable(\"ne6 exception\");\n+        Nestable ne6 = getNestable(null, t6);\n+        assertNotNull(\"nestable exception(null, Throwable(\\\"ne6 exception\\\") message is not null\",\n+            ne6.getMessage()); \n+        assertEquals(\"nestable exception(null, Throwable(\\\"ne6 exception\\\") message equals cause.toString()\",\n+            ne6.getMessage(), ne6.getCause().toString()); \n+        \n+        Nestable ne7 = getNestable(\"ne7o\", getNestable(\"ne7i\", getThrowable(\"ne7 exception\")));\n+        assertEquals(\"nestable exception(\\\"ne7o\\\", getNestable(\\\"ne7i\\\", Throwable(\\\"ne7 exception\\\"))) message is ne7o: ne7i: ne7 exception\",\n+            ne7.getMessage(), \"ne7o\");\n+\n+        Nestable ne8 = getNestable();\n+        assertNull(\"nestable exception() message is null\",\n+            ne8.getMessage());\n+\n+    }\n+\n+    /**\n+     * Tests the getMessage(int) operation.\n+     */\n+    public void testGetMessageI()\n+    {\n+        String[] msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        Nestable ne = getNestable(msgs[0], getNestable(msgs[1], getNestable(getNestable(msgs[3], getThrowable(msgs[4])))));\n+        for(int i = 0; i < msgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, msgs[i], ne.getMessage(i));\n+        }\n+        \n+        // Test for index out of bounds\n+        try\n+        {\n+            String msg = ne.getMessage(-1);\n+            fail(\"getMessage(-1) should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException ioode)\n+        {\n+        }\n+        try\n+        {\n+            String msg = ne.getMessage(msgs.length + 100);\n+            fail(\"getMessage(999) should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException ioode)\n+        {\n+        }\n+    }\n+\n+    /**\n+     * Tests the getMessages() operation.\n+     */\n+    public void testGetMessages()\n+    {\n+        String[] msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        Nestable ne = getNestable(msgs[0], getNestable(msgs[1], getNestable(getNestable(msgs[3], getThrowable(msgs[4])))));\n+        String[] nMsgs = ne.getMessages();\n+        assertEquals(\"messages length\", msgs.length, nMsgs.length);\n+        for(int i = 0; i < nMsgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, msgs[i], nMsgs[i]);\n+        }\n+    }\n+\n+    /**\n+     * Tests the getThrowable(int) operation.\n+     */\n+    public void testGetThrowableI()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = getTester1Class();\n+        throwables[1] = getThrowableClass();\n+        n = getTester1(getThrowable(msgs[1]));\n+        doNestableExceptionGetThrowableI(n, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = getTester1Class();\n+        throwables[1] = getTester2Class();\n+        throwables[2] = getTester1Class();\n+        throwables[3] = getTester2Class();\n+        throwables[4] = getThrowableClass();        \n+        n = getTester1(msgs[0], getTester2(msgs[1], getTester1(getTester2(msgs[3], getThrowable(msgs[4])))));\n+        doNestableExceptionGetThrowableI(n, throwables, msgs);\n+    }\n+    \n+    private void doNestableExceptionGetThrowableI(Nestable n, Class[] classes, String[] msgs)\n+    {\n+        Throwable t = null;\n+        String msg = null;\n+\n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            t = n.getThrowable(i);\n+            assertEquals(\"throwable class\", classes[i], t.getClass());\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+        \n+        // Test for index out of bounds\n+        try\n+        {\n+            t = n.getThrowable(-1);\n+            fail(\"getThrowable(-1) should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException ioobe)\n+        {\n+        }\n+        try\n+        {\n+            t = n.getThrowable(999);\n+            fail(\"getThrowable(999) should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException ioobe)\n+        {\n+        }\n+    }\n+\n+    /**\n+     * Tests the getThrowables() operation.\n+     */\n+    public void testGetThrowables()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = getTester1Class();\n+        throwables[1] = getThrowableClass();\n+        n = getTester1(getThrowable(msgs[1]));\n+        doNestableExceptionGetThrowables(n, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = getTester1Class();\n+        throwables[1] = getTester2Class();\n+        throwables[2] = getTester1Class();\n+        throwables[3] = getTester2Class();\n+        throwables[4] = getThrowableClass();\n+        n = getTester1(msgs[0], getTester2(msgs[1], getTester1(getTester2(msgs[3], getThrowable(msgs[4])))));\n+        doNestableExceptionGetThrowables(n, throwables, msgs);\n+    }\n+    \n+    private void doNestableExceptionGetThrowables(Nestable n, Class[] classes, String[] msgs)\n+    {\n+        String msg = null;\n+\n+        Throwable throwables[] = n.getThrowables();\n+        assertEquals(\"throwables length\", classes.length, throwables.length);\n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            assertEquals(\"throwable class\", classes[i], throwables[i].getClass());\n+            Throwable t = throwables[i];\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+    }\n+\n+    /**\n+     * Tests the indexOfThrowable() operation.\n+     */\n+    public void testIndexOfThrowable()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = getTester1Class();\n+        throwables[1] = getTester2Class();\n+        throwables[2] = getTester1Class();\n+        throwables[3] = getTester2Class();\n+        throwables[4] = getThrowableClass();\n+        int[] indexes = {0, 1, 0, 1, 4};\n+        n = getTester1(msgs[0], getTester2(msgs[1], getTester1(getTester2(msgs[3], getThrowable(msgs[4])))));\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            doNestableExceptionIndexOfThrowable(n, throwables[i], indexes[i], msgs[indexes[i]]);\n+        }\n+        doNestableExceptionIndexOfThrowable(n, getBaseThrowableClass(), 0, msgs[0]);\n+        doNestableExceptionIndexOfThrowable(n, java.util.Date.class, -1, null);\n+        doNestableExceptionIndexOfThrowable(n, null, -1, null);\n+    }\n+    \n+    private void doNestableExceptionIndexOfThrowable(Nestable n, Class type, int expectedIndex, String expectedMsg)\n+    {\n+        Throwable t = null;\n+        \n+        int index = n.indexOfThrowable(type);\n+        assertEquals(\"index of throwable \" + (type == null ? \"null\" : type.getName()), expectedIndex, index);\n+        if(expectedIndex > -1)\n+        {\n+            t = n.getThrowable(index);\n+            if(expectedMsg != null)\n+            {\n+                String msg = null;\n+                if(Nestable.class.isInstance(t))\n+                {\n+                    msg = ((Nestable) t).getMessage(0);\n+                }\n+                else\n+                {\n+                    msg = t.getMessage();\n+                }\n+                assertEquals(\"message of indexed throwable\", expectedMsg, msg);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Tests the indexOfThrowable(int) operation.\n+     */\n+    public void testIndexOfThrowableI()\n+    {\n+        Nestable n = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = getTester1Class();\n+        throwables[1] = getTester2Class();\n+        throwables[2] = getTester1Class();\n+        throwables[3] = getTester2Class();\n+        throwables[4] = getThrowableClass();\n+        int[] indexes = {0, 1, 0, 1, 4};\n+        n = getTester1(msgs[0], getTester2(msgs[1], getTester1(getTester2(msgs[3], getThrowable(msgs[4])))));\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            doNestableExceptionIndexOfThrowableI(n, throwables[i], 0, indexes[i], msgs[indexes[i]]);\n+        }\n+        doNestableExceptionIndexOfThrowableI(n, getTester2Class(), 2, 3, msgs[3]);\n+        doNestableExceptionIndexOfThrowableI(n, getTester1Class(), 1, 2, msgs[2]);\n+        doNestableExceptionIndexOfThrowableI(n, getTester1Class(), 3, -1, null);\n+        doNestableExceptionIndexOfThrowableI(n, getTester1Class(), 4, -1, null);\n+        doNestableExceptionIndexOfThrowableI(n, getThrowableClass(), 2, 4, msgs[4]);\n+        doNestableExceptionIndexOfThrowableI(n, java.util.Date.class, 0, -1, null);\n+        doNestableExceptionIndexOfThrowableI(n, null, 0, -1, null);\n+        \n+        // Test for index out of bounds\n+        try\n+        {\n+            int index = n.indexOfThrowable(getTester1Class(), -1);\n+            fail(\"method should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException iooob)\n+        {\n+        }\n+        try\n+        {\n+            int index = n.indexOfThrowable(getTester1Class(), 5);\n+            fail(\"method should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException iooob)\n+        {\n+        }\n+        \n+    }\n+\n+    private void doNestableExceptionIndexOfThrowableI(Nestable n, Class type, int fromIndex, int expectedIndex, String expectedMsg)\n+    {\n+        Throwable t = null;\n+        \n+        int index = n.indexOfThrowable(type, fromIndex);\n+        assertEquals(\"index of throwable \" + (type == null ? \"null\" : type.getName()), expectedIndex, index);\n+        if(expectedIndex > -1)\n+        {\n+            t = n.getThrowable(index);\n+            if(expectedMsg != null)\n+            {\n+                String msg = null;\n+                if(Nestable.class.isInstance(t))\n+                {\n+                    msg = ((Nestable) t).getMessage(0);\n+                }\n+                else\n+                {\n+                    msg = t.getMessage();\n+                }\n+                assertEquals(\"message of indexed throwable\", expectedMsg, msg);\n+            }\n+        }\n+        \n+    }\n+\n+    /**\n+     * Tests the printPartialStackTrace() operation.\n+     */\n+    public void testPrintPartialStackTrace()\n+    {\n+        Nestable ne9 = getNestable(\"ne9\", getThrowable(\"ne9 exception\"));\n+        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\n+        PrintStream ps2 = new PrintStream(baos2);\n+        PrintWriter pw2 = new PrintWriter(ps2, true);\n+        ne9.printPartialStackTrace(pw2);\n+        String stack2 = baos2.toString();\n+        String startsWith = ne9.getClass().getName() + \": ne9\";\n+        assertTrue(\"stack trace startsWith == \" + startsWith,\n+            stack2.startsWith(startsWith));\n+        assertEquals(\"stack trace indexOf rethrown == -1\",\n+            stack2.indexOf(\"rethrown\"), -1);\n+    }\n+\n+    /**\n+     * Tests the printStackTrace() operation.\n+     */\n+    public void testPrintStackTrace()\n+    {\n+        Nestable ne8 = getNestable(\"ne8\", getThrowable(\"ne8 exception\"));\n+        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();\n+        PrintStream ps1 = new PrintStream(baos1);\n+        PrintWriter pw1 = new PrintWriter(ps1, true);\n+        ne8.printStackTrace(pw1);\n+        String stack1 = baos1.toString();\n+        String startsWith = ne8.getClass().getName() + \": ne8\";\n+        assertTrue(\"stack trace startsWith == \" + startsWith,\n+            stack1.startsWith(startsWith));\n+        String indexOf = getThrowableClass().getName() + \": ne8 exception\";\n+        assertTrue(\"stack trace indexOf \" + indexOf + \" > -1\",\n+            stack1.indexOf(indexOf) > -1); \n+    }\n+\n+    /**\n+     * Returns an instance of the <code>Nestable</code> implementation being\n+     * tested.\n+     *\n+     * @return the instance\n+     */\n+    public abstract Nestable getNestable();\n+    \n+    /**\n+     * Returns an instance of the <code>Nestable</code> implementation being\n+     * tested.\n+     *\n+     * @param n <code>Nestable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getNestable(Nestable n);\n+    \n+    /**\n+     * Returns an instance of the <code>Nestable</code> implementation being\n+     * tested.\n+     *\n+     * @param msg <code>String</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getNestable(String msg);\n+    \n+    /**\n+     * Returns an instance of the <code>Nestable</code> implementation being\n+     * tested.\n+     *\n+     * @param msg <code>String</code> argument to be provided to the instance\n+     * constructor\n+     * @param n <code>Nestable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getNestable(String msg, Nestable n);\n+    \n+    /**\n+     * Returns an instance of the <code>Nestable</code> implementation being\n+     * tested.\n+     *\n+     * @param msg <code>String</code> argument to be provided to the instance\n+     * constructor\n+     * @param t <code>Throwable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getNestable(String msg, Throwable t);\n+    \n+    /**\n+     * Returns an instance of the <code>Nestable</code> implementation being\n+     * tested.\n+     *\n+     * @param t <code>Throwable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getNestable(Throwable t);\n+    \n+    /**\n+     * Returns an instance of a <code>Throwable</code> to be used in\n+     * constructing instances of the <code>Nestable</code> implementation being\n+     * tested.\n+     *\n+     * @param msg <code>String</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Throwable getThrowable(String msg);\n+\n+    /**\n+     * Returns an instance of one tester <code>Nestable</code> implementation.\n+     *\n+     * @param n <code>Nestable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getTester1(Nestable n);\n+    \n+    /**\n+     * Returns an instance of one tester <code>Nestable</code> implementation.\n+     *\n+     * @param t <code>Throwable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getTester1(Throwable t);\n+    \n+    /**\n+     * Returns an instance of one tester <code>Nestable</code> implementation.\n+     *\n+     * @param msg <code>String</code> argument to be provided to the instance\n+     * constructor\n+     * @param n <code>Nestable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getTester1(String msg, Nestable n);\n+    \n+    /**\n+     * Returns an instance of one tester <code>Nestable</code> implementation.\n+     *\n+     * @param msg <code>String</code> argument to be provided to the instance\n+     * constructor\n+     * @param t <code>Throwable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getTester1(String msg, Throwable t);\n+    \n+    /**\n+     * Returns an instance of a second tester <code>Nestable</code>\n+     * implementation.\n+     *\n+     * @param msg <code>String</code> argument to be provided to the instance\n+     * constructor\n+     * @param n <code>Nestable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getTester2(String msg, Nestable n);\n+    \n+    /**\n+     * Returns an instance of a second tester <code>Nestable</code>\n+     * implementation.\n+     *\n+     * @param msg <code>String</code> argument to be provided to the instance\n+     * constructor\n+     * @param t <code>Throwable</code> argument to be provided to the instance\n+     * constructor\n+     * @return the instance\n+     */\n+    public abstract Nestable getTester2(String msg, Throwable t);\n+\n+    /**\n+     * Returns the class of the first tester <code>Nestable</code>\n+     * implementation.\n+     *\n+     * @return the class\n+     */\n+    public abstract Class getTester1Class();\n+    \n+    /**\n+     * Returns the class of the second tester <code>Nestable</code>\n+     * implementation.\n+     *\n+     * @return the class\n+     */\n+    public abstract Class getTester2Class();\n+\n+    /**\n+     * Returns the class of the <code>Throwable</code> used in constructing\n+     * instances of the <code>Nestable</code> implementation being tested.\n+     *\n+     * @return the class\n+     */\n+    public abstract Class getThrowableClass();\n+\n+    /**\n+     * Returns the base class being used, typically Error, Eception or RuntimeException.\n+     *\n+     * @return the class\n+     */\n+    public abstract Class getBaseThrowableClass();\n+\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/exception/ExceptionTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test manager for the org.apache.commons.lang.exception classes.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ */\n+public class ExceptionTestSuite extends TestCase\n+{\n+    /**\n+     * Construct a new instance.\n+     */\n+    public ExceptionTestSuite(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args)\n+    {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite()\n+    {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(NestableDelegateTestCase.suite());\n+        suite.addTest(NestableErrorTestCase.suite());\n+        suite.addTest(NestableExceptionTestCase.suite());\n+        suite.addTest(NestableRuntimeExceptionTestCase.suite());\n+        suite.addTest(ExceptionUtilsTestCase.suite());\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/exception/ExceptionUtilsTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Tests {@link org.apache.commons.lang.exception.ExceptionUtils}.\n+ * \n+ * <h3>Notes</h3>\n+ * <p>\n+ * Make sure this exception code does not depend on Java 1.4 nested exceptions. SVN revision 38990 does not compile with\n+ * Java 1.3.1.\n+ * </p>\n+ * <ul>\n+ * <li>Compiled with Sun Java 1.3.1_15</li>\n+ * <li>Tested with Sun Java 1.3.1_15</li>\n+ * <li>Tested with Sun Java 1.4.2_12</li>\n+ * <li>Tested with Sun Java 1.5.0_08</li>\n+ * <li>All of the above on Windows XP SP2 + patches.</li>\n+ * </ul>\n+ * <p>\n+ * Gary Gregory; August 16, 2006.\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @since 1.0\n+ */\n+public class ExceptionUtilsTestCase extends junit.framework.TestCase {\n+    \n+    private NestableException nested;\n+    private Throwable withCause;\n+    private Throwable withoutCause;\n+    private Throwable jdkNoCause;\n+    private ExceptionWithCause selfCause;\n+    private ExceptionWithCause cyclicCause;\n+\n+    public ExceptionUtilsTestCase(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(ExceptionUtilsTestCase.class);\n+    }\n+\n+    public void setUp() {\n+        withoutCause = createExceptionWithoutCause();\n+        nested = new NestableException(withoutCause);\n+        withCause = new ExceptionWithCause(nested);\n+        jdkNoCause = new NullPointerException();\n+        selfCause = new ExceptionWithCause(null);\n+        selfCause.setCause(selfCause);\n+        ExceptionWithCause a = new ExceptionWithCause(null);\n+        ExceptionWithCause b = new ExceptionWithCause(a);\n+        a.setCause(b);\n+        cyclicCause = new ExceptionWithCause(a);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        withoutCause = null;\n+        nested = null;\n+        withCause = null;\n+        jdkNoCause = null;\n+        selfCause = null;\n+        cyclicCause = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private Throwable createExceptionWithoutCause() {\n+        try {\n+            throw new ExceptionWithoutCause();\n+        } catch (Throwable t) {\n+            return t;\n+        }\n+    }\n+\n+    private Throwable createExceptionWithCause() {\n+        try {\n+            try {\n+                throw new ExceptionWithCause(createExceptionWithoutCause());\n+            } catch (Throwable t) {\n+                throw new ExceptionWithCause(t);\n+            }\n+        } catch (Throwable t) {\n+            return t;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public void testConstructor() {\n+        assertNotNull(new ExceptionUtils());\n+        Constructor[] cons = ExceptionUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(ExceptionUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(ExceptionUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    \n+    public void testCauseMethodNameOps() {\n+        this.testCauseMethodNameOps(null);\n+        this.testCauseMethodNameOps(\"\");\n+        this.testCauseMethodNameOps(\" \");\n+        this.testCauseMethodNameOps(\"\\t\\r\\n\\t\");\n+        this.testCauseMethodNameOps(\"testMethodName\");\n+    }\n+    \n+    void testCauseMethodNameOps(String name) {\n+        String methodName = \"testMethodName\";\n+        try {\n+            Assert.assertFalse(ExceptionUtils.isCauseMethodName(methodName));\n+            ExceptionUtils.addCauseMethodName(methodName);            \n+            ExceptionUtils.addCauseMethodName(methodName);            \n+            Assert.assertTrue(ExceptionUtils.isCauseMethodName(methodName));\n+        } finally {\n+            ExceptionUtils.removeCauseMethodName(methodName);\n+            Assert.assertFalse(\n+                    \"The method name \" + methodName + \" should not be in the array\", \n+                    ExceptionUtils.isCauseMethodName(methodName));\n+        }\n+    }\n+    \n+    public void testGetCause_Throwable() {\n+        assertSame(null, ExceptionUtils.getCause(null));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause));\n+        assertSame(withoutCause, ExceptionUtils.getCause(nested));\n+        assertSame(nested, ExceptionUtils.getCause(withCause));\n+        assertSame(null, ExceptionUtils.getCause(jdkNoCause));\n+        assertSame(selfCause, ExceptionUtils.getCause(selfCause));\n+        assertSame(cyclicCause.getCause(), ExceptionUtils.getCause(cyclicCause));\n+        assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), ExceptionUtils.getCause(cyclicCause.getCause()));\n+        assertSame(cyclicCause.getCause(), ExceptionUtils.getCause(((ExceptionWithCause) cyclicCause.getCause()).getCause()));\n+    }\n+\n+    public void testGetCause_ThrowableArray() {\n+        assertSame(null, ExceptionUtils.getCause(null, null));\n+        assertSame(null, ExceptionUtils.getCause(null, new String[0]));\n+\n+        // match because known type        \n+        assertSame(withoutCause, ExceptionUtils.getCause(nested, null));\n+        assertSame(withoutCause, ExceptionUtils.getCause(nested, new String[0]));\n+        assertSame(withoutCause, ExceptionUtils.getCause(nested, new String[] {\"getCause\"}));\n+        \n+        // not known type, so match on supplied method names\n+        assertSame(nested, ExceptionUtils.getCause(withCause, null));  // default names\n+        assertSame(null, ExceptionUtils.getCause(withCause, new String[0]));\n+        assertSame(null, ExceptionUtils.getCause(withCause, new String[] {null}));\n+        assertSame(nested, ExceptionUtils.getCause(withCause, new String[] {\"getCause\"}));\n+        \n+        // not known type, so match on supplied method names\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, null));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, new String[0]));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {null}));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {\"getCause\"}));\n+        assertSame(null, ExceptionUtils.getCause(withoutCause, new String[] {\"getTargetException\"}));\n+    }\n+\n+    public void testGetRootCause_Throwable() {\n+        assertSame(null, ExceptionUtils.getRootCause(null));\n+        assertSame(null, ExceptionUtils.getRootCause(withoutCause));\n+        assertSame(withoutCause, ExceptionUtils.getRootCause(nested));\n+        assertSame(withoutCause, ExceptionUtils.getRootCause(withCause));\n+        assertSame(null, ExceptionUtils.getRootCause(jdkNoCause));\n+        assertSame(null, ExceptionUtils.getRootCause(selfCause));\n+        assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), ExceptionUtils.getRootCause(cyclicCause));\n+    }\n+\n+    public void testSetCause() {\n+        Exception cause = new ExceptionWithoutCause();\n+        assertEquals(true, ExceptionUtils.setCause(new ExceptionWithCause(null), cause));\n+        if (SystemUtils.isJavaVersionAtLeast(140)) {\n+            assertEquals(true, ExceptionUtils.setCause(new ExceptionWithoutCause(), cause));\n+        }\n+    }\n+\n+    /**\n+     * Tests overriding a cause to <code>null</code>.\n+     */\n+    public void testSetCauseToNull() {\n+        Exception ex = new ExceptionWithCause(new IOException());\n+        assertEquals(true, ExceptionUtils.setCause(ex, new IllegalStateException()));\n+        assertNotNull(ExceptionUtils.getCause(ex));\n+        assertEquals(true, ExceptionUtils.setCause(ex, null));\n+        assertNull(ExceptionUtils.getCause(ex));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsThrowableNested() {\n+        if (SystemUtils.isJavaVersionAtLeast(140)) {\n+            assertEquals(true, ExceptionUtils.isThrowableNested());\n+        } else {\n+            assertEquals(false, ExceptionUtils.isThrowableNested());\n+        }\n+    }\n+    \n+    public void testIsNestedThrowable_Throwable() {\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(new SQLException()));\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(new InvocationTargetException(new Exception())));\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(new NestableRuntimeException()));\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(withCause));\n+        assertEquals(true, ExceptionUtils.isNestedThrowable(nested));\n+        if (SystemUtils.isJavaVersionAtLeast(140)) {\n+            assertEquals(true, ExceptionUtils.isNestedThrowable(withoutCause));\n+            assertEquals(true, ExceptionUtils.isNestedThrowable(new Throwable()));\n+        } else {\n+            assertEquals(false, ExceptionUtils.isNestedThrowable(withoutCause));\n+            assertEquals(false, ExceptionUtils.isNestedThrowable(new Throwable()));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetThrowableCount_Throwable() {\n+        assertEquals(0, ExceptionUtils.getThrowableCount(null));\n+        assertEquals(1, ExceptionUtils.getThrowableCount(withoutCause));\n+        assertEquals(2, ExceptionUtils.getThrowableCount(nested));\n+        assertEquals(3, ExceptionUtils.getThrowableCount(withCause));\n+        assertEquals(1, ExceptionUtils.getThrowableCount(jdkNoCause));\n+        assertEquals(1, ExceptionUtils.getThrowableCount(selfCause));\n+        assertEquals(3, ExceptionUtils.getThrowableCount(cyclicCause));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetThrowables_Throwable_null() {\n+        assertEquals(0, ExceptionUtils.getThrowables(null).length);\n+    }\n+\n+    public void testGetThrowables_Throwable_withoutCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause);\n+        assertEquals(1, throwables.length);\n+        assertSame(withoutCause, throwables[0]);\n+    }\n+\n+    public void testGetThrowables_Throwable_nested() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(nested);\n+        assertEquals(2, throwables.length);\n+        assertSame(nested, throwables[0]);\n+        assertSame(withoutCause, throwables[1]);\n+    }\n+\n+    public void testGetThrowables_Throwable_withCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(withCause);\n+        assertEquals(3, throwables.length);\n+        assertSame(withCause, throwables[0]);\n+        assertSame(nested, throwables[1]);\n+        assertSame(withoutCause, throwables[2]);\n+    }\n+\n+    public void testGetThrowables_Throwable_jdkNoCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(jdkNoCause);\n+        assertEquals(1, throwables.length);\n+        assertSame(jdkNoCause, throwables[0]);\n+    }\n+\n+    public void testGetThrowables_Throwable_selfCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(selfCause);\n+        assertEquals(1, throwables.length);\n+        assertSame(selfCause, throwables[0]);\n+    }\n+\n+    public void testGetThrowables_Throwable_recursiveCause() {\n+        Throwable[] throwables = ExceptionUtils.getThrowables(cyclicCause);\n+        assertEquals(3, throwables.length);\n+        assertSame(cyclicCause, throwables[0]);\n+        assertSame(cyclicCause.getCause(), throwables[1]);\n+        assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), throwables[2]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetThrowableList_Throwable_null() {\n+        List throwables = ExceptionUtils.getThrowableList(null);\n+        assertEquals(0, throwables.size());\n+    }\n+\n+    public void testGetThrowableList_Throwable_withoutCause() {\n+        List throwables = ExceptionUtils.getThrowableList(withoutCause);\n+        assertEquals(1, throwables.size());\n+        assertSame(withoutCause, throwables.get(0));\n+    }\n+\n+    public void testGetThrowableList_Throwable_nested() {\n+        List throwables = ExceptionUtils.getThrowableList(nested);\n+        assertEquals(2, throwables.size());\n+        assertSame(nested, throwables.get(0));\n+        assertSame(withoutCause, throwables.get(1));\n+    }\n+\n+    public void testGetThrowableList_Throwable_withCause() {\n+        List throwables = ExceptionUtils.getThrowableList(withCause);\n+        assertEquals(3, throwables.size());\n+        assertSame(withCause, throwables.get(0));\n+        assertSame(nested, throwables.get(1));\n+        assertSame(withoutCause, throwables.get(2));\n+    }\n+\n+    public void testGetThrowableList_Throwable_jdkNoCause() {\n+        List throwables = ExceptionUtils.getThrowableList(jdkNoCause);\n+        assertEquals(1, throwables.size());\n+        assertSame(jdkNoCause, throwables.get(0));\n+    }\n+\n+    public void testGetThrowableList_Throwable_selfCause() {\n+        List throwables = ExceptionUtils.getThrowableList(selfCause);\n+        assertEquals(1, throwables.size());\n+        assertSame(selfCause, throwables.get(0));\n+    }\n+\n+    public void testGetThrowableList_Throwable_recursiveCause() {\n+        List throwables = ExceptionUtils.getThrowableList(cyclicCause);\n+        assertEquals(3, throwables.size());\n+        assertSame(cyclicCause, throwables.get(0));\n+        assertSame(cyclicCause.getCause(), throwables.get(1));\n+        assertSame(((ExceptionWithCause) cyclicCause.getCause()).getCause(), throwables.get(2));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOf_ThrowableClass() {\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(null, null));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(null, NestableException.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, null));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithCause.class));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, NestableException.class));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, null));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithCause.class));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(nested, NestableException.class));\n+        assertEquals(1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, null));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class));\n+        assertEquals(1, ExceptionUtils.indexOfThrowable(withCause, NestableException.class));\n+        assertEquals(2, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Exception.class));\n+    }\n+\n+    public void testIndexOf_ThrowableClassInt() {\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(null, null, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(null, NestableException.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, null));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithCause.class, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withoutCause, NestableException.class, 0));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withoutCause, ExceptionWithoutCause.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, null, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithCause.class, 0));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(nested, NestableException.class, 0));\n+        assertEquals(1, ExceptionUtils.indexOfThrowable(nested, ExceptionWithoutCause.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, null));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 0));\n+        assertEquals(1, ExceptionUtils.indexOfThrowable(withCause, NestableException.class, 0));\n+        assertEquals(2, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithoutCause.class, 0));\n+\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, -1));\n+        assertEquals(0, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 1));\n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, ExceptionWithCause.class, 9));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfThrowable(withCause, Exception.class, 0));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOfType_ThrowableClass() {\n+        assertEquals(-1, ExceptionUtils.indexOfType(null, null));\n+        assertEquals(-1, ExceptionUtils.indexOfType(null, NestableException.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, null));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, ExceptionWithCause.class));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, NestableException.class));\n+        assertEquals(0, ExceptionUtils.indexOfType(withoutCause, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(nested, null));\n+        assertEquals(-1, ExceptionUtils.indexOfType(nested, ExceptionWithCause.class));\n+        assertEquals(0, ExceptionUtils.indexOfType(nested, NestableException.class));\n+        assertEquals(1, ExceptionUtils.indexOfType(nested, ExceptionWithoutCause.class));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(withCause, null));\n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class));\n+        assertEquals(1, ExceptionUtils.indexOfType(withCause, NestableException.class));\n+        assertEquals(2, ExceptionUtils.indexOfType(withCause, ExceptionWithoutCause.class));\n+        \n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, Exception.class));\n+    }\n+\n+    public void testIndexOfType_ThrowableClassInt() {\n+        assertEquals(-1, ExceptionUtils.indexOfType(null, null, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfType(null, NestableException.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, null));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, ExceptionWithCause.class, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withoutCause, NestableException.class, 0));\n+        assertEquals(0, ExceptionUtils.indexOfType(withoutCause, ExceptionWithoutCause.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(nested, null, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfType(nested, ExceptionWithCause.class, 0));\n+        assertEquals(0, ExceptionUtils.indexOfType(nested, NestableException.class, 0));\n+        assertEquals(1, ExceptionUtils.indexOfType(nested, ExceptionWithoutCause.class, 0));\n+        \n+        assertEquals(-1, ExceptionUtils.indexOfType(withCause, null));\n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 0));\n+        assertEquals(1, ExceptionUtils.indexOfType(withCause, NestableException.class, 0));\n+        assertEquals(2, ExceptionUtils.indexOfType(withCause, ExceptionWithoutCause.class, 0));\n+\n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, -1));\n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 0));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 1));\n+        assertEquals(-1, ExceptionUtils.indexOfType(withCause, ExceptionWithCause.class, 9));\n+        \n+        assertEquals(0, ExceptionUtils.indexOfType(withCause, Exception.class, 0));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPrintRootCauseStackTrace_Throwable() throws Exception {\n+        ExceptionUtils.printRootCauseStackTrace(null);\n+        // could pipe system.err to a known stream, but not much point as\n+        // internally this method calls stram method anyway\n+    }\n+    \n+    public void testPrintRootCauseStackTrace_ThrowableStream() throws Exception {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n+        ExceptionUtils.printRootCauseStackTrace(null, (PrintStream) null);\n+        ExceptionUtils.printRootCauseStackTrace(null, new PrintStream(out));\n+        assertEquals(0, out.toString().length());\n+        \n+        out = new ByteArrayOutputStream(1024);\n+        try {\n+            ExceptionUtils.printRootCauseStackTrace(withCause, (PrintStream) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        \n+        out = new ByteArrayOutputStream(1024);\n+        Throwable withCause = createExceptionWithCause();\n+        ExceptionUtils.printRootCauseStackTrace(withCause, new PrintStream(out));\n+        String stackTrace = out.toString();\n+        assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1);\n+        \n+        out = new ByteArrayOutputStream(1024);\n+        ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintStream(out));\n+        stackTrace = out.toString();\n+        assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1);\n+    }\n+\n+    public void testPrintRootCauseStackTrace_ThrowableWriter() throws Exception {\n+        StringWriter writer = new StringWriter(1024);\n+        ExceptionUtils.printRootCauseStackTrace(null, (PrintWriter) null);\n+        ExceptionUtils.printRootCauseStackTrace(null, new PrintWriter(writer));\n+        assertEquals(0, writer.getBuffer().length());\n+        \n+        writer = new StringWriter(1024);\n+        try {\n+            ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        \n+        writer = new StringWriter(1024);\n+        Throwable withCause = createExceptionWithCause();\n+        ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer));\n+        String stackTrace = writer.toString();\n+        assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1);\n+        \n+        writer = new StringWriter(1024);\n+        ExceptionUtils.printRootCauseStackTrace(withoutCause, new PrintWriter(writer));\n+        stackTrace = writer.toString();\n+        assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) == -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetRootCauseStackTrace_Throwable() throws Exception {\n+        assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length);\n+        \n+        Throwable withCause = createExceptionWithCause();\n+        String[] stackTrace = ExceptionUtils.getRootCauseStackTrace(withCause);\n+        boolean match = false;\n+        for (int i = 0; i < stackTrace.length; i++) {\n+            if (stackTrace[i].startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n+                match = true;\n+                break;\n+            }\n+        }\n+        assertEquals(true, match);\n+        \n+        stackTrace = ExceptionUtils.getRootCauseStackTrace(withoutCause);\n+        match = false;\n+        for (int i = 0; i < stackTrace.length; i++) {\n+            if (stackTrace[i].startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n+                match = true;\n+                break;\n+            }\n+        }\n+        assertEquals(false, match);\n+    }\n+\n+    public void testRemoveCommonFrames_ListList() throws Exception {\n+        try {\n+            ExceptionUtils.removeCommonFrames(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+    }\n+\n+    public void test_getMessage_Throwable() {\n+        Throwable th = null;\n+        assertEquals(\"\", ExceptionUtils.getMessage(th));\n+        \n+        th = new IllegalArgumentException(\"Base\");\n+        assertEquals(\"IllegalArgumentException: Base\", ExceptionUtils.getMessage(th));\n+        \n+        th = new ExceptionWithCause(\"Wrapper\", th);\n+        assertEquals(\"ExceptionUtilsTestCase.ExceptionWithCause: Wrapper\", ExceptionUtils.getMessage(th));\n+    }\n+\n+    public void test_getRootCauseMessage_Throwable() {\n+        Throwable th = null;\n+        assertEquals(\"\", ExceptionUtils.getRootCauseMessage(th));\n+        \n+        th = new IllegalArgumentException(\"Base\");\n+        assertEquals(\"IllegalArgumentException: Base\", ExceptionUtils.getRootCauseMessage(th));\n+        \n+        th = new ExceptionWithCause(\"Wrapper\", th);\n+        assertEquals(\"IllegalArgumentException: Base\", ExceptionUtils.getRootCauseMessage(th));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Provides a method with a well known chained/nested exception\n+     * name which matches the full signature (e.g. has a return value\n+     * of <code>Throwable</code>.\n+     */\n+    private static class ExceptionWithCause extends Exception {\n+        private Throwable cause;\n+\n+        public ExceptionWithCause(String str, Throwable cause) {\n+            super(str);\n+            setCause(cause);\n+        }\n+\n+        public ExceptionWithCause(Throwable cause) {\n+            super();\n+            setCause(cause);\n+        }\n+\n+        public Throwable getCause() {\n+            return cause;\n+        }\n+\n+        public void setCause(Throwable cause) {\n+            this.cause = cause;\n+        }\n+    }\n+\n+    /**\n+     * Provides a method with a well known chained/nested exception\n+     * name which does not match the full signature (e.g. lacks a\n+     * return value of <code>Throwable</code>.\n+     */\n+    private static class ExceptionWithoutCause extends Exception {\n+        public void getTargetException() {\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/exception/NestableDelegateTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests the org.apache.commons.lang.exception.NestableDelegate class.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @version $Id$\n+ */\n+public class NestableDelegateTestCase extends junit.framework.TestCase {\n+    private static final String CONSTRUCTOR_FAILED_MSG = \n+    \"The Nestable implementation passed to the NestableDelegate(Nestable) constructor must extend java.lang.Throwable\";\n+\n+    private static final String PARTIAL_STACK_TRACE =\n+        \"ThrowableNestedNestable partial stack trace place-holder\";\n+\n+    protected String lineSeparator;\n+\n+    /**\n+     * Construct a new instance of NestableDelegateTestCase with the specified name\n+     */\n+    public NestableDelegateTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+        lineSeparator = System.getProperty(\"line.separator\");\n+    }\n+    \n+    public static Test suite()\n+    {\n+        return new TestSuite(NestableDelegateTestCase.class);\n+    }\n+    \n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+        lineSeparator = null;\n+    }\n+    \n+    /**\n+     * Test the implementation\n+     */\n+    public void testNestableDelegateConstructor()\n+    {\n+        String msg = null;\n+        boolean constructorFailed = false;\n+        try\n+        {\n+            NestableDelegate nonThrowableCause = new NestableDelegate(new NonThrowableNestable());\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            constructorFailed = true;\n+            msg = iae.getMessage();\n+        }\n+        assertTrue(\"nestable delegate constructor with non-throwable cause failed == true\", constructorFailed);\n+        assertTrue(\"constructor failed exception msg == \" + CONSTRUCTOR_FAILED_MSG,\n+            msg.equals(CONSTRUCTOR_FAILED_MSG));\n+\n+        constructorFailed = false;\n+        try\n+        {\n+            NestableDelegate nd1 = new NestableDelegate(new ThrowableNestable());\n+        }\n+        catch(IllegalArgumentException iae)\n+        {\n+            constructorFailed = true;\n+        }\n+        assertTrue(\"nestable delegate constructor with throwable cause failed == false\", !constructorFailed);\n+    }\n+\n+    public void testNestableDelegateGetMessage()\n+    {\n+        Nestable ne1 = new ThrowableNestable();\n+        assertTrue(\"ThrowableNestable ne1 getMessage() == ThrowableNestable exception\",\n+            ne1.getMessage().equals(\"ThrowableNestable exception\"));\n+        NestableDelegate nd1 = new NestableDelegate(ne1);\n+        assertTrue(\"nd1 getMessage() == \" + ne1.getCause().getMessage(),\n+            nd1.getMessage(\"base\").equals(\"base: \" + ne1.getCause().getMessage()));\n+        \n+        Nestable ne2 = new ThrowableNestedNestable(new Exception(\"nested exception 2\"));\n+        NestableDelegate nd2 = new NestableDelegate(ne2);\n+        assertTrue(\"nd2 getMessage() == base: \" + ne2.getCause().getMessage(),\n+            nd2.getMessage(\"base\").equals(\"base: \" + ne2.getCause().getMessage()));\n+    }\n+\n+    public void testNestableDelegateGetThrowableCount()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        \n+        n = new NestableDelegateTester1();\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowableCount(d, 1);\n+        \n+        n = new NestableDelegateTester1(\"level 1\");\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowableCount(d, 1);\n+        \n+        n = new NestableDelegateTester1(new Exception());\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowableCount(d, 2);\n+        \n+        n = new NestableDelegateTester1(new Exception(\"level 2\"));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowableCount(d, 2);\n+        \n+        n = new NestableDelegateTester1(\"level 1\", \n+                new NestableDelegateTester2(\"level 2\", \n+                    new NestableDelegateTester1(\n+                        new NestableDelegateTester2(\"level 4\", \n+                            new Exception(\"level 5\")\n+                        )\n+                    )\n+                )\n+            );\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowableCount(d, 5);\n+    }\n+\n+    private void doNestableDelegateGetThrowableCount(NestableDelegate d, int len)\n+    {\n+        // Compare the lengths\n+        assertEquals(\"delegate length\", len, d.getThrowableCount());\n+    }\n+    \n+    public void testNestableDelegateGetMessages()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String msgs[] = null;\n+        \n+        msgs = new String[1];\n+        n = new NestableDelegateTester1();\n+        d = new NestableDelegate(n);        \n+        doNestableDelegateGetMessages(d, msgs);\n+        \n+        msgs = new String[1];\n+        msgs[0] = \"level 1\";\n+        n = new NestableDelegateTester1(msgs[0]);\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetMessages(d, msgs);\n+\n+        msgs = new String[2];\n+        n = new NestableDelegateTester1(new Exception());\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetMessages(d, msgs);\n+\n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        n = new NestableDelegateTester1(new Exception(msgs[1]));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetMessages(d, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        n = new NestableDelegateTester1(msgs[0], \n+                new NestableDelegateTester2(msgs[1], \n+                    new NestableDelegateTester1(\n+                        new NestableDelegateTester2(msgs[3], \n+                            new Exception(msgs[4])\n+                        )\n+                    )\n+                )\n+            );\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetMessages(d, msgs);\n+    }\n+\n+    private void doNestableDelegateGetMessages(NestableDelegate d, String[] nMsgs)\n+    {\n+        // Compare the messages\n+        String[] dMsgs = d.getMessages();\n+        assertEquals(\"messages length\", nMsgs.length, dMsgs.length);\n+        for(int i = 0; i < nMsgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, nMsgs[i], dMsgs[i]);\n+        }\n+    }\n+    \n+    public void testGetMessageString()\n+    {\n+        NestableDelegateTester1 ndt1 = new NestableDelegateTester1 (new NullPointerException ());\n+        NestableDelegate nd = new NestableDelegate (ndt1);\n+        assertNull (nd.getMessage((String)null));\n+        \n+        ndt1 = new NestableDelegateTester1 (new NullPointerException (\"null pointer\"));\n+        nd = new NestableDelegate (ndt1);\n+        assertNotNull(nd.getMessage((String)null));\n+        \n+        ndt1 = new NestableDelegateTester1 ();\n+        nd = new NestableDelegate (ndt1);\n+        assertNull(nd.getMessage((String)null));\n+        \n+        ndt1 = new NestableDelegateTester1 (\"root\");\n+        nd = new NestableDelegate (ndt1);\n+        assertNull(nd.getMessage((String)null));\n+    }\n+\n+    public void testNestableDelegateGetMessageN()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String[] msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        n = new NestableDelegateTester1(msgs[0], \n+                new NestableDelegateTester2(msgs[1], \n+                    new NestableDelegateTester1(\n+                        new NestableDelegateTester2(msgs[3], \n+                            new Exception(msgs[4])\n+                        )\n+                    )\n+                )\n+            );\n+        d = new NestableDelegate(n);\n+        for(int i = 0; i < msgs.length; i++)\n+        {\n+            assertEquals(\"message \" + i, msgs[i], d.getMessage(i));\n+        }\n+        \n+        // Test for index out of bounds\n+        try\n+        {\n+            String msg = d.getMessage(-1);\n+            fail(\"getMessage(-1) should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException ioode)\n+        {\n+        }\n+        try\n+        {\n+            String msg = d.getMessage(msgs.length + 100);\n+            fail(\"getMessage(999) should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException ioode)\n+        {\n+        }\n+    }\n+\n+    public void testNestableDelegateGetThrowableN()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = Exception.class;\n+        n = new NestableDelegateTester1(new Exception(msgs[1]));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowableN(d, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = NestableDelegateTester2.class;\n+        throwables[2] = NestableDelegateTester1.class;\n+        throwables[3] = NestableDelegateTester2.class;\n+        throwables[4] = Exception.class;        \n+        n = new NestableDelegateTester1(msgs[0], \n+                new NestableDelegateTester2(msgs[1], \n+                    new NestableDelegateTester1(\n+                        new NestableDelegateTester2(msgs[3], \n+                            new Exception(msgs[4])\n+                            )\n+                        )\n+                    )\n+                );\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowableN(d, throwables, msgs);\n+    }\n+\n+    private void doNestableDelegateGetThrowableN(NestableDelegate d, Class[] classes, String[] msgs)\n+    {\n+        Throwable t = null;\n+        String msg = null;\n+        \n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            t = d.getThrowable(i);\n+            assertEquals(\"throwable class\", classes[i], t.getClass());\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+        \n+        // Test for index out of bounds\n+        try\n+        {\n+            t = d.getThrowable(-1);\n+            fail(\"getThrowable(-1) should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException ioobe)\n+        {\n+        }\n+        try\n+        {\n+            t = d.getThrowable(999);\n+            fail(\"getThrowable(999) should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException ioobe)\n+        {\n+        }\n+    }\n+\n+    public void testNestableDelegateGetThrowables()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[2];\n+        msgs[0] = null;\n+        msgs[1] = \"level 2\";\n+        throwables = new Class[2];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = Exception.class;\n+        n = new NestableDelegateTester1(new Exception(msgs[1]));\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowables(d, throwables, msgs);\n+ \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = NestableDelegateTester2.class;\n+        throwables[2] = NestableDelegateTester1.class;\n+        throwables[3] = NestableDelegateTester2.class;\n+        throwables[4] = Exception.class;        \n+        n = new NestableDelegateTester1(msgs[0], \n+                new NestableDelegateTester2(msgs[1], \n+                    new NestableDelegateTester1(\n+                        new NestableDelegateTester2(msgs[3], \n+                            new Exception(msgs[4])\n+                        )\n+                    )\n+                )\n+            );\n+        d = new NestableDelegate(n);\n+        doNestableDelegateGetThrowables(d, throwables, msgs);\n+    }\n+    \n+    private void doNestableDelegateGetThrowables(NestableDelegate d, Class[] classes, String[] msgs)\n+    {\n+        Throwable[] throwables = null;\n+        String msg = null;\n+\n+        throwables = d.getThrowables();\n+        assertEquals(\"throwables length\", classes.length, throwables.length);\n+        for(int i = 0; i < classes.length; i++)\n+        {\n+            assertEquals(\"throwable class\", classes[i], throwables[i].getClass());\n+            Throwable t = throwables[i];\n+            if(Nestable.class.isInstance(t))\n+            {\n+                msg = ((Nestable) t).getMessage(0);\n+            }\n+            else\n+            {\n+                msg = t.getMessage();\n+            }\n+            assertEquals(\"throwable message\", msgs[i], msg);\n+        }\n+    }\n+\n+    public void testIndexOfThrowable()\n+    {\n+        Nestable n = null;\n+        NestableDelegate d = null;\n+        String msgs[] = null;\n+        Class[] throwables = null;\n+        \n+        msgs = new String[5];\n+        msgs[0] = \"level 1\";\n+        msgs[1] = \"level 2\";\n+        msgs[2] = null;\n+        msgs[3] = \"level 4\";\n+        msgs[4] = \"level 5\";\n+        throwables = new Class[5];\n+        throwables[0] = NestableDelegateTester1.class;\n+        throwables[1] = NestableDelegateTester2.class;\n+        throwables[2] = NestableDelegateTester1.class;\n+        throwables[3] = NestableDelegateTester2.class;\n+        throwables[4] = EOFException.class;\n+        int[] indexes = {0, 1, 0, 1, 4};\n+        n = new NestableDelegateTester1(msgs[0], \n+                new NestableDelegateTester2(msgs[1], \n+                    new NestableDelegateTester1(\n+                        new NestableDelegateTester2(msgs[3], \n+                            new EOFException(msgs[4])\n+                        )\n+                    )\n+                )\n+            );\n+        d = new NestableDelegate(n);\n+        for(int i = 0; i < throwables.length; i++)\n+        {\n+            doNestableDelegateIndexOfThrowable(d, throwables[i], 0, indexes[i], msgs[indexes[i]]);\n+        }\n+        doNestableDelegateIndexOfThrowable(d, NestableDelegateTester2.class, 2, 3, msgs[3]);\n+        doNestableDelegateIndexOfThrowable(d, NestableDelegateTester1.class, 1, 2, msgs[2]);\n+        doNestableDelegateIndexOfThrowable(d, NestableDelegateTester1.class, 3, -1, null);\n+        doNestableDelegateIndexOfThrowable(d, NestableDelegateTester1.class, 4, -1, null);\n+        doNestableDelegateIndexOfThrowable(d, EOFException.class, 2, 4, msgs[4]);\n+        doNestableDelegateIndexOfThrowable(d, IOException.class, 2, 4, msgs[4]);\n+        doNestableDelegateIndexOfThrowable(d, Exception.class, 2, 2, msgs[2]);\n+        doNestableDelegateIndexOfThrowable(d, Exception.class, 0, 0, msgs[0]);\n+        doNestableDelegateIndexOfThrowable(d, java.util.Date.class, 0, -1, null);\n+        doNestableDelegateIndexOfThrowable(d, null, 0, -1, null);\n+        \n+        // Test for index out of bounds\n+        try\n+        {\n+            int index = d.indexOfThrowable(NestableDelegateTester1.class, -1);\n+            fail(\"method should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException iooob)\n+        {\n+        }\n+        try\n+        {\n+            int index = d.indexOfThrowable(NestableDelegateTester1.class, 5);\n+            fail(\"method should have thrown IndexOutOfBoundsException\");\n+        }\n+        catch(IndexOutOfBoundsException iooob)\n+        {\n+        }\n+    }\n+\n+    private void doNestableDelegateIndexOfThrowable(NestableDelegate d, Class type, int fromIndex, int expectedIndex, String expectedMsg)\n+    {\n+        Throwable t = null;\n+        \n+        int index = d.indexOfThrowable(type, fromIndex);\n+        assertEquals(\"index of throwable \" + (type == null ? \"null\" : type.getName()), expectedIndex, index);\n+        if(expectedIndex > -1)\n+        {\n+            t = d.getThrowable(index);\n+            if(expectedMsg != null)\n+            {\n+                String msg = null;\n+                if(Nestable.class.isInstance(t))\n+                {\n+                    msg = ((Nestable) t).getMessage(0);\n+                }\n+                else\n+                {\n+                    msg = t.getMessage();\n+                }\n+                assertEquals(\"message of indexed throwable\", expectedMsg, msg);\n+            }\n+        }\n+    }\n+    \n+    public void testNestableDelegetePrintStackTrace()\n+    {\n+        int lineSepLen = lineSeparator.length();\n+        int partialStackTraceLen = PARTIAL_STACK_TRACE.length();\n+        Nestable ne3 = new ThrowableNestedNestable(new Exception(\"nested exception 3\"));\n+        NestableDelegate nd3 = new NestableDelegate(ne3);\n+\n+        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();\n+        PrintStream ps1 = new PrintStream(baos1);\n+        nd3.printStackTrace(ps1);\n+        String stack1 = baos1.toString();\n+        assertTrue(\"stack trace startsWith\", stack1.startsWith(PARTIAL_STACK_TRACE));\n+\n+        Nestable n = new NestableDelegateTester1(\"level 1\", \n+                new NestableDelegateTester2(\"level 2\", \n+                    new NestableDelegateTester1(\n+                        new NestableDelegateTester2(\"level 4\", \n+                            new Exception(\"level 5\")\n+                        )\n+                    )\n+                )\n+            );\n+        NestableDelegate d = new NestableDelegate(n);\n+        \n+        // Only testing the flags for jdk1.3 and below\n+        if (!ExceptionUtils.isThrowableNested()) {\n+            NestableDelegate.topDown = true; NestableDelegate.trimStackFrames = true;\n+            checkStackTrace(d, true, true, NestableDelegateTester1.class.getName()+\": level 1\", 24);\n+            NestableDelegate.topDown = true; NestableDelegate.trimStackFrames = false;\n+            checkStackTrace(d, true, false, NestableDelegateTester1.class.getName()+\": level 1\", 80);\n+            NestableDelegate.topDown = false; NestableDelegate.trimStackFrames = true;\n+            checkStackTrace(d, false, true, \"java.lang.Exception: level 5\", 24);\n+            NestableDelegate.topDown = false; NestableDelegate.trimStackFrames = false;\n+            checkStackTrace(d, false, false, \"java.lang.Exception: level 5\", 80);\n+            NestableDelegate.topDown = true; NestableDelegate.trimStackFrames = true;\n+        }\n+    }\n+    private void checkStackTrace(NestableDelegate d, boolean topDown, boolean trimStackFrames,\n+            String startsWith, int expCount) {\n+        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();\n+        PrintStream ps1 = new PrintStream(baos1);\n+        d.printStackTrace(ps1);\n+        String stack1 = baos1.toString();\n+        int actCount = countLines(stack1);\n+        assertTrue(\"topDown: \"+topDown+\", trimStackFrames: \"+trimStackFrames+\" startsWith\",\n+            stack1.startsWith(startsWith));\n+        // test is unreliable, as count varies depending on JUnit version/where main method is\n+//        assertEquals(\"topDown: \"+topDown+\", trimStackFrames: \"+trimStackFrames+\" lineCount\",\n+//            expCount, actCount);\n+    }\n+    private int countLines(String s) {\n+        if (s == null) return 0;\n+        \n+        int i = 0, ndx = -1;\n+        while ((ndx = s.indexOf(\"\\n\", ndx+1)) != -1) {\n+            i++;\n+        }\n+        return i;\n+    }\n+    \n+    public static void main(String args[])\n+    {\n+        TestRunner.run(suite());\n+    }\n+}\n+\n+/**\n+ * Nestable and Throwable class which can be passed to the NestableDelegate\n+ * constructor. Used for testing various methods which iterate through the\n+ * nested causes.\n+ */\n+class NestableDelegateTester1 extends Exception implements Nestable\n+{\n+    private Throwable cause = null;\n+\n+    public NestableDelegateTester1()\n+    {\n+        super();\n+    }\n+\n+    public NestableDelegateTester1(String reason, Throwable cause)\n+    {\n+        super(reason);\n+        this.cause = cause;\n+    }\n+    \n+    public NestableDelegateTester1(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableDelegateTester1(Throwable cause)\n+    {\n+        super();\n+        this.cause = cause;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowables()\n+     * Returns zero-length <code>Throwable</code> array for this test.\n+     */\n+    public Throwable[] getThrowables()\n+    {\n+        return new Throwable[0];\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessages()\n+     * Returns zero-length String array for this test.\n+     */\n+    public String[] getMessages()\n+    {\n+        return new String[0];\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class)\n+     * Returns -1 for this test.\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        return -1;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowable(int)\n+     * Returns <code>null</code> for this test.\n+     */\n+    public Throwable getThrowable(int index)\n+    {\n+        return null;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowableCount()\n+     * Returns 1 for this test.\n+     */\n+    public int getThrowableCount()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * @see Nestable#getCause()\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+    \n+    /**\n+     * Empty method to satisfy the implemented interface. Does nothing\n+     * in this test.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+        super.printStackTrace(out);\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessage(int)\n+     */\n+    public String getMessage(int index)\n+    {\n+        if(index == 0)\n+        {\n+            return super.getMessage();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class, int)\n+     * Returns -1 for this test.\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex)\n+    {\n+        return -1;\n+    }\n+    \n+}\n+\n+/**\n+ * Nestable and Throwable class which can be passed to the NestableDelegate\n+ * constructor. Used for testing various methods which iterate through the\n+ * nested causes.\n+ */\n+class NestableDelegateTester2 extends Throwable implements Nestable\n+{\n+    private Throwable cause = null;\n+\n+    public NestableDelegateTester2()\n+    {\n+        super();\n+    }\n+    \n+    public NestableDelegateTester2(String reason, Throwable cause)\n+    {\n+        super(reason);\n+        this.cause = cause;\n+    }\n+    \n+    public NestableDelegateTester2(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableDelegateTester2(Throwable cause)\n+    {\n+        super();\n+        this.cause = cause;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowables()\n+     * Returns zero-length <code>Throwable</code> array for this test.\n+     */\n+    public Throwable[] getThrowables()\n+    {\n+        return new Throwable[0];\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessages()\n+     * Returns zero-length String array for this test.\n+     */\n+    public String[] getMessages()\n+    {\n+        return new String[0];\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class)\n+     * Returns -1 for this test.\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        return -1;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowable(int)\n+     * Returns <code>null</code> for this test.\n+     */\n+    public Throwable getThrowable(int index)\n+    {\n+        return null;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowableCount()\n+     * Returns 1 for this test.\n+     *\n+     * @return 1\n+     */\n+    public int getThrowableCount()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * @see Nestable#getCause()\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+    \n+    /**\n+     * Empty method to satisfy the implemented interface. Does nothing\n+     * in this test.\n+     *\n+     * @param out The writer to use.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+        super.printStackTrace(out);\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessage(int)\n+     */\n+    public String getMessage(int index)\n+    {\n+        if(index == 0)\n+        {\n+            return super.getMessage();\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class, int)     \n+     * Returns -1 for this test.\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex)\n+    {\n+        return -1;\n+    }\n+    \n+}\n+\n+/**\n+ * Used to test that the constructor passes when passed a throwable cause\n+ * And, the NestableDelegate.getMessage() returns the message from underlying \n+ * nestable (which also has to be a Throwable).\n+ */\n+class ThrowableNestable extends Throwable implements Nestable\n+{\n+    private Throwable cause = new Exception(\"ThrowableNestable cause\");\n+\n+    /**\n+     * @see Nestable#getThrowableCount()\n+     * Returns 1 for this test.\n+     */\n+    public int getThrowableCount()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessage()\n+     * Returns the hard-coded string \"ThrowableNestable exception\" for this\n+     * test.\n+     */\n+    public String getMessage()\n+    {\n+        return \"ThrowableNestable exception\";\n+    }\n+\n+    /**\n+     * @see Nestable#getMessage(int)\n+     * Returns the hard-coded string \"ThrowableNestable exception\" for this\n+     * test.\n+     */\n+    public String getMessage(int index)\n+    {\n+        return getMessage();\n+    }\n+\n+    /**\n+     * @see Nestable#getMessages()\n+     * Returns single-element string array with \"ThrowableNestable exception\".\n+     */\n+    public String[] getMessages()\n+    {\n+        String msgs[] = new String[1];\n+        msgs[0] = getMessage();\n+        return msgs;\n+    }\n+    \n+    /**\n+     * @see Nestable#getCause()\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+\n+    /**\n+     * @see Nestable#printStackTrace(PrintWriter)\n+     * Empty method to satisfy the implemented interface. Does nothing\n+     * in this test.\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    /**\n+     * @see Nestable#printPartialStackTrace(PrintWriter)\n+     * Empty method to satisfy the implemented interface. Does nothing\n+     * in this test.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowable(int)\n+     */\n+    public Throwable getThrowable(int index)\n+    {\n+        return cause;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowables()\n+     */\n+    public Throwable[] getThrowables()\n+    {\n+        Throwable throwables[] = new Throwable[1];\n+        throwables[0] = cause;\n+        return throwables;\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class)\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        if(Exception.class.isInstance(type))\n+        {\n+            return 0;\n+        }\n+        return -1;\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class,int)\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex)\n+    {\n+        return indexOfThrowable(type);\n+    }\n+    \n+}\n+\n+/**\n+ * Nestable and Throwable class which takes in a 'cause' object.\n+ * Returns a message wrapping the 'cause' message\n+ * Prints a fixed stack trace and partial stack trace.\n+ */\n+class ThrowableNestedNestable extends Throwable implements Nestable\n+{\n+    private Throwable cause = null;\n+    \n+    public ThrowableNestedNestable(Throwable cause)\n+    {\n+        this.cause = cause;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowableCount()\n+     * Returns 1 for this test.\n+     */\n+    public int getThrowableCount()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessage()\n+     * For this test, returns \"ThrowableNestable exception (\" appended to the\n+     * message of the cause specified in the constructor.\n+     */\n+    public String getMessage()\n+    {\n+        return \"ThrowableNestedNestable exception (\" + cause.getMessage() + \")\";\n+    }\n+\n+    /**\n+     * @see Nestable#getMessage(int)\n+     * For this test, returns \"ThrowableNestable exception (\" appended to the\n+     * message of the cause specified in the constructor.\n+     */\n+    public String getMessage(int index)\n+    {\n+        return \"ThrowableNestedNestable exception (\" + cause.getMessage() + \")\";\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessages()\n+     * For this test, returns a single-element string array containing\n+     * \"ThrowableNestable exception (\" appended to the\n+     * message of the cause specified in the constructor.\n+     */\n+    public String[] getMessages()\n+    {\n+        String[] msgs = new String[1];\n+        msgs[0] = \"ThrowableNestedNestable exception (\" + cause.getMessage() + \")\";\n+        return msgs;\n+    }\n+    \n+    /**\n+     * @see Nestable#getCause()\n+     */\n+    public Throwable getCause()\n+    {\n+        return cause;\n+    }\n+    \n+    /**\n+     * @see Nestable#printStackTrace(PrintWriter)\n+     * For this test, writes the string\n+     * \"ThrowableNestedNestable stack trace place-holder\" to the print writer.\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+        out.println(\"ThrowableNestedNestable stack trace place-holder\");\n+    }\n+    \n+    /**\n+     * @see Nestable#printPartialStackTrace(PrintWriter)\n+     * For this test, writes the string\n+     * \"ThrowableNestedNestable partial stack trace place-holder\" to the print\n+     * writer.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+        out.println(\"ThrowableNestedNestable partial stack trace place-holder\");\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowable(int)\n+     */\n+    public Throwable getThrowable(int index)\n+    {\n+        return cause;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowableS()\n+     */\n+    public Throwable[] getThrowables()\n+    {\n+        Throwable throwables[] = new Throwable[1];\n+        throwables[0] = cause;\n+        return throwables;\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class)\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        if(Exception.class.isInstance(type))\n+        {\n+            return 0;\n+        }\n+        return -1;\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class, int)\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex)\n+    {\n+        return indexOfThrowable(type);\n+    }\n+    \n+}\n+\n+/**\n+ * Used to test that the constructor fails when passed a non-throwable cause\n+ */\n+class NonThrowableNestable implements Nestable\n+{\n+    /**\n+     * @see Nestable#getThrowableCount()\n+     * Returns 1 for this test.\n+     */\n+    public int getThrowableCount()\n+    {\n+        return 1;\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessage()\n+     * Returns the string \"non-throwable\" for this test.\n+     */\n+    public String getMessage()\n+    {\n+        return \"non-throwable\";\n+    }\n+\n+    /**\n+     * @see Nestable#getMessage(int)\n+     * Returns the string \"non-throwable\" for this test.\n+     */\n+    public String getMessage(int index)\n+    {\n+        return \"non-throwable\";\n+    }\n+    \n+    /**\n+     * @see Nestable#getMessage()\n+     * Returns a single-element array containing the string \"non-throwable\" for\n+     * this test.\n+     */\n+    public String[] getMessages()\n+    {\n+        String[] msgs = new String[1];\n+        msgs[0] = \"non-throwable\";\n+        return msgs;\n+    }\n+    \n+    /**\n+     * @see Nestable#getCause()\n+     * Returns <code>null</code> for this test.\n+     */\n+    public Throwable getCause()\n+    {\n+        return null;\n+    }\n+    \n+    /**\n+     * @see Nestable#printStackTrace(PrintWriter)\n+     * Empty method to satisfy the implemented interface. Does nothing\n+     * in this test.\n+     */\n+    public void printStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+    /**\n+     * @see Nestable#printStackTrace(PrintStream)\n+     * Empty method to satisfy the implemented interface. Does nothing\n+     * in this test.\n+     */\n+    public void printStackTrace(PrintStream out)\n+    {\n+    }\n+    \n+    /**\n+     * @see Nestable#printPartialStackTrace(PrintWriter)\n+     * Empty method to satisfy the implemented interface. Does nothing\n+     * in this test.\n+     */\n+    public void printPartialStackTrace(PrintWriter out)\n+    {\n+    }\n+    \n+\n+    /**\n+     * @see Nestable#getThrowable(int)\n+     * Returns <code>null</code> for this test.\n+     */\n+    public Throwable getThrowable(int index)\n+    {\n+        return null;\n+    }\n+    \n+    /**\n+     * @see Nestable#getThrowables()\n+     * Returns zero-length <code>Throwable</code> array.\n+     */\n+    public Throwable[] getThrowables()\n+    {\n+        return new Throwable[0];\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class)\n+     * Returns -1 for this test.\n+     */\n+    public int indexOfThrowable(Class type)\n+    {\n+        return -1;\n+    }\n+    \n+    /**\n+     * @see Nestable#indexOfThrowable(Class, int)\n+     * Returns -1 for this test.\n+     */\n+    public int indexOfThrowable(Class type, int fromIndex)\n+    {\n+        return -1;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/exception/NestableErrorTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.EOFException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests the org.apache.commons.lang.exception.NestableError class.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id$\n+ */\n+public class NestableErrorTestCase extends AbstractNestableTestCase {\n+    \n+    /**\n+     * Construct a new instance of\n+     * <code>NestableErrorTestCase</code>.\n+     *\n+     * @param name test case name\n+     */\n+    public NestableErrorTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Sets up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+    }\n+\n+    /**\n+     * Returns the test suite\n+     *\n+     * @return the test suite\n+     */\n+    public static Test suite()\n+    {\n+        return new TestSuite(NestableErrorTestCase.class);\n+    }\n+    \n+    /**\n+     * Tears down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+    }\n+\n+    /**\n+     * Command line entry point for running the test suite.\n+     *\n+     * @param args array of command line arguments\n+     */\n+    public static void main(String args[])\n+    {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * @see AbstractNestableTestCase#getNestable()\n+     */\n+    public Nestable getNestable()\n+    {\n+        return new NestableError();\n+    }    \n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(Nestable)\n+     */\n+    public Nestable getNestable(Nestable n)\n+    {\n+        return new NestableError((Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String)\n+     */\n+    public Nestable getNestable(String msg)\n+    {\n+        return new NestableError(msg);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(Throwable)\n+     */\n+    public Nestable getNestable(Throwable t)\n+    {\n+        return new NestableError(t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String, Throwable)\n+     */\n+    public Nestable getNestable(String msg, Throwable t)\n+    {\n+        return new NestableError(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String, Nestable)\n+     */\n+    public Nestable getNestable(String msg, Nestable n)\n+    {\n+        return new NestableError(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(Throwable)\n+     */\n+    public Nestable getTester1(Throwable t)\n+    {\n+        return new NestableErrorTester1(t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(Nestable)\n+     */\n+    public Nestable getTester1(Nestable n)\n+    {\n+        return new NestableErrorTester1((Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(String, Throwable)\n+     */\n+    public Nestable getTester1(String msg, Throwable t)\n+    {\n+        return new NestableErrorTester1(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(String, Nestable)\n+     */\n+    public Nestable getTester1(String msg, Nestable n)\n+    {\n+        return new NestableErrorTester1(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1Class()\n+     */\n+    public Class getTester1Class()\n+    {\n+        return NestableErrorTester1.class;\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2(String, Throwable)\n+     */\n+    public Nestable getTester2(String msg, Throwable t)\n+    {\n+        return new NestableErrorTester2(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2(String, Nestable)\n+     */\n+    public Nestable getTester2(String msg, Nestable n)\n+    {\n+        return new NestableErrorTester2(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2Class()\n+     */\n+    public Class getTester2Class()\n+    {\n+        return NestableErrorTester2.class;\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getThrowable(String)\n+     */\n+    public Throwable getThrowable(String msg)\n+    {\n+        return new EOFException(msg);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getThrowableClass()\n+     */\n+    public Class getThrowableClass()\n+    {\n+        return EOFException.class;\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getBaseThrowableClass()\n+     */\n+    public Class getBaseThrowableClass()\n+    {\n+        return Error.class;\n+    }\n+    \n+}\n+\n+/**\n+ * First nestable tester implementation for use in test cases.\n+ */\n+class NestableErrorTester1 extends NestableError\n+{\n+    public NestableErrorTester1()\n+    {\n+        super();\n+    }\n+\n+    public NestableErrorTester1(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableErrorTester1(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableErrorTester1(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n+\n+/**\n+ * Second nestable tester implementation for use in test cases.\n+ */\n+class NestableErrorTester2 extends NestableError\n+{\n+    public NestableErrorTester2()\n+    {\n+        super();\n+    }\n+    \n+    public NestableErrorTester2(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableErrorTester2(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableErrorTester2(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/exception/NestableExceptionTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.EOFException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.PrintStream;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests the org.apache.commons.lang.exception.NestableException class.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id$\n+ */\n+public class NestableExceptionTestCase extends AbstractNestableTestCase {\n+    \n+    /**\n+     * Construct a new instance of\n+     * <code>NestableExceptionTestCase</code>.\n+     *\n+     * @param name test case name\n+     */\n+    public NestableExceptionTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Sets up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+    }\n+    \n+    /**\n+     * Returns the test suite\n+     *\n+     * @return the test suite\n+     */\n+    public static Test suite()\n+    {\n+        return new TestSuite(NestableExceptionTestCase.class);\n+    }\n+    \n+    /**\n+     * Tears down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+    }\n+    \n+    /**\n+     * Command line entry point for running the test suite.\n+     *\n+     * @param args array of command line arguments\n+     */\n+    public static void main(String args[])\n+    {\n+        TestRunner.run(suite());\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable()\n+     */\n+    public Nestable getNestable()\n+    {\n+        return new NestableException();\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(Nestable)\n+     */\n+    public Nestable getNestable(Nestable n)\n+    {\n+        return new NestableException((Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String)\n+     */\n+    public Nestable getNestable(String msg)\n+    {\n+        return new NestableException(msg);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(Throwable)\n+     */\n+    public Nestable getNestable(Throwable t)\n+    {\n+        return new NestableException(t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String, Throwable)\n+     */\n+    public Nestable getNestable(String msg, Throwable t)\n+    {\n+        return new NestableException(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String, Nestable)\n+     */\n+    public Nestable getNestable(String msg, Nestable n)\n+    {\n+        return new NestableException(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(Throwable)\n+     */\n+    public Nestable getTester1(Throwable t)\n+    {\n+        return new NestableExceptionTester1(t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(Nestable)\n+     */\n+    public Nestable getTester1(Nestable n)\n+    {\n+        return new NestableExceptionTester1((Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(String, Throwable)\n+     */\n+    public Nestable getTester1(String msg, Throwable t)\n+    {\n+        return new NestableExceptionTester1(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(String, Nestable)\n+     */\n+    public Nestable getTester1(String msg, Nestable n)\n+    {\n+        return new NestableExceptionTester1(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1Class()\n+     */\n+    public Class getTester1Class()\n+    {\n+        return NestableExceptionTester1.class;\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2(String, Throwable)\n+     */\n+    public Nestable getTester2(String msg, Throwable t)\n+    {\n+        return new NestableExceptionTester2(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2(String, Nestable)\n+     */\n+    public Nestable getTester2(String msg, Nestable n)\n+    {\n+        return new NestableExceptionTester2(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2Class()\n+     */\n+    public Class getTester2Class()\n+    {\n+        return NestableExceptionTester2.class;\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getThrowable(String)\n+     */\n+    public Throwable getThrowable(String msg)\n+    {\n+        return new EOFException(msg);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getThrowableClass()\n+     */\n+    public Class getThrowableClass()\n+    {\n+        return EOFException.class;\n+    }\n+\n+    /**\n+     * @see AbstractNestableTestCase#getBaseThrowableClass()\n+     */\n+    public Class getBaseThrowableClass()\n+    {\n+        return Exception.class;\n+    }\n+    \n+    public void testSpecificPrintStackTrace()\n+    {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(baos);\n+        NestableException ne = new NestableException(\"outer\", new NestableException(\"inner\", new Exception(\"another exception\")));\n+        for(int i = 0; i < 2; i++)\n+        {\n+            if(i == 0)\n+            {\n+                // Test printStackTrac()\n+                // Replace System.err with our own PrintStream so that we can\n+                // obtain and check the printStrackTrace output\n+                PrintStream err = System.err;\n+                System.setErr(ps);\n+                ne.printStackTrace();\n+                // Restore the System.err\n+                System.setErr(err);\n+            }\n+            else\n+            {\n+                // Test printStackTrace(PrintStream)\n+                ne.printStackTrace(ps);\n+            }\n+        }\n+        String msg = baos.toString();\n+        assertTrue( \"printStackTrace() starts with outer message\", msg.startsWith(\"org.apache.commons.lang.exception.NestableException: outer\"));\n+        assertTrue( \"printStackTrace() contains 1st nested message\", msg.indexOf(\"Caused by: org.apache.commons.lang.exception.NestableException: inner\") >= 0);\n+        assertTrue( \"printStackTrace() contains 2nd nested message\", msg.indexOf(\"Caused by: java.lang.Exception: another exception\") >= 0);\n+        assertTrue( \"printStackTrace() inner message after outer message\", \n+            msg.indexOf(\"org.apache.commons.lang.exception.NestableException: outer\") <\n+            msg.indexOf(\"Caused by: org.apache.commons.lang.exception.NestableException: inner\"));\n+        assertTrue( \"printStackTrace() cause message after inner message\",\n+            msg.indexOf(\"Caused by: org.apache.commons.lang.exception.NestableException: inner\") <\n+            msg.indexOf(\"Caused by: java.lang.Exception: another exception\"));\n+    }\n+    \n+    public void testSerialization()\n+        throws java.io.IOException, ClassNotFoundException\n+    {\n+        RuntimeException nestedEx = new RuntimeException(\"nested exception message\");\n+        NestableExceptionTester1 ex = new NestableExceptionTester1(\"serialization test\", nestedEx);\n+\n+        assertTrue( \"implements java.io.Serializable\", nestedEx instanceof java.io.Serializable);\n+        \n+        assertTrue( \"implements java.io.Serializable\", ex instanceof java.io.Serializable);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ByteArrayInputStream bais = null;\n+        ObjectOutputStream oos = null;\n+        ObjectInputStream ois = null;\n+\n+        try\n+        {        \n+            oos = new ObjectOutputStream(baos);\n+            oos.writeObject(ex);\n+            oos.flush();\n+            bais = new ByteArrayInputStream(baos.toByteArray());\n+            ois = new ObjectInputStream(bais);\n+            NestableExceptionTester1 deserializedEx = (NestableExceptionTester1) ois.readObject();\n+            assertEquals( \n+                    \"getThrowableCount() return value\",\n+                        ex.getThrowableCount(),\n+                        deserializedEx.getThrowableCount());\n+            \n+            for (int i = 0; i < ex.getThrowableCount(); i++)\n+            {\n+                Throwable t = ex.getThrowable(i);\n+                Throwable deserializedThrowable = deserializedEx.getThrowable(i);\n+                \n+                assertEquals( t.getClass(),\n+                        deserializedThrowable.getClass());\n+                        \n+                assertEquals(\n+                    t.getMessage(),\n+                    deserializedThrowable.getMessage());\n+            }\n+        }\n+        finally\n+        {\n+            if (null != oos)\n+            {\n+                try\n+                {\n+                    oos.close();\n+                }\n+                catch (Exception ignored)\n+                {\n+                    // intentionally empty\n+                }\n+            }\n+        }\n+        \n+    }\n+}\n+\n+/**\n+ * First nestable tester implementation for use in test cases.\n+ */\n+class NestableExceptionTester1 extends NestableException\n+{\n+    public NestableExceptionTester1()\n+    {\n+        super();\n+    }\n+\n+    public NestableExceptionTester1(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableExceptionTester1(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableExceptionTester1(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n+\n+/**\n+ * Second nestable tester implementation for use in test cases.\n+ */\n+class NestableExceptionTester2 extends NestableException\n+{\n+    public NestableExceptionTester2()\n+    {\n+        super();\n+    }\n+    \n+    public NestableExceptionTester2(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableExceptionTester2(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableExceptionTester2(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/exception/NestableRuntimeExceptionTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.exception;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.EOFException;\n+import java.io.PrintStream;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Tests the org.apache.commons.lang.exception.NestableRuntimeException class.\n+ *\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @version $Id$\n+ */\n+public class NestableRuntimeExceptionTestCase extends AbstractNestableTestCase {\n+    \n+    /**\n+     * Construct a new instance of\n+     * <code>NestableRuntimeExceptionTestCase</code>.\n+     *\n+     * @param name test case name\n+     */\n+    public NestableRuntimeExceptionTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+    /**\n+     * Sets up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+    }\n+    \n+    /**\n+     * Returns the test suite\n+     *\n+     * @return the test suite\n+     */\n+    public static Test suite()\n+    {\n+        return new TestSuite(NestableRuntimeExceptionTestCase.class);\n+    }\n+    \n+    /**\n+     * Tears down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+    }\n+    \n+    /**\n+     * Command line entry point for running the test suite.\n+     *\n+     * @param args array of command line arguments\n+     */\n+    public static void main(String args[])\n+    {\n+        TestRunner.run(suite());\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable()\n+     */\n+    public Nestable getNestable()\n+    {\n+        return new NestableRuntimeException();\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(Nestable)\n+     */\n+    public Nestable getNestable(Nestable n)\n+    {\n+        return new NestableRuntimeException((Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String)\n+     */\n+    public Nestable getNestable(String msg)\n+    {\n+        return new NestableRuntimeException(msg);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(Throwable)\n+     */\n+    public Nestable getNestable(Throwable t)\n+    {\n+        return new NestableRuntimeException(t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String, Throwable)\n+     */\n+    public Nestable getNestable(String msg, Throwable t)\n+    {\n+        return new NestableRuntimeException(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getNestable(String, Nestable)\n+     */\n+    public Nestable getNestable(String msg, Nestable n)\n+    {\n+        return new NestableRuntimeException(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(Throwable)\n+     */\n+    public Nestable getTester1(Throwable t)\n+    {\n+        return new NestableRuntimeExceptionTester1(t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(Nestable)\n+     */\n+    public Nestable getTester1(Nestable n)\n+    {\n+        return new NestableRuntimeExceptionTester1((Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(String, Throwable)\n+     */\n+    public Nestable getTester1(String msg, Throwable t)\n+    {\n+        return new NestableRuntimeExceptionTester1(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1(String, Nestable)\n+     */\n+    public Nestable getTester1(String msg, Nestable n)\n+    {\n+        return new NestableRuntimeExceptionTester1(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester1Class()\n+     */\n+    public Class getTester1Class()\n+    {\n+        return NestableRuntimeExceptionTester1.class;\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2(String, Throwable)\n+     */\n+    public Nestable getTester2(String msg, Throwable t)\n+    {\n+        return new NestableRuntimeExceptionTester2(msg, t);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2(String, Nestable)\n+     */\n+    public Nestable getTester2(String msg, Nestable n)\n+    {\n+        return new NestableRuntimeExceptionTester2(msg, (Throwable) n);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getTester2Class()\n+     */\n+    public Class getTester2Class()\n+    {\n+        return NestableRuntimeExceptionTester2.class;\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getThrowable(String)\n+     */\n+    public Throwable getThrowable(String msg)\n+    {\n+        return new EOFException(msg);\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getThrowableClass()\n+     */\n+    public Class getThrowableClass()\n+    {\n+        return EOFException.class;\n+    }\n+    \n+    /**\n+     * @see AbstractNestableTestCase#getBaseThrowableClass()\n+     */\n+    public Class getBaseThrowableClass()\n+    {\n+        return RuntimeException.class;\n+    }\n+    \n+    public void testSpecificPrintStackTrace()\n+    {\n+        // Test printStackTrac()\n+        // Replace System.err with our own PrintStream so that we can obtain\n+        // and check the printStrackTrace output\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(baos);\n+        NestableRuntimeException ne = new NestableRuntimeException(\"outer\", new NestableRuntimeException(\"inner\", new Exception(\"another exception\")));\n+        for(int i = 0; i < 2; i++)\n+        {\n+            if(i == 0)\n+            {\n+                // Test printStackTrac()\n+                // Replace System.err with our own PrintStream so that we can\n+                // obtain and check the printStrackTrace output\n+                PrintStream err = System.err;\n+                System.setErr(ps);\n+                ne.printStackTrace();\n+                // Restore the System.err\n+                System.setErr(err);\n+            }\n+            else\n+            {\n+                // Test printStackTrace(PrintStream)\n+                ne.printStackTrace(ps);\n+            }\n+        }\n+        String msg = baos.toString();\n+        assertTrue( \"printStackTrace() starts with outer message\", msg.startsWith(\"org.apache.commons.lang.exception.NestableRuntimeException: outer\"));\n+        assertTrue( \"printStackTrace() contains 1st nested message\", msg.indexOf(\"Caused by: org.apache.commons.lang.exception.NestableRuntimeException: inner\") >= 0);\n+        assertTrue( \"printStackTrace() contains 2nd nested message\", msg.indexOf(\"Caused by: java.lang.Exception: another exception\") >= 0);\n+        assertTrue( \"printStackTrace() inner message after outer message\", \n+            msg.indexOf(\"org.apache.commons.lang.exception.NestableRuntimeException: outer\") <\n+            msg.indexOf(\"Caused by: org.apache.commons.lang.exception.NestableRuntimeException: inner\"));\n+        assertTrue( \"printStackTrace() cause message after inner message\",\n+            msg.indexOf(\"Caused by: org.apache.commons.lang.exception.NestableRuntimeException: inner\") <\n+            msg.indexOf(\"Caused by: java.lang.Exception: another exception\"));\n+    }\n+    \n+}\n+\n+/**\n+ * First nestable tester implementation for use in test cases.\n+ */\n+class NestableRuntimeExceptionTester1 extends NestableRuntimeException\n+{\n+    public NestableRuntimeExceptionTester1()\n+    {\n+        super();\n+    }\n+\n+    public NestableRuntimeExceptionTester1(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableRuntimeExceptionTester1(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableRuntimeExceptionTester1(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n+\n+/**\n+ * Second nestable tester implementation.\n+ */\n+class NestableRuntimeExceptionTester2 extends NestableRuntimeException\n+{\n+    public NestableRuntimeExceptionTester2()\n+    {\n+        super();\n+    }\n+    \n+    public NestableRuntimeExceptionTester2(String reason, Throwable cause)\n+    {\n+        super(reason, cause);\n+    }\n+    \n+    public NestableRuntimeExceptionTester2(String reason)\n+    {\n+        super(reason);\n+    }\n+    \n+    public NestableRuntimeExceptionTester2(Throwable cause)\n+    {\n+        super(cause);\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/AbstractRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for the {@link Range} classes.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public abstract class AbstractRangeTest extends TestCase {\n+\n+    protected Range tenToTwenty;\n+    protected Range otherRange;\n+    \n+    protected Integer five;\n+    protected Integer ten;\n+    protected Integer twelve;\n+    protected Integer fifteen;\n+    protected Integer twenty;\n+    protected Integer twentyFive;\n+    protected Long long8;\n+    protected Long long10;\n+    protected Long long12;\n+    protected Long long20;\n+    protected Long long21;\n+    protected Double double8;\n+    protected Double double10;\n+    protected Double double12;\n+    protected Double double20;\n+    protected Double double21;\n+    protected Float float8;\n+    protected Float float10;\n+    protected Float float12;\n+    protected Float float20;\n+    protected Float float21;\n+    \n+    private static class InnerNumber extends Number {\n+        public double doubleValue() {\n+            return 12d;\n+        }\n+        public float floatValue() {\n+            return 12f;\n+        }\n+        public int intValue() {\n+            return 12;\n+        }\n+        public long longValue() {\n+            return 12L;\n+        }\n+    }\n+    \n+    protected InnerNumber nonComparableNumber = new InnerNumber();\n+\n+\n+    public AbstractRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        five = new Integer(5);\n+        ten = new Integer(10);\n+        twelve = new Integer(12);\n+        fifteen = new Integer(15);\n+        twenty = new Integer(20);\n+        twentyFive = new Integer(25);\n+        long8 = new Long(8);\n+        long10 = new Long(10);\n+        long12 = new Long(12);\n+        long20 = new Long(20);\n+        long21 = new Long(21);\n+        double8 = new Double(8);\n+        double10 = new Double(10);\n+        double12 = new Double(12);\n+        double20 = new Double(20);\n+        double21 = new Double(21);\n+        float8 = new Float(8);\n+        float10 = new Float(10);\n+        float12 = new Float(12);\n+        float20 = new Float(20);\n+        float21 = new Float(21);\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+    public void testGetMinimum() {\n+        assertEquals(10L, tenToTwenty.getMinimumLong());\n+        assertEquals(10, tenToTwenty.getMinimumInteger());\n+        assertEquals(10d, tenToTwenty.getMinimumDouble(), 0.00001d);\n+        assertEquals(10f, tenToTwenty.getMinimumFloat(), 0.00001f);\n+    }\n+    \n+    public void testGetMaximum() {\n+        assertEquals(20L, tenToTwenty.getMaximumLong());\n+        assertEquals(20, tenToTwenty.getMaximumInteger());\n+        assertEquals(20d, tenToTwenty.getMaximumDouble(), 0.00001d);\n+        assertEquals(20f, tenToTwenty.getMaximumFloat(), 0.00001f);\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testContainsLong() {\n+        assertEquals(false, tenToTwenty.containsLong(null));\n+        assertEquals(true, tenToTwenty.containsLong(nonComparableNumber));\n+        \n+        assertEquals(false, tenToTwenty.containsLong(five));\n+        assertEquals(true, tenToTwenty.containsLong(ten));\n+        assertEquals(true, tenToTwenty.containsLong(fifteen));\n+        assertEquals(true, tenToTwenty.containsLong(twenty));\n+        assertEquals(false, tenToTwenty.containsLong(twentyFive));\n+        \n+        assertEquals(false, tenToTwenty.containsLong(long8));\n+        assertEquals(true, tenToTwenty.containsLong(long10));\n+        assertEquals(true, tenToTwenty.containsLong(long12));\n+        assertEquals(true, tenToTwenty.containsLong(long20));\n+        assertEquals(false, tenToTwenty.containsLong(long21));\n+        \n+        assertEquals(false, tenToTwenty.containsLong(double8));\n+        assertEquals(true, tenToTwenty.containsLong(double10));\n+        assertEquals(true, tenToTwenty.containsLong(double12));\n+        assertEquals(true, tenToTwenty.containsLong(double20));\n+        assertEquals(false, tenToTwenty.containsLong(double21));\n+        \n+        assertEquals(false, tenToTwenty.containsLong(float8));\n+        assertEquals(true, tenToTwenty.containsLong(float10));\n+        assertEquals(true, tenToTwenty.containsLong(float12));\n+        assertEquals(true, tenToTwenty.containsLong(float20));\n+        assertEquals(false, tenToTwenty.containsLong(float21));\n+        \n+        assertEquals(false, tenToTwenty.containsLong(9L));\n+        assertEquals(true, tenToTwenty.containsLong(10L));\n+        assertEquals(true, tenToTwenty.containsLong(15L));\n+        assertEquals(true, tenToTwenty.containsLong(20L));\n+        assertEquals(false, tenToTwenty.containsLong(21L));\n+    }\n+        \n+    public void testContainsInteger() {\n+        assertEquals(false, tenToTwenty.containsInteger(null));\n+        assertEquals(true, tenToTwenty.containsInteger(nonComparableNumber));\n+        \n+        assertEquals(false, tenToTwenty.containsInteger(five));\n+        assertEquals(true, tenToTwenty.containsInteger(ten));\n+        assertEquals(true, tenToTwenty.containsInteger(fifteen));\n+        assertEquals(true, tenToTwenty.containsInteger(twenty));\n+        assertEquals(false, tenToTwenty.containsInteger(twentyFive));\n+        \n+        assertEquals(false, tenToTwenty.containsInteger(long8));\n+        assertEquals(true, tenToTwenty.containsInteger(long10));\n+        assertEquals(true, tenToTwenty.containsInteger(long12));\n+        assertEquals(true, tenToTwenty.containsInteger(long20));\n+        assertEquals(false, tenToTwenty.containsInteger(long21));\n+        \n+        assertEquals(false, tenToTwenty.containsInteger(double8));\n+        assertEquals(true, tenToTwenty.containsInteger(double10));\n+        assertEquals(true, tenToTwenty.containsInteger(double12));\n+        assertEquals(true, tenToTwenty.containsInteger(double20));\n+        assertEquals(false, tenToTwenty.containsInteger(double21));\n+        \n+        assertEquals(false, tenToTwenty.containsInteger(float8));\n+        assertEquals(true, tenToTwenty.containsInteger(float10));\n+        assertEquals(true, tenToTwenty.containsInteger(float12));\n+        assertEquals(true, tenToTwenty.containsInteger(float20));\n+        assertEquals(false, tenToTwenty.containsInteger(float21));\n+        \n+        assertEquals(false, tenToTwenty.containsInteger(9));\n+        assertEquals(true, tenToTwenty.containsInteger(10));\n+        assertEquals(true, tenToTwenty.containsInteger(15));\n+        assertEquals(true, tenToTwenty.containsInteger(20));\n+        assertEquals(false, tenToTwenty.containsInteger(21));\n+    }\n+\n+    public void testContainsDouble() {\n+        assertEquals(false, tenToTwenty.containsDouble(null));\n+        assertEquals(true, tenToTwenty.containsDouble(nonComparableNumber));\n+        \n+        assertEquals(false, tenToTwenty.containsDouble(five));\n+        assertEquals(true, tenToTwenty.containsDouble(ten));\n+        assertEquals(true, tenToTwenty.containsDouble(fifteen));\n+        assertEquals(true, tenToTwenty.containsDouble(twenty));\n+        assertEquals(false, tenToTwenty.containsDouble(twentyFive));\n+        \n+        assertEquals(false, tenToTwenty.containsDouble(long8));\n+        assertEquals(true, tenToTwenty.containsDouble(long10));\n+        assertEquals(true, tenToTwenty.containsDouble(long12));\n+        assertEquals(true, tenToTwenty.containsDouble(long20));\n+        assertEquals(false, tenToTwenty.containsDouble(long21));\n+        \n+        assertEquals(false, tenToTwenty.containsDouble(double8));\n+        assertEquals(true, tenToTwenty.containsDouble(double10));\n+        assertEquals(true, tenToTwenty.containsDouble(double12));\n+        assertEquals(true, tenToTwenty.containsDouble(double20));\n+        assertEquals(false, tenToTwenty.containsDouble(double21));\n+        \n+        assertEquals(false, tenToTwenty.containsDouble(float8));\n+        assertEquals(true, tenToTwenty.containsDouble(float10));\n+        assertEquals(true, tenToTwenty.containsDouble(float12));\n+        assertEquals(true, tenToTwenty.containsDouble(float20));\n+        assertEquals(false, tenToTwenty.containsDouble(float21));\n+        \n+        assertEquals(false, tenToTwenty.containsDouble(9d));\n+        assertEquals(true, tenToTwenty.containsDouble(10d));\n+        assertEquals(true, tenToTwenty.containsDouble(15d));\n+        assertEquals(true, tenToTwenty.containsDouble(20d));\n+        assertEquals(false, tenToTwenty.containsDouble(21d));\n+    }\n+\n+    public void testContainsFloat() {\n+        assertEquals(false, tenToTwenty.containsFloat(null));\n+        assertEquals(true, tenToTwenty.containsFloat(nonComparableNumber));\n+        \n+        assertEquals(false, tenToTwenty.containsFloat(five));\n+        assertEquals(true, tenToTwenty.containsFloat(ten));\n+        assertEquals(true, tenToTwenty.containsFloat(fifteen));\n+        assertEquals(true, tenToTwenty.containsFloat(twenty));\n+        assertEquals(false, tenToTwenty.containsFloat(twentyFive));\n+        \n+        assertEquals(false, tenToTwenty.containsFloat(long8));\n+        assertEquals(true, tenToTwenty.containsFloat(long10));\n+        assertEquals(true, tenToTwenty.containsFloat(long12));\n+        assertEquals(true, tenToTwenty.containsFloat(long20));\n+        assertEquals(false, tenToTwenty.containsFloat(long21));\n+        \n+        assertEquals(false, tenToTwenty.containsFloat(double8));\n+        assertEquals(true, tenToTwenty.containsFloat(double10));\n+        assertEquals(true, tenToTwenty.containsFloat(double12));\n+        assertEquals(true, tenToTwenty.containsFloat(double20));\n+        assertEquals(false, tenToTwenty.containsFloat(double21));\n+        \n+        assertEquals(false, tenToTwenty.containsFloat(float8));\n+        assertEquals(true, tenToTwenty.containsFloat(float10));\n+        assertEquals(true, tenToTwenty.containsFloat(float12));\n+        assertEquals(true, tenToTwenty.containsFloat(float20));\n+        assertEquals(false, tenToTwenty.containsFloat(float21));\n+        \n+        assertEquals(false, tenToTwenty.containsFloat(9f));\n+        assertEquals(true, tenToTwenty.containsFloat(10f));\n+        assertEquals(true, tenToTwenty.containsFloat(15f));\n+        assertEquals(true, tenToTwenty.containsFloat(20f));\n+        assertEquals(false, tenToTwenty.containsFloat(21f));\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testContainsRange() {\n+        assertEquals(false, tenToTwenty.containsRange(null));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(five, five)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(five, ten)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(five, twelve)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(five, fifteen)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(five, twenty)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(five, twentyFive)));\n+        \n+        assertEquals(true, tenToTwenty.containsRange(createRange(ten, ten)));\n+        assertEquals(true, tenToTwenty.containsRange(createRange(ten, twelve)));\n+        assertEquals(true, tenToTwenty.containsRange(createRange(ten, fifteen)));\n+        assertEquals(true, tenToTwenty.containsRange(createRange(ten, twenty)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(ten, twentyFive)));\n+        \n+        assertEquals(true, tenToTwenty.containsRange(createRange(twelve, twelve)));\n+        assertEquals(true, tenToTwenty.containsRange(createRange(twelve, fifteen)));\n+        assertEquals(true, tenToTwenty.containsRange(createRange(twelve, twenty)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(twelve, twentyFive)));\n+        \n+        assertEquals(true, tenToTwenty.containsRange(createRange(fifteen, fifteen)));\n+        assertEquals(true, tenToTwenty.containsRange(createRange(fifteen, twenty)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(fifteen, twentyFive)));\n+        \n+        assertEquals(true, tenToTwenty.containsRange(createRange(twenty, twenty)));\n+        assertEquals(false, tenToTwenty.containsRange(createRange(twenty, twentyFive)));\n+        \n+        assertEquals(false, tenToTwenty.containsRange(createRange(twentyFive, twentyFive)));\n+    }\n+\n+    public void testOverlapsRange() {\n+        assertEquals(false, tenToTwenty.overlapsRange(null));\n+        assertEquals(false, tenToTwenty.overlapsRange(createRange(five, five)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, ten)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, twelve)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, fifteen)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, twenty)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, twentyFive)));\n+        \n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, ten)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, twelve)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, fifteen)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, twenty)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, twentyFive)));\n+        \n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(twelve, twelve)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(twelve, fifteen)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(twelve, twenty)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(twelve, twentyFive)));\n+        \n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(fifteen, fifteen)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(fifteen, twenty)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(fifteen, twentyFive)));\n+        \n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(twenty, twenty)));\n+        assertEquals(true, tenToTwenty.overlapsRange(createRange(twenty, twentyFive)));\n+        \n+        assertEquals(false, tenToTwenty.overlapsRange(createRange(twentyFive, twentyFive)));\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testEquals() {\n+        assertEquals(false, tenToTwenty.equals(createRange(ten, fifteen)));\n+        assertEquals(false, tenToTwenty.equals(createRange(ten, twentyFive)));\n+        \n+        assertEquals(false, tenToTwenty.equals(createRange(fifteen, twenty)));\n+        assertEquals(false, tenToTwenty.equals(createRange(five, twenty)));\n+        \n+        assertEquals(false, tenToTwenty.equals(createRange(five, ten)));\n+        assertEquals(false, tenToTwenty.equals(createRange(ten)));\n+\n+        assertEquals(true, tenToTwenty.equals(tenToTwenty));\n+        assertEquals(true, tenToTwenty.equals(createRange(ten, twenty)));\n+        assertEquals(true, tenToTwenty.equals(createRange(twenty, ten)));\n+        \n+        assertEquals(false, tenToTwenty.equals(null));\n+        assertEquals(false, tenToTwenty.equals(new Object()));\n+        assertEquals(false, tenToTwenty.equals(otherRange));\n+    }\n+\n+    public void testHashCode() {\n+        assertEquals(tenToTwenty.hashCode(), tenToTwenty.hashCode());\n+        assertTrue(tenToTwenty.hashCode() != 0);\n+    }\n+    \n+    public void testToString() {\n+        String str = tenToTwenty.toString();\n+        assertEquals(\"Range[10,20]\", str);\n+        assertSame(str, tenToTwenty.toString());\n+        assertEquals(\"Range[-20,-10]\", createRange(new Integer(-20), new Integer(-10)).toString());\n+    }\n+\n+\n+    protected abstract Range createRange(Integer integer);\n+    protected abstract Range createRange(Integer integer1, Integer integer2);\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/DoubleRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link DoubleRange} class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public final class DoubleRangeTest extends AbstractRangeTest {\n+\n+    public DoubleRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DoubleRangeTest.class);\n+        suite.setName(\"DoubleRange Tests\");\n+        return suite;\n+    }\n+    \n+    public void setUp() {\n+        super.setUp();\n+        tenToTwenty = new DoubleRange(double10, double20);\n+        otherRange = new NumberRange(ten, twenty);\n+    }\n+\n+    protected Range createRange(Integer integer1, Integer integer2) {\n+        return new DoubleRange(integer1, integer2);\n+    }\n+    protected Range createRange(Integer integer) {\n+        return new NumberRange(integer);\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+\n+    public void testConstructor1a() {\n+        DoubleRange nr = new DoubleRange(8d);\n+        assertEquals(double8, nr.getMinimumNumber());\n+        assertEquals(double8, nr.getMaximumNumber());\n+        \n+        try {\n+            new DoubleRange(Double.NaN);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testConstructor1b() {\n+        DoubleRange nr = new DoubleRange(double8);\n+        assertSame(double8, nr.getMinimumNumber());\n+        assertSame(double8, nr.getMaximumNumber());\n+        \n+        Range r = new DoubleRange(nonComparableNumber);\n+        \n+        try {\n+            new DoubleRange(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DoubleRange(new Double(Double.NaN));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testConstructor2a() {\n+        DoubleRange nr = new DoubleRange(8d, 10d);\n+        assertEquals(double8, nr.getMinimumNumber());\n+        assertEquals(double10, nr.getMaximumNumber());\n+        \n+        nr = new DoubleRange(10d, 8d);\n+        assertEquals(double8, nr.getMinimumNumber());\n+        assertEquals(double10, nr.getMaximumNumber());\n+        \n+        try {\n+            new DoubleRange(Double.NaN, 8d);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor2b() {\n+        DoubleRange nr = new DoubleRange(double8, double10);\n+        assertSame(double8, nr.getMinimumNumber());\n+        assertSame(double10, nr.getMaximumNumber());\n+        \n+        nr = new DoubleRange(double10, double8);\n+        assertSame(double8, nr.getMinimumNumber());\n+        assertSame(double10, nr.getMaximumNumber());\n+        \n+        nr = new DoubleRange(double8, double10);\n+        assertSame(double8, nr.getMinimumNumber());\n+        assertEquals(double10, nr.getMaximumNumber());\n+        \n+        // not null\n+        try {\n+            new DoubleRange(double8, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DoubleRange(null, double8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new DoubleRange(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            new DoubleRange(new Double(Double.NaN), double10);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testContainsNumber() {\n+        assertEquals(false, tenToTwenty.containsNumber(null));\n+        assertEquals(true, tenToTwenty.containsNumber(nonComparableNumber));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(five));\n+        assertEquals(true, tenToTwenty.containsNumber(ten));\n+        assertEquals(true, tenToTwenty.containsNumber(fifteen));\n+        assertEquals(true, tenToTwenty.containsNumber(twenty));\n+        assertEquals(false, tenToTwenty.containsNumber(twentyFive));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(long8));\n+        assertEquals(true, tenToTwenty.containsNumber(long10));\n+        assertEquals(true, tenToTwenty.containsNumber(long12));\n+        assertEquals(true, tenToTwenty.containsNumber(long20));\n+        assertEquals(false, tenToTwenty.containsNumber(long21));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(double8));\n+        assertEquals(true, tenToTwenty.containsNumber(double10));\n+        assertEquals(true, tenToTwenty.containsNumber(double12));\n+        assertEquals(true, tenToTwenty.containsNumber(double20));\n+        assertEquals(false, tenToTwenty.containsNumber(double21));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(float8));\n+        assertEquals(true, tenToTwenty.containsNumber(float10));\n+        assertEquals(true, tenToTwenty.containsNumber(float12));\n+        assertEquals(true, tenToTwenty.containsNumber(float20));\n+        assertEquals(false, tenToTwenty.containsNumber(float21));\n+    }\n+\n+    public void testToString() {\n+        String str = tenToTwenty.toString();\n+        assertEquals(\"Range[10.0,20.0]\", str);\n+        assertSame(str, tenToTwenty.toString());\n+        assertEquals(\"Range[-20.0,-10.0]\", createRange(new Integer(-20), new Integer(-10)).toString());\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/FloatRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link FloatRange} class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public final class FloatRangeTest extends AbstractRangeTest {\n+\n+    public FloatRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FloatRangeTest.class);\n+        suite.setName(\"FloatRange Tests\");\n+        return suite;\n+    }\n+    \n+    public void setUp() {\n+        super.setUp();\n+        tenToTwenty = new FloatRange(float10, float20);\n+        otherRange = new NumberRange(ten, twenty);\n+    }\n+\n+    protected Range createRange(Integer integer1, Integer integer2) {\n+        return new FloatRange(integer1, integer2);\n+    }\n+    protected Range createRange(Integer integer) {\n+        return new NumberRange(integer);\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+\n+    public void testConstructor1a() {\n+        FloatRange nr = new FloatRange(8f);\n+        assertEquals(float8, nr.getMinimumNumber());\n+        assertEquals(float8, nr.getMaximumNumber());\n+        \n+        try {\n+            new FloatRange(Float.NaN);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testConstructor1b() {\n+        FloatRange nr = new FloatRange(float8);\n+        assertSame(float8, nr.getMinimumNumber());\n+        assertSame(float8, nr.getMaximumNumber());\n+        \n+        Range r = new FloatRange(nonComparableNumber);\n+        \n+        try {\n+            new FloatRange(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new FloatRange(new Double(Double.NaN));\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testConstructor2a() {\n+        FloatRange nr = new FloatRange(8f, 10f);\n+        assertEquals(float8, nr.getMinimumNumber());\n+        assertEquals(float10, nr.getMaximumNumber());\n+        \n+        nr = new FloatRange(10f, 8f);\n+        assertEquals(float8, nr.getMinimumNumber());\n+        assertEquals(float10, nr.getMaximumNumber());\n+        \n+        try {\n+            new FloatRange(Float.NaN, 8f);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testConstructor2b() {\n+        FloatRange nr = new FloatRange(float8, float10);\n+        assertSame(float8, nr.getMinimumNumber());\n+        assertSame(float10, nr.getMaximumNumber());\n+        \n+        nr = new FloatRange(float10, float8);\n+        assertSame(float8, nr.getMinimumNumber());\n+        assertSame(float10, nr.getMaximumNumber());\n+        \n+        nr = new FloatRange(float8, float10);\n+        assertSame(float8, nr.getMinimumNumber());\n+        assertEquals(float10, nr.getMaximumNumber());\n+        \n+        // not null\n+        try {\n+            new FloatRange(float8, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new FloatRange(null, float8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new FloatRange(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            new FloatRange(new Double(Double.NaN), float10);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testContainsNumber() {\n+        assertEquals(false, tenToTwenty.containsNumber(null));\n+        assertEquals(true, tenToTwenty.containsNumber(nonComparableNumber));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(five));\n+        assertEquals(true, tenToTwenty.containsNumber(ten));\n+        assertEquals(true, tenToTwenty.containsNumber(fifteen));\n+        assertEquals(true, tenToTwenty.containsNumber(twenty));\n+        assertEquals(false, tenToTwenty.containsNumber(twentyFive));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(long8));\n+        assertEquals(true, tenToTwenty.containsNumber(long10));\n+        assertEquals(true, tenToTwenty.containsNumber(long12));\n+        assertEquals(true, tenToTwenty.containsNumber(long20));\n+        assertEquals(false, tenToTwenty.containsNumber(long21));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(double8));\n+        assertEquals(true, tenToTwenty.containsNumber(double10));\n+        assertEquals(true, tenToTwenty.containsNumber(double12));\n+        assertEquals(true, tenToTwenty.containsNumber(double20));\n+        assertEquals(false, tenToTwenty.containsNumber(double21));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(float8));\n+        assertEquals(true, tenToTwenty.containsNumber(float10));\n+        assertEquals(true, tenToTwenty.containsNumber(float12));\n+        assertEquals(true, tenToTwenty.containsNumber(float20));\n+        assertEquals(false, tenToTwenty.containsNumber(float21));\n+    }\n+\n+    public void testToString() {\n+        String str = tenToTwenty.toString();\n+        assertEquals(\"Range[10.0,20.0]\", str);\n+        assertSame(str, tenToTwenty.toString());\n+        assertEquals(\"Range[-20.0,-10.0]\", createRange(new Integer(-20), new Integer(-10)).toString());\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/FractionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Fraction} class\n+ *\n+ * @author Stephen Colebourne\n+ * @author C. Scott Ananian\n+ * @version $Id$\n+ */\n+public class FractionTest extends TestCase {\n+    \n+    private static final int SKIP = 500;  //53\n+\n+    public FractionTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FractionTest.class);\n+        suite.setName(\"Fraction Tests\");\n+        return suite;\n+    }\n+    \n+    public void setUp() {\n+    }\n+\n+    //--------------------------------------------------------------------------\n+    \n+    public void testConstants() {\n+        assertEquals(0, Fraction.ZERO.getNumerator());\n+        assertEquals(1, Fraction.ZERO.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE.getNumerator());\n+        assertEquals(1, Fraction.ONE.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE_HALF.getNumerator());\n+        assertEquals(2, Fraction.ONE_HALF.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE_THIRD.getNumerator());\n+        assertEquals(3, Fraction.ONE_THIRD.getDenominator());\n+        \n+        assertEquals(2, Fraction.TWO_THIRDS.getNumerator());\n+        assertEquals(3, Fraction.TWO_THIRDS.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE_QUARTER.getNumerator());\n+        assertEquals(4, Fraction.ONE_QUARTER.getDenominator());\n+        \n+        assertEquals(2, Fraction.TWO_QUARTERS.getNumerator());\n+        assertEquals(4, Fraction.TWO_QUARTERS.getDenominator());\n+        \n+        assertEquals(3, Fraction.THREE_QUARTERS.getNumerator());\n+        assertEquals(4, Fraction.THREE_QUARTERS.getDenominator());\n+        \n+        assertEquals(1, Fraction.ONE_FIFTH.getNumerator());\n+        assertEquals(5, Fraction.ONE_FIFTH.getDenominator());\n+        \n+        assertEquals(2, Fraction.TWO_FIFTHS.getNumerator());\n+        assertEquals(5, Fraction.TWO_FIFTHS.getDenominator());\n+        \n+        assertEquals(3, Fraction.THREE_FIFTHS.getNumerator());\n+        assertEquals(5, Fraction.THREE_FIFTHS.getDenominator());\n+        \n+        assertEquals(4, Fraction.FOUR_FIFTHS.getNumerator());\n+        assertEquals(5, Fraction.FOUR_FIFTHS.getDenominator());\n+    }\n+\n+    public void testFactory_int_int() {\n+        Fraction f = null;\n+        \n+        // zero\n+        f = Fraction.getFraction(0, 1);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(0, 2);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // normal\n+        f = Fraction.getFraction(1, 1);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(2, 1);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(23, 345);\n+        assertEquals(23, f.getNumerator());\n+        assertEquals(345, f.getDenominator());\n+        \n+        // improper\n+        f = Fraction.getFraction(22, 7);\n+        assertEquals(22, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        // negatives\n+        f = Fraction.getFraction(-6, 10);\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, -10);\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-6, -10);\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        // zero denominator\n+        try {\n+            f = Fraction.getFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(2, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-3, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // very large: can't represent as unsimplified fraction, although\n+        try {\n+            f = Fraction.getFraction(4, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(1, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+\n+    public void testFactory_int_int_int() {\n+        Fraction f = null;\n+        \n+        // zero\n+        f = Fraction.getFraction(0, 0, 2);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(2, 0, 2);\n+        assertEquals(4, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(0, 1, 2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // normal\n+        f = Fraction.getFraction(1, 1, 2);\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // negatives\n+        try {\n+            f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        try {\n+            f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        try {\n+            f = Fraction.getFraction(1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        // negative whole\n+        f = Fraction.getFraction(-1, 6, 10);\n+        assertEquals(-16, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        try {\n+            f = Fraction.getFraction(-1, -6, 10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        try {\n+            f = Fraction.getFraction(-1, 6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-1, -6, -10);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        // zero denominator\n+        try {\n+            f = Fraction.getFraction(0, 1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(1, 2, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-1, -3, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(Integer.MAX_VALUE, 1, 2); \n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(-Integer.MAX_VALUE, 1, 2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // very large\n+        f = Fraction.getFraction(-1, 0, Integer.MAX_VALUE);\n+        assertEquals(-Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        try {\n+            // negative denominators not allowed in this constructor.\n+            f = Fraction.getFraction(0, 4, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(1, 1, Integer.MAX_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(-1, 2, Integer.MAX_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    public void testReducedFactory_int_int() {\n+        Fraction f = null;\n+        \n+        // zero\n+        f = Fraction.getReducedFraction(0, 1);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // normal\n+        f = Fraction.getReducedFraction(1, 1);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(2, 1);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // improper\n+        f = Fraction.getReducedFraction(22, 7);\n+        assertEquals(22, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        // negatives\n+        f = Fraction.getReducedFraction(-6, 10);\n+        assertEquals(-3, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(6, -10);\n+        assertEquals(-3, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(-6, -10);\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        // zero denominator\n+        try {\n+            f = Fraction.getReducedFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getReducedFraction(2, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getReducedFraction(-3, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // reduced        \n+        f = Fraction.getReducedFraction(0, 2);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(2, 2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(2, 4);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(15, 10);\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getReducedFraction(121, 22);\n+        assertEquals(11, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // Extreme values \n+        // OK, can reduce before negating\n+        f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());\n+        \n+        // Can't reduce, negation will throw\n+        try { \n+            f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}      \n+    }\n+\n+    public void testFactory_double() {\n+        Fraction f = null;\n+        \n+        try {\n+            f = Fraction.getFraction(Double.NaN);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(Double.POSITIVE_INFINITY);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(Double.NEGATIVE_INFINITY);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction((double) Integer.MAX_VALUE + 1);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        // zero\n+        f = Fraction.getFraction(0.0d);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // one\n+        f = Fraction.getFraction(1.0d);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // one half\n+        f = Fraction.getFraction(0.5d);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        // negative\n+        f = Fraction.getFraction(-0.875d);\n+        assertEquals(-7, f.getNumerator());\n+        assertEquals(8, f.getDenominator());\n+        \n+        // over 1\n+        f = Fraction.getFraction(1.25d);\n+        assertEquals(5, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        // two thirds\n+        f = Fraction.getFraction(0.66666d);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        // small\n+        f = Fraction.getFraction(1.0d/10001d);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        // normal\n+        Fraction f2 = null;\n+        int remainder, number1, number2 = 0;\n+        for (int i = 1; i <= 100; i++) {  // denominator\n+            for (int j = 1; j <= i; j++) {  // numerator\n+                try {\n+                    f = Fraction.getFraction((double) j / (double) i);\n+                } catch (ArithmeticException ex) {\n+                    System.err.println(j + \" \" + i);\n+                    throw ex;\n+                }\n+                f2 = Fraction.getReducedFraction(j, i);\n+                assertEquals(f2.getNumerator(), f.getNumerator());\n+                assertEquals(f2.getDenominator(), f.getDenominator());\n+            }\n+        }\n+        // save time by skipping some tests!  (\n+        for (int i = 1001; i <= 10000; i+=SKIP) {  // denominator\n+            for (int j = 1; j <= i; j++) {  // numerator\n+                try {\n+                    f = Fraction.getFraction((double) j / (double) i);\n+                } catch (ArithmeticException ex) {\n+                    System.err.println(j + \" \" + i);\n+                    throw ex;\n+                }\n+                f2 = Fraction.getReducedFraction(j, i);\n+                assertEquals(f2.getNumerator(), f.getNumerator());\n+                assertEquals(f2.getDenominator(), f.getDenominator());\n+            }\n+        }\n+    }\n+\n+    public void testFactory_String() {\n+        try {\n+            Fraction.getFraction(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    \n+    public void testFactory_String_double() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(\"0.0\");\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"0.2\");\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"0.5\");\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"0.66666\");\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        try {\n+            f = Fraction.getFraction(\"2.3R\");\n+            fail(\"Expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2147483648\"); // too big\n+            fail(\"Expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\".\");\n+            fail(\"Expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+    }\n+\n+    public void testFactory_String_proper() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(\"0 0/1\");\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"1 1/5\");\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"7 1/2\");\n+        assertEquals(15, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"1 2/4\");\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"-7 1/2\");\n+        assertEquals(-15, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"-1 2/4\");\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        try {\n+            f = Fraction.getFraction(\"2 3\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"a 3\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2 b/4\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2 \");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+\n+        try {\n+            f = Fraction.getFraction(\" 3\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\" \");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+    }\n+\n+    public void testFactory_String_improper() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(\"0/1\");\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"1/5\");\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"1/2\");\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"2/3\");\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"7/3\");\n+        assertEquals(7, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"2/4\");\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        try {\n+            f = Fraction.getFraction(\"2/d\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2e/3\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"2/\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+        \n+        try {\n+            f = Fraction.getFraction(\"/\");\n+            fail(\"expecting NumberFormatException\");\n+        } catch (NumberFormatException ex) {}\n+    }\n+\n+    public void testGets() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(3, 5, 6);\n+        assertEquals(23, f.getNumerator());\n+        assertEquals(3, f.getProperWhole());\n+        assertEquals(5, f.getProperNumerator());\n+        assertEquals(6, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-3, 5, 6);\n+        assertEquals(-23, f.getNumerator());\n+        assertEquals(-3, f.getProperWhole());\n+        assertEquals(5, f.getProperNumerator());\n+        assertEquals(6, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(Integer.MIN_VALUE, f.getProperWhole());\n+        assertEquals(0, f.getProperNumerator());\n+        assertEquals(1, f.getDenominator());\n+    }\n+            \n+    public void testConversions() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(3, 7, 8);\n+        assertEquals(3, f.intValue());\n+        assertEquals(3L, f.longValue());\n+        assertEquals(3.875f, f.floatValue(), 0.00001f);\n+        assertEquals(3.875d, f.doubleValue(), 0.00001d);\n+    }\n+    \n+    public void testReduce() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(50, 75);\n+        Fraction result = f.reduce();\n+        assertEquals(2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+\n+        f = Fraction.getFraction(-2, -3);\n+        result = f.reduce();\n+        assertEquals(2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+\n+        f = Fraction.getFraction(2, -3);\n+        result = f.reduce();\n+        assertEquals(-2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+\n+        f = Fraction.getFraction(-2, 3);\n+        result = f.reduce();\n+        assertEquals(-2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+        assertSame(f, result);\n+\n+        f = Fraction.getFraction(2, 3);\n+        result = f.reduce();\n+        assertEquals(2, result.getNumerator());\n+        assertEquals(3, result.getDenominator());\n+        assertSame(f, result);\n+    }\n+    \n+    public void testInvert() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(50, 75);\n+        f = f.invert();\n+        assertEquals(75, f.getNumerator());\n+        assertEquals(50, f.getDenominator());\n+        \n+        f = Fraction.getFraction(4, 3);\n+        f = f.invert();\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-15, 47);\n+        f = f.invert();\n+        assertEquals(-47, f.getNumerator());\n+        assertEquals(15, f.getDenominator());\n+        \n+        f = Fraction.getFraction(0, 3);\n+        try {\n+            f = f.invert();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // large values\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.invert();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f = f.invert();\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+    }\n+    \n+    public void testNegate() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(50, 75);\n+        f = f.negate();\n+        assertEquals(-50, f.getNumerator());\n+        assertEquals(75, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-50, 75);\n+        f = f.negate();\n+        assertEquals(50, f.getNumerator());\n+        assertEquals(75, f.getDenominator());\n+\n+        // large values\n+        f = Fraction.getFraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);\n+        f = f.negate();\n+        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.negate();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testAbs() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(50, 75);\n+        f = f.abs();\n+        assertEquals(50, f.getNumerator());\n+        assertEquals(75, f.getDenominator());\n+        \n+        f = Fraction.getFraction(-50, 75);\n+        f = f.abs();\n+        assertEquals(50, f.getNumerator());\n+        assertEquals(75, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f = f.abs();\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, -1);\n+        f = f.abs();\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.abs();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testPow() {\n+        Fraction f = null;\n+        \n+        f = Fraction.getFraction(3, 5);\n+        assertEquals(Fraction.ONE, f.pow(0));\n+        \n+        f = Fraction.getFraction(3, 5);\n+        assertSame(f, f.pow(1));\n+        assertEquals(f, f.pow(1));\n+\n+        f = Fraction.getFraction(3, 5);\n+        f = f.pow(2);\n+        assertEquals(9, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f = Fraction.getFraction(3, 5);\n+        f = f.pow(3);\n+        assertEquals(27, f.getNumerator());\n+        assertEquals(125, f.getDenominator());\n+        \n+        f = Fraction.getFraction(3, 5);\n+        f = f.pow(-1);\n+        assertEquals(5, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = Fraction.getFraction(3, 5);\n+        f = f.pow(-2);\n+        assertEquals(25, f.getNumerator());\n+        assertEquals(9, f.getDenominator());\n+        \n+        // check unreduced fractions stay that way.\n+        f = Fraction.getFraction(6, 10);\n+        assertEquals(Fraction.ONE, f.pow(0));\n+        \n+        f = Fraction.getFraction(6, 10);\n+        assertEquals(f, f.pow(1));\n+        assertFalse(f.pow(1).equals(Fraction.getFraction(3,5)));\n+\n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(2);\n+        assertEquals(9, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(3);\n+        assertEquals(27, f.getNumerator());\n+        assertEquals(125, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(-1);\n+        assertEquals(10, f.getNumerator());\n+        assertEquals(6, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(-2);\n+        assertEquals(25, f.getNumerator());\n+        assertEquals(9, f.getDenominator());\n+        \n+        // zero to any positive power is still zero.\n+        f = Fraction.getFraction(0, 1231);\n+        f = f.pow(1);\n+        assertTrue(0==f.compareTo(Fraction.ZERO));\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1231, f.getDenominator());\n+        f = f.pow(2);\n+        assertTrue(0==f.compareTo(Fraction.ZERO));\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        // zero to negative powers should throw an exception\n+        try {\n+            f = f.pow(-1);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = f.pow(Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // one to any power is still one.\n+        f = Fraction.getFraction(1, 1);\n+        f = f.pow(0);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(1);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(-1);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(Integer.MAX_VALUE);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(Integer.MIN_VALUE);\n+        assertEquals(f, Fraction.ONE);\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        try {\n+            f = f.pow(2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // Numerator growing too negative during the pow operation.\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.pow(3);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        f = Fraction.getFraction(65536, 1);\n+        try {\n+            f = f.pow(2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testAdd() {\n+        Fraction f = null;\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(1, 5);\n+        f = f1.add(f2);\n+        assertEquals(4, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        f = f1.add(f2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(3, 5);\n+        f = f1.add(f2);\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(-4, 5);\n+        f = f1.add(f2);\n+        assertEquals(-1, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(1, 2);\n+        f = f1.add(f2);\n+        assertEquals(11, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 8);\n+        f2 = Fraction.getFraction(1, 6);\n+        f = f1.add(f2);\n+        assertEquals(13, f.getNumerator());\n+        assertEquals(24, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(1, 5);\n+        f = f1.add(f2);\n+        assertSame(f2, f);\n+        f = f2.add(f1);\n+        assertSame(f2, f);\n+        \n+        f1 = Fraction.getFraction(-1, 13*13*2*2);\n+        f2 = Fraction.getFraction(-2, 13*17*2);\n+        f = f1.add(f2);\n+        assertEquals(13*13*17*2*2, f.getDenominator());\n+        assertEquals(-17 - 2*13*2, f.getNumerator());\n+        \n+        try {\n+            f.add(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is added naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = Fraction.getFraction(1,32768*3);\n+        f2 = Fraction.getFraction(1,59049);\n+        f = f1.add(f2);\n+        assertEquals(52451, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 3);\n+        f2 = Fraction.ONE_THIRD;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        try {\n+            f = f.add(Fraction.ONE); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 5);\n+        f2 = Fraction.getFraction(-1,5);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        try {\n+            f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        f1 = Fraction.getFraction(3,327680);\n+        f2 = Fraction.getFraction(2,59049);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+    }\n+            \n+    public void testSubtract() {\n+        Fraction f = null;\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(1, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(7, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(3, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(-4, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(7, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(4, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(-4, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(-4, 5);\n+        f = f1.subtract(f2);\n+        assertEquals(4, f.getNumerator());\n+        assertEquals(5, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(1, 2);\n+        f = f1.subtract(f2);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(10, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(1, 5);\n+        f = f2.subtract(f1);\n+        assertSame(f2, f);\n+        \n+        try {\n+            f.subtract(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is subtracted naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = Fraction.getFraction(1,32768*3);\n+        f2 = Fraction.getFraction(1,59049);\n+        f = f1.subtract(f2);\n+        assertEquals(-13085, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 3);\n+        f2 = Fraction.ONE_THIRD.negate();\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1);\n+            f = f1.subtract(f2);\n+            fail(\"expecting ArithmeticException\");  //should overflow\n+        } catch (ArithmeticException ex) {}\n+            \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 5);\n+        f2 = Fraction.getFraction(1,5);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= Fraction.getFraction(Integer.MIN_VALUE, 1);\n+            f = f.subtract(Fraction.ONE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        try {\n+            f= Fraction.getFraction(Integer.MAX_VALUE, 1);\n+            f = f.subtract(Fraction.ONE.negate());\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        f1 = Fraction.getFraction(3,327680);\n+        f2 = Fraction.getFraction(2,59049);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+    }\n+            \n+    public void testMultiply() {\n+        Fraction f = null;\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(6, 10);\n+        f2 = Fraction.getFraction(6, 10);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(9, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        f = f.multiplyBy(f2);\n+        assertEquals(27, f.getNumerator());\n+        assertEquals(125, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(-2, 5);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(-3, 5);\n+        f2 = Fraction.getFraction(-2, 5);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(6, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(2, 7);\n+        f = f1.multiplyBy(f2);\n+        assertSame(Fraction.ZERO, f);\n+        \n+        f1 = Fraction.getFraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.multiplyBy(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.multiplyBy(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f = f1.multiplyBy(f1);  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        try {\n+            f1 = Fraction.getFraction(1, -Integer.MAX_VALUE);\n+            f = f1.multiplyBy(f1);  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+            \n+    public void testDivide() {\n+        Fraction f = null;\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        f = f1.divideBy(f2);\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.ZERO;\n+        try {\n+            f = f1.divideBy(f2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = Fraction.getFraction(0, 5);\n+        f2 = Fraction.getFraction(2, 7);\n+        f = f1.divideBy(f2);\n+        assertSame(Fraction.ZERO, f);\n+        \n+        f1 = Fraction.getFraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.divideBy(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+        f = f1.divideBy(f1);  \n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f2 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+        f = f1.divideBy(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.divideBy(null);\n+            fail(\"IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+            f = f1.divideBy(f1.invert());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f1 = Fraction.getFraction(1, -Integer.MAX_VALUE);\n+            f = f1.divideBy(f1.invert());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+            \n+    public void testEquals() {\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        assertEquals(false, f1.equals(null));\n+        assertEquals(false, f1.equals(new Object()));\n+        assertEquals(false, f1.equals(new Integer(6)));\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        f2 = Fraction.getFraction(2, 5);\n+        assertEquals(false, f1.equals(f2));\n+        assertEquals(true, f1.equals(f1));\n+        assertEquals(true, f2.equals(f2));\n+        \n+        f2 = Fraction.getFraction(3, 5);\n+        assertEquals(true, f1.equals(f2));\n+        \n+        f2 = Fraction.getFraction(6, 10);\n+        assertEquals(false, f1.equals(f2));\n+    }\n+    \n+    public void testHashCode() {\n+        Fraction f1 = Fraction.getFraction(3, 5);\n+        Fraction f2 = Fraction.getFraction(3, 5);\n+        \n+        assertTrue(f1.hashCode() == f2.hashCode());\n+        \n+        f2 = Fraction.getFraction(2, 5);\n+        assertTrue(f1.hashCode() != f2.hashCode());\n+        \n+        f2 = Fraction.getFraction(6, 10);\n+        assertTrue(f1.hashCode() != f2.hashCode());\n+    }\n+    \n+    public void testCompareTo() {\n+        Fraction f1 = null;\n+        Fraction f2 = null;\n+        \n+        f1 = Fraction.getFraction(3, 5);\n+        assertTrue(f1.compareTo(f1) == 0);\n+        \n+        try {\n+            f1.compareTo(null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException ex) {}\n+        \n+        try {\n+            f1.compareTo(new Object());\n+            fail(\"expecting ClassCastException\");\n+        } catch (ClassCastException ex) {}\n+        \n+        f2 = Fraction.getFraction(2, 5);\n+        assertTrue(f1.compareTo(f2) > 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+        \n+        f2 = Fraction.getFraction(4, 5);\n+        assertTrue(f1.compareTo(f2) < 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+        \n+        f2 = Fraction.getFraction(3, 5);\n+        assertTrue(f1.compareTo(f2) == 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+        \n+        f2 = Fraction.getFraction(6, 10);\n+        assertTrue(f1.compareTo(f2) == 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+\n+        f2 = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertTrue(f1.compareTo(f2) > 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+\n+    }\n+    \n+    public void testToString() {\n+        Fraction f = null;\n+\n+        f = Fraction.getFraction(3, 5);\n+        String str = f.toString();\n+        assertEquals(\"3/5\", str);\n+        assertSame(str, f.toString());\n+        \n+        f = Fraction.getFraction(7, 5);\n+        assertEquals(\"7/5\", f.toString());        \n+        \n+        f = Fraction.getFraction(4, 2);\n+        assertEquals(\"4/2\", f.toString());        \n+        \n+        f = Fraction.getFraction(0, 2);\n+        assertEquals(\"0/2\", f.toString());        \n+        \n+        f = Fraction.getFraction(2, 2);\n+        assertEquals(\"2/2\", f.toString());        \n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(\"-2147483648/1\", f.toString());        \n+\n+        f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertEquals(\"-2147483648/2147483647\", f.toString());\n+    }\n+    \n+    public void testToProperString() {\n+        Fraction f = null;\n+\n+        f = Fraction.getFraction(3, 5);\n+        String str = f.toProperString();\n+        assertEquals(\"3/5\", str);\n+        assertSame(str, f.toProperString());\n+        \n+        f = Fraction.getFraction(7, 5);\n+        assertEquals(\"1 2/5\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(14, 10);\n+        assertEquals(\"1 4/10\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(4, 2);\n+        assertEquals(\"2\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(0, 2);\n+        assertEquals(\"0\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(2, 2);\n+        assertEquals(\"1\", f.toProperString());        \n+        \n+        f = Fraction.getFraction(-7, 5);\n+        assertEquals(\"-1 2/5\", f.toProperString());        \n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(\"-2147483648\", f.toProperString());        \n+\n+        f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertEquals(\"-1 1/2147483647\", f.toProperString());\n+\n+        assertEquals(\"-1\", Fraction.getFraction(-1).toProperString());\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/IntRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link IntRange} class.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Janek Bogucki\n+ * @author Phil Steitz\n+ * @version $Id$\n+ */\n+public final class IntRangeTest extends AbstractRangeTest {\n+\n+    public IntRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(IntRangeTest.class);\n+        suite.setName(\"IntRange Tests\");\n+        return suite;\n+    }\n+    \n+    public void setUp() {\n+        super.setUp();\n+        tenToTwenty = new IntRange(ten, twenty);\n+        otherRange = new NumberRange(ten, twenty);\n+    }\n+\n+    protected Range createRange(Integer integer1, Integer integer2) {\n+        return new IntRange(integer1, integer2);\n+    }\n+    protected Range createRange(Integer integer) {\n+        return new NumberRange(integer);\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+\n+    public void testConstructor1a() {\n+        IntRange nr = new IntRange(5);\n+        assertEquals(five, nr.getMinimumNumber());\n+        assertEquals(five, nr.getMaximumNumber());\n+    }\n+    \n+    public void testConstructor1b() {\n+        IntRange nr = new IntRange(five);\n+        assertSame(five, nr.getMinimumNumber());\n+        assertSame(five, nr.getMaximumNumber());\n+        \n+        Range r = new IntRange(nonComparableNumber);\n+        \n+        try {\n+            new IntRange(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testConstructor2a() {\n+        IntRange nr = new IntRange(5, 10);\n+        assertEquals(five, nr.getMinimumNumber());\n+        assertEquals(ten, nr.getMaximumNumber());\n+        \n+        nr = new IntRange(5, 10);\n+        assertEquals(five, nr.getMinimumNumber());\n+        assertEquals(ten, nr.getMaximumNumber());\n+    }\n+\n+    public void testConstructor2b() {\n+        IntRange nr = new IntRange(five, ten);\n+        assertSame(five, nr.getMinimumNumber());\n+        assertSame(ten, nr.getMaximumNumber());\n+        \n+        nr = new IntRange(ten, five);\n+        assertSame(five, nr.getMinimumNumber());\n+        assertSame(ten, nr.getMaximumNumber());\n+        \n+        nr = new IntRange(five, long10);\n+        assertSame(five, nr.getMinimumNumber());\n+        assertEquals(ten, nr.getMaximumNumber());\n+        \n+        // test non Integer, for full coverage\n+        Long fiveL = new Long(5L);\n+        Long tenL = new Long(10L);\n+        nr = new IntRange(fiveL, tenL);\n+        assertEquals(five, nr.getMinimumNumber());\n+        assertEquals(ten, nr.getMaximumNumber());\n+        nr = new IntRange(tenL, fiveL);\n+        assertEquals(five, nr.getMinimumNumber());\n+        assertEquals(ten, nr.getMaximumNumber());\n+        \n+        // not null\n+        try {\n+            new IntRange(five, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new IntRange(null, five);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new IntRange(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testContainsNumber() {\n+        assertEquals(false, tenToTwenty.containsNumber(null));\n+        assertEquals(true, tenToTwenty.containsNumber(nonComparableNumber));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(five));\n+        assertEquals(true, tenToTwenty.containsNumber(ten));\n+        assertEquals(true, tenToTwenty.containsNumber(fifteen));\n+        assertEquals(true, tenToTwenty.containsNumber(twenty));\n+        assertEquals(false, tenToTwenty.containsNumber(twentyFive));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(long8));\n+        assertEquals(true, tenToTwenty.containsNumber(long10));\n+        assertEquals(true, tenToTwenty.containsNumber(long12));\n+        assertEquals(true, tenToTwenty.containsNumber(long20));\n+        assertEquals(false, tenToTwenty.containsNumber(long21));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(double8));\n+        assertEquals(true, tenToTwenty.containsNumber(double10));\n+        assertEquals(true, tenToTwenty.containsNumber(double12));\n+        assertEquals(true, tenToTwenty.containsNumber(double20));\n+        assertEquals(false, tenToTwenty.containsNumber(double21));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(float8));\n+        assertEquals(true, tenToTwenty.containsNumber(float10));\n+        assertEquals(true, tenToTwenty.containsNumber(float12));\n+        assertEquals(true, tenToTwenty.containsNumber(float20));\n+        assertEquals(false, tenToTwenty.containsNumber(float21));\n+    }\n+\n+    public void testContainsIntegerBig() {\n+        IntRange big = new IntRange(Integer.MAX_VALUE, Integer.MAX_VALUE- 2);\n+        assertEquals(true, big.containsInteger(Integer.MAX_VALUE - 1));\n+        assertEquals(false, big.containsInteger(Integer.MAX_VALUE - 3));\n+    }\n+\n+    //--------------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/LongRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link LongRange} class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public final class LongRangeTest extends AbstractRangeTest {\n+\n+    public LongRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LongRangeTest.class);\n+        suite.setName(\"LongRange Tests\");\n+        return suite;\n+    }\n+    \n+    public void setUp() {\n+        super.setUp();\n+        tenToTwenty = new LongRange(long10, long20);\n+        otherRange = new NumberRange(ten, twenty);\n+    }\n+\n+    protected Range createRange(Integer integer1, Integer integer2) {\n+        return new LongRange(integer1, integer2);\n+    }\n+    protected Range createRange(Integer integer) {\n+        return new NumberRange(integer);\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+\n+    public void testConstructor1a() {\n+        LongRange nr = new LongRange(8L);\n+        assertEquals(long8, nr.getMinimumNumber());\n+        assertEquals(long8, nr.getMaximumNumber());\n+    }\n+    \n+    public void testConstructor1b() {\n+        LongRange nr = new LongRange(long8);\n+        assertSame(long8, nr.getMinimumNumber());\n+        assertSame(long8, nr.getMaximumNumber());\n+        \n+        Range r = new LongRange(nonComparableNumber);\n+        \n+        try {\n+            new LongRange(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testConstructor2a() {\n+        LongRange nr = new LongRange(8L, 10L);\n+        assertEquals(long8, nr.getMinimumNumber());\n+        assertEquals(long10, nr.getMaximumNumber());\n+        \n+        nr = new LongRange(10L, 8L);\n+        assertEquals(long8, nr.getMinimumNumber());\n+        assertEquals(long10, nr.getMaximumNumber());\n+    }\n+\n+    public void testConstructor2b() {\n+        LongRange nr = new LongRange(long8, long10);\n+        assertSame(long8, nr.getMinimumNumber());\n+        assertSame(long10, nr.getMaximumNumber());\n+        \n+        nr = new LongRange(long10, long8);\n+        assertSame(long8, nr.getMinimumNumber());\n+        assertSame(long10, nr.getMaximumNumber());\n+        \n+        nr = new LongRange(long8, long10);\n+        assertSame(long8, nr.getMinimumNumber());\n+        assertEquals(long10, nr.getMaximumNumber());\n+        \n+        // not null\n+        try {\n+            new LongRange(long8, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new LongRange(null, long8);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new LongRange(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testContainsNumber() {\n+        assertEquals(false, tenToTwenty.containsNumber(null));\n+        assertEquals(true, tenToTwenty.containsNumber(nonComparableNumber));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(five));\n+        assertEquals(true, tenToTwenty.containsNumber(ten));\n+        assertEquals(true, tenToTwenty.containsNumber(fifteen));\n+        assertEquals(true, tenToTwenty.containsNumber(twenty));\n+        assertEquals(false, tenToTwenty.containsNumber(twentyFive));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(long8));\n+        assertEquals(true, tenToTwenty.containsNumber(long10));\n+        assertEquals(true, tenToTwenty.containsNumber(long12));\n+        assertEquals(true, tenToTwenty.containsNumber(long20));\n+        assertEquals(false, tenToTwenty.containsNumber(long21));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(double8));\n+        assertEquals(true, tenToTwenty.containsNumber(double10));\n+        assertEquals(true, tenToTwenty.containsNumber(double12));\n+        assertEquals(true, tenToTwenty.containsNumber(double20));\n+        assertEquals(false, tenToTwenty.containsNumber(double21));\n+        \n+        assertEquals(false, tenToTwenty.containsNumber(float8));\n+        assertEquals(true, tenToTwenty.containsNumber(float10));\n+        assertEquals(true, tenToTwenty.containsNumber(float12));\n+        assertEquals(true, tenToTwenty.containsNumber(float20));\n+        assertEquals(false, tenToTwenty.containsNumber(float21));\n+    }\n+\n+    public void testContainsLongBig() {\n+        LongRange big = new LongRange(Long.MAX_VALUE, Long.MAX_VALUE- 2);\n+        assertEquals(true, big.containsLong(Long.MAX_VALUE - 1));\n+        assertEquals(false, big.containsLong(Long.MAX_VALUE - 3));\n+    }\n+\n+    //--------------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/MathTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Test suite for the Math package.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class MathTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public MathTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Math Tests\");\n+        suite.addTest(DoubleRangeTest.suite());\n+        suite.addTest(FloatRangeTest.suite());\n+        suite.addTest(FractionTest.suite());\n+        suite.addTest(IntRangeTest.suite());\n+        suite.addTest(LongRangeTest.suite());\n+        suite.addTest(NumberRangeTest.suite());\n+        suite.addTest(NumberUtilsTest.suite());\n+        suite.addTest(RandomUtilsTest.suite());\n+        suite.addTest(RangeTest.suite());\n+        return suite;\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/NumberRangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link NumberRange} class.\n+ * \n+ * @author <a href=\"mailto:chrise@esha.com\">Christopher Elkins</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public final class NumberRangeTest extends AbstractRangeTest {\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NumberRangeTest.class);\n+        suite.setName(\"NumberRange Tests\");\n+        return suite;\n+    }\n+\n+    public NumberRangeTest(String name) {\n+        super(name);\n+    }\n+\n+    void checkConstructorException(Number num) {\n+        try {\n+            new NumberRange(num);\n+            fail(\"Expected an IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected.\n+        }\n+    }\n+\n+    void checkConstructorException(Number num1, Number num2) {\n+        try {\n+            new NumberRange(num1, num2);\n+            fail(\"Expected an IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected.\n+        }\n+    }\n+\n+    protected Range createRange(Integer integer) {\n+        return new NumberRange(integer);\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+    protected Range createRange(Integer integer1, Integer integer2) {\n+        return new NumberRange(integer1, integer2);\n+    }\n+\n+    public void setUp() {\n+        super.setUp();\n+        tenToTwenty = new NumberRange(ten, twenty);\n+        otherRange = new IntRange(ten, twenty);\n+    }\n+\n+    /**\n+     * Tests non-exceptional conditions for the one argument constructor.\n+     */\n+    public void testConstructor1() {\n+        NumberRange nr = new NumberRange(five);\n+        assertSame(five, nr.getMinimumNumber());\n+        assertSame(five, nr.getMaximumNumber());\n+    }\n+\n+    /**\n+     * Tests exceptional conditions for the one argument constructor.\n+     */\n+    public void testConstructor1Exceptions() {\n+        this.checkConstructorException(null);\n+        this.checkConstructorException(nonComparableNumber);\n+        this.checkConstructorException(new Float(Float.NaN));\n+        this.checkConstructorException(new Double(Double.NaN));\n+    }\n+\n+    /**\n+     * Tests non-exceptional conditions for the two argument constructor.\n+     */\n+    public void testConstructor2() {\n+        NumberRange nr = new NumberRange(five, ten);\n+        assertSame(five, nr.getMinimumNumber());\n+        assertSame(ten, nr.getMaximumNumber());\n+\n+        nr = new NumberRange(ten, five);\n+        assertSame(five, nr.getMinimumNumber());\n+        assertSame(ten, nr.getMaximumNumber());\n+    }\n+\n+    /**\n+     * Tests exceptional conditions for the two argument constructor.\n+     */\n+    public void testConstructor2Exceptions() {\n+        this.checkConstructorException(null, null);\n+\n+        this.checkConstructorException(new Float(12.2f), new Double(12.2));\n+        this.checkConstructorException(new Float(Float.NaN), new Double(12.2));\n+        this.checkConstructorException(new Double(Double.NaN), new Double(12.2));\n+        this.checkConstructorException(new Double(12.2), new Double(Double.NaN));\n+        this.checkConstructorException(new Double(Double.NaN), new Double(Double.NaN));\n+        this.checkConstructorException(null, new Double(12.2));\n+        this.checkConstructorException(new Double(12.2), null);\n+\n+        this.checkConstructorException(new Double(12.2f), new Float(12.2));\n+        this.checkConstructorException(new Double(Double.NaN), new Float(12.2));\n+        this.checkConstructorException(new Float(Float.NaN), new Float(12.2));\n+        this.checkConstructorException(new Float(12.2), new Float(Float.NaN));\n+        this.checkConstructorException(new Float(Float.NaN), new Float(Float.NaN));\n+        this.checkConstructorException(null, new Float(12.2));\n+        this.checkConstructorException(new Float(12.2), null);\n+\n+        this.checkConstructorException(nonComparableNumber, nonComparableNumber);\n+        this.checkConstructorException(null, nonComparableNumber);\n+        this.checkConstructorException(nonComparableNumber, null);\n+        this.checkConstructorException(new Float(12.2), nonComparableNumber);\n+        this.checkConstructorException(nonComparableNumber, new Float(12.2));\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+    public void testContainsLongBig() {\n+        // original NumberRange class failed this test\n+        NumberRange big = new NumberRange(new Long(Long.MAX_VALUE), new Long(Long.MAX_VALUE - 2));\n+        assertEquals(true, big.containsLong(Long.MAX_VALUE - 1));\n+        assertEquals(false, big.containsLong(Long.MAX_VALUE - 3));\n+    }\n+\n+    public void testContainsNumber() {\n+        assertEquals(false, tenToTwenty.containsNumber(null));\n+        assertEquals(false, tenToTwenty.containsNumber(five));\n+        assertEquals(true, tenToTwenty.containsNumber(ten));\n+        assertEquals(true, tenToTwenty.containsNumber(fifteen));\n+        assertEquals(true, tenToTwenty.containsNumber(twenty));\n+        assertEquals(false, tenToTwenty.containsNumber(twentyFive));\n+\n+        try {\n+            tenToTwenty.containsNumber(long21);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+    }\n+\n+    // --------------------------------------------------------------------------\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/NumberUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.math.NumberUtils}.\n+ *\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n+ * @author Eric Pugh\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ * @author Matthew Hawthorne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class NumberUtilsTest extends TestCase {\n+\n+    public NumberUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(NumberUtilsTest.class);\n+        suite.setName(\"NumberUtils Tests\");\n+        return suite;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new NumberUtils());\n+        Constructor[] cons = NumberUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(NumberUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(NumberUtils.class.getModifiers()));\n+    }\n+    \n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * Test for {@link NumberUtils#stringToInt(String)}.\n+     */\n+    public void testStringToIntString() {\n+        assertTrue(\"stringToInt(String) 1 failed\", NumberUtils.stringToInt(\"12345\") == 12345);\n+        assertTrue(\"stringToInt(String) 2 failed\", NumberUtils.stringToInt(\"abc\") == 0);\n+        assertTrue(\"stringToInt(empty) failed\", NumberUtils.stringToInt(\"\") == 0);\n+        assertTrue(\"stringToInt(null) failed\", NumberUtils.stringToInt(null) == 0);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toInt(String)}.\n+     */\n+    public void testToIntString() {\n+        assertTrue(\"toInt(String) 1 failed\", NumberUtils.toInt(\"12345\") == 12345);\n+        assertTrue(\"toInt(String) 2 failed\", NumberUtils.toInt(\"abc\") == 0);\n+        assertTrue(\"toInt(empty) failed\", NumberUtils.toInt(\"\") == 0);\n+        assertTrue(\"toInt(null) failed\", NumberUtils.toInt(null) == 0);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#stringToInt(String, int)}.\n+     */\n+    public void testStringToIntStringI() {\n+        assertTrue(\"stringToInt(String,int) 1 failed\", NumberUtils.stringToInt(\"12345\", 5) == 12345);\n+        assertTrue(\"stringToInt(String,int) 2 failed\", NumberUtils.stringToInt(\"1234.5\", 5) == 5);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toInt(String, int)}.\n+     */\n+    public void testToIntStringI() {\n+        assertTrue(\"toInt(String,int) 1 failed\", NumberUtils.toInt(\"12345\", 5) == 12345);\n+        assertTrue(\"toInt(String,int) 2 failed\", NumberUtils.toInt(\"1234.5\", 5) == 5);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toLong(String)}.\n+     */\n+    public void testToLongString() {\n+        assertTrue(\"toLong(String) 1 failed\", NumberUtils.toLong(\"12345\") == 12345l);\n+        assertTrue(\"toLong(String) 2 failed\", NumberUtils.toLong(\"abc\") == 0l);\n+        assertTrue(\"toLong(String) 3 failed\", NumberUtils.toLong(\"1L\") == 0l);\n+        assertTrue(\"toLong(String) 4 failed\", NumberUtils.toLong(\"1l\") == 0l);\n+        assertTrue(\"toLong(Long.MAX_VALUE) failed\", NumberUtils.toLong(Long.MAX_VALUE+\"\") == Long.MAX_VALUE);\n+        assertTrue(\"toLong(Long.MIN_VALUE) failed\", NumberUtils.toLong(Long.MIN_VALUE+\"\") == Long.MIN_VALUE);\n+        assertTrue(\"toLong(empty) failed\", NumberUtils.toLong(\"\") == 0l);\n+        assertTrue(\"toLong(null) failed\", NumberUtils.toLong(null) == 0l);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toLong(String, long)}.\n+     */\n+    public void testToLongStringL() {\n+        assertTrue(\"toLong(String,long) 1 failed\", NumberUtils.toLong(\"12345\", 5l) == 12345l);\n+        assertTrue(\"toLong(String,long) 2 failed\", NumberUtils.toLong(\"1234.5\", 5l) == 5l);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toFloat(String)}.\n+     */\n+    public void testToFloatString() {\n+        assertTrue(\"toFloat(String) 1 failed\", NumberUtils.toFloat(\"-1.2345\") == -1.2345f);\n+        assertTrue(\"toFloat(String) 2 failed\", NumberUtils.toFloat(\"1.2345\") == 1.2345f);\n+        assertTrue(\"toFloat(String) 3 failed\", NumberUtils.toFloat(\"abc\") == 0.0f);\n+        assertTrue(\"toFloat(Float.MAX_VALUE) failed\", NumberUtils.toFloat(Float.MAX_VALUE+\"\") ==  Float.MAX_VALUE);\n+        assertTrue(\"toFloat(Float.MIN_VALUE) failed\", NumberUtils.toFloat(Float.MIN_VALUE+\"\") == Float.MIN_VALUE);\n+        assertTrue(\"toFloat(empty) failed\", NumberUtils.toFloat(\"\") == 0.0f);\n+        assertTrue(\"toFloat(null) failed\", NumberUtils.toFloat(null) == 0.0f);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toFloat(String, float)}.\n+     */\n+    public void testToFloatStringF() {\n+        assertTrue(\"toFloat(String,int) 1 failed\", NumberUtils.toFloat(\"1.2345\", 5.1f) == 1.2345f);\n+        assertTrue(\"toFloat(String,int) 2 failed\", NumberUtils.toFloat(\"a\", 5.0f) == 5.0f);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toDouble(String)}.\n+     */\n+    public void testStringToDoubleString() {\n+        assertTrue(\"toDouble(String) 1 failed\", NumberUtils.toDouble(\"-1.2345\") == -1.2345d);\n+        assertTrue(\"toDouble(String) 2 failed\", NumberUtils.toDouble(\"1.2345\") == 1.2345d);\n+        assertTrue(\"toDouble(String) 3 failed\", NumberUtils.toDouble(\"abc\") == 0.0d);\n+        assertTrue(\"toDouble(Double.MAX_VALUE) failed\", NumberUtils.toDouble(Double.MAX_VALUE+\"\") == Double.MAX_VALUE);\n+        assertTrue(\"toDouble(Double.MIN_VALUE) failed\", NumberUtils.toDouble(Double.MIN_VALUE+\"\") == Double.MIN_VALUE);\n+        assertTrue(\"toDouble(empty) failed\", NumberUtils.toDouble(\"\") == 0.0d);\n+        assertTrue(\"toDouble(null) failed\", NumberUtils.toDouble(null) == 0.0d);\n+    }\n+\n+    /**\n+     * Test for {@link NumberUtils#toDouble(String, double)}.\n+     */\n+    public void testStringToDoubleStringD() {\n+        assertTrue(\"toDouble(String,int) 1 failed\", NumberUtils.toDouble(\"1.2345\", 5.1d) == 1.2345d);\n+        assertTrue(\"toDouble(String,int) 2 failed\", NumberUtils.toDouble(\"a\", 5.0d) == 5.0d);\n+    }\n+\n+    public void testCreateNumber() {\n+        // a lot of things can go wrong\n+        assertEquals(\"createNumber(String) 1 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5\"));\n+        assertEquals(\"createNumber(String) 2 failed\", new Integer(\"12345\"), NumberUtils.createNumber(\"12345\"));\n+        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5D\"));\n+        assertEquals(\"createNumber(String) 3 failed\", new Double(\"1234.5\"), NumberUtils.createNumber(\"1234.5d\"));\n+        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5F\"));\n+        assertEquals(\"createNumber(String) 4 failed\", new Float(\"1234.5\"), NumberUtils.createNumber(\"1234.5f\"));\n+        assertEquals(\"createNumber(String) 5 failed\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\"\"\n+            + (Integer.MAX_VALUE + 1L)));\n+        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345L\"));\n+        assertEquals(\"createNumber(String) 6 failed\", new Long(12345), NumberUtils.createNumber(\"12345l\"));\n+        assertEquals(\"createNumber(String) 7 failed\", new Float(\"-1234.5\"), NumberUtils.createNumber(\"-1234.5\"));\n+        assertEquals(\"createNumber(String) 8 failed\", new Integer(\"-12345\"), NumberUtils.createNumber(\"-12345\"));\n+        assertTrue(\"createNumber(String) 9 failed\", 0xFADE == NumberUtils.createNumber(\"0xFADE\").intValue());\n+        assertTrue(\"createNumber(String) 10 failed\", -0xFADE == NumberUtils.createNumber(\"-0xFADE\").intValue());\n+        assertEquals(\"createNumber(String) 11 failed\", new Double(\"1.1E200\"), NumberUtils.createNumber(\"1.1E200\"));\n+        assertEquals(\"createNumber(String) 12 failed\", new Float(\"1.1E20\"), NumberUtils.createNumber(\"1.1E20\"));\n+        assertEquals(\"createNumber(String) 13 failed\", new Double(\"-1.1E200\"), NumberUtils.createNumber(\"-1.1E200\"));\n+        assertEquals(\"createNumber(String) 14 failed\", new Double(\"1.1E-200\"), NumberUtils.createNumber(\"1.1E-200\"));\n+        assertEquals(\"createNumber(null) failed\", null, NumberUtils.createNumber(null));\n+        assertEquals(\"createNumber(String) failed\", new BigInteger(\"12345678901234567890\"), NumberUtils\n+                .createNumber(\"12345678901234567890L\"));\n+\n+        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n+        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n+            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n+                    .createNumber(\"1.1E-700F\"));\n+        }\n+        assertEquals(\"createNumber(String) 16 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n+                .createNumber(\"10\" + Integer.MAX_VALUE + \"L\"));\n+        assertEquals(\"createNumber(String) 17 failed\", new Long(\"10\" + Integer.MAX_VALUE), NumberUtils\n+                .createNumber(\"10\" + Integer.MAX_VALUE));\n+        assertEquals(\"createNumber(String) 18 failed\", new BigInteger(\"10\" + Long.MAX_VALUE), NumberUtils\n+                .createNumber(\"10\" + Long.MAX_VALUE));\n+    }\n+\n+    public void testCreateFloat() {\n+        assertEquals(\"createFloat(String) failed\", new Float(\"1234.5\"), NumberUtils.createFloat(\"1234.5\"));\n+        assertEquals(\"createFloat(null) failed\", null, NumberUtils.createFloat(null));\n+        this.testCreateFloatFailure(\"\");\n+        this.testCreateFloatFailure(\" \");\n+        this.testCreateFloatFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateFloatFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateFloatFailure(String str) {\n+        try {\n+            Float value = NumberUtils.createFloat(str);\n+            fail(\"createFloat(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateDouble() {\n+        assertEquals(\"createDouble(String) failed\", new Double(\"1234.5\"), NumberUtils.createDouble(\"1234.5\"));\n+        assertEquals(\"createDouble(null) failed\", null, NumberUtils.createDouble(null));\n+        this.testCreateDoubleFailure(\"\");\n+        this.testCreateDoubleFailure(\" \");\n+        this.testCreateDoubleFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateDoubleFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateDoubleFailure(String str) {\n+        try {\n+            Double value = NumberUtils.createDouble(str);\n+            fail(\"createDouble(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateInteger() {\n+        assertEquals(\"createInteger(String) failed\", new Integer(\"12345\"), NumberUtils.createInteger(\"12345\"));\n+        assertEquals(\"createInteger(null) failed\", null, NumberUtils.createInteger(null));\n+        this.testCreateIntegerFailure(\"\");\n+        this.testCreateIntegerFailure(\" \");\n+        this.testCreateIntegerFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateIntegerFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateIntegerFailure(String str) {\n+        try {\n+            Integer value = NumberUtils.createInteger(str);\n+            fail(\"createInteger(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateLong() {\n+        assertEquals(\"createLong(String) failed\", new Long(\"12345\"), NumberUtils.createLong(\"12345\"));\n+        assertEquals(\"createLong(null) failed\", null, NumberUtils.createLong(null));\n+        this.testCreateLongFailure(\"\");\n+        this.testCreateLongFailure(\" \");\n+        this.testCreateLongFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateLongFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateLongFailure(String str) {\n+        try {\n+            Long value = NumberUtils.createLong(str);\n+            fail(\"createLong(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateBigInteger() {\n+        assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"12345\"), NumberUtils.createBigInteger(\"12345\"));\n+        assertEquals(\"createBigInteger(null) failed\", null, NumberUtils.createBigInteger(null));\n+        this.testCreateBigIntegerFailure(\"\");\n+        this.testCreateBigIntegerFailure(\" \");\n+        this.testCreateBigIntegerFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateBigIntegerFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateBigIntegerFailure(String str) {\n+        try {\n+            BigInteger value = NumberUtils.createBigInteger(str);\n+            fail(\"createBigInteger(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    public void testCreateBigDecimal() {\n+        assertEquals(\"createBigDecimal(String) failed\", new BigDecimal(\"1234.5\"), NumberUtils.createBigDecimal(\"1234.5\"));\n+        assertEquals(\"createBigDecimal(null) failed\", null, NumberUtils.createBigDecimal(null));\n+        this.testCreateBigDecimalFailure(\"\");\n+        this.testCreateBigDecimalFailure(\" \");\n+        this.testCreateBigDecimalFailure(\"\\b\\t\\n\\f\\r\");\n+        // Funky whitespaces\n+        this.testCreateBigDecimalFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n+    }\n+\n+    protected void testCreateBigDecimalFailure(String str) {\n+        try {\n+            BigDecimal value = NumberUtils.createBigDecimal(str);\n+            fail(\"createBigDecimal(blank) failed: \" + value);\n+        } catch (NumberFormatException ex) {\n+            // empty\n+        }\n+    }\n+\n+    // min/max tests\n+    // ----------------------------------------------------------------------\n+    public void testMinLong() {\n+        final long[] l = null;\n+        try {\n+            NumberUtils.min(l);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new long[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(long[]) failed for array length 1\",\n+            5,\n+            NumberUtils.min(new long[] { 5 }));\n+\n+        assertEquals(\n+            \"min(long[]) failed for array length 2\",\n+            6,\n+            NumberUtils.min(new long[] { 6, 9 }));\n+\n+        assertEquals(-10, NumberUtils.min(new long[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(-10, NumberUtils.min(new long[] { -5, 0, -10, 5, 10 }));\n+    }\n+\n+    public void testMinInt() {\n+        final int[] i = null;\n+        try {\n+            NumberUtils.min(i);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new int[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(int[]) failed for array length 1\",\n+            5,\n+            NumberUtils.min(new int[] { 5 }));\n+\n+        assertEquals(\n+            \"min(int[]) failed for array length 2\",\n+            6,\n+            NumberUtils.min(new int[] { 6, 9 }));\n+\n+        assertEquals(-10, NumberUtils.min(new int[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(-10, NumberUtils.min(new int[] { -5, 0, -10, 5, 10 }));\n+    }\n+\n+    public void testMinShort() {\n+        final short[] s = null;\n+        try {\n+            NumberUtils.min(s);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new short[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(short[]) failed for array length 1\",\n+            5,\n+            NumberUtils.min(new short[] { 5 }));\n+\n+        assertEquals(\n+            \"min(short[]) failed for array length 2\",\n+            6,\n+            NumberUtils.min(new short[] { 6, 9 }));\n+\n+        assertEquals(-10, NumberUtils.min(new short[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(-10, NumberUtils.min(new short[] { -5, 0, -10, 5, 10 }));\n+    }\n+\n+    public void testMinDouble() {\n+        final double[] d = null;\n+        try {\n+            NumberUtils.min(d);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new double[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(double[]) failed for array length 1\",\n+            5.12,\n+            NumberUtils.min(new double[] { 5.12 }),\n+            0);\n+\n+        assertEquals(\n+            \"min(double[]) failed for array length 2\",\n+            6.23,\n+            NumberUtils.min(new double[] { 6.23, 9.34 }),\n+            0);\n+\n+        assertEquals(\n+            \"min(double[]) failed for array length 5\",\n+            -10.45,\n+            NumberUtils.min(new double[] { -10.45, -5.56, 0, 5.67, 10.78 }),\n+            0);\n+        assertEquals(-10, NumberUtils.min(new double[] { -10, -5, 0, 5, 10 }), 0.0001);\n+        assertEquals(-10, NumberUtils.min(new double[] { -5, 0, -10, 5, 10 }), 0.0001);\n+    }\n+\n+    public void testMinFloat() {\n+        final float[] f = null;\n+        try {\n+            NumberUtils.min(f);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.min(new float[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"min(float[]) failed for array length 1\",\n+            5.9f,\n+            NumberUtils.min(new float[] { 5.9f }),\n+            0);\n+\n+        assertEquals(\n+            \"min(float[]) failed for array length 2\",\n+            6.8f,\n+            NumberUtils.min(new float[] { 6.8f, 9.7f }),\n+            0);\n+\n+        assertEquals(\n+            \"min(float[]) failed for array length 5\",\n+            -10.6f,\n+            NumberUtils.min(new float[] { -10.6f, -5.5f, 0, 5.4f, 10.3f }),\n+            0);\n+        assertEquals(-10, NumberUtils.min(new float[] { -10, -5, 0, 5, 10 }), 0.0001f);\n+        assertEquals(-10, NumberUtils.min(new float[] { -5, 0, -10, 5, 10 }), 0.0001f);\n+    }\n+\n+    public void testMaxLong() {\n+        final long[] l = null;\n+        try {\n+            NumberUtils.max(l);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new long[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(long[]) failed for array length 1\",\n+            5,\n+            NumberUtils.max(new long[] { 5 }));\n+\n+        assertEquals(\n+            \"max(long[]) failed for array length 2\",\n+            9,\n+            NumberUtils.max(new long[] { 6, 9 }));\n+\n+        assertEquals(\n+            \"max(long[]) failed for array length 5\",\n+            10,\n+            NumberUtils.max(new long[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new long[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new long[] { -5, 0, 10, 5, -10 }));\n+    }\n+\n+    public void testMaxInt() {\n+        final int[] i = null;\n+        try {\n+            NumberUtils.max(i);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new int[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(int[]) failed for array length 1\",\n+            5,\n+            NumberUtils.max(new int[] { 5 }));\n+\n+        assertEquals(\n+            \"max(int[]) failed for array length 2\",\n+            9,\n+            NumberUtils.max(new int[] { 6, 9 }));\n+\n+        assertEquals(\n+            \"max(int[]) failed for array length 5\",\n+            10,\n+            NumberUtils.max(new int[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new int[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new int[] { -5, 0, 10, 5, -10 }));\n+    }\n+\n+    public void testMaxShort() {\n+        final short[] s = null;\n+        try {\n+            NumberUtils.max(s);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new short[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(short[]) failed for array length 1\",\n+            5,\n+            NumberUtils.max(new short[] { 5 }));\n+\n+        assertEquals(\n+            \"max(short[]) failed for array length 2\",\n+            9,\n+            NumberUtils.max(new short[] { 6, 9 }));\n+\n+        assertEquals(\n+            \"max(short[]) failed for array length 5\",\n+            10,\n+            NumberUtils.max(new short[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new short[] { -10, -5, 0, 5, 10 }));\n+        assertEquals(10, NumberUtils.max(new short[] { -5, 0, 10, 5, -10 }));\n+    }\n+\n+    public void testMaxDouble() {\n+        final double[] d = null;\n+        try {\n+            NumberUtils.max(d);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new double[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(double[]) failed for array length 1\",\n+            5.1f,\n+            NumberUtils.max(new double[] { 5.1f }),\n+            0);\n+\n+        assertEquals(\n+            \"max(double[]) failed for array length 2\",\n+            9.2f,\n+            NumberUtils.max(new double[] { 6.3f, 9.2f }),\n+            0);\n+\n+        assertEquals(\n+            \"max(double[]) failed for float length 5\",\n+            10.4f,\n+            NumberUtils.max(new double[] { -10.5f, -5.6f, 0, 5.7f, 10.4f }),\n+            0);\n+        assertEquals(10, NumberUtils.max(new double[] { -10, -5, 0, 5, 10 }), 0.0001);\n+        assertEquals(10, NumberUtils.max(new double[] { -5, 0, 10, 5, -10 }), 0.0001);\n+    }\n+ \n+    public void testMaxFloat() {\n+        final float[] f = null;\n+        try {\n+            NumberUtils.max(f);\n+            fail(\"No exception was thrown for null input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            NumberUtils.max(new float[0]);\n+            fail(\"No exception was thrown for empty input.\");\n+        } catch (IllegalArgumentException ex) {}\n+\n+        assertEquals(\n+            \"max(float[]) failed for array length 1\",\n+            5.1f,\n+            NumberUtils.max(new float[] { 5.1f }),\n+            0);\n+\n+        assertEquals(\n+            \"max(float[]) failed for array length 2\",\n+            9.2f,\n+            NumberUtils.max(new float[] { 6.3f, 9.2f }),\n+            0);\n+\n+        assertEquals(\n+            \"max(float[]) failed for float length 5\",\n+            10.4f,\n+            NumberUtils.max(new float[] { -10.5f, -5.6f, 0, 5.7f, 10.4f }),\n+            0);\n+        assertEquals(10, NumberUtils.max(new float[] { -10, -5, 0, 5, 10 }), 0.0001f);\n+        assertEquals(10, NumberUtils.max(new float[] { -5, 0, 10, 5, -10 }), 0.0001f);\n+    }\n+\n+    public void testMinimumLong() {\n+        assertEquals(\"minimum(long,long,long) 1 failed\", 12345L, NumberUtils.min(12345L, 12345L + 1L, 12345L + 2L));\n+        assertEquals(\"minimum(long,long,long) 2 failed\", 12345L, NumberUtils.min(12345L + 1L, 12345L, 12345 + 2L));\n+        assertEquals(\"minimum(long,long,long) 3 failed\", 12345L, NumberUtils.min(12345L + 1L, 12345L + 2L, 12345L));\n+        assertEquals(\"minimum(long,long,long) 4 failed\", 12345L, NumberUtils.min(12345L + 1L, 12345L, 12345L));\n+        assertEquals(\"minimum(long,long,long) 5 failed\", 12345L, NumberUtils.min(12345L, 12345L, 12345L));\n+    }\n+\n+    public void testMinimumInt() {\n+        assertEquals(\"minimum(int,int,int) 1 failed\", 12345, NumberUtils.min(12345, 12345 + 1, 12345 + 2));\n+        assertEquals(\"minimum(int,int,int) 2 failed\", 12345, NumberUtils.min(12345 + 1, 12345, 12345 + 2));\n+        assertEquals(\"minimum(int,int,int) 3 failed\", 12345, NumberUtils.min(12345 + 1, 12345 + 2, 12345));\n+        assertEquals(\"minimum(int,int,int) 4 failed\", 12345, NumberUtils.min(12345 + 1, 12345, 12345));\n+        assertEquals(\"minimum(int,int,int) 5 failed\", 12345, NumberUtils.min(12345, 12345, 12345));\n+    }\n+\n+    public void testMinimumShort() {\n+        short low = 1234;\n+        short mid = 1234 + 1;\n+        short high = 1234 + 2;\n+        assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(low, mid, high));\n+        assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(mid, low, high));\n+        assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(mid, high, low));\n+        assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(low, mid, low));\n+    }\n+\n+    public void testMinimumByte() {\n+        byte low = 123;\n+        byte mid = 123 + 1;\n+        byte high = 123 + 2;\n+        assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(low, mid, high));\n+        assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(mid, low, high));\n+        assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(mid, high, low));\n+        assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(low, mid, low));\n+    }\n+\n+    public void testMinimumDouble() {\n+        double low = 12.3;\n+        double mid = 12.3 + 1;\n+        double high = 12.3 + 2;\n+        assertEquals(low, NumberUtils.min(low, mid, high), 0.0001);\n+        assertEquals(low, NumberUtils.min(mid, low, high), 0.0001);\n+        assertEquals(low, NumberUtils.min(mid, high, low), 0.0001);\n+        assertEquals(low, NumberUtils.min(low, mid, low), 0.0001);\n+        assertEquals(mid, NumberUtils.min(high, mid, high), 0.0001);\n+    }\n+\n+    public void testMinimumFloat() {\n+        float low = 12.3f;\n+        float mid = 12.3f + 1;\n+        float high = 12.3f + 2;\n+        assertEquals(low, NumberUtils.min(low, mid, high), 0.0001f);\n+        assertEquals(low, NumberUtils.min(mid, low, high), 0.0001f);\n+        assertEquals(low, NumberUtils.min(mid, high, low), 0.0001f);\n+        assertEquals(low, NumberUtils.min(low, mid, low), 0.0001f);\n+        assertEquals(mid, NumberUtils.min(high, mid, high), 0.0001f);\n+    }\n+\n+    public void testMaximumLong() {\n+        assertEquals(\"maximum(long,long,long) 1 failed\", 12345L, NumberUtils.max(12345L, 12345L - 1L, 12345L - 2L));\n+        assertEquals(\"maximum(long,long,long) 2 failed\", 12345L, NumberUtils.max(12345L - 1L, 12345L, 12345L - 2L));\n+        assertEquals(\"maximum(long,long,long) 3 failed\", 12345L, NumberUtils.max(12345L - 1L, 12345L - 2L, 12345L));\n+        assertEquals(\"maximum(long,long,long) 4 failed\", 12345L, NumberUtils.max(12345L - 1L, 12345L, 12345L));\n+        assertEquals(\"maximum(long,long,long) 5 failed\", 12345L, NumberUtils.max(12345L, 12345L, 12345L));\n+    }\n+\n+    public void testMaximumInt() {\n+        assertEquals(\"maximum(int,int,int) 1 failed\", 12345, NumberUtils.max(12345, 12345 - 1, 12345 - 2));\n+        assertEquals(\"maximum(int,int,int) 2 failed\", 12345, NumberUtils.max(12345 - 1, 12345, 12345 - 2));\n+        assertEquals(\"maximum(int,int,int) 3 failed\", 12345, NumberUtils.max(12345 - 1, 12345 - 2, 12345));\n+        assertEquals(\"maximum(int,int,int) 4 failed\", 12345, NumberUtils.max(12345 - 1, 12345, 12345));\n+        assertEquals(\"maximum(int,int,int) 5 failed\", 12345, NumberUtils.max(12345, 12345, 12345));\n+    }\n+\n+    public void testMaximumShort() {\n+        short low = 1234;\n+        short mid = 1234 + 1;\n+        short high = 1234 + 2;\n+        assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(low, mid, high));\n+        assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(mid, low, high));\n+        assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(mid, high, low));\n+        assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(high, mid, high));\n+    }\n+\n+    public void testMaximumByte() {\n+        byte low = 123;\n+        byte mid = 123 + 1;\n+        byte high = 123 + 2;\n+        assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(low, mid, high));\n+        assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(mid, low, high));\n+        assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(mid, high, low));\n+        assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(high, mid, high));\n+    }\n+\n+    public void testMaximumDouble() {\n+        double low = 12.3;\n+        double mid = 12.3 + 1;\n+        double high = 12.3 + 2;\n+        assertEquals(high, NumberUtils.max(low, mid, high), 0.0001);\n+        assertEquals(high, NumberUtils.max(mid, low, high), 0.0001);\n+        assertEquals(high, NumberUtils.max(mid, high, low), 0.0001);\n+        assertEquals(mid, NumberUtils.max(low, mid, low), 0.0001);\n+        assertEquals(high, NumberUtils.max(high, mid, high), 0.0001);\n+    }\n+\n+    public void testMaximumFloat() {\n+        float low = 12.3f;\n+        float mid = 12.3f + 1;\n+        float high = 12.3f + 2;\n+        assertEquals(high, NumberUtils.max(low, mid, high), 0.0001f);\n+        assertEquals(high, NumberUtils.max(mid, low, high), 0.0001f);\n+        assertEquals(high, NumberUtils.max(mid, high, low), 0.0001f);\n+        assertEquals(mid, NumberUtils.max(low, mid, low), 0.0001f);\n+        assertEquals(high, NumberUtils.max(high, mid, high), 0.0001f);\n+    }\n+\n+    public void testCompareDouble() {\n+        assertTrue(NumberUtils.compare(Double.NaN, Double.NaN) == 0);\n+        assertTrue(NumberUtils.compare(Double.NaN, Double.POSITIVE_INFINITY) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, 1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, 0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.NaN, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY) == 0);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, 1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, 0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.MAX_VALUE) == 0);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, 1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, 0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(1.2d, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(1.2d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(1.2d, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(1.2d, 1.2d) == 0);\n+        assertTrue(NumberUtils.compare(1.2d, 0.0d) == +1);\n+        assertTrue(NumberUtils.compare(1.2d, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(1.2d, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(1.2d, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(1.2d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(0.0d, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(0.0d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(0.0d, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(0.0d, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(0.0d, 0.0d) == 0);\n+        assertTrue(NumberUtils.compare(0.0d, -0.0d) == +1);\n+        assertTrue(NumberUtils.compare(0.0d, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(0.0d, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(0.0d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-0.0d, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, 0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-0.0d, -0.0d) == 0);\n+        assertTrue(NumberUtils.compare(-0.0d, -1.2d) == +1);\n+        assertTrue(NumberUtils.compare(-0.0d, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(-0.0d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-1.2d, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, 0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, -0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-1.2d, -1.2d) == 0);\n+        assertTrue(NumberUtils.compare(-1.2d, -Double.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(-1.2d, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, 0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -0.0d) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -1.2d) == -1);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -Double.MAX_VALUE) == 0);\n+        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, 1.2d) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, 0.0d) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -0.0d) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -1.2d) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) == 0);\n+    }\n+\n+    public void testCompareFloat() {\n+        assertTrue(NumberUtils.compare(Float.NaN, Float.NaN) == 0);\n+        assertTrue(NumberUtils.compare(Float.NaN, Float.POSITIVE_INFINITY) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, 1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, 0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.NaN, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY) == 0);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, 1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, 0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.MAX_VALUE) == 0);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, 1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, 0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(1.2f, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(1.2f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(1.2f, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(1.2f, 1.2f) == 0);\n+        assertTrue(NumberUtils.compare(1.2f, 0.0f) == +1);\n+        assertTrue(NumberUtils.compare(1.2f, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(1.2f, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(1.2f, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(1.2f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(0.0f, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(0.0f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(0.0f, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(0.0f, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(0.0f, 0.0f) == 0);\n+        assertTrue(NumberUtils.compare(0.0f, -0.0f) == +1);\n+        assertTrue(NumberUtils.compare(0.0f, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(0.0f, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(0.0f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-0.0f, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, 0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-0.0f, -0.0f) == 0);\n+        assertTrue(NumberUtils.compare(-0.0f, -1.2f) == +1);\n+        assertTrue(NumberUtils.compare(-0.0f, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(-0.0f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-1.2f, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, 0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, -0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-1.2f, -1.2f) == 0);\n+        assertTrue(NumberUtils.compare(-1.2f, -Float.MAX_VALUE) == +1);\n+        assertTrue(NumberUtils.compare(-1.2f, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, 0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -0.0f) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -1.2f) == -1);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -Float.MAX_VALUE) == 0);\n+        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);\n+        \n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.NaN) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, 1.2f) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, 0.0f) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -0.0f) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -1.2f) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -Float.MAX_VALUE) == -1);\n+        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY) == 0);\n+    }\n+\n+    public void testIsDigits() {\n+        assertEquals(\"isDigits(null) failed\", false, NumberUtils.isDigits(null));\n+        assertEquals(\"isDigits('') failed\", false, NumberUtils.isDigits(\"\"));\n+        assertEquals(\"isDigits(String) failed\", true, NumberUtils.isDigits(\"12345\"));\n+        assertEquals(\"isDigits(String) neg 1 failed\", false, NumberUtils.isDigits(\"1234.5\"));\n+        assertEquals(\"isDigits(String) neg 3 failed\", false, NumberUtils.isDigits(\"1ab\"));\n+        assertEquals(\"isDigits(String) neg 4 failed\", false, NumberUtils.isDigits(\"abc\"));\n+    }\n+    \n+    /**\n+     * Tests isNumber(String) and tests that createNumber(String) returns\n+     * a valid number iff isNumber(String) returns false.\n+     */\n+    public void testIsNumber() {\n+        String val = \"12345\";\n+        assertTrue(\"isNumber(String) 1 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 1 failed\", checkCreateNumber(val));\n+        val = \"1234.5\";\n+        assertTrue(\"isNumber(String) 2 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 2 failed\", checkCreateNumber(val));\n+        val = \".12345\";\n+        assertTrue(\"isNumber(String) 3 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 3 failed\", checkCreateNumber(val));\n+        val = \"1234E5\";\n+        assertTrue(\"isNumber(String) 4 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 4 failed\", checkCreateNumber(val));\n+        val = \"1234E+5\";\n+        assertTrue(\"isNumber(String) 5 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 5 failed\", checkCreateNumber(val));\n+        val = \"1234E-5\";\n+        assertTrue(\"isNumber(String) 6 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 6 failed\", checkCreateNumber(val));\n+        val = \"123.4E5\";\n+        assertTrue(\"isNumber(String) 7 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 7 failed\", checkCreateNumber(val));\n+        val = \"-1234\";\n+        assertTrue(\"isNumber(String) 8 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 8 failed\", checkCreateNumber(val));\n+        val = \"-1234.5\";\n+        assertTrue(\"isNumber(String) 9 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 9 failed\", checkCreateNumber(val));\n+        val = \"-.12345\";\n+        assertTrue(\"isNumber(String) 10 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 10 failed\", checkCreateNumber(val));\n+        val = \"-1234E5\";\n+        assertTrue(\"isNumber(String) 11 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 11 failed\", checkCreateNumber(val));\n+        val = \"0\";\n+        assertTrue(\"isNumber(String) 12 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 12 failed\", checkCreateNumber(val));\n+        val = \"-0\";\n+        assertTrue(\"isNumber(String) 13 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 13 failed\", checkCreateNumber(val));\n+        val = \"01234\";\n+        assertTrue(\"isNumber(String) 14 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 14 failed\", checkCreateNumber(val));\n+        val = \"-01234\";\n+        assertTrue(\"isNumber(String) 15 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 15 failed\", checkCreateNumber(val));\n+        val = \"0xABC123\";\n+        assertTrue(\"isNumber(String) 16 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 16 failed\", checkCreateNumber(val));\n+        val = \"0x0\";\n+        assertTrue(\"isNumber(String) 17 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 17 failed\", checkCreateNumber(val));\n+        val = \"123.4E21D\";\n+        assertTrue(\"isNumber(String) 19 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 19 failed\", checkCreateNumber(val));\n+        val = \"-221.23F\";\n+        assertTrue(\"isNumber(String) 20 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 20 failed\", checkCreateNumber(val));\n+        val = \"22338L\";\n+        assertTrue(\"isNumber(String) 21 failed\", NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 21 failed\", checkCreateNumber(val));\n+        val = null;\n+        assertTrue(\"isNumber(String) 1 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 1 Neg failed\", !checkCreateNumber(val));\n+        val = \"\";\n+        assertTrue(\"isNumber(String) 2 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 2 Neg failed\", !checkCreateNumber(val));\n+        val = \"--2.3\";\n+        assertTrue(\"isNumber(String) 3 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 3 Neg failed\", !checkCreateNumber(val));\n+        val = \".12.3\";\n+        assertTrue(\"isNumber(String) 4 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 4 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E\";\n+        assertTrue(\"isNumber(String) 5 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 5 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E+-212\";\n+        assertTrue(\"isNumber(String) 6 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 6 Neg failed\", !checkCreateNumber(val));\n+        val = \"-123E2.12\";\n+        assertTrue(\"isNumber(String) 7 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 7 Neg failed\", !checkCreateNumber(val));\n+        val = \"0xGF\";\n+        assertTrue(\"isNumber(String) 8 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 8 Neg failed\", !checkCreateNumber(val));\n+        val = \"0xFAE-1\";\n+        assertTrue(\"isNumber(String) 9 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 9 Neg failed\", !checkCreateNumber(val));\n+        val = \".\";\n+        assertTrue(\"isNumber(String) 10 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 10 Neg failed\", !checkCreateNumber(val));\n+        val = \"-0ABC123\";\n+        assertTrue(\"isNumber(String) 11 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 11 Neg failed\", !checkCreateNumber(val));\n+        val = \"123.4E-D\";\n+        assertTrue(\"isNumber(String) 12 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 12 Neg failed\", !checkCreateNumber(val));\n+        val = \"123.4ED\";\n+        assertTrue(\"isNumber(String) 13 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 13 Neg failed\", !checkCreateNumber(val));\n+        val = \"1234E5l\";\n+        assertTrue(\"isNumber(String) 14 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 14 Neg failed\", !checkCreateNumber(val));\n+        val = \"11a\";\n+        assertTrue(\"isNumber(String) 15 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 15 Neg failed\", !checkCreateNumber(val)); \n+        val = \"1a\";\n+        assertTrue(\"isNumber(String) 16 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 16 Neg failed\", !checkCreateNumber(val)); \n+        val = \"a\";\n+        assertTrue(\"isNumber(String) 17 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 17 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11g\";\n+        assertTrue(\"isNumber(String) 18 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 18 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11z\";\n+        assertTrue(\"isNumber(String) 19 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 19 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11def\";\n+        assertTrue(\"isNumber(String) 20 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 20 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11d11\";\n+        assertTrue(\"isNumber(String) 21 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 21 Neg failed\", !checkCreateNumber(val)); \n+        val = \"11 11\";\n+        assertTrue(\"isNumber(String) 22 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 22 Neg failed\", !checkCreateNumber(val));\n+        val = \" 1111\";\n+        assertTrue(\"isNumber(String) 23 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 23 Neg failed\", !checkCreateNumber(val));\n+        val = \"1111 \";\n+        assertTrue(\"isNumber(String) 24 Neg failed\", !NumberUtils.isNumber(val));\n+        assertTrue(\"isNumber(String)/createNumber(String) 24 Neg failed\", !checkCreateNumber(val));\n+\n+    }\n+\n+    private boolean checkCreateNumber(String val) {\n+        try {\n+            Object obj = NumberUtils.createNumber(val);\n+            if (obj == null) {\n+                return false;\n+            }\n+            return true;\n+        } catch (NumberFormatException e) {\n+            return false;\n+       }\n+    }\n+\n+    public void testConstants() {\n+        assertTrue(NumberUtils.LONG_ZERO instanceof Long);\n+        assertTrue(NumberUtils.LONG_ONE instanceof Long);\n+        assertTrue(NumberUtils.LONG_MINUS_ONE instanceof Long);\n+        assertTrue(NumberUtils.INTEGER_ZERO instanceof Integer);\n+        assertTrue(NumberUtils.INTEGER_ONE instanceof Integer);\n+        assertTrue(NumberUtils.INTEGER_MINUS_ONE instanceof Integer);\n+        assertTrue(NumberUtils.SHORT_ZERO instanceof Short);\n+        assertTrue(NumberUtils.SHORT_ONE instanceof Short);\n+        assertTrue(NumberUtils.SHORT_MINUS_ONE instanceof Short);\n+        assertTrue(NumberUtils.BYTE_ZERO instanceof Byte);\n+        assertTrue(NumberUtils.BYTE_ONE instanceof Byte);\n+        assertTrue(NumberUtils.BYTE_MINUS_ONE instanceof Byte);\n+        assertTrue(NumberUtils.DOUBLE_ZERO instanceof Double);\n+        assertTrue(NumberUtils.DOUBLE_ONE instanceof Double);\n+        assertTrue(NumberUtils.DOUBLE_MINUS_ONE instanceof Double);\n+        assertTrue(NumberUtils.FLOAT_ZERO instanceof Float);\n+        assertTrue(NumberUtils.FLOAT_ONE instanceof Float);\n+        assertTrue(NumberUtils.FLOAT_MINUS_ONE instanceof Float);\n+        \n+        assertTrue(NumberUtils.LONG_ZERO.longValue() == 0);\n+        assertTrue(NumberUtils.LONG_ONE.longValue() == 1);\n+        assertTrue(NumberUtils.LONG_MINUS_ONE.longValue() == -1);\n+        assertTrue(NumberUtils.INTEGER_ZERO.intValue() == 0);\n+        assertTrue(NumberUtils.INTEGER_ONE.intValue() == 1);\n+        assertTrue(NumberUtils.INTEGER_MINUS_ONE.intValue() == -1);\n+        assertTrue(NumberUtils.SHORT_ZERO.shortValue() == 0);\n+        assertTrue(NumberUtils.SHORT_ONE.shortValue() == 1);\n+        assertTrue(NumberUtils.SHORT_MINUS_ONE.shortValue() == -1);\n+        assertTrue(NumberUtils.BYTE_ZERO.byteValue() == 0);\n+        assertTrue(NumberUtils.BYTE_ONE.byteValue() == 1);\n+        assertTrue(NumberUtils.BYTE_MINUS_ONE.byteValue() == -1);\n+        assertTrue(NumberUtils.DOUBLE_ZERO.doubleValue() == 0.0d);\n+        assertTrue(NumberUtils.DOUBLE_ONE.doubleValue() == 1.0d);\n+        assertTrue(NumberUtils.DOUBLE_MINUS_ONE.doubleValue() == -1.0d);\n+        assertTrue(NumberUtils.FLOAT_ZERO.floatValue() == 0.0f);\n+        assertTrue(NumberUtils.FLOAT_ONE.floatValue() == 1.0f);\n+        assertTrue(NumberUtils.FLOAT_MINUS_ONE.floatValue() == -1.0f);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/RandomUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link RandomUtils} class.\n+ *\n+ * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class RandomUtilsTest extends TestCase {\n+\n+    public RandomUtilsTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RandomUtilsTest.class);\n+        suite.setName(\"RandomUtils Tests\");\n+        return suite;\n+    }\n+    \n+    /** test distribution of nextInt() */\n+    public void testNextInt() {\n+        tstNextInt(null);\n+        \n+        assertTrue (RandomUtils.nextInt() >= 0);\n+    }\n+    \n+    /** test distribution of nextInt(Random) */\n+    public void testNextInt2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextInt(rnd);\n+    } \n+    \n+    /** test distribution of JVMRandom.nextInt() */\n+    public void testJvmRandomNextInt() {\n+        tstNextInt(RandomUtils.JVM_RANDOM);\n+    } \n+\n+    \n+    /** \n+     * Generate 1000 values for nextInt(bound) and compare\n+     * the observed frequency counts to expected counts using\n+     * a chi-square test.\n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextInt(Random rnd) {\n+        int bound = 0;\n+        int result = 0;\n+        // test boundary condition: n = Integer.MAX_VALUE;\n+        bound = Integer.MAX_VALUE;\n+        if (rnd == null) {\n+            result = RandomUtils.nextInt(bound);\n+        } else {\n+            result = RandomUtils.nextInt(rnd,bound);\n+        }      \n+        assertTrue(\"result less than bound\",result < bound);\n+        assertTrue(\"result non-negative\",result >= 0);\n+        \n+        // test uniformity -- use Chi-Square test at .01 level\n+        bound = 4;\n+        int[] expected = new int[] {250,250,250,250};\n+        int[] observed = new int[] {0,0,0,0};\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = RandomUtils.nextInt(bound);\n+            } else {\n+                result = RandomUtils.nextInt(rnd,bound);\n+            }     \n+            assertTrue(result < bound);\n+            assertTrue(result >= 0);\n+            observed[result]++;\n+        } \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01   \n+         */\n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 1000 times\",\n+            chiSquare(expected,observed) < 16.27);                                                            \n+    }  \n+    \n+    /** test distribution of nextLong() */\n+    public void testNextLong() {\n+        tstNextLong(null);\n+    }\n+    \n+    /** test distribution of nextLong(Random) BROKEN\n+     *  contract of nextLong(Random) is different from\n+     * nextLong() */\n+    public void testNextLong2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextLong(rnd);\n+    }\n+     \n+    /** \n+     * Generate 1000 values for nextLong and check that\n+     * p(value < long.MAXVALUE/2) ~ 0.5. Use chi-square test\n+     * with df = 2-1 = 1  \n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextLong(Random rnd) {\n+        int[] expected = new int[] {500,500};\n+        int[] observed = new int[] {0,0};\n+        long result = 0;\n+        long midPoint = Long.MAX_VALUE/2;\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = Math.abs(RandomUtils.nextLong());\n+            } else {\n+                result = Math.abs(RandomUtils.nextLong(rnd));\n+            }  \n+            if (result < midPoint) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n+         * Change to 6.64 for alpha = .01  \n+         */ \n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 1000 times\",\n+            chiSquare(expected,observed) < 10.83); \n+    }\n+        \n+    \n+    /** test distribution of nextBoolean() */\n+    public void testNextBoolean() {\n+        tstNextBoolean(null);\n+    }\n+    \n+    /** test distribution of nextBoolean(Random) */\n+    public void testNextBoolean2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextBoolean(rnd);\n+    }\n+    \n+    /** \n+     * Generate 1000 values for nextBoolean and check that\n+     * p(value = false) ~ 0.5. Use chi-square test\n+     * with df = 2-1 = 1  \n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextBoolean(Random rnd) {\n+        int[] expected = new int[] {500,500};\n+        int[] observed = new int[] {0,0};\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = RandomUtils.nextBoolean();\n+            } else {\n+                result = RandomUtils.nextBoolean(rnd);\n+            }     \n+            if (result) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n+         * Change to 6.64 for alpha = .01 \n+         */\n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 1000 times\",\n+            chiSquare(expected,observed) < 10.83 );  \n+    }\n+    \n+    /** test distribution of nextFloat() */\n+    public void testNextFloat() {\n+        tstNextFloat(null);\n+    }\n+    \n+    /** test distribution of nextFloat(Random) */\n+    public void testNextFloat2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextFloat(rnd);\n+    }\n+    \n+    /** \n+     * Generate 1000 values for nextFloat and check that\n+     * p(value < 0.5) ~ 0.5. Use chi-square test\n+     * with df = 2-1 = 1  \n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextFloat(Random rnd) {\n+        int[] expected = new int[] {500,500};\n+        int[] observed = new int[] {0,0};\n+        float result = 0;\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = RandomUtils.nextFloat();\n+            } else {\n+                result = RandomUtils.nextFloat(rnd);\n+            }     \n+            if (result < 0.5) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n+         * Change to 6.64 for alpha = .01 \n+         */\n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 1000 times\",\n+            chiSquare(expected,observed) < 10.83);  \n+    }\n+    \n+    /** test distribution of nextDouble() */\n+    public void testNextDouble() {\n+        tstNextDouble(null);\n+    }\n+    \n+    /** test distribution of nextDouble(Random) */\n+    public void testNextDouble2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextDouble(rnd);\n+    }\n+    \n+    /** \n+     * Generate 1000 values for nextFloat and check that\n+     * p(value < 0.5) ~ 0.5. Use chi-square test\n+     * with df = 2-1 = 1  \n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextDouble(Random rnd) {\n+        int[] expected = new int[] {500,500};\n+        int[] observed = new int[] {0,0};\n+        double result = 0;\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = RandomUtils.nextDouble();\n+            } else {\n+                result = RandomUtils.nextDouble(rnd);\n+            }     \n+            if (result < 0.5) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n+         * Change to 6.64 for alpha = .01 \n+         */\n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 1000 times\",\n+            chiSquare(expected,observed) < 10.83);  \n+    }\n+    \n+    /** make sure that unimplemented methods fail */\n+    public void testUnimplementedMethods() {\n+\n+        try {\n+            RandomUtils.JVM_RANDOM.setSeed(1000);\n+            fail(\"expecting UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ex) {\n+            // empty\n+        }\n+\n+        try {\n+            RandomUtils.JVM_RANDOM.nextGaussian();\n+            fail(\"expecting UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ex) {\n+            // empty\n+        }\n+\n+        try {\n+            RandomUtils.JVM_RANDOM.nextBytes(null);\n+            fail(\"expecting UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ex) {\n+            // empty\n+        }\n+\n+    }\n+\n+    /** make sure that illegal arguments fail */\n+    public void testIllegalArguments() {\n+\n+        try {\n+            RandomUtils.JVM_RANDOM.nextInt(-1);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+\n+        try {\n+            JVMRandom.nextLong( -1L );\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+\n+    }\n+    \n+    /**\n+     * Computes Chi-Square statistic given observed and expected counts\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     */\n+    private double chiSquare(int[] expected, int[] observed) {\n+        double sumSq = 0.0d;\n+        double dev = 0.0d;\n+        for (int i = 0; i< observed.length; i++) {\n+            dev = (double)(observed[i] - expected[i]);\n+            sumSq += dev*dev/(double)expected[i];\n+        }\n+        return sumSq;\n+    }           \n+\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/math/RangeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * <p>\n+ * Tests the base methods in the {@link org.apache.commons.lang.math.Range} class.\n+ * </p>\n+ * \n+ * @author Nathan Beyer\n+ * @version $Id$\n+ */\n+public class RangeTest extends TestCase {\n+\n+    private static class RangeTestFixture extends Range {\n+        private byte max;\n+\n+        private byte min;\n+\n+        RangeTestFixture(byte min, byte max) {\n+            super();\n+            this.min = min;\n+            this.max = max;\n+        }\n+\n+        public boolean containsNumber(Number number) {\n+            if (number.byteValue() >= min && number.byteValue() <= max) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        public Number getMaximumNumber() {\n+            return new Byte(max);\n+        }\n+\n+        public Number getMinimumNumber() {\n+            return new Byte(min);\n+        }\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RangeTest.class);\n+        suite.setName(\"Range Tests\");\n+        return suite;\n+    }\n+\n+    public RangeTest(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Test method for 'org.apache.commons.lang.math.Range.equals(Object)'\n+     */\n+    public void testEqualsObject() {\n+        RangeTestFixture r1 = new RangeTestFixture((byte) 0, (byte) 5);\n+        RangeTestFixture r2 = new RangeTestFixture((byte) 0, (byte) 5);\n+        RangeTestFixture r3 = new RangeTestFixture((byte) 0, (byte) 10);\n+\n+        assertEquals(r1, r1);\n+        assertEquals(r1, r2);\n+        assertEquals(r2, r2);\n+        assertTrue(r1.equals(r1));\n+        assertTrue(r2.equals(r2));\n+        assertTrue(r3.equals(r3));\n+        assertFalse(r2.equals(r3));\n+        assertFalse(r2.equals(null));\n+        assertFalse(r2.equals(\"Ni!\"));\n+    }\n+\n+    /**\n+     * Test method for 'org.apache.commons.lang.math.Range.hashCode()'\n+     */\n+    public void testHashCode() {\n+        RangeTestFixture r1 = new RangeTestFixture((byte) 0, (byte) 5);\n+        RangeTestFixture r2 = new RangeTestFixture((byte) 0, (byte) 5);\n+        RangeTestFixture r3 = new RangeTestFixture((byte) 0, (byte) 10);\n+\n+        assertEquals(r1.hashCode(), r2.hashCode());\n+        assertFalse(r1.hashCode() == r3.hashCode());\n+    }\n+\n+    /**\n+     * Test method for 'org.apache.commons.lang.math.Range.toString()'\n+     */\n+    public void testToString() {\n+        RangeTestFixture r1 = new RangeTestFixture((byte) 0, (byte) 5);\n+        assertNotNull(r1.toString());\n+        assertNotNull(r1.toString());\n+        RangeTestFixture r2 = new RangeTestFixture((byte) 0, (byte) 5);\n+        assertNotNull(r2.toString());\n+        assertNotNull(r2.toString());\n+        RangeTestFixture r3 = new RangeTestFixture((byte) 0, (byte) 10);\n+        assertNotNull(r3.toString());\n+        assertNotNull(r3.toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableBooleanTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @since 2.2\n+ * @see MutableBoolean\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableBooleanTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableBooleanTest.class);\n+    }\n+\n+    public MutableBooleanTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableBoolean mutBool = new MutableBoolean(false);\n+\n+        assertEquals(0, mutBool.compareTo(new MutableBoolean(false)));\n+        assertEquals(-1, mutBool.compareTo(new MutableBoolean(true)));\n+        mutBool.setValue(true);\n+        assertEquals(+1, mutBool.compareTo(new MutableBoolean(false)));\n+        assertEquals(0, mutBool.compareTo(new MutableBoolean(true)));\n+\n+        try {\n+            mutBool.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+        try {\n+            mutBool.compareTo(Boolean.FALSE);\n+            fail();\n+        } catch (ClassCastException ex) {\n+        }\n+        try {\n+            mutBool.compareTo(\"false\");\n+            fail();\n+        } catch (ClassCastException ex) {\n+        }\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(false, new MutableBoolean().booleanValue());\n+\n+        assertEquals(true, new MutableBoolean(true).booleanValue());\n+        assertEquals(false, new MutableBoolean(false).booleanValue());\n+\n+        assertEquals(true, new MutableBoolean(Boolean.TRUE).booleanValue());\n+        assertEquals(false, new MutableBoolean(Boolean.FALSE).booleanValue());\n+\n+        try {\n+            new MutableBoolean(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+\n+    public void testEquals() {\n+        final MutableBoolean mutBoolA = new MutableBoolean(false);\n+        final MutableBoolean mutBoolB = new MutableBoolean(false);\n+        final MutableBoolean mutBoolC = new MutableBoolean(true);\n+\n+        assertEquals(true, mutBoolA.equals(mutBoolA));\n+        assertEquals(true, mutBoolA.equals(mutBoolB));\n+        assertEquals(true, mutBoolB.equals(mutBoolA));\n+        assertEquals(true, mutBoolB.equals(mutBoolB));\n+        assertEquals(false, mutBoolA.equals(mutBoolC));\n+        assertEquals(false, mutBoolB.equals(mutBoolC));\n+        assertEquals(true, mutBoolC.equals(mutBoolC));\n+        assertEquals(false, mutBoolA.equals(null));\n+        assertEquals(false, mutBoolA.equals(Boolean.FALSE));\n+        assertEquals(false, mutBoolA.equals(\"false\"));\n+    }\n+\n+    public void testGetSet() {\n+        final MutableBoolean mutBool = new MutableBoolean(false);\n+        assertEquals(false, new MutableBoolean().booleanValue());\n+\n+        mutBool.setValue(Boolean.TRUE);\n+        assertEquals(true, mutBool.booleanValue());\n+\n+        mutBool.setValue(false);\n+        assertEquals(false, mutBool.booleanValue());\n+\n+        mutBool.setValue(true);\n+        assertEquals(true, mutBool.booleanValue());\n+\n+        try {\n+            mutBool.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+        try {\n+            mutBool.setValue(\"false\");\n+            fail();\n+        } catch (ClassCastException ex) {\n+        }\n+    }\n+\n+    public void testHashCode() {\n+        final MutableBoolean mutBoolA = new MutableBoolean(false);\n+        final MutableBoolean mutBoolB = new MutableBoolean(false);\n+        final MutableBoolean mutBoolC = new MutableBoolean(true);\n+\n+        assertEquals(true, mutBoolA.hashCode() == mutBoolA.hashCode());\n+        assertEquals(true, mutBoolA.hashCode() == mutBoolB.hashCode());\n+        assertEquals(false, mutBoolA.hashCode() == mutBoolC.hashCode());\n+        assertEquals(true, mutBoolA.hashCode() == Boolean.FALSE.hashCode());\n+        assertEquals(true, mutBoolC.hashCode() == Boolean.TRUE.hashCode());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(Boolean.FALSE.toString(), new MutableBoolean(false).toString());\n+        assertEquals(Boolean.TRUE.toString(), new MutableBoolean(true).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableByteTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableByte\n+ */\n+public class MutableByteTest extends TestCase {\n+\n+    public MutableByteTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableByteTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals((byte) 0, new MutableByte().byteValue());\n+        \n+        assertEquals((byte) 1, new MutableByte((byte) 1).byteValue());\n+        \n+        assertEquals((byte) 2, new MutableByte(new Byte((byte) 2)).byteValue());\n+        assertEquals((byte) 3, new MutableByte(new MutableByte((byte) 3)).byteValue());\n+        try {\n+            new MutableByte(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableByte mutNum = new MutableByte((byte) 0);\n+        assertEquals((byte) 0, new MutableByte().byteValue());\n+        assertEquals(new Byte((byte) 0), new MutableByte().getValue());\n+        \n+        mutNum.setValue((byte) 1);\n+        assertEquals((byte) 1, mutNum.byteValue());\n+        assertEquals(new Byte((byte) 1), mutNum.getValue());\n+        \n+        mutNum.setValue(new Byte((byte) 2));\n+        assertEquals((byte) 2, mutNum.byteValue());\n+        assertEquals(new Byte((byte) 2), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableByte((byte) 3));\n+        assertEquals((byte) 3, mutNum.byteValue());\n+        assertEquals(new Byte((byte) 3), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.setValue(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        final MutableByte mutNumA = new MutableByte((byte) 0);\n+        final MutableByte mutNumB = new MutableByte((byte) 0);\n+        final MutableByte mutNumC = new MutableByte((byte) 1);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Byte((byte) 0)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableByte mutNumA = new MutableByte((byte) 0);\n+        final MutableByte mutNumB = new MutableByte((byte) 0);\n+        final MutableByte mutNumC = new MutableByte((byte) 1);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Byte((byte) 0).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableByte mutNum = new MutableByte((byte) 0);\n+\n+        assertEquals((byte) 0, mutNum.compareTo(new MutableByte((byte) 0)));\n+        assertEquals((byte) +1, mutNum.compareTo(new MutableByte((byte) -1)));\n+        assertEquals((byte) -1, mutNum.compareTo(new MutableByte((byte) 1)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.compareTo(new Byte((byte) 0));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            mutNum.compareTo(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableByte mutNum = new MutableByte( (byte) 1 );\n+        \n+        assertEquals( 1.0F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.0, mutNum.doubleValue(), 0 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToByte() {\n+        assertEquals(new Byte((byte) 0), new MutableByte((byte) 0).toByte());\n+        assertEquals(new Byte((byte) 123), new MutableByte((byte) 123).toByte());\n+    }\n+\n+    public void testIncrement() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.add((byte)1);\n+        \n+        assertEquals((byte) 2, mutNum.byteValue());\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.add(new Integer(1));\n+        \n+        assertEquals((byte) 2, mutNum.byteValue());\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.subtract((byte) 1);\n+        \n+        assertEquals((byte) 0, mutNum.byteValue());\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableByte mutNum = new MutableByte((byte) 1);\n+        mutNum.subtract(new Integer(1));\n+        \n+        assertEquals((byte) 0, mutNum.byteValue());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new MutableByte((byte) 0).toString());\n+        assertEquals(\"10\", new MutableByte((byte) 10).toString());\n+        assertEquals(\"-123\", new MutableByte((byte) -123).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableDoubleTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableDouble\n+ */\n+public class MutableDoubleTest extends TestCase {\n+\n+    public MutableDoubleTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableDoubleTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d);\n+        \n+        assertEquals(1d, new MutableDouble(1d).doubleValue(), 0.0001d);\n+        \n+        assertEquals(2d, new MutableDouble(new Double(2d)).doubleValue(), 0.0001d);\n+        assertEquals(3d, new MutableDouble(new MutableDouble(3d)).doubleValue(), 0.0001d);\n+        try {\n+            new MutableDouble(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableDouble mutNum = new MutableDouble(0d);\n+        assertEquals(0d, new MutableDouble().doubleValue(), 0.0001d);\n+        assertEquals(new Double(0), new MutableDouble().getValue());\n+        \n+        mutNum.setValue(1);\n+        assertEquals(1d, mutNum.doubleValue(), 0.0001d);\n+        assertEquals(new Double(1d), mutNum.getValue());\n+        \n+        mutNum.setValue(new Double(2d));\n+        assertEquals(2d, mutNum.doubleValue(), 0.0001d);\n+        assertEquals(new Double(2d), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableDouble(3d));\n+        assertEquals(3d, mutNum.doubleValue(), 0.0001d);\n+        assertEquals(new Double(3d), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.setValue(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testNanInfinite() {\n+        MutableDouble mutNum = new MutableDouble(Double.NaN);\n+        assertEquals(true, mutNum.isNaN());\n+        \n+        mutNum = new MutableDouble(Double.POSITIVE_INFINITY);\n+        assertEquals(true, mutNum.isInfinite());\n+        \n+        mutNum = new MutableDouble(Double.NEGATIVE_INFINITY);\n+        assertEquals(true, mutNum.isInfinite());\n+    }\n+\n+    public void testEquals() {\n+        final MutableDouble mutNumA = new MutableDouble(0d);\n+        final MutableDouble mutNumB = new MutableDouble(0d);\n+        final MutableDouble mutNumC = new MutableDouble(1d);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Double(0d)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableDouble mutNumA = new MutableDouble(0d);\n+        final MutableDouble mutNumB = new MutableDouble(0d);\n+        final MutableDouble mutNumC = new MutableDouble(1d);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Double(0d).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableDouble mutNum = new MutableDouble(0d);\n+\n+        assertEquals(0, mutNum.compareTo(new MutableDouble(0d)));\n+        assertEquals(+1, mutNum.compareTo(new MutableDouble(-1d)));\n+        assertEquals(-1, mutNum.compareTo(new MutableDouble(1d)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.compareTo(new Double(0d));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            mutNum.compareTo(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableDouble mutNum = new MutableDouble(1.7);\n+        \n+        assertEquals( 1.7F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.7, mutNum.doubleValue(), 0 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToDouble() {\n+        assertEquals(new Double(0d), new MutableDouble(0d).toDouble());\n+        assertEquals(new Double(12.3d), new MutableDouble(12.3d).toDouble());\n+    }\n+\n+    public void testIncrement() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.add(1.1d);\n+        \n+        assertEquals(2.1d, mutNum.doubleValue(), 0.01d);\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.add(new Double(1.1d));\n+        \n+        assertEquals(2.1d, mutNum.doubleValue(), 0.01d);\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.subtract(0.9d);\n+        \n+        assertEquals(0.1d, mutNum.doubleValue(), 0.01d);\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableDouble mutNum = new MutableDouble(1);\n+        mutNum.subtract(new Double(0.9d));\n+        \n+        assertEquals(0.1d, mutNum.doubleValue(), 0.01d);\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0.0\", new MutableDouble(0d).toString());\n+        assertEquals(\"10.0\", new MutableDouble(10d).toString());\n+        assertEquals(\"-123.0\", new MutableDouble(-123d).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableFloatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableFloat\n+ */\n+public class MutableFloatTest extends TestCase {\n+\n+    public MutableFloatTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableFloatTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(0f, new MutableFloat().floatValue(), 0.0001f);\n+        \n+        assertEquals(1f, new MutableFloat(1f).floatValue(), 0.0001f);\n+        \n+        assertEquals(2f, new MutableFloat(new Float(2f)).floatValue(), 0.0001f);\n+        assertEquals(3f, new MutableFloat(new MutableFloat(3f)).floatValue(), 0.0001f);\n+        try {\n+            new MutableFloat(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableFloat mutNum = new MutableFloat(0f);\n+        assertEquals(0f, new MutableFloat().floatValue(), 0.0001f);\n+        assertEquals(new Float(0), new MutableFloat().getValue());\n+        \n+        mutNum.setValue(1);\n+        assertEquals(1f, mutNum.floatValue(), 0.0001f);\n+        assertEquals(new Float(1f), mutNum.getValue());\n+        \n+        mutNum.setValue(new Float(2f));\n+        assertEquals(2f, mutNum.floatValue(), 0.0001f);\n+        assertEquals(new Float(2f), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableFloat(3f));\n+        assertEquals(3f, mutNum.floatValue(), 0.0001f);\n+        assertEquals(new Float(3f), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.setValue(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testNanInfinite() {\n+        MutableFloat mutNum = new MutableFloat(Float.NaN);\n+        assertEquals(true, mutNum.isNaN());\n+        \n+        mutNum = new MutableFloat(Float.POSITIVE_INFINITY);\n+        assertEquals(true, mutNum.isInfinite());\n+        \n+        mutNum = new MutableFloat(Float.NEGATIVE_INFINITY);\n+        assertEquals(true, mutNum.isInfinite());\n+    }\n+\n+    public void testEquals() {\n+        final MutableFloat mutNumA = new MutableFloat(0f);\n+        final MutableFloat mutNumB = new MutableFloat(0f);\n+        final MutableFloat mutNumC = new MutableFloat(1f);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Float(0f)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableFloat mutNumA = new MutableFloat(0f);\n+        final MutableFloat mutNumB = new MutableFloat(0f);\n+        final MutableFloat mutNumC = new MutableFloat(1f);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Float(0f).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableFloat mutNum = new MutableFloat(0f);\n+\n+        assertEquals(0, mutNum.compareTo(new MutableFloat(0f)));\n+        assertEquals(+1, mutNum.compareTo(new MutableFloat(-1f)));\n+        assertEquals(-1, mutNum.compareTo(new MutableFloat(1f)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.compareTo(new Float(0f));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            mutNum.compareTo(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableFloat mutNum = new MutableFloat(1.7F);\n+        \n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1.7, mutNum.doubleValue(), 0.00001 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToFloat() {\n+        assertEquals(new Float(0f), new MutableFloat(0f).toFloat());\n+        assertEquals(new Float(12.3f), new MutableFloat(12.3f).toFloat());\n+    }\n+\n+    public void testIncrement() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.add(1.1f);\n+        \n+        assertEquals(2.1f, mutNum.floatValue(), 0.01f);\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.add(new Float(1.1f));\n+        \n+        assertEquals(2.1f, mutNum.floatValue(), 0.01f);\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.subtract(0.9f);\n+        \n+        assertEquals(0.1f, mutNum.floatValue(), 0.01f);\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableFloat mutNum = new MutableFloat(1);\n+        mutNum.subtract(new Float(0.9f));\n+        \n+        assertEquals(0.1f, mutNum.floatValue(), 0.01f);\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0.0\", new MutableFloat(0f).toString());\n+        assertEquals(\"10.0\", new MutableFloat(10f).toString());\n+        assertEquals(\"-123.0\", new MutableFloat(-123f).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableIntTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableInt\n+ */\n+public class MutableIntTest extends TestCase {\n+\n+    public MutableIntTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableIntTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(0, new MutableInt().intValue());\n+        \n+        assertEquals(1, new MutableInt(1).intValue());\n+        \n+        assertEquals(2, new MutableInt(new Integer(2)).intValue());\n+        assertEquals(3, new MutableInt(new MutableLong(3)).intValue());\n+        try {\n+            new MutableInt(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableInt mutNum = new MutableInt(0);\n+        assertEquals(0, new MutableInt().intValue());\n+        assertEquals(new Integer(0), new MutableInt().getValue());\n+        \n+        mutNum.setValue(1);\n+        assertEquals(1, mutNum.intValue());\n+        assertEquals(new Integer(1), mutNum.getValue());\n+        \n+        mutNum.setValue(new Integer(2));\n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(new Integer(2), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableLong(3));\n+        assertEquals(3, mutNum.intValue());\n+        assertEquals(new Integer(3), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.setValue(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        this.testEquals(new MutableInt(0), new MutableInt(0), new MutableInt(1));\n+        // Should Numbers be supported? GaryG July-21-2005.\n+        //this.testEquals(mutNumA, new Integer(0), mutNumC);\n+    }\n+\n+    /**\n+     * @param numA must not be a 0 Integer; must not equal numC.\n+     * @param numB must equal numA; must not equal numC.\n+     * @param numC must not equal numA; must not equal numC.\n+     */\n+    void testEquals(final Number numA, final Number numB, final Number numC) {\n+        assertEquals(true, numA.equals(numA));\n+        assertEquals(true, numA.equals(numB));\n+        assertEquals(true, numB.equals(numA));\n+        assertEquals(true, numB.equals(numB));\n+        assertEquals(false, numA.equals(numC));\n+        assertEquals(false, numB.equals(numC));\n+        assertEquals(true, numC.equals(numC));\n+        assertEquals(false, numA.equals(null));\n+        assertEquals(false, numA.equals(new Integer(0)));\n+        assertEquals(false, numA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableInt mutNumA = new MutableInt(0);\n+        final MutableInt mutNumB = new MutableInt(0);\n+        final MutableInt mutNumC = new MutableInt(1);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Integer(0).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableInt mutNum = new MutableInt(0);\n+\n+        assertEquals(0, mutNum.compareTo(new MutableInt(0)));\n+        assertEquals(+1, mutNum.compareTo(new MutableInt(-1)));\n+        assertEquals(-1, mutNum.compareTo(new MutableInt(1)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.compareTo(new Integer(0));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            mutNum.compareTo(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableInt mutNum = new MutableInt(1);\n+        \n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1.0F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.0, mutNum.doubleValue(), 0 );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToInteger() {\n+        assertEquals(new Integer(0), new MutableInt(0).toInteger());\n+        assertEquals(new Integer(123), new MutableInt(123).toInteger());\n+    }\n+\n+    public void testIncrement() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.add(1);\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.add(new Integer(1));\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.subtract(1);\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableInt mutNum = new MutableInt(1);\n+        mutNum.subtract(new Integer(1));\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new MutableInt(0).toString());\n+        assertEquals(\"10\", new MutableInt(10).toString());\n+        assertEquals(\"-123\", new MutableInt(-123).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableLongTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableLong\n+ */\n+public class MutableLongTest extends TestCase {\n+\n+    public MutableLongTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableLongTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(0, new MutableLong().longValue());\n+        \n+        assertEquals(1, new MutableLong(1).longValue());\n+        \n+        assertEquals(2, new MutableLong(new Long(2)).longValue());\n+        assertEquals(3, new MutableLong(new MutableLong(3)).longValue());\n+        try {\n+            new MutableLong(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableLong mutNum = new MutableLong(0);\n+        assertEquals(0, new MutableLong().longValue());\n+        assertEquals(new Long(0), new MutableLong().getValue());\n+        \n+        mutNum.setValue(1);\n+        assertEquals(1, mutNum.longValue());\n+        assertEquals(new Long(1), mutNum.getValue());\n+        \n+        mutNum.setValue(new Long(2));\n+        assertEquals(2, mutNum.longValue());\n+        assertEquals(new Long(2), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableLong(3));\n+        assertEquals(3, mutNum.longValue());\n+        assertEquals(new Long(3), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.setValue(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        final MutableLong mutNumA = new MutableLong(0);\n+        final MutableLong mutNumB = new MutableLong(0);\n+        final MutableLong mutNumC = new MutableLong(1);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Long(0)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableLong mutNumA = new MutableLong(0);\n+        final MutableLong mutNumB = new MutableLong(0);\n+        final MutableLong mutNumC = new MutableLong(1);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Long(0).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableLong mutNum = new MutableLong(0);\n+\n+        assertEquals(0, mutNum.compareTo(new MutableLong(0)));\n+        assertEquals(+1, mutNum.compareTo(new MutableLong(-1)));\n+        assertEquals(-1, mutNum.compareTo(new MutableLong(1)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.compareTo(new Long(0));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            mutNum.compareTo(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableLong mutNum = new MutableLong(1L);\n+\n+        assertEquals( 1.0F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.0, mutNum.doubleValue(), 0 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToLong() {\n+        assertEquals(new Long(0L), new MutableLong(0L).toLong());\n+        assertEquals(new Long(123L), new MutableLong(123L).toLong());\n+    }\n+\n+    public void testIncrement() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.add(1);\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.add(new Long(1));\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.subtract(1);\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableLong mutNum = new MutableLong(1);\n+        mutNum.subtract(new Long(1));\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new MutableLong(0).toString());\n+        assertEquals(\"10\", new MutableLong(10).toString());\n+        assertEquals(\"-123\", new MutableLong(-123).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableObjectTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableShort\n+ */\n+public class MutableObjectTest extends TestCase {\n+\n+    public MutableObjectTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableObjectTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals(null, new MutableObject().getValue());\n+        \n+        Integer i = new Integer(6);\n+        assertSame(i, new MutableObject(i).getValue());\n+        assertSame(\"HI\", new MutableObject(\"HI\").getValue());\n+        assertSame(null, new MutableObject(null).getValue());\n+    }\n+\n+    public void testGetSet() {\n+        final MutableObject mutNum = new MutableObject();\n+        assertEquals(null, new MutableObject().getValue());\n+        \n+        mutNum.setValue(\"HELLO\");\n+        assertSame(\"HELLO\", mutNum.getValue());\n+        \n+        mutNum.setValue(null);\n+        assertSame(null, mutNum.getValue());\n+    }\n+\n+    public void testEquals() {\n+        final MutableObject mutNumA = new MutableObject(\"ALPHA\");\n+        final MutableObject mutNumB = new MutableObject(\"ALPHA\");\n+        final MutableObject mutNumC = new MutableObject(\"BETA\");\n+        final MutableObject mutNumD = new MutableObject(null);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(mutNumD));\n+        assertEquals(true, mutNumD.equals(mutNumD));\n+        \n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Object()));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableObject mutNumA = new MutableObject(\"ALPHA\");\n+        final MutableObject mutNumB = new MutableObject(\"ALPHA\");\n+        final MutableObject mutNumC = new MutableObject(\"BETA\");\n+        final MutableObject mutNumD = new MutableObject(null);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumD.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == \"ALPHA\".hashCode());\n+        assertEquals(0, mutNumD.hashCode());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"HI\", new MutableObject(\"HI\").toString());\n+        assertEquals(\"10.0\", new MutableObject(new Double(10)).toString());\n+        assertEquals(\"null\", new MutableObject(null).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableShortTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ * @see MutableShort\n+ */\n+public class MutableShortTest extends TestCase {\n+\n+    public MutableShortTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(MutableShortTest.class);\n+    }\n+\n+    // ----------------------------------------------------------------\n+    public void testConstructors() {\n+        assertEquals((short) 0, new MutableShort().shortValue());\n+        \n+        assertEquals((short) 1, new MutableShort((short) 1).shortValue());\n+        \n+        assertEquals((short) 2, new MutableShort(new Short((short) 2)).shortValue());\n+        assertEquals((short) 3, new MutableShort(new MutableShort((short) 3)).shortValue());\n+        try {\n+            new MutableShort(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    public void testGetSet() {\n+        final MutableShort mutNum = new MutableShort((short) 0);\n+        assertEquals((short) 0, new MutableShort().shortValue());\n+        assertEquals(new Short((short) 0), new MutableShort().getValue());\n+        \n+        mutNum.setValue((short) 1);\n+        assertEquals((short) 1, mutNum.shortValue());\n+        assertEquals(new Short((short) 1), mutNum.getValue());\n+        \n+        mutNum.setValue(new Short((short) 2));\n+        assertEquals((short) 2, mutNum.shortValue());\n+        assertEquals(new Short((short) 2), mutNum.getValue());\n+        \n+        mutNum.setValue(new MutableShort((short) 3));\n+        assertEquals((short) 3, mutNum.shortValue());\n+        assertEquals(new Short((short) 3), mutNum.getValue());\n+        try {\n+            mutNum.setValue(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.setValue(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testEquals() {\n+        final MutableShort mutNumA = new MutableShort((short) 0);\n+        final MutableShort mutNumB = new MutableShort((short) 0);\n+        final MutableShort mutNumC = new MutableShort((short) 1);\n+\n+        assertEquals(true, mutNumA.equals(mutNumA));\n+        assertEquals(true, mutNumA.equals(mutNumB));\n+        assertEquals(true, mutNumB.equals(mutNumA));\n+        assertEquals(true, mutNumB.equals(mutNumB));\n+        assertEquals(false, mutNumA.equals(mutNumC));\n+        assertEquals(false, mutNumB.equals(mutNumC));\n+        assertEquals(true, mutNumC.equals(mutNumC));\n+        assertEquals(false, mutNumA.equals(null));\n+        assertEquals(false, mutNumA.equals(new Short((short) 0)));\n+        assertEquals(false, mutNumA.equals(\"0\"));\n+    }\n+\n+    public void testHashCode() {\n+        final MutableShort mutNumA = new MutableShort((short) 0);\n+        final MutableShort mutNumB = new MutableShort((short) 0);\n+        final MutableShort mutNumC = new MutableShort((short) 1);\n+\n+        assertEquals(true, mutNumA.hashCode() == mutNumA.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == mutNumB.hashCode());\n+        assertEquals(false, mutNumA.hashCode() == mutNumC.hashCode());\n+        assertEquals(true, mutNumA.hashCode() == new Short((short) 0).hashCode());\n+    }\n+\n+    public void testCompareTo() {\n+        final MutableShort mutNum = new MutableShort((short) 0);\n+\n+        assertEquals((short) 0, mutNum.compareTo(new MutableShort((short) 0)));\n+        assertEquals((short) +1, mutNum.compareTo(new MutableShort((short) -1)));\n+        assertEquals((short) -1, mutNum.compareTo(new MutableShort((short) 1)));\n+        try {\n+            mutNum.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            mutNum.compareTo(new Short((short) 0));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            mutNum.compareTo(\"0\");\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testPrimitiveValues() {\n+        MutableShort mutNum = new MutableShort( (short) 1 );\n+        \n+        assertEquals( 1.0F, mutNum.floatValue(), 0 );\n+        assertEquals( 1.0, mutNum.doubleValue(), 0 );\n+        assertEquals( (byte) 1, mutNum.byteValue() );\n+        assertEquals( (short) 1, mutNum.shortValue() );\n+        assertEquals( 1, mutNum.intValue() );\n+        assertEquals( 1L, mutNum.longValue() );\n+    }\n+\n+    public void testToShort() {\n+        assertEquals(new Short((short) 0), new MutableShort((short) 0).toShort());\n+        assertEquals(new Short((short) 123), new MutableShort((short) 123).toShort());\n+    }\n+\n+    public void testIncrement() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.increment();\n+        \n+        assertEquals(2, mutNum.intValue());\n+        assertEquals(2L, mutNum.longValue());\n+    }\n+\n+    public void testDecrement() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.decrement();\n+        \n+        assertEquals(0, mutNum.intValue());\n+        assertEquals(0L, mutNum.longValue());\n+    }\n+\n+    public void testAddValuePrimitive() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.add((short) 1);\n+        \n+        assertEquals((short) 2, mutNum.shortValue());\n+    }\n+\n+    public void testAddValueObject() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.add(new Short((short) 1));\n+        \n+        assertEquals((short) 2, mutNum.shortValue());\n+    }\n+\n+    public void testSubtractValuePrimitive() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.subtract((short) 1);\n+        \n+        assertEquals((short) 0, mutNum.shortValue());\n+    }\n+\n+    public void testSubtractValueObject() {\n+        MutableShort mutNum = new MutableShort((short) 1);\n+        mutNum.subtract(new Short((short) 1));\n+        \n+        assertEquals((short) 0, mutNum.shortValue());\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"0\", new MutableShort((short) 0).toString());\n+        assertEquals(\"10\", new MutableShort((short) 10).toString());\n+        assertEquals(\"-123\", new MutableShort((short) -123).toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/mutable/MutableTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.mutable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Id$\n+ */\n+public class MutableTestSuite {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        final TestSuite suite = new TestSuite();\n+\n+        suite.addTest(MutableBooleanTest.suite());\n+        suite.addTest(MutableByteTest.suite());\n+        suite.addTest(MutableShortTest.suite());\n+        suite.addTest(MutableIntTest.suite());\n+        suite.addTest(MutableLongTest.suite());\n+        suite.addTest(MutableFloatTest.suite());\n+        suite.addTest(MutableDoubleTest.suite());\n+        suite.addTest(MutableObjectTest.suite());\n+\n+        return suite;\n+    }\n+\n+    private MutableTestSuite() {\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/text/CompositeFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.text.Format;\n+import java.text.FieldPosition;\n+import java.text.ParsePosition;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Locale;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.CompositeFormat}.\n+ */\n+public class CompositeFormatTest extends TestCase {\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CompositeFormatTest.class);\n+        suite.setName(\"CompositeFormat Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case with the specified name.\n+     * \n+     * @param name\n+     *            name\n+     */\n+    public CompositeFormatTest(String name) {\n+        super(name);\n+    }\n+\n+\n+    /**\n+     * Ensures that the parse/format separation is correctly maintained. \n+     */\n+    public void testCompositeFormat() {\n+\n+        Format parser = new Format() {\n+            public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+                throw new UnsupportedOperationException(\"Not implemented\");\n+            }\n+\n+            public Object parseObject(String source, ParsePosition pos) {\n+                return null;    // do nothing\n+            }\n+        };\n+\n+        Format formatter = new Format() {\n+            public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+                return null;    // do nothing\n+            }\n+\n+            public Object parseObject(String source, ParsePosition pos) {\n+                throw new UnsupportedOperationException(\"Not implemented\");\n+            }\n+        };\n+\n+        CompositeFormat composite = new CompositeFormat(parser, formatter);\n+\n+        composite.parseObject(\"\", null);\n+        composite.format(new Object(), new StringBuffer(), null);\n+        assertEquals( \"Parser get method incorrectly implemented\", parser, composite.getParser() );\n+        assertEquals( \"Formatter get method incorrectly implemented\", formatter, composite.getFormatter() );\n+    }\n+\n+    public void testUsage() throws Exception {\n+        Format f1 = new SimpleDateFormat(\"MMddyyyy\", Locale.ENGLISH);\n+        Format f2 = new SimpleDateFormat(\"MMMM d, yyyy\", Locale.ENGLISH);\n+        CompositeFormat c = new CompositeFormat(f1, f2);\n+        String testString = \"January 3, 2005\";\n+        assertEquals(testString, c.format(c.parseObject(\"01032005\")));\n+        assertEquals(testString, c.reformat(\"01032005\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/text/StrBuilderAppendInsertTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.StrBuilder}.\n+ *\n+ * @version $Id$\n+ */\n+public class StrBuilderAppendInsertTest extends TestCase {\n+\n+    /** Test subclass of Object, with a toString method. */\n+    private static Object FOO = new Object() {\n+        public String toString() {\n+            return \"foo\";\n+        }\n+    };\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrBuilderAppendInsertTest.class);\n+        suite.setName(\"StrBuilder Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case with the specified name.\n+     * \n+     * @param name  the name\n+     */\n+    public StrBuilderAppendInsertTest(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendNewLine() {\n+        StrBuilder sb = new StrBuilder(\"---\");\n+        sb.appendNewLine().append(\"+++\");\n+        assertEquals(\"---\" + SystemUtils.LINE_SEPARATOR + \"+++\", sb.toString());\n+        \n+        sb = new StrBuilder(\"---\");\n+        sb.setNewLineText(\"#\").appendNewLine().setNewLineText(null).appendNewLine();\n+        assertEquals(\"---#\" + SystemUtils.LINE_SEPARATOR, sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithNullText() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.appendNull();\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb.append((Object) null);\n+        assertEquals(\"NULLNULL\", sb.toString());\n+\n+        sb.append(FOO);\n+        assertEquals(\"NULLNULLfoo\", sb.toString());\n+\n+        sb.append((String) null);\n+        assertEquals(\"NULLNULLfooNULL\", sb.toString());\n+\n+        sb.append(\"\");\n+        assertEquals(\"NULLNULLfooNULL\", sb.toString());\n+\n+        sb.append(\"bar\");\n+        assertEquals(\"NULLNULLfooNULLbar\", sb.toString());\n+\n+        sb.append((StringBuffer) null);\n+        assertEquals(\"NULLNULLfooNULLbarNULL\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"baz\"));\n+        assertEquals(\"NULLNULLfooNULLbarNULLbaz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_Object() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendNull();\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.append((Object) null);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.append(FOO);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append((StringBuffer) null);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"baz\"));\n+        assertEquals(\"foobaz\", sb.toString());\n+\n+        sb.append(new StrBuilder(\"yes\"));\n+        assertEquals(\"foobazyes\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_String() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((String) null);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(\"foo\");\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(\"\");\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(\"bar\");\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_String_int_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((String) null, 0, 1);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(\"foo\", 0, 3);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        try {\n+            sb.append(\"bar\", -1, 1);\n+            fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", 3, 1);\n+            fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", 1, -1);\n+            fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", 1, 3);\n+            fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", -1, 3);\n+            fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(\"bar\", 4, 0);\n+            fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.append(\"bar\", 3, 0);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(\"abcbardef\", 3, 3);\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_StringBuffer() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((StringBuffer) null);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new StringBuffer(\"foo\"));\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"\"));\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"bar\"));\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_StringBuffer_int_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((StringBuffer) null, 0, 1);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new StringBuffer(\"foo\"), 0, 3);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), -1, 1);\n+            fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), 3, 1);\n+            fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), 1, -1);\n+            fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), 1, 3);\n+            fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), -1, 3);\n+            fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StringBuffer(\"bar\"), 4, 0);\n+            fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.append(new StringBuffer(\"bar\"), 3, 0);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StringBuffer(\"abcbardef\"), 3, 3);\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_StrBuilder() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((StrBuilder) null);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new StrBuilder(\"foo\"));\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StrBuilder(\"\"));\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StrBuilder(\"bar\"));\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_StrBuilder_int_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((StrBuilder) null, 0, 1);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new StrBuilder(\"foo\"), 0, 3);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), -1, 1);\n+            fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), 3, 1);\n+            fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), 1, -1);\n+            fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), 1, 3);\n+            fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), -1, 3);\n+            fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new StrBuilder(\"bar\"), 4, 0);\n+            fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.append(new StrBuilder(\"bar\"), 3, 0);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new StrBuilder(\"abcbardef\"), 3, 3);\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_CharArray() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((char[]) null);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new char[0]);\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.append(new char[]{'f', 'o', 'o'});\n+        assertEquals(\"foo\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_CharArray_int_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"NULL\").append((char[]) null, 0, 1);\n+        assertEquals(\"NULL\", sb.toString());\n+\n+        sb = new StrBuilder();\n+        sb.append(new char[]{'f', 'o', 'o'}, 0, 3);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, -1, 1);\n+            fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, 3, 1);\n+            fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, 1, -1);\n+            fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, 1, 3);\n+            fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, -1, 3);\n+            fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.append(new char[]{'b', 'a', 'r'}, 4, 0);\n+            fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.append(new char[]{'b', 'a', 'r'}, 3, 0);\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.append(new char[]{'a', 'b', 'c', 'b', 'a', 'r', 'd', 'e', 'f'}, 3, 3);\n+        assertEquals(\"foobar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_Primitive() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(true);\n+        assertEquals(\"true\", sb.toString());\n+\n+        sb.append(false);\n+        assertEquals(\"truefalse\", sb.toString());\n+\n+        sb.append('!');\n+        assertEquals(\"truefalse!\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppend_PrimitiveNumber() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(0);\n+        assertEquals(\"0\", sb.toString());\n+\n+        sb.append(1L);\n+        assertEquals(\"01\", sb.toString());\n+\n+        sb.append(2.3f);\n+        assertEquals(\"012.3\", sb.toString());\n+\n+        sb.append(4.5d);\n+        assertEquals(\"012.34.5\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendPadding() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(\"foo\");\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.appendPadding(-1, '-');\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.appendPadding(0, '-');\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.appendPadding(1, '-');\n+        assertEquals(\"foo-\", sb.toString());\n+\n+        sb.appendPadding(16, '-');\n+        assertEquals(20, sb.length());\n+        //            12345678901234567890\n+        assertEquals(\"foo-----------------\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendFixedWidthPadLeft() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadLeft(\"foo\", -1, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 0, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 1, '-');\n+        assertEquals(\"o\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 2, '-');\n+        assertEquals(\"oo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 3, '-');\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 4, '-');\n+        assertEquals(\"-foo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(\"foo\", 10, '-');\n+        assertEquals(10, sb.length());\n+        //            1234567890\n+        assertEquals(\"-------foo\", sb.toString());\n+\n+        sb.clear();\n+        sb.setNullText(\"null\");\n+        sb.appendFixedWidthPadLeft(null, 5, '-');\n+        assertEquals(\"-null\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendFixedWidthPadLeft_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadLeft(123, -1, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 0, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 1, '-');\n+        assertEquals(\"3\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 2, '-');\n+        assertEquals(\"23\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 3, '-');\n+        assertEquals(\"123\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 4, '-');\n+        assertEquals(\"-123\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadLeft(123, 10, '-');\n+        assertEquals(10, sb.length());\n+        //            1234567890\n+        assertEquals(\"-------123\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendFixedWidthPadRight() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadRight(\"foo\", -1, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 0, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 1, '-');\n+        assertEquals(\"f\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 2, '-');\n+        assertEquals(\"fo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 3, '-');\n+        assertEquals(\"foo\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 4, '-');\n+        assertEquals(\"foo-\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(\"foo\", 10, '-');\n+        assertEquals(10, sb.length());\n+        //            1234567890\n+        assertEquals(\"foo-------\", sb.toString());\n+\n+        sb.clear();\n+        sb.setNullText(\"null\");\n+        sb.appendFixedWidthPadRight(null, 5, '-');\n+        assertEquals(\"null-\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendFixedWidthPadRight_int() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendFixedWidthPadRight(123, -1, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 0, '-');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 1, '-');\n+        assertEquals(\"1\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 2, '-');\n+        assertEquals(\"12\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 3, '-');\n+        assertEquals(\"123\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 4, '-');\n+        assertEquals(\"123-\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendFixedWidthPadRight(123, 10, '-');\n+        assertEquals(10, sb.length());\n+        //            1234567890\n+        assertEquals(\"123-------\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithSeparators_Array() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendWithSeparators((Object[]) null, \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(new Object[0], \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(new Object[]{\"foo\", \"bar\", \"baz\"}, \",\");\n+        assertEquals(\"foo,bar,baz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(new Object[]{\"foo\", \"bar\", \"baz\"}, null);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(new Object[]{\"foo\", null, \"baz\"}, \",\");\n+        assertEquals(\"foo,,baz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithSeparators_Collection() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendWithSeparators((Collection) null, \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Collections.EMPTY_LIST, \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}), \",\");\n+        assertEquals(\"foo,bar,baz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}), null);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", null, \"baz\"}), \",\");\n+        assertEquals(\"foo,,baz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithSeparators_Iterator() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.appendWithSeparators((Iterator) null, \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), \",\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}).iterator(), \",\");\n+        assertEquals(\"foo,bar,baz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", \"bar\", \"baz\"}).iterator(), null);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", null, \"baz\"}).iterator(), \",\");\n+        assertEquals(\"foo,,baz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAppendWithSeparatorsWithNullText() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"null\");\n+        sb.appendWithSeparators(new Object[]{\"foo\", null, \"baz\"}, \",\");\n+        assertEquals(\"foo,null,baz\", sb.toString());\n+\n+        sb.clear();\n+        sb.appendWithSeparators(Arrays.asList(new Object[]{\"foo\", null, \"baz\"}), \",\");\n+        assertEquals(\"foo,null,baz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInsert() {\n+\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, FOO);\n+            fail(\"insert(-1, Object) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, FOO);\n+            fail(\"insert(7, Object) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (Object) null);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, FOO);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, \"foo\");\n+            fail(\"insert(-1, String) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, \"foo\");\n+            fail(\"insert(7, String) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (String) null);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, \"foo\");\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, new char[]{'f', 'o', 'o'});\n+            fail(\"insert(-1, char[]) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, new char[]{'f', 'o', 'o'});\n+            fail(\"insert(7, char[]) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (char[]) null);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, new char[0]);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, new char[]{'f', 'o', 'o'});\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);\n+            fail(\"insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);\n+            fail(\"insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (char[]) null, 0, 0);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, new char[0], 0, 0);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3);\n+            fail(\"insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3);\n+            fail(\"insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1);\n+            fail(\"insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10);\n+            fail(\"insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 0);\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);\n+        assertEquals(\"foobarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, true);\n+            fail(\"insert(-1, boolean) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, true);\n+            fail(\"insert(7, boolean) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, true);\n+        assertEquals(\"truebarbaz\", sb.toString());\n+\n+        sb.insert(0, false);\n+        assertEquals(\"falsetruebarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, '!');\n+            fail(\"insert(-1, char) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, '!');\n+            fail(\"insert(7, char) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, '!');\n+        assertEquals(\"!barbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, 0);\n+            fail(\"insert(-1, int) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, 0);\n+            fail(\"insert(7, int) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, '0');\n+        assertEquals(\"0barbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, 1L);\n+            fail(\"insert(-1, long) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, 1L);\n+            fail(\"insert(7, long) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, 1L);\n+        assertEquals(\"1barbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, 2.3F);\n+            fail(\"insert(-1, float) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, 2.3F);\n+            fail(\"insert(7, float) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, 2.3F);\n+        assertEquals(\"2.3barbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, 4.5D);\n+            fail(\"insert(-1, double) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, 4.5D);\n+            fail(\"insert(7, double) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, 4.5D);\n+        assertEquals(\"4.5barbaz\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInsertWithNullText() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.setNullText(\"null\");\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, FOO);\n+            fail(\"insert(-1, Object) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, FOO);\n+            fail(\"insert(7, Object) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (Object) null);\n+        assertEquals(\"nullbarbaz\", sb.toString());\n+\n+        sb.insert(0, FOO);\n+        assertEquals(\"foonullbarbaz\", sb.toString());\n+\n+        sb.clear();\n+        sb.append(\"barbaz\");\n+        assertEquals(\"barbaz\", sb.toString());\n+\n+        try {\n+            sb.insert(-1, \"foo\");\n+            fail(\"insert(-1, String) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            sb.insert(7, \"foo\");\n+            fail(\"insert(7, String) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.insert(0, (String) null);\n+        assertEquals(\"nullbarbaz\", sb.toString());\n+\n+        sb.insert(0, \"foo\");\n+        assertEquals(\"foonullbarbaz\", sb.toString());\n+\n+        sb.insert(0, (char[]) null);\n+        assertEquals(\"nullfoonullbarbaz\", sb.toString());\n+\n+        sb.insert(0, (char[]) null, 0, 0);\n+        assertEquals(\"nullnullfoonullbarbaz\", sb.toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/text/StrBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.StrBuilder}.\n+ * \n+ * @author Michael Heuer\n+ * @version $Id$\n+ */\n+public class StrBuilderTest extends TestCase {\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrBuilderTest.class);\n+        suite.setName(\"StrBuilder Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case with the specified name.\n+     * \n+     * @param name\n+     *            name\n+     */\n+    public StrBuilderTest(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructors() {\n+        StrBuilder sb0 = new StrBuilder();\n+        assertEquals(32, sb0.capacity());\n+        assertEquals(0, sb0.length());\n+        assertEquals(0, sb0.size());\n+\n+        StrBuilder sb1 = new StrBuilder(32);\n+        assertEquals(32, sb1.capacity());\n+        assertEquals(0, sb1.length());\n+        assertEquals(0, sb1.size());\n+\n+        StrBuilder sb2 = new StrBuilder(0);\n+        assertEquals(32, sb2.capacity());\n+        assertEquals(0, sb2.length());\n+        assertEquals(0, sb2.size());\n+\n+        StrBuilder sb3 = new StrBuilder(-1);\n+        assertEquals(32, sb3.capacity());\n+        assertEquals(0, sb3.length());\n+        assertEquals(0, sb3.size());\n+\n+        StrBuilder sb4 = new StrBuilder(1);\n+        assertEquals(1, sb4.capacity());\n+        assertEquals(0, sb4.length());\n+        assertEquals(0, sb4.size());\n+\n+        StrBuilder sb5 = new StrBuilder((String) null);\n+        assertEquals(32, sb5.capacity());\n+        assertEquals(0, sb5.length());\n+        assertEquals(0, sb5.size());\n+\n+        StrBuilder sb6 = new StrBuilder(\"\");\n+        assertEquals(32, sb6.capacity());\n+        assertEquals(0, sb6.length());\n+        assertEquals(0, sb6.size());\n+\n+        StrBuilder sb7 = new StrBuilder(\"foo\");\n+        assertEquals(35, sb7.capacity());\n+        assertEquals(3, sb7.length());\n+        assertEquals(3, sb7.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testChaining() {\n+        StrBuilder sb = new StrBuilder();\n+        assertSame(sb, sb.setNewLineText(null));\n+        assertSame(sb, sb.setNullText(null));\n+        assertSame(sb, sb.setLength(1));\n+        assertSame(sb, sb.setCharAt(0, 'a'));\n+        assertSame(sb, sb.ensureCapacity(0));\n+        assertSame(sb, sb.minimizeCapacity());\n+        assertSame(sb, sb.clear());\n+        assertSame(sb, sb.reverse());\n+        assertSame(sb, sb.trim());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetSetNewLineText() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(null, sb.getNewLineText());\n+\n+        sb.setNewLineText(\"#\");\n+        assertEquals(\"#\", sb.getNewLineText());\n+\n+        sb.setNewLineText(\"\");\n+        assertEquals(\"\", sb.getNewLineText());\n+\n+        sb.setNewLineText((String) null);\n+        assertEquals(null, sb.getNewLineText());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetSetNullText() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(null, sb.getNullText());\n+\n+        sb.setNullText(\"null\");\n+        assertEquals(\"null\", sb.getNullText());\n+\n+        sb.setNullText(\"\");\n+        assertEquals(null, sb.getNullText());\n+\n+        sb.setNullText(\"NULL\");\n+        assertEquals(\"NULL\", sb.getNullText());\n+\n+        sb.setNullText((String) null);\n+        assertEquals(null, sb.getNullText());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCapacityAndLength() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(32, sb.capacity());\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+\n+        sb.minimizeCapacity();\n+        assertEquals(0, sb.capacity());\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+\n+        sb.ensureCapacity(32);\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+\n+        sb.append(\"foo\");\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(3, sb.length());\n+        assertEquals(3, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.clear();\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+\n+        sb.append(\"123456789012345678901234567890123\");\n+        assertTrue(sb.capacity() > 32);\n+        assertEquals(33, sb.length());\n+        assertEquals(33, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.ensureCapacity(16);\n+        assertTrue(sb.capacity() > 16);\n+        assertEquals(33, sb.length());\n+        assertEquals(33, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.minimizeCapacity();\n+        assertEquals(33, sb.capacity());\n+        assertEquals(33, sb.length());\n+        assertEquals(33, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        try {\n+            sb.setLength(-1);\n+            fail(\"setLength(-1) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        sb.setLength(33);\n+        assertEquals(33, sb.capacity());\n+        assertEquals(33, sb.length());\n+        assertEquals(33, sb.size());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.setLength(16);\n+        assertTrue(sb.capacity() >= 16);\n+        assertEquals(16, sb.length());\n+        assertEquals(16, sb.size());\n+        assertEquals(\"1234567890123456\", sb.toString());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.setLength(32);\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(32, sb.length());\n+        assertEquals(32, sb.size());\n+        assertEquals(\"1234567890123456\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sb.toString());\n+        assertTrue(sb.isEmpty() == false);\n+\n+        sb.setLength(0);\n+        assertTrue(sb.capacity() >= 32);\n+        assertEquals(0, sb.length());\n+        assertEquals(0, sb.size());\n+        assertTrue(sb.isEmpty());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLength() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(0, sb.length());\n+        \n+        sb.append(\"Hello\");\n+        assertEquals(5, sb.length());\n+    }\n+\n+    public void testSetLength() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(\"Hello\");\n+        sb.setLength(2);  // shorten\n+        assertEquals(\"He\", sb.toString());\n+        sb.setLength(2);  // no change\n+        assertEquals(\"He\", sb.toString());\n+        sb.setLength(3);  // lengthen\n+        assertEquals(\"He\\0\", sb.toString());\n+\n+        try {\n+            sb.setLength(-1);\n+            fail(\"setLength(-1) expected StringIndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCapacity() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(sb.buffer.length, sb.capacity());\n+        \n+        sb.append(\"HelloWorldHelloWorldHelloWorldHelloWorld\");\n+        assertEquals(sb.buffer.length, sb.capacity());\n+    }\n+\n+    public void testEnsureCapacity() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.ensureCapacity(2);\n+        assertEquals(true, sb.capacity() >= 2);\n+        \n+        sb.ensureCapacity(-1);\n+        assertEquals(true, sb.capacity() >= 0);\n+        \n+        sb.append(\"HelloWorld\");\n+        sb.ensureCapacity(40);\n+        assertEquals(true, sb.capacity() >= 40);\n+    }\n+\n+    public void testMinimizeCapacity() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.minimizeCapacity();\n+        assertEquals(0, sb.capacity());\n+        \n+        sb.append(\"HelloWorld\");\n+        sb.minimizeCapacity();\n+        assertEquals(10, sb.capacity());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSize() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(0, sb.size());\n+        \n+        sb.append(\"Hello\");\n+        assertEquals(5, sb.size());\n+    }\n+\n+    public void testIsEmpty() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(true, sb.isEmpty());\n+        \n+        sb.append(\"Hello\");\n+        assertEquals(false, sb.isEmpty());\n+        \n+        sb.clear();\n+        assertEquals(true, sb.isEmpty());\n+    }\n+\n+    public void testClear() {\n+        StrBuilder sb = new StrBuilder();\n+        sb.append(\"Hello\");\n+        sb.clear();\n+        assertEquals(0, sb.length());\n+        assertEquals(true, sb.buffer.length >= 5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCharAt() {\n+        StrBuilder sb = new StrBuilder();\n+        try {\n+            sb.charAt(0);\n+            fail(\"charAt(0) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            sb.charAt(-1);\n+            fail(\"charAt(-1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        sb.append(\"foo\");\n+        assertEquals('f', sb.charAt(0));\n+        assertEquals('o', sb.charAt(1));\n+        assertEquals('o', sb.charAt(2));\n+        try {\n+            sb.charAt(-1);\n+            fail(\"charAt(-1) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            sb.charAt(3);\n+            fail(\"charAt(3) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSetCharAt() {\n+        StrBuilder sb = new StrBuilder();\n+        try {\n+            sb.setCharAt(0, 'f');\n+            fail(\"setCharAt(0,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            sb.setCharAt(-1, 'f');\n+            fail(\"setCharAt(-1,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        sb.append(\"foo\");\n+        sb.setCharAt(0, 'b');\n+        sb.setCharAt(1, 'a');\n+        sb.setCharAt(2, 'r');\n+        try {\n+            sb.setCharAt(3, '!');\n+            fail(\"setCharAt(3,) expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertEquals(\"bar\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDeleteCharAt() {\n+        StrBuilder sb = new StrBuilder(\"abc\");\n+        sb.deleteCharAt(0);\n+        assertEquals(\"bc\", sb.toString()); \n+        \n+        try {\n+            sb.deleteCharAt(1000);\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToCharArray() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray());\n+\n+        char[] a = sb.toCharArray();\n+        assertNotNull(\"toCharArray() result is null\", a);\n+        assertEquals(\"toCharArray() result is too large\", 0, a.length);\n+\n+        sb.append(\"junit\");\n+        a = sb.toCharArray();\n+        assertEquals(\"toCharArray() result incorrect length\", 5, a.length);\n+        assertTrue(\"toCharArray() result does not match\", Arrays.equals(\"junit\".toCharArray(), a));\n+    }\n+\n+    public void testToCharArrayIntInt() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray(0, 0));\n+\n+        sb.append(\"junit\");\n+        char[] a = sb.toCharArray(0, 20); // too large test\n+        assertEquals(\"toCharArray(int,int) result incorrect length\", 5, a.length);\n+        assertTrue(\"toCharArray(int,int) result does not match\", Arrays.equals(\"junit\".toCharArray(), a));\n+\n+        a = sb.toCharArray(0, 4);\n+        assertEquals(\"toCharArray(int,int) result incorrect length\", 4, a.length);\n+        assertTrue(\"toCharArray(int,int) result does not match\", Arrays.equals(\"juni\".toCharArray(), a));\n+\n+        a = sb.toCharArray(0, 4);\n+        assertEquals(\"toCharArray(int,int) result incorrect length\", 4, a.length);\n+        assertTrue(\"toCharArray(int,int) result does not match\", Arrays.equals(\"juni\".toCharArray(), a));\n+\n+        a = sb.toCharArray(0, 1);\n+        assertNotNull(\"toCharArray(int,int) result is null\", a);\n+\n+        try {\n+            sb.toCharArray(-1, 5);\n+            fail(\"no string index out of bound on -1\");\n+        } catch (IndexOutOfBoundsException e) {\n+        }\n+\n+        try {\n+            sb.toCharArray(6, 5);\n+            fail(\"no string index out of bound on -1\");\n+        } catch (IndexOutOfBoundsException e) {\n+        }\n+    }\n+\n+    public void testGetChars ( ) {\n+        StrBuilder sb = new StrBuilder();\n+        \n+        char[] input = new char[10];\n+        char[] a = sb.getChars(input);\n+        assertSame (input, a);\n+        assertTrue(Arrays.equals(new char[10], a));\n+        \n+        sb.append(\"junit\");\n+        a = sb.getChars(input);\n+        assertSame(input, a);\n+        assertTrue(Arrays.equals(new char[] {'j','u','n','i','t',0,0,0,0,0},a));\n+        \n+        a = sb.getChars(null);\n+        assertNotSame(input,a);\n+        assertEquals(5,a.length);\n+        assertTrue(Arrays.equals(\"junit\".toCharArray(),a));\n+        \n+        input = new char[5];\n+        a = sb.getChars(input);\n+        assertSame(input, a);\n+        \n+        input = new char[4];\n+        a = sb.getChars(input);\n+        assertNotSame(input, a);\n+    }\n+\n+    public void testGetCharsIntIntCharArrayInt( ) {\n+        StrBuilder sb = new StrBuilder();\n+               \n+        sb.append(\"junit\");\n+        char[] a = new char[5];\n+        sb.getChars(0,5,a,0);\n+        assertTrue(Arrays.equals(new char[] {'j','u','n','i','t'},a));\n+        \n+        a = new char[5];\n+        sb.getChars(0,2,a,3);\n+        assertTrue(Arrays.equals(new char[] {0,0,0,'j','u'},a));\n+        \n+        try {\n+            sb.getChars(-1,0,a,0);\n+            fail(\"no exception\");\n+        }\n+        catch (IndexOutOfBoundsException e) {\n+        }\n+        \n+        try {\n+            sb.getChars(0,-1,a,0);\n+            fail(\"no exception\");\n+        }\n+        catch (IndexOutOfBoundsException e) {\n+        }\n+        \n+        try {\n+            sb.getChars(0,20,a,0);\n+            fail(\"no exception\");\n+        }\n+        catch (IndexOutOfBoundsException e) {\n+        }\n+        \n+        try {\n+            sb.getChars(4,2,a,0);\n+            fail(\"no exception\");\n+        }\n+        catch (IndexOutOfBoundsException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDeleteIntInt() {\n+        StrBuilder sb = new StrBuilder(\"abc\");\n+        sb.delete(0, 1);\n+        assertEquals(\"bc\", sb.toString()); \n+        sb.delete(1, 2);\n+        assertEquals(\"b\", sb.toString());\n+        sb.delete(0, 1);\n+        assertEquals(\"\", sb.toString()); \n+        sb.delete(0, 1000);\n+        assertEquals(\"\", sb.toString()); \n+        \n+        try {\n+            sb.delete(1, 2);\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            sb.delete(-1, 1);\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        sb = new StrBuilder(\"anything\");\n+        try {\n+            sb.delete(2, 1);\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDeleteAll_char() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteAll('X');\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteAll('a');\n+        assertEquals(\"bcbccb\", sb.toString());\n+        sb.deleteAll('c');\n+        assertEquals(\"bbb\", sb.toString());\n+        sb.deleteAll('b');\n+        assertEquals(\"\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteAll('b');\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    public void testDeleteFirst_char() {\n+        StrBuilder sb = new StrBuilder(\"abcba\");\n+        sb.deleteFirst('X');\n+        assertEquals(\"abcba\", sb.toString());\n+        sb.deleteFirst('a');\n+        assertEquals(\"bcba\", sb.toString());\n+        sb.deleteFirst('c');\n+        assertEquals(\"bba\", sb.toString());\n+        sb.deleteFirst('b');\n+        assertEquals(\"ba\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteFirst('b');\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testDeleteAll_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteAll((String) null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteAll(\"\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.deleteAll(\"X\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteAll(\"a\");\n+        assertEquals(\"bcbccb\", sb.toString());\n+        sb.deleteAll(\"c\");\n+        assertEquals(\"bbb\", sb.toString());\n+        sb.deleteAll(\"b\");\n+        assertEquals(\"\", sb.toString());\n+\n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteAll(\"bc\");\n+        assertEquals(\"acba\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteAll(\"bc\");\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    public void testDeleteFirst_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteFirst((String) null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteFirst(\"\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+\n+        sb.deleteFirst(\"X\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.deleteFirst(\"a\");\n+        assertEquals(\"bcbccba\", sb.toString());\n+        sb.deleteFirst(\"c\");\n+        assertEquals(\"bbccba\", sb.toString());\n+        sb.deleteFirst(\"b\");\n+        assertEquals(\"bccba\", sb.toString());\n+\n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.deleteFirst(\"bc\");\n+        assertEquals(\"abccba\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteFirst(\"bc\");\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testDeleteAll_StrMatcher() {\n+        StrBuilder sb = new StrBuilder(\"A0xA1A2yA3\");\n+        sb.deleteAll((StrMatcher) null);\n+        assertEquals(\"A0xA1A2yA3\", sb.toString());\n+        sb.deleteAll(A_NUMBER_MATCHER);\n+        assertEquals(\"xy\", sb.toString());\n+\n+        sb = new StrBuilder(\"Ax1\");\n+        sb.deleteAll(A_NUMBER_MATCHER);\n+        assertEquals(\"Ax1\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteAll(A_NUMBER_MATCHER);\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    public void testDeleteFirst_StrMatcher() {\n+        StrBuilder sb = new StrBuilder(\"A0xA1A2yA3\");\n+        sb.deleteFirst((StrMatcher) null);\n+        assertEquals(\"A0xA1A2yA3\", sb.toString());\n+        sb.deleteFirst(A_NUMBER_MATCHER);\n+        assertEquals(\"xA1A2yA3\", sb.toString());\n+\n+        sb = new StrBuilder(\"Ax1\");\n+        sb.deleteFirst(A_NUMBER_MATCHER);\n+        assertEquals(\"Ax1\", sb.toString());\n+\n+        sb = new StrBuilder(\"\");\n+        sb.deleteFirst(A_NUMBER_MATCHER);\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testReplace_int_int_String() {\n+        StrBuilder sb = new StrBuilder(\"abc\");\n+        sb.replace(0, 1, \"d\");\n+        assertEquals(\"dbc\", sb.toString());\n+        sb.replace(0, 1, \"aaa\");\n+        assertEquals(\"aaabc\", sb.toString());\n+        sb.replace(0, 3, \"\");\n+        assertEquals(\"bc\", sb.toString());\n+        sb.replace(1, 2, (String) null);\n+        assertEquals(\"b\", sb.toString());\n+        sb.replace(1, 1000, \"text\");\n+        assertEquals(\"btext\", sb.toString());\n+        sb.replace(0, 1000, \"text\");\n+        assertEquals(\"text\", sb.toString());\n+        \n+        sb = new StrBuilder(\"atext\");\n+        sb.replace(1, 1, \"ny\");\n+        assertEquals(\"anytext\", sb.toString());\n+        try {\n+            sb.replace(2, 1, \"anything\");\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        sb = new StrBuilder();\n+        try {\n+            sb.replace(1, 2, \"anything\");\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+        try {\n+            sb.replace(-1, 1, \"anything\");\n+            fail(\"Expected IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplaceAll_char_char() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceAll('x', 'y');\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll('a', 'd');\n+        assertEquals(\"dbcbccbd\", sb.toString());\n+        sb.replaceAll('b', 'e');\n+        assertEquals(\"dececced\", sb.toString());\n+        sb.replaceAll('c', 'f');\n+        assertEquals(\"defeffed\", sb.toString());\n+        sb.replaceAll('d', 'd');\n+        assertEquals(\"defeffed\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplaceFirst_char_char() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceFirst('x', 'y');\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst('a', 'd');\n+        assertEquals(\"dbcbccba\", sb.toString());\n+        sb.replaceFirst('b', 'e');\n+        assertEquals(\"decbccba\", sb.toString());\n+        sb.replaceFirst('c', 'f');\n+        assertEquals(\"defbccba\", sb.toString());\n+        sb.replaceFirst('d', 'd');\n+        assertEquals(\"defbccba\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplaceAll_String_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceAll((String) null, null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll((String) null, \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(\"\", null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(\"\", \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replaceAll(\"x\", \"y\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(\"a\", \"d\");\n+        assertEquals(\"dbcbccbd\", sb.toString());\n+        sb.replaceAll(\"d\", null);\n+        assertEquals(\"bcbccb\", sb.toString());\n+        sb.replaceAll(\"cb\", \"-\");\n+        assertEquals(\"b-c-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcba\");\n+        sb.replaceAll(\"b\", \"xbx\");\n+        assertEquals(\"axbxcxbxa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"bb\");\n+        sb.replaceAll(\"b\", \"xbx\");\n+        assertEquals(\"xbxxbx\", sb.toString());\n+    }\n+\n+    public void testReplaceFirst_String_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceFirst((String) null, null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst((String) null, \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(\"\", null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(\"\", \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replaceFirst(\"x\", \"y\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(\"a\", \"d\");\n+        assertEquals(\"dbcbccba\", sb.toString());\n+        sb.replaceFirst(\"d\", null);\n+        assertEquals(\"bcbccba\", sb.toString());\n+        sb.replaceFirst(\"cb\", \"-\");\n+        assertEquals(\"b-ccba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcba\");\n+        sb.replaceFirst(\"b\", \"xbx\");\n+        assertEquals(\"axbxcba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"bb\");\n+        sb.replaceFirst(\"b\", \"xbx\");\n+        assertEquals(\"xbxb\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplaceAll_StrMatcher_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceAll((StrMatcher) null, null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll((StrMatcher) null, \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(StrMatcher.noneMatcher(), null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(StrMatcher.noneMatcher(), \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replaceAll(StrMatcher.charMatcher('x'), \"y\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceAll(StrMatcher.charMatcher('a'), \"d\");\n+        assertEquals(\"dbcbccbd\", sb.toString());\n+        sb.replaceAll(StrMatcher.charMatcher('d'), null);\n+        assertEquals(\"bcbccb\", sb.toString());\n+        sb.replaceAll(StrMatcher.stringMatcher(\"cb\"), \"-\");\n+        assertEquals(\"b-c-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcba\");\n+        sb.replaceAll(StrMatcher.charMatcher('b'), \"xbx\");\n+        assertEquals(\"axbxcxbxa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"bb\");\n+        sb.replaceAll(StrMatcher.charMatcher('b'), \"xbx\");\n+        assertEquals(\"xbxxbx\", sb.toString());\n+        \n+        sb = new StrBuilder(\"A1-A2A3-A4\");\n+        sb.replaceAll(A_NUMBER_MATCHER, \"***\");\n+        assertEquals(\"***-******-***\", sb.toString());\n+    }\n+\n+    public void testReplaceFirst_StrMatcher_String() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replaceFirst((StrMatcher) null, null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst((StrMatcher) null, \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.noneMatcher(), null);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.noneMatcher(), \"anything\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replaceFirst(StrMatcher.charMatcher('x'), \"y\");\n+        assertEquals(\"abcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.charMatcher('a'), \"d\");\n+        assertEquals(\"dbcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.charMatcher('d'), null);\n+        assertEquals(\"bcbccba\", sb.toString());\n+        sb.replaceFirst(StrMatcher.stringMatcher(\"cb\"), \"-\");\n+        assertEquals(\"b-ccba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcba\");\n+        sb.replaceFirst(StrMatcher.charMatcher('b'), \"xbx\");\n+        assertEquals(\"axbxcba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"bb\");\n+        sb.replaceFirst(StrMatcher.charMatcher('b'), \"xbx\");\n+        assertEquals(\"xbxb\", sb.toString());\n+        \n+        sb = new StrBuilder(\"A1-A2A3-A4\");\n+        sb.replaceFirst(A_NUMBER_MATCHER, \"***\");\n+        assertEquals(\"***-A2A3-A4\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReplace_StrMatcher_String_int_int_int_VaryMatcher() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replace((StrMatcher) null, \"x\", 0, sb.length(), -1);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb.replace(StrMatcher.charMatcher('a'), \"x\", 0, sb.length(), -1);\n+        assertEquals(\"xbcbccbx\", sb.toString());\n+        \n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"x\", 0, sb.length(), -1);\n+        assertEquals(\"xbxcxx\", sb.toString());\n+        \n+        sb = new StrBuilder(\"A1-A2A3-A4\");\n+        sb.replace(A_NUMBER_MATCHER, \"***\", 0, sb.length(), -1);\n+        assertEquals(\"***-******-***\", sb.toString());\n+        \n+        sb = new StrBuilder();\n+        sb.replace(A_NUMBER_MATCHER, \"***\", 0, sb.length(), -1);\n+        assertEquals(\"\", sb.toString());\n+    }\n+\n+    public void testReplace_StrMatcher_String_int_int_int_VaryReplace() {\n+        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"cb\", 0, sb.length(), -1);\n+        assertEquals(\"abcbccba\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"-\", 0, sb.length(), -1);\n+        assertEquals(\"ab-c-a\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"+++\", 0, sb.length(), -1);\n+        assertEquals(\"ab+++c+++a\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), \"\", 0, sb.length(), -1);\n+        assertEquals(\"abca\", sb.toString());\n+        \n+        sb = new StrBuilder(\"abcbccba\");\n+        sb.replace(StrMatcher.stringMatcher(\"cb\"), null, 0, sb.length(), -1);\n+        assertEquals(\"abca\", sb.toString());\n+    }\n+\n+    public void testReplace_StrMatcher_String_int_int_int_VaryStartIndex() {\n+        StrBuilder sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, sb.length(), -1);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 1, sb.length(), -1);\n+        assertEquals(\"aax--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 2, sb.length(), -1);\n+        assertEquals(\"aax--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 3, sb.length(), -1);\n+        assertEquals(\"aax--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 4, sb.length(), -1);\n+        assertEquals(\"aaxa-ay-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 5, sb.length(), -1);\n+        assertEquals(\"aaxaa-y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 6, sb.length(), -1);\n+        assertEquals(\"aaxaaaay-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 7, sb.length(), -1);\n+        assertEquals(\"aaxaaaay-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 8, sb.length(), -1);\n+        assertEquals(\"aaxaaaay-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 9, sb.length(), -1);\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 10, sb.length(), -1);\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        try {\n+            sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 11, sb.length(), -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        try {\n+            sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", -1, sb.length(), -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+    }\n+\n+    public void testReplace_StrMatcher_String_int_int_int_VaryEndIndex() {\n+        StrBuilder sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 0, -1);\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 2, -1);\n+        assertEquals(\"-xaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 3, -1);\n+        assertEquals(\"-xaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 4, -1);\n+        assertEquals(\"-xaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 5, -1);\n+        assertEquals(\"-x-aayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 6, -1);\n+        assertEquals(\"-x-aayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 7, -1);\n+        assertEquals(\"-x--yaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 8, -1);\n+        assertEquals(\"-x--yaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 9, -1);\n+        assertEquals(\"-x--yaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, -1);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 1000, -1);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        try {\n+            sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 2, 1, -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+    }\n+\n+    public void testReplace_StrMatcher_String_int_int_int_VaryCount() {\n+        StrBuilder sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, -1);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 0);\n+        assertEquals(\"aaxaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 1);\n+        assertEquals(\"-xaaaayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 2);\n+        assertEquals(\"-x-aayaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 3);\n+        assertEquals(\"-x--yaa\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 4);\n+        assertEquals(\"-x--y-\", sb.toString());\n+        \n+        sb = new StrBuilder(\"aaxaaaayaa\");\n+        sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 0, 10, 5);\n+        assertEquals(\"-x--y-\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReverse() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(\"\", sb.reverse().toString());\n+        \n+        sb.clear().append(true);\n+        assertEquals(\"eurt\", sb.reverse().toString());\n+        assertEquals(\"true\", sb.reverse().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTrim() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(\"\", sb.reverse().toString());\n+        \n+        sb.clear().append(\" \\u0000 \");\n+        assertEquals(\"\", sb.trim().toString());\n+        \n+        sb.clear().append(\" \\u0000 a b c\");\n+        assertEquals(\"a b c\", sb.trim().toString());\n+        \n+        sb.clear().append(\"a b c \\u0000 \");\n+        assertEquals(\"a b c\", sb.trim().toString());\n+        \n+        sb.clear().append(\" \\u0000 a b c \\u0000 \");\n+        assertEquals(\"a b c\", sb.trim().toString());\n+        \n+        sb.clear().append(\"a b c\");\n+        assertEquals(\"a b c\", sb.trim().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStartsWith() {\n+        StrBuilder sb = new StrBuilder();\n+        assertFalse(sb.startsWith(\"a\"));\n+        assertFalse(sb.startsWith(null));\n+        assertTrue(sb.startsWith(\"\"));\n+        sb.append(\"abc\");\n+        assertTrue(sb.startsWith(\"a\"));\n+        assertTrue(sb.startsWith(\"ab\"));\n+        assertTrue(sb.startsWith(\"abc\"));\n+        assertFalse(sb.startsWith(\"cba\"));\n+    }\n+\n+    public void testEndsWith() {\n+        StrBuilder sb = new StrBuilder();\n+        assertFalse(sb.endsWith(\"a\"));\n+        assertFalse(sb.endsWith(\"c\"));\n+        assertTrue(sb.endsWith(\"\"));\n+        assertFalse(sb.endsWith(null));\n+        sb.append(\"abc\");\n+        assertTrue(sb.endsWith(\"c\"));\n+        assertTrue(sb.endsWith(\"bc\"));\n+        assertTrue(sb.endsWith(\"abc\"));\n+        assertFalse(sb.endsWith(\"cba\"));\n+        assertFalse(sb.endsWith(\"abcd\"));\n+        assertFalse(sb.endsWith(\" abc\"));\n+        assertFalse(sb.endsWith(\"abc \"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSubstringInt() {\n+        StrBuilder sb = new StrBuilder (\"hello goodbye\");\n+        assertEquals (\"goodbye\", sb.substring(6));\n+        assertEquals (\"hello goodbye\".substring(6), sb.substring(6));\n+        assertEquals (\"hello goodbye\", sb.substring(0));\n+        assertEquals (\"hello goodbye\".substring(0), sb.substring(0));\n+        try {\n+            sb.substring(-1);\n+            fail ();\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        try {\n+            sb.substring(15);\n+            fail ();\n+        } catch (IndexOutOfBoundsException e) {}\n+    \n+    }\n+    \n+    public void testSubstringIntInt() {\n+        StrBuilder sb = new StrBuilder (\"hello goodbye\");\n+        assertEquals (\"hello\", sb.substring(0, 5));\n+        assertEquals (\"hello goodbye\".substring(0, 6), sb.substring(0, 6));\n+        \n+        assertEquals (\"goodbye\", sb.substring(6, 13));\n+        assertEquals (\"hello goodbye\".substring(6,13), sb.substring(6, 13));\n+        \n+        assertEquals (\"goodbye\", sb.substring(6, 20));\n+        \n+        try {\n+            sb.substring(-1, 5);\n+            fail();\n+        } catch (IndexOutOfBoundsException e) {}\n+        \n+        try {\n+            sb.substring(15, 20);\n+            fail();\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testMidString() {\n+        StrBuilder sb = new StrBuilder(\"hello goodbye hello\");\n+        assertEquals(\"goodbye\", sb.midString(6, 7));\n+        assertEquals(\"hello\", sb.midString(0, 5));\n+        assertEquals(\"hello\", sb.midString(-5, 5));\n+        assertEquals(\"\", sb.midString(0, -1));\n+        assertEquals(\"\", sb.midString(20, 2));\n+        assertEquals(\"hello\", sb.midString(14, 22));\n+    }\n+\n+    public void testRightString() {\n+        StrBuilder sb = new StrBuilder(\"left right\");\n+        assertEquals(\"right\", sb.rightString(5));\n+        assertEquals(\"\", sb.rightString(0));\n+        assertEquals(\"\", sb.rightString(-5));\n+        assertEquals(\"left right\", sb.rightString(15));\n+    }\n+\n+    public void testLeftString() {\n+        StrBuilder sb = new StrBuilder(\"left right\");\n+        assertEquals(\"left\", sb.leftString(4));\n+        assertEquals(\"\", sb.leftString(0));\n+        assertEquals(\"\", sb.leftString(-5));\n+        assertEquals(\"left right\", sb.leftString(15));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testContains_char() {\n+        StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        assertEquals(true, sb.contains('a'));\n+        assertEquals(true, sb.contains('o'));\n+        assertEquals(true, sb.contains('z'));\n+        assertEquals(false, sb.contains('1'));\n+    }\n+\n+    public void testContains_String() {\n+        StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        assertEquals(true, sb.contains(\"a\"));\n+        assertEquals(true, sb.contains(\"pq\"));\n+        assertEquals(true, sb.contains(\"z\"));\n+        assertEquals(false, sb.contains(\"zyx\"));\n+        assertEquals(false, sb.contains((String) null));\n+    }\n+\n+    public void testContains_StrMatcher() {\n+        StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        assertEquals(true, sb.contains(StrMatcher.charMatcher('a')));\n+        assertEquals(true, sb.contains(StrMatcher.stringMatcher(\"pq\")));\n+        assertEquals(true, sb.contains(StrMatcher.charMatcher('z')));\n+        assertEquals(false, sb.contains(StrMatcher.stringMatcher(\"zy\")));\n+        assertEquals(false, sb.contains((StrMatcher) null));\n+\n+        sb = new StrBuilder();\n+        assertEquals(false, sb.contains(A_NUMBER_MATCHER));\n+        sb.append(\"B A1 C\");\n+        assertEquals(true, sb.contains(A_NUMBER_MATCHER));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testIndexOf_char() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(0, sb.indexOf('a'));\n+        \n+        // should work like String#indexOf\n+        assertEquals(\"abab\".indexOf('a'), sb.indexOf('a'));\n+\n+        assertEquals(1, sb.indexOf('b'));\n+        assertEquals(\"abab\".indexOf('b'), sb.indexOf('b'));\n+\n+        assertEquals(-1, sb.indexOf('z'));\n+    }\n+\n+    public void testIndexOf_char_int() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(0, sb.indexOf('a', -1));\n+        assertEquals(0, sb.indexOf('a', 0));\n+        assertEquals(2, sb.indexOf('a', 1));\n+        assertEquals(-1, sb.indexOf('a', 4));\n+        assertEquals(-1, sb.indexOf('a', 5));\n+\n+        // should work like String#indexOf\n+        assertEquals(\"abab\".indexOf('a', 1), sb.indexOf('a', 1));\n+\n+        assertEquals(3, sb.indexOf('b', 2));\n+        assertEquals(\"abab\".indexOf('b', 2), sb.indexOf('b', 2));\n+\n+        assertEquals(-1, sb.indexOf('z', 2));\n+\n+        sb = new StrBuilder(\"xyzabc\");\n+        assertEquals(2, sb.indexOf('z', 0));\n+        assertEquals(-1, sb.indexOf('z', 3));\n+    }\n+\n+    public void testLastIndexOf_char() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        \n+        assertEquals (2, sb.lastIndexOf('a'));\n+        //should work like String#lastIndexOf\n+        assertEquals (\"abab\".lastIndexOf('a'), sb.lastIndexOf('a'));\n+        \n+        assertEquals(3, sb.lastIndexOf('b'));\n+        assertEquals (\"abab\".lastIndexOf('b'), sb.lastIndexOf('b'));\n+        \n+        assertEquals (-1, sb.lastIndexOf('z'));\n+    }\n+\n+    public void testLastIndexOf_char_int() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(-1, sb.lastIndexOf('a', -1));\n+        assertEquals(0, sb.lastIndexOf('a', 0));\n+        assertEquals(0, sb.lastIndexOf('a', 1));\n+\n+        // should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf('a', 1), sb.lastIndexOf('a', 1));\n+\n+        assertEquals(1, sb.lastIndexOf('b', 2));\n+        assertEquals(\"abab\".lastIndexOf('b', 2), sb.lastIndexOf('b', 2));\n+\n+        assertEquals(-1, sb.lastIndexOf('z', 2));\n+\n+        sb = new StrBuilder(\"xyzabc\");\n+        assertEquals(2, sb.lastIndexOf('z', sb.length()));\n+        assertEquals(-1, sb.lastIndexOf('z', 1));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testIndexOf_String() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        \n+        assertEquals(0, sb.indexOf(\"a\"));\n+        //should work like String#indexOf\n+        assertEquals(\"abab\".indexOf(\"a\"), sb.indexOf(\"a\"));\n+        \n+        assertEquals(0, sb.indexOf(\"ab\"));\n+        //should work like String#indexOf\n+        assertEquals(\"abab\".indexOf(\"ab\"), sb.indexOf(\"ab\"));\n+        \n+        assertEquals(1, sb.indexOf(\"b\"));\n+        assertEquals(\"abab\".indexOf(\"b\"), sb.indexOf(\"b\"));\n+        \n+        assertEquals(1, sb.indexOf(\"ba\"));\n+        assertEquals(\"abab\".indexOf(\"ba\"), sb.indexOf(\"ba\"));\n+        \n+        assertEquals(-1, sb.indexOf(\"z\"));\n+        \n+        assertEquals(-1, sb.indexOf((String) null));\n+    }\n+\n+    public void testIndexOf_String_int() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(0, sb.indexOf(\"a\", -1));\n+        assertEquals(0, sb.indexOf(\"a\", 0));\n+        assertEquals(2, sb.indexOf(\"a\", 1));\n+        assertEquals(2, sb.indexOf(\"a\", 2));\n+        assertEquals(-1, sb.indexOf(\"a\", 3));\n+        assertEquals(-1, sb.indexOf(\"a\", 4));\n+        assertEquals(-1, sb.indexOf(\"a\", 5));\n+        \n+        assertEquals(-1, sb.indexOf(\"abcdef\", 0));\n+        assertEquals(0, sb.indexOf(\"\", 0));\n+        assertEquals(1, sb.indexOf(\"\", 1));\n+        \n+        //should work like String#indexOf\n+        assertEquals (\"abab\".indexOf(\"a\", 1), sb.indexOf(\"a\", 1));\n+        \n+        assertEquals(2, sb.indexOf(\"ab\", 1));\n+        //should work like String#indexOf\n+        assertEquals(\"abab\".indexOf(\"ab\", 1), sb.indexOf(\"ab\", 1));\n+        \n+        assertEquals(3, sb.indexOf(\"b\", 2));\n+        assertEquals(\"abab\".indexOf(\"b\", 2), sb.indexOf(\"b\", 2));\n+        \n+        assertEquals(1, sb.indexOf(\"ba\", 1));\n+        assertEquals(\"abab\".indexOf(\"ba\", 2), sb.indexOf(\"ba\", 2));\n+        \n+        assertEquals(-1, sb.indexOf(\"z\", 2));\n+        \n+        sb = new StrBuilder(\"xyzabc\");\n+        assertEquals(2, sb.indexOf(\"za\", 0));\n+        assertEquals(-1, sb.indexOf(\"za\", 3));\n+        \n+        assertEquals(-1, sb.indexOf((String) null, 2));\n+    }\n+\n+    public void testLastIndexOf_String() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        \n+        assertEquals(2, sb.lastIndexOf(\"a\"));\n+        //should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf(\"a\"), sb.lastIndexOf(\"a\"));\n+        \n+        assertEquals(2, sb.lastIndexOf(\"ab\"));\n+        //should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf(\"ab\"), sb.lastIndexOf(\"ab\"));\n+        \n+        assertEquals(3, sb.lastIndexOf(\"b\"));\n+        assertEquals(\"abab\".lastIndexOf(\"b\"), sb.lastIndexOf(\"b\"));\n+        \n+        assertEquals(1, sb.lastIndexOf(\"ba\"));\n+        assertEquals(\"abab\".lastIndexOf(\"ba\"), sb.lastIndexOf(\"ba\"));\n+        \n+        assertEquals(-1, sb.lastIndexOf(\"z\"));\n+        \n+        assertEquals(-1, sb.lastIndexOf((String) null));\n+    }\n+\n+    public void testLastIndexOf_String_int() {\n+        StrBuilder sb = new StrBuilder(\"abab\");\n+        assertEquals(-1, sb.lastIndexOf(\"a\", -1));\n+        assertEquals(0, sb.lastIndexOf(\"a\", 0));\n+        assertEquals(0, sb.lastIndexOf(\"a\", 1));\n+        assertEquals(2, sb.lastIndexOf(\"a\", 2));\n+        assertEquals(2, sb.lastIndexOf(\"a\", 3));\n+        assertEquals(2, sb.lastIndexOf(\"a\", 4));\n+        assertEquals(2, sb.lastIndexOf(\"a\", 5));\n+        \n+        assertEquals(-1, sb.lastIndexOf(\"abcdef\", 3));\n+        assertEquals(\"abab\".lastIndexOf(\"\", 3), sb.lastIndexOf(\"\", 3));\n+        assertEquals(\"abab\".lastIndexOf(\"\", 1), sb.lastIndexOf(\"\", 1));\n+        \n+        //should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf(\"a\", 1), sb.lastIndexOf(\"a\", 1));\n+        \n+        assertEquals(0, sb.lastIndexOf(\"ab\", 1));\n+        //should work like String#lastIndexOf\n+        assertEquals(\"abab\".lastIndexOf(\"ab\", 1), sb.lastIndexOf(\"ab\", 1));\n+        \n+        assertEquals(1, sb.lastIndexOf(\"b\", 2));\n+        assertEquals(\"abab\".lastIndexOf(\"b\", 2), sb.lastIndexOf(\"b\", 2));\n+        \n+        assertEquals(1, sb.lastIndexOf(\"ba\", 2));\n+        assertEquals(\"abab\".lastIndexOf(\"ba\", 2), sb.lastIndexOf(\"ba\", 2));\n+        \n+        assertEquals(-1, sb.lastIndexOf(\"z\", 2));\n+        \n+        sb = new StrBuilder(\"xyzabc\");\n+        assertEquals(2, sb.lastIndexOf(\"za\", sb.length()));\n+        assertEquals(-1, sb.lastIndexOf(\"za\", 1));\n+        \n+        assertEquals(-1, sb.lastIndexOf((String) null, 2));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testIndexOf_StrMatcher() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(-1, sb.indexOf((StrMatcher) null));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a')));\n+        \n+        sb.append(\"ab bd\");\n+        assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a')));\n+        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b')));\n+        assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher()));\n+        assertEquals(4, sb.indexOf(StrMatcher.charMatcher('d')));\n+        assertEquals(-1, sb.indexOf(StrMatcher.noneMatcher()));\n+        assertEquals(-1, sb.indexOf((StrMatcher) null));\n+        \n+        sb.append(\" A1 junction\");\n+        assertEquals(6, sb.indexOf(A_NUMBER_MATCHER));\n+    }\n+\n+    public void testIndexOf_StrMatcher_int() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(-1, sb.indexOf((StrMatcher) null, 2));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 0));\n+        \n+        sb.append(\"ab bd\");\n+        assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), -2));\n+        assertEquals(0, sb.indexOf(StrMatcher.charMatcher('a'), 0));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 20));\n+        \n+        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), -1));\n+        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 0));\n+        assertEquals(1, sb.indexOf(StrMatcher.charMatcher('b'), 1));\n+        assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 2));\n+        assertEquals(3, sb.indexOf(StrMatcher.charMatcher('b'), 3));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 4));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 5));\n+        assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('b'), 6));\n+        \n+        assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), -2));\n+        assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), 0));\n+        assertEquals(2, sb.indexOf(StrMatcher.spaceMatcher(), 2));\n+        assertEquals(-1, sb.indexOf(StrMatcher.spaceMatcher(), 4));\n+        assertEquals(-1, sb.indexOf(StrMatcher.spaceMatcher(), 20));\n+        \n+        assertEquals(-1, sb.indexOf(StrMatcher.noneMatcher(), 0));\n+        assertEquals(-1, sb.indexOf((StrMatcher) null, 0));\n+        \n+        sb.append(\" A1 junction with A2\");\n+        assertEquals(6, sb.indexOf(A_NUMBER_MATCHER, 5));\n+        assertEquals(6, sb.indexOf(A_NUMBER_MATCHER, 6));\n+        assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 7));\n+        assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 22));\n+        assertEquals(23, sb.indexOf(A_NUMBER_MATCHER, 23));\n+        assertEquals(-1, sb.indexOf(A_NUMBER_MATCHER, 24));\n+    }\n+\n+    public void testLastIndexOf_StrMatcher() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(-1, sb.lastIndexOf((StrMatcher) null));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a')));\n+        \n+        sb.append(\"ab bd\");\n+        assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a')));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b')));\n+        assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher()));\n+        assertEquals(4, sb.lastIndexOf(StrMatcher.charMatcher('d')));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.noneMatcher()));\n+        assertEquals(-1, sb.lastIndexOf((StrMatcher) null));\n+        \n+        sb.append(\" A1 junction\");\n+        assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER));\n+    }\n+\n+    public void testLastIndexOf_StrMatcher_int() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 2));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), -1));\n+        \n+        sb.append(\"ab bd\");\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), -2));\n+        assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0));\n+        assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2));\n+        assertEquals(0, sb.lastIndexOf(StrMatcher.charMatcher('a'), 20));\n+        \n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('b'), -1));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 0));\n+        assertEquals(1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 1));\n+        assertEquals(1, sb.lastIndexOf(StrMatcher.charMatcher('b'), 2));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 3));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 4));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 5));\n+        assertEquals(3, sb.lastIndexOf(StrMatcher.charMatcher('b'), 6));\n+        \n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.spaceMatcher(), -2));\n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.spaceMatcher(), 0));\n+        assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 2));\n+        assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 4));\n+        assertEquals(2, sb.lastIndexOf(StrMatcher.spaceMatcher(), 20));\n+        \n+        assertEquals(-1, sb.lastIndexOf(StrMatcher.noneMatcher(), 0));\n+        assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 0));\n+        \n+        sb.append(\" A1 junction with A2\");\n+        assertEquals(-1, sb.lastIndexOf(A_NUMBER_MATCHER, 5));\n+        assertEquals(-1, sb.lastIndexOf(A_NUMBER_MATCHER, 6)); // A matches, 1 is outside bounds\n+        assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 7));\n+        assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 22));\n+        assertEquals(6, sb.lastIndexOf(A_NUMBER_MATCHER, 23)); // A matches, 2 is outside bounds\n+        assertEquals(23, sb.lastIndexOf(A_NUMBER_MATCHER, 24));\n+    }\n+\n+    static final StrMatcher A_NUMBER_MATCHER = new StrMatcher() {\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            if (buffer[pos] == 'A') {\n+                pos++;\n+                if (pos < bufferEnd && buffer[pos] >= '0' && buffer[pos] <= '9') {\n+                    return 2;\n+                }\n+            }\n+            return 0;\n+        }\n+    };\n+\n+    //-----------------------------------------------------------------------\n+    public void testAsTokenizer() throws Exception {\n+        // from Javadoc\n+        StrBuilder b = new StrBuilder();\n+        b.append(\"a b \");\n+        StrTokenizer t = b.asTokenizer();\n+        \n+        String[] tokens1 = t.getTokenArray();\n+        assertEquals(2, tokens1.length);\n+        assertEquals(\"a\", tokens1[0]);\n+        assertEquals(\"b\", tokens1[1]);\n+        assertEquals(2, t.size());\n+        \n+        b.append(\"c d \");\n+        String[] tokens2 = t.getTokenArray();\n+        assertEquals(2, tokens2.length);\n+        assertEquals(\"a\", tokens2[0]);\n+        assertEquals(\"b\", tokens2[1]);\n+        assertEquals(2, t.size());\n+        assertEquals(\"a\", t.next());\n+        assertEquals(\"b\", t.next());\n+        \n+        t.reset();\n+        String[] tokens3 = t.getTokenArray();\n+        assertEquals(4, tokens3.length);\n+        assertEquals(\"a\", tokens3[0]);\n+        assertEquals(\"b\", tokens3[1]);\n+        assertEquals(\"c\", tokens3[2]);\n+        assertEquals(\"d\", tokens3[3]);\n+        assertEquals(4, t.size());\n+        assertEquals(\"a\", t.next());\n+        assertEquals(\"b\", t.next());\n+        assertEquals(\"c\", t.next());\n+        assertEquals(\"d\", t.next());\n+        \n+        assertEquals(\"a b c d \", t.getContent());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testAsReader() throws Exception {\n+        StrBuilder sb = new StrBuilder(\"some text\");\n+        Reader reader = sb.asReader();\n+        assertEquals(true, reader.ready());\n+        char[] buf = new char[40];\n+        assertEquals(9, reader.read(buf));\n+        assertEquals(\"some text\", new String(buf, 0, 9));\n+        \n+        assertEquals(-1, reader.read());\n+        assertEquals(false, reader.ready());\n+        assertEquals(0, reader.skip(2));\n+        assertEquals(0, reader.skip(-1));\n+        \n+        assertEquals(true, reader.markSupported());\n+        reader = sb.asReader();\n+        assertEquals('s', reader.read());\n+        reader.mark(-1);\n+        char[] array = new char[3];\n+        assertEquals(3, reader.read(array, 0, 3));\n+        assertEquals('o', array[0]);\n+        assertEquals('m', array[1]);\n+        assertEquals('e', array[2]);\n+        reader.reset();\n+        assertEquals(1, reader.read(array, 1, 1));\n+        assertEquals('o', array[0]);\n+        assertEquals('o', array[1]);\n+        assertEquals('e', array[2]);\n+        assertEquals(2, reader.skip(2));\n+        assertEquals(' ', reader.read());\n+        \n+        assertEquals(true, reader.ready());\n+        reader.close();\n+        assertEquals(true, reader.ready());\n+        \n+        reader = sb.asReader();\n+        array = new char[3];\n+        try {\n+            reader.read(array, -1, 0);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 0, -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 100, 1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 0, 100);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        assertEquals(0, reader.read(array, 0, 0));\n+        assertEquals(0, array[0]);\n+        assertEquals(0, array[1]);\n+        assertEquals(0, array[2]);\n+        \n+        reader.skip(9);\n+        assertEquals(-1, reader.read(array, 0, 1));\n+        \n+        reader.reset();\n+        array = new char[30];\n+        assertEquals(9, reader.read(array, 0, 30));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAsWriter() throws Exception {\n+        StrBuilder sb = new StrBuilder(\"base\");\n+        Writer writer = sb.asWriter();\n+        \n+        writer.write('l');\n+        assertEquals(\"basel\", sb.toString());\n+        \n+        writer.write(new char[] {'i', 'n'});\n+        assertEquals(\"baselin\", sb.toString());\n+        \n+        writer.write(new char[] {'n', 'e', 'r'}, 1, 2);\n+        assertEquals(\"baseliner\", sb.toString());\n+        \n+        writer.write(\" rout\");\n+        assertEquals(\"baseliner rout\", sb.toString());\n+        \n+        writer.write(\"ping that server\", 1, 3);\n+        assertEquals(\"baseliner routing\", sb.toString());\n+        \n+        writer.flush();  // no effect\n+        assertEquals(\"baseliner routing\", sb.toString());\n+        \n+        writer.close();  // no effect\n+        assertEquals(\"baseliner routing\", sb.toString());\n+        \n+        writer.write(\" hi\");  // works after close\n+        assertEquals(\"baseliner routing hi\", sb.toString());\n+        \n+        sb.setLength(4);  // mix and match\n+        writer.write('d');\n+        assertEquals(\"based\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEqualsIgnoreCase() {\n+        StrBuilder sb1 = new StrBuilder();\n+        StrBuilder sb2 = new StrBuilder();\n+        assertEquals(true, sb1.equalsIgnoreCase(sb1));\n+        assertEquals(true, sb1.equalsIgnoreCase(sb2));\n+        assertEquals(true, sb2.equalsIgnoreCase(sb2));\n+        \n+        sb1.append(\"abc\");\n+        assertEquals(false, sb1.equalsIgnoreCase(sb2));\n+        \n+        sb2.append(\"ABC\");\n+        assertEquals(true, sb1.equalsIgnoreCase(sb2));\n+        \n+        sb2.clear().append(\"abc\");\n+        assertEquals(true, sb1.equalsIgnoreCase(sb2));\n+        assertEquals(true, sb1.equalsIgnoreCase(sb1));\n+        assertEquals(true, sb2.equalsIgnoreCase(sb2));\n+        \n+        sb2.clear().append(\"aBc\");\n+        assertEquals(true, sb1.equalsIgnoreCase(sb2));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquals() {\n+        StrBuilder sb1 = new StrBuilder();\n+        StrBuilder sb2 = new StrBuilder();\n+        assertEquals(true, sb1.equals(sb2));\n+        assertEquals(true, sb1.equals(sb1));\n+        assertEquals(true, sb2.equals(sb2));\n+        assertEquals(true, sb1.equals((Object) sb2));\n+        \n+        sb1.append(\"abc\");\n+        assertEquals(false, sb1.equals(sb2));\n+        assertEquals(false, sb1.equals((Object) sb2));\n+        \n+        sb2.append(\"ABC\");\n+        assertEquals(false, sb1.equals(sb2));\n+        assertEquals(false, sb1.equals((Object) sb2));\n+        \n+        sb2.clear().append(\"abc\");\n+        assertEquals(true, sb1.equals(sb2));\n+        assertEquals(true, sb1.equals((Object) sb2));\n+        \n+        assertEquals(false, sb1.equals(new Integer(1)));\n+        assertEquals(false, sb1.equals(\"abc\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testHashCode() {\n+        StrBuilder sb = new StrBuilder();\n+        int hc1a = sb.hashCode();\n+        int hc1b = sb.hashCode();\n+        assertEquals(0, hc1a);\n+        assertEquals(hc1a, hc1b);\n+        \n+        sb.append(\"abc\");\n+        int hc2a = sb.hashCode();\n+        int hc2b = sb.hashCode();\n+        assertEquals(true, hc2a != 0);\n+        assertEquals(hc2a, hc2b);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        StrBuilder sb = new StrBuilder(\"abc\");\n+        assertEquals(\"abc\", sb.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToStringBuffer() {\n+        StrBuilder sb = new StrBuilder();\n+        assertEquals(new StringBuffer().toString(), sb.toStringBuffer().toString());\n+        \n+        sb.append(\"junit\");\n+        assertEquals(new StringBuffer(\"junit\").toString(), sb.toStringBuffer().toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/text/StrLookupTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test class for StrLookup.\n+ *\n+ * @version $Id$\n+ */\n+public class StrLookupTest extends TestCase {\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrLookupTest.class);\n+        suite.setName(\"StrLookup Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoneLookup() {\n+        assertEquals(null, StrLookup.noneLookup().lookup(null));\n+        assertEquals(null, StrLookup.noneLookup().lookup(\"\"));\n+        assertEquals(null, StrLookup.noneLookup().lookup(\"any\"));\n+    }\n+\n+    public void testSystemProperiesLookup() {\n+        assertEquals(System.getProperty(\"os.name\"), StrLookup.systemPropertiesLookup().lookup(\"os.name\"));\n+        assertEquals(null, StrLookup.systemPropertiesLookup().lookup(\"\"));\n+        assertEquals(null, StrLookup.systemPropertiesLookup().lookup(\"other\"));\n+        try {\n+            StrLookup.systemPropertiesLookup().lookup(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMapLookup() {\n+        Map map = new HashMap();\n+        map.put(\"key\", \"value\");\n+        map.put(\"number\", new Integer(2));\n+        assertEquals(\"value\", StrLookup.mapLookup(map).lookup(\"key\"));\n+        assertEquals(\"2\", StrLookup.mapLookup(map).lookup(\"number\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(null));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"other\"));\n+    }\n+\n+    public void testMapLookup_nullMap() {\n+        Map map = null;\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(null));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"any\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/text/StrMatcherTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.lang.text.StrMatcher}.\n+ *\n+ * @version $Id$\n+ */\n+public class StrMatcherTest extends TestCase {\n+\n+    private static final char[] BUFFER1 = \"0,1\\t2 3\\n\\r\\f\\u0000'\\\"\".toCharArray();\n+\n+    private static final char[] BUFFER2 = \"abcdef\".toCharArray();\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrMatcherTest.class);\n+        suite.setName(\"StrMatcher Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Create a new test case with the specified name.\n+     * \n+     * @param name  the name\n+     */\n+    public StrMatcherTest(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCommaMatcher() {\n+        StrMatcher matcher = StrMatcher.commaMatcher();\n+        assertSame(matcher, StrMatcher.commaMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 0, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 1, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTabMatcher() {\n+        StrMatcher matcher = StrMatcher.tabMatcher();\n+        assertSame(matcher, StrMatcher.tabMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 3, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSpaceMatcher() {\n+        StrMatcher matcher = StrMatcher.spaceMatcher();\n+        assertSame(matcher, StrMatcher.spaceMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 5, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 6, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSplitMatcher() {\n+        StrMatcher matcher = StrMatcher.splitMatcher();\n+        assertSame(matcher, StrMatcher.splitMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 3, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 5, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 6, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 7, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 8, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 9, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 10, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTrimMatcher() {\n+        StrMatcher matcher = StrMatcher.trimMatcher();\n+        assertSame(matcher, StrMatcher.trimMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 3, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 5, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 6, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 7, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 8, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 9, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 10, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSingleQuoteMatcher() {\n+        StrMatcher matcher = StrMatcher.singleQuoteMatcher();\n+        assertSame(matcher, StrMatcher.singleQuoteMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 10, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 11, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 12, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDoubleQuoteMatcher() {\n+        StrMatcher matcher = StrMatcher.doubleQuoteMatcher();\n+        assertSame(matcher, StrMatcher.doubleQuoteMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 11, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 12, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testQuoteMatcher() {\n+        StrMatcher matcher = StrMatcher.quoteMatcher();\n+        assertSame(matcher, StrMatcher.quoteMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 10, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 11, 0, BUFFER1.length));\n+        assertEquals(1, matcher.isMatch(BUFFER1, 12, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoneMatcher() {\n+        StrMatcher matcher = StrMatcher.noneMatcher();\n+        assertSame(matcher, StrMatcher.noneMatcher());\n+        assertEquals(0, matcher.isMatch(BUFFER1, 0, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 1, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 2, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 3, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 4, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 5, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 6, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 7, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 8, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 9, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 10, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 11, 0, BUFFER1.length));\n+        assertEquals(0, matcher.isMatch(BUFFER1, 12, 0, BUFFER1.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCharMatcher_char() {\n+        StrMatcher matcher = StrMatcher.charMatcher('c');\n+        assertEquals(0, matcher.isMatch(BUFFER2, 0, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, BUFFER2.length));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 2, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 3, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 4, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 5, 0, BUFFER2.length));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCharSetMatcher_String() {\n+        StrMatcher matcher = StrMatcher.charSetMatcher(\"ace\");\n+        assertEquals(1, matcher.isMatch(BUFFER2, 0, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, BUFFER2.length));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 2, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 3, 0, BUFFER2.length));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 4, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 5, 0, BUFFER2.length));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(\"\"));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((String) null));\n+        assertTrue(StrMatcher.charSetMatcher(\"a\") instanceof StrMatcher.CharMatcher);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCharSetMatcher_charArray() {\n+        StrMatcher matcher = StrMatcher.charSetMatcher(\"ace\".toCharArray());\n+        assertEquals(1, matcher.isMatch(BUFFER2, 0, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, BUFFER2.length));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 2, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 3, 0, BUFFER2.length));\n+        assertEquals(1, matcher.isMatch(BUFFER2, 4, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 5, 0, BUFFER2.length));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher(new char[0]));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.charSetMatcher((char[]) null));\n+        assertTrue(StrMatcher.charSetMatcher(\"a\".toCharArray()) instanceof StrMatcher.CharMatcher);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStringMatcher_String() {\n+        StrMatcher matcher = StrMatcher.stringMatcher(\"bc\");\n+        assertEquals(0, matcher.isMatch(BUFFER2, 0, 0, BUFFER2.length));\n+        assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 2, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 3, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 4, 0, BUFFER2.length));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 5, 0, BUFFER2.length));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.stringMatcher(\"\"));\n+        assertSame(StrMatcher.noneMatcher(), StrMatcher.stringMatcher((String) null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMatcherIndices() {\n+        // remember that the API contract is tight for the isMatch() method\n+        // all the onus is on the caller, so invalid inputs are not\n+        // the concern of StrMatcher, and are not bugs\n+        StrMatcher matcher = StrMatcher.stringMatcher(\"bc\");\n+        assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length));\n+        assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3));\n+        assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2));\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/text/StrSubstitutorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.mutable.MutableObject;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test class for StrSubstitutor.\n+ * \n+ * @author Oliver Heger\n+ * @version $Id$\n+ */\n+public class StrSubstitutorTest extends TestCase {\n+\n+    private Map values;\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrSubstitutorTest.class);\n+        suite.setName(\"StrSubstitutor Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        values = new HashMap();\n+        values.put(\"animal\", \"quick brown fox\");\n+        values.put(\"target\", \"lazy dog\");\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        values = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplaceSimple() {\n+        doTestReplace(\"The quick brown fox jumps over the lazy dog.\", \"The ${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplaceSolo() {\n+        doTestReplace(\"quick brown fox\", \"${animal}\", false);\n+    }\n+\n+    /**\n+     * Tests replace with no variables.\n+     */\n+    public void testReplaceNoVariables() {\n+        doTestNoReplace(\"The balloon arrived.\");\n+    }\n+\n+    /**\n+     * Tests replace with null.\n+     */\n+    public void testReplaceNull() {\n+        doTestNoReplace(null);\n+    }\n+\n+    /**\n+     * Tests replace with null.\n+     */\n+    public void testReplaceEmpty() {\n+        doTestNoReplace(\"\");\n+    }\n+\n+    /**\n+     * Tests key replace changing map after initialization (not recommended).\n+     */\n+    public void testReplaceChangedMap() {\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        values.put(\"target\", \"moon\");\n+        assertEquals(\"The quick brown fox jumps over the moon.\", sub.replace(\"The ${animal} jumps over the ${target}.\"));\n+    }\n+\n+    /**\n+     * Tests unknown key replace.\n+     */\n+    public void testReplaceUnknownKey() {\n+        doTestReplace(\"The ${person} jumps over the lazy dog.\", \"The ${person} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests adjacent keys.\n+     */\n+    public void testReplaceAdjacentAtStart() {\n+        values.put(\"code\", \"GBP\");\n+        values.put(\"amount\", \"12.50\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(\"GBP12.50 charged\", sub.replace(\"${code}${amount} charged\"));\n+    }\n+\n+    /**\n+     * Tests adjacent keys.\n+     */\n+    public void testReplaceAdjacentAtEnd() {\n+        values.put(\"code\", \"GBP\");\n+        values.put(\"amount\", \"12.50\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(\"Amount is GBP12.50\", sub.replace(\"Amount is ${code}${amount}\"));\n+    }\n+\n+    /**\n+     * Tests simple recursive replace.\n+     */\n+    public void testReplaceRecursive() {\n+        values.put(\"animal\", \"${critter}\");\n+        values.put(\"target\", \"${pet}\");\n+        values.put(\"pet\", \"${petCharacteristic} dog\");\n+        values.put(\"petCharacteristic\", \"lazy\");\n+        values.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        values.put(\"critterSpeed\", \"quick\");\n+        values.put(\"critterColor\", \"brown\");\n+        values.put(\"critterType\", \"fox\");\n+        doTestReplace(\"The quick brown fox jumps over the lazy dog.\", \"The ${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests escaping.\n+     */\n+    public void testReplaceEscaping() {\n+        doTestReplace(\"The ${animal} jumps over the lazy dog.\", \"The $${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests escaping.\n+     */\n+    public void testReplaceSoloEscaping() {\n+        doTestReplace(\"${animal}\", \"$${animal}\", false);\n+    }\n+\n+    /**\n+     * Tests complex escaping.\n+     */\n+    public void testReplaceComplexEscaping() {\n+        doTestReplace(\"The ${quick brown fox} jumps over the lazy dog.\", \"The $${${animal}} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no prefix or suffix.\n+     */\n+    public void testReplaceNoPefixNoSuffix() {\n+        doTestReplace(\"The animal jumps over the lazy dog.\", \"The animal jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no incomplete prefix.\n+     */\n+    public void testReplaceIncompletePefix() {\n+        doTestReplace(\"The {animal} jumps over the lazy dog.\", \"The {animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when prefix but no suffix.\n+     */\n+    public void testReplacePrefixNoSuffix() {\n+        doTestReplace(\"The ${animal jumps over the ${target} lazy dog.\", \"The ${animal jumps over the ${target} ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when suffix but no prefix.\n+     */\n+    public void testReplaceNoPrefixSuffix() {\n+        doTestReplace(\"The animal} jumps over the lazy dog.\", \"The animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no variable name.\n+     */\n+    public void testReplaceEmptyKeys() {\n+        doTestReplace(\"The ${} jumps over the lazy dog.\", \"The ${} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests replace creates output same as input.\n+     */\n+    public void testReplaceToIdentical() {\n+        values.put(\"animal\", \"$${${thing}}\");\n+        values.put(\"thing\", \"animal\");\n+        doTestReplace(\"The ${animal} jumps.\", \"The ${animal} jumps.\", true);\n+    }\n+\n+    /**\n+     * Tests a cyclic replace operation.\n+     * The cycle should be detected and cause an exception to be thrown.\n+     */\n+    public void testCyclicReplacement() {\n+        Map map = new HashMap();\n+        map.put(\"animal\", \"${critter}\");\n+        map.put(\"target\", \"${pet}\");\n+        map.put(\"pet\", \"${petCharacteristic} dog\");\n+        map.put(\"petCharacteristic\", \"lazy\");\n+        map.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        map.put(\"critterSpeed\", \"quick\");\n+        map.put(\"critterColor\", \"brown\");\n+        map.put(\"critterType\", \"${animal}\");\n+        StrSubstitutor sub = new StrSubstitutor(map);\n+        try {\n+            sub.replace(\"The ${animal} jumps over the ${target}.\");\n+            fail(\"Cyclic replacement was not detected!\");\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests interpolation with weird boundary patterns.\n+     */\n+    public void testReplaceWeirdPattens() {\n+        doTestNoReplace(\"\");\n+        doTestNoReplace(\"${}\");\n+        doTestNoReplace(\"${ }\");\n+        doTestNoReplace(\"${\\t}\");\n+        doTestNoReplace(\"${\\n}\");\n+        doTestNoReplace(\"${\\b}\");\n+        doTestNoReplace(\"${\");\n+        doTestNoReplace(\"$}\");\n+        doTestNoReplace(\"}\");\n+        doTestNoReplace(\"${}$\");\n+        doTestNoReplace(\"${${\");\n+        doTestNoReplace(\"${${}}\");\n+        doTestNoReplace(\"${$${}}\");\n+        doTestNoReplace(\"${$$${}}\");\n+        doTestNoReplace(\"${$$${$}}\");\n+        doTestNoReplace(\"${${}}\");\n+        doTestNoReplace(\"${${ }}\");\n+    }\n+\n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplacePartialString_noReplace() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(\"${animal} jumps\", sub.replace(\"The ${animal} jumps over the ${target}.\", 4, 15));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests protected.\n+     */\n+    public void testResolveVariable() {\n+        final StrBuilder builder = new StrBuilder(\"Hi ${name}!\");\n+        Map map = new HashMap();\n+        map.put(\"name\", \"commons\");\n+        StrSubstitutor sub = new StrSubstitutor(map) {\n+            protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {\n+                assertEquals(\"name\", variableName);\n+                assertSame(builder, buf);\n+                assertEquals(3, startPos);\n+                assertEquals(10, endPos);\n+                return \"jakarta\";\n+            }\n+        };\n+        sub.replaceIn(builder);\n+        assertEquals(\"Hi jakarta!\", builder.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorNoArgs() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(\"Hi ${name}\", sub.replace(\"Hi ${name}\"));\n+    }\n+\n+    /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorMapPrefixSuffix() {\n+        Map map = new HashMap();\n+        map.put(\"name\", \"commons\");\n+        StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\");\n+        assertEquals(\"Hi < commons\", sub.replace(\"Hi $< <name>\"));\n+    }\n+\n+    /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorMapFull() {\n+        Map map = new HashMap();\n+        map.put(\"name\", \"commons\");\n+        StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\", '!');\n+        assertEquals(\"Hi < commons\", sub.replace(\"Hi !< <name>\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetEscape() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals('$', sub.getEscapeChar());\n+        sub.setEscapeChar('<');\n+        assertEquals('<', sub.getEscapeChar());\n+    }\n+\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetPrefix() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        sub.setVariablePrefix('<');\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher);\n+        \n+        sub.setVariablePrefix(\"<<\");\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        try {\n+            sub.setVariablePrefix((String) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        \n+        StrMatcher matcher = StrMatcher.commaMatcher();\n+        sub.setVariablePrefixMatcher(matcher);\n+        assertSame(matcher, sub.getVariablePrefixMatcher());\n+        try {\n+            sub.setVariablePrefixMatcher((StrMatcher) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertSame(matcher, sub.getVariablePrefixMatcher());\n+    }\n+\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetSuffix() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        sub.setVariableSuffix('<');\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher);\n+        \n+        sub.setVariableSuffix(\"<<\");\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        try {\n+            sub.setVariableSuffix((String) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        \n+        StrMatcher matcher = StrMatcher.commaMatcher();\n+        sub.setVariableSuffixMatcher(matcher);\n+        assertSame(matcher, sub.getVariableSuffixMatcher());\n+        try {\n+            sub.setVariableSuffixMatcher((StrMatcher) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertSame(matcher, sub.getVariableSuffixMatcher());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests static.\n+     */\n+    public void testStaticReplace() {\n+        Map map = new HashMap();\n+        map.put(\"name\", \"commons\");\n+        assertEquals(\"Hi commons!\", StrSubstitutor.replace(\"Hi ${name}!\", map));\n+    }\n+\n+    /**\n+     * Tests static.\n+     */\n+    public void testStaticReplacePrefixSuffix() {\n+        Map map = new HashMap();\n+        map.put(\"name\", \"commons\");\n+        assertEquals(\"Hi commons!\", StrSubstitutor.replace(\"Hi <name>!\", map, \"<\", \">\"));\n+    }\n+\n+    /**\n+     * Tests interpolation with system properties.\n+     */\n+    public void testStaticReplaceSystemProperties() {\n+        StrBuilder buf = new StrBuilder();\n+        buf.append(\"Hi \").append(System.getProperty(\"user.name\"));\n+        buf.append(\", you are working with \");\n+        buf.append(System.getProperty(\"os.name\"));\n+        buf.append(\", your home directory is \");\n+        buf.append(System.getProperty(\"user.home\")).append('.');\n+        assertEquals(buf.toString(), StrSubstitutor.replaceSystemProperties(\"Hi ${user.name}, you are \"\n+            + \"working with ${os.name}, your home \"\n+            + \"directory is ${user.home}.\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void doTestReplace(String expectedResult, String replaceTemplate, boolean substring) {\n+        String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        \n+        // replace using String\n+        assertEquals(expectedResult, sub.replace(replaceTemplate));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2));\n+        }\n+        \n+        // replace using char[]\n+        char[] chars = replaceTemplate.toCharArray();\n+        assertEquals(expectedResult, sub.replace(chars));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));\n+        }\n+        \n+        // replace using StringBuffer\n+        StringBuffer buf = new StringBuffer(replaceTemplate);\n+        assertEquals(expectedResult, sub.replace(buf));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2));\n+        }\n+        \n+        // replace using StrBuilder\n+        StrBuilder bld = new StrBuilder(replaceTemplate);\n+        assertEquals(expectedResult, sub.replace(bld));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(bld, 1, bld.length() - 2));\n+        }\n+        \n+        // replace using object\n+        MutableObject obj = new MutableObject(replaceTemplate);  // toString returns template\n+        assertEquals(expectedResult, sub.replace(obj));\n+        \n+        // replace in StringBuffer\n+        buf = new StringBuffer(replaceTemplate);\n+        assertEquals(true, sub.replaceIn(buf));\n+        assertEquals(expectedResult, buf.toString());\n+        if (substring) {\n+            buf = new StringBuffer(replaceTemplate);\n+            assertEquals(true, sub.replaceIn(buf, 1, buf.length() - 2));\n+            assertEquals(expectedResult, buf.toString());  // expect full result as remainder is untouched\n+        }\n+        \n+        // replace in StrBuilder\n+        bld = new StrBuilder(replaceTemplate);\n+        assertEquals(true, sub.replaceIn(bld));\n+        assertEquals(expectedResult, bld.toString());\n+        if (substring) {\n+            bld = new StrBuilder(replaceTemplate);\n+            assertEquals(true, sub.replaceIn(bld, 1, bld.length() - 2));\n+            assertEquals(expectedResult, bld.toString());  // expect full result as remainder is untouched\n+        }\n+    }\n+\n+    private void doTestNoReplace(String replaceTemplate) {\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        \n+        if (replaceTemplate == null) {\n+            assertEquals(null, sub.replace((String) null));\n+            assertEquals(null, sub.replace((String) null, 0, 100));\n+            assertEquals(null, sub.replace((char[]) null));\n+            assertEquals(null, sub.replace((char[]) null, 0, 100));\n+            assertEquals(null, sub.replace((StringBuffer) null));\n+            assertEquals(null, sub.replace((StringBuffer) null, 0, 100));\n+            assertEquals(null, sub.replace((StrBuilder) null));\n+            assertEquals(null, sub.replace((StrBuilder) null, 0, 100));\n+            assertEquals(null, sub.replace((Object) null));\n+            assertEquals(false, sub.replaceIn((StringBuffer) null));\n+            assertEquals(false, sub.replaceIn((StringBuffer) null, 0, 100));\n+            assertEquals(false, sub.replaceIn((StrBuilder) null));\n+            assertEquals(false, sub.replaceIn((StrBuilder) null, 0, 100));\n+        } else {\n+            assertEquals(replaceTemplate, sub.replace(replaceTemplate));\n+            StrBuilder bld = new StrBuilder(replaceTemplate);\n+            assertEquals(false, sub.replaceIn(bld));\n+            assertEquals(replaceTemplate, bld.toString());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/text/StrTokenizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.ObjectUtils;\n+\n+/**\n+ * Unit test for Tokenizer.\n+ * \n+ * @author Matthew Inger\n+ */\n+public class StrTokenizerTest extends TestCase {\n+\n+    private static final String CSV_SIMPLE_FIXTURE = \"A,b,c\";\n+\n+    private static final String TSV_SIMPLE_FIXTURE = \"A\\tb\\tc\";\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrTokenizerTest.class);\n+        suite.setName(\"TokenizerTest Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param name\n+     */\n+    public StrTokenizerTest(String name) {\n+        super(name);\n+    }\n+\n+    private void checkClone(StrTokenizer tokenizer) {\n+        assertFalse(StrTokenizer.getCSVInstance() == tokenizer);\n+        assertFalse(StrTokenizer.getTSVInstance() == tokenizer);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void test1() {\n+\n+        String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;  \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", \"\", \"\", \"\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test2() {\n+\n+        String input = \"a;b;c ;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c \", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test3() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test4() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(true);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test5() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", null, null, null,};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test6() {\n+\n+        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        // tok.setTreatingEmptyAsNull(true);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", null, null, null,};\n+\n+        int nextCount = 0;\n+        while (tok.hasNext()) {\n+            tok.next();\n+            nextCount++;\n+        }\n+\n+        int prevCount = 0;\n+        while (tok.hasPrevious()) {\n+            tok.previous();\n+            prevCount++;\n+        }\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+\n+        assertTrue(\"could not cycle through entire token list\" + \" using the 'hasNext' and 'next' methods\",\n+                nextCount == expected.length);\n+\n+        assertTrue(\"could not cycle through entire token list\" + \" using the 'hasPrevious' and 'previous' methods\",\n+                prevCount == expected.length);\n+\n+    }\n+\n+    public void test7() {\n+\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterMatcher(StrMatcher.spaceMatcher());\n+        tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"\", \"\", \"b\", \"c\", \"d e\", \"f\", \"\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void test8() {\n+\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setDelimiterMatcher(StrMatcher.spaceMatcher());\n+        tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        tok.setIgnoreEmptyTokens(true);\n+        String tokens[] = tok.getTokenArray();\n+\n+        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d e\", \"f\",};\n+\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n+                    ObjectUtils.equals(expected[i], tokens[i]));\n+        }\n+\n+    }\n+\n+    public void testBasic1() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic2() {\n+        String input = \"a \\nb\\fc\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic3() {\n+        String input = \"a \\nb\\u0001\\fc\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\\u0001\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic4() {\n+        String input = \"a \\\"b\\\" c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"\\\"b\\\"\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic5() {\n+        String input = \"a:b':c\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b'\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicDelim1() {\n+        String input = \"a:b:c\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicDelim2() {\n+        String input = \"a:b:c\";\n+        StrTokenizer tok = new StrTokenizer(input, ',');\n+        assertEquals(\"a:b:c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicEmpty1() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setIgnoreEmptyTokens(false);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicEmpty2() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted1() {\n+        String input = \"a 'b' c\";\n+        StrTokenizer tok = new StrTokenizer(input, ' ', '\\'');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted2() {\n+        String input = \"a:'b':\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted3() {\n+        String input = \"a:'b''c'\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b'c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted4() {\n+        String input = \"a: 'b' 'c' :d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b c\", tok.next());\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted5() {\n+        String input = \"a: 'b'x'c' :d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bxc\", tok.next());\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted6() {\n+        String input = \"a:'b'\\\"c':d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setQuoteMatcher(StrMatcher.quoteMatcher());\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\\\"c:d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted7() {\n+        String input = \"a:\\\"There's a reason here\\\":b\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setQuoteMatcher(StrMatcher.quoteMatcher());\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"There's a reason here\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuotedTrimmed1() {\n+        String input = \"a: 'b' :\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicTrimmed1() {\n+        String input = \"a: b :  \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicTrimmed2() {\n+        String input = \"a:  b  :\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setTrimmerMatcher(StrMatcher.stringMatcher(\"  \"));\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed1() {\n+        String input = \"a: bIGNOREc : \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bc\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed2() {\n+        String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bc\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed3() {\n+        String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"  bc  \", tok.next());\n+        assertEquals(\"  \", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed4() {\n+        String input = \"IGNOREaIGNORE: IGNORE 'bIGNOREc'IGNORE'd' IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bIGNOREcd\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testListArray() {\n+        String input = \"a  b c\";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        String[] array = tok.getTokenArray();\n+        List list = tok.getTokenList();\n+        \n+        assertEquals(Arrays.asList(array), list);\n+        assertEquals(3, list.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCSV(String data) {\n+        this.testXSVAbc(StrTokenizer.getCSVInstance(data));\n+        this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray()));\n+    }\n+\n+    public void testCSVEmpty() {\n+        this.testEmpty(StrTokenizer.getCSVInstance());\n+        this.testEmpty(StrTokenizer.getCSVInstance(\"\"));\n+    }\n+\n+    public void testCSVSimple() {\n+        this.testCSV(CSV_SIMPLE_FIXTURE);\n+    }\n+\n+    public void testCSVSimpleNeedsTrim() {\n+        this.testCSV(\"   \" + CSV_SIMPLE_FIXTURE);\n+        this.testCSV(\"   \\n\\t  \" + CSV_SIMPLE_FIXTURE);\n+        this.testCSV(\"   \\n  \" + CSV_SIMPLE_FIXTURE + \"\\n\\n\\r\");\n+    }\n+\n+    void testEmpty(StrTokenizer tokenizer) {\n+        this.checkClone(tokenizer);\n+        assertEquals(false, tokenizer.hasNext());\n+        assertEquals(false, tokenizer.hasPrevious());\n+        assertEquals(null, tokenizer.nextToken());\n+        assertEquals(0, tokenizer.size());\n+        try {\n+            tokenizer.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+    }\n+\n+    public void testGetContent() {\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        StrTokenizer tok = new StrTokenizer(input);\n+        assertEquals(input, tok.getContent());\n+\n+        tok = new StrTokenizer(input.toCharArray());\n+        assertEquals(input, tok.getContent());\n+        \n+        tok = new StrTokenizer();\n+        assertEquals(null, tok.getContent());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testChaining() {\n+        StrTokenizer tok = new StrTokenizer();\n+        assertEquals(tok, tok.reset());\n+        assertEquals(tok, tok.reset(\"\"));\n+        assertEquals(tok, tok.reset(new char[0]));\n+        assertEquals(tok, tok.setDelimiterChar(' '));\n+        assertEquals(tok, tok.setDelimiterString(\" \"));\n+        assertEquals(tok, tok.setDelimiterMatcher(null));\n+        assertEquals(tok, tok.setQuoteChar(' '));\n+        assertEquals(tok, tok.setQuoteMatcher(null));\n+        assertEquals(tok, tok.setIgnoredChar(' '));\n+        assertEquals(tok, tok.setIgnoredMatcher(null));\n+        assertEquals(tok, tok.setTrimmerMatcher(null));\n+        assertEquals(tok, tok.setEmptyTokenAsNull(false));\n+        assertEquals(tok, tok.setIgnoreEmptyTokens(false));\n+    }\n+\n+    /**\n+     * Tests that the {@link StrTokenizer#clone()} clone method catches {@link CloneNotSupportedException} and returns\n+     * <code>null</code>.\n+     */\n+    public void testCloneNotSupportedException() {\n+        Object notCloned = (new StrTokenizer() {\n+            Object cloneReset() throws CloneNotSupportedException {\n+                throw new CloneNotSupportedException(\"test\");\n+            }\n+        }).clone();\n+        assertNull(notCloned);\n+    }\n+\n+    public void testCloneNull() {\n+        StrTokenizer tokenizer = new StrTokenizer((char[]) null);\n+        // Start sanity check\n+        assertEquals(null, tokenizer.nextToken());\n+        tokenizer.reset();\n+        assertEquals(null, tokenizer.nextToken());\n+        // End sanity check\n+        StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();\n+        tokenizer.reset();\n+        assertEquals(null, tokenizer.nextToken());\n+        assertEquals(null, clonedTokenizer.nextToken());\n+    }\n+\n+    public void testCloneReset() {\n+        char[] input = new char[]{'a'};\n+        StrTokenizer tokenizer = new StrTokenizer(input);\n+        // Start sanity check\n+        assertEquals(\"a\", tokenizer.nextToken());\n+        tokenizer.reset();\n+        assertEquals(\"a\", tokenizer.nextToken());\n+        // End sanity check\n+        StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();\n+        input[0] = 'b';\n+        tokenizer.reset();\n+        assertEquals(\"b\", tokenizer.nextToken());\n+        assertEquals(\"a\", clonedTokenizer.nextToken());\n+    }\n+  \n+    // -----------------------------------------------------------------------\n+    public void testConstructor_String() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\");\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(\"\");\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((String) null);\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_String_char() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\", ' ');\n+        assertEquals(1, tok.getDelimiterMatcher().isMatch(\" \".toCharArray(), 0, 0, 1));\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(\"\", ' ');\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((String) null, ' ');\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_String_char_char() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\", ' ', '\"');\n+        assertEquals(1, tok.getDelimiterMatcher().isMatch(\" \".toCharArray(), 0, 0, 1));\n+        assertEquals(1, tok.getQuoteMatcher().isMatch(\"\\\"\".toCharArray(), 0, 0, 1));\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(\"\", ' ', '\"');\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((String) null, ' ', '\"');\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_charArray() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\".toCharArray());\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(new char[0]);\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((char[]) null);\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_charArray_char() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\".toCharArray(), ' ');\n+        assertEquals(1, tok.getDelimiterMatcher().isMatch(\" \".toCharArray(), 0, 0, 1));\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(new char[0], ' ');\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((char[]) null, ' ');\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_charArray_char_char() {\n+        StrTokenizer tok = new StrTokenizer(\"a b\".toCharArray(), ' ', '\"');\n+        assertEquals(1, tok.getDelimiterMatcher().isMatch(\" \".toCharArray(), 0, 0, 1));\n+        assertEquals(1, tok.getQuoteMatcher().isMatch(\"\\\"\".toCharArray(), 0, 0, 1));\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer(new char[0], ' ', '\"');\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok = new StrTokenizer((char[]) null, ' ', '\"');\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReset() {\n+        StrTokenizer tok = new StrTokenizer(\"a b c\");\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok.reset();\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReset_String() {\n+        StrTokenizer tok = new StrTokenizer(\"x x x\");\n+        tok.reset(\"d e\");\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(\"e\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok.reset((String) null);\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReset_charArray() {\n+        StrTokenizer tok = new StrTokenizer(\"x x x\");\n+        \n+        char[] array = new char[] {'a', ' ', 'c'};\n+        tok.reset(array);\n+        array[1] = 'b'; // test linked array\n+        assertEquals(\"abc\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+        \n+        tok.reset((char[]) null);\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTSV() {\n+        this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE));\n+        this.testXSVAbc(StrTokenizer.getTSVInstance(TSV_SIMPLE_FIXTURE.toCharArray()));\n+    }\n+\n+    public void testTSVEmpty() {\n+        this.testEmpty(StrTokenizer.getCSVInstance());\n+        this.testEmpty(StrTokenizer.getCSVInstance(\"\"));\n+    }\n+\n+    void testXSVAbc(StrTokenizer tokenizer) {\n+        this.checkClone(tokenizer);\n+        assertEquals(-1, tokenizer.previousIndex());\n+        assertEquals(0, tokenizer.nextIndex());\n+        assertEquals(null, tokenizer.previousToken());\n+        assertEquals(\"A\", tokenizer.nextToken());\n+        assertEquals(1, tokenizer.nextIndex());\n+        assertEquals(\"b\", tokenizer.nextToken());\n+        assertEquals(2, tokenizer.nextIndex());\n+        assertEquals(\"c\", tokenizer.nextToken());\n+        assertEquals(3, tokenizer.nextIndex());\n+        assertEquals(null, tokenizer.nextToken());\n+        assertEquals(3, tokenizer.nextIndex());\n+        assertEquals(\"c\", tokenizer.previousToken());\n+        assertEquals(2, tokenizer.nextIndex());\n+        assertEquals(\"b\", tokenizer.previousToken());\n+        assertEquals(1, tokenizer.nextIndex());\n+        assertEquals(\"A\", tokenizer.previousToken());\n+        assertEquals(0, tokenizer.nextIndex());\n+        assertEquals(null, tokenizer.previousToken());\n+        assertEquals(0, tokenizer.nextIndex());\n+        assertEquals(-1, tokenizer.previousIndex());\n+        assertEquals(3, tokenizer.size());\n+    }\n+\n+    public void testIteration() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c\");\n+        assertEquals(false, tkn.hasPrevious());\n+        try {\n+            tkn.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        assertEquals(true, tkn.hasNext());\n+        \n+        assertEquals(\"a\", tkn.next());\n+        try {\n+            tkn.remove();\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        try {\n+            tkn.set(\"x\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        try {\n+            tkn.add(\"y\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(true, tkn.hasNext());\n+        \n+        assertEquals(\"b\", tkn.next());\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(true, tkn.hasNext());\n+        \n+        assertEquals(\"c\", tkn.next());\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(false, tkn.hasNext());\n+        \n+        try {\n+            tkn.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(false, tkn.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTokenizeSubclassInputChange() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c d e\") {\n+            protected List tokenize(char[] chars, int offset, int count) {\n+                return super.tokenize(\"w x y z\".toCharArray(), 2, 5);\n+            }\n+        };\n+        assertEquals(\"x\", tkn.next());\n+        assertEquals(\"y\", tkn.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTokenizeSubclassOutputChange() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c\") {\n+            protected List tokenize(char[] chars, int offset, int count) {\n+                List list = super.tokenize(chars, offset, count);\n+                Collections.reverse(list);\n+                return list;\n+            }\n+        };\n+        assertEquals(\"c\", tkn.next());\n+        assertEquals(\"b\", tkn.next());\n+        assertEquals(\"a\", tkn.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c d e\");\n+        assertEquals(\"StrTokenizer[not tokenized yet]\", tkn.toString());\n+        tkn.next();\n+        assertEquals(\"StrTokenizer[a, b, c, d, e]\", tkn.toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/text/TextTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test suite for the Text package.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class TextTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public TextTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Text Tests\");\n+        suite.addTest(CompositeFormatTest.suite());\n+        suite.addTest(StrBuilderTest.suite());\n+        suite.addTest(StrBuilderAppendInsertTest.suite());\n+        suite.addTest(StrLookupTest.suite());\n+        suite.addTest(StrMatcherTest.suite());\n+        suite.addTest(StrSubstitutorTest.suite());\n+        suite.addTest(StrTokenizerTest.suite());\n+        return suite;\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/time/DateFormatUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Calendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * TestCase for DateFormatUtils.\n+ *\n+ * @author Apache Ant - DateUtilsTest\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ */\n+public class DateFormatUtilsTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DateFormatUtilsTest.class);\n+        suite.setName(\"DateFormatUtils Tests\");\n+        return suite;\n+    }\n+\n+    public DateFormatUtilsTest(String s) {\n+        super(s);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new DateFormatUtils());\n+        Constructor[] cons = DateFormatUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(DateFormatUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(DateFormatUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testFormat() {\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        c.set(2005,0,1,12,0,0);\n+        c.setTimeZone(TimeZone.getDefault());\n+        StringBuffer buffer = new StringBuffer ();\n+        int year = c.get(Calendar.YEAR);\n+        int month = c.get(Calendar.MONTH) + 1;\n+        int day = c.get(Calendar.DAY_OF_MONTH);\n+        int hour = c.get(Calendar.HOUR_OF_DAY);\n+        buffer.append (year);\n+        buffer.append(month);\n+        buffer.append(day);\n+        buffer.append(hour);\n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), \"yyyyMdH\"));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), \"yyyyMdH\"));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime(), \"yyyyMdH\", Locale.US));\n+        \n+        assertEquals(buffer.toString(), DateFormatUtils.format(c.getTime().getTime(), \"yyyyMdH\", Locale.US));\n+    }\n+    \n+    public void testFormatUTC() {\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        c.set(2005,0,1,12,0,0);\n+        assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern()));\n+        \n+        assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern()));\n+        \n+        assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US));\n+        \n+        assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime().getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), Locale.US));\n+    }\n+    \n+    public void testDateTimeISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,9,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        text = DateFormatUtils.ISO_DATETIME_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+    }\n+\n+    public void testDateISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23\", text);\n+        text = DateFormatUtils.ISO_DATE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+        text = DateFormatUtils.ISO_DATE_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+    }\n+\n+    public void testTimeISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12\", text);\n+        text = DateFormatUtils.ISO_TIME_FORMAT.format(cal);\n+        assertEquals(\"T10:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_TIME_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+    }\n+\n+    public void testTimeNoTISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12\", text);\n+        text = DateFormatUtils.ISO_TIME_NO_T_FORMAT.format(cal);\n+        assertEquals(\"10:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_TIME_NO_T_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"10:11:12-03:00\", text);\n+    }\n+\n+    public void testSMTP(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2003,5,8,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone,\n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale());\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone,\n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale());\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal);\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        \n+        // format UTC\n+        text = DateFormatUtils.formatUTC(cal.getTime().getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),\n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getLocale());\n+        assertEquals(\"Sun, 08 Jun 2003 13:11:12 +0000\", text);\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/time/DateUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+import java.util.TimeZone;\n+\n+import junit.framework.AssertionFailedError;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.SystemUtils;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.time.DateUtils}.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ * @author <a href=\"mailto:steve@mungoknotwise.com\">Steven Caswell</a>\n+ */\n+public class DateUtilsTest extends TestCase {\n+\n+    private static final long MILLIS_TEST;\n+    static {\n+        GregorianCalendar cal = new GregorianCalendar(2000, 6, 5, 4, 3, 2);\n+        cal.set(Calendar.MILLISECOND, 1);\n+        MILLIS_TEST = cal.getTime().getTime();\n+    }\n+\n+    DateFormat dateParser = null;\n+    DateFormat dateTimeParser = null;\n+    DateFormat timeZoneDateParser = null;\n+    Date dateAmPm1 = null;\n+    Date dateAmPm2 = null;\n+    Date dateAmPm3 = null;\n+    Date dateAmPm4 = null;\n+    Date date0 = null;\n+    Date date1 = null;\n+    Date date2 = null;\n+    Date date3 = null;\n+    Date date4 = null;\n+    Date date5 = null;\n+    Date date6 = null;\n+    Date date7 = null;\n+    Date date8 = null;\n+    Calendar calAmPm1 = null;\n+    Calendar calAmPm2 = null;\n+    Calendar calAmPm3 = null;\n+    Calendar calAmPm4 = null;\n+    Calendar cal1 = null;\n+    Calendar cal2 = null;\n+    Calendar cal3 = null;\n+    Calendar cal4 = null;\n+    Calendar cal5 = null;\n+    Calendar cal6 = null;\n+    Calendar cal7 = null;\n+    Calendar cal8 = null;\n+    TimeZone zone = null;\n+    TimeZone defaultZone = null;\n+\n+    public DateUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DateUtilsTest.class);\n+        suite.setName(\"DateUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        dateParser = new SimpleDateFormat(\"MMM dd, yyyy\", Locale.ENGLISH);\n+        dateTimeParser = new SimpleDateFormat(\"MMM dd, yyyy H:mm:ss.SSS\", Locale.ENGLISH);\n+\n+        dateAmPm1 = dateTimeParser.parse(\"February 3, 2002 01:10:00.000\");\n+        dateAmPm2 = dateTimeParser.parse(\"February 3, 2002 11:10:00.000\");\n+        dateAmPm3 = dateTimeParser.parse(\"February 3, 2002 13:10:00.000\");\n+        dateAmPm4 = dateTimeParser.parse(\"February 3, 2002 19:10:00.000\");\n+        date0 = dateTimeParser.parse(\"February 3, 2002 12:34:56.789\");\n+        date1 = dateTimeParser.parse(\"February 12, 2002 12:34:56.789\");\n+        date2 = dateTimeParser.parse(\"November 18, 2001 1:23:11.321\");\n+        defaultZone = TimeZone.getDefault();\n+        zone = TimeZone.getTimeZone(\"MET\");\n+        TimeZone.setDefault(zone);\n+        dateTimeParser.setTimeZone(zone);\n+        date3 = dateTimeParser.parse(\"March 30, 2003 05:30:45.000\");\n+        date4 = dateTimeParser.parse(\"March 30, 2003 01:10:00.000\");\n+        date5 = dateTimeParser.parse(\"March 30, 2003 01:40:00.000\");\n+        date6 = dateTimeParser.parse(\"March 30, 2003 02:10:00.000\");\n+        date7 = dateTimeParser.parse(\"March 30, 2003 02:40:00.000\");\n+        date8 = dateTimeParser.parse(\"October 26, 2003 05:30:45.000\");\n+        dateTimeParser.setTimeZone(defaultZone);\n+        TimeZone.setDefault(defaultZone);\n+        calAmPm1 = Calendar.getInstance();\n+        calAmPm1.setTime(dateAmPm1);\n+        calAmPm2 = Calendar.getInstance();\n+        calAmPm2.setTime(dateAmPm2);\n+        calAmPm3 = Calendar.getInstance();\n+        calAmPm3.setTime(dateAmPm3);\n+        calAmPm4 = Calendar.getInstance();\n+        calAmPm4.setTime(dateAmPm4);\n+        cal1 = Calendar.getInstance();\n+        cal1.setTime(date1);\n+        cal2 = Calendar.getInstance();\n+        cal2.setTime(date2);\n+        TimeZone.setDefault(zone);\n+        cal3 = Calendar.getInstance();\n+        cal3.setTime(date3);\n+        cal4 = Calendar.getInstance();\n+        cal4.setTime(date4);\n+        cal5 = Calendar.getInstance();\n+        cal5.setTime(date5);\n+        cal6 = Calendar.getInstance();\n+        cal6.setTime(date6);\n+        cal7 = Calendar.getInstance();\n+        cal7.setTime(date7);\n+        cal8 = Calendar.getInstance();\n+        cal8.setTime(date8);\n+        TimeZone.setDefault(defaultZone);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new DateUtils());\n+        Constructor[] cons = DateUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(DateUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(DateUtils.class.getModifiers()));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameDay_Date() {\n+        Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();\n+        Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();\n+        assertEquals(true, DateUtils.isSameDay(date1, date2));\n+        date2 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();\n+        assertEquals(false, DateUtils.isSameDay(date1, date2));\n+        date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();\n+        assertEquals(true, DateUtils.isSameDay(date1, date2));\n+        date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime();\n+        assertEquals(false, DateUtils.isSameDay(date1, date2));\n+        try {\n+            DateUtils.isSameDay((Date) null, (Date) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameDay_Cal() {\n+        GregorianCalendar cal1 = new GregorianCalendar(2004, 6, 9, 13, 45);\n+        GregorianCalendar cal2 = new GregorianCalendar(2004, 6, 9, 13, 45);\n+        assertEquals(true, DateUtils.isSameDay(cal1, cal2));\n+        cal2.add(Calendar.DAY_OF_YEAR, 1);\n+        assertEquals(false, DateUtils.isSameDay(cal1, cal2));\n+        cal1.add(Calendar.DAY_OF_YEAR, 1);\n+        assertEquals(true, DateUtils.isSameDay(cal1, cal2));\n+        cal2.add(Calendar.YEAR, 1);\n+        assertEquals(false, DateUtils.isSameDay(cal1, cal2));\n+        try {\n+            DateUtils.isSameDay((Calendar) null, (Calendar) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameInstant_Date() {\n+        Date date1 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();\n+        Date date2 = new GregorianCalendar(2004, 6, 9, 13, 45).getTime();\n+        assertEquals(true, DateUtils.isSameInstant(date1, date2));\n+        date2 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();\n+        assertEquals(false, DateUtils.isSameInstant(date1, date2));\n+        date1 = new GregorianCalendar(2004, 6, 10, 13, 45).getTime();\n+        assertEquals(true, DateUtils.isSameInstant(date1, date2));\n+        date2 = new GregorianCalendar(2005, 6, 10, 13, 45).getTime();\n+        assertEquals(false, DateUtils.isSameInstant(date1, date2));\n+        try {\n+            DateUtils.isSameInstant((Date) null, (Date) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameInstant_Cal() {\n+        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n+        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n+        cal1.set(2004, 6, 9, 13, 45, 0);\n+        cal1.set(Calendar.MILLISECOND, 0);\n+        cal2.set(2004, 6, 9, 13, 45, 0);\n+        cal2.set(Calendar.MILLISECOND, 0);\n+        assertEquals(false, DateUtils.isSameInstant(cal1, cal2));\n+        \n+        cal2.set(2004, 6, 9, 11, 45, 0);\n+        assertEquals(true, DateUtils.isSameInstant(cal1, cal2));\n+        try {\n+            DateUtils.isSameInstant((Calendar) null, (Calendar) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testIsSameLocalTime_Cal() {\n+        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n+        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n+        cal1.set(2004, 6, 9, 13, 45, 0);\n+        cal1.set(Calendar.MILLISECOND, 0);\n+        cal2.set(2004, 6, 9, 13, 45, 0);\n+        cal2.set(Calendar.MILLISECOND, 0);\n+        assertEquals(true, DateUtils.isSameLocalTime(cal1, cal2));\n+        \n+        cal2.set(2004, 6, 9, 11, 45, 0);\n+        assertEquals(false, DateUtils.isSameLocalTime(cal1, cal2));\n+        try {\n+            DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testParseDate() throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar(1972, 11, 3);\n+        String dateStr = \"1972-12-03\";\n+        String[] parsers = new String[] {\"yyyy'-'DDD\", \"yyyy'-'MM'-'dd\", \"yyyyMMdd\"};\n+        Date date = DateUtils.parseDate(dateStr, parsers);\n+        assertEquals(cal.getTime(), date);\n+        \n+        dateStr = \"1972-338\";\n+        date = DateUtils.parseDate(dateStr, parsers);\n+        assertEquals(cal.getTime(), date);\n+        \n+        dateStr = \"19721203\";\n+        date = DateUtils.parseDate(dateStr, parsers);\n+        assertEquals(cal.getTime(), date);\n+        \n+        try {\n+            DateUtils.parseDate(\"PURPLE\", parsers);\n+            fail();\n+        } catch (ParseException ex) {}\n+        try {\n+            DateUtils.parseDate(\"197212AB\", parsers);\n+            fail();\n+        } catch (ParseException ex) {}\n+        try {\n+            DateUtils.parseDate(null, parsers);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.parseDate(dateStr, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddYears() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addYears(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addYears(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2001, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addYears(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 1999, 6, 5, 4, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddMonths() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addMonths(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addMonths(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 7, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addMonths(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 5, 5, 4, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddWeeks() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addWeeks(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addWeeks(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 12, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addWeeks(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);      // july\n+        assertDate(result, 2000, 5, 28, 4, 3, 2, 1);   // june\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddDays() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addDays(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addDays(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 6, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addDays(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 4, 4, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddHours() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addHours(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addHours(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 5, 3, 2, 1);\n+        \n+        result = DateUtils.addHours(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 3, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddMinutes() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addMinutes(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addMinutes(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 4, 2, 1);\n+        \n+        result = DateUtils.addMinutes(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 2, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddSeconds() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addSeconds(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addSeconds(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 3, 1);\n+        \n+        result = DateUtils.addSeconds(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 1, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddMilliseconds() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.addMilliseconds(base, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.addMilliseconds(base, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 2);\n+        \n+        result = DateUtils.addMilliseconds(base, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAddByField() throws Exception {\n+        Date base = new Date(MILLIS_TEST);\n+        Date result = DateUtils.add(base, Calendar.YEAR, 0);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2000, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.add(base, Calendar.YEAR, 1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 2001, 6, 5, 4, 3, 2, 1);\n+        \n+        result = DateUtils.add(base, Calendar.YEAR, -1);\n+        assertNotSame(base, result);\n+        assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n+        assertDate(result, 1999, 6, 5, 4, 3, 2, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void assertDate(Date date, int year, int month, int day, int hour, int min, int sec, int mil) throws Exception {\n+        GregorianCalendar cal = new GregorianCalendar();\n+        cal.setTime(date);\n+        assertEquals(year, cal.get(Calendar.YEAR));\n+        assertEquals(month, cal.get(Calendar.MONTH));\n+        assertEquals(day, cal.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(hour, cal.get(Calendar.HOUR_OF_DAY));\n+        assertEquals(min, cal.get(Calendar.MINUTE));\n+        assertEquals(sec, cal.get(Calendar.SECOND));\n+        assertEquals(mil, cal.get(Calendar.MILLISECOND));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests various values with the round method\n+     */\n+    public void testRound() throws Exception {\n+        // tests for public static Date round(Date date, int field)\n+        assertEquals(\"round year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round(date1, Calendar.YEAR));\n+        assertEquals(\"round year-2 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round(date2, Calendar.YEAR));\n+        assertEquals(\"round month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round(date1, Calendar.MONTH));\n+        assertEquals(\"round month-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.round(date2, Calendar.MONTH));\n+        assertEquals(\"round semimonth-0 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round(date0, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-1 failed\",\n+                dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.round(date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.round(date2, DateUtils.SEMI_MONTH));\n+        \n+        \n+        assertEquals(\"round date-1 failed\",\n+                dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.round(date1, Calendar.DATE));\n+        assertEquals(\"round date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.round(date2, Calendar.DATE));\n+        assertEquals(\"round hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.round(date1, Calendar.HOUR));\n+        assertEquals(\"round hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.round(date2, Calendar.HOUR));\n+        assertEquals(\"round minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.round(date1, Calendar.MINUTE));\n+        assertEquals(\"round minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.round(date2, Calendar.MINUTE));\n+        assertEquals(\"round second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round(date1, Calendar.SECOND));\n+        assertEquals(\"round second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round(date2, Calendar.SECOND));\n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.round(dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.round(dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round(dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 12:00:00.000\"),\n+                DateUtils.round(dateAmPm4, Calendar.AM_PM));\n+\n+        // tests for public static Date round(Object date, int field)\n+        assertEquals(\"round year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round((Object) date1, Calendar.YEAR));\n+        assertEquals(\"round year-2 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round((Object) date2, Calendar.YEAR));\n+        assertEquals(\"round month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round((Object) date1, Calendar.MONTH));\n+        assertEquals(\"round month-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.round((Object) date2, Calendar.MONTH));\n+        assertEquals(\"round semimonth-1 failed\",\n+                dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.round((Object) date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.round((Object) date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round date-1 failed\",\n+                dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.round((Object) date1, Calendar.DATE));\n+        assertEquals(\"round date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.round((Object) date2, Calendar.DATE));\n+        assertEquals(\"round hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.round((Object) date1, Calendar.HOUR));\n+        assertEquals(\"round hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.round((Object) date2, Calendar.HOUR));\n+        assertEquals(\"round minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.round((Object) date1, Calendar.MINUTE));\n+        assertEquals(\"round minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.round((Object) date2, Calendar.MINUTE));\n+        assertEquals(\"round second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round((Object) date1, Calendar.SECOND));\n+        assertEquals(\"round second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round((Object) date2, Calendar.SECOND));\n+        assertEquals(\"round calendar second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round((Object) cal1, Calendar.SECOND));\n+        assertEquals(\"round calendar second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round((Object) cal2, Calendar.SECOND));\n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.round((Object) dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.round((Object) dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round((Object) dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 12:00:00.000\"),\n+                DateUtils.round((Object) dateAmPm4, Calendar.AM_PM));\n+\n+        try {\n+            DateUtils.round((Date) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round((Calendar) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round((Object) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round(\"\", Calendar.SECOND);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            DateUtils.round(date1, -9999);\n+            fail();\n+        } catch(IllegalArgumentException ex) {}\n+\n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.round((Object) calAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"),\n+                DateUtils.round((Object) calAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.round((Object) calAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 4, 2002 12:00:00.000\"),\n+                DateUtils.round((Object) calAmPm4, Calendar.AM_PM));\n+        \n+        // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n+        // Test rounding across the beginning of daylight saving time\n+        TimeZone.setDefault(zone);\n+        dateTimeParser.setTimeZone(zone);\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round(date4, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round((Object) cal4, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round(date5, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round((Object) cal5, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round(date6, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round((Object) cal6, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round(date7, Calendar.DATE));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.round((Object) cal7, Calendar.DATE));\n+        \n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"),\n+                DateUtils.round(date4, Calendar.HOUR_OF_DAY));\n+        assertEquals(\"round MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"),\n+                DateUtils.round((Object) cal4, Calendar.HOUR_OF_DAY));\n+        if (SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.round(date5, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.round((Object) cal5, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.round(date6, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"),\n+                    DateUtils.round((Object) cal6, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"),\n+                    DateUtils.round(date7, Calendar.HOUR_OF_DAY));\n+            assertEquals(\"round MET date across DST change-over\",\n+                    dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"),\n+                    DateUtils.round((Object) cal7, Calendar.HOUR_OF_DAY));\n+        } else {\n+            this.warn(\"WARNING: Some date rounding tests not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+        }\n+        TimeZone.setDefault(defaultZone);\n+        dateTimeParser.setTimeZone(defaultZone);\n+    }\n+\n+    /**\n+     * Tests various values with the trunc method\n+     */\n+    public void testTruncate() throws Exception {\n+        // tests public static Date truncate(Date date, int field)\n+        assertEquals(\"truncate year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.truncate(date1, Calendar.YEAR));\n+        assertEquals(\"truncate year-2 failed\",\n+                dateParser.parse(\"January 1, 2001\"),\n+                DateUtils.truncate(date2, Calendar.YEAR));\n+        assertEquals(\"truncate month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.truncate(date1, Calendar.MONTH));\n+        assertEquals(\"truncate month-2 failed\",\n+                dateParser.parse(\"November 1, 2001\"),\n+                DateUtils.truncate(date2, Calendar.MONTH));\n+        assertEquals(\"truncate semimonth-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.truncate(date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.truncate(date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate date-1 failed\",\n+                dateParser.parse(\"February 12, 2002\"),\n+                DateUtils.truncate(date1, Calendar.DATE));\n+        assertEquals(\"truncate date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.truncate(date2, Calendar.DATE));\n+        assertEquals(\"truncate hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"),\n+                DateUtils.truncate(date1, Calendar.HOUR));\n+        assertEquals(\"truncate hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.truncate(date2, Calendar.HOUR));\n+        assertEquals(\"truncate minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"),\n+                DateUtils.truncate(date1, Calendar.MINUTE));\n+        assertEquals(\"truncate minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.truncate(date2, Calendar.MINUTE));\n+        assertEquals(\"truncate second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"),\n+                DateUtils.truncate(date1, Calendar.SECOND));\n+        assertEquals(\"truncate second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.truncate(date2, Calendar.SECOND));\n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate(dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate(dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate(dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate(dateAmPm4, Calendar.AM_PM));\n+\n+        // tests public static Date truncate(Object date, int field)\n+        assertEquals(\"truncate year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.truncate((Object) date1, Calendar.YEAR));\n+        assertEquals(\"truncate year-2 failed\",\n+                dateParser.parse(\"January 1, 2001\"),\n+                DateUtils.truncate((Object) date2, Calendar.YEAR));\n+        assertEquals(\"truncate month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.truncate((Object) date1, Calendar.MONTH));\n+        assertEquals(\"truncate month-2 failed\",\n+                dateParser.parse(\"November 1, 2001\"),\n+                DateUtils.truncate((Object) date2, Calendar.MONTH));\n+        assertEquals(\"truncate semimonth-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate date-1 failed\",\n+                dateParser.parse(\"February 12, 2002\"),\n+                DateUtils.truncate((Object) date1, Calendar.DATE));\n+        assertEquals(\"truncate date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.truncate((Object) date2, Calendar.DATE));\n+        assertEquals(\"truncate hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) date1, Calendar.HOUR));\n+        assertEquals(\"truncate hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.truncate((Object) date2, Calendar.HOUR));\n+        assertEquals(\"truncate minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"),\n+                DateUtils.truncate((Object) date1, Calendar.MINUTE));\n+        assertEquals(\"truncate minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.truncate((Object) date2, Calendar.MINUTE));\n+        assertEquals(\"truncate second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"),\n+                DateUtils.truncate((Object) date1, Calendar.SECOND));\n+        assertEquals(\"truncate second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.truncate((Object) date2, Calendar.SECOND));\n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM));\n+        \n+        assertEquals(\"truncate calendar second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"),\n+                DateUtils.truncate((Object) cal1, Calendar.SECOND));\n+        assertEquals(\"truncate calendar second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.truncate((Object) cal2, Calendar.SECOND));\n+        \n+        assertEquals(\"truncate ampm-1 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-2 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n+                DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-3 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM));\n+        assertEquals(\"truncate ampm-4 failed\",\n+                dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"),\n+                DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM));\n+        \n+        try {\n+            DateUtils.truncate((Date) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate((Calendar) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate((Object) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate(\"\", Calendar.SECOND);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+\n+        // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n+        // Test truncate across beginning of daylight saving time\n+        TimeZone.setDefault(zone);\n+        dateTimeParser.setTimeZone(zone);\n+        assertEquals(\"truncate MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.truncate(date3, Calendar.DATE));\n+        assertEquals(\"truncate MET date across DST change-over\",\n+                dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"),\n+                DateUtils.truncate((Object) cal3, Calendar.DATE));\n+        // Test truncate across end of daylight saving time\n+        assertEquals(\"truncate MET date across DST change-over\",\n+                dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"),\n+                DateUtils.truncate(date8, Calendar.DATE));\n+        assertEquals(\"truncate MET date across DST change-over\",\n+                dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"),\n+                DateUtils.truncate((Object) cal8, Calendar.DATE));\n+        TimeZone.setDefault(defaultZone);\n+        dateTimeParser.setTimeZone(defaultZone);\n+        \n+        // Bug 31395, large dates\n+        Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n+        GregorianCalendar endCal = new GregorianCalendar();\n+        endCal.setTime(endOfTime);\n+        try {\n+            DateUtils.truncate(endCal, Calendar.DATE);\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+        endCal.set(Calendar.YEAR, 280000001);\n+        try {\n+            DateUtils.truncate(endCal, Calendar.DATE);\n+            fail();\n+        } catch (ArithmeticException ex) {}\n+        endCal.set(Calendar.YEAR, 280000000);\n+        Calendar cal = DateUtils.truncate(endCal, Calendar.DATE);\n+        assertEquals(0, cal.get(Calendar.HOUR));\n+    }\n+\n+    /**\n+     * Tests for LANG-59\n+     *\n+     * see http://issues.apache.org/jira/browse/LANG-59\n+     */\n+    public void testTruncateLang59() throws Exception {\n+        if (!SystemUtils.isJavaVersionAtLeast(1.4f)) {\n+            this.warn(\"WARNING: Test for LANG-59 not run since the current version is \" + SystemUtils.JAVA_VERSION);\n+            return;\n+        }\n+\n+        // Set TimeZone to Mountain Time\n+        TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n+        TimeZone.setDefault(MST_MDT);\n+        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n+        format.setTimeZone(MST_MDT);\n+\n+        Date oct31_01MDT = new Date(1099206000000L); \n+\n+        Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n+        Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n+        Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n+        Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n+\n+        assertEquals(\"Check 00:00:00.000\", \"2004-10-31 00:00:00.000 MDT\", format.format(oct31MDT));\n+        assertEquals(\"Check 01:00:00.000\", \"2004-10-31 01:00:00.000 MDT\", format.format(oct31_01MDT));\n+        assertEquals(\"Check 01:02:00.000\", \"2004-10-31 01:02:00.000 MDT\", format.format(oct31_01_02MDT));\n+        assertEquals(\"Check 01:02:03.000\", \"2004-10-31 01:02:03.000 MDT\", format.format(oct31_01_02_03MDT));\n+        assertEquals(\"Check 01:02:03.004\", \"2004-10-31 01:02:03.004 MDT\", format.format(oct31_01_02_03_04MDT));\n+\n+        // ------- Demonstrate Problem -------\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(new Date(oct31_01MDT.getTime()));\n+        gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n+        assertEquals(\"Demonstrate Problem\", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);\n+\n+        // ---------- Test Truncate ----------\n+        assertEquals(\"Truncate Calendar.MILLISECOND\",\n+                oct31_01_02_03_04MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n+\n+        assertEquals(\"Truncate Calendar.SECOND\",\n+                   oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND));\n+\n+        assertEquals(\"Truncate Calendar.MINUTE\",\n+                      oct31_01_02MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.MINUTE));\n+\n+        assertEquals(\"Truncate Calendar.HOUR_OF_DAY\",\n+                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n+\n+        assertEquals(\"Truncate Calendar.HOUR\",\n+                         oct31_01MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.HOUR));\n+\n+        assertEquals(\"Truncate Calendar.DATE\",\n+                            oct31MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.DATE));\n+\n+\n+        // ---------- Test Round (down) ----------\n+        assertEquals(\"Round Calendar.MILLISECOND\",\n+                oct31_01_02_03_04MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MILLISECOND));\n+\n+        assertEquals(\"Round Calendar.SECOND\",\n+                   oct31_01_02_03MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.SECOND));\n+\n+        assertEquals(\"Round Calendar.MINUTE\",\n+                      oct31_01_02MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.MINUTE));\n+\n+        assertEquals(\"Round Calendar.HOUR_OF_DAY\",\n+                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR_OF_DAY));\n+\n+        assertEquals(\"Round Calendar.HOUR\",\n+                         oct31_01MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.HOUR));\n+\n+        assertEquals(\"Round Calendar.DATE\",\n+                            oct31MDT, DateUtils.round(oct31_01_02_03_04MDT, Calendar.DATE));\n+\n+        // restore default time zone\n+        TimeZone.setDefault(defaultZone);\n+    }\n+\n+    /**\n+     * Tests the iterator exceptions\n+     */\n+    public void testIteratorEx() throws Exception {\n+        try {\n+            DateUtils.iterator(Calendar.getInstance(), -9999);\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator(\"\", DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    /**\n+     * Tests the calendar iterator for week ranges\n+     */\n+    public void testWeekIterator() throws Exception {\n+        Calendar now = Calendar.getInstance();\n+        for (int i = 0; i< 7; i++) {\n+            Calendar today = DateUtils.truncate(now, Calendar.DATE);\n+            Calendar sunday = DateUtils.truncate(now, Calendar.DATE);\n+            sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));\n+            Calendar monday = DateUtils.truncate(now, Calendar.DATE);\n+            if (monday.get(Calendar.DAY_OF_WEEK) == 1) {\n+                //This is sunday... roll back 6 days\n+                monday.add(Calendar.DATE, -6);\n+            } else {\n+                monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));\n+            }\n+            Calendar centered = DateUtils.truncate(now, Calendar.DATE);\n+            centered.add(Calendar.DATE, -3);\n+            \n+            Iterator it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY);\n+            assertWeekIterator(it, sunday);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY);\n+            assertWeekIterator(it, monday);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE);\n+            assertWeekIterator(it, today);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);\n+            assertWeekIterator(it, centered);\n+            \n+            it = DateUtils.iterator((Object) now, DateUtils.RANGE_WEEK_CENTER);\n+            assertWeekIterator(it, centered);\n+            it = DateUtils.iterator((Object) now.getTime(), DateUtils.RANGE_WEEK_CENTER);\n+            assertWeekIterator(it, centered);\n+            try {\n+                it.next();\n+                fail();\n+            } catch (NoSuchElementException ex) {}\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);\n+            it.next();\n+            try {\n+                it.remove();\n+            } catch( UnsupportedOperationException ex) {}\n+            \n+            now.add(Calendar.DATE,1);\n+        }\n+    }\n+            \n+    /**\n+     * Tests the calendar iterator for month-based ranges\n+     */\n+    public void testMonthIterator() throws Exception {\n+        Iterator it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"January 27, 2002\"),\n+                dateParser.parse(\"March 2, 2002\"));\n+\n+        it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"January 28, 2002\"),\n+                dateParser.parse(\"March 3, 2002\"));\n+\n+        it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"October 28, 2001\"),\n+                dateParser.parse(\"December 1, 2001\"));\n+\n+        it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"October 29, 2001\"),\n+                dateParser.parse(\"December 2, 2001\"));\n+    }\n+\n+    /**\n+     * This checks that this is a 7 element iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other.\n+     */\n+    private static void assertWeekIterator(Iterator it, Calendar start) {\n+        Calendar end = (Calendar) start.clone();\n+        end.add(Calendar.DATE, 6);\n+\n+        assertWeekIterator(it, start, end);\n+    }\n+\n+    /**\n+     * Convenience method for when working with Date objects\n+     */\n+    private static void assertWeekIterator(Iterator it, Date start, Date end) {\n+        Calendar calStart = Calendar.getInstance();\n+        calStart.setTime(start);\n+        Calendar calEnd = Calendar.getInstance();\n+        calEnd.setTime(end);\n+\n+        assertWeekIterator(it, calStart, calEnd);\n+    }\n+\n+    /**\n+     * This checks that this is a 7 divisble iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other\n+     * (in addition to the proper start and stop dates)\n+     */\n+    private static void assertWeekIterator(Iterator it, Calendar start, Calendar end) {\n+        Calendar cal = (Calendar) it.next();\n+        assertEquals(\"\", start, cal, 0);\n+        Calendar last = null;\n+        int count = 1;\n+        while (it.hasNext()) {\n+            //Check this is just a date (no time component)\n+            assertEquals(\"\", cal, DateUtils.truncate(cal, Calendar.DATE), 0);\n+\n+            last = cal;\n+            cal = (Calendar) it.next();\n+            count++;\n+\n+            //Check that this is one day more than the last date\n+            last.add(Calendar.DATE, 1);\n+            assertEquals(\"\", last, cal, 0);\n+        }\n+        if (count % 7 != 0) {\n+            throw new AssertionFailedError(\"There were \" + count + \" days in this iterator\");\n+        }\n+        assertEquals(\"\", end, cal, 0);\n+    }\n+\n+    /**\n+     * Used to check that Calendar objects are close enough\n+     * delta is in milliseconds\n+     */\n+    private static void assertEquals(String message, Calendar cal1, Calendar cal2, long delta) {\n+        if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) {\n+            throw new AssertionFailedError(\n+                    message + \" expected \" + cal1.getTime() + \" but got \" + cal2.getTime());\n+        }\n+    }\n+\n+    void warn(String msg) {\n+        System.err.println(msg);\n+    }\n+}\n+\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.time;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.Calendar;\n+import java.util.TimeZone;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * TestCase for DurationFormatUtils.\n+ * \n+ * @author Apache Ant - DateUtilsTest\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Henri Yandell\n+ */\n+public class DurationFormatUtilsTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DurationFormatUtilsTest.class);\n+        suite.setName(\"DurationFormatUtils Tests\");\n+        return suite;\n+    }\n+\n+    public DurationFormatUtilsTest(String s) {\n+        super(s);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertNotNull(new DurationFormatUtils());\n+        Constructor[] cons = DurationFormatUtils.class.getDeclaredConstructors();\n+        assertEquals(1, cons.length);\n+        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n+        assertEquals(true, Modifier.isPublic(DurationFormatUtils.class.getModifiers()));\n+        assertEquals(false, Modifier.isFinal(DurationFormatUtils.class.getModifiers()));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testFormatDurationWords() {\n+        String text = null;\n+\n+        text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false);\n+        assertEquals(\"50 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false);\n+        assertEquals(\"1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false);\n+        assertEquals(\"2 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false);\n+        assertEquals(\"2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false);\n+        assertEquals(\"1 hour 12 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false);\n+        assertEquals(\"1 day 0 hours 0 minutes 0 seconds\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true);\n+        assertEquals(\"50 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true);\n+        assertEquals(\"1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true);\n+        assertEquals(\"2 minutes\", text);\n+        text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true);\n+        assertEquals(\"2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true);\n+        assertEquals(\"1 hour 12 minutes\", text);\n+        text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true);\n+        assertEquals(\"1 day\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true);\n+        assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true);\n+        assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true);\n+        assertEquals(\"0 days 0 hours 2 minutes\", text);\n+        text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true);\n+        assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true);\n+        assertEquals(\"0 days 1 hour 12 minutes\", text);\n+        text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true);\n+        assertEquals(\"1 day\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false);\n+        assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false);\n+        assertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false);\n+        assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false);\n+        assertEquals(\"0 days 1 hour 12 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);\n+        assertEquals(\"1 day 1 hour 12 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);\n+        assertEquals(\"2 days 1 hour 12 minutes 0 seconds\", text);\n+        for (int i = 2; i < 31; i++) {\n+            text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000, false, false);\n+            // assertEquals(i + \" days 0 hours 0 minutes 0 seconds\", text);\n+            //            \n+            // junit.framework.ComparisonFailure: expected:<25 days 0 hours 0 minutes 0...> but was:<-24 days -17 hours\n+            // -2 minutes -47...>\n+            // at junit.framework.Assert.assertEquals(Assert.java:81)\n+            // at junit.framework.Assert.assertEquals(Assert.java:87)\n+            // at\n+            // org.apache.commons.lang.time.DurationFormatUtilsTest.testFormatDurationWords(DurationFormatUtilsTest.java:124)\n+            // at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n+            // at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n+            // at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n+            // at java.lang.reflect.Method.invoke(Method.java:324)\n+            // at junit.framework.TestCase.runTest(TestCase.java:154)\n+            // at junit.framework.TestCase.runBare(TestCase.java:127)\n+            // at junit.framework.TestResult$1.protect(TestResult.java:106)\n+            // at junit.framework.TestResult.runProtected(TestResult.java:124)\n+            // at junit.framework.TestResult.run(TestResult.java:109)\n+            // at junit.framework.TestCase.run(TestCase.java:118)\n+            // at junit.framework.TestSuite.runTest(TestSuite.java:208)\n+            // at junit.framework.TestSuite.run(TestSuite.java:203)\n+            // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)\n+            // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)\n+            // at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\n+        }\n+    }\n+\n+    /**\n+     * Tests that \"1 <unit>s\" gets converted to \"1 <unit>\" but that \"11 <unit>s\" is left alone.\n+     */\n+    public void testFormatDurationPluralWords() {\n+        long oneSecond = 1000;\n+        long oneMinute = oneSecond * 60;\n+        long oneHour = oneMinute * 60;\n+        long oneDay = oneHour * 24;\n+        String text = null;\n+\n+        text = DurationFormatUtils.formatDurationWords(oneSecond, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneSecond * 2, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 2 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneSecond * 11, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 11 seconds\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(oneMinute, false, false);\n+        assertEquals(\"0 days 0 hours 1 minute 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneMinute * 2, false, false);\n+        assertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneMinute * 11, false, false);\n+        assertEquals(\"0 days 0 hours 11 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneMinute + oneSecond, false, false);\n+        assertEquals(\"0 days 0 hours 1 minute 1 second\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(oneHour, false, false);\n+        assertEquals(\"0 days 1 hour 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneHour * 2, false, false);\n+        assertEquals(\"0 days 2 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneHour * 11, false, false);\n+        assertEquals(\"0 days 11 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneHour + oneMinute + oneSecond, false, false);\n+        assertEquals(\"0 days 1 hour 1 minute 1 second\", text);\n+\n+        text = DurationFormatUtils.formatDurationWords(oneDay, false, false);\n+        assertEquals(\"1 day 0 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneDay * 2, false, false);\n+        assertEquals(\"2 days 0 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneDay * 11, false, false);\n+        assertEquals(\"11 days 0 hours 0 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatDurationWords(oneDay + oneHour + oneMinute + oneSecond, false, false);\n+        assertEquals(\"1 day 1 hour 1 minute 1 second\", text);\n+    }\n+\n+    public void testFormatDurationHMS() {\n+        long time = 0;\n+        assertEquals(\"0:00:00.000\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 1;\n+        assertEquals(\"0:00:00.001\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 15;\n+        assertEquals(\"0:00:00.015\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 165;\n+        assertEquals(\"0:00:00.165\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 1675;\n+        assertEquals(\"0:00:01.675\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 13465;\n+        assertEquals(\"0:00:13.465\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 72789;\n+        assertEquals(\"0:01:12.789\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 12789 + 32 * 60000;\n+        assertEquals(\"0:32:12.789\", DurationFormatUtils.formatDurationHMS(time));\n+\n+        time = 12789 + 62 * 60000;\n+        assertEquals(\"1:02:12.789\", DurationFormatUtils.formatDurationHMS(time));\n+    }\n+\n+    public void testFormatDurationISO() {\n+        assertEquals(\"P0Y0M0DT0H0M0.000S\", DurationFormatUtils.formatDurationISO(0L));\n+        assertEquals(\"P0Y0M0DT0H0M0.001S\", DurationFormatUtils.formatDurationISO(1L));\n+        assertEquals(\"P0Y0M0DT0H0M0.010S\", DurationFormatUtils.formatDurationISO(10L));\n+        assertEquals(\"P0Y0M0DT0H0M0.100S\", DurationFormatUtils.formatDurationISO(100L));\n+        assertEquals(\"P0Y0M0DT0H1M15.321S\", DurationFormatUtils.formatDurationISO(75321L));\n+    }\n+\n+    public void testFormatDuration() {\n+        long duration = 0;\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"y\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"M\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"d\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"H\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"m\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"s\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"S\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatDuration(duration, \"SSSS\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatDuration(duration, \"yyyy\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatDuration(duration, \"yyMM\"));\n+\n+        duration = 60 * 1000;\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"y\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"M\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"d\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatDuration(duration, \"H\"));\n+        assertEquals(\"1\", DurationFormatUtils.formatDuration(duration, \"m\"));\n+        assertEquals(\"60\", DurationFormatUtils.formatDuration(duration, \"s\"));\n+        assertEquals(\"60000\", DurationFormatUtils.formatDuration(duration, \"S\"));\n+        assertEquals(\"01:00\", DurationFormatUtils.formatDuration(duration, \"mm:ss\"));\n+\n+        Calendar base = Calendar.getInstance();\n+        base.set(2000, 0, 1, 0, 0, 0);\n+        base.set(Calendar.MILLISECOND, 0);\n+\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2003, 1, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        duration = cal.getTime().getTime() - base.getTime().getTime(); // duration from 2000-01-01 to cal\n+        // don't use 1970 in test as time zones were less reliable in 1970 than now\n+        // remember that duration formatting ignores time zones, working on strict hour lengths\n+        int days = 366 + 365 + 365 + 31;\n+        assertEquals(\"0 0 \" + days, DurationFormatUtils.formatDuration(duration, \"y M d\"));\n+    }\n+\n+    public void testFormatPeriodISO() {\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar base = Calendar.getInstance(timeZone);\n+        base.set(1970, 0, 1, 0, 0, 0);\n+        base.set(Calendar.MILLISECOND, 0);\n+\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002, 1, 23, 9, 11, 12);\n+        cal.set(Calendar.MILLISECOND, 1);\n+        String text;\n+        // repeat a test from testDateTimeISO to compare extended and not extended.\n+        text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+        // test fixture is the same as above, but now with extended format.\n+        text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(),\n+                DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n+        assertEquals(\"P32Y1M22DT9H11M12.001S\", text);\n+        // test fixture from example in http://www.w3.org/TR/xmlschema-2/#duration\n+        cal.set(1971, 1, 3, 10, 30, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        text = DurationFormatUtils.formatPeriod(base.getTime().getTime(), cal.getTime().getTime(),\n+                DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n+        assertEquals(\"P1Y1M2DT10H30M0.000S\", text);\n+        // want a way to say 'don't print the seconds in format()' or other fields for that matter:\n+        // assertEquals(\"P1Y2M3DT10H30M\", text);\n+    }\n+\n+    public void testFormatPeriod() {\n+        Calendar cal1970 = Calendar.getInstance();\n+        cal1970.set(1970, 0, 1, 0, 0, 0);\n+        cal1970.set(Calendar.MILLISECOND, 0);\n+        long time1970 = cal1970.getTime().getTime();\n+\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"y\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"M\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"d\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"H\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"m\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"s\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"S\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"SSSS\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"yyyy\"));\n+        assertEquals(\"0000\", DurationFormatUtils.formatPeriod(time1970, time1970, \"yyMM\"));\n+\n+        long time = time1970 + 60 * 1000;\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time, \"y\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time, \"M\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time, \"d\"));\n+        assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time, \"H\"));\n+        assertEquals(\"1\", DurationFormatUtils.formatPeriod(time1970, time, \"m\"));\n+        assertEquals(\"60\", DurationFormatUtils.formatPeriod(time1970, time, \"s\"));\n+        assertEquals(\"60000\", DurationFormatUtils.formatPeriod(time1970, time, \"S\"));\n+        assertEquals(\"01:00\", DurationFormatUtils.formatPeriod(time1970, time, \"mm:ss\"));\n+\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(1973, 6, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        time = cal.getTime().getTime();\n+        assertEquals(\"36\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\"));\n+        assertEquals(\"3 years 6 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\"));\n+        assertEquals(\"03/06\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\"));\n+\n+        cal.set(1973, 10, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        time = cal.getTime().getTime();\n+        assertEquals(\"310\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\"));\n+        assertEquals(\"3 years 10 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\"));\n+        assertEquals(\"03/10\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\"));\n+\n+        cal.set(1974, 0, 1, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        time = cal.getTime().getTime();\n+        assertEquals(\"40\", DurationFormatUtils.formatPeriod(time1970, time, \"yM\"));\n+        assertEquals(\"4 years 0 months\", DurationFormatUtils.formatPeriod(time1970, time, \"y' years 'M' months'\"));\n+        assertEquals(\"04/00\", DurationFormatUtils.formatPeriod(time1970, time, \"yy/MM\"));\n+        assertEquals(\"48\", DurationFormatUtils.formatPeriod(time1970, time, \"M\"));\n+        assertEquals(\"48\", DurationFormatUtils.formatPeriod(time1970, time, \"MM\"));\n+        assertEquals(\"048\", DurationFormatUtils.formatPeriod(time1970, time, \"MMM\"));\n+    }\n+\n+    public void testLexx() {\n+        // tests each constant\n+        assertArrayEquals(new DurationFormatUtils.Token[]{\n+            new DurationFormatUtils.Token(DurationFormatUtils.y, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.M, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.d, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.m, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.s, 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.S, 1)}, DurationFormatUtils.lexx(\"yMdHmsS\"));\n+\n+        // tests the ISO8601-like\n+        assertArrayEquals(new DurationFormatUtils.Token[]{\n+            new DurationFormatUtils.Token(DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\":\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.m, 2),\n+            new DurationFormatUtils.Token(new StringBuffer(\":\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.s, 2),\n+            new DurationFormatUtils.Token(new StringBuffer(\".\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.S, 3)}, DurationFormatUtils.lexx(\"H:mm:ss.SSS\"));\n+\n+        // test the iso extended format\n+        assertArrayEquals(new DurationFormatUtils.Token[]{\n+            new DurationFormatUtils.Token(new StringBuffer(\"P\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.y, 4),\n+            new DurationFormatUtils.Token(new StringBuffer(\"Y\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.M, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"M\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.d, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"DT\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.H, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"H\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.m, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"M\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.s, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\".\"), 1),\n+            new DurationFormatUtils.Token(DurationFormatUtils.S, 1),\n+            new DurationFormatUtils.Token(new StringBuffer(\"S\"), 1)}, DurationFormatUtils\n+                .lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN));\n+\n+        // test failures in equals\n+        DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4);\n+        assertFalse(\"Token equal to non-Token class. \", token.equals(new Object()));\n+        assertFalse(\"Token equal to Token with wrong value class. \", token.equals(new DurationFormatUtils.Token(\n+                new Object())));\n+        assertFalse(\"Token equal to Token with different count. \", token.equals(new DurationFormatUtils.Token(\n+                DurationFormatUtils.y, 1)));\n+        DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(new Integer(1), 4);\n+        assertTrue(\"Token with Number value not equal to itself. \", numToken.equals(numToken));\n+    }\n+\n+\n+    // http://issues.apache.org/bugzilla/show_bug.cgi?id=38401\n+    public void testBugzilla38401() {\n+        Calendar cal1 = Calendar.getInstance();\n+        cal1.set(2006, 0, 26, 18, 47, 34);\n+        cal1.set(Calendar.MILLISECOND, 0);\n+        Calendar cal2 = Calendar.getInstance();\n+        cal2.set(2006, 1, 26, 10, 47, 34);\n+        cal2.set(Calendar.MILLISECOND, 0);\n+\n+        assertEquals( \"0000/00/30 16:00:00 000\", DurationFormatUtils.formatPeriod(cal1.getTime().getTime(), cal2.getTime().getTime(), \"yyyy/MM/dd HH:mm:ss SSS\") );\n+    }\n+\n+    private void assertArrayEquals(DurationFormatUtils.Token[] obj1, DurationFormatUtils.Token[] obj2) {\n+        assertEquals(\"Arrays are unequal length. \", obj1.length, obj2.length);\n+        for (int i = 0; i < obj1.length; i++) {\n+            assertTrue(\"Index \" + i + \" not equal, \" + obj1[i] + \" vs \" + obj2, obj1[i].equals(obj2[i]));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/time/FastDateFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.time.FastDateFormat}.\n+ *\n+ * @author Sean Schofield\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Fredrik Westermarck\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class FastDateFormatTest extends TestCase {\n+\n+    public FastDateFormatTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FastDateFormatTest.class);\n+        suite.setName(\"FastDateFormat Tests\");\n+\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    public void test_getInstance() {\n+        FastDateFormat format1 = FastDateFormat.getInstance();\n+        FastDateFormat format2 = FastDateFormat.getInstance();\n+        assertSame(format1, format2);\n+        assertEquals(new SimpleDateFormat().toPattern(), format1.getPattern());\n+    }\n+\n+    public void test_getInstance_String() {\n+        FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+        FastDateFormat format2 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+        FastDateFormat format3 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+\n+        assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+        assertSame(format2, format3);\n+        assertEquals(\"MM/DD/yyyy\", format1.getPattern());\n+        assertEquals(TimeZone.getDefault(), format1.getTimeZone());\n+        assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+        assertEquals(false, format1.getTimeZoneOverridesCalendar());\n+        assertEquals(false, format2.getTimeZoneOverridesCalendar());\n+    }\n+\n+    public void test_getInstance_String_TimeZone() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+\n+            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                    TimeZone.getTimeZone(\"Atlantic/Reykjavik\"));\n+            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n+            FastDateFormat format4 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n+            FastDateFormat format5 = FastDateFormat.getInstance(\"MM-DD-yyyy\", TimeZone.getDefault());\n+            FastDateFormat format6 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+\n+            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+            assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n+            assertEquals(true, format1.getTimeZoneOverridesCalendar());\n+            assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+            assertEquals(false, format2.getTimeZoneOverridesCalendar());\n+            assertSame(format3, format4);\n+            assertTrue(format3 != format5); // -- junit 3.8 version -- assertFalse(format3 == format5);\n+            assertTrue(format4 != format6); // -- junit 3.8 version -- assertFalse(format3 == format5);\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+            TimeZone.setDefault(realDefaultZone);\n+        }\n+    }\n+\n+    public void test_getInstance_String_Locale() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+\n+            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+            assertSame(format1, format3);\n+            assertSame(Locale.GERMANY, format1.getLocale());\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+        }\n+    }\n+\n+    public void test_getInstance_String_TimeZone_Locale() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+\n+            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                    TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), Locale.GERMANY);\n+            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                    TimeZone.getDefault(), Locale.GERMANY);\n+\n+            assertTrue(format1 != format2); // -- junit 3.8 version -- assertNotSame(format1, format2);\n+            assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n+            assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+            assertEquals(TimeZone.getDefault(), format3.getTimeZone());\n+            assertEquals(true, format1.getTimeZoneOverridesCalendar());\n+            assertEquals(false, format2.getTimeZoneOverridesCalendar());\n+            assertEquals(true, format3.getTimeZoneOverridesCalendar());\n+            assertEquals(Locale.GERMANY, format1.getLocale());\n+            assertEquals(Locale.GERMANY, format2.getLocale());\n+            assertEquals(Locale.GERMANY, format3.getLocale());\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+            TimeZone.setDefault(realDefaultZone);\n+        }\n+    }\n+\n+    public void testFormat() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+            FastDateFormat fdf = null;\n+            SimpleDateFormat sdf = null;\n+\n+            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n+            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n+            Date date1 = cal1.getTime();\n+            Date date2 = cal2.getTime();\n+            long millis1 = date1.getTime();\n+            long millis2 = date2.getTime();\n+\n+            fdf = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            assertEquals(sdf.format(date1), fdf.format(date1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(millis1));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(millis2));\n+\n+            fdf = FastDateFormat.getInstance(\"Z\");\n+            assertEquals(\"-0500\", fdf.format(date1));\n+            assertEquals(\"-0500\", fdf.format(cal1));\n+            assertEquals(\"-0500\", fdf.format(millis1));\n+\n+            fdf = FastDateFormat.getInstance(\"Z\");\n+            assertEquals(\"-0400\", fdf.format(date2));\n+            assertEquals(\"-0400\", fdf.format(cal2));\n+            assertEquals(\"-0400\", fdf.format(millis2));\n+\n+            fdf = FastDateFormat.getInstance(\"ZZ\");\n+            assertEquals(\"-05:00\", fdf.format(date1));\n+            assertEquals(\"-05:00\", fdf.format(cal1));\n+            assertEquals(\"-05:00\", fdf.format(millis1));\n+\n+            fdf = FastDateFormat.getInstance(\"ZZ\");\n+            assertEquals(\"-04:00\", fdf.format(date2));\n+            assertEquals(\"-04:00\", fdf.format(cal2));\n+            assertEquals(\"-04:00\", fdf.format(millis2));\n+\n+            String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n+                \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n+            fdf = FastDateFormat.getInstance(pattern);\n+            sdf = new SimpleDateFormat(pattern);\n+            assertEquals(sdf.format(date1), fdf.format(date1));\n+            assertEquals(sdf.format(date2), fdf.format(date2));\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+            TimeZone.setDefault(realDefaultZone);\n+        }\n+    }\n+\n+    /**\n+     * Test case for {@link FastDateFormat#getDateInstance(int, java.util.Locale)}.\n+     */\n+    public void testShortDateStyleWithLocales() {\n+        Locale usLocale = Locale.US;\n+        Locale swedishLocale = new Locale(\"sv\", \"SE\");\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2004, 1, 3);\n+        FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, usLocale);\n+        assertEquals(\"2/3/04\", fdf.format(cal));\n+\n+        fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, swedishLocale);\n+        assertEquals(\"2004-02-03\", fdf.format(cal));\n+\n+    }\n+\n+    /**\n+     * Tests that pre-1000AD years get padded with yyyy\n+     */\n+    public void testLowYearPadding() {\n+        Calendar cal = Calendar.getInstance();\n+        FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/DD\");\n+\n+        cal.set(1,0,1);\n+        assertEquals(\"0001/01/01\", format.format(cal));\n+        cal.set(10,0,1);\n+        assertEquals(\"0010/01/01\", format.format(cal));\n+        cal.set(100,0,1);\n+        assertEquals(\"0100/01/01\", format.format(cal));\n+        cal.set(999,0,1);\n+        assertEquals(\"0999/01/01\", format.format(cal));\n+    }\n+    /**\n+     * Show Bug #39410 is solved\n+     */\n+    public void testMilleniumBug() {\n+        Calendar cal = Calendar.getInstance();\n+        FastDateFormat format = FastDateFormat.getInstance(\"dd.MM.yyyy\");\n+\n+        cal.set(1000,0,1);\n+        assertEquals(\"01.01.1000\", format.format(cal));\n+    }\n+\n+    /**\n+     * testLowYearPadding showed that the date was buggy\n+     * This test confirms it, getting 366 back as a date\n+     */\n+     // TODO: Fix this problem\n+    public void testSimpleDate() {\n+        Calendar cal = Calendar.getInstance();\n+        FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/dd\");\n+\n+        cal.set(2004,11,31);\n+        assertEquals(\"2004/12/31\", format.format(cal));\n+        cal.set(999,11,31);\n+        assertEquals(\"0999/12/31\", format.format(cal));\n+        cal.set(1,2,2);\n+        assertEquals(\"0001/03/02\", format.format(cal));\n+    }\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/time/StopWatchTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * TestCase for StopWatch.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class StopWatchTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StopWatchTest.class);\n+        suite.setName(\"StopWatch Tests\");\n+        return suite;\n+    }\n+\n+    public StopWatchTest(String s) {\n+        super(s);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStopWatchSimple(){\n+        StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.stop();\n+        long time = watch.getTime();\n+        assertEquals(time, watch.getTime());\n+        \n+        assertTrue(time >= 500);\n+        assertTrue(time < 700);\n+        \n+        watch.reset();\n+        assertEquals(0, watch.getTime());\n+    }\n+    \n+    public void testStopWatchSimpleGet(){\n+        StopWatch watch = new StopWatch();\n+        assertEquals(0, watch.getTime());\n+        assertEquals(\"0:00:00.000\", watch.toString());\n+        \n+        watch.start();\n+            try {Thread.sleep(500);} catch (InterruptedException ex) {}\n+        assertTrue(watch.getTime() < 2000);\n+    }\n+    \n+    public void testStopWatchSplit(){\n+        StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.split();\n+        long splitTime = watch.getSplitTime();\n+        String splitStr = watch.toSplitString();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.unsplit();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.stop();\n+        long totalTime = watch.getTime();\n+\n+        assertEquals(\"Formatted split string not the correct length\", \n+                     splitStr.length(), 11);\n+        assertTrue(splitTime >= 500);\n+        assertTrue(splitTime < 700);\n+        assertTrue(totalTime >= 1500);\n+        assertTrue(totalTime < 1900);\n+    }\n+    \n+    public void testStopWatchSuspend(){\n+        StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.suspend();\n+        long suspendTime = watch.getTime();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.resume();\n+            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        watch.stop();\n+        long totalTime = watch.getTime();\n+        \n+        assertTrue(suspendTime >= 500);\n+        assertTrue(suspendTime < 700);\n+        assertTrue(totalTime >= 1000);\n+        assertTrue(totalTime < 1300);\n+    }\n+\n+    // test bad states\n+    public void testBadStates() {\n+        StopWatch watch = new StopWatch();\n+        try {\n+            watch.stop();\n+            fail(\"Calling stop on an unstarted StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.stop();\n+            fail(\"Calling stop on an unstarted StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.suspend();\n+            fail(\"Calling suspend on an unstarted StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.split();\n+            fail(\"Calling split on a non-running StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.unsplit();\n+            fail(\"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.resume();\n+            fail(\"Calling resume on an unsuspended StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        watch.start();\n+\n+        try {\n+            watch.start();\n+            fail(\"Calling start on a started StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.unsplit();\n+            fail(\"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.getSplitTime();\n+            fail(\"Calling getSplitTime on an unsplit StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        try {\n+            watch.resume();\n+            fail(\"Calling resume on an unsuspended StopWatch should throw an exception. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+        watch.stop();\n+\n+        try {\n+            watch.start();\n+            fail(\"Calling start on a stopped StopWatch should throw an exception as it needs to be reset. \");\n+        } catch(IllegalStateException ise) {\n+            // expected\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/LANG_2_2_RC1/src/test/org/apache/commons/lang/time/TimeTestSuite.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test suite for the Time package.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id$\n+ */\n+public class TimeTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public TimeTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Time Tests\");\n+        suite.addTest(DateUtilsTest.suite());\n+        suite.addTest(DateFormatUtilsTest.suite());\n+        suite.addTest(DurationFormatUtilsTest.suite());\n+        suite.addTest(StopWatchTest.suite());\n+        suite.addTest(FastDateFormatTest.suite());\n+        return suite;\n+    }\n+}", "timestamp": 1158726664, "metainfo": ""}