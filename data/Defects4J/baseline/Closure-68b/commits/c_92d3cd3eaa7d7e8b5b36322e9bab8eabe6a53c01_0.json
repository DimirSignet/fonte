{"sha": "92d3cd3eaa7d7e8b5b36322e9bab8eabe6a53c01", "log": "Use new @modifies{this} annotations  R=avd DELTA=214  (185 added, 4 deleted, 25 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=249465   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n       DiagnosticType.error(\n           \"JSC_INVALID_NO_SIDE_EFFECT_ANNOTATION\",\n           \"@nosideeffects may only appear in externs files.\");\n+\n+  static final DiagnosticType INVALID_MODIFIES_ANNOTATION =\n+    DiagnosticType.error(\n+        \"JSC_INVALID_MODIFIES_ANNOTATION\",\n+        \"@modifies may only appear in externs files.\");\n \n   private final AbstractCompiler compiler;\n   private final DefinitionProvider definitionProvider;\n       FunctionInformation sideEffectInfo = new FunctionInformation(inExterns);\n       functionSideEffectMap.put(node, sideEffectInfo);\n \n-      if (hasNoSideEffectsAnnotation(node, parent, gramp)) {\n+      JSDocInfo info = getJSDocInfoForFunction(node, parent, gramp);\n+      if (info != null) {\n+        boolean hasSpecificSideEffects = false;\n+        if (hasSideEffectsThisAnnotation(info)) {\n+          if (inExterns) {\n+            hasSpecificSideEffects = true;\n+            sideEffectInfo.setTaintsThis();\n+          } else {\n+            traversal.report(node, INVALID_MODIFIES_ANNOTATION);\n+          }\n+        }\n+\n+        if (hasSideEffectsArgumentsAnnotation(info)) {\n+          if (inExterns) {\n+            hasSpecificSideEffects = true;\n+            sideEffectInfo.setTaintsArguments();\n+          } else {\n+            traversal.report(node, INVALID_MODIFIES_ANNOTATION);\n+          }\n+        }\n+\n+        if (!hasSpecificSideEffects) {\n+          if (hasNoSideEffectsAnnotation(info)) {\n+            if (inExterns) {\n+              sideEffectInfo.setIsPure();\n+            } else {\n+              traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n+            }\n+          } else if (inExterns) {\n+            sideEffectInfo.setTaintsGlobalState();\n+          }\n+        }\n+      } else {\n         if (inExterns) {\n-          sideEffectInfo.setIsPure();\n-        } else {\n-          traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n-        }\n-      } else if (inExterns) {\n-        sideEffectInfo.setTaintsGlobalState();\n+          sideEffectInfo.setTaintsGlobalState();\n+        }\n       }\n     }\n \n     }\n \n     /**\n+     * Get the doc info associated with the function.\n+     */\n+    private JSDocInfo getJSDocInfoForFunction(\n+        Node node, Node parent, Node gramp) {\n+      JSDocInfo info = node.getJSDocInfo();\n+      if (info != null) {\n+        return info;\n+      } else if (NodeUtil.isName(parent)) {\n+        return gramp.hasOneChild() ? gramp.getJSDocInfo() : null;\n+      } else if (NodeUtil.isAssign(parent)) {\n+        return parent.getJSDocInfo();\n+      } else {\n+        return null;\n+      }\n+    }\n+\n+    /**\n      * Get the value of the @nosideeffects annotation stored in the\n      * doc info.\n      */\n-    private boolean hasNoSideEffectsAnnotation(Node node,\n-                                               Node parent,\n-                                               Node gramp) {\n-      {\n-        JSDocInfo docInfo = node.getJSDocInfo();\n-        if (docInfo != null && docInfo.isNoSideEffects()) {\n-          return true;\n-        }\n-      }\n-\n-      if (NodeUtil.isName(parent)) {\n-        JSDocInfo docInfo = gramp.getJSDocInfo();\n-        return gramp.hasOneChild() &&\n-            docInfo != null &&\n-            docInfo.isNoSideEffects();\n-      } else if (NodeUtil.isAssign(parent)) {\n-        JSDocInfo docInfo = parent.getJSDocInfo();\n-        return docInfo != null && docInfo.isNoSideEffects();\n-      } else {\n-        return false;\n-      }\n+    private boolean hasNoSideEffectsAnnotation(JSDocInfo docInfo) {\n+      Preconditions.checkNotNull(docInfo);\n+      return docInfo.isNoSideEffects();\n+    }\n+\n+    /**\n+     * Get the value of the @modifies{this} annotation stored in the\n+     * doc info.\n+     */\n+    private boolean hasSideEffectsThisAnnotation(JSDocInfo docInfo) {\n+      Preconditions.checkNotNull(docInfo);\n+      return (docInfo.getModifies().contains(\"this\"));\n+    }\n+\n+    /**\n+     * @returns Whether the @modifies annotation includes \"arguments\"\n+     * or any named parameters.\n+     */\n+    private boolean hasSideEffectsArgumentsAnnotation(JSDocInfo docInfo) {\n+      Preconditions.checkNotNull(docInfo);\n+      Set<String> modifies = docInfo.getModifies();\n+      // TODO(johnlenz): if we start tracking parameters individually\n+      // this should simply be a check for \"arguments\".\n+      return (modifies.size() > 1\n+          || (modifies.size() == 1 && !modifies.contains(\"this\")));\n     }\n   }\n \n     private boolean functionThrows = false;\n     private boolean taintsGlobalState = false;\n     private boolean taintsThis = false;\n+    private boolean taintsArguments = false;\n     private boolean taintsUnknown = false;\n     private boolean taintsReturn = false;\n \n       return !(functionThrows ||\n                taintsGlobalState ||\n                taintsThis ||\n+               taintsArguments ||\n                taintsUnknown);\n     }\n \n     }\n \n     /**\n+     * Marks the function as having \"modifies arguments\" side effects.\n+     */\n+    void setTaintsArguments() {\n+      taintsArguments = true;\n+      checkInvariant();\n+    }\n+\n+    /**\n      * Marks the function as having \"throw\" side effects.\n      */\n     void setFunctionThrows() {\n      * Returns true if function mutates global state.\n      */\n     boolean mutatesGlobalState() {\n-      return taintsGlobalState || taintsUnknown;\n+      // TODO(johnlenz): track arguments separately.\n+      return taintsGlobalState || taintsArguments || taintsUnknown;\n     }\n \n     /**\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n \n   private static String kExterns =\n       CompilerTypeTestCase.DEFAULT_EXTERNS +\n+      \"/**@nosideeffects*/ function externSENone(){}\\n\" +\n+\n+      \"/**@modifies{this}*/ function externSEThis(){}\\n\" +\n+      \"/**@constructor\\n\" +\n+      \" * @modifies{this}*/\\n\" +\n+      \"function externObjSEThis(){}\\n\" +\n+\n+      \"/**\\n\" +\n+      \" * @param {string} s id.\\n\" +\n+      \" * @return {string}\\n\" +\n+      \" * @modifies{this}\\n\" +\n+      \" */\\n\" +\n+      \"externObjSEThis.prototype.externObjSEThisMethod = function(s) {};\" +\n+\n+      \"/**\\n\" +\n+      \" * @param {string} s id.\\n\" +\n+      \" * @return {string}\\n\" +\n+      \" * @modifies{arguments}\\n\" +\n+      \" */\\n\" +\n+      \"externObjSEThis.prototype.externObjSEThisMethod2 = function(s) {};\" +\n+\n       \"/**@nosideeffects*/function Error(){}\" +\n \n       \"function externSef1(){}\" +\n     noSideEffectCalls.clear();\n     localResultCalls.clear();\n     boolean regExpHaveSideEffects = true;\n+  }\n+\n+  public void testAnnotationInExterns_new1() throws Exception {\n+    checkMarkedCalls(\"externSENone()\",\n+        ImmutableList.<String>of(\"externSENone\"));\n+  }\n+\n+  public void testAnnotationInExterns_new2() throws Exception {\n+    checkMarkedCalls(\"externSEThis()\",\n+        ImmutableList.<String>of());\n+  }\n+\n+  public void testAnnotationInExterns_new3() throws Exception {\n+    checkMarkedCalls(\"new externObjSEThis()\",\n+        ImmutableList.<String>of(\"externObjSEThis\"));\n+  }\n+\n+  public void testAnnotationInExterns_new4() throws Exception {\n+    // TODO(johnlenz): We would like the entire expression containing\n+    // \"externObjSEThisMethod\" to be considered side-effect free\n+    // in this context, but not yet, and maybe not here.\n+    checkMarkedCalls(\"new externObjSEThis().externObjSEThisMethod('')\",\n+        ImmutableList.<String>of(\"externObjSEThis\"));\n+  }\n+\n+  public void testAnnotationInExterns_new5() throws Exception {\n+    checkMarkedCalls(\n+        \"function f() { new externObjSEThis() };\" +\n+        \"f();\",\n+        ImmutableList.<String>of(\"externObjSEThis\", \"f\"));\n+  }\n+\n+  public void testAnnotationInExterns_new6() throws Exception {\n+    // While \"externObjSEThisMethod\" has modifies \"this\"\n+    // it does not have global side-effects with \"this\" is\n+    // a known local value.\n+    checkMarkedCalls(\n+        \"function f() {\" +\n+        \"  new externObjSEThis().externObjSEThisMethod('') \" +\n+        \"};\" +\n+        \"f();\",\n+        ImmutableList.<String>of(\"externObjSEThis\", \"f\"));\n+  }\n+\n+  public void testAnnotationInExterns_new7() throws Exception {\n+    // While \"externObjSEThisMethod\" has modifies \"this\"\n+    // it does not have global side-effects with \"this\" is\n+    // a known local value.\n+    checkMarkedCalls(\n+        \"function f() {\" +\n+        \"  var x = new externObjSEThis(); \" +\n+        \"  x.externObjSEThisMethod('') \" +\n+        \"};\" +\n+        \"f();\",\n+        ImmutableList.<String>of(\"externObjSEThis\", \"f\"));\n+  }\n+\n+  public void testAnnotationInExterns_new8() throws Exception {\n+    // \"externObjSEThisMethod\" modifies \"this\", the 'this'\n+    // is not a known local value, so it must be assumed it is to\n+    // have global side-effects.\n+    checkMarkedCalls(\n+        \"function f(x) {\" +\n+        \"  x.externObjSEThisMethod('') \" +\n+        \"};\" +\n+        \"f(new externObjSEThis());\",\n+        ImmutableList.<String>of(\"externObjSEThis\"));\n+  }\n+\n+  public void testAnnotationInExterns_new9() throws Exception {\n+    // \"externObjSEThisMethod\" modifies \"this\", the 'this'\n+    // is not a known local value, so it must be assumed it is to\n+    // have global side-effects.  All possible values of \"x\" are considered\n+    // as no intraprocedural data flow is done.\n+    checkMarkedCalls(\n+        \"function f(x) {\" +\n+        \"  x = new externObjSEThis(); \" +\n+        \"  x.externObjSEThisMethod('') \" +\n+        \"};\" +\n+        \"f(g);\",\n+        ImmutableList.<String>of(\"externObjSEThis\"));\n+  }\n+\n+\n+  public void testAnnotationInExterns_new10() throws Exception {\n+    // While \"externObjSEThisMethod2\" only modifies it arguments\n+    // and the arguments are known local values, we don't\n+    // yet connect the dots, and \"f\" is consider to have\n+    // global side-effects.\n+    checkMarkedCalls(\n+        \"function f() {\" +\n+        \"  new externObjSEThis().externObjSEThisMethod2('') \" +\n+        \"};\" +\n+        \"f();\",\n+        ImmutableList.<String>of(\"externObjSEThis\"));\n   }\n \n   public void testAnnotationInExterns1() throws Exception {", "timestamp": 1285351897, "metainfo": ""}