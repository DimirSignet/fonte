{"sha": "e323b879de2e53e5eedf6e7afb0d582382c6248d", "log": "Label names must be made unique when inlining a function. Fixes issue 435  R=nicksantos DELTA=59  (52 added, 4 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1681   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n    * @param fnNode A mutable instance of the function to be inlined.\n    */\n   private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n+    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n+    // Make variable names unique to this instance.\n     NodeTraversal.traverse(\n         compiler, fnNode, new MakeDeclaredNamesUnique(\n             new InlineRenamer(\n-                compiler.getUniqueNameIdSupplier(),\n+                idSupplier,\n                 \"inline_\",\n                 isCallInLoop)));\n+    // Make label names unique to this instance.\n+    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)\n+        .process(null, fnNode);\n+  }\n+\n+  static class LabelNameSupplier implements Supplier<String> {\n+    final Supplier<String> idSupplier;\n+\n+    LabelNameSupplier(Supplier<String> idSupplier) {\n+      this.idSupplier = idSupplier;\n+    }\n+\n+    @Override\n+    public String get() {\n+        return \"JSCompiler_inline_label_\" + idSupplier.get();\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/RenameLabels.java\n+++ b/src/com/google/javascript/jscomp/RenameLabels.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Supplier;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.rhino.Node;\n  */\n final class RenameLabels implements CompilerPass {\n   private final AbstractCompiler compiler;\n+  private final Supplier<String> nameSupplier;\n+  private final boolean removeUnused;\n \n   RenameLabels(AbstractCompiler compiler) {\n+    this(compiler, new DefaultNameSupplier(), true);\n+  }\n+\n+  RenameLabels(\n+      AbstractCompiler compiler,\n+      Supplier<String> supplier,\n+      boolean removeUnused) {\n     this.compiler = compiler;\n+    this.nameSupplier = supplier;\n+    this.removeUnused = removeUnused;\n+  }\n+\n+  static class DefaultNameSupplier implements Supplier<String> {\n+    // NameGenerator is used to create safe label names.\n+    final NameGenerator nameGenerator =\n+        new NameGenerator(new HashSet<String>(), \"\", null);\n+\n+    @Override\n+    public String get() {\n+      return nameGenerator.generateNextName();\n+    }\n   }\n \n   /**\n     // A stack of labels namespaces. Labels in an outer scope aren't part of an\n     // inner scope, so a new namespace is created each time a scope is entered.\n     final Deque<LabelNamespace> namespaceStack = Lists.newLinkedList();\n-\n-    // NameGenerator is used to create safe label names.\n-    final NameGenerator nameGenerator =\n-        new NameGenerator(new HashSet<String>(), \"\", null);\n \n     // The list of generated names. Typically, the first name will be \"a\",\n     // the second \"b\", etc.\n \n         // Create a new name, if needed, for this depth.\n         if (names.size() < currentDepth) {\n-          names.add(nameGenerator.generateNextName());\n+          names.add(nameSupplier.get());\n         }\n \n         String newName = getNameForId(currentDepth);\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n       // This is a label...\n-      if (li.referenced) {\n+      if (li.referenced || !removeUnused) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n           // ... and it is used, give it the short name.\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n     // As simple a test as we can get.\n     testSame(\"function foo(){ return eval() }\" +\n         \"foo();\");\n+  }\n+\n+  public void testInlineFunctions31() {\n+    // Don't introduce a duplicate label in the same scope\n+    test(\"function foo(){ lab:{4;} }\" +\n+        \"lab:{foo();}\",\n+        \"lab:{{JSCompiler_inline_label_0:{4}}}\");\n   }\n \n   public void testMixedModeInlining1() {\n--- a/test/com/google/javascript/jscomp/RenameLabelsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameLabelsTest.java\n          \"a(); while (1) break;\");\n   }\n \n+  public void testRenameReused() {\n+    test(\"foo:{break foo}; foo:{break foo}\", \"a:{break a};a:{break a}\");\n+  }\n+\n }", "timestamp": 1304367123, "metainfo": ""}