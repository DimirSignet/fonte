{"sha": "efd3c178e471df6a689c1a50fbd7c404e778bfaa", "log": "Better number printing. Add flags for fine-grained warning controls. Better type-declaration finding. Added some missing externs. Marked externs that don't have side effects.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n public abstract class AbstractCompilerRunner<A extends Compiler,\n     B extends CompilerOptions> {\n \n-  @FlagSpec(help = \"Prints out the parse tree and exits\")\n+  @FlagSpec(help = \"Prints out the parse tree and exits\",\n+      docLevel = DocLevel.SECRET)\n   public static final Flag<Boolean> FLAG_print_tree = Flag.value(false);\n \n   @FlagSpec(help = \"Prints a dot file describing the internal abstract syntax\"\n-      + \" tree and exits\")\n+      + \" tree and exits\",\n+      docLevel = DocLevel.SECRET)\n   public static final Flag<Boolean> FLAG_print_ast = Flag.value(false);\n \n   @FlagSpec(help = \"Turns on extra sanity checks.\", altName = \"dev_mode\",\n \n   @FlagSpec(help = \"The logging level (standard java.util.logging.Level\"\n       + \" values) for Compiler progress. Does not control errors or\"\n-      + \" warnings for the JavaScript code under compilation.\")\n+      + \" warnings for the JavaScript code under compilation.\",\n+      docLevel = DocLevel.SECRET)\n   public static final Flag<String> FLAG_logging_level =\n       Flag.value(Level.WARNING.getName());\n \n       Flag.value(\"\");\n \n   @FlagSpec(help = \"File containing the serialized version of the property \"\n-      + \"renaming map produced by a previous compilation.\")\n+      + \"renaming map produced by a previous compilation.\",\n+      docLevel = DocLevel.SECRET)\n   public static final Flag<String> FLAG_property_map_input_file =\n       Flag.value(\"\");\n \n   @FlagSpec(help = \"File where the serialized version of the variable \"\n-      + \"renaming map produced should be saved.\")\n+      + \"renaming map produced should be saved.\",\n+      docLevel = DocLevel.SECRET)\n   public static final Flag<String> FLAG_variable_map_output_file =\n       Flag.value(\"\");\n \n       + \"files will be produced as {binary name}_vars_map.out and \"\n       + \"{binary name}_props_map.out. Note that this flag cannot be used \"\n       + \"in conjunction with either variable_map_output_file or \"\n-      + \"property_map_output_file.\")\n+      + \"property_map_output_file.\",\n+      docLevel = DocLevel.SECRET)\n   public static final Flag<Boolean> FLAG_create_name_map_files =\n       Flag.value(false);\n \n             \" module's name placed into the path at that spot.\")\n   public static final Flag<String> FLAG_create_source_map =\n       Flag.value(\"\");\n+\n+  @FlagSpec(help = \"Make the named class of warnings an error.\")\n+  public static final Flag<List<String>> FLAG_jscomp_error =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Make the named class of warnings a normal warning.\")\n+  public static final Flag<List<String>> FLAG_jscomp_warning =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Turn off the named class of warnings.\")\n+  public static final Flag<List<String>> FLAG_jscomp_off =\n+      Flag.stringCollector();\n \n   private PrintStream out;\n   private final PrintStream err;\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.rhino.Node;\n+\n \n /**\n  * Abstracted consumer of the CodeGenerator output.\n     }\n \n     if ((long) x == x) {\n-      add(Long.toString((long) x));\n+      long value = (long) x;\n+      long mantissa = value;\n+      int exp = 0;\n+      if (x >= 100) {\n+        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n+          mantissa /= 10;\n+          exp++;\n+        }\n+      }\n+      if (exp > 2) {\n+        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n+      } else {\n+        add(Long.toString(value));\n+      }\n     } else {\n       add(String.valueOf(x));\n     }\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n     return warningsGuard;\n   }\n \n-  void setWarningsGuard(ComposeWarningsGuard guard) {\n-    warningsGuard = guard;\n-  }\n-\n   /**\n    * Add a guard to the set of warnings guards.\n    */\n--- a/src/com/google/javascript/jscomp/CompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/CompilerRunner.java\n     if (FLAG_process_closure_primitives.get()) {\n       options.closurePass = true;\n     }\n+\n+    DiagnosticGroups.setWarningLevels(\n+        options, AbstractCompilerRunner.FLAG_jscomp_error.get(),\n+        CheckLevel.ERROR);\n+    DiagnosticGroups.setWarningLevels(\n+        options, AbstractCompilerRunner.FLAG_jscomp_warning.get(),\n+        CheckLevel.WARNING);\n+    DiagnosticGroups.setWarningLevels(\n+        options, AbstractCompilerRunner.FLAG_jscomp_off.get(),\n+        CheckLevel.OFF);\n+\n     return options;\n   }\n \n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Maps;\n \n+import java.util.List;\n import java.util.Map;\n \n /**\n       DiagnosticGroups.registerGroup(\"undefinedVars\",\n           new DiagnosticGroup(VarCheck.UNDEFINED_VAR_ERROR));\n \n+  /**\n+   * Adds warning levels by name.\n+   */\n+  static void setWarningLevels(CompilerOptions options,\n+      List<String> diagnosticGroups, CheckLevel level) {\n+    for (String name : diagnosticGroups) {\n+      DiagnosticGroup group = DiagnosticGroups.forName(name);\n+      Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n+      options.setWarningLevel(group, level);\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n-import com.google.common.primitives.IntStack;\n import com.google.javascript.jscomp.GlobalNamespace.Name;\n import com.google.javascript.jscomp.GlobalNamespace.Ref;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Token;\n \n import java.text.MessageFormat;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n     // A stack tied to the node traversal, to keep track of whether\n     // we're in a conditional block. If 1 is at the top, assignment to\n     // a define is allowed. Otherwise, it's not allowed.\n-    //\n-    // TODO(user): Replace with ArrayDeque\n-    private final IntStack assignAllowed;\n+    private final Deque<Integer> assignAllowed;\n \n     CollectDefines(AbstractCompiler compiler, List<Name> listOfDefines) {\n       this.compiler = compiler;\n       this.allDefines = Maps.newHashMap();\n \n       assignableDefines = Maps.newHashMap();\n-      assignAllowed = new IntStack();\n-      assignAllowed.add(1);\n+      assignAllowed = new ArrayDeque<Integer>();\n+      assignAllowed.push(1);\n \n       // Create a map of references to defines keyed by node for easy lookup\n       allRefInfo = Maps.newHashMap();\n         case Token.SWITCH:\n         case Token.WHILE:\n           if (entering) {\n-            assignAllowed.add(0);\n+            assignAllowed.push(0);\n           } else {\n             assignAllowed.remove();\n           }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n       GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope);\n       NodeTraversal.traverse(compiler, root, scopeBuilder);\n+      scopeBuilder.resolveStubDeclarations();\n \n       // Gather the properties in each function that we found in the\n       // global scope, if that function has a @this type that we can\n      */\n     private final List<Node> nonExternFunctions = Lists.newArrayList();\n \n+    /**\n+     * Type-less stubs in the global scope.\n+     *\n+     * If at the end of traversal, we still don't have types for these\n+     * stubs, then we should declare UNKNOWN types.\n+     */\n+    private final List<StubDeclaration> stubDeclarations =\n+        Lists.newArrayList();\n+\n     private GlobalScopeBuilder(Scope scope) {\n       super(scope);\n     }\n \n       if (valueType == null) {\n         if (parent.getType() == Token.EXPR_RESULT) {\n-          // If we see a stub property, make sure to register this property\n-          // in the type registry.\n-          ObjectType ownerType = getObjectSlot(ownerName);\n-          JSType unknownType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n-          if (ownerType == null) {\n-            defineSlot(n, parent, unknownType, false);\n-          } else {\n-            boolean isExtern = t.getInput().isExtern();\n-            if (isExtern || ownerType.isFunctionPrototypeType()) {\n-              // If this is a stub for a prototype, just declare it\n-              // as an unknown type. These are seen often in externs.\n-              ownerType.defineDeclaredProperty(\n-                  propName, unknownType, isExtern);\n-            } else {\n-              typeRegistry.registerPropertyOnType(propName, ownerType);\n-            }\n-          }\n+          stubDeclarations.add(new StubDeclaration(\n+              n, t.getInput().isExtern(), ownerName));\n         } else if (rhsValue != null &&\n                    rhsValue.getType() == Token.TRUE) {\n           // We declare these for delegate proxy method properties.\n         return rhsValue.getJSType();\n       } else {\n         return getDeclaredTypeInAnnotation(t, n, info);\n+      }\n+    }\n+\n+    /**\n+     * Resolve any stub delcarations to unknown types if we could not\n+     * find types for them during traversal.\n+     */\n+    private void resolveStubDeclarations() {\n+      for (StubDeclaration stub : stubDeclarations) {\n+        Node n = stub.node;\n+        Node parent = n.getParent();\n+        String qName = n.getQualifiedName();\n+        String propName = n.getLastChild().getString();\n+        String ownerName = stub.ownerName;\n+        boolean isExtern = stub.isExtern;\n+\n+        if (scope.isDeclared(qName, false)) {\n+          continue;\n+        }\n+\n+        // If we see a stub property, make sure to register this property\n+        // in the type registry.\n+        ObjectType ownerType = getObjectSlot(ownerName);\n+        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n+        defineSlot(n, parent, unknownType, true);\n+\n+        if (ownerType != null &&\n+            (isExtern || ownerType.isFunctionPrototypeType())) {\n+          // If this is a stub for a prototype, just declare it\n+          // as an unknown type. These are seen often in externs.\n+          ownerType.defineInferredProperty(\n+              propName, unknownType, isExtern);\n+        } else {\n+          typeRegistry.registerPropertyOnType(\n+              propName, ownerType == null ? unknownType : ownerType);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * A stub declaration without any type information.\n+     */\n+    private final class StubDeclaration {\n+      private final Node node;\n+      private final boolean isExtern;\n+      private final String ownerName;\n+\n+      private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n+        this.node = node;\n+        this.isExtern = isExtern;\n+        this.ownerName = ownerName;\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                   }\n \n                   String name = null;\n+                  boolean isBracketedParam = JsDocToken.LB == token;\n+                  if (isBracketedParam) {\n+                    token = next();\n+                  }\n \n                   if (JsDocToken.STRING != token) {\n                     parser.addWarning(\"msg.missing.variable.name\",\n                         lineno, charno);\n                   } else {\n                     name = stream.getString();\n+\n+                    if (isBracketedParam) {\n+                      token = next();\n+                      if (JsDocToken.RB != token) {\n+                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n+                      }\n+                    }\n+\n                     if (!jsdocBuilder.recordParameter(name, type)) {\n                       if (jsdocBuilder.hasParameter(name)) {\n                         parser.addWarning(\"msg.dup.variable.name\", name,\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     assertPrint(\"if(e1)function goo(){return true}\",\n         \"if(e1){function goo(){return true}}\");\n   }\n+  \n+  public void testExponents() {\n+    assertPrint(\"1\", \"1\");\n+    assertPrint(\"10\", \"10\");\n+    assertPrint(\"100\", \"100\");\n+    assertPrint(\"1000\", \"1E3\");\n+    assertPrint(\"10000\", \"1E4\");\n+    assertPrint(\"100000\", \"1E5\");\n+    assertPrint(\"-1\", \"-1\");\n+    assertPrint(\"-10\", \"-10\");\n+    assertPrint(\"-100\", \"-100\");\n+    assertPrint(\"-1000\", \"-1E3\");\n+    assertPrint(\"-123412340000\", \"-12341234E4\");\n+    assertPrint(\"1000000000000000000\", \"1E18\");\n+    assertPrint(\"100000.0\", \"1E5\");\n+    assertPrint(\"100000.1\", \"100000.1\");\n+    \n+    assertPrint(\"0.000001\", \"1.0E-6\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Join;\n+import com.google.common.collect.Lists;\n import com.google.common.flags.Flags;\n import com.google.javascript.rhino.Node;\n \n   public void testCheckSymbolsOnForVerbose() {\n     CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n     test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n+  }\n+\n+  public void testCheckSymbolsOverrideForVerbose() {\n+    CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    AbstractCompilerRunner.FLAG_jscomp_off.setForTest(\n+        Lists.newArrayList(\"undefinedVars\"));\n+    testSame(\"x = 3;\");\n+  }\n+\n+  public void testCheckUndefinedProperties() {\n+    CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    AbstractCompilerRunner.FLAG_jscomp_error.setForTest(\n+        Lists.newArrayList(\"missingProperties\"));\n+    test(\"var x = {}; var y = x.bar;\", TypeCheck.INEXISTENT_PROPERTY);\n   }\n \n   private void testSame(String original) {\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     ObjectType externProto = ((FunctionType) e).getPrototype();\n     assertTrue(globalScope.getRootNode().toStringTree(),\n         externProto.hasOwnProperty(\"foo\"));\n-    assertTrue(externProto.isPropertyTypeDeclared(\"foo\"));\n+    assertTrue(externProto.isPropertyTypeInferred(\"foo\"));\n     assertEquals(\"?\", externProto.getPropertyType(\"foo\").toString());\n     assertTrue(externProto.isPropertyInExterns(\"foo\"));\n   }\n     assertEquals(\"string\", findNameType(\"f\", lastLocalScope).toString());\n   }\n \n+  public void testDuplicateExternProperty1() {\n+    testSame(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar;\" +\n+        \"/** @type {number} */ Foo.prototype.bar; var x = (new Foo).bar;\",\n+        null);\n+    assertEquals(\"number\", findNameType(\"x\", globalScope).toString());\n+  }\n+\n+  public void testDuplicateExternProperty2() {\n+    testSame(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @type {number} */ Foo.prototype.bar;\" +\n+        \"Foo.prototype.bar; var x = (new Foo).bar;\", null);\n+    assertEquals(\"number\", findNameType(\"x\", globalScope).toString());\n+  }\n+\n   private JSType findNameType(String name, Scope scope) {\n     Node root = scope.getRootNode();\n     Deque<Node> queue = Lists.newLinkedList();", "timestamp": 1258141096, "metainfo": ""}