{"sha": "e805e65cbda20cf7f2159e348bf6b483fb15c953", "log": "Move the source map consumption libraries into the common library and open source them.  R=jschorr,chrisn DELTA=3166  (1721 added, 1416 deleted, 29 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1035   ", "commit": "\n--- /dev/null\n+++ b/gen/com/google/debugging/sourcemap/proto/Mapping.java\n+// Generated by the protocol buffer compiler.  DO NOT EDIT!\n+// source: mapping.proto\n+\n+package com.google.debugging.sourcemap.proto;\n+\n+public final class Mapping {\n+  private Mapping() {}\n+  public static void registerAllExtensions(\n+      com.google.protobuf.ExtensionRegistry registry) {\n+  }\n+  public static final class LineMapping extends\n+      com.google.protobuf.GeneratedMessage {\n+    // Use LineMapping.newBuilder() to construct.\n+    private LineMapping() {\n+      initFields();\n+    }\n+    private LineMapping(boolean noInit) {}\n+\n+    private static final LineMapping defaultInstance;\n+    public static LineMapping getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+\n+    public LineMapping getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return com.google.debugging.sourcemap.proto.Mapping.internal_static_sourcemap_LineMapping_descriptor;\n+    }\n+\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return com.google.debugging.sourcemap.proto.Mapping.internal_static_sourcemap_LineMapping_fieldAccessorTable;\n+    }\n+\n+    // optional int32 line_number = 1;\n+    public static final int LINE_NUMBER_FIELD_NUMBER = 1;\n+    private boolean hasLineNumber;\n+    private int lineNumber_ = 0;\n+    public boolean hasLineNumber() { return hasLineNumber; }\n+    public int getLineNumber() { return lineNumber_; }\n+\n+    // optional int32 column_position = 2;\n+    public static final int COLUMN_POSITION_FIELD_NUMBER = 2;\n+    private boolean hasColumnPosition;\n+    private int columnPosition_ = 0;\n+    public boolean hasColumnPosition() { return hasColumnPosition; }\n+    public int getColumnPosition() { return columnPosition_; }\n+\n+    // optional .sourcemap.OriginalMapping original_mapping = 3;\n+    public static final int ORIGINAL_MAPPING_FIELD_NUMBER = 3;\n+    private boolean hasOriginalMapping;\n+    private com.google.debugging.sourcemap.proto.Mapping.OriginalMapping originalMapping_;\n+    public boolean hasOriginalMapping() { return hasOriginalMapping; }\n+    public com.google.debugging.sourcemap.proto.Mapping.OriginalMapping getOriginalMapping() { return originalMapping_; }\n+\n+    private void initFields() {\n+      originalMapping_ = com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.getDefaultInstance();\n+    }\n+    public final boolean isInitialized() {\n+      return true;\n+    }\n+\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (hasLineNumber()) {\n+        output.writeInt32(1, getLineNumber());\n+      }\n+      if (hasColumnPosition()) {\n+        output.writeInt32(2, getColumnPosition());\n+      }\n+      if (hasOriginalMapping()) {\n+        output.writeMessage(3, getOriginalMapping());\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (hasLineNumber()) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(1, getLineNumber());\n+      }\n+      if (hasColumnPosition()) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(2, getColumnPosition());\n+      }\n+      if (hasOriginalMapping()) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeMessageSize(3, getOriginalMapping());\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.LineMapping parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+\n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(com.google.debugging.sourcemap.proto.Mapping.LineMapping prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> {\n+      private com.google.debugging.sourcemap.proto.Mapping.LineMapping result;\n+\n+      // Construct using com.google.debugging.sourcemap.proto.Mapping.LineMapping.newBuilder()\n+      private Builder() {}\n+\n+      private static Builder create() {\n+        Builder builder = new Builder();\n+        builder.result = new com.google.debugging.sourcemap.proto.Mapping.LineMapping();\n+        return builder;\n+      }\n+\n+      protected com.google.debugging.sourcemap.proto.Mapping.LineMapping internalGetResult() {\n+        return result;\n+      }\n+\n+      public Builder clear() {\n+        if (result == null) {\n+          throw new IllegalStateException(\n+            \"Cannot call clear() after build().\");\n+        }\n+        result = new com.google.debugging.sourcemap.proto.Mapping.LineMapping();\n+        return this;\n+      }\n+\n+      public Builder clone() {\n+        return create().mergeFrom(result);\n+      }\n+\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return com.google.debugging.sourcemap.proto.Mapping.LineMapping.getDescriptor();\n+      }\n+\n+      public com.google.debugging.sourcemap.proto.Mapping.LineMapping getDefaultInstanceForType() {\n+        return com.google.debugging.sourcemap.proto.Mapping.LineMapping.getDefaultInstance();\n+      }\n+\n+      public boolean isInitialized() {\n+        return result.isInitialized();\n+      }\n+      public com.google.debugging.sourcemap.proto.Mapping.LineMapping build() {\n+        if (result != null && !isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return buildPartial();\n+      }\n+\n+      private com.google.debugging.sourcemap.proto.Mapping.LineMapping buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        if (!isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return buildPartial();\n+      }\n+\n+      public com.google.debugging.sourcemap.proto.Mapping.LineMapping buildPartial() {\n+        if (result == null) {\n+          throw new IllegalStateException(\n+            \"build() has already been called on this Builder.\");\n+        }\n+        com.google.debugging.sourcemap.proto.Mapping.LineMapping returnMe = result;\n+        result = null;\n+        return returnMe;\n+      }\n+\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof com.google.debugging.sourcemap.proto.Mapping.LineMapping) {\n+          return mergeFrom((com.google.debugging.sourcemap.proto.Mapping.LineMapping)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(com.google.debugging.sourcemap.proto.Mapping.LineMapping other) {\n+        if (other == com.google.debugging.sourcemap.proto.Mapping.LineMapping.getDefaultInstance()) return this;\n+        if (other.hasLineNumber()) {\n+          setLineNumber(other.getLineNumber());\n+        }\n+        if (other.hasColumnPosition()) {\n+          setColumnPosition(other.getColumnPosition());\n+        }\n+        if (other.hasOriginalMapping()) {\n+          mergeOriginalMapping(other.getOriginalMapping());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                return this;\n+              }\n+              break;\n+            }\n+            case 8: {\n+              setLineNumber(input.readInt32());\n+              break;\n+            }\n+            case 16: {\n+              setColumnPosition(input.readInt32());\n+              break;\n+            }\n+            case 26: {\n+              com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.Builder subBuilder = com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.newBuilder();\n+              if (hasOriginalMapping()) {\n+                subBuilder.mergeFrom(getOriginalMapping());\n+              }\n+              input.readMessage(subBuilder, extensionRegistry);\n+              setOriginalMapping(subBuilder.buildPartial());\n+              break;\n+            }\n+          }\n+        }\n+      }\n+\n+\n+      // optional int32 line_number = 1;\n+      public boolean hasLineNumber() {\n+        return result.hasLineNumber();\n+      }\n+      public int getLineNumber() {\n+        return result.getLineNumber();\n+      }\n+      public Builder setLineNumber(int value) {\n+        result.hasLineNumber = true;\n+        result.lineNumber_ = value;\n+        return this;\n+      }\n+      public Builder clearLineNumber() {\n+        result.hasLineNumber = false;\n+        result.lineNumber_ = 0;\n+        return this;\n+      }\n+\n+      // optional int32 column_position = 2;\n+      public boolean hasColumnPosition() {\n+        return result.hasColumnPosition();\n+      }\n+      public int getColumnPosition() {\n+        return result.getColumnPosition();\n+      }\n+      public Builder setColumnPosition(int value) {\n+        result.hasColumnPosition = true;\n+        result.columnPosition_ = value;\n+        return this;\n+      }\n+      public Builder clearColumnPosition() {\n+        result.hasColumnPosition = false;\n+        result.columnPosition_ = 0;\n+        return this;\n+      }\n+\n+      // optional .sourcemap.OriginalMapping original_mapping = 3;\n+      public boolean hasOriginalMapping() {\n+        return result.hasOriginalMapping();\n+      }\n+      public com.google.debugging.sourcemap.proto.Mapping.OriginalMapping getOriginalMapping() {\n+        return result.getOriginalMapping();\n+      }\n+      public Builder setOriginalMapping(com.google.debugging.sourcemap.proto.Mapping.OriginalMapping value) {\n+        if (value == null) {\n+          throw new NullPointerException();\n+        }\n+        result.hasOriginalMapping = true;\n+        result.originalMapping_ = value;\n+        return this;\n+      }\n+      public Builder setOriginalMapping(com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.Builder builderForValue) {\n+        result.hasOriginalMapping = true;\n+        result.originalMapping_ = builderForValue.build();\n+        return this;\n+      }\n+      public Builder mergeOriginalMapping(com.google.debugging.sourcemap.proto.Mapping.OriginalMapping value) {\n+        if (result.hasOriginalMapping() &&\n+            result.originalMapping_ != com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.getDefaultInstance()) {\n+          result.originalMapping_ =\n+            com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.newBuilder(result.originalMapping_).mergeFrom(value).buildPartial();\n+        } else {\n+          result.originalMapping_ = value;\n+        }\n+        result.hasOriginalMapping = true;\n+        return this;\n+      }\n+      public Builder clearOriginalMapping() {\n+        result.hasOriginalMapping = false;\n+        result.originalMapping_ = com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.getDefaultInstance();\n+        return this;\n+      }\n+\n+      // @@protoc_insertion_point(builder_scope:sourcemap.LineMapping)\n+    }\n+\n+    static {\n+      defaultInstance = new LineMapping(true);\n+      com.google.debugging.sourcemap.proto.Mapping.internalForceInit();\n+      defaultInstance.initFields();\n+    }\n+\n+    // @@protoc_insertion_point(class_scope:sourcemap.LineMapping)\n+  }\n+\n+  public static final class OriginalMapping extends\n+      com.google.protobuf.GeneratedMessage {\n+    // Use OriginalMapping.newBuilder() to construct.\n+    private OriginalMapping() {\n+      initFields();\n+    }\n+    private OriginalMapping(boolean noInit) {}\n+\n+    private static final OriginalMapping defaultInstance;\n+    public static OriginalMapping getDefaultInstance() {\n+      return defaultInstance;\n+    }\n+\n+    public OriginalMapping getDefaultInstanceForType() {\n+      return defaultInstance;\n+    }\n+\n+    public static final com.google.protobuf.Descriptors.Descriptor\n+        getDescriptor() {\n+      return com.google.debugging.sourcemap.proto.Mapping.internal_static_sourcemap_OriginalMapping_descriptor;\n+    }\n+\n+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+        internalGetFieldAccessorTable() {\n+      return com.google.debugging.sourcemap.proto.Mapping.internal_static_sourcemap_OriginalMapping_fieldAccessorTable;\n+    }\n+\n+    // optional string original_file = 1;\n+    public static final int ORIGINAL_FILE_FIELD_NUMBER = 1;\n+    private boolean hasOriginalFile;\n+    private java.lang.String originalFile_ = \"\";\n+    public boolean hasOriginalFile() { return hasOriginalFile; }\n+    public java.lang.String getOriginalFile() { return originalFile_; }\n+\n+    // optional int32 line_number = 2;\n+    public static final int LINE_NUMBER_FIELD_NUMBER = 2;\n+    private boolean hasLineNumber;\n+    private int lineNumber_ = 0;\n+    public boolean hasLineNumber() { return hasLineNumber; }\n+    public int getLineNumber() { return lineNumber_; }\n+\n+    // optional int32 column_position = 3;\n+    public static final int COLUMN_POSITION_FIELD_NUMBER = 3;\n+    private boolean hasColumnPosition;\n+    private int columnPosition_ = 0;\n+    public boolean hasColumnPosition() { return hasColumnPosition; }\n+    public int getColumnPosition() { return columnPosition_; }\n+\n+    // optional string identifier = 4;\n+    public static final int IDENTIFIER_FIELD_NUMBER = 4;\n+    private boolean hasIdentifier;\n+    private java.lang.String identifier_ = \"\";\n+    public boolean hasIdentifier() { return hasIdentifier; }\n+    public java.lang.String getIdentifier() { return identifier_; }\n+\n+    private void initFields() {\n+    }\n+    public final boolean isInitialized() {\n+      return true;\n+    }\n+\n+    public void writeTo(com.google.protobuf.CodedOutputStream output)\n+                        throws java.io.IOException {\n+      getSerializedSize();\n+      if (hasOriginalFile()) {\n+        output.writeString(1, getOriginalFile());\n+      }\n+      if (hasLineNumber()) {\n+        output.writeInt32(2, getLineNumber());\n+      }\n+      if (hasColumnPosition()) {\n+        output.writeInt32(3, getColumnPosition());\n+      }\n+      if (hasIdentifier()) {\n+        output.writeString(4, getIdentifier());\n+      }\n+      getUnknownFields().writeTo(output);\n+    }\n+\n+    private int memoizedSerializedSize = -1;\n+    public int getSerializedSize() {\n+      int size = memoizedSerializedSize;\n+      if (size != -1) return size;\n+\n+      size = 0;\n+      if (hasOriginalFile()) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeStringSize(1, getOriginalFile());\n+      }\n+      if (hasLineNumber()) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(2, getLineNumber());\n+      }\n+      if (hasColumnPosition()) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeInt32Size(3, getColumnPosition());\n+      }\n+      if (hasIdentifier()) {\n+        size += com.google.protobuf.CodedOutputStream\n+          .computeStringSize(4, getIdentifier());\n+      }\n+      size += getUnknownFields().getSerializedSize();\n+      memoizedSerializedSize = size;\n+      return size;\n+    }\n+\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseFrom(\n+        com.google.protobuf.ByteString data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseFrom(\n+        com.google.protobuf.ByteString data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseFrom(byte[] data)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data).buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseFrom(\n+        byte[] data,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws com.google.protobuf.InvalidProtocolBufferException {\n+      return newBuilder().mergeFrom(data, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseDelimitedFrom(java.io.InputStream input)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseDelimitedFrom(\n+        java.io.InputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      Builder builder = newBuilder();\n+      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {\n+        return builder.buildParsed();\n+      } else {\n+        return null;\n+      }\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseFrom(\n+        com.google.protobuf.CodedInputStream input)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input).buildParsed();\n+    }\n+    public static com.google.debugging.sourcemap.proto.Mapping.OriginalMapping parseFrom(\n+        com.google.protobuf.CodedInputStream input,\n+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+        throws java.io.IOException {\n+      return newBuilder().mergeFrom(input, extensionRegistry)\n+               .buildParsed();\n+    }\n+\n+    public static Builder newBuilder() { return Builder.create(); }\n+    public Builder newBuilderForType() { return newBuilder(); }\n+    public static Builder newBuilder(com.google.debugging.sourcemap.proto.Mapping.OriginalMapping prototype) {\n+      return newBuilder().mergeFrom(prototype);\n+    }\n+    public Builder toBuilder() { return newBuilder(this); }\n+\n+    public static final class Builder extends\n+        com.google.protobuf.GeneratedMessage.Builder<Builder> {\n+      private com.google.debugging.sourcemap.proto.Mapping.OriginalMapping result;\n+\n+      // Construct using com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.newBuilder()\n+      private Builder() {}\n+\n+      private static Builder create() {\n+        Builder builder = new Builder();\n+        builder.result = new com.google.debugging.sourcemap.proto.Mapping.OriginalMapping();\n+        return builder;\n+      }\n+\n+      protected com.google.debugging.sourcemap.proto.Mapping.OriginalMapping internalGetResult() {\n+        return result;\n+      }\n+\n+      public Builder clear() {\n+        if (result == null) {\n+          throw new IllegalStateException(\n+            \"Cannot call clear() after build().\");\n+        }\n+        result = new com.google.debugging.sourcemap.proto.Mapping.OriginalMapping();\n+        return this;\n+      }\n+\n+      public Builder clone() {\n+        return create().mergeFrom(result);\n+      }\n+\n+      public com.google.protobuf.Descriptors.Descriptor\n+          getDescriptorForType() {\n+        return com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.getDescriptor();\n+      }\n+\n+      public com.google.debugging.sourcemap.proto.Mapping.OriginalMapping getDefaultInstanceForType() {\n+        return com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.getDefaultInstance();\n+      }\n+\n+      public boolean isInitialized() {\n+        return result.isInitialized();\n+      }\n+      public com.google.debugging.sourcemap.proto.Mapping.OriginalMapping build() {\n+        if (result != null && !isInitialized()) {\n+          throw newUninitializedMessageException(result);\n+        }\n+        return buildPartial();\n+      }\n+\n+      private com.google.debugging.sourcemap.proto.Mapping.OriginalMapping buildParsed()\n+          throws com.google.protobuf.InvalidProtocolBufferException {\n+        if (!isInitialized()) {\n+          throw newUninitializedMessageException(\n+            result).asInvalidProtocolBufferException();\n+        }\n+        return buildPartial();\n+      }\n+\n+      public com.google.debugging.sourcemap.proto.Mapping.OriginalMapping buildPartial() {\n+        if (result == null) {\n+          throw new IllegalStateException(\n+            \"build() has already been called on this Builder.\");\n+        }\n+        com.google.debugging.sourcemap.proto.Mapping.OriginalMapping returnMe = result;\n+        result = null;\n+        return returnMe;\n+      }\n+\n+      public Builder mergeFrom(com.google.protobuf.Message other) {\n+        if (other instanceof com.google.debugging.sourcemap.proto.Mapping.OriginalMapping) {\n+          return mergeFrom((com.google.debugging.sourcemap.proto.Mapping.OriginalMapping)other);\n+        } else {\n+          super.mergeFrom(other);\n+          return this;\n+        }\n+      }\n+\n+      public Builder mergeFrom(com.google.debugging.sourcemap.proto.Mapping.OriginalMapping other) {\n+        if (other == com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.getDefaultInstance()) return this;\n+        if (other.hasOriginalFile()) {\n+          setOriginalFile(other.getOriginalFile());\n+        }\n+        if (other.hasLineNumber()) {\n+          setLineNumber(other.getLineNumber());\n+        }\n+        if (other.hasColumnPosition()) {\n+          setColumnPosition(other.getColumnPosition());\n+        }\n+        if (other.hasIdentifier()) {\n+          setIdentifier(other.getIdentifier());\n+        }\n+        this.mergeUnknownFields(other.getUnknownFields());\n+        return this;\n+      }\n+\n+      public Builder mergeFrom(\n+          com.google.protobuf.CodedInputStream input,\n+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n+          throws java.io.IOException {\n+        com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n+          com.google.protobuf.UnknownFieldSet.newBuilder(\n+            this.getUnknownFields());\n+        while (true) {\n+          int tag = input.readTag();\n+          switch (tag) {\n+            case 0:\n+              this.setUnknownFields(unknownFields.build());\n+              return this;\n+            default: {\n+              if (!parseUnknownField(input, unknownFields,\n+                                     extensionRegistry, tag)) {\n+                this.setUnknownFields(unknownFields.build());\n+                return this;\n+              }\n+              break;\n+            }\n+            case 10: {\n+              setOriginalFile(input.readString());\n+              break;\n+            }\n+            case 16: {\n+              setLineNumber(input.readInt32());\n+              break;\n+            }\n+            case 24: {\n+              setColumnPosition(input.readInt32());\n+              break;\n+            }\n+            case 34: {\n+              setIdentifier(input.readString());\n+              break;\n+            }\n+          }\n+        }\n+      }\n+\n+\n+      // optional string original_file = 1;\n+      public boolean hasOriginalFile() {\n+        return result.hasOriginalFile();\n+      }\n+      public java.lang.String getOriginalFile() {\n+        return result.getOriginalFile();\n+      }\n+      public Builder setOriginalFile(java.lang.String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  result.hasOriginalFile = true;\n+        result.originalFile_ = value;\n+        return this;\n+      }\n+      public Builder clearOriginalFile() {\n+        result.hasOriginalFile = false;\n+        result.originalFile_ = getDefaultInstance().getOriginalFile();\n+        return this;\n+      }\n+\n+      // optional int32 line_number = 2;\n+      public boolean hasLineNumber() {\n+        return result.hasLineNumber();\n+      }\n+      public int getLineNumber() {\n+        return result.getLineNumber();\n+      }\n+      public Builder setLineNumber(int value) {\n+        result.hasLineNumber = true;\n+        result.lineNumber_ = value;\n+        return this;\n+      }\n+      public Builder clearLineNumber() {\n+        result.hasLineNumber = false;\n+        result.lineNumber_ = 0;\n+        return this;\n+      }\n+\n+      // optional int32 column_position = 3;\n+      public boolean hasColumnPosition() {\n+        return result.hasColumnPosition();\n+      }\n+      public int getColumnPosition() {\n+        return result.getColumnPosition();\n+      }\n+      public Builder setColumnPosition(int value) {\n+        result.hasColumnPosition = true;\n+        result.columnPosition_ = value;\n+        return this;\n+      }\n+      public Builder clearColumnPosition() {\n+        result.hasColumnPosition = false;\n+        result.columnPosition_ = 0;\n+        return this;\n+      }\n+\n+      // optional string identifier = 4;\n+      public boolean hasIdentifier() {\n+        return result.hasIdentifier();\n+      }\n+      public java.lang.String getIdentifier() {\n+        return result.getIdentifier();\n+      }\n+      public Builder setIdentifier(java.lang.String value) {\n+        if (value == null) {\n+    throw new NullPointerException();\n+  }\n+  result.hasIdentifier = true;\n+        result.identifier_ = value;\n+        return this;\n+      }\n+      public Builder clearIdentifier() {\n+        result.hasIdentifier = false;\n+        result.identifier_ = getDefaultInstance().getIdentifier();\n+        return this;\n+      }\n+\n+      // @@protoc_insertion_point(builder_scope:sourcemap.OriginalMapping)\n+    }\n+\n+    static {\n+      defaultInstance = new OriginalMapping(true);\n+      com.google.debugging.sourcemap.proto.Mapping.internalForceInit();\n+      defaultInstance.initFields();\n+    }\n+\n+    // @@protoc_insertion_point(class_scope:sourcemap.OriginalMapping)\n+  }\n+\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_sourcemap_LineMapping_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_sourcemap_LineMapping_fieldAccessorTable;\n+  private static com.google.protobuf.Descriptors.Descriptor\n+    internal_static_sourcemap_OriginalMapping_descriptor;\n+  private static\n+    com.google.protobuf.GeneratedMessage.FieldAccessorTable\n+      internal_static_sourcemap_OriginalMapping_fieldAccessorTable;\n+\n+  public static com.google.protobuf.Descriptors.FileDescriptor\n+      getDescriptor() {\n+    return descriptor;\n+  }\n+  private static com.google.protobuf.Descriptors.FileDescriptor\n+      descriptor;\n+  static {\n+    java.lang.String[] descriptorData = {\n+      \"\\n\\rmapping.proto\\022\\tsourcemap\\\"q\\n\\013LineMappin\" +\n+      \"g\\022\\023\\n\\013line_number\\030\\001 \\001(\\005\\022\\027\\n\\017column_positio\" +\n+      \"n\\030\\002 \\001(\\005\\0224\\n\\020original_mapping\\030\\003 \\001(\\0132\\032.sour\" +\n+      \"cemap.OriginalMapping\\\"j\\n\\017OriginalMapping\" +\n+      \"\\022\\025\\n\\roriginal_file\\030\\001 \\001(\\t\\022\\023\\n\\013line_number\\030\\002\" +\n+      \" \\001(\\005\\022\\027\\n\\017column_position\\030\\003 \\001(\\005\\022\\022\\n\\nidentif\" +\n+      \"ier\\030\\004 \\001(\\tB&\\n$com.google.debugging.source\" +\n+      \"map.proto\"\n+    };\n+    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n+      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {\n+        public com.google.protobuf.ExtensionRegistry assignDescriptors(\n+            com.google.protobuf.Descriptors.FileDescriptor root) {\n+          descriptor = root;\n+          internal_static_sourcemap_LineMapping_descriptor =\n+            getDescriptor().getMessageTypes().get(0);\n+          internal_static_sourcemap_LineMapping_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_sourcemap_LineMapping_descriptor,\n+              new java.lang.String[] { \"LineNumber\", \"ColumnPosition\", \"OriginalMapping\", },\n+              com.google.debugging.sourcemap.proto.Mapping.LineMapping.class,\n+              com.google.debugging.sourcemap.proto.Mapping.LineMapping.Builder.class);\n+          internal_static_sourcemap_OriginalMapping_descriptor =\n+            getDescriptor().getMessageTypes().get(1);\n+          internal_static_sourcemap_OriginalMapping_fieldAccessorTable = new\n+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(\n+              internal_static_sourcemap_OriginalMapping_descriptor,\n+              new java.lang.String[] { \"OriginalFile\", \"LineNumber\", \"ColumnPosition\", \"Identifier\", },\n+              com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.class,\n+              com.google.debugging.sourcemap.proto.Mapping.OriginalMapping.Builder.class);\n+          return null;\n+        }\n+      };\n+    com.google.protobuf.Descriptors.FileDescriptor\n+      .internalBuildGeneratedFileFrom(descriptorData,\n+        new com.google.protobuf.Descriptors.FileDescriptor[] {\n+        }, assigner);\n+  }\n+\n+  public static void internalForceInit() {}\n+\n+  // @@protoc_insertion_point(outer_class_scope)\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumer.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+/**\n+ * A SourceMapConsumer is a SourceMapping provide that can parse from a raw\n+ * string.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public interface SourceMapConsumer extends SourceMapping {\n+\n+  /**\n+   * Parses the given contents containing a source map to provide initialize\n+   * a class providing SourceMapping.\n+   */\n+  public void parse(String contents) throws SourceMapParseException;\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerFactory.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+/**\n+ * Detect and parse the provided source map.\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMapConsumerFactory {\n+\n+  /** not constructible */\n+  private SourceMapConsumerFactory() {}\n+\n+  /**\n+   * @param contents The string representing the source map file contents.\n+   * @return The parsed source map.\n+   * @throws SourceMapParseException\n+   */\n+  public static SourceMapping parse(String contents)\n+      throws SourceMapParseException {\n+    SourceMapConsumer consumer = null;\n+    SourceMapGenerator.Format format = detectVersion(contents);\n+    consumer = createForVerion(detectVersion(contents));\n+    consumer.parse(contents);\n+    return consumer;\n+  }\n+\n+  /**\n+   * @param contents\n+   * @return The best guess of the source map version.\n+   * @throws SourceMapParseException\n+   */\n+  private static SourceMapGenerator.Format detectVersion(String contents)\n+      throws SourceMapParseException {\n+    if (contents.startsWith(\"/** Begin line maps. **/\")) {\n+      return SourceMapGenerator.Format.LEGACY;\n+    } else if (contents.startsWith(\"{\")){\n+      return SourceMapGenerator.Format.EXPERIMENTIAL;\n+    } else {\n+      throw new SourceMapParseException(\"unable to detect source map format\");\n+    }\n+  }\n+\n+  /**\n+   * @return The appropriate source map object for the given source map format.\n+   * @throws SourceMapParseException\n+   */\n+  private static SourceMapConsumer createForVerion(\n+      SourceMapGenerator.Format format)\n+      throws SourceMapParseException {\n+    switch (format) {\n+      case LEGACY:\n+        return new SourceMapConsumerV1();\n+      case EXPERIMENTIAL:\n+        return new SourceMapConsumerV2();\n+      default:\n+        throw new SourceMapParseException(\"unsupported source map format\");\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV1.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Interner;\n+import com.google.common.collect.Interners;\n+import com.google.common.collect.Lists;\n+import com.google.common.primitives.Bytes;\n+import com.google.common.primitives.Shorts;\n+import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Class for parsing and representing a SourceMap, as produced by the\n+ * Closure Compiler, Caja-Compiler, etc.\n+ */\n+public class SourceMapConsumerV1 implements SourceMapConsumer {\n+  private static final String LINEMAP_HEADER = \"/** Begin line maps. **/\";\n+  private static final String FILEINFO_HEADER =\n+      \"/** Begin file information. **/\";\n+\n+  private static final String DEFINITION_HEADER =\n+      \"/** Begin mapping definitions. **/\";\n+\n+  /**\n+   * Internal class for parsing the SourceMap. Used to maintain parser\n+   * state in an easy to use instance.\n+   */\n+  private static class ParseState {\n+    final String contents;\n+    int currentPosition = 0;\n+\n+    ParseState(String contents) {\n+      this.contents = contents;\n+    }\n+\n+    /** Reads a line, returning null at EOF. */\n+    String readLineOrNull() {\n+      if (currentPosition >= contents.length()) {\n+        return null;\n+      }\n+      int index = contents.indexOf('\\n', currentPosition);\n+      if (index < 0) {\n+        index = contents.length();\n+      }\n+      String line = contents.substring(currentPosition, index);\n+      currentPosition = index + 1;\n+      return line;\n+    }\n+\n+    /** Reads a line, throwing a parse exception at EOF. */\n+    String readLine() throws SourceMapParseException {\n+      String line = readLineOrNull();\n+      if (line == null) {\n+        fail(\"EOF\");\n+      }\n+      return line;\n+    }\n+\n+    /**\n+     * Reads a line and throws an parse exception if the line does not\n+     * equal the argument.\n+     */\n+    void expectLine(String expect) throws SourceMapParseException {\n+      String line = readLine();\n+      if (!expect.equals(line)) {\n+        fail(\"Expected \" + expect + \" got \" + line);\n+      }\n+    }\n+\n+    /**\n+     * Indicates that parsing has failed by throwing a parse exception.\n+     */\n+    void fail(String message) throws SourceMapParseException {\n+      throw new SourceMapParseException(message);\n+    }\n+  }\n+\n+  /**\n+   * Mapping from a line number (0-indexed), to a list of mapping IDs, one for\n+   * each character on the line. For example, if the array for line 2 is\n+   * {@code [4,,,,5,6,,,7]}, then there will be the entry:\n+   *\n+   * <pre>\n+   * 1 => {4, 4, 4, 4, 5, 6, 6, 6, 7}\n+   * </pre>\n+   */\n+  private ImmutableList<ImmutableList<LineFragment>> characterMap;\n+\n+  /**\n+   * Map of Mapping IDs to the actual mapping object.\n+   */\n+  private ImmutableList<SourceFile> mappings;\n+\n+  /**\n+   * Parses the given contents containing a source map.\n+   */\n+  public void parse(String contents) throws SourceMapParseException {\n+    ParseState parser = new ParseState(contents);\n+    try {\n+      parseInternal(parser);\n+    } catch (JSONException ex) {\n+      parser.fail(\"JSON parse exception: \" + ex);\n+    }\n+  }\n+\n+  /**\n+   * Parses the first section of the source map file that has character\n+   * mappings.\n+   * @param parser The parser to use\n+   * @param lineCount The number of lines in the generated js\n+   * @return The max id found in the file\n+   */\n+  private int parseCharacterMap(\n+      ParseState parser, int lineCount,\n+      ImmutableList.Builder<ImmutableList<LineFragment>> characterMapBuilder)\n+      throws SourceMapParseException, JSONException {\n+    int maxID = -1;\n+    // [0,,,,,,1,2]\n+    for (int i = 0; i < lineCount; ++i) {\n+      String currentLine = parser.readLine();\n+\n+      // Blank lines are allowed in the spec to indicate no mapping\n+      // information for the line.\n+      if (currentLine.isEmpty()) {\n+        continue;\n+      }\n+\n+      ImmutableList.Builder<LineFragment> fragmentList =\n+          ImmutableList.builder();\n+      // We need the start index to initialize this, needs to be done in the\n+      // loop.\n+      LineFragment myLineFragment = null;\n+\n+      JSONArray charArray = new JSONArray(currentLine);\n+      int numOffsets = charArray.length();\n+      int lastID = -1;\n+      int startID = Integer.MIN_VALUE;\n+      List<Byte> currentOffsets = Lists.newArrayList();\n+      for (int j = 0; j < charArray.length(); ++j) {\n+        // Keep track of the current mappingID, if the next element in the\n+        // array is empty we reuse the existing mappingID for the column.\n+        int mappingID = lastID;\n+        if (!charArray.isNull(j)) {\n+          mappingID = charArray.optInt(j);\n+          if (mappingID > maxID) {\n+            maxID = mappingID;\n+          }\n+        }\n+\n+        if (startID == Integer.MIN_VALUE) {\n+          startID = mappingID;\n+        } else {\n+          // If the difference is bigger than a byte we need to keep track of\n+          // a new line fragment with a new start value.\n+          if (mappingID - lastID > Byte.MAX_VALUE\n+              || mappingID - lastID < Byte.MIN_VALUE) {\n+            myLineFragment = new LineFragment(\n+                startID, Bytes.toArray(currentOffsets));\n+            currentOffsets.clear();\n+            // Start a new section.\n+            fragmentList.add(myLineFragment);\n+            startID = mappingID;\n+          } else {\n+            currentOffsets.add((byte) (mappingID - lastID));\n+          }\n+        }\n+\n+        lastID = mappingID;\n+      }\n+      if (startID != Integer.MIN_VALUE) {\n+        myLineFragment = new LineFragment(\n+            startID, Bytes.toArray(currentOffsets));\n+        fragmentList.add(myLineFragment);\n+      }\n+      characterMapBuilder.add(fragmentList.build());\n+    }\n+    return maxID;\n+  }\n+\n+  private class FileName {\n+    private final String dir;\n+    private final String name;\n+\n+    FileName(String directory, String name) {\n+      this.dir = directory;\n+      this.name = name;\n+    }\n+  }\n+\n+  /**\n+   * Split the file into a filename/directory pair.\n+   *\n+   * @param interner The interner to use for interning the strings.\n+   * @param input The input to split.\n+   * @return The pair of directory, filename.\n+   */\n+  private FileName splitFileName(\n+      Interner<String> interner, String input) {\n+    int hashIndex = input.lastIndexOf('/');\n+    String dir = interner.intern(input.substring(0, hashIndex + 1));\n+    String fileName = interner.intern(input.substring(hashIndex + 1));\n+    return new FileName(dir, fileName);\n+  }\n+\n+  /**\n+   * Parse the file mappings section of the source map file.  This maps the\n+   * ids to the filename, line number and colunm number in the original\n+   * files.\n+   * @param parser The parser to get the data from.\n+   * @param maxID The maximum id found in the character mapping section.\n+   */\n+  private void parseFileMappings(ParseState parser, int maxID)\n+      throws SourceMapParseException, JSONException {\n+    // ['d.js', 3, 78, 'foo']\n+    // Intern the strings to save memory.\n+    Interner<String> interner = Interners.newStrongInterner();\n+    ImmutableList.Builder<SourceFile> mappingsBuilder = ImmutableList.builder();\n+\n+    // Setup all the arrays to keep track of the various details about the\n+    // source file.\n+    ArrayList<Byte> lineOffsets = Lists.newArrayList();\n+    ArrayList<Short> columns = Lists.newArrayList();\n+    ArrayList<String> identifiers = Lists.newArrayList();\n+\n+    // The indexes and details about the current position in the file to do\n+    // diffs against.\n+    String currentFile = null;\n+    int lastLine = -1;\n+    int startLine = -1;\n+    int startMapId = -1;\n+    for (int mappingId = 0; mappingId <= maxID; ++mappingId) {\n+      String currentLine = parser.readLine();\n+      JSONArray mapArray = new JSONArray(currentLine);\n+      if (mapArray.length() < 3) {\n+        parser.fail(\"Invalid mapping array\");\n+      }\n+\n+      // Split up the file and directory names to reduce memory usage.\n+      String myFile = mapArray.getString(0);\n+      int line = mapArray.getInt(1);\n+      if (!myFile.equals(currentFile) || (line - lastLine) > Byte.MAX_VALUE\n+          || (line - lastLine) < Byte.MIN_VALUE) {\n+        if (currentFile != null) {\n+          FileName dirFile = splitFileName(interner, currentFile);\n+          SourceFile.Builder builder = SourceFile.newBuilder()\n+              .setDir(dirFile.dir)\n+              .setFileName(dirFile.name)\n+              .setStartLine(startLine)\n+              .setStartMapId(startMapId)\n+              .setLineOffsets(lineOffsets)\n+              .setColumns(columns)\n+              .setIdentifiers(identifiers);\n+          mappingsBuilder.add(builder.build());\n+        }\n+        // Reset all the positions back to the start and clear out the arrays\n+        // to start afresh.\n+        currentFile = myFile;\n+        startLine = line;\n+        lastLine = line;\n+        startMapId = mappingId;\n+        columns.clear();\n+        lineOffsets.clear();\n+        identifiers.clear();\n+      }\n+      // We need to add on the columns and identifiers for all the lines, even\n+      // for the first line.\n+      lineOffsets.add((byte) (line - lastLine));\n+      columns.add((short) mapArray.getInt(2));\n+      identifiers.add(interner.intern(mapArray.optString(3, \"\")));\n+      lastLine = line;\n+    }\n+    if (currentFile != null) {\n+      FileName dirFile = splitFileName(interner, currentFile);\n+      SourceFile.Builder builder = SourceFile.newBuilder()\n+          .setDir(dirFile.dir)\n+          .setFileName(dirFile.name)\n+          .setStartLine(startLine)\n+          .setStartMapId(startMapId)\n+          .setLineOffsets(lineOffsets)\n+          .setColumns(columns)\n+          .setIdentifiers(identifiers);\n+      mappingsBuilder.add(builder.build());\n+    }\n+    mappings = mappingsBuilder.build();\n+  }\n+\n+  private void parseInternal(ParseState parser)\n+      throws SourceMapParseException, JSONException {\n+\n+    // /** Begin line maps. **/{ count: 2 }\n+    String headerCount = parser.readLine();\n+    Preconditions.checkArgument(headerCount.startsWith(LINEMAP_HEADER),\n+        \"Expected %s\", LINEMAP_HEADER);\n+    JSONObject countObject = new JSONObject(\n+        headerCount.substring(LINEMAP_HEADER.length()));\n+    if (!countObject.has(\"count\")) {\n+      parser.fail(\"Missing 'count'\");\n+    }\n+\n+    int lineCount = countObject.getInt(\"count\");\n+    if (lineCount <= 0) {\n+      parser.fail(\"Count must be >= 1\");\n+    }\n+    ImmutableList.Builder<ImmutableList<LineFragment>> characterMapBuilder =\n+        ImmutableList.builder();\n+    int maxId = parseCharacterMap(parser, lineCount, characterMapBuilder);\n+    characterMap = characterMapBuilder.build();\n+\n+    // /** Begin file information. **/\n+    parser.expectLine(FILEINFO_HEADER);\n+\n+    // File information. Not used, so we just consume it.\n+    for (int i = 0; i < lineCount; i++) {\n+      parser.readLine();\n+    }\n+\n+    // /** Begin mapping definitions. **/\n+    parser.expectLine(DEFINITION_HEADER);\n+\n+    parseFileMappings(parser, maxId);\n+  }\n+\n+  @Override\n+  public OriginalMapping getMappingForLine(int lineNumber, int columnIndex) {\n+    Preconditions.checkNotNull(characterMap, \"parse() must be called first\");\n+\n+    if (lineNumber < 1 || lineNumber > characterMap.size() || columnIndex < 1) {\n+      return null;\n+    }\n+\n+    List<LineFragment> lineFragments = characterMap.get(lineNumber - 1);\n+    if (lineFragments == null || lineFragments.isEmpty()) {\n+      return null;\n+    }\n+\n+    int columnOffset = 0;\n+    // The code assumes everything past the end is the same as the last item\n+    // so we default to the last item in the line.\n+    LineFragment lastFragment = lineFragments.get(lineFragments.size() - 1);\n+    int mapId = lastFragment.valueAtColumn(lastFragment.length());\n+    for (LineFragment lineFragment : lineFragments) {\n+      int columnPosition = columnIndex - columnOffset;\n+      if (columnPosition <= lineFragment.length()) {\n+        mapId = lineFragment.valueAtColumn(columnPosition);\n+        break;\n+      }\n+      columnOffset += lineFragment.length();\n+    }\n+\n+    if (mapId < 0) {\n+      return null;\n+    }\n+\n+    return getMappingFromId(mapId);\n+  }\n+\n+  /**\n+   * Do a binary search for the correct mapping array to use.\n+   *\n+   * @param mapId The mapping array to find\n+   * @return The source file mapping to use.\n+   */\n+  private SourceFile binarySearch(int mapId) {\n+    int lower = 0;\n+    int upper = mappings.size() - 1;\n+\n+    while (lower <= upper) {\n+      int middle = lower + (upper - lower) / 2;\n+      SourceFile middleCompare = mappings.get(middle);\n+      if (mapId < middleCompare.getStartMapId()) {\n+        upper = middle - 1;\n+      } else if (mapId < (middleCompare.getStartMapId()\n+            + middleCompare.getLength())) {\n+        return middleCompare;\n+      } else {\n+        lower = middle + 1;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Find the original mapping for the specified mapping id.\n+   *\n+   * @param mapID The mapID to lookup.\n+   * @return The originalMapping protocol buffer for the id.\n+   */\n+  private OriginalMapping getMappingFromId(int mapID) {\n+    SourceFile match = binarySearch(mapID);\n+    if (match == null) {\n+      return null;\n+    }\n+    int pos = mapID - match.getStartMapId();\n+    return match.getOriginalMapping(pos);\n+  }\n+\n+  /**\n+   * Keeps track of the information about the line in a more compact way.  It\n+   * represents a fragment of the line starting at a specific index and then\n+   * looks at offsets from that index stored as a byte, this dramatically\n+   * reduces the memory usuage of this array.\n+   */\n+  private static final class LineFragment {\n+    private final int startIndex;\n+    private final byte[] offsets;\n+\n+    /**\n+     * Create a new line fragment to store information about.\n+     *\n+     * @param startIndex The start index for this line.\n+     * @param offsets The byte array of offsets to store.\n+     */\n+    LineFragment(int startIndex, byte[] offsets) {\n+      this.startIndex = startIndex;\n+      this.offsets = offsets;\n+    }\n+\n+    /**\n+     * The length of columns stored in the line.  One is added because we\n+     * store the start index outside of the offsets array.\n+     */\n+    int length() {\n+      return offsets.length + 1;\n+    }\n+\n+    /**\n+     * Find the mapping id at the specified column.\n+     *\n+     * @param column The column to lookup\n+     * @return the value at that point in the column\n+     */\n+    int valueAtColumn(int column) {\n+      Preconditions.checkArgument(column > 0);\n+      int pos = startIndex;\n+      for (int i = 0; i < column - 1; i++) {\n+        pos += offsets[i];\n+      }\n+      return pos;\n+    }\n+  }\n+\n+  /**\n+   * Keeps track of data about the source file itself.  This is contains a list\n+   * of line offsetsand columns to track down where exactly a line falls into\n+   * the data.\n+   */\n+  private static final class SourceFile {\n+    final String dir;\n+    final String fileName;\n+    final int startMapId;\n+    final int startLine;\n+    final byte[] lineOffsets;\n+    final short[] columns;\n+    final String[] identifiers;\n+\n+    private SourceFile(\n+        String dir, String fileName, int startLine, int startMapId,\n+        byte[] lineOffsets, short[] columns, String[] identifiers) {\n+      this.fileName = Preconditions.checkNotNull(fileName);\n+      this.dir = Preconditions.checkNotNull(dir);\n+      this.startLine = startLine;\n+      this.startMapId = startMapId;\n+      this.lineOffsets = Preconditions.checkNotNull(lineOffsets);\n+      this.columns = Preconditions.checkNotNull(columns);\n+      this.identifiers = Preconditions.checkNotNull(identifiers);\n+      Preconditions.checkArgument(lineOffsets.length == columns.length &&\n+          columns.length == identifiers.length);\n+    }\n+\n+    private SourceFile(int startMapId) {\n+      // Only used for binary searches.\n+      this.startMapId = startMapId;\n+\n+      this.fileName = null;\n+      this.dir = null;\n+      this.startLine = 0;\n+      this.lineOffsets = null;\n+      this.columns = null;\n+      this.identifiers = null;\n+    }\n+\n+    /**\n+     * Returns the number of elements in this source file.\n+     */\n+    int getLength() {\n+      return lineOffsets.length;\n+    }\n+\n+    /**\n+     * Returns the number of elements in this source file.\n+     */\n+    int getStartMapId() {\n+      return startMapId;\n+    }\n+\n+    /**\n+     * Creates an original mapping from the data.\n+     *\n+     * @param offset The offset into the array to find the mapping for.\n+     * @return A new original mapping object.\n+     */\n+    OriginalMapping getOriginalMapping(int offset) {\n+      int lineNumber = this.startLine;\n+      // Offset is an index into this array and we need to include it.\n+      for (int i = 0; i <= offset; i++) {\n+        lineNumber += lineOffsets[i];\n+      }\n+      OriginalMapping.Builder builder = OriginalMapping.newBuilder()\n+          .setOriginalFile(dir + fileName)\n+          .setLineNumber(lineNumber)\n+          .setColumnPosition(columns[offset])\n+          .setIdentifier(identifiers[offset]);\n+      return builder.build();\n+    }\n+\n+    /**\n+     * Builder to make a new SourceFile object.\n+     */\n+    static final class Builder {\n+      String dir;\n+      String fileName;\n+      int startMapId;\n+      int startLine;\n+      byte[] lineOffsets;\n+      short[] columns;\n+      String[] identifiers;\n+\n+      Builder setDir(String dir) {\n+        this.dir = dir;\n+        return this;\n+      }\n+\n+      Builder setFileName(String fileName) {\n+        this.fileName = fileName;\n+        return this;\n+      }\n+\n+      Builder setStartMapId(int startMapId) {\n+        this.startMapId = startMapId;\n+        return this;\n+      }\n+\n+      Builder setStartLine(int startLine) {\n+        this.startLine = startLine;\n+        return this;\n+      }\n+\n+      Builder setLineOffsets(List<Byte> lineOffsets) {\n+        this.lineOffsets = Bytes.toArray(lineOffsets);\n+        return this;\n+      }\n+\n+      Builder setColumns(List<Short> columns) {\n+        this.columns = Shorts.toArray(columns);\n+        return this;\n+      }\n+\n+      Builder setIdentifiers(List<String> identifiers) {\n+        this.identifiers = identifiers.toArray(new String[0]);\n+        return this;\n+      }\n+\n+      /**\n+       * Creates a new SourceFile from the parameters.\n+       */\n+      SourceFile build() {\n+        return new SourceFile(dir, fileName, startLine, startMapId,\n+            lineOffsets, columns, identifiers);\n+      }\n+    }\n+\n+    static Builder newBuilder() {\n+      return new Builder();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV2.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for parsing version 2 of the SourceMap format, as produced by the\n+ * Closure Compiler, etc.\n+ * @author johnlenz@google.com (John Lenz)\n+ * @author jschorr@google.com (Joseph Schorr)\n+ */\n+public class SourceMapConsumerV2 implements SourceMapConsumer {\n+  /**\n+   * The character map for each line. If a line does not have an entry,\n+   * then it has not yet been decoded.\n+   */\n+  private Map<Integer, List<Integer>> characterMap = null;\n+\n+  /**\n+   * The undecoded line maps. Will be accessed to decode lines as needed.\n+   */\n+  private JSONArray lineMaps = null;\n+\n+  /**\n+   * Map of Mapping IDs to the actual mapping object.\n+   */\n+  private List<OriginalMapping> mappings;\n+\n+  public SourceMapConsumerV2() {}\n+\n+  /**\n+   * Parses the given contents containing a source map.\n+   */\n+  public void parse(String contents) throws SourceMapParseException {\n+    try {\n+      parseInternal(contents);\n+    } catch (JSONException ex) {\n+      throw new SourceMapParseException(\"JSON parse exception: \" + ex);\n+    }\n+  }\n+\n+  /**\n+   * Parses the given contents as version 2 of a SourceMap.\n+   */\n+  private void parseInternal(String contents)\n+      throws JSONException, SourceMapParseException {\n+    JSONObject sourceMapRoot = new JSONObject(contents);\n+\n+    // Check basic assertions about the format.\n+    int version = sourceMapRoot.getInt(\"version\");\n+    if (version != 2) {\n+      throw new SourceMapParseException(\"Unknown version: \" + version);\n+    }\n+\n+    String file = sourceMapRoot.getString(\"file\");\n+    if (file.isEmpty()) {\n+      throw new SourceMapParseException(\"File entry is missing or empty\");\n+    }\n+\n+    int lineCount = sourceMapRoot.getInt(\"lineCount\");\n+    lineMaps = sourceMapRoot.getJSONArray(\"lineMaps\");\n+    if (lineCount != lineMaps.length()) {\n+      throw new SourceMapParseException(\n+          \"lineMaps length does not match lineCount\");\n+    }\n+\n+    // Build an empty character map. The character map will be filled in as\n+    // lines are requested.\n+    characterMap = Maps.newHashMap();\n+\n+    JSONArray sources = sourceMapRoot.getJSONArray(\"sources\");\n+    JSONArray names = sourceMapRoot.has(\"names\")\n+        ? sourceMapRoot.getJSONArray(\"names\") : null;\n+\n+    // Create each of the OriginalMappings.\n+    JSONArray jsonMappings = sourceMapRoot.getJSONArray(\"mappings\");\n+    mappings = Lists.newArrayListWithCapacity(lineCount);\n+\n+    for (int i = 0; i < jsonMappings.length(); i++) {\n+      JSONArray entry = jsonMappings.getJSONArray(i);\n+\n+      // The name can be accessed in two ways: Directly (i.e. a string) or\n+      // indirectly (i.e. an index into the name map).\n+      String name = entry.optString(3, \"\");\n+      if (names != null) {\n+        try {\n+          int nameIndex = entry.getInt(3);\n+          name = names.getString(nameIndex);\n+        } catch (JSONException e) {\n+        }\n+      }\n+\n+      // Build the new OriginalMapping entry.\n+      String sourceFile = sources.getString(entry.getInt(0));\n+      int lineNumber = entry.getInt(1);\n+      int column = entry.getInt(2);\n+\n+      OriginalMapping.Builder builder = OriginalMapping.newBuilder()\n+          .setOriginalFile(sourceFile)\n+          .setLineNumber(lineNumber)\n+          .setColumnPosition(column)\n+          .setIdentifier(name);\n+      mappings.add(builder.build());\n+    }\n+  }\n+\n+  @Override\n+  public OriginalMapping getMappingForLine(int lineNumber, int columnIndex) {\n+    // Normalize the line and column numbers to 0.\n+    lineNumber--;\n+    columnIndex--;\n+\n+    if (lineNumber >= lineMaps.length()) {\n+      return null;\n+    }\n+\n+    if (!characterMap.containsKey(lineNumber)) {\n+      // Parse the line map entry and place it into the character map.\n+      try {\n+        characterMap.put(lineNumber,\n+            SourceMapLineDecoder.decodeLine(lineMaps.getString(lineNumber)));\n+      } catch (JSONException jse) {\n+        throw new IllegalStateException(\n+            \"JSON exception when retrieving line map\", jse);\n+      }\n+    }\n+\n+    List<Integer> map = characterMap.get(lineNumber);\n+    if (map == null || map.size() <= columnIndex) {\n+      return null;\n+    }\n+\n+    int index = map.get(columnIndex);\n+    Preconditions.checkState(index < mappings.size(),\n+        \"Invalid mapping reference\");\n+    return mappings.get(index);\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapLineDecoder.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+\n+/**\n+ * Class for parsing the line maps in SourceMap v2.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ * @author jschorr@google.com (Joseph Schorr)\n+ */\n+// NOTE : Copied from the JSC to avoid a dependency.\n+// TODO(user): Move this into a central shared location.\n+class SourceMapLineDecoder {\n+  /**\n+   *  A map used to convert integer values in the range 0-63 to their base64\n+   *  values.\n+   */\n+  private static final String BASE64_MAP =\n+      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n+      \"abcdefghijklmnopqrstuvwzyz\" +\n+      \"0123456789+/\";\n+\n+  /**\n+   * Decodes a line in a character map into a list of mapping IDs.\n+   */\n+  static List<Integer> decodeLine(String lineSource) {\n+    return decodeLine(new StringParser(lineSource));\n+  }\n+\n+  private SourceMapLineDecoder() {}\n+\n+  private static LineEntry decodeLineEntry(String in, int lastId) {\n+    return decodeLineEntry(new StringParser(in), lastId);\n+  }\n+\n+  private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n+    int repDigits = 0;\n+\n+    // Determine the number of digits used for the repetition count.\n+    // Each \"!\" indicates another base64 digit.\n+    for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n+      repDigits++;\n+      reader.next(); // consume the \"!\"\n+    }\n+\n+    int idDigits = 0;\n+    int reps = 0;\n+    if (repDigits == 0) {\n+      // No repetition digit escapes, so the next character represents the\n+      // number of digits in the id (bottom 2 bits) and the number of\n+      // repetitions (top 4 digits).\n+      char digit = reader.next();\n+      int value = addBase64Digit(digit, 0);\n+      reps = (value >> 2);\n+      idDigits = (value & 3);\n+    } else {\n+      char digit = reader.next();\n+      idDigits = addBase64Digit(digit, 0);\n+\n+      int value = 0;\n+      for (int i = 0; i < repDigits; i++) {\n+        digit = reader.next();\n+        value = addBase64Digit(digit, value);\n+      }\n+      reps = value;\n+    }\n+\n+    // Adjust for 1 offset encoding.\n+    reps += 1;\n+    idDigits += 1;\n+\n+    // Decode the id token.\n+    int value = 0;\n+    for (int i = 0; i < idDigits; i++) {\n+      char digit = reader.next();\n+      value = addBase64Digit(digit, value);\n+    }\n+    int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n+    return new LineEntry(mappingId, reps);\n+  }\n+\n+  private static List<Integer> decodeLine(StringParser reader) {\n+    List<Integer> result = Lists.newArrayListWithCapacity(512);\n+    int lastId = 0;\n+    do {\n+      LineEntry entry = decodeLineEntry(reader, lastId);\n+      lastId = entry.id;\n+\n+      for (int i=0; i < entry.reps; i++) {\n+        result.add(entry.id);\n+      }\n+    } while(reader.hasNext());\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Build base64 number a digit at a time, most significant digit first.\n+   */\n+  private static int addBase64Digit(char digit, int previousValue) {\n+    return (previousValue * 64) + BASE64_MAP.indexOf(digit);\n+  }\n+\n+  /**\n+   * @return the id from the relative id.\n+   */\n+  private static int getIdFromRelativeId(int rawId, int digits, int lastId) {\n+    // The value range depends on the number of digits\n+    int base = 1 << (digits * 6);\n+    return ((rawId >= base/2) ? rawId - base : rawId) + lastId;\n+  }\n+\n+  /**\n+   * Simple class for tracking a single entry in a line map.\n+   */\n+  static class LineEntry {\n+    final int id;\n+    final int reps;\n+    public LineEntry(int id, int reps) {\n+      this.id = id;\n+      this.reps = reps;\n+    }\n+  }\n+\n+  /**\n+   * A simple class for maintaining the current location\n+   * in the input.\n+   */\n+  static class StringParser {\n+    final String content;\n+    int current = 0;\n+\n+    StringParser(String content) {\n+      this.content = content;\n+    }\n+\n+    char next() {\n+      return content.charAt(current++);\n+    }\n+\n+    char peek() {\n+      return content.charAt(current);\n+    }\n+\n+    boolean hasNext() {\n+      return  current < content.length() -1;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapParseException.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+/**\n+ * Throw if an invalid or unknown source map is encountered.\n+ */\n+public class SourceMapParseException extends Exception {\n+  public SourceMapParseException(String message) {\n+    super(message);\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapping.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping;\n+\n+/**\n+ * Interface for provide a way of mapping (line, column) positions back to\n+ * positions in the original (uncompiled) source code.\n+ *\n+ */\n+public interface SourceMapping {\n+  /**\n+   * Returns the original mapping for the line number and column position found\n+   * in the source map. Returns null if none is found.\n+   *\n+   * @param lineNumber The line number, with the first being '1'.\n+   * @param columnIndex The column index, with the first being '1'.\n+   */\n+  OriginalMapping getMappingForLine(int lineNumber, int columnIndex);\n+}\n--- /dev/null\n+++ b/test/com/google/debugging/sourcemap/SourceMapConsumerV1Test.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.debugging.sourcemap.SourceMapConsumerV1;\n+import com.google.debugging.sourcemap.SourceMapParseException;\n+import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping;\n+\n+import junit.framework.TestCase;\n+\n+public class SourceMapConsumerV1Test extends TestCase {\n+\n+  public SourceMapConsumerV1Test() {\n+  }\n+\n+  public SourceMapConsumerV1Test(String name) {\n+    super(name);\n+  }\n+\n+  public void testGetMappingForLine() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 2 }\\n\");\n+    sb.append(\"[0,,,,1,,2]\\n\");\n+    sb.append(\"[3,,,,,,,]\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"['test.js']\\n\");\n+    sb.append(\"['foo.js']\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+    sb.append(\"['test.js', 0, 1]\\n\");\n+    sb.append(\"['bleg.js', 5, 8, 'hello']\\n\");\n+    sb.append(\"['bleg.js', 12, 78]\\n\");\n+    sb.append(\"['foo.js', 15, 16, 'yo!']\");\n+\n+    SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+    sourceMap.parse(sb.toString());\n+\n+    OriginalMapping mapping = sourceMap.getMappingForLine(1, 1);\n+\n+    assertNotNull(mapping);\n+    assertEquals(\"test.js\", mapping.getOriginalFile());\n+    assertEquals(0, mapping.getLineNumber());\n+    assertEquals(1, mapping.getColumnPosition());\n+    assertEquals(\"\", mapping.getIdentifier());\n+\n+    mapping = sourceMap.getMappingForLine(1, 6);\n+    assertNotNull(mapping);\n+    assertEquals(\"bleg.js\", mapping.getOriginalFile());\n+    assertEquals(5, mapping.getLineNumber());\n+    assertEquals(8, mapping.getColumnPosition());\n+    assertEquals(\"hello\", mapping.getIdentifier());\n+\n+    mapping = sourceMap.getMappingForLine(2, 4);\n+    assertNotNull(mapping);\n+    assertEquals(\"foo.js\", mapping.getOriginalFile());\n+    assertEquals(15, mapping.getLineNumber());\n+    assertEquals(16, mapping.getColumnPosition());\n+    assertEquals(\"yo!\", mapping.getIdentifier());\n+  }\n+\n+  public void testLineEdges() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 2 }\\n\");\n+    sb.append(\"[100]\\n\");\n+    sb.append(\"[200]\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"['test.js']\\n\");\n+    sb.append(\"['foo.js']\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+    for (int i = 0; i <= 200; i++) {\n+      sb.append(\"['foo.js', \").append(i).append(\", 1]\\n\");\n+    }\n+\n+    SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+    sourceMap.parse(sb.toString());\n+\n+    OriginalMapping mapping = sourceMap.getMappingForLine(-1, 1);\n+    assertNull(mapping);\n+\n+    mapping = sourceMap.getMappingForLine(0, 1);\n+    assertNull(mapping);\n+\n+    mapping = sourceMap.getMappingForLine(1, 1);\n+    assertEquals(100, mapping.getLineNumber());\n+\n+    mapping = sourceMap.getMappingForLine(2, 1);\n+    assertEquals(200, mapping.getLineNumber());\n+\n+    mapping = sourceMap.getMappingForLine(3, 1);\n+    assertNull(mapping);\n+  }\n+\n+  public void testColumnEdges() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"[100, 101]\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+    for (int i = 0; i <= 200; i++) {\n+      sb.append(\"['foo.js', \").append(i).append(\", 1]\\n\");\n+    }\n+\n+    SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+    sourceMap.parse(sb.toString());\n+\n+    OriginalMapping mapping = sourceMap.getMappingForLine(1, -1);\n+    assertNull(mapping);\n+\n+    mapping = sourceMap.getMappingForLine(1, 0);\n+    assertNull(mapping);\n+\n+    mapping = sourceMap.getMappingForLine(1, 1);\n+    assertEquals(100, mapping.getLineNumber());\n+\n+    mapping = sourceMap.getMappingForLine(1, 2);\n+    assertEquals(101, mapping.getLineNumber());\n+\n+    // Columns beyond the end of the line are treated the same\n+    // as the last column.\n+    mapping = sourceMap.getMappingForLine(1, 3);\n+    assertEquals(101, mapping.getLineNumber());\n+  }\n+\n+  public void testNegativeOneInLineMap() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"[200,-1,199,-1]\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+    for (int i = 0; i <= 200; i++) {\n+      sb.append(\"['foo.js', 1, \").append(i).append(\"]\\n\");\n+    }\n+\n+    SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+    sourceMap.parse(sb.toString());\n+\n+    OriginalMapping mapping = sourceMap.getMappingForLine(1, 2);\n+    assertNull(mapping);\n+\n+    mapping = sourceMap.getMappingForLine(1, 4);\n+    assertNull(mapping);\n+  }\n+\n+  public void testSimpleParse() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"[0,,,,1,2]\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"['test.js']\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+    sb.append(\"['test.js', 0, 1]\\n\");\n+    sb.append(\"['test.js', 0, 1, 'hello']\\n\");\n+    sb.append(\"['test.js', 0, 1]\");\n+\n+    SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+    sourceMap.parse(sb.toString());\n+  }\n+\n+  public void testBlankLine() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+\n+    SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+    sourceMap.parse(sb.toString());\n+  }\n+\n+  public void testCountFailure() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ counter : 1 }\\n\");\n+\n+    assertException(\"Missing 'count'\", sb);\n+  }\n+\n+  public void testInvalidCountFailure() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 0 }\\n\");\n+\n+    assertException(\"Count must be >= 1\", sb);\n+  }\n+\n+  public void testInvalidJSONFailure() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 2 }\\n\");\n+    sb.append(\"[0,,,,2\\n\");\n+\n+    assertExceptionStartsWith(\"JSON parse exception: org.json.JSONException: \" +\n+                    \"Expected a ',' or ']' at \", sb);\n+  }\n+\n+  public void testInvalidHeaderFailure() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"[0,,,1]\\n\");\n+    sb.append(\"[3,,,4]\\n\");\n+\n+    assertException(\n+        \"Expected /** Begin file information. **/ got [3,,,4]\", sb);\n+  }\n+\n+  public void testInvalidPostHeaderToken() throws Exception {\n+     StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"[0,,,1]\\n\");\n+    sb.append(\"/** Begin file information. **/f\\n\");\n+\n+    assertException(\"Expected /** Begin file information. **/\"\n+        + \" got /** Begin file information. **/f\", sb);\n+  }\n+\n+  public void testInvalidMappingArrayFailure() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"[0,,,,1,2]\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"['test.js']\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+    sb.append(\"['test.js', 0]\\n\");\n+\n+    assertException(\"Invalid mapping array\", sb);\n+  }\n+\n+  public void testMultipleLineFragments() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"[0,1,2,3,260,261,262]\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+    for (int i = 0; i < 262; i++) {\n+      sb.append(\"['frog/test\" + i + \".js', \" + i + \", 1]\\n\");\n+    }\n+    sb.append(\"['frog/testigloo.js', 500, 1]\");\n+\n+    SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+    sourceMap.parse(sb.toString());\n+\n+    OriginalMapping mapping = sourceMap.getMappingForLine(1, 1);\n+\n+    assertNotNull(mapping);\n+    assertEquals(\"frog/test0.js\", mapping.getOriginalFile());\n+    assertEquals(0, mapping.getLineNumber());\n+    assertEquals(1, mapping.getColumnPosition());\n+    assertEquals(\"\", mapping.getIdentifier());\n+\n+    mapping = sourceMap.getMappingForLine(1, 6);\n+    assertNotNull(mapping);\n+    assertEquals(\"frog/test261.js\", mapping.getOriginalFile());\n+    assertEquals(261, mapping.getLineNumber());\n+    assertEquals(1, mapping.getColumnPosition());\n+  }\n+\n+  public void testMultipleMappingFragments() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"/** Begin line maps. **/{ count : 1 }\\n\");\n+    sb.append(\"[0,1,2,3,260,261,262,1023]\\n\");\n+    sb.append(\"/** Begin file information. **/\\n\");\n+    sb.append(\"\\n\");\n+    sb.append(\"/** Begin mapping definitions. **/\\n\");\n+    for (int i = 0; i < 2000; i++) {\n+      sb.append(\"['frog/test\" + (i / 100) + \".js', \" + i + \", 1]\\n\");\n+    }\n+    sb.append(\"['frog/testigloo.js', 500, 1]\");\n+\n+    SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+    sourceMap.parse(sb.toString());\n+\n+    OriginalMapping mapping = sourceMap.getMappingForLine(1, 1);\n+\n+    assertNotNull(mapping);\n+    assertEquals(\"frog/test0.js\", mapping.getOriginalFile());\n+    assertEquals(0, mapping.getLineNumber());\n+    assertEquals(1, mapping.getColumnPosition());\n+    assertEquals(\"\", mapping.getIdentifier());\n+\n+    mapping = sourceMap.getMappingForLine(1, 6);\n+    assertNotNull(mapping);\n+    assertEquals(\"frog/test2.js\", mapping.getOriginalFile());\n+    assertEquals(261, mapping.getLineNumber());\n+    assertEquals(1, mapping.getColumnPosition());\n+\n+    mapping = sourceMap.getMappingForLine(1, 8);\n+    assertNotNull(mapping);\n+    assertEquals(\"frog/test10.js\", mapping.getOriginalFile());\n+    assertEquals(1023, mapping.getLineNumber());\n+    assertEquals(1, mapping.getColumnPosition());\n+  }\n+\n+  private void assertException(String exception, StringBuilder sb) {\n+    boolean exceptionRaised = false;\n+\n+    try {\n+      SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+      sourceMap.parse(sb.toString());\n+\n+    } catch (SourceMapParseException pe) {\n+      assertEquals(exception, pe.getMessage());\n+      exceptionRaised = true;\n+    }\n+\n+    assertTrue(exceptionRaised);\n+  }\n+\n+  private void assertExceptionStartsWith(String exception, StringBuilder sb) {\n+    boolean exceptionRaised = false;\n+\n+    try {\n+      SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1();\n+      sourceMap.parse(sb.toString());\n+\n+    } catch (SourceMapParseException pe) {\n+      assertTrue(\n+        \"expected <\" + exception +\"> but was <\"+ pe.getMessage() +\">\",\n+        pe.getMessage().startsWith(exception));\n+      exceptionRaised = true;\n+    }\n+\n+    assertTrue(exceptionRaised);\n+  }\n+\n+}\n--- /dev/null\n+++ b/test/com/google/debugging/sourcemap/SourceMapConsumerV2Test.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import com.google.debugging.sourcemap.SourceMapConsumerV2;\n+import com.google.debugging.sourcemap.SourceMapParseException;\n+import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping;\n+\n+import junit.framework.TestCase;\n+\n+public class SourceMapConsumerV2Test extends TestCase {\n+\n+  public SourceMapConsumerV2Test() {\n+  }\n+\n+  public SourceMapConsumerV2Test(String name) {\n+    super(name);\n+  }\n+\n+  public void testEmptyMap() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\n\");\n+    sb.append(\"\\\"version\\\": 2,\\n\");\n+    sb.append(\"\\\"file\\\": \\\"somefile.js\\\",\\n\");\n+    sb.append(\"\\\"lineCount\\\": 0,\\n\");\n+    sb.append(\"\\\"lineMaps\\\": [],\\n\");\n+    sb.append(\"\\\"sources\\\": [],\\n\");\n+    sb.append(\"\\\"mappings\\\": []\\n\");\n+    sb.append(\"}\\n\");\n+\n+    SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2();\n+    sourceMap.parse(sb.toString());\n+  }\n+\n+  public void testGetMappingForLine() throws Exception {\n+    // Input Code: function f(foo, bar) { foo = foo + bar + 2; return foo; }\n+    String mapData =\n+        \"{\\n\" +\n+        \"\\\"version\\\":2,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":1,\\n\" +\n+        \"\\\"lineMaps\\\":\" +\n+        \"[\\\"cAEBABIBA/ICA+ADICA/ICA+IDA9AEYBMBA5\\\"],\\n\" +\n+        \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+        \"\\\"mappings\\\":[[0,1,9,\\\"f\\\"],\\n\" +\n+        \"[0,1,9,\\\"f\\\"],\\n\" +\n+        \"[0,1,10],\\n\" +\n+        \"[0,1,11,\\\"foo\\\"],\\n\" +\n+        \"[0,1,16,\\\"bar\\\"],\\n\" +\n+        \"[0,1,21],\\n\" +\n+        \"[0,1,23],\\n\" +\n+        \"[0,1,23,\\\"foo\\\"],\\n\" +\n+        \"[0,1,29,\\\"foo\\\"],\\n\" +\n+        \"[0,1,35,\\\"bar\\\"],\\n\" +\n+        \"[0,1,41],\\n\" +\n+        \"[0,1,44],\\n\" +\n+        \"[0,1,51,\\\"foo\\\"],\\n\" +\n+        \"]\\n\" +\n+        \"}\\n\";\n+\n+    SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2();\n+    sourceMap.parse(mapData);\n+\n+    OriginalMapping mapping = sourceMap.getMappingForLine(1, 10);\n+\n+    assertNotNull(mapping);\n+    assertEquals(\"testcode\", mapping.getOriginalFile());\n+    assertEquals(1, mapping.getLineNumber());\n+    assertEquals(9, mapping.getColumnPosition());\n+    assertEquals(\"f\", mapping.getIdentifier());\n+\n+    mapping = sourceMap.getMappingForLine(1, 40);\n+\n+    assertNotNull(mapping);\n+    assertEquals(\"testcode\", mapping.getOriginalFile());\n+    assertEquals(1, mapping.getLineNumber());\n+    assertEquals(44, mapping.getColumnPosition());\n+    assertEquals(\"\", mapping.getIdentifier());\n+\n+    mapping = sourceMap.getMappingForLine(1, 42);\n+    assertNotNull(mapping);\n+    assertEquals(\"testcode\", mapping.getOriginalFile());\n+    assertEquals(1, mapping.getLineNumber());\n+    assertEquals(51, mapping.getColumnPosition());\n+    assertEquals(\"foo\", mapping.getIdentifier());\n+  }\n+\n+  public void testGetMappingForLineWithNameIndex() throws Exception {\n+    String mapData =\n+        \"{\\n\" +\n+        \"\\\"version\\\":2,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":1,\\n\" +\n+        \"\\\"lineMaps\\\":\" +\n+        \"[\\\"cAEBABIBA/ICA+ADICA/ICA+IDA9AEYBMBA5\\\"],\\n\" +\n+        \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+        \"\\\"names\\\": [\\\"f\\\"],\\n\" +\n+        \"\\\"mappings\\\":[[0,1,9,0],\\n\" +\n+        \"[0,1,9,0]\\n\" +\n+        \"]\\n\" +\n+        \"}\\n\";\n+\n+    SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2();\n+    sourceMap.parse(mapData);\n+\n+    OriginalMapping mapping = sourceMap.getMappingForLine(1, 10);\n+\n+    assertNotNull(mapping);\n+    assertEquals(\"testcode\", mapping.getOriginalFile());\n+    assertEquals(1, mapping.getLineNumber());\n+    assertEquals(9, mapping.getColumnPosition());\n+    assertEquals(\"f\", mapping.getIdentifier());\n+  }\n+\n+  public void testInvalidJSONFailure() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"notjson\");\n+\n+    assertExceptionStartsWith(\"JSON parse exception: org.json.JSONException: \"\n+         + \"A JSONObject text must begin \"\n+         + \"with '{' at character 1\", sb);\n+  }\n+\n+  public void testUnknownVersion() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\\"version\\\": 3}\");\n+    assertException(\"Unknown version: 3\", sb);\n+  }\n+\n+  public void testMissingFile() throws Exception {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\\"version\\\": 2, \\\"file\\\": \\\"\\\"}\");\n+    assertException(\"File entry is missing or empty\", sb);\n+  }\n+\n+  private void assertException(String exception, StringBuilder sb) {\n+    boolean exceptionRaised = false;\n+\n+    try {\n+      SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2();\n+      sourceMap.parse(sb.toString());\n+\n+    } catch (SourceMapParseException pe) {\n+      assertEquals(exception, pe.getMessage());\n+      exceptionRaised = true;\n+    }\n+\n+    assertTrue(exceptionRaised);\n+  }\n+\n+  private void assertExceptionStartsWith(String exception, StringBuilder sb) {\n+    boolean exceptionRaised = false;\n+\n+    try {\n+      SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2();\n+      sourceMap.parse(sb.toString());\n+\n+    } catch (SourceMapParseException pe) {\n+      assertTrue(\n+        \"expected <\" + exception +\"> but was <\"+ pe.getMessage() +\">\",\n+        pe.getMessage().startsWith(exception));\n+      exceptionRaised = true;\n+    }\n+\n+    assertTrue(exceptionRaised);\n+  }\n+}", "timestamp": 1300929924, "metainfo": ""}