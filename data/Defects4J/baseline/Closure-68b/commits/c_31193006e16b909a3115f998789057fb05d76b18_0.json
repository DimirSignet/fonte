{"sha": "31193006e16b909a3115f998789057fb05d76b18", "log": "Add a --debug flag for easier debugging.  Turn off autoboxing from number -> Number, string -> String, etc.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Join;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.GraphColoring;\n+import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n-import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n-import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     CompilerPass, ScopedCallback {\n \n   private final AbstractCompiler compiler;\n-  private final Deque<GraphColoring<Var, ?>> colorings;\n-\n-  /** Logs all name assignments */\n-  private StringBuilder coalescedLog;\n+  private final Deque<GraphColoring<Var, Void>> colorings;\n+  private final boolean usePseudoNames;\n \n   private static final Comparator<Var> coloringTieBreaker =\n       new Comparator<Var>() {\n     }\n   };\n \n-  CoalesceVariableNames(AbstractCompiler compiler) {\n+  /**\n+   * @param usePseudoNames For debug purposes, when merging variable foo and bar\n+   * to foo, rename both variable to foo_bar.\n+   */\n+  CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {\n     this.compiler = compiler;\n     colorings = Lists.newLinkedList();\n-    coalescedLog = new StringBuilder();\n+    this.usePseudoNames = usePseudoNames;\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n-\n-    // Lastly, write the report to the debug log.\n-    compiler.addToDebugLog(\"JS vars coalesced:\\n\" + coalescedLog.toString());\n-    coalescedLog = new StringBuilder();\n   }\n \n   @Override\n         computeVariableNamesInterferenceGraph(\n             t, cfg, liveness.getEscapedLocals());\n \n-    GraphColoring<Var, ?> coloring =\n+    GraphColoring<Var, Void> coloring =\n         new GreedyGraphColoring<Var, Void>(interferenceGraph,\n             coloringTieBreaker);\n \n       return;\n     }\n     Var coalescedVar = colorings.peek().getPartitionSuperNode(var);\n-    if (vNode.getValue().equals(coalescedVar)) {\n-      // The coalesced name is itself, nothing to do.\n-      return;\n-    }\n-\n-    if (var.getNameNode() == n) {\n-      coalescedLog.append(n.getString()).append(\" => \")\n-          .append(coalescedVar.name).append(\" in \")\n-          .append(t.getSourceName()).append(':')\n-          .append(n.getLineno()).append('\\n');\n-    }\n-\n-    // Rename.\n-    n.setString(coalescedVar.name);\n-    compiler.reportCodeChange();\n-\n-    if (NodeUtil.isVar(parent)) {\n-      removeVarDeclaration(n);\n+    \n+    if (!usePseudoNames) {\n+      if (vNode.getValue().equals(coalescedVar)) {\n+        // The coalesced name is itself, nothing to do.\n+        return;\n+      }\n+\n+      // Rename.\n+      n.setString(coalescedVar.name);\n+      compiler.reportCodeChange();\n+\n+      if (NodeUtil.isVar(parent)) {\n+        removeVarDeclaration(n);\n+      }\n+    } else {\n+      // This code block is slow but since usePseudoName is for debugging,\n+      // we should not sacrifice performance for non-debugging compilation to\n+      // make this fast.\n+      String pseudoName = null;\n+      Set<String> allMergedNames = Sets.newTreeSet();\n+      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n+        Var iVar = i.next();\n+        if (coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) {\n+          allMergedNames.add(iVar.name);\n+        }\n+      }\n+      \n+      // Keep its original name.\n+      if (allMergedNames.size() == 1) {\n+        return;\n+      }\n+      \n+      pseudoName = Join.join(\"_\", allMergedNames);\n+      \n+      while (t.getScope().isDeclared(pseudoName, true)) {\n+        pseudoName += \"$\";\n+      }\n+      \n+      n.setString(pseudoName);\n+      compiler.reportCodeChange();\n+\n+      if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isVar(parent)) {\n+        removeVarDeclaration(n);\n+      }\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     options.optimizeArgumentsArray = true;\n \n     // All the advance optimizations.\n+    options.reserveRawExports = true;\n     options.variableRenaming = VariableRenamingPolicy.ALL;\n     options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;\n     options.removeUnusedPrototypeProperties = true;\n--- a/src/com/google/javascript/jscomp/CompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/CompilerRunner.java\n \n   @FlagSpec(help = \"Specifies the compilation level to use. Options: \" +\n             \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n-  private static final Flag<CompilationLevel> FLAG_compilation_level\n+  static final Flag<CompilationLevel> FLAG_compilation_level\n       = Flag.value(CompilationLevel.SIMPLE_OPTIMIZATIONS);\n \n   @FlagSpec(help = \"Specifies the warning level to use. Options: \" +\n \n   @FlagSpec(help = \"Specifies whether the default externs should be excluded.\")\n   static final Flag<Boolean> FLAG_use_only_custom_externs\n+      = Flag.value(false);\n+\n+  @FlagSpec(help = \"Enable debugging opitons.\")\n+  static final Flag<Boolean> FLAG_debug\n       = Flag.value(false);\n \n   /**\n \n   @FlagSpec(help = \"Specifies which formatting options, if any, should be \"\n       + \"applied to the output JS\")\n-  private static final Flag<List<FormattingOption>> FLAG_formatting\n+  static final Flag<List<FormattingOption>> FLAG_formatting\n       = Flag.enumList(FormattingOption.class);\n \n   @FlagSpec(help = \"Processes built-ins from the Closure library, such as \"\n       + \"goog.require(), goog.provide(), and goog.exportSymbol().\")\n-  private static final Flag<Boolean> FLAG_process_closure_primitives\n+  static final Flag<Boolean> FLAG_process_closure_primitives\n       = Flag.value(true);\n \n   public CompilerRunner(String[] args) {\n     options.setCodingConvention(new ClosureCodingConvention());\n     CompilationLevel level = FLAG_compilation_level.get();\n     level.setOptionsForCompilationLevel(options);\n+    if (FLAG_debug.get()) {\n+      level.setDebugOptionsForCompilationLevel(options);\n+    }\n+\n     WarningLevel wLevel = FLAG_warning_level.get();\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : FLAG_formatting.get()) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       new PassFactory(\"coalesceVariableNames\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new CoalesceVariableNames(compiler);\n+      return new CoalesceVariableNames(compiler, options.generatePseudoNames);\n     }\n   };\n \n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   public boolean canAssignTo(JSType that) {\n     if (this.isSubtype(that)) {\n       return true;\n-    }\n-    if (autoboxesTo() != null) {\n-      return autoboxesTo().isSubtype(that);\n-    }\n-    if (unboxesTo() != null) {\n-      return unboxesTo().isSubtype(that);\n     }\n     return false;\n   }\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n   // The spacing in this file is not exactly standard but it greatly helps\n   // picking out which variable names are merged.\n \n+  private boolean usePseudoName = false;\n+  \n+  @Override\n+  protected int getNumRepetitions() {\n+   return 1;\n+  }  \n+  \n+  @Override\n+  public void setUp() {\n+    usePseudoName = false;\n+  }\n+  \n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n       public void process(Node externs, Node js) {\n         NodeTraversal.traverse(compiler, js,\n-            new CoalesceVariableNames(compiler));\n+            new CoalesceVariableNames(compiler, usePseudoName));\n       }\n     };\n   }\n         \"   this.load();\");\n   }\n \n+  public void testUsePseduoNames() {\n+    usePseudoName = true;\n+    inFunction(\"var x   = 0; print(x  ); var   y = 1; print(  y)\",\n+               \"var x_y = 0; print(x_y);     x_y = 1; print(x_y)\");\n+    \n+    inFunction(\"var x_y = 1; var x   = 0; print(x  ); var     y = 1;\" + \n+               \"print(  y); print(x_y);\",\n+\n+               \"var x_y = 1; var x_y$ = 0; print(x_y$);     x_y$ = 1;\" + \"\" +\n+               \"print(x_y$); print(x_y);\");\n+    \n+    inFunction(\"var x_y = 1; function f() {\" +\n+               \"var x    = 0; print(x  ); var y = 1; print( y);\" +\n+               \"print(x_y);}\",\n+\n+               \"var x_y = 1; function f() {\" +\n+               \"var x_y$ = 0; print(x_y$); x_y$ = 1; print(x_y$);\" +\n+               \"print(x_y);}\");\n+  }\n+  \n   private void inFunction(String src) {\n     inFunction(src, src);\n   }\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n   @Override\n   public void setUp() {\n     Flags.disableStateCheckingForTest();\n+    Flags.resetAllFlagsForTest();\n     lastCompiler = null;\n   }\n \n \n   public void testIssue70() {\n     test(\"function foo({}) {}\", RhinoErrorReporter.PARSE_ERROR);\n+  }\n+\n+  public void testDebugFlag1() {\n+    CompilerRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n+    CompilerRunner.FLAG_debug.setForTest(false);\n+    testSame(\"function foo(a) {}\");\n+  }\n+\n+  public void testDebugFlag2() {\n+    CompilerRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n+    CompilerRunner.FLAG_debug.setForTest(true);\n+    test(\"function foo(a) {}\",\n+         \"function foo($a$$) {}\");\n+  }\n+\n+  public void testDebugFlag3() {\n+    CompilerRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n+    CompilerRunner.FLAG_warning_level.setForTest(\n+        WarningLevel.QUIET);\n+    CompilerRunner.FLAG_debug.setForTest(false);\n+    test(\"function Foo() {};\" +\n+         \"Foo.x = 1;\" +\n+         \"function f() {throw new Foo().x;} f();\",\n+         \"function a() {};\" +\n+         \"throw new a().a;\");\n+  }\n+\n+  public void testDebugFlag4() {\n+    CompilerRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n+    CompilerRunner.FLAG_warning_level.setForTest(\n+        WarningLevel.QUIET);\n+    CompilerRunner.FLAG_debug.setForTest(true);\n+    test(\"function Foo() {};\" +\n+        \"Foo.x = 1;\" +\n+        \"function f() {throw new Foo().x;} f();\",\n+        \"function $Foo$$() {};\" +\n+        \"throw new $Foo$$().$x$;\");\n   }\n \n   /* Helper functions */\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n \n   public void testDocumentationThrows() throws Exception {\n     JSDocInfo jsdoc\n-        = parse(\"@throws {Number} This is a description.*/\", true);\n+        = parse(\"@throws {number} This is a description.*/\", true);\n \n     assertEquals(\"This is a description.\",\n                  jsdoc.getDescriptionForThrownType(NUMBER_TYPE, null));\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     // canAssignTo\n     assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(ALL_TYPE));\n     assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n-    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(NUMBER_TYPE));\n+    assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(NUMBER_TYPE));\n     assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(functionType));\n     assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(NULL_TYPE));\n     assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(OBJECT_TYPE));\n     assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(namedGoogBar));\n     assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(\n             createUnionType(NUMBER_OBJECT_TYPE, NULL_TYPE)));\n-    assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(\n+    assertFalse(NUMBER_OBJECT_TYPE.canAssignTo(\n             createUnionType(NUMBER_TYPE, NULL_TYPE)));\n     assertTrue(NUMBER_OBJECT_TYPE.canAssignTo(UNKNOWN_TYPE));\n \n     assertTrue(NUMBER_TYPE.canAssignTo(NUMBER_TYPE));\n     assertFalse(NUMBER_TYPE.canAssignTo(functionType));\n     assertFalse(NUMBER_TYPE.canAssignTo(NULL_TYPE));\n-    assertTrue(NUMBER_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(NUMBER_TYPE.canAssignTo(OBJECT_TYPE));\n     assertFalse(NUMBER_TYPE.canAssignTo(DATE_TYPE));\n     assertTrue(NUMBER_TYPE.canAssignTo(unresolvedNamedType));\n     assertFalse(NUMBER_TYPE.canAssignTo(namedGoogBar));\n     // canAssignTo\n     assertTrue(STRING_OBJECT_TYPE.canAssignTo(ALL_TYPE));\n     assertTrue(STRING_OBJECT_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n-    assertTrue(STRING_OBJECT_TYPE.canAssignTo(STRING_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canAssignTo(STRING_TYPE));\n     assertTrue(STRING_OBJECT_TYPE.canAssignTo(OBJECT_TYPE));\n     assertFalse(STRING_OBJECT_TYPE.canAssignTo(NUMBER_TYPE));\n     assertFalse(STRING_OBJECT_TYPE.canAssignTo(DATE_TYPE));\n     assertFalse(STRING_OBJECT_TYPE.canAssignTo(REGEXP_TYPE));\n     assertFalse(STRING_OBJECT_TYPE.canAssignTo(ARRAY_TYPE));\n-    assertTrue(STRING_OBJECT_TYPE.canAssignTo(STRING_TYPE));\n+    assertFalse(STRING_OBJECT_TYPE.canAssignTo(STRING_TYPE));\n \n     // canBeCalled\n     assertFalse(STRING_OBJECT_TYPE.canBeCalled());\n \n     // canAssignTo\n     assertTrue(STRING_TYPE.canAssignTo(ALL_TYPE));\n-    assertTrue(STRING_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canAssignTo(STRING_OBJECT_TYPE));\n     assertFalse(STRING_TYPE.canAssignTo(NUMBER_TYPE));\n-    assertTrue(STRING_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(STRING_TYPE.canAssignTo(OBJECT_TYPE));\n     assertFalse(STRING_TYPE.canAssignTo(NUMBER_TYPE));\n     assertFalse(STRING_TYPE.canAssignTo(DATE_TYPE));\n     assertFalse(STRING_TYPE.canAssignTo(REGEXP_TYPE));\n     assertFalse(BOOLEAN_TYPE.canAssignTo(NUMBER_TYPE));\n     assertFalse(BOOLEAN_TYPE.canAssignTo(functionType));\n     assertFalse(BOOLEAN_TYPE.canAssignTo(NULL_TYPE));\n-    assertTrue(BOOLEAN_TYPE.canAssignTo(OBJECT_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canAssignTo(OBJECT_TYPE));\n     assertFalse(BOOLEAN_TYPE.canAssignTo(DATE_TYPE));\n     assertTrue(BOOLEAN_TYPE.canAssignTo(unresolvedNamedType));\n     assertFalse(BOOLEAN_TYPE.canAssignTo(namedGoogBar));\n     assertTrue(elementsType.canAssignTo(NUMBER_TYPE));\n     assertFalse(elementsType.canAssignTo(functionType));\n     assertFalse(elementsType.canAssignTo(NULL_TYPE));\n-    assertTrue(elementsType.canAssignTo(OBJECT_TYPE)); // autoboxing\n+    assertFalse(elementsType.canAssignTo(OBJECT_TYPE)); // no more autoboxing\n     assertFalse(elementsType.canAssignTo(DATE_TYPE));\n     assertTrue(elementsType.canAssignTo(unresolvedNamedType));\n     assertFalse(elementsType.canAssignTo(namedGoogBar));\n   }\n \n   /**\n-   * Tests that special union types can assign to other types. For instance\n-   * <code>(number,Number)</code> can assign to <code>number</code> or\n-   * <code>Number</code> even though <code>number &lt; (number, Number)</code>\n-   * and <code>Number &lt; (number,Number)</code>. Unions containing the unknown\n-   * type should be able to assign to any other type.\n+   * Tests that special union types can assign to other types.  Unions\n+   * containing the unknown type should be able to assign to any other\n+   * type.\n    */\n   @SuppressWarnings(\"checked\")\n       public void testSpecialUnionCanAssignTo() throws Exception {\n     // autoboxing quirks\n     UnionType numbers =\n         (UnionType) createUnionType(NUMBER_TYPE, NUMBER_OBJECT_TYPE);\n-    assertTrue(numbers.canAssignTo(NUMBER_TYPE));\n-    assertTrue(numbers.canAssignTo(NUMBER_OBJECT_TYPE));\n+    assertFalse(numbers.canAssignTo(NUMBER_TYPE));\n+    assertFalse(numbers.canAssignTo(NUMBER_OBJECT_TYPE));\n     assertFalse(numbers.canAssignTo(EVAL_ERROR_TYPE));\n \n     UnionType strings =\n         (UnionType) createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n-    assertTrue(strings.canAssignTo(STRING_TYPE));\n-    assertTrue(strings.canAssignTo(STRING_OBJECT_TYPE));\n+    assertFalse(strings.canAssignTo(STRING_TYPE));\n+    assertFalse(strings.canAssignTo(STRING_OBJECT_TYPE));\n     assertFalse(strings.canAssignTo(DATE_TYPE));\n \n     UnionType booleans =\n         (UnionType) createUnionType(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE);\n-    assertTrue(booleans.canAssignTo(BOOLEAN_TYPE));\n-    assertTrue(booleans.canAssignTo(BOOLEAN_OBJECT_TYPE));\n+    assertFalse(booleans.canAssignTo(BOOLEAN_TYPE));\n+    assertFalse(booleans.canAssignTo(BOOLEAN_OBJECT_TYPE));\n     assertFalse(booleans.canAssignTo(REGEXP_TYPE));\n \n     // unknown quirks", "timestamp": 1260836306, "metainfo": ""}