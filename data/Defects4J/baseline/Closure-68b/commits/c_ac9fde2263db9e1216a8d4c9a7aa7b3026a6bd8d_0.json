{"sha": "ac9fde2263db9e1216a8d4c9a7aa7b3026a6bd8d", "log": "Tweak inline getters to be safe around \"get\" and \"set\".  R=nicksantos DELTA=71  (57 added, 3 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=111   ", "commit": "\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n         } break;\n \n         case Token.OBJECTLIT: {\n-          // assumes the object literal is well formed\n-          // (has an even number of children)\n-          for (Node key = n.getFirstChild();\n-               key != null; key = key.getNext()) {\n-            if (key.getType() == Token.STRING) {\n+          for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n+            if (key.getType() != Token.NUMBER) {\n               Node value = key.getFirstChild();\n               String name = key.getString();\n-              if (value.getType() == Token.FUNCTION) {\n+              if (key.getType() == Token.STRING\n+                  && value.getType() == Token.FUNCTION) {\n                 addSignature(name, value, t.getSourceName());\n               } else {\n                 getSignatureStore().removeSignature(name);\n           break;\n \n         case Token.OBJECTLIT:\n-          // assumes the object literal is well formed\n-          // (has an even number of children)\n-          for (Node key = n.getFirstChild();\n-               key != null; key = key.getNext()) {\n-            if (key.getType() == Token.STRING) {\n-              Node value = key.getFirstChild();\n-              addPossibleSignature(key.getString(), value, t);\n+          for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n+            switch(key.getType()) {\n+              case Token.STRING:\n+                addPossibleSignature(key.getString(), key.getFirstChild(), t);\n+                break;\n+              case Token.SET:\n+              case Token.GET:\n+                nonMethodProperties.add(key.getString());\n+                break;\n+              case Token.NUMBER:\n+                // Ignore numberic keys.\n+                break;\n+              default:\n+                throw new IllegalStateException(\n+                    \"unexpect OBJECTLIT key: \" + key);\n             }\n           }\n           break;\n--- a/test/com/google/javascript/jscomp/InlineGettersTest.java\n+++ b/test/com/google/javascript/jscomp/InlineGettersTest.java\n     test(definitions + js, definitions + expected);\n   }\n \n-  public void testSimpleInline() {\n+  public void testSimpleInline1() {\n     testWithPrefix(\"function Foo(){}\" +\n         \"Foo.prototype.bar=function(){return this.baz};\",\n         \"var x=(new Foo).bar();var y=(new Foo).bar();\",\n         \"var x=(new Foo).baz;var y=(new Foo).baz\");\n+  }\n+\n+  public void testSimpleInline2() {\n+    testWithPrefix(\"function Foo(){}\" +\n+        \"Foo.prototype={bar:function(){return this.baz}};\",\n+        \"var x=(new Foo).bar();var y=(new Foo).bar();\",\n+        \"var x=(new Foo).baz;var y=(new Foo).baz\");\n+  }\n+\n+  public void testSimpleGetterInline1() {\n+    // TODO(johnlenz): Support this case.\n+    testSame(\"function Foo(){}\" +\n+      \"Foo.prototype={get bar(){return this.baz}};\" +\n+      \"var x=(new Foo).bar;var y=(new Foo).bar\");\n+    // Verify we are not confusing calling the result of an ES5 getter\n+    // with call the getter.\n+    testSame(\"function Foo(){}\" +\n+      \"Foo.prototype={get bar(){return this.baz}};\" +\n+      \"var x=(new Foo).bar();var y=(new Foo).bar()\");\n+  }\n+\n+  public void testSimpleSetterInline1() {\n+    // Verify 'get' and 'set' are not confused.\n+    testSame(\"function Foo(){}\" +\n+      \"Foo.prototype={set bar(a){return this.baz}};\" +\n+      \"var x=(new Foo).bar;var y=(new Foo).bar\");\n+    testSame(\"function Foo(){}\" +\n+      \"Foo.prototype={set bar(a){return this.baz}};\" +\n+      \"var x=(new Foo).bar();var y=(new Foo).bar()\");\n   }\n \n   public void testSelfInline() {\n              \"(new Foo).bar()\");\n   }\n \n+  public void testObjectLit2() {\n+    testSame(\"var blah={bar:function(){}};\" +\n+             \"(new Foo).bar()\");\n+  }\n+\n   public void testObjectLitExtern() {\n     String externs = \"window.bridge={_sip:function(){}};\";\n     testSame(externs, \"window.bridge._sip()\", null);\n     // Anonymous object definition without side-effect should be removed.\n     test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\n   }\n+\n+  public void testAnonymousGet() {\n+    // Anonymous object definition without side-effect should be removed.\n+    testSame(\"({get a(){return function(){}},b:alert}).a(\\\"a\\\")\");\n+    testSame(\"({get a(){},b:alert}).a(\\\"a\\\")\");\n+    testSame(\"({get a(){},b:alert}).a\");\n+  }\n+\n+  public void testAnonymousSet() {\n+    // Anonymous object definition without side-effect should be removed.\n+    testSame(\"({set a(b){return function(){}},b:alert}).a(\\\"a\\\")\");\n+    testSame(\"({set a(b){},b:alert}).a(\\\"a\\\")\");\n+    testSame(\"({set a(b){},b:alert}).a\");\n+  }\n }", "timestamp": 1292002622, "metainfo": ""}