{"sha": "3a76f8e3ce96a5c3fc7baed2012ef8e079ebb9f3", "log": "Use return type information to infer the locality of the function result when possible.  R=nicksantos DELTA=56  (48 added, 3 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=273400   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n \n import java.io.File;\n import java.io.IOException;\n       functionSideEffectMap.put(node, sideEffectInfo);\n \n       if (inExterns) {\n-        // TODO(johnlenz): determine the locality of the results of extern\n-        // functions.\n-        sideEffectInfo.setTaintsReturn();\n+        JSType jstype = node.getJSType();\n+        boolean knownLocalResult = false;\n+        if (jstype != null && jstype.isFunctionType()) {\n+          FunctionType functionType = (FunctionType) jstype;\n+          JSType jstypeReturn = functionType.getReturnType();\n+          if (isLocalValueType(jstypeReturn, true)) {\n+            knownLocalResult = true;\n+          }\n+        }\n+        if (!knownLocalResult) {\n+          sideEffectInfo.setTaintsReturn();\n+        }\n       }\n \n       JSDocInfo info = getJSDocInfoForFunction(node, parent, gramp);\n           sideEffectInfo.setTaintsGlobalState();\n         }\n       }\n+    }\n+\n+    /**\n+     * @return Whether the jstype is something known to be a local value.\n+     */\n+    private boolean isLocalValueType(JSType jstype, boolean recurse) {\n+      Preconditions.checkNotNull(jstype);\n+      JSType subtype =  jstype.getGreatestSubtype(\n+          compiler.getTypeRegistry().getNativeType(JSTypeNative.OBJECT_TYPE));\n+      // If the type includes anything related to a object type, don't assume\n+      // anything about the locality of the value.\n+      return subtype.isNoType();\n     }\n \n     /**\n    * @return Whether the node is known to be a value that is not a reference\n    *     outside the local scope.\n    */\n-  private static boolean isKnownLocalValue(Node value) {\n+  private static boolean isKnownLocalValue(final Node value) {\n     Predicate<Node> taintingPredicate = new Predicate<Node>() {\n       @Override\n       public boolean apply(Node value) {\n         switch (value.getType()) {\n+          case Token.ASSIGN:\n+            // The assignment might cause an alias, look at the lhs.\n+            return false;\n           case Token.THIS:\n             // TODO(johnlenz): maybe redirect this to be a tainting list for 'this'.\n             return false;\n           case Token.NAME:\n             // TODO(johnlenz): add to local tainting list, if the NAME\n             // is known to be a local.\n-\n             return false;\n           case Token.GETELEM:\n           case Token.GETPROP:", "timestamp": 1285711565, "metainfo": ""}