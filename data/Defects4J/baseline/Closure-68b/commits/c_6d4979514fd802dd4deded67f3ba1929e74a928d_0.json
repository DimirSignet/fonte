{"sha": "6d4979514fd802dd4deded67f3ba1929e74a928d", "log": "Propagate known local value information across functions.  This also fixes problems with incomplete local information.  R=nicksantos DELTA=1000  (667 added, 250 deleted, 83 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=0   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/FunctionSideEffectData.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Keeps track of a function's known side effects by type and the\n+ * list of calls that appear in a function's body.\n+ *\n+ */\n+class FunctionSideEffectData {\n+  private final boolean extern;\n+  private final List<Node> callsInFunctionBody = Lists.newArrayList();\n+  private final Scope localScope;\n+  private Set<ValueEntry> nonLocalValues = Sets.newHashSet();\n+  private Set<ValueEntry> modifiedLocals = Sets.newHashSet();\n+  private Multimap<ValueEntry, ValueEntry> valueInfluenceMap =\n+      HashMultimap.create();\n+  private boolean pureFunction = false;\n+  private boolean functionThrows = false;\n+  private boolean taintsGlobalState = false;\n+  private boolean taintsThis = false;\n+  private boolean taintsArguments = false;\n+  private boolean taintsUnknown = false;\n+  private boolean taintsReturn = false;\n+\n+  /**\n+   * Represents a value in the value locality and modification structures:\n+   * #nonLocalValues, #modifiedLocals, #valueInfluenceMap\n+   */\n+  interface ValueEntry {\n+  }\n+\n+  /**\n+   * A representation of the values associated with these the: this and return\n+   * keywords and the arguments pseudo-keyword.\n+   */\n+  static class KeywordValueEntry implements ValueEntry {\n+    // These special token objects are used to track values that we care about\n+    // that are not represented by Vars.\n+    final static ValueEntry THIS = new KeywordValueEntry();\n+    final static ValueEntry RETURN = new KeywordValueEntry();\n+    final static ValueEntry ARGUMENTS = new KeywordValueEntry();\n+\n+    KeywordValueEntry() {}\n+  }\n+\n+  /**\n+   * A named value (vars, functions) entry.\n+   */\n+  static class NameValueEntry implements ValueEntry {\n+    private final String name;\n+\n+    NameValueEntry(Node node) {\n+      Preconditions.checkState(node.getType() == Token.NAME);\n+      this.name = node.getString();\n+    }\n+\n+    NameValueEntry(Var var) {\n+      this.name = var.name;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return name.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o != null\n+          && o instanceof NameValueEntry\n+          && name.equals(((NameValueEntry)o).name);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return name;\n+    }\n+  }\n+\n+  /**\n+   * An entry representing a NEW or CALL.\n+   */\n+  static class CallValueEntry implements ValueEntry {\n+    private final Node node;\n+\n+    CallValueEntry(Node node) {\n+      Preconditions.checkState(\n+          node.getType() == Token.CALL || node.getType() == Token.NEW);\n+      this.node = node;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return node.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      return o != null\n+          && o instanceof CallValueEntry\n+          && node.equals(((CallValueEntry)o).node);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return node.toString();\n+    }\n+  }\n+\n+  FunctionSideEffectData(boolean extern, Scope scope) {\n+    this.extern = extern;\n+    this.localScope = scope;\n+    checkInvariant();\n+  }\n+\n+  Scope getScope() {\n+    return localScope;\n+  }\n+\n+  private Multimap<ValueEntry, ValueEntry> getValueInfluenceMap() {\n+    return valueInfluenceMap;\n+  }\n+\n+  // TODO(johnlenz): The use of isInformationStable and clearLocalityState\n+  // is fragile.  Consider using a singleton instance of FunctionSideEffectData\n+  // that represents this state (everything is mutating).\n+  \n+  boolean isInformationStable() {\n+    // Once we know there are global changes and the result is non-local\n+    // there is no point in looking for additional information.\n+    return (mutatesGlobalState() && taintsReturn);\n+  }\n+\n+  /**\n+   * Free up the data structure that are used to calculate value locality.\n+   */\n+  void clearLocalityState() {\n+    nonLocalValues = null;\n+    modifiedLocals = null;\n+    valueInfluenceMap = null;\n+  }\n+\n+  /**\n+   * @param var\n+   */\n+  void addModified(Var var) {\n+    Preconditions.checkState(var.scope == localScope);\n+    modifiedLocals.add(new NameValueEntry(var));\n+  }\n+\n+  /**\n+   * @param var\n+   */\n+  void addNonLocalValue(Var var) {\n+    Preconditions.checkState(var.scope == localScope);\n+    nonLocalValues.add(new NameValueEntry(var));\n+  }\n+\n+  /**\n+   * Add a value dependency from the source ValueEntry to the sink\n+   * ValueEntry.\n+   * @param source\n+   * @param sink\n+   */\n+  void addInfluence(ValueEntry source, ValueEntry sink) {\n+    valueInfluenceMap.put(source, sink);\n+  }\n+\n+  /**\n+   * For use with NodeUtil#evaluatesToLocalValue\n+   * @return Whether the node represents a value that is currently considered\n+   *     a known-local-unescaped value.\n+   */\n+  boolean isLocalValue(Node value) {\n+    switch (value.getType()) {\n+      case Token.NAME:\n+        String name = value.getString();\n+        return getScope().isDeclared(name, false)\n+            && !nonLocalValues.contains(new NameValueEntry(value));\n+      case Token.CALL:\n+        return !nonLocalValues.contains(new CallValueEntry(value));\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * @returns false if function known to have side effects.\n+   */\n+  boolean mayBePure() {\n+    return !(functionThrows ||\n+             taintsGlobalState ||\n+             taintsThis ||\n+             taintsArguments ||\n+             taintsUnknown);\n+  }\n+\n+  /**\n+   * @returns false if function known to be pure.\n+   */\n+  boolean mayHaveSideEffects() {\n+    return !pureFunction;\n+  }\n+\n+  /**\n+   * Mark the function as being pure.\n+   */\n+  void setIsPure() {\n+    pureFunction = true;\n+    checkInvariant();\n+  }\n+\n+  /**\n+   * Marks the function as having \"modifies globals\" side effects.\n+   */\n+  void setTaintsGlobalState() {\n+    taintsGlobalState = true;\n+    checkInvariant();\n+  }\n+\n+  /**\n+   * Marks the function as having \"modifies this\" side effects.\n+   */\n+  void setTaintsThis() {\n+    taintsThis = true;\n+    checkInvariant();\n+  }\n+\n+  /**\n+   * Marks the function as having \"modifies arguments\" side effects.\n+   */\n+  void setTaintsArguments() {\n+    taintsArguments = true;\n+    checkInvariant();\n+  }\n+\n+  /**\n+   * Marks the function as having \"throw\" side effects.\n+   */\n+  void setFunctionThrows() {\n+    functionThrows = true;\n+    checkInvariant();\n+  }\n+\n+  /**\n+   * Marks the function as having \"complex\" side effects that are\n+   * not otherwise explicitly tracked.\n+   */\n+  void setTaintsUnknown() {\n+    taintsUnknown = true;\n+    checkInvariant();\n+  }\n+\n+  /**\n+   * Marks the function as having non-local return result.\n+   */\n+  void setTaintsReturn() {\n+    taintsReturn = true;\n+    checkInvariant();\n+  }\n+\n+  /**\n+   * @return Whether the function has a non-local return value.\n+   */\n+  boolean hasNonLocalReturnValue() {\n+    return taintsReturn;\n+  }\n+\n+  /**\n+   * Returns true if function mutates global state.\n+   */\n+  boolean mutatesGlobalState() {\n+    // TODO(johnlenz): track arguments separately.\n+    return taintsGlobalState || taintsArguments || taintsUnknown;\n+  }\n+\n+  /**\n+   * Returns true if function mutates \"this\".\n+   */\n+  boolean mutatesThis() {\n+    return taintsThis;\n+  }\n+\n+  /**\n+   * Returns true if function has an explicit \"throw\".\n+   */\n+  boolean functionThrows() {\n+    return functionThrows;\n+  }\n+\n+  /**\n+   * Verify internal consistency.  Should be called at the end of\n+   * every method that mutates internal state.\n+   */\n+  private void checkInvariant() {\n+    boolean invariant = mayBePure() || mayHaveSideEffects();\n+    if (!invariant) {\n+      throw new IllegalStateException(\"Invariant failed.  \" + toString());\n+    }\n+  }\n+\n+  /**\n+   * Add a CALL or NEW node to the list of calls this function makes.\n+   */\n+  void appendCall(Node callNode) {\n+    callsInFunctionBody.add(callNode);\n+  }\n+\n+  /**\n+   * Gets the list of CALL and NEW nodes.\n+   */\n+  List<Node> getCallsInFunctionBody() {\n+    return callsInFunctionBody;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    List<String> status = Lists.newArrayList();\n+    if (extern) {\n+      status.add(\"extern\");\n+    }\n+\n+    if (pureFunction) {\n+      status.add(\"pure\");\n+    }\n+\n+    if (taintsThis) {\n+      status.add(\"this\");\n+    }\n+\n+    if (taintsGlobalState) {\n+      status.add(\"global\");\n+    }\n+\n+    if (functionThrows) {\n+      status.add(\"throw\");\n+    }\n+\n+    if (taintsUnknown) {\n+      status.add(\"complex\");\n+    }\n+\n+    return \"Side effects: \" + status.toString();\n+  }\n+\n+  /**\n+   * Normalize the ValueEntry maps relation using the value dependencies\n+   * so that any non-local-value that may have been modified has been\n+   * accounted for.\n+   */\n+  void normalizeValueMaps() {\n+    //\n+    // Normalize the value influence map.\n+    //\n+    if (!mutatesGlobalState() || !taintsReturn) {\n+      // propagate non-local objects values\n+      // Note: propagateNonLocal adds entries so grap a snapshot\n+      // as an array to interate over.\n+      for (ValueEntry entry : nonLocalValues.toArray(new ValueEntry[0])) {\n+        propagateNonLocal(entry);\n+      }\n+    }\n+\n+    if (!mutatesGlobalState()) {\n+      // propagate object modification\n+      // Note: propagateNonLocal adds entries so grap a snapshot\n+      // as an array to interate over.\n+      for (ValueEntry entry : modifiedLocals.toArray(new ValueEntry[0])) {\n+        propagateModified(entry);\n+      }\n+    }\n+\n+    // Don't retain information that won't be used.\n+    if (isInformationStable()){\n+      // a global state change maybe a inner function modifying these local\n+      // names, or a call to eval,  so there are locals that are known to be\n+      // unmodified.\n+      clearLocalityState();\n+    }\n+  }\n+\n+  /**\n+   * @param value A Var or token representing the value.\n+   * @return Whether the FunctionInformation was updated.\n+   */\n+  boolean maybePropagateNonLocal(ValueEntry value) {\n+    if (!nonLocalValues.contains(value)) {\n+      nonLocalValues.add(value);\n+      return propagateNonLocal(value);\n+    }\n+    return false;\n+  }\n+  \n+  /**\n+   * @param value The ValueEntry of interest.\n+   * @return Whether the FunctionInformation was updated.\n+   */\n+  boolean propagateNonLocal(ValueEntry value) {\n+    Preconditions.checkState(nonLocalValues != null);\n+    Preconditions.checkState(modifiedLocals != null);\n+\n+    boolean changed = false;\n+    if (modifiedLocals.contains(value)) {\n+      if (!mutatesGlobalState()) {\n+        setTaintsGlobalState();\n+        changed = true;\n+      }\n+    }\n+\n+    if (value == KeywordValueEntry.RETURN) {\n+      if (!taintsReturn) {\n+        setTaintsReturn();\n+        changed = true;\n+      }\n+    }\n+\n+    // Add the value now to prevent recursion\n+    Collection<ValueEntry> dependents = getValueInfluenceMap().get(value);\n+    if (dependents != null) {\n+      for (ValueEntry dependent : dependents) {\n+        if (!nonLocalValues.contains(dependent)) {\n+          nonLocalValues.add(dependent);\n+          changed = propagateNonLocal(dependent) || changed;\n+        }\n+      }\n+    }\n+\n+    return changed;\n+  }\n+\n+  /**\n+   * @param value A Var or token representing the value.\n+   * @return Whether the FunctionInformation was updated.\n+   */\n+  private boolean propagateModified(ValueEntry value) {\n+    Preconditions.checkState(nonLocalValues != null);\n+    Preconditions.checkState(modifiedLocals != null);\n+\n+    boolean changed = false;\n+    if (nonLocalValues != null\n+        && nonLocalValues.contains(value)) {\n+      if (!mutatesGlobalState()) {\n+        setTaintsUnknown();\n+        changed = true;\n+      }\n+    } else if (value == KeywordValueEntry.THIS) {\n+      if (!taintsThis) {\n+        setTaintsThis();\n+        changed = true;\n+      }\n+    } else if (value == KeywordValueEntry.ARGUMENTS) {\n+      if (!taintsArguments) {\n+        setTaintsArguments();\n+        changed = true;\n+      }\n+    }\n+    // Add the value now to prevent recursion\n+    Collection<ValueEntry> dependents = getValueInfluenceMap().get(value);\n+    if (dependents != null) {\n+      for (ValueEntry dependent : dependents) {\n+        if (!modifiedLocals.contains(dependent)) {\n+          modifiedLocals.add(dependent);\n+          changed = propagateModified(dependent) || changed;\n+        }\n+      }\n+    }\n+    return changed;\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n+import com.google.javascript.jscomp.FunctionSideEffectData.CallValueEntry;\n+import com.google.javascript.jscomp.FunctionSideEffectData.KeywordValueEntry;\n+import com.google.javascript.jscomp.FunctionSideEffectData.ValueEntry;\n+import com.google.javascript.jscomp.FunctionSideEffectData.NameValueEntry;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph;\n import java.io.File;\n import java.io.IOException;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n   private final DefinitionProvider definitionProvider;\n \n   // Function node -> function side effects map\n-  private final Map<Node, FunctionInformation> functionSideEffectMap;\n+  private final Map<Node, FunctionSideEffectData> functionSideEffectMap;\n \n   // List of all function call sites; used to iterate in markPureFunctionCalls.\n   private final List<Node> allFunctionCalls;\n     functionNames.process(null, root);\n \n     sb.append(\"Pure functions:\\n\");\n-    for (Map.Entry<Node, FunctionInformation> entry :\n+    for (Map.Entry<Node, FunctionSideEffectData> entry :\n              functionSideEffectMap.entrySet()) {\n       Node function = entry.getKey();\n-      FunctionInformation functionInfo = entry.getValue();\n+      FunctionSideEffectData functionInfo = entry.getValue();\n \n       boolean isPure =\n           functionInfo.mayBePure() && !functionInfo.mayHaveSideEffects();\n     }\n     sb.append(\"\\n\");\n \n-    for (Map.Entry<Node, FunctionInformation> entry :\n+    for (Map.Entry<Node, FunctionSideEffectData> entry :\n              functionSideEffectMap.entrySet()) {\n       Node function = entry.getKey();\n-      FunctionInformation functionInfo = entry.getValue();\n+      FunctionSideEffectData functionInfo = entry.getValue();\n \n       Set<String> depFunctionNames = Sets.newHashSet();\n       for (Node callSite : functionInfo.getCallsInFunctionBody()) {\n    */\n   private void propagateSideEffects() {\n     // Nodes are function declarations; Edges are function call sites.\n-    DiGraph<FunctionInformation, Node> sideEffectGraph =\n-        new LinkedDirectedGraph<FunctionInformation, Node>();\n+    DiGraph<FunctionSideEffectData, Node> sideEffectGraph =\n+        new LinkedDirectedGraph<FunctionSideEffectData, Node>();\n \n     // create graph nodes\n-    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {\n+    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {\n       sideEffectGraph.createNode(functionInfo);\n     }\n \n     // add connections to called functions and side effect root.\n-    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {\n+    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {\n       if (!functionInfo.mayHaveSideEffects()) {\n         continue;\n       }\n \n         for (Definition def : defs) {\n           Node defValue = def.getRValue();\n-          FunctionInformation dep = functionSideEffectMap.get(defValue);\n+          FunctionSideEffectData dep = functionSideEffectMap.get(defValue);\n           Preconditions.checkNotNull(dep);\n           sideEffectGraph.connect(dep, callSite, functionInfo);\n         }\n         .computeFixedPoint(sideEffectGraph);\n \n     // Mark remaining functions \"pure\".\n-    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {\n+    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {\n       if (functionInfo.mayBePure()) {\n         functionInfo.setIsPure();\n       }\n       } else {\n         flags.clearAllFlags();\n         for (Definition def : defs) {\n-          FunctionInformation functionInfo =\n+          FunctionSideEffectData functionInfo =\n               functionSideEffectMap.get(def.getRValue());\n           Preconditions.checkNotNull(functionInfo);\n           // TODO(johnlenz): set the arguments separately from the\n             flags.setMutatesGlobalState();\n           }\n \n-          if (functionInfo.functionThrows) {\n+          if (functionInfo.functionThrows()) {\n             flags.setThrows();\n           }\n \n           if (!NodeUtil.isNew(callNode)) {\n-            if (functionInfo.taintsThis) {\n+            if (functionInfo.mutatesThis()) {\n               flags.setMutatesThis();\n             }\n           }\n \n-          if (functionInfo.taintsReturn) {\n+          if (functionInfo.hasNonLocalReturnValue()) {\n             flags.setReturnsTainted();\n           }\n \n                                   Node node,\n                                   Node parent) {\n \n-      // Functions need to be processed as part of pre-traversal so an\n-      // entry for the enclosing function exists in the\n-      // FunctionInformation map when processing assignments and calls\n-      // inside visit.\n-      if (NodeUtil.isFunction(node)) {\n-        Node gramp = parent.getParent();\n-        visitFunction(traversal, node, parent, gramp);\n-      }\n+\n \n       return true;\n     }\n \n       Node enclosingFunction = traversal.getEnclosingFunction();\n       if (enclosingFunction != null) {\n-        FunctionInformation sideEffectInfo =\n+        FunctionSideEffectData sideEffectInfo =\n             functionSideEffectMap.get(enclosingFunction);\n         Preconditions.checkNotNull(sideEffectInfo);\n \n               // Assignment to local, if the value isn't a safe local value,\n               // new object creation or literal or known primitive result\n               // value, add it to the local blacklist.\n-              if (value != null && !NodeUtil.evaluatesToLocalValue(value)) {\n+              if (value != null && !analyzeSet(\n+                      new NameValueEntry(node), value, sideEffectInfo)) {\n                 Scope scope = traversal.getScope();\n                 Var var = scope.getVar(node.getString());\n-                sideEffectInfo.blacklistLocal(var);\n+                sideEffectInfo.addNonLocalValue(var);\n               }\n               break;\n             case Token.THROW:\n               visitThrow(sideEffectInfo);\n               break;\n             case Token.RETURN:\n-              if (node.hasChildren()\n-                  && !NodeUtil.evaluatesToLocalValue(node.getFirstChild())) {\n+              if (node.hasChildren() && !analyzeSet(\n+                      KeywordValueEntry.RETURN, node.getFirstChild(),\n+                      sideEffectInfo)) {\n                 sideEffectInfo.setTaintsReturn();\n               }\n               break;\n     }\n \n     @Override\n-    public void enterScope(NodeTraversal t) {\n-      // Nothing to do.\n+    public void enterScope(NodeTraversal traversal) {\n+      Node enclosingFunction = traversal.getEnclosingFunction();\n+      if (enclosingFunction != null) {\n+        // Functions need to be processed as part of pre-traversal so an\n+        // entry for the enclosing function exists in the\n+        // FunctionInformation map when processing assignments and calls\n+        // inside visit.\n+        visitFunction(traversal, enclosingFunction);\n+      }\n     }\n \n     @Override\n     public void exitScope(NodeTraversal t) {\n-      if (t.inGlobalScope()) {\n+      if (t.inGlobalScope() || inExterns) {\n         return;\n       }\n \n-      // Handle deferred local variable modifications:\n-      //\n-      FunctionInformation sideEffectInfo =\n-        functionSideEffectMap.get(t.getScopeRoot());\n-      if (sideEffectInfo.mutatesGlobalState()){\n-        sideEffectInfo.resetLocalVars();\n-        return;\n-      }\n-\n-      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n-        Var v = i.next();\n-        boolean localVar = false;\n-        // Parameters and catch values come can from other scopes.\n-        if (v.getParentNode().getType() == Token.VAR) {\n-          // TODO(johnlenz): create a useful parameter list\n-          sideEffectInfo.knownLocals.add(v.getName());\n-          localVar = true;\n-        }\n-\n-        // Take care of locals that might have been tainted.\n-        if (!localVar || sideEffectInfo.blacklisted.contains(v)) {\n-          if (sideEffectInfo.taintedLocals.contains(v)) {\n-            // If the function has global side-effects\n-            // don't bother with the local side-effects.\n-            sideEffectInfo.setTaintsUnknown();\n-            sideEffectInfo.resetLocalVars();\n-            break;\n-          }\n-        }\n-      }\n-\n-      sideEffectInfo.taintedLocals = null;\n-      sideEffectInfo.blacklisted = null;\n-    }\n-\n+      FunctionSideEffectData sideEffectInfo =\n+          functionSideEffectMap.get(t.getScopeRoot());\n+\n+      sideEffectInfo.normalizeValueMaps();\n+    }\n \n     /**\n      * Record information about the side effects caused by an\n-     * assigment or mutating unary operator.\n+     * assignment or mutating unary operator.\n      *\n      * If the operation modifies this or taints global state, mark the\n      * enclosing function as having those side effects.\n      * @param rhs The right have value, if any.\n      */\n     private void visitAssignmentOrUnaryOperator(\n-        FunctionInformation sideEffectInfo,\n+        FunctionSideEffectData sideEffectInfo,\n         Scope scope, Node op, Node lhs, Node rhs) {\n       if (NodeUtil.isName(lhs)) {\n         Var var = scope.getVar(lhs.getString());\n               || isIncDec(op) || op.getType() == Token.DELPROP);\n           if (rhs != null\n               && NodeUtil.isAssign(op)\n-              && !NodeUtil.evaluatesToLocalValue(rhs)) {\n-            sideEffectInfo.blacklistLocal(var);\n+              && !analyzeSet(\n+                new NameValueEntry(lhs), rhs, sideEffectInfo)) {\n+            sideEffectInfo.addNonLocalValue(var);\n           }\n         }\n       } else if (NodeUtil.isGet(lhs)) {\n             // Maybe a local object modification.  We won't know for sure until\n             // we exit the scope and can validate the value of the local.\n             //\n-            sideEffectInfo.addTaintedLocalObject(var);\n+            sideEffectInfo.addModified(var);\n           }\n         }\n       } else {\n     /**\n      * Record information about a call site.\n      */\n-    private void visitCall(FunctionInformation sideEffectInfo, Node node) {\n+    private void visitCall(FunctionSideEffectData sideEffectInfo, Node node) {\n       // Handle special cases (Math, RegEx)\n       if (NodeUtil.isCall(node)\n           && !NodeUtil.functionCallHasSideEffects(node, compiler)) {\n     /**\n      * Record function and check for @nosideeffects annotations.\n      */\n-    private void visitFunction(NodeTraversal traversal,\n-                               Node node,\n-                               Node parent,\n-                               Node gramp) {\n+    private void visitFunction(NodeTraversal traversal, Node node) {\n       Preconditions.checkArgument(!functionSideEffectMap.containsKey(node));\n \n-      FunctionInformation sideEffectInfo = new FunctionInformation(inExterns);\n+      FunctionSideEffectData sideEffectInfo = new FunctionSideEffectData(\n+          inExterns, traversal.getScope());\n       functionSideEffectMap.put(node, sideEffectInfo);\n \n+      if (!inExterns) {\n+        Scope localScope = traversal.getScope();\n+\n+        // Only vars and function declarations maybe known to be local.\n+        // Parameters and catch exception definitions are are not tracked\n+        // so mark them non-local immediately.\n+        Iterator<Var> i = localScope.getVars();\n+        while (i.hasNext()) {\n+          Var v = i.next();\n+          Node parent = v.getParentNode();\n+          if (parent.getType() == Token.LP\n+              || parent.getType() == Token.CATCH) {\n+            // TODO(johnlenz): Allow function parameters\n+            sideEffectInfo.addNonLocalValue(v);\n+          }\n+        }\n+      }\n+\n+      processFunctionAnnotations(sideEffectInfo, traversal, node);\n+    }\n+\n+    /**\n+     * Update the function side effect info for any user provided annotations.\n+     * Reports discovered invalid usages of these annotations.\n+     */\n+    private void processFunctionAnnotations(\n+        FunctionSideEffectData sideEffectInfo,\n+        NodeTraversal traversal, Node function) {\n+      // Infer the locality of the return type\n       if (inExterns) {\n-        JSType jstype = node.getJSType();\n+        JSType jstype = function.getJSType();\n         boolean knownLocalResult = false;\n         if (jstype != null && jstype.isFunctionType()) {\n           FunctionType functionType = (FunctionType) jstype;\n         }\n       }\n \n-      JSDocInfo info = getJSDocInfoForFunction(node, parent, gramp);\n+      JSDocInfo info = getJSDocInfoForFunction(function);\n       if (info != null) {\n         boolean hasSpecificSideEffects = false;\n         if (hasSideEffectsThisAnnotation(info)) {\n             hasSpecificSideEffects = true;\n             sideEffectInfo.setTaintsThis();\n           } else {\n-            traversal.report(node, INVALID_MODIFIES_ANNOTATION);\n+            traversal.report(function, INVALID_MODIFIES_ANNOTATION);\n           }\n         }\n \n             hasSpecificSideEffects = true;\n             sideEffectInfo.setTaintsArguments();\n           } else {\n-            traversal.report(node, INVALID_MODIFIES_ANNOTATION);\n+            traversal.report(function, INVALID_MODIFIES_ANNOTATION);\n           }\n         }\n \n             if (inExterns) {\n               sideEffectInfo.setIsPure();\n             } else {\n-              traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n+              traversal.report(function, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n             }\n           } else if (inExterns) {\n             sideEffectInfo.setTaintsGlobalState();\n     /**\n      * Record that the enclosing function throws.\n      */\n-    private void visitThrow(FunctionInformation sideEffectInfo) {\n+    private void visitThrow(FunctionSideEffectData sideEffectInfo) {\n       sideEffectInfo.setFunctionThrows();\n     }\n \n     /**\n      * Get the doc info associated with the function.\n      */\n-    private JSDocInfo getJSDocInfoForFunction(\n-        Node node, Node parent, Node gramp) {\n+    private JSDocInfo getJSDocInfoForFunction(Node node) {\n+      Node parent = node.getParent();\n       JSDocInfo info = node.getJSDocInfo();\n       if (info != null) {\n         return info;\n       } else if (NodeUtil.isName(parent)) {\n+        Node gramp = parent.getParent();\n         return gramp.hasOneChild() ? gramp.getJSDocInfo() : null;\n       } else if (NodeUtil.isAssign(parent)) {\n         return parent.getJSDocInfo();\n   }\n \n   /**\n-   * @return Whether the node is known to be a value that is not a reference\n-   *     outside the local scope.\n+   * Check local values and updates the value influence map.\n+   * @param lValue A var name or token value used in the value influence map.\n+   *\n+   * @return Whether the node is maybe to be a value that has not escaped\n+   *     the local scope.\n    */\n-  private static boolean isKnownLocalValue(final Node value) {\n-    Predicate<Node> taintingPredicate = new Predicate<Node>() {\n+  private static boolean analyzeSet(\n+      final ValueEntry lValue,\n+      Node rValue,\n+      final FunctionSideEffectData info) {\n+\n+    final boolean isReturnResult = lValue.equals(KeywordValueEntry.RETURN);\n+\n+    // Create a predicate for NodeUtil#evaluatesToLocalValue.\n+    final Predicate<Node> taintingPredicate = new Predicate<Node>() {\n       @Override\n       public boolean apply(Node value) {\n         switch (value.getType()) {\n           case Token.ASSIGN:\n-            // The assignment might cause an alias, look at the lhs.\n+            // Check the LHS of the assignment, the RHS will be evaluated\n+            // separately.  If the LHS is a local NAME add that dependency on\n+            // that value as it is a alias of the RHS value.\n+\n+            // Aliases of immutable RHS values don't matter, but should already\n+            // be filtered out.\n+            Preconditions.checkState(\n+                !NodeUtil.isImmutableValue(value.getLastChild()));\n+            Node lhs = value.getFirstChild();\n+            if (NodeUtil.isName(lhs)\n+                && info.getScope().isDeclared(lhs.getString(), false)) {\n+              addValue(lhs);\n+              return true;\n+            }\n+            // Don't attempt to track an aliasing property assignment.\n             return false;\n           case Token.THIS:\n-            // TODO(johnlenz): maybe redirect this to be a tainting list for 'this'.\n+            // changes to \"this\" now change \"key\", changes to \"key\" will\n+            // also infer a change to \"this\".\n+            addValue(KeywordValueEntry.THIS);\n+            return true;\n+          case Token.NAME:\n+            // add to local tainting list, if the NAME\n+            // is known to be a local.\n+            if (info.getScope().isDeclared(value.getString(), false)) {\n+              addValue(value);\n+              return true;\n+            }\n             return false;\n-          case Token.NAME:\n-            // TODO(johnlenz): add to local tainting list, if the NAME\n-            // is known to be a local.\n-            return false;\n+          case Token.CALL:\n+            // For calls the taint is the actual call node.\n+            addCall(value);\n+            return true;\n           case Token.GETELEM:\n           case Token.GETPROP:\n             // There is no information about the locality of object properties.\n             return false;\n-          case Token.CALL:\n-            // TODO(johnlenz): add to local tainting list, if the call result\n-            // is not known to be a local result.\n-            return false;\n-        }\n-        return false;\n+          default:\n+            throw new IllegalStateException(\"unexpected\");\n+        }\n+      }\n+\n+      private void addCall(Node callNode) {\n+        Preconditions.checkState(callNode.getType() == Token.CALL);\n+        info.addInfluence(new CallValueEntry(callNode), lValue);\n+      }\n+\n+      private void addValue(Node name) {\n+        ValueEntry value = new NameValueEntry(name);\n+        addValue(value);\n+      }\n+\n+      private void addValue(ValueEntry value) {\n+        // The value and keys maybe aliases\n+        info.addInfluence(value, lValue);\n+        if (!isReturnResult) {\n+          info.addInfluence(lValue, value);\n+        }\n       }\n     };\n \n-    return NodeUtil.evaluatesToLocalValue(value, taintingPredicate);\n+    // Walk the expression with the provided predicate.\n+    return NodeUtil.evaluatesToLocalValue(rValue, taintingPredicate);\n+  }\n+\n+  private static Predicate<Node> getLocalPredicate(\n+      final FunctionSideEffectData caller) {\n+    return new Predicate<Node>() {\n+      @Override\n+      public boolean apply(Node value) {\n+        return caller.isLocalValue(value);\n+      }\n+    };\n   }\n \n   /**\n    * Callback that propagates side effect information across call sites.\n    */\n   private static class SideEffectPropagationCallback\n-      implements EdgeCallback<FunctionInformation, Node> {\n-    public boolean traverseEdge(FunctionInformation callee,\n-                                Node callSite,\n-                                FunctionInformation caller) {\n+      implements EdgeCallback<FunctionSideEffectData, Node> {\n+    public boolean traverseEdge(final FunctionSideEffectData callee,\n+                                final Node callSite,\n+                                final FunctionSideEffectData caller) {\n       Preconditions.checkArgument(callSite.getType() == Token.CALL ||\n                                   callSite.getType() == Token.NEW);\n \n       boolean changed = false;\n+      if (caller.isInformationStable()) {\n+        // There is no more useful information to be gathered.\n+        return false;\n+      }\n+\n       if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) {\n         caller.setTaintsGlobalState();\n         changed = true;\n       if (!caller.functionThrows() && callee.functionThrows()) {\n         caller.setFunctionThrows();\n         changed = true;\n+      }\n+\n+      Predicate<Node> locals = getLocalPredicate(caller);\n+      if (callee.hasNonLocalReturnValue()) {\n+        if (caller.maybePropagateNonLocal(new CallValueEntry(callSite))) {\n+          changed = true;\n+        }\n       }\n \n       if (callee.mutatesThis()) {\n         // Calling a constructor that modifies \"this\" has no side effects.\n         if (callSite.getType() != Token.NEW) {\n           Node objectNode = getCallThisObject(callSite);\n-          if (objectNode != null && NodeUtil.isName(objectNode)\n-              && !isCallOrApply(callSite)) {\n+          if (objectNode != null && NodeUtil.isThis(objectNode)) {\n+            if (!caller.mutatesThis()) {\n+              caller.setTaintsThis();\n+              changed = true;\n+            }\n+          } else if (objectNode != null && !isCallOrApply(callSite)) {\n             // Exclude \".call\" and \".apply\" as the value may still be may be\n             // null or undefined. We don't need to worry about this with a\n             // direct method call because null and undefined don't have any\n             // properties.\n-            String name = objectNode.getString();\n-\n-            // TODO(nicksantos): Turn this back on when locals-tracking\n-            // is fixed. See testLocalizedSideEffects11.\n-            //if (!caller.knownLocals.contains(name)) {\n+            // TODO(johnlenz): We can improve this by including literal values\n+            // that we know for sure are not null.\n+\n+            // Modifying 'this' on a known local object doesn't change any\n+            // significant state.\n+            if (!NodeUtil.evaluatesToLocalValue(objectNode, locals)) {\n               if (!caller.mutatesGlobalState()) {\n                 caller.setTaintsGlobalState();\n                 changed = true;\n               }\n-            //}\n-          } else if (objectNode != null && NodeUtil.isThis(objectNode)) {\n-            if (!caller.mutatesThis()) {\n-              caller.setTaintsThis();\n-              changed = true;\n             }\n-          } else if (objectNode != null\n-              && NodeUtil.evaluatesToLocalValue(objectNode)\n-              && !isCallOrApply(callSite)) {\n-            // Modifying 'this' on a known local object doesn't change any\n-            // significant state.\n-            // TODO(johnlenz): We can improve this by including literal values\n-            // that we know for sure are not null.\n           } else if (!caller.mutatesGlobalState()) {\n             caller.setTaintsGlobalState();\n             changed = true;\n           }\n         }\n+      }\n+\n+      if (caller.isInformationStable()) {\n+        // Once the caller has reach a stable state, clear the local state\n+        // to avoid memory being a memory hog.\n+        caller.clearLocalityState();\n       }\n \n       return changed;\n   }\n \n   /**\n-   * Keeps track of a function's known side effects by type and the\n-   * list of calls that appear in a function's body.\n-   */\n-  private static class FunctionInformation {\n-    private final boolean extern;\n-    private final List<Node> callsInFunctionBody = Lists.newArrayList();\n-    private Set<Var> blacklisted = Sets.newHashSet();\n-    private Set<Var> taintedLocals = Sets.newHashSet();\n-    private Set<String> knownLocals = Sets.newHashSet();\n-    private boolean pureFunction = false;\n-    private boolean functionThrows = false;\n-    private boolean taintsGlobalState = false;\n-    private boolean taintsThis = false;\n-    private boolean taintsArguments = false;\n-    private boolean taintsUnknown = false;\n-    private boolean taintsReturn = false;\n-\n-    FunctionInformation(boolean extern) {\n-      this.extern = extern;\n-      checkInvariant();\n-    }\n-\n-    /**\n-     * @param var\n-     */\n-    void addTaintedLocalObject(Var var) {\n-      taintedLocals.add(var);\n-    }\n-\n-    void resetLocalVars() {\n-      blacklisted = null;\n-      taintedLocals = null;\n-      knownLocals = Collections.emptySet();\n-    }\n-\n-    /**\n-     * @param var\n-     */\n-    public void blacklistLocal(Var var) {\n-      blacklisted.add(var);\n-    }\n-\n-    /**\n-     * @returns false if function known to have side effects.\n-     */\n-    boolean mayBePure() {\n-      return !(functionThrows ||\n-               taintsGlobalState ||\n-               taintsThis ||\n-               taintsArguments ||\n-               taintsUnknown);\n-    }\n-\n-    /**\n-     * @returns false if function known to be pure.\n-     */\n-    boolean mayHaveSideEffects() {\n-      return !pureFunction;\n-    }\n-\n-    /**\n-     * Mark the function as being pure.\n-     */\n-    void setIsPure() {\n-      pureFunction = true;\n-      checkInvariant();\n-    }\n-\n-    /**\n-     * Marks the function as having \"modifies globals\" side effects.\n-     */\n-    void setTaintsGlobalState() {\n-      taintsGlobalState = true;\n-      checkInvariant();\n-    }\n-\n-    /**\n-     * Marks the function as having \"modifies this\" side effects.\n-     */\n-    void setTaintsThis() {\n-      taintsThis = true;\n-      checkInvariant();\n-    }\n-\n-    /**\n-     * Marks the function as having \"modifies arguments\" side effects.\n-     */\n-    void setTaintsArguments() {\n-      taintsArguments = true;\n-      checkInvariant();\n-    }\n-\n-    /**\n-     * Marks the function as having \"throw\" side effects.\n-     */\n-    void setFunctionThrows() {\n-      functionThrows = true;\n-      checkInvariant();\n-    }\n-\n-    /**\n-     * Marks the function as having \"complex\" side effects that are\n-     * not otherwise explicitly tracked.\n-     */\n-    void setTaintsUnknown() {\n-      taintsUnknown = true;\n-      checkInvariant();\n-    }\n-\n-    /**\n-     * Marks the function as having non-local return result.\n-     */\n-    void setTaintsReturn() {\n-      taintsReturn = true;\n-      checkInvariant();\n-    }\n-\n-\n-    /**\n-     * Returns true if function mutates global state.\n-     */\n-    boolean mutatesGlobalState() {\n-      // TODO(johnlenz): track arguments separately.\n-      return taintsGlobalState || taintsArguments || taintsUnknown;\n-    }\n-\n-    /**\n-     * Returns true if function mutates \"this\".\n-     */\n-    boolean mutatesThis() {\n-      return taintsThis;\n-    }\n-\n-    /**\n-     * Returns true if function has an explicit \"throw\".\n-     */\n-    boolean functionThrows() {\n-      return functionThrows;\n-    }\n-\n-    /**\n-     * Verify internal consistency.  Should be called at the end of\n-     * every method that mutates internal state.\n-     */\n-    private void checkInvariant() {\n-      boolean invariant = mayBePure() || mayHaveSideEffects();\n-      if (!invariant) {\n-        throw new IllegalStateException(\"Invariant failed.  \" + toString());\n-      }\n-    }\n-\n-    /**\n-     * Add a CALL or NEW node to the list of calls this function makes.\n-     */\n-    void appendCall(Node callNode) {\n-      callsInFunctionBody.add(callNode);\n-    }\n-\n-    /**\n-     * Gets the list of CALL and NEW nodes.\n-     */\n-    List<Node> getCallsInFunctionBody() {\n-      return callsInFunctionBody;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      List<String> status = Lists.newArrayList();\n-      if (extern) {\n-        status.add(\"extern\");\n-      }\n-\n-      if (pureFunction) {\n-        status.add(\"pure\");\n-      }\n-\n-      if (taintsThis) {\n-        status.add(\"this\");\n-      }\n-\n-      if (taintsGlobalState) {\n-        status.add(\"global\");\n-      }\n-\n-      if (functionThrows) {\n-        status.add(\"throw\");\n-      }\n-\n-      if (taintsUnknown) {\n-        status.add(\"complex\");\n-      }\n-\n-      return \"Side effects: \" + status.toString();\n-    }\n-  }\n-\n-  /**\n    * A compiler pass that constructs a reference graph and drives\n    * the PureFunctionIdentifier across it.\n    */\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n         \"  x.externObjSEThisMethod('') \" +\n         \"};\" +\n         \"f();\",\n-        ImmutableList.<String>of(\"externObjSEThis\"));\n+        ImmutableList.<String>of(\"externObjSEThis\", \"f\"));\n   }\n \n   public void testAnnotationInExterns_new8() throws Exception {\n         prefix + \"return externObj.foo\" + suffix, expected);\n   }\n \n+  public void testResultLocalitySimpleSample() throws Exception {\n+    String prefix = \"var g; function f(){\";\n+    String suffix = \"} f()\";\n+    List<String> expected = ImmutableList.of(\"f\");\n+    List<String> notExpected = ImmutableList.of();\n+\n+    // global result\n+    checkLocalityOfMarkedCalls(\n+      prefix + \"var a = (g = []); return a\" + suffix, notExpected);\n+  }\n+\n   public void testResultLocalitySimple() throws Exception {\n     String prefix = \"var g; function f(){\";\n     String suffix = \"} f()\";\n         prefix + \"return 1; return g\" + suffix, notExpected);\n \n \n-    // local var, not yet.\n-    checkLocalityOfMarkedCalls(\n-        prefix + \"var a = 1; return a\" + suffix, notExpected);\n-\n-    // mutate local var, not yet.\n-    checkLocalityOfMarkedCalls(\n-        prefix + \"var a = 1; a = 2; return a\" + suffix, notExpected);\n+    // local var.\n+    checkLocalityOfMarkedCalls(\n+        prefix + \"var a = 1; return a\" + suffix, expected);\n+\n+    // mutate local var.\n+    checkLocalityOfMarkedCalls(\n+        prefix + \"var a = 1; a = 2; return a\" + suffix, expected);\n     checkLocalityOfMarkedCalls(\n         prefix + \"var a = 1; a = 2; return a + 1\" + suffix, expected);\n+\n+    // Global aliases of immutables is ok.\n+    checkLocalityOfMarkedCalls(\n+        prefix + \"var a = (g = 2); return a\" + suffix, expected);\n+\n+    checkLocalityOfMarkedCalls(\n+       prefix + \"var a = (g = []); return a\" + suffix, notExpected);\n+\n \n     // read from obj literal\n     checkLocalityOfMarkedCalls(\n                      \"  var a = new A; a.g(); return a;\" +\n                      \"}\" +\n                      \"f()\",\n-                     ImmutableList.<String>of(\"A\"));\n+                     ImmutableList.<String>of(\"A\", \"f\"));\n   }\n \n   public void testLocalizedSideEffects11() throws Exception {\n         ImmutableList.of(\"A\", \"B\"));\n   }\n \n+  public void testLocalizedSideEffects12() throws Exception {\n+    // A expression containing an assignment is an alias of the value\n+    checkMarkedCalls(\"var g = 1;\" +\n+                     \"function f() {\" +\n+                     \"  var a = (g = new Foo); return a;\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of());\n+  }\n+\n+  public void testLocalizedSideEffects13() throws Exception {\n+    // A expression containing an assignment is an alias of the value, but\n+    // aliasing an immutable value doesn't matter, but the global side-effect\n+    // does.\n+    checkMarkedCalls(\"var g = 1;\" +\n+                     \"function f() {\" +\n+                     \"  var a = (g = 2); return a;\" +\n+                     \"}\" +\n+                     \"f()\",\n+                     ImmutableList.<String>of());\n+  }\n+\n   public void testUnaryOperators1() throws Exception {\n     checkMarkedCalls(\"function f() {var x = 1; x++}\" +\n                      \"f()\",\n         \"function g(){var a = new A; a.foo(); return a}\\n\" +\n         \"f(); g()\";\n \n-    checkMarkedCalls(source, ImmutableList.<String>of(\"A\", \"A\", \"f\"));\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"A\", \"A\", \"f\", \"g\"));\n   }\n \n   public void testCallFunctionFOrG() throws Exception {", "timestamp": 1290466929, "metainfo": ""}