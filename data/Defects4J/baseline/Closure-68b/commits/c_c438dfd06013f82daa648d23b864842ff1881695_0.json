{"sha": "c438dfd06013f82daa648d23b864842ff1881695", "log": "Implement multiple extends for interfaces  R=nicksantos DELTA=711  (635 added, 41 deleted, 35 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1917   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n       // like references to the initial property, so they are renamed alike.\n       ObjectType foundType = null;\n       ObjectType objType = ObjectType.cast(type);\n-      while (objType != null && objType.getImplicitPrototype() != objType) {\n-        if (objType.hasOwnProperty(field)) {\n-          foundType = objType;\n-        }\n-        objType = objType.getImplicitPrototype();\n-      }\n+      if (objType != null && objType.getConstructor() != null\n+          && objType.getConstructor().isInterface()) {\n+        ObjectType topInterface = FunctionType.getTopDefiningInterface(\n+            objType, field);\n+        if (topInterface != null && topInterface.getConstructor() != null) {\n+          foundType = topInterface.getConstructor().getPrototype();\n+        }\n+      } else {\n+        while (objType != null && objType.getImplicitPrototype() != objType) {\n+          if (objType.hasOwnProperty(field)) {\n+            foundType = objType;\n+          }\n+          objType = objType.getImplicitPrototype();\n+        }\n+      }\n+\n       // If the property does not exist on the referenced type but the original\n       // type is an object type, see if any subtype has the property.\n       if (foundType == null) {\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n-import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n   private JSType returnType = null;\n   private boolean returnTypeInferred = false;\n   private List<ObjectType> implementedInterfaces = null;\n+  private List<ObjectType> extendedInterfaces = null;\n   private ObjectType baseType = null;\n   private ObjectType thisType = null;\n   private boolean isConstructor = false;\n       ObjectType objectType = ObjectType.cast(type);\n       if (objectType == null) {\n         reportWarning(EXTENDS_NON_OBJECT, fnName, type.toString());\n-      } else if (\n-          objectType.isEmptyType() ||\n-          (objectType.isUnknownType() &&\n-           // If this has a supertype that hasn't been resolved yet,\n-           // then we can assume this type will be ok once the super\n-           // type resolves.\n-           (objectType.getImplicitPrototype() == null ||\n-            objectType.getImplicitPrototype().isResolved()))) {\n+        return false;\n+      } else if (objectType.isEmptyType()) {\n         reportWarning(RESOLVED_TAG_EMPTY, \"@extends\", fnName);\n+        return false;\n+      } else if (objectType.isUnknownType()) {\n+        if (hasMoreTagsToResolve(objectType)) {\n+          return true;\n+        } else {\n+          reportWarning(RESOLVED_TAG_EMPTY, \"@extends\", fnName);\n+          return false;\n+        }\n       } else {\n         return true;\n       }\n-      return false;\n     }\n   }\n \n       ObjectType objectType = ObjectType.cast(type);\n       if (objectType == null) {\n         reportError(BAD_IMPLEMENTED_TYPE, fnName);\n-      } else if (\n-          objectType.isEmptyType() ||\n-          (objectType.isUnknownType() &&\n-           // If this has a supertype that hasn't been resolved yet,\n-           // then we can assume this type will be ok once the super\n-           // type resolves.\n-           (objectType.getImplicitPrototype() == null ||\n-            objectType.getImplicitPrototype().isResolved()))) {\n+        return false;\n+      } else if (objectType.isEmptyType()) {\n         reportWarning(RESOLVED_TAG_EMPTY, \"@implements\", fnName);\n+        return false;\n+      } else if (objectType.isUnknownType()) {\n+        if (hasMoreTagsToResolve(objectType)) {\n+          return true;\n+        } else {\n+          reportWarning(RESOLVED_TAG_EMPTY, \"@implements\", fnName);\n+          return false;\n+        }\n       } else {\n         return true;\n       }\n-      return false;\n     }\n   }\n \n \n       // base type\n       if (info.hasBaseType()) {\n-        if (isConstructor || isInterface) {\n+        if (isConstructor) {\n           JSType maybeBaseType =\n               info.getBaseType().evaluate(scope, typeRegistry);\n           if (maybeBaseType != null &&\n             implementedInterfaces.add((ObjectType) maybeInterType);\n           }\n         }\n-        if (baseType != null) {\n-          JSType maybeFunctionType = baseType.getConstructor();\n-          if (maybeFunctionType instanceof FunctionType) {\n-            FunctionType functionType = baseType.getConstructor();\n-            Iterables.addAll(\n-                implementedInterfaces,\n-                functionType.getImplementedInterfaces());\n-          }\n-        }\n       } else if (info.getImplementedInterfaceCount() > 0) {\n         reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName);\n+      }\n+\n+      // extended interfaces (for interface only)\n+      if (isInterface) {\n+        extendedInterfaces = Lists.newArrayList();\n+        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n+          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n+          if (maybeInterfaceType != null &&\n+              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n+            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n+          }\n+        }\n       }\n     }\n \n       fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n \n+    if (extendedInterfaces != null) {\n+      fnType.setExtendedInterfaces(extendedInterfaces);\n+    }\n+\n     typeRegistry.clearTemplateTypeName();\n \n     return fnType;\n   }\n \n   private void maybeSetBaseType(FunctionType fnType) {\n-    if (baseType != null) {\n+    if (!fnType.isInterface() && baseType != null) {\n       fnType.setPrototypeBasedOn(baseType);\n     }\n   }\n     }\n     return scope;\n   }\n+\n+  /**\n+   * Check whether a type is resolvable in the future\n+   * If this has a supertype that hasn't been resolved yet, then we can assume\n+   * this type will be ok once the super type resolves.\n+   * @param objectType\n+   * @return true if objectType is resolvable in the future\n+   */\n+  private static boolean hasMoreTagsToResolve(ObjectType objectType) {\n+    Preconditions.checkArgument(objectType.isUnknownType());\n+    if (objectType.getImplicitPrototype() != null) {\n+      // constructor extends class\n+      if (objectType.getImplicitPrototype().isResolved()) {\n+        return false;\n+      } else {\n+        return true;\n+      }\n+    } else {\n+      // interface extends interfaces\n+      FunctionType ctor = objectType.getConstructor();\n+      if (ctor != null) {\n+        for (ObjectType interfaceType : ctor.getExtendedInterfaces()) {\n+          if (!interfaceType.isResolved()) {\n+            return true;\n+          }\n+        }\n+      }\n+      return false;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     FunctionType superClass = ctorType.getSuperClassConstructor();\n     boolean superClassHasProperty = superClass != null &&\n         superClass.getPrototype().hasProperty(propertyName);\n+    // For interface\n+    boolean superInterfacesHasProperty = false;\n+    if (ctorType.isInterface()) {\n+      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n+        superInterfacesHasProperty =\n+          superInterfacesHasProperty || interfaceType.hasProperty(propertyName);\n+      }\n+    }\n     boolean declaredOverride = info != null && info.isOverride();\n \n     boolean foundInterfaceProperty = false;\n     if (ctorType.isConstructor()) {\n-      for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n+      for (JSType implementedInterface :\n+          ctorType.getAllImplementedInterfaces()) {\n         if (implementedInterface.isUnknownType() ||\n             implementedInterface.isEmptyType()) {\n           continue;\n       }\n     }\n \n-    if (!declaredOverride && !superClassHasProperty) {\n+    if (!declaredOverride && !superClassHasProperty\n+        && !superInterfacesHasProperty) {\n       // nothing to do here, it's just a plain new property\n       return;\n     }\n             t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                 propertyName, topInstanceType.toString(),\n                 superClassPropType.toString(), propertyType.toString()));\n+      }\n+    } else if (superInterfacesHasProperty) {\n+      // there is an super interface property\n+      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n+        if (interfaceType.hasProperty(propertyName)) {\n+          JSType superPropertyType =\n+            interfaceType.getPropertyType(propertyName);\n+          if (!propertyType.canAssignTo(superPropertyType)) {\n+            topInstanceType = interfaceType.getConstructor().\n+                getTopMostDefiningType(propertyName);\n+            compiler.report(\n+                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n+                    propertyName, topInstanceType.toString(),\n+                    superPropertyType.toString(),\n+                    propertyType.toString()));\n+          }\n+        }\n       }\n     } else if (!foundInterfaceProperty) {\n       // there is no superclass nor interface implementation\n    * @param n The node being visited.\n    */\n   private void visitFunction(NodeTraversal t, Node n) {\n-    JSDocInfo info = n.getJSDocInfo();\n-\n     FunctionType functionType = (FunctionType) n.getJSType();\n     String functionPrivateName = n.getFirstChild().getString();\n-    if (functionType.isInterface() || functionType.isConstructor()) {\n+    if (functionType.isConstructor()) {\n       FunctionType baseConstructor = functionType.\n           getPrototype().getImplicitPrototype().getConstructor();\n       if (baseConstructor != null &&\n           baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n-          (baseConstructor.isConstructor() && functionType.isInterface() ||\n-           baseConstructor.isInterface() && functionType.isConstructor())) {\n+          (baseConstructor.isInterface() && functionType.isConstructor())) {\n         compiler.report(\n             t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n-      }\n-\n-      if (functionType.isInterface()) {\n-        if (functionType.hasImplementedInterfaces()) {\n-          compiler.report(t.makeError(n,\n-              CONFLICTING_IMPLEMENTED_TYPE, functionPrivateName));\n-        }\n       } else {\n+        // All interfaces are properly implemented by a class\n         for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n           boolean badImplementedType = false;\n           ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n             report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n           }\n         }\n-      }\n-      if (functionType.isConstructor()) {\n+        // check properties\n         validator.expectAllInterfaceProperties(t, n, functionType);\n+      }\n+    } else if (functionType.isInterface()) {\n+      // Interface must extend only interfaces\n+      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n+        if (extInterface.getConstructor() != null\n+            && !extInterface.getConstructor().isInterface()) {\n+          compiler.report(\n+              t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n+        }\n+      }\n+      // Interface cannot implement any interfaces\n+      if (functionType.hasImplementedInterfaces()) {\n+        compiler.report(t.makeError(n,\n+            CONFLICTING_IMPLEMENTED_TYPE, functionPrivateName));\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n       ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n       if (objectType != null) {\n         String propName = n.getLastChild().getString();\n-        while (objectType != null && !objectType.hasOwnProperty(propName)) {\n-          objectType = objectType.getImplicitPrototype();\n+        if (objectType.getConstructor() != null &&\n+            objectType.getConstructor().isInterface()) {\n+          objectType = FunctionType.getTopDefiningInterface(\n+              objectType, propName);\n+        } else {\n+          // classes\n+          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n+            objectType = objectType.getImplicitPrototype();\n+          }\n         }\n \n         // Don't show complex function names or anonymous types.\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n         }\n       }\n \n+      if (funType.isInterface()) {\n+        for (ObjectType interfaceType : funType.getExtendedInterfaces()) {\n+          sb.append(\" * @extends {\" + interfaceType + \"}\\n\");\n+        }\n+      }\n+\n       // Avoid duplicates, add implemented type to a set first\n       Set<String> interfaces = Sets.newTreeSet();\n       for (ObjectType interfaze : funType.getImplementedInterfaces()) {\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n           parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n               typeInfo.lineno, typeInfo.charno);\n         }\n-      }\n-\n-      // For interfaces, still record the first extended type as base type\n-      // It's the temporary setting and will be changed when multiple\n-      // extends for interfaces are done\n-      if (!jsdocBuilder.recordBaseType(typeInfo.type) &&\n-          !jsdocBuilder.isInterfaceRecorded()) {\n-        parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-            typeInfo.lineno, typeInfo.charno);\n+      } else {\n+        if (!jsdocBuilder.recordBaseType(typeInfo.type)) {\n+          parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n+              typeInfo.lineno, typeInfo.charno);\n+        }\n       }\n     }\n   }\n--- a/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n /**\n     return getOwnerFunction().getImplementedInterfaces();\n   }\n \n+  @Override\n+  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n+    if (getOwnerFunction() != null) {\n+      return getOwnerFunction().getExtendedInterfaces();\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n+\n   // The owner will always be a resolved type, so there's no need to set\n   // the ownerFunction in resolveInternal.\n   // (it would lead to infinite loops if we did).\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   private Node source;\n \n   /**\n-   * The interfaces directly implemented by this function.\n+   * The interfaces directly implemented by this function (for constructors)\n    * It is only relevant for constructors. May not be {@code null}.\n    */\n   private List<ObjectType> implementedInterfaces = ImmutableList.of();\n+\n+  /**\n+   * The interfaces directly extendeded by this function (for interfaces)\n+   * It is only relevant for constructors. May not be {@code null}.\n+   */\n+  private List<ObjectType> extendedInterfaces = ImmutableList.of();\n \n   /**\n    * The types which are subtypes of this function. It is only relevant for\n       if (superClass != null) {\n         superClass.addSubType(this);\n       }\n+\n+      if (isInterface()) {\n+        for (ObjectType interfaceType : getExtendedInterfaces()) {\n+          if (interfaceType.getConstructor() != null) {\n+            interfaceType.getConstructor().addSubType(this);\n+          }\n+        }\n+      }\n     }\n \n     if (replacedPrototype) {\n \n       set.add(instance);\n \n-      if (constructor.getSuperClassConstructor() != null) {\n-        addRelatedInterfaces(\n-            constructor.getSuperClassConstructor().getInstanceType(), set);\n+      for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) {\n+        addRelatedInterfaces(interfaceType, set);\n       }\n     }\n   }\n       registry.registerTypeImplementingInterface(this, type);\n     }\n     this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);\n+  }\n+\n+  /**\n+   * Returns all extended interfaces declared by an interfaces or its super-\n+   * interfaces. If this is called before all types are resolved, it may return\n+   * an incomplete set.\n+   */\n+  public Iterable<ObjectType> getAllExtendedInterfaces() {\n+    // Store them in a linked hash set, so that the compile job is\n+    // deterministic.\n+    Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet();\n+\n+    for (ObjectType interfaceType : getExtendedInterfaces()) {\n+      addRelatedExtendedInterfaces(interfaceType, extendedInterfaces);\n+    }\n+    return extendedInterfaces;\n+  }\n+\n+  private void addRelatedExtendedInterfaces(ObjectType instance,\n+      Set<ObjectType> set) {\n+    FunctionType constructor = instance.getConstructor();\n+    if (constructor != null) {\n+      set.add(instance);\n+\n+      for (ObjectType interfaceType : constructor.getExtendedInterfaces()) {\n+        addRelatedExtendedInterfaces(interfaceType, set);\n+      }\n+    }\n+  }\n+\n+  /** Returns interfaces directly extended by an interface */\n+  public Iterable<ObjectType> getExtendedInterfaces() {\n+    return extendedInterfaces;\n+  }\n+\n+  public void setExtendedInterfaces(List<ObjectType> extendedInterfaces)\n+    throws UnsupportedOperationException {\n+    if (isInterface()) {\n+      this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces);\n+    } else {\n+      throw new UnsupportedOperationException();\n+    }\n   }\n \n   @Override\n   }\n \n   /**\n+   * Given an interface and a property, finds the top-most super interface\n+   * that has the property defined (including this interface).\n+   */\n+  public static ObjectType getTopDefiningInterface(ObjectType type,\n+      String propertyName) {\n+    ObjectType foundType = null;\n+    if (type.hasProperty(propertyName)) {\n+      foundType = type;\n+    }\n+    for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) {\n+      if (interfaceType.hasProperty(propertyName)) {\n+        foundType = getTopDefiningInterface(interfaceType, propertyName);\n+      }\n+    }\n+    return foundType;\n+  }\n+\n+  /**\n    * Given a constructor or an interface type and a property, finds the\n    * top-most superclass that has the property defined (including this\n    * constructor).\n    */\n-  public JSType getTopMostDefiningType(String propertyName) {\n+  public ObjectType getTopMostDefiningType(String propertyName) {\n     Preconditions.checkState(isConstructor() || isInterface());\n     Preconditions.checkArgument(getPrototype().hasProperty(propertyName));\n     FunctionType ctor = this;\n-    JSType topInstanceType;\n-    do {\n+\n+    if (isInterface()) {\n+      return getTopDefiningInterface(this.getInstanceType(), propertyName);\n+    }\n+\n+    ObjectType topInstanceType = ctor.getInstanceType();\n+    while (true) {\n       topInstanceType = ctor.getInstanceType();\n       ctor = ctor.getSuperClassConstructor();\n-    } while (ctor != null && ctor.getPrototype().hasProperty(propertyName));\n+      if (ctor == null || !ctor.getPrototype().hasProperty(propertyName)) {\n+        break;\n+      }\n+    }\n     return topInstanceType;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n     return getConstructor().getImplementedInterfaces();\n   }\n \n+  @Override\n+  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n+    return getConstructor().getExtendedInterfaces();\n+  }\n+\n   // The owner will always be a resolved type, so there's no need to set\n   // the constructor in resolveInternal.\n   // (it would lead to infinite loops if we did).\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n       if (implicitProto == null ||\n           implicitProto.isNativeObjectType()) {\n         unknown = false;\n+        for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n+          if (interfaceType.isUnknownType()) {\n+            unknown = true;\n+            break;\n+          }\n+        }\n       } else {\n         unknown = implicitProto.isUnknownType();\n       }\n   public Iterable<ObjectType> getCtorImplementedInterfaces() {\n     return ImmutableSet.of();\n   }\n+\n+  /**\n+   * Gets the interfaces extended by the interface associated with this type.\n+   * Intended to be overriden by subclasses.\n+   */\n+  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n+    return ImmutableSet.of();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n     }\n     ObjectType implicitPrototype = getImplicitPrototype();\n     if (implicitPrototype != null) {\n-      return implicitPrototype.hasProperty(propertyName);\n+      if (implicitPrototype.hasProperty(propertyName)) {\n+        return true;\n+      }\n+    }\n+    for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n+      if (interfaceType.hasProperty(propertyName)) {\n+        return true;\n+      }\n     }\n     return false;\n   }\n       }\n     }\n \n+    if (getConstructor() != null && getConstructor().isInterface()) {\n+      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n+        if (thisInterface.isSubtype(that)) {\n+          return true;\n+        }\n+      }\n+    }\n+\n     // other prototype based objects\n     if (that != null) {\n       if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n         + \"/**\\n * @interface\\n */\\n\"\n         + \"a.Foo = function() {\\n};\\n\"\n         + \"/**\\n * @extends {a.Foo}\\n\"\n+        + \" * @interface\\n */\\n\"\n+        + \"a.Bar = function() {\\n};\\n\");\n+  }\n+\n+  public void testTypeAnnotationsMultipleInterface() {\n+    assertTypeAnnotations(\"var a = {};\"\n+        + \"/** @interface */ a.Foo1 = function(){};\"\n+        + \"/** @interface */ a.Foo2 = function(){};\"\n+        + \"/** @interface \\n @extends {a.Foo1} \\n @extends {a.Foo2} */\"\n+        + \"a.Bar = function(){}\",\n+        \"var a = {};\\n\"\n+        + \"/**\\n * @interface\\n */\\n\"\n+        + \"a.Foo1 = function() {\\n};\\n\"\n+        + \"/**\\n * @interface\\n */\\n\"\n+        + \"a.Foo2 = function() {\\n};\\n\"\n+        + \"/**\\n * @extends {a.Foo1}\\n\"\n+        + \" * @extends {a.Foo2}\\n\"\n         + \" * @interface\\n */\\n\"\n         + \"a.Bar = function() {\\n};\\n\");\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   public void testInterfaceAssignment8() throws Exception {\n     testTypes(\"/** @interface */var I = function() {};\\n\" +\n         \"/** @type {I} */var i;\\n\" +\n-        \"/** @type {Object} */var o = i;\");\n+        \"/** @type {Object} */var o = i;\\n\" +\n+        \"new Object().prototype = i.prototype;\");\n   }\n \n   public void testInterfaceAssignment9() throws Exception {\n         \" it overrides from interface I\\n\" +\n         \"original: string\\n\" +\n         \"override: number\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck13() throws Exception {\n+    testTypes(\n+        \"function abstractMethod() {};\\n\" +\n+        \"/** @interface */var base = function() {};\\n\" +\n+        \"/** @extends {base} \\n @interface */ var Int = function() {}\\n\" +\n+        \"/** @type {{bar : !Function}} */ var x; \\n\" +\n+        \"/** @type {!Function} */ base.prototype.bar = abstractMethod; \\n\" +\n+        \"/** @type {Int} */ foo;\\n\" +\n+        \"foo.bar();\");\n   }\n \n   public void testInterfacePropertyNotImplemented() throws Exception {\n            \"Bad type annotation. Unknown type y\"});\n   }\n \n+  public void testMultipleExtendsInterface1() throws Exception {\n+    testTypes(\"/** @interface */ function base1() {}\\n\"\n+        + \"/** @interface */ function base2() {}\\n\"\n+        + \"/** @interface\\n\"\n+        + \"* @extends {base1}\\n\"\n+        + \"* @extends {base2}\\n\"\n+        + \"*/\\n\"\n+        + \"function derived() {}\");\n+  }\n+\n+  public void testMultipleExtendsInterface2() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Int0() {};\" +\n+        \"/** @interface */function Int1() {};\" +\n+        \"/** @desc description */Int0.prototype.foo = function() {};\" +\n+        \"/** @interface \\n @extends {Int0} \\n @extends {Int1} */\" +\n+        \"function Int2() {};\" +\n+        \"/** @constructor\\n @implements {Int2} */function Foo() {};\",\n+        \"property foo on interface Int0 is not implemented by type Foo\");\n+  }\n+\n+  public void testMultipleExtendsInterface3() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Int0() {};\" +\n+        \"/** @interface */function Int1() {};\" +\n+        \"/** @desc description */Int1.prototype.foo = function() {};\" +\n+        \"/** @interface \\n @extends {Int0} \\n @extends {Int1} */\" +\n+        \"function Int2() {};\" +\n+        \"/** @constructor\\n @implements {Int2} */function Foo() {};\",\n+        \"property foo on interface Int1 is not implemented by type Foo\");\n+  }\n+\n+  public void testMultipleExtendsInterface4() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Int0() {};\" +\n+        \"/** @interface */function Int1() {};\" +\n+        \"/** @interface \\n @extends {Int0} \\n @extends {Int1} \\n\" +\n+        \" @extends {number} */\" +\n+        \"function Int2() {};\" +\n+        \"/** @constructor\\n @implements {Int2} */function Foo() {};\",\n+        \"Int2 @extends non-object type number\");\n+  }\n+\n+  public void testMultipleExtendsInterface5() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Int0() {};\" +\n+        \"/** @constructor */function Int1() {};\" +\n+        \"/** @desc description @ return {string} x */\" +\n+        \"/** @interface \\n @extends {Int0} \\n @extends {Int1} */\" +\n+        \"function Int2() {};\",\n+        \"Int2 cannot extend this type; a constructor can only extend \" +\n+        \"objects and an interface can only extend interfaces\");\n+  }\n+\n+  public void testMultipleExtendsInterface6() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Super1() {};\" +\n+        \"/** @interface */function Super2() {};\" +\n+        \"/** @param {number} bar */Super2.prototype.foo = function(bar) {};\" +\n+        \"/** @interface\\n @extends {Super1}\\n \" +\n+        \"@extends {Super2} */function Sub() {};\" +\n+        \"/** @override\\n @param {string} bar */Sub.prototype.foo =\\n\" +\n+        \"function(bar) {};\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from superclass Super2\\n\" +\n+        \"original: function (this:Super2, number): undefined\\n\" +\n+        \"override: function (this:Sub, string): undefined\");\n+  }\n+\n+  public void testMultipleExtendsInterfaceAssignment() throws Exception {\n+    testTypes(\"/** @interface */var I1 = function() {};\\n\" +\n+        \"/** @interface */ var I2 = function() {}\\n\" +\n+        \"/** @interface\\n@extends {I1}\\n@extends {I2}*/\" +\n+        \"var I3 = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I3}*/var T = function() {};\\n\" +\n+        \"var t = new T();\\n\" +\n+         \"/** @type {I1} */var i1 = t;\\n\" +\n+         \"/** @type {I2} */var i2 = t;\\n\" +\n+         \"/** @type {I3} */var i3 = t;\\n\" +\n+         \"i1 = i3;\\n\" +\n+         \"i2 = i3;\\n\");\n+  }\n+\n+  public void testMultipleExtendsInterfaceParamPass() throws Exception {\n+    testTypes(\"/** @interface */var I1 = function() {};\\n\" +\n+        \"/** @interface */ var I2 = function() {}\\n\" +\n+        \"/** @interface\\n@extends {I1}\\n@extends {I2}*/\" +\n+        \"var I3 = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I3}*/var T = function() {};\\n\" +\n+        \"var t = new T();\\n\" +\n+        \"/** @param x I1 \\n@param y I2\\n@param z I3*/function foo(x,y,z){};\\n\" +\n+        \"foo(t,t,t)\\n\");\n+  }\n+\n+  public void testBadMultipleExtendsClass() throws Exception {\n+    testTypes(\"/** @constructor */ function base1() {}\\n\"\n+        + \"/** @constructor */ function base2() {}\\n\"\n+        + \"/** @constructor\\n\"\n+        + \"* @extends {base1}\\n\"\n+        + \"* @extends {base2}\\n\"\n+        + \"*/\\n\"\n+        + \"function derived() {}\",\n+        \"Bad type annotation. type annotation incompatible \"\n+        + \"with other annotations\");\n+  }\n+\n+  public void testInterfaceExtendsResolution() throws Exception {\n+    testTypes(\"/** @interface \\n @extends {A} */ function B() {};\\n\" +\n+        \"/** @constructor \\n @implements {B} */ function C() {};\\n\" +\n+        \"/** @interface */ function A() {};\");\n+  }\n+\n+  public void testPropertyCanBeDefinedInObject() throws Exception {\n+    testTypes(\"/** @interface */ function I() {};\" +\n+        \"I.prototype.bar = function() {};\" +\n+        \"/** @type {Object} */ var foo;\" +\n+        \"foo.bar();\");\n+  }\n+\n   private void checkObjectType(ObjectType objectType, String propertyName,\n         JSType expectedType) {\n     assertTrue(\"Expected \" + objectType.getReferenceName() +\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n         \" * @extends {Extended1} \\n\" +\n         \" * @extends {Extended2} */\");\n     assertTrue(jsdoc.isInterface());\n+    assertNull(jsdoc.getBaseType());\n     assertEquals(2, jsdoc.getExtendedInterfacesCount());\n     List<JSTypeExpression> types = jsdoc.getExtendedInterfaces();\n     assertTypeEquals(registry.createNamedType(\"Extended1\", null, -1, -1),\n         \" * @extends {Extended2} \\n\" +\n         \" * @extends {Extended3} */\");\n     assertTrue(jsdoc.isInterface());\n+    assertNull(jsdoc.getBaseType());\n     assertEquals(3, jsdoc.getExtendedInterfacesCount());\n     List<JSTypeExpression> types = jsdoc.getExtendedInterfaces();\n     assertTypeEquals(registry.createNamedType(\"Extended1\", null, -1, -1),\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.Lists;\n+\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n \n     assertFalse(GREATEST_FUNCTION_TYPE.isEmptyType());\n   }\n \n+  public void testInterfacePrototypeChain1() {\n+    FunctionType iface = registry.createInterfaceType(\"I\", null);\n+    assertTypeEquals(\n+        iface.getPrototype(),\n+        iface.getInstanceType().getImplicitPrototype());\n+    assertTypeEquals(\n+        OBJECT_TYPE,\n+        iface.getPrototype().getImplicitPrototype());\n+  }\n+\n+  public void testInterfacePrototypeChain2() {\n+    FunctionType iface = registry.createInterfaceType(\"I\", null);\n+    FunctionType subIface = registry.createInterfaceType(\"SubI\", null);\n+    subIface.setExtendedInterfaces(Lists.<ObjectType>newArrayList(iface));\n+    assertTypeEquals(\n+        subIface.getPrototype(),\n+        subIface.getInstanceType().getImplicitPrototype());\n+    assertTypeEquals(\n+        OBJECT_TYPE,\n+        subIface.getPrototype().getImplicitPrototype());\n+  }\n+\n   private void assertLeastSupertype(String s, JSType t1, JSType t2) {\n     assertEquals(s, t1.getLeastSupertype(t2).toString());\n     assertEquals(s, t2.getLeastSupertype(t1).toString());\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n   private FunctionType subclassCtor;\n   private FunctionType interfaceType;\n   private ObjectType interfaceInstType;\n+  private FunctionType subInterfaceType;\n+  private ObjectType subInterfaceInstType;\n   private JSType recordType;\n   private EnumType enumType;\n   private EnumElementType elementsType;\n \n     interfaceType = FunctionType.forInterface(registry, \"Interface\", null);\n     interfaceInstType = interfaceType.getInstanceType();\n+\n+    subInterfaceType = FunctionType.forInterface(\n+        registry, \"SubInterface\", null);\n+    subInterfaceType.setExtendedInterfaces(\n+        Lists.<ObjectType>newArrayList(interfaceInstType));\n+    subInterfaceInstType = subInterfaceType.getInstanceType();\n \n     googBar = registry.createConstructorType(\"goog.Bar\", null, null, null);\n     googBar.getPrototype().defineDeclaredProperty(\"date\", DATE_TYPE, true,\n     verifySubtypeChain(typeChain);\n   }\n \n+  public void testInterfaceInheritanceSubtypeChain() throws Exception {\n+    FunctionType tempType =\n+      registry.createConstructorType(\"goog.TempType\", null, null, null);\n+    tempType.setImplementedInterfaces(\n+        Lists.<ObjectType>newArrayList(subInterfaceInstType));\n+    List<JSType> typeChain = Lists.newArrayList(\n+        ALL_TYPE,\n+        OBJECT_TYPE,\n+        interfaceInstType,\n+        subInterfaceInstType,\n+        tempType.getPrototype(),\n+        tempType.getInstanceType(),\n+        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n+        registry.getNativeType(JSTypeNative.NO_TYPE));\n+    verifySubtypeChain(typeChain);\n+  }\n+\n   /**\n    * Tests that the given chain of types has a total ordering defined\n    * by the subtype relationship, with types at the top of the lattice\n     assertTrue(namedGoogBar.hasProperty(\"sub\"));\n   }\n \n+  public void testInterfaceHasOwnProperty() throws Exception {\n+    interfaceInstType.defineProperty(\"base\", null, false, false, null);\n+    subInterfaceInstType.defineProperty(\"sub\", null, false, false, null);\n+\n+    assertTrue(interfaceInstType.hasProperty(\"base\"));\n+    assertFalse(interfaceInstType.hasProperty(\"sub\"));\n+    assertTrue(interfaceInstType.hasOwnProperty(\"base\"));\n+    assertFalse(interfaceInstType.hasOwnProperty(\"sub\"));\n+    assertFalse(interfaceInstType.hasOwnProperty(\"none\"));\n+\n+    assertTrue(subInterfaceInstType.hasProperty(\"base\"));\n+    assertTrue(subInterfaceInstType.hasProperty(\"sub\"));\n+    assertFalse(subInterfaceInstType.hasOwnProperty(\"base\"));\n+    assertTrue(subInterfaceInstType.hasOwnProperty(\"sub\"));\n+    assertFalse(subInterfaceInstType.hasOwnProperty(\"none\"));\n+  }\n+\n   public void testGetPropertyNames() throws Exception {\n     ObjectType sup =\n         registry.createObjectType(registry.createAnonymousObjectType());", "timestamp": 1305575833, "metainfo": ""}