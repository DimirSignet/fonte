{"sha": "2581851be3b2202bd48d4c76889b020f4cecebf6", "log": "Remove more unconditional jumps.  R=johnlenz DELTA=94  (74 added, 4 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=85018   ", "commit": "\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n-  @SuppressWarnings(\"fallthrough\")\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (parent == null) {\n     }\n     if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n         (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n))) {\n-      removeDeadExprStatementSafely(n, parent);\n-      return;\n-    }\n-\n+      removeDeadExprStatementSafely(n);\n+      return;\n+    }\n+\n+    tryRemoveUnconditionalBranching(n);\n+  }\n+\n+  /**\n+   * Tries to remove n if an unconditional branch node (break, continue or\n+   * return) if the target of n is the same as the the follow of n. That is, if\n+   * we remove n, the control flow remains the same. Also if n targets to\n+   * another unconditional branch, this function will recursively try to remove\n+   * the target branch as well. The reason why we want to cascade this removal\n+   * is because we only run this pass once. If we have code such as\n+   *\n+   * break -> break -> break\n+   *\n+   * where all 3 break's are useless. The order of removal matters. When we\n+   * first look at the first break, we see that it branches to the 2nd break.\n+   * However, if we remove the last break, the 2nd break becomes useless and\n+   * finally the first break becomes useless as well.\n+   *\n+   * @return The target of this jump. If the target is also useless jump,\n+   *     the target of that useless jump recursively.\n+   */\n+  @SuppressWarnings(\"fallthrough\")\n+  private Node tryRemoveUnconditionalBranching(Node n) {\n     /*\n      * For each of the unconditional branching control flow node, check to see\n      * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n      * if-else conversion but it handles more complicated switch statements\n      * much nicer.\n      */\n+\n+    // If n is null the target is the end of the function, nothing to do.\n+    if (n == null) {\n+       return n;\n+    }\n+\n+    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n+\n+    if (gNode == null) {\n+      return n;\n+    }\n+\n+    // If the parent is null, this mean whatever node it was there is now\n+    // useless and it has been removed by other logics in this pass. That node\n+    // while no longer exists in the AST, is still in the CFG because we\n+    // never update the graph as nodes are removed.\n+    if (n.getParent() == null) {\n+      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n+      if (outEdges.size() == 1) {\n+        return tryRemoveUnconditionalBranching(\n+          outEdges.get(0).getDestination().getValue());\n+      }\n+    }\n+\n     switch (n.getType()) {\n+      case Token.BLOCK:\n+        if (n.hasChildren()) {\n+          Node first = n.getFirstChild();\n+          return tryRemoveUnconditionalBranching(first);\n+        } else {\n+          return tryRemoveUnconditionalBranching(\n+            ControlFlowAnalysis.computeFollowNode(n));\n+        }\n       case Token.RETURN:\n         if (n.hasChildren()) {\n           break;\n             // If there is a next node, there is no chance this jump is useless.\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n-          Node fallThrough = ControlFlowAnalysis.computeFollowNode(n);\n-          if (outEdges.get(0).getDestination().getValue() == fallThrough) {\n-            removeDeadExprStatementSafely(n, parent);\n+          Node fallThrough = tryRemoveUnconditionalBranching(\n+            ControlFlowAnalysis.computeFollowNode(n));\n+          Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n+          if (nextCfgNode == fallThrough) {\n+            removeDeadExprStatementSafely(n);\n+            return fallThrough;\n           }\n+\n         }\n     }\n-  }\n-\n-  private void removeDeadExprStatementSafely(Node n, Node parent) {\n+    return n;\n+  }\n+\n+  private void removeDeadExprStatementSafely(Node n) {\n     if (n.getType() == Token.EMPTY ||\n         (n.getType() == Token.BLOCK && !n.hasChildren())) {\n       // Not always trivial to remove, let FoldContants work its magic later.\n     if (logger.isLoggable(Level.FINE)) {\n       logger.fine(\"Removing \" + n.toString());\n     }\n-    NodeUtil.removeChild(parent, n);\n+    NodeUtil.removeChild(n.getParent(), n);\n   }\n }\n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n     test(\"function foo(){switch(foo){case 1:x=1;return;break;\" +\n          \"case 2:{x=2;return;break}default:}}\",\n          \"function foo(){switch(foo){case 1:x=1;return;\" +\n-         \"case 2:{x=2;return}default:}}\");\n+         \"case 2:{x=2}default:}}\");\n \n     // if/else statements with returns\n     test(\"function bar(){if(foo)x=1;else if(bar){return;x=2}\" +\n \n     test(\"function() {switch (a) { case 'a': return}}\",\n          \"function() {switch (a) { case 'a': }}\");\n-    testSame(\"function() {switch (a) { case 'a': return; case foo(): }}\");\n+    testSame(\"function() {switch (a) { case 'a': case foo(): }}\");\n     testSame(\"function() {switch (a) { default: return; case 'a': alert(1)}}\");\n     testSame(\"function() {switch (a) { case 'a': return; default: alert(1)}}\");\n   }\n \n   public void testUnlessUnconditonalBreak() {\n     test(\"switch (a) { case 'a': break }\", \"switch (a) { case 'a': }\");\n-    testSame(\"switch (a) { case 'a': break; case foo(): }\");\n-    testSame(\"switch (a) { default: break; case 'a': }\");\n-    testSame(\"switch (a) { case 'a': break; default: }\");\n+    test(\"switch (a) { case 'a': break; case foo(): }\",\n+         \"switch (a) { case 'a':        case foo(): }\");\n+    test(\"switch (a) { default: break; case 'a': }\",\n+         \"switch (a) { default:        case 'a': }\");\n+\n+    testSame(\"switch (a) { case 'a': alert(a); break; default: alert(a); }\");\n+    testSame(\"switch (a) { default: alert(a); break; case 'a': alert(a); }\");\n \n \n     test(\"X: {switch (a) { case 'a': break X}}\",\n     test(\"X: {switch (a) { case 'a': if (a()) {break X}}}\",\n          \"X: {switch (a) { case 'a': if (a()) {}}}\");\n \n-    // TODO(user): Optimize these better.\n-    test(\"switch (a) { case 'a': break; case 'b': break; case 'c': break }\",\n-         \"switch (a) { case 'a': break; case 'b': break; case 'c': }\");\n \n     testSame(\"do { break } while(1);\");\n     testSame(\"for(;1;) { break }\");\n   }\n+\n+  public void testCascadedRemovalOfUnlessUnconditonalJumps() {\n+    test(\"switch (a) { case 'a': break; case 'b': break; case 'c': break }\",\n+         \"switch (a) { case 'a': case 'b': case 'c': }\");\n+    test(\"function foo() {\" +\n+         \"  switch (a) { case 'a':return; case 'b':return; case 'c':return }}\",\n+         \"function foo() { switch (a) { case 'a': case 'b': case 'c': }}\");\n+    testSame(\"function foo() {\" +\n+             \"switch (a) { case 'a':return 2; case 'b':return 1}}\");\n+  }\n }", "timestamp": 1281056790, "metainfo": ""}