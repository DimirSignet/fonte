{"sha": "7d80ca979b09eed590c85c00fb7957f90e1706d4", "log": "Peephole collapsing property assignments into objects/array definitions.  R=johnlenz DELTA=380  (348 added, 3 deleted, 29 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       return new PeepholeOptimizationsPass(compiler,\n             new PeepholeSubstituteAlternateSyntax(true),\n             new PeepholeRemoveDeadCode(),\n-            new PeepholeFoldConstants());\n-    }\n-  };\n-\n-  /** Same as peepholeOptimizations but aggreesively merges code together */\n+            new PeepholeFoldConstants(),\n+            new PeepholeCollectPropertyAssignments());\n+    }\n+  };\n+\n+  /** Same as peepholeOptimizations but aggressively merges code together */\n   private final PassFactory latePeepholeOptimizations =\n       new PassFactory(\"peepholeOptimizations\", false) {\n     @Override\n       new PassFactory(\"replaceStrings\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n-      VariableMap map = null;\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n           ReplaceStrings pass = new ReplaceStrings(\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * A pass that looks for assignments to properties of an object or array\n+ * immediately following its creation using the abbreviated syntax.\n+ * <p>\n+ * E.g. {@code var a = [];a[0] = 0} is optimized to {@code var a = [0]} and\n+ * similarly for the object constructor.\n+ *\n+ */\n+public class PeepholeCollectPropertyAssignments\n+    extends AbstractPeepholeOptimization {\n+\n+  @Override\n+  Node optimizeSubtree(Node subtree) {\n+    if (subtree.getType() != Token.SCRIPT\n+        && subtree.getType() != Token.BLOCK) {\n+      return subtree;\n+    }\n+\n+    boolean codeChanged = false;\n+\n+    // Look for variable declarations and start processing there.\n+    for (Node child = subtree.getFirstChild();\n+         child != null; child = child.getNext()) {\n+      if (child.getType() != Token.VAR) {\n+        continue;\n+      }\n+      if (!isPropertyAssignmentToVar(child.getNext())) {\n+        // Quick check to see if there's anything to collapse.\n+        continue;\n+      }\n+\n+      Preconditions.checkState(child.hasOneChild());\n+      Node var = child.getFirstChild();\n+      Node varValue = var.getFirstChild();\n+      if (varValue == null) {  // No initializer.\n+        continue;\n+      }\n+\n+      Node propertyCandidate;\n+      while ((propertyCandidate = child.getNext()) != null) {\n+        // This does not infinitely loop because collectProperty always\n+        // removes propertyCandidate from its parent when it returns true.\n+        if (!collectProperty(propertyCandidate, var)) {\n+          break;\n+        }\n+        codeChanged = true;\n+      }\n+    }\n+\n+    if (codeChanged) {\n+      reportCodeChange();\n+    }\n+    return subtree;\n+  }\n+\n+  private boolean isPropertyAssignmentToVar(Node propertyCandidate) {\n+    if (propertyCandidate == null) { return false; }\n+    // Must be an assignment...\n+    if (!NodeUtil.isExprAssign(propertyCandidate)) {\n+      return false;\n+    }\n+\n+    Node expr = propertyCandidate.getFirstChild();\n+\n+    // to a property...\n+    Node lhs = expr.getFirstChild();\n+    if (lhs.getType() != Token.GETELEM && lhs.getType() != Token.GETPROP) {\n+      return false;\n+    }\n+\n+    // of a variable.\n+    Node obj = lhs.getFirstChild();\n+    if (obj.getType() != Token.NAME) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private boolean collectProperty(Node propertyCandidate, Node var) {\n+    if (!isPropertyAssignmentToVar(propertyCandidate)) {\n+      return false;\n+    }\n+\n+    String varName = var.getString();\n+\n+    Node lhs = propertyCandidate.getFirstChild().getFirstChild();\n+    // Must be an assignment to the recent variable...\n+    if (!varName.equals(lhs.getFirstChild().getString())) {\n+      return false;\n+    }\n+\n+    Node rhs = lhs.getNext();\n+    // with a value that cannot change the values of the variables,\n+    if (NodeUtil.mayHaveSideEffects(rhs)\n+        || NodeUtil.canBeSideEffected(rhs)) {\n+      return false;\n+    }\n+    // and does not have a reference to a variable initialized after it.\n+    if (mightContainForwardReference(rhs, varName)) {\n+      return false;\n+    }\n+\n+    // Either collect it as an array property or an object property based on\n+    // the type of the variable initializer.\n+    Node varValue = var.getFirstChild();\n+    switch (varValue.getType()) {\n+      case Token.ARRAYLIT:\n+        if (!collectArrayProperty(varValue, propertyCandidate)) {\n+          return false;\n+        }\n+        break;\n+      case Token.OBJECTLIT:\n+        if (!collectObjectProperty(varValue, propertyCandidate)) {\n+          return false;\n+        }\n+        break;\n+      default: return false;\n+    }\n+    return true;\n+  }\n+\n+\n+  private boolean collectArrayProperty(\n+      Node arrayLiteral, Node propertyCandidate) {\n+    Node assignment = propertyCandidate.getFirstChild();\n+    final int sizeOfArrayAtStart = arrayLiteral.getChildCount();\n+    int maxIndexAssigned = sizeOfArrayAtStart - 1;\n+\n+    Node lhs = assignment.getFirstChild();\n+    Node rhs = lhs.getNext();\n+    if (lhs.getType() != Token.GETELEM) {\n+      return false;\n+    }\n+    Node obj = lhs.getFirstChild();\n+    Node property = obj.getNext();\n+    // The left hand side must have a numeric index\n+    if (property.getType() != Token.NUMBER) {\n+      return false;\n+    }\n+    // that is a valid array index\n+    double dindex = property.getDouble();\n+    if (!(dindex >= 0)  // Handles NaN and negatives.\n+        || Double.isInfinite(dindex) || dindex > 0x7fffffffL) {\n+      return false;\n+    }\n+    int index = (int) dindex;\n+    if (dindex != index) {\n+      return false;\n+    }\n+    // that would not make the array so sparse that they take more space\n+    // when rendered than x[9]=1.\n+    if (maxIndexAssigned + 4 < index) {\n+      return false;\n+    }\n+    while (maxIndexAssigned < index - 1) {\n+      // Pad the array if it is sparse.\n+      // So if array is [0] and integer 3 is assigned at index is 2, then\n+      // we want to produce [0,,2].\n+      Node emptyNode = new Node(Token.EMPTY)\n+          .copyInformationFrom(arrayLiteral);\n+      arrayLiteral.addChildToBack(emptyNode);\n+      ++maxIndexAssigned;\n+    }\n+    arrayLiteral.addChildToBack(rhs.detachFromParent());\n+    ++maxIndexAssigned;\n+\n+    propertyCandidate.detachFromParent();\n+    return true;\n+  }\n+\n+  private boolean collectObjectProperty(\n+      Node objectLiteral, Node propertyCandidate) {\n+    Node assignment = propertyCandidate.getFirstChild();\n+    Node lhs = assignment.getFirstChild(), rhs = lhs.getNext();\n+    Node obj = lhs.getFirstChild();\n+    Node property = obj.getNext();\n+\n+    // The property must be statically known.\n+    if (lhs.getType() == Token.GETELEM\n+        && (property.getType() != Token.STRING\n+            && property.getType() != Token.NUMBER)) {\n+      return false;\n+    }\n+\n+    String propertyName;\n+    if (property.getType() == Token.NUMBER) {\n+      propertyName = NodeUtil.getStringValue(property);\n+    } else {\n+      propertyName = property.getString();\n+    }\n+\n+    Node newProperty = Node.newString(propertyName)\n+        .copyInformationFrom(property);\n+    // Preserve the quotedness of a property reference\n+    if (lhs.getType() == Token.GETELEM) {\n+      newProperty.setQuotedString();\n+    }\n+    Node newValue = rhs.detachFromParent();\n+    newProperty.addChildToBack(newValue);\n+    objectLiteral.addChildToBack(newProperty);\n+\n+    propertyCandidate.detachFromParent();\n+    return true;\n+  }\n+\n+\n+  private static boolean mightContainForwardReference(\n+      Node node, String varName) {\n+    if (node.getType() == Token.NAME) {\n+      return varName.equals(node.getString());\n+    }\n+    for (Node child = node.getFirstChild(); child != null;\n+         child = child.getNext()) {\n+      if (mightContainForwardReference(child, varName)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+}\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n         // In the case of JsDoc trees, the first child is often not a string\n         // which causes exceptions to be thrown when calling toString or\n         // toStringTree.\n-        if (first.getType() == Token.STRING) {\n+        if (first == null || first.getType() != Token.NAME) {\n+          sb.append(\"<invalid>\");\n+        } else {\n           sb.append(first.getString());\n         }\n       } else if (this instanceof ScriptOrFnNode) {\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n \n   public void testProcessClosurePrimitives() {\n     test(\"var goog = {}; goog.provide('goog.dom');\",\n-         \"var goog = {}; goog.dom = {};\");\n+         \"var goog = {dom:{}};\");\n     args.add(\"--process_closure_primitives=false\");\n     testSame(\"var goog = {}; goog.provide('goog.dom');\");\n   }\n \n   public void testCssNameWiring() throws Exception {\n-    String prefix =\n-        \"var goog = {}; goog.getCssName = function() {};\" +\n-         \"goog.setCssNameMapping = function() {};\";\n-    test(prefix + \"goog.setCssNameMapping({'goog': 'a', 'button': 'b'});\" +\n+    test(\"var goog = {}; goog.getCssName = function() {};\" +\n+         \"goog.setCssNameMapping = function() {};\" +\n+         \"goog.setCssNameMapping({'goog': 'a', 'button': 'b'});\" +\n          \"var a = goog.getCssName('goog-button');\" +\n          \"var b = goog.getCssName('css-button');\" +\n          \"var c = goog.getCssName('goog-menu');\" +\n          \"var d = goog.getCssName('css-menu');\",\n-         prefix +\n-         \"var a = 'a-b',\" +\n+         \"var goog = { getCssName: function() {},\" +\n+         \"             setCssNameMapping: function() {} },\" +\n+         \"    a = 'a-b',\" +\n          \"    b = 'css-b',\" +\n          \"    c = 'a-menu',\" +\n          \"    d = 'css-menu';\");\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeCollectPropertyAssignmentsTest.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+public class PeepholeCollectPropertyAssignmentsTest extends CompilerTestCase {\n+\n+  @Override\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+    return new PeepholeOptimizationsPass(\n+        compiler, new PeepholeCollectPropertyAssignments());\n+  }\n+\n+  public final void testArrayOptimization() {\n+    test(\"var a = []; a[0] = 1; a[1] = 2; a[2] = 3;\",\n+         \"var a = [1, 2, 3];\");\n+  }\n+\n+  public final void testNegativeArrayIndex() {\n+    testSame(\"var a = []; a[-1] = 1;\");\n+  }\n+\n+  public final void testFractionalArrayIndex() {\n+    testSame(\"var a = []; a[0.5] = 1;\");\n+  }\n+\n+  public final void testArrayOptimizationOfPartiallyBuiltArray() {\n+    test(\"var a = [1, 2]; a[2] = 3;\",\n+         \"var a = [1, 2, 3];\");\n+  }\n+\n+  public final void testArrayOptimizationWithAHole() {\n+    test(\"var a = []; a[0] = 1; a[1] = 2; a[3] = 4;\",\n+         \"var a = [1, 2, , 4];\");\n+  }\n+\n+  public final void testEarlyUsage() {\n+    testSame(\n+        \"function c() {return sum(a)};\"\n+        + \"var a = [1,2,3];\"\n+        + \"a[4] = c();\");\n+  }\n+\n+  public final void testArrayTooSparseOptimization() {\n+    test(\"var a = []; a[0] = 1; a[1] = 2; a[100] = 4;\",\n+         \"var a = [1, 2]; a[100] = 4;\");\n+  }\n+\n+  public final void testMultipleNames() {\n+    test(\"var b = []; b[0] = 2; var a = []; a[0] = 1;\",\n+         \"var b = [2]; var a = [1];\");\n+  }\n+\n+  public final void testArrayReassignedInValue() {\n+    test(\"var a = []; a[0] = 1; a[1] = (a = []); a[3] = 4;\",\n+         \"var a = [1]; a[1] = (a = []); a[3] = 4;\");\n+  }\n+\n+  public final void testArrayReassignedInSubsequentVar() {\n+    testSame(\"var a = []; a[0] = a = []; a[1] = 2;\");\n+  }\n+\n+  public final void testForwardReference() {\n+    test(\"var a = []; a[0] = 1; a[1] = a;\",\n+         \"var a = [1]; a[1] = a;\");\n+  }\n+\n+  public final void testObjectOptimization() {\n+    test(\"var o = {}; o.x = 0; o['y'] = 1; o[2] = 2;\",\n+         \"var o = { x: 0, \\\"y\\\": 1, \\\"2\\\": 2 };\");\n+  }\n+\n+  public final void testObjectReassignedInValue() {\n+    test(\"var o = {}; o.x = 1; o.y = (o = {}); o.z = 4;\",\n+         \"var o = {x:1}; o.y = (o = {}); o.z = 4;\");\n+  }\n+\n+}\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n \n   private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n     String resultA = process(exprA);\n-    String resultB = process(exprB);\n+    String resultB = process(exprB);  // TODO: why is nothing done with this?\n     if (resultA.equals(print(exprA))) {\n       foldSame(exprA);\n       foldSame(exprB);", "timestamp": 1300821043, "metainfo": ""}