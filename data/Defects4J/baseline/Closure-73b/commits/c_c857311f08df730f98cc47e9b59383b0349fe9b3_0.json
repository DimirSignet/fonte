{"sha": "c857311f08df730f98cc47e9b59383b0349fe9b3", "log": "Allow the COMMA operator to be used to make a call to eval indirect.   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n \n     int pt = parent.getType();\n     if (pt == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.getType() == Token.CALL &&\n+          parent == gramps.getFirstChild()) {\n+        // Semantically, a direct call to eval is different from an indirect\n+        // call to an eval. See Ecma-262 S15.1.2.1. So it's ok for the first\n+        // expression to a comma to be a no-op if it's used to indirect\n+        // an eval.\n+        if (n == parent.getFirstChild() &&\n+            parent.getChildCount() == 2 &&\n+            n.getNext().getType() == Token.NAME &&\n+            \"eval\".equals(n.getNext().getString())) {\n+          return;\n+        }\n+      }\n+\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n--- a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java\n+++ b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java\n     test(\"function A() { /** This is a jsdoc comment */ this.foo; }\", ok);\n     test(\"function A() { /* This is a normal comment */ this.foo; }\", e);\n   }\n+\n+  public void testIssue80() {\n+    test(\"(0, eval)('alert');\", ok);\n+    test(\"(0, foo)('alert');\", e);\n+  }\n }", "timestamp": 1264636084, "metainfo": ""}