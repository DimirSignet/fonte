{"sha": "928d6655b9fb5183cb8058ef3c4c3da6ecabf1ba", "log": "Adds the ability to use Closure Compiler in Ant. Can also be used in other systems like Gradle, Buildr and Maven. It's not feature complete, but it's a start.  Contributed by stenrs  See issue 88    ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ant/AntErrorManager.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.ant;\n+\n+import com.google.javascript.jscomp.BasicErrorManager;\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.jscomp.MessageFormatter;\n+\n+import org.apache.tools.ant.Project;\n+import org.apache.tools.ant.Task;\n+\n+/**\n+ * An error manager that pipes warnings and errors properly into the Ant\n+ * task infrastructure.\n+*\n+ */\n+public final class AntErrorManager\n+    extends BasicErrorManager {\n+  private final MessageFormatter formatter;\n+  private final Task task;\n+\n+  public AntErrorManager(MessageFormatter formatter, Task task) {\n+    this.formatter = formatter;\n+    this.task = task;\n+  }\n+\n+  @Override\n+  public void println(CheckLevel level, JSError error) {\n+    switch (level) {\n+      case ERROR:\n+        this.task.log(error.format(level, this.formatter), Project.MSG_ERR);\n+        break;\n+      case WARNING:\n+        this.task.log(error.format(level, this.formatter), Project.MSG_WARN);\n+        break;\n+    }\n+  }\n+\n+  @Override\n+  protected void printSummary() {\n+    String message =\n+        getErrorCount() + \" error(s), \" + getWarningCount() + \" warning(s)\";\n+\n+    if (getTypedPercent() > 0.0) {\n+      message += \", \" + getTypedPercent() + \" typed\";\n+    }\n+\n+    int level = (getErrorCount() + getWarningCount() == 0) ?\n+        Project.MSG_INFO : Project.MSG_WARN;\n+    this.task.log(message, level);\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.ant;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.io.LimitInputStream;\n+import com.google.javascript.jscomp.CompilationLevel;\n+import com.google.javascript.jscomp.Compiler;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.CompilerRunner;\n+import com.google.javascript.jscomp.JSSourceFile;\n+import com.google.javascript.jscomp.MessageFormatter;\n+import com.google.javascript.jscomp.Result;\n+import com.google.javascript.jscomp.WarningLevel;\n+\n+import org.apache.tools.ant.BuildException;\n+import org.apache.tools.ant.Project;\n+import org.apache.tools.ant.Task;\n+import org.apache.tools.ant.types.FileList;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+\n+/**\n+ * This class implements a simple Ant task to do almost the same as\n+ * CompilerRunner.\n+ *\n+ * Most of the public methods of this class are entry points for the\n+ * Ant code to hook into.\n+ *\n+*\n+ */\n+public final class CompileTask\n+    extends Task {\n+  private WarningLevel warningLevel;\n+  private boolean debugOptions;\n+  private CompilationLevel compilationLevel;\n+  private boolean customExternsOnly;\n+  private File outputFile;\n+  private final List<FileList> externFileLists;\n+  private final List<FileList> sourceFileLists;\n+\n+  public CompileTask() {\n+    this.warningLevel = WarningLevel.DEFAULT;\n+    this.debugOptions = false;\n+    this.compilationLevel = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n+    this.customExternsOnly = false;\n+    this.externFileLists = Lists.newLinkedList();\n+    this.sourceFileLists = Lists.newLinkedList();\n+  }\n+\n+  /**\n+   * Set the warning level.\n+   * @param value The warning level by string name. (default, quiet, verbose).\n+   */\n+  public void setWarning(String value) {\n+    if (\"default\".equalsIgnoreCase(value)) {\n+      this.warningLevel = WarningLevel.DEFAULT;\n+    } else if (\"quiet\".equalsIgnoreCase(value)) {\n+      this.warningLevel = WarningLevel.QUIET;\n+    } else if (\"verbose\".equalsIgnoreCase(value)) {\n+      this.warningLevel = WarningLevel.VERBOSE;\n+    } else {\n+      throw new BuildException(\n+          \"Unrecognized 'warning' option value (\" + value + \")\");\n+    }\n+  }\n+\n+  /**\n+   * Enable debugging options.\n+   * @param value True if debug mode is enabled.\n+   */\n+  public void setDebug(boolean value) {\n+    this.debugOptions = value;\n+  }\n+\n+  /**\n+   * Set the compilation level.\n+   * @param value The optimization level by string name.\n+   *     (whitespace, simple, advanced).\n+   */\n+  public void setCompilationLevel(String value) {\n+    if (\"simple\".equalsIgnoreCase(value)) {\n+      this.compilationLevel = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n+    } else if (\"advanced\".equalsIgnoreCase(value)) {\n+      this.compilationLevel = CompilationLevel.ADVANCED_OPTIMIZATIONS;\n+    } else if (\"whitespace\".equalsIgnoreCase(value)) {\n+      this.compilationLevel = CompilationLevel.WHITESPACE_ONLY;\n+    } else {\n+      throw new BuildException(\n+          \"Unrecognized 'compilation' option value (\" + value + \")\");\n+    }\n+  }\n+\n+  /**\n+   * Use only custom externs.\n+   */\n+  public void setCustomExternsOnly(boolean value) {\n+    this.customExternsOnly = value;\n+  }\n+\n+  /**\n+   * Set output file.\n+   */\n+  public void setOutput(File value) {\n+    this.outputFile = value;\n+  }\n+\n+  /**\n+   * Sets the externs file.\n+   */\n+  public void addExterns(FileList list) {\n+    this.externFileLists.add(list);\n+  }\n+\n+  /**\n+   * Sets the source files.\n+   */\n+  public void addSources(FileList list) {\n+    this.sourceFileLists.add(list);\n+  }\n+\n+  public void execute() {\n+    if (this.outputFile == null) {\n+      throw new BuildException(\"outputFile attribute must be set\");\n+    }\n+\n+    Compiler.setLoggingLevel(Level.OFF);\n+\n+    CompilerOptions options = createCompilerOptions();\n+    Compiler compiler = createCompiler(options);\n+\n+    JSSourceFile[] externs = findExternFiles();\n+    JSSourceFile[] sources = findSourceFiles();\n+\n+    log(\"Compiling \" + sources.length + \" file(s) with \" +\n+        externs.length + \" extern(s)\");\n+\n+    Result result = compiler.compile(externs, sources, options);\n+    if (result.success) {\n+      writeResult(compiler.toSource());\n+    }\n+  }\n+\n+  private CompilerOptions createCompilerOptions() {\n+    CompilerOptions options = new CompilerOptions();\n+\n+    if (this.debugOptions) {\n+      this.compilationLevel.setDebugOptionsForCompilationLevel(options);\n+    } else {\n+      this.compilationLevel.setOptionsForCompilationLevel(options);\n+    }\n+\n+    this.warningLevel.setOptionsForWarningLevel(options);\n+    return options;\n+  }\n+\n+  private Compiler createCompiler(CompilerOptions options) {\n+    Compiler compiler = new Compiler();\n+    MessageFormatter formatter =\n+        options.errorFormat.toFormatter(compiler, false);\n+    AntErrorManager errorManager = new AntErrorManager(formatter, this);\n+    compiler.setErrorManager(errorManager);\n+    return compiler;\n+  }\n+\n+  private JSSourceFile[] findExternFiles() {\n+    List<JSSourceFile> files = Lists.newLinkedList();\n+    if (!this.customExternsOnly) {\n+      files.addAll(getDefaultExterns());\n+    }\n+\n+    for (FileList list : this.externFileLists) {\n+      files.addAll(findJavaScriptFiles(list));\n+    }\n+\n+    return files.toArray(new JSSourceFile[files.size()]);\n+  }\n+\n+  private JSSourceFile[] findSourceFiles() {\n+    List<JSSourceFile> files = Lists.newLinkedList();\n+\n+    for (FileList list : this.sourceFileLists) {\n+      files.addAll(findJavaScriptFiles(list));\n+    }\n+\n+    return files.toArray(new JSSourceFile[files.size()]);\n+  }\n+\n+  /**\n+   * Translates an Ant file list into the file format that the compiler\n+   * expects.\n+   */\n+  private List<JSSourceFile> findJavaScriptFiles(FileList fileList) {\n+    List<JSSourceFile> files = Lists.newLinkedList();\n+    File baseDir = fileList.getDir(getProject());\n+\n+    for (String included : fileList.getFiles(getProject())) {\n+      files.add(JSSourceFile.fromFile(new File(baseDir, included)));\n+    }\n+\n+    return files;\n+  }\n+\n+  /**\n+   * Gets the default externs set.\n+   *\n+   * Adapted from {@link CompilerRunner}.\n+   */\n+  private List<JSSourceFile> getDefaultExterns() {\n+    try {\n+      InputStream input = CompilerRunner.class.getResourceAsStream(\n+          \"/externs.zip\");\n+      ZipInputStream zip = new ZipInputStream(input);\n+      List<JSSourceFile> externs = Lists.newLinkedList();\n+\n+      for (ZipEntry entry; (entry = zip.getNextEntry()) != null; ) {\n+        LimitInputStream entryStream =\n+            new LimitInputStream(zip, entry.getSize());\n+        externs.add(\n+            JSSourceFile.fromInputStream(entry.getName(), entryStream));\n+      }\n+\n+      return externs;\n+    } catch (IOException e) {\n+      throw new BuildException(e);\n+    }\n+  }\n+\n+  private void writeResult(String source) {\n+    if (this.outputFile.getParentFile().mkdirs()) {\n+      log(\"Created missing parent directory \" +\n+          this.outputFile.getParentFile(), Project.MSG_DEBUG);\n+    }\n+\n+    try {\n+      FileWriter out = new FileWriter(this.outputFile);\n+      out.append(source);\n+      out.close();\n+    } catch (IOException e) {\n+      throw new BuildException(e);\n+    }\n+\n+    log(\"Compiled javascript written to \" + this.outputFile.getAbsolutePath(),\n+        Project.MSG_DEBUG);\n+  }\n+}", "timestamp": 1263443563, "metainfo": ""}