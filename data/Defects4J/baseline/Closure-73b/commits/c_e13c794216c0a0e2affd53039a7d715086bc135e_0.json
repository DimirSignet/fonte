{"sha": "e13c794216c0a0e2affd53039a7d715086bc135e", "log": "Automated g4 rollback.  *** Reason for rollback ***  The old algorithm takes 49324ms to finish in gmail. Now it takes 1281 ms. It used to take around 300-600ms without affinity.   *** Original change description ***  Automated g4 rollback.  *** Reason for rollback ***  Runs too slow.  *** Original change description ***  RenameProperties with affinity informations.  R=nicksantos DELTA=174  (152 added, 6 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1009   ", "commit": "\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n+import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n+import com.google.javascript.jscomp.graph.UndiGraph;\n+import com.google.javascript.jscomp.graph.UndiGraph.UndiGraphEdge;\n+import com.google.javascript.jscomp.graph.UndiGraph.UndiGraphNode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n \n import javax.annotation.Nullable;\n \n   private final Map<String, Property> propertyMap =\n       new HashMap<String, Property>();\n \n+  /**\n+   * A graph of property affinity information.\n+   *\n+   * Suppose property X and Y are access in the same function N times.\n+   *\n+   * The graph would have X -> Y with the edge of N.\n+   */\n+  private final UndiGraph<Property, PropertyAffinity> affinityGraph =\n+      LinkedUndirectedGraph.createWithoutAnnotations();\n+\n   // Property names that don't get renamed\n   private final Set<String> externedNames = new HashSet<String>(\n       Arrays.asList(\"prototype\"));\n   // Names to which properties shouldn't be renamed, to avoid name conflicts\n   private final Set<String> quotedNames = new HashSet<String>();\n \n-  /**\n-   * Sorts Property objects by their count, breaking ties alphabetically to\n-   * ensure a deterministic total ordering.\n-   */\n   private static final Comparator<Property> FREQUENCY_COMPARATOR =\n-      new Comparator<Property>() {\n-        public int compare(Property p1, Property p2) {\n-          if (p1.numOccurrences != p2.numOccurrences) {\n-            return p2.numOccurrences - p1.numOccurrences;\n-          }\n-          return p1.oldName.compareTo(p2.oldName);\n-        }\n-      };\n+    new Comparator<Property>() {\n+      public int compare(Property p1, Property p2) {\n+\n+        /**\n+         * First a frequently used names would always be picked first.\n+         */\n+        if (p1.numOccurrences != p2.numOccurrences) {\n+          return p2.numOccurrences - p1.numOccurrences;\n+\n+        /**\n+         * If both properties are used equally frequent. We'll let the property\n+         * with a high affinity score get a name first.\n+         *\n+         * see #computeAffinityScores() for how the score is computed.\n+         */\n+        } else if (p1.affinityScore != p2.affinityScore) {\n+          return p2.affinityScore - p1.affinityScore;\n+        }\n+\n+        /**\n+         * Finally, for determinism, we compare them based on the old name.\n+         */\n+        return p1.oldName.compareTo(p2.oldName);\n+       }\n+    };\n \n   /**\n    * The name of a special function that this pass replaces. It takes one\n     }\n \n     compiler.addToDebugLog(\"JS property assignments:\");\n+    computeAffinityScores();\n \n     // Assign names, sorted by descending frequency to minimize code size.\n     Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n   }\n \n   /**\n+   * A X property gets an affinity score:\n+   *\n+   * score = sum (# of times X appears Y * frequency(Y)) for all Y where\n+   *   frequency(Y) > frequency (X).\n+   *\n+   * This way a property would have a name closer to all high frequency names.\n+   * Also two property of the same frequency would have very close names if\n+   * they always appear together.\n+   */\n+  private void computeAffinityScores() {\n+    for (Property p : propertyMap.values()) {\n+      UndiGraphNode<Property, PropertyAffinity> node =\n+          affinityGraph.getUndirectedGraphNode(p);\n+\n+      int affinityScore = 0;\n+      for (Iterator<UndiGraphEdge<Property, PropertyAffinity>> edgeIterator =\n+          node.getNeighborEdgesIterator(); edgeIterator.hasNext();) {\n+        UndiGraphEdge<Property,PropertyAffinity> edge = edgeIterator.next();\n+        affinityScore += edge.getValue().affinity +\n+            (node == edge.getNodeA() ?\n+                edge.getNodeB().getValue().numOccurrences :\n+                edge.getNodeA().getValue().numOccurrences);\n+      }\n+      node.getValue().affinityScore = affinityScore;\n+    }\n+  }\n+\n+  /**\n    * Generates new names for properties.\n    *\n    * @param props Properties to generate new names for\n           p.newName = nameGen.generateNextName();\n         }\n       }\n-\n       reservedNames.add(p.newName);\n-\n       compiler.addToDebugLog(p.oldName + \" => \" + p.newName);\n     }\n   }\n     }\n   }\n \n+\n   // -------------------------------------------------------------------------\n \n   /**\n    * A traversal callback that collects property names and counts how\n    * frequently each property name occurs.\n    */\n-  private class ProcessProperties extends AbstractPostOrderCallback {\n+  private class ProcessProperties extends AbstractPostOrderCallback implements\n+      ScopedCallback {\n+\n+    private Set<Property> currentHighAffinityProperties = null;\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (prop == null) {\n         prop = new Property(name);\n         propertyMap.put(name, prop);\n+        affinityGraph.createNode(prop);\n       }\n       prop.numOccurrences++;\n+      if (currentHighAffinityProperties != null) {\n+        currentHighAffinityProperties.add(prop);\n+      }\n+    }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) {\n+        currentHighAffinityProperties = Sets.newHashSet();\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+      if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) {\n+        for (Property p1 : currentHighAffinityProperties) {\n+          for (Property p2 : currentHighAffinityProperties) {\n+            if (p1.oldName.compareTo(p2.oldName) < 0) {\n+              GraphEdge<Property,PropertyAffinity> edge =\n+                  affinityGraph.getFirstEdge(p1, p2);\n+              if (edge == null) {\n+                affinityGraph.connect(p1, new PropertyAffinity(1), p2);\n+              } else {\n+                edge.getValue().increase();\n+              }\n+            }\n+          }\n+        }\n+        currentHighAffinityProperties = null;\n+      }\n     }\n   }\n \n     final String oldName;\n     String newName;\n     int numOccurrences;\n+    int affinityScore = 0;\n \n     Property(String name) {\n       this.oldName = name;\n     }\n   }\n+\n+  private class PropertyAffinity {\n+    private int affinity = 0;\n+\n+    private PropertyAffinity(int affinity) {\n+      this.affinity = affinity;\n+    }\n+\n+    private void increase() {\n+      affinity++;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n+import com.google.javascript.jscomp.graph.UndiGraph.UndiGraphEdge;\n \n import java.util.Collection;\n import java.util.Collections;\n       return neighborList;\n     }\n \n+    public Iterator<UndiGraphEdge<N, E>> getNeighborEdgesIterator() {\n+      return neighborList.iterator();\n+    }\n+\n     @Override\n     public <A extends Annotation> A getAnnotation() {\n       throw new UnsupportedOperationException(\n--- a/src/com/google/javascript/jscomp/graph/UndiGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/UndiGraph.java\n package com.google.javascript.jscomp.graph;\n \n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n \n /**\n \n   abstract UndiGraphNode<N, E> createUndirectedGraphNode(N nodeValue);\n \n-  abstract UndiGraphNode<N, E> getUndirectedGraphNode(N nodeValue);\n+  public abstract UndiGraphNode<N, E> getUndirectedGraphNode(N nodeValue);\n \n   abstract List<UndiGraphEdge<N, E>> getUndirectedGraphEdges(N n1, N n2);\n \n    * @param <E> Value type that the graph edge stores.\n    */\n   public static interface UndiGraphNode<N, E> extends GraphNode<N, E> {\n-    List<UndiGraphEdge<N, E>> getNeighborEdges();\n+    public List<UndiGraphEdge<N, E>> getNeighborEdges();\n+    public Iterator<UndiGraphEdge<N, E>> getNeighborEdgesIterator();\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n                  compiler.toSource(module3));\n   }\n \n+  public void testPropertyAffinity() {\n+    // 'y' gets to be 'b' because it appears with z often.\n+    // Other wise, 'x' gets to be 'b' because of alphabetical ordering.\n+\n+    test(\"var foo={};foo.x=1;foo.y=2;foo.z=3;\" +\n+         \"function f1() { foo.z; foo.z; foo.z; foo.y}\" +\n+         \"function f2() {                      foo.x}\",\n+\n+\n+         \"var foo={};foo.c=1;foo.b=2;foo.a=3;\" +\n+         \"function f1() { foo.a; foo.a; foo.a; foo.b}\" +\n+         \"function f2() {                      foo.c}\");\n+\n+    test(\"var foo={};foo.x=1;foo.y=2;foo.z=3;\" +\n+        \"function f1() { foo.z; foo.z; foo.z; foo.y}\" +\n+        \"function f2() { foo.z; foo.z; foo.z; foo.x}\",\n+\n+\n+        \"var foo={};foo.b=1;foo.c=2;foo.a=3;\" +\n+        \"function f1() { foo.a; foo.a; foo.a; foo.c}\" +\n+        \"function f2() { foo.a; foo.a; foo.a; foo.b}\");\n+  }\n+\n   public void testPrototypePropertiesStable() {\n     testStableRenaming(\n         \"Bar.prototype.getA = function(){}; bar.getA();\" +", "timestamp": 1300909202, "metainfo": ""}