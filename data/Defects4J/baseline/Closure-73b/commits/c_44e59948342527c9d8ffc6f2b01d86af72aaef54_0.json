{"sha": "44e59948342527c9d8ffc6f2b01d86af72aaef54", "log": "Experimental initial module specialization.  This optimization replaces functions in the initial module with specialized versions that are only safe in the initial module. The original, general, versions of the functions are \"fixed up\" in later modules. This optimization can shrink the initial module significantly but the fixup code in later modules increases overall code size.  See SpecializeModule.java for more details.  This change modifies three existing passes: DevirtualizePrototyMethods, InlineFunctions, and RemoveUnusedPrototypeProperties, to be specialization-aware. When running under specialization, these modules now ask before modifying or removing a function and report what functions they have modified or removed.  Files meriting extra scrutiny: - DevirtualizePrototypeMethods.java - RemoveUnusedPrototypeProperties.java - InlineFunctions.java - DefaultPassConfig.java  R=acleung DELTA=1820  (1810 added, 0 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=103003   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n   /**\n    * A function initialized as a VAR statement or a function declaration.\n    */\n-  private class GlobalFunction implements Symbol {\n+   class GlobalFunction implements Symbol {\n     private final Node nameNode;\n     private final JSModule module;\n \n     public JSModule getModule() {\n       return module;\n     }\n+\n+    public Node getFunctionNode() {\n+      Node parent = nameNode.getParent();\n+\n+      if (NodeUtil.isFunction(parent)) {\n+        return parent;\n+      } else {\n+        // we are the name of a var node, so the function is name's second child\n+        return nameNode.getChildAtIndex(1);\n+      }\n+    }\n   }\n \n   /**\n    * <pre>function Foo() { ... };\n    * Foo.prototype.bar = function() { ... };</pre>\n    */\n-  private static class AssignmentProperty implements Property {\n+  static class AssignmentProperty implements Property {\n     private final Node node;\n     private final JSModule module;\n \n    * <pre>function Foo() { ... };\n    * Foo.prototype = {bar: function() { ... };</pre>\n    */\n-  private static class LiteralProperty implements Property {\n+  static class LiteralProperty implements Property {\n     private final Node key;\n     private final Node value;\n     private final Node map;\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Whether to export test functions. */\n   public boolean exportTestFunctions;\n+\n+  /** Specialize the initial module at the cost of later modules */\n+  public boolean specializeInitialModule;\n \n   //--------------------------------\n   // Special-purpose alterations\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n     passes.add(createEmptyPass(\"beforeMainOptimizations\"));\n \n+    if (options.specializeInitialModule) {\n+      // When specializing the initial module, we want our fixups to be\n+      // as lean as possible, so we run the entire optimization loop to a\n+      // fixed point before specializing, then specialize, and then run the\n+      // main optimization loop again.\n+\n+      passes.addAll(getMainOptimizationLoop());\n+\n+      if (options.crossModuleCodeMotion) {\n+        passes.add(crossModuleCodeMotion);\n+      }\n+\n+      if (options.crossModuleMethodMotion) {\n+        passes.add(crossModuleMethodMotion);\n+      }\n+\n+      passes.add(specializeInitialModule.makeOneTimePass());\n+    }\n+\n     passes.addAll(getMainOptimizationLoop());\n \n     passes.add(createEmptyPass(\"beforeModuleMotion\"));\n           // Only move properties in externs if we're not treating\n           // them as exports.\n           options.removeUnusedPrototypePropertiesInExterns);\n+    }\n+  };\n+\n+  /**\n+   * Specialize the initial module at the cost of later modules\n+   */\n+  private PassFactory specializeInitialModule =\n+      new PassFactory(\"specializeInitialModule\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new SpecializeModule(compiler, devirtualizePrototypeMethods,\n+          inlineFunctions, removeUnusedPrototypeProperties);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n  *\n  *\n  */\n-class DevirtualizePrototypeMethods implements CompilerPass {\n+class DevirtualizePrototypeMethods implements SpecializationAwareCompilerPass {\n   private final AbstractCompiler compiler;\n+  private SpecializeModule.SpecializationState specializationState;\n \n   DevirtualizePrototypeMethods(AbstractCompiler compiler) {\n     this.compiler = compiler;\n+  }\n+\n+  public void enableSpecialization(SpecializeModule.SpecializationState state) {\n+    this.specializationState = state;\n   }\n \n   @Override\n \n       // Multiple definitions prevent rewrite.\n       Node nameNode = site.node;\n+\n+      // Don't rewrite methods called in functions that can't be specialized\n+      // if we are specializing\n+      if (specializationState != null &&\n+          !specializationState.canFixupSpecializedFunctionContainingNode(\n+              nameNode)) {\n+        return false;\n+      }\n+\n       Collection<Definition> singleSiteDefinitions =\n           defFinder.getDefinitionsReferencedAt(nameNode);\n       if (singleSiteDefinitions.size() > 1) {\n           Node.newString(Token.NAME, newMethodName)\n               .copyInformationFrom(node));\n       compiler.reportCodeChange();\n+\n+      if (specializationState != null) {\n+        specializationState.reportSpecializedFunctionContainingNode(parent);\n+      }\n     }\n   }\n \n \n     Node newNameNode = Node.newString(Token.NAME, newMethodName)\n         .copyInformationFrom(parent.getFirstChild());\n+\n+    if (specializationState != null) {\n+      specializationState.reportRemovedFunction(functionNode);\n+    }\n+\n     parent.removeChild(functionNode);\n     newNameNode.addChildToFront(functionNode);\n     block.replaceChild(expr, new Node(Token.VAR, newNameNode));\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n  *\n  * @author johnlenz@google.com (John Lenz)\n  */\n-class InlineFunctions implements CompilerPass {\n+class InlineFunctions implements SpecializationAwareCompilerPass {\n \n   // TODO(nicksantos): This needs to be completely rewritten to use scopes\n   // to do variable lookups. Right now, it assumes that all functions are\n   private final boolean blockFunctionInliningEnabled;\n   private final boolean inlineGlobalFunctions;\n   private final boolean inlineLocalFunctions;\n+\n+  private SpecializeModule.SpecializationState specializationState;\n \n   InlineFunctions(AbstractCompiler compiler,\n       Supplier<String> safeNameIdSupplier,\n       fns.put(fnName, fs);\n     }\n     return fs;\n+  }\n+\n+  public void enableSpecialization(SpecializeModule.SpecializationState\n+      specializationState) {\n+    this.specializationState = specializationState;\n   }\n \n   @Override\n   }\n \n   /**\n+   * Returns the function the traversal is currently traversing, or null\n+   * if in the global scope.\n+   */\n+  private Node getContainingFunction(NodeTraversal t) {\n+    return (t.inGlobalScope()) ? null : t.getScopeRoot();\n+  }\n+\n+  /**\n    * Checks if the given function matches the criteria for an inlinable\n    * function.\n    */\n \n     // Don't inline this special function\n     if (RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(fnName)) {\n+      return false;\n+    }\n+\n+    // Don't inline if we are specializing and the function can't be fixed up\n+    if (specializationState != null &&\n+        !specializationState.canFixupFunction(fn.getFunctionNode())) {\n       return false;\n     }\n \n     private boolean maybeAddReferenceUsingMode(\n         NodeTraversal t, FunctionState fs, Node callNode,\n         JSModule module, InliningMode mode) {\n+\n+      if (specializationState != null) {\n+        // If we're specializing, make sure we can fixup\n+        // the containing function before inlining\n+        Node containingFunction = getContainingFunction(t);\n+        if (containingFunction != null && !specializationState.canFixupFunction(\n+            containingFunction)) {\n+            return false;\n+        }\n+      }\n+\n       CanInlineResult result = injector.canInlineReferenceToFunction(\n           t, callNode, fs.getFn().getFunctionNode(),\n           fs.getNamesToAlias(), mode, fs.getReferencesThis(),\n   /**\n    * Inline functions at the call sites.\n    */\n-  private static class Inline implements CallVisitorCallback {\n+  private class Inline implements CallVisitorCallback {\n     private final FunctionInjector injector;\n \n     Inline(FunctionInjector injector) {\n         // or if the call site was trimmed from the list of references because\n         // the function couldn't be inlined at this location.\n         if (ref != null) {\n+          if (specializationState != null) {\n+            Node containingFunction = getContainingFunction(t);\n+\n+            if (containingFunction != null) {\n+              // Report that the function was specialized so that\n+              // {@link SpecializeModule} can fix it up.\n+              specializationState.reportSpecializedFunction(containingFunction);\n+            }\n+          }\n+\n           inlineFunction(t, callNode, fs, ref.mode);\n           // Keep track of references that have been inlined so that\n           // we can verify that none have been missed.\n         Preconditions.checkState(fs.canInline());\n         Preconditions.checkState(fn != null);\n         verifyAllReferencesInlined(fs);\n+\n+        if (specializationState != null) {\n+          specializationState.reportRemovedFunction(fn.getFunctionNode());\n+        }\n+\n         fn.remove();\n         compiler.reportCodeChange();\n       }\n--- a/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.AnalyzePrototypeProperties.AssignmentProperty;\n+import com.google.javascript.jscomp.AnalyzePrototypeProperties.GlobalFunction;\n+import com.google.javascript.jscomp.AnalyzePrototypeProperties.LiteralProperty;\n import com.google.javascript.jscomp.AnalyzePrototypeProperties.NameInfo;\n import com.google.javascript.jscomp.AnalyzePrototypeProperties.Symbol;\n import com.google.javascript.rhino.Node;\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-class RemoveUnusedPrototypeProperties implements CompilerPass {\n+class RemoveUnusedPrototypeProperties implements\n+    SpecializationAwareCompilerPass {\n \n   private static final Logger logger =\n     Logger.getLogger(RemoveUnusedPrototypeProperties.class.getName());\n   private final AbstractCompiler compiler;\n   private final boolean canModifyExterns;\n   private final boolean anchorUnusedVars;\n+  private SpecializeModule.SpecializationState specializationState;\n \n   /**\n    * Creates a new pass for removing unused prototype properties, based\n    *     never used.\n    */\n   RemoveUnusedPrototypeProperties(AbstractCompiler compiler,\n-      boolean canModifyExterns, boolean anchorUnusedVars) {\n+      boolean canModifyExterns,\n+      boolean anchorUnusedVars) {\n     this.compiler = compiler;\n     this.canModifyExterns = canModifyExterns;\n     this.anchorUnusedVars = anchorUnusedVars;\n   }\n \n+  public void enableSpecialization(SpecializeModule.SpecializationState state) {\n+    this.specializationState = state;\n+  }\n+\n+  @Override\n   public void process(Node externRoot, Node root) {\n     AnalyzePrototypeProperties analyzer =\n         new AnalyzePrototypeProperties(compiler,\n     for (NameInfo nameInfo : allNameInfo) {\n       if (!nameInfo.isReferenced()) {\n         for (Symbol declaration : nameInfo.getDeclarations()) {\n-          declaration.remove();\n-          changed = true;\n+          boolean canRemove = false;\n+\n+          if (specializationState == null) {\n+            canRemove = true;\n+          } else {\n+            Node specializableFunction =\n+              getSpecializableFunctionFromSymbol(declaration);\n+\n+            if (specializableFunction != null) {\n+              specializationState.reportRemovedFunction(specializableFunction);\n+              canRemove = true;\n+            }\n+          }\n+\n+          if (canRemove) {\n+            declaration.remove();\n+            changed = true;\n+          }\n         }\n \n         logger.fine(\"Removed unused prototype property: \" + nameInfo.name);\n       compiler.reportCodeChange();\n     }\n   }\n+\n+  /**\n+   * Attempts to find a specializable function from the Symbol.\n+   */\n+  private Node getSpecializableFunctionFromSymbol(Symbol symbol) {\n+    Preconditions.checkNotNull(specializationState);\n+\n+    Node specializableFunction = null;\n+\n+    if (symbol instanceof GlobalFunction) {\n+      specializableFunction = ((GlobalFunction) symbol).getFunctionNode();\n+    } else if (symbol instanceof AssignmentProperty) {\n+      Node propertyValue = ((AssignmentProperty) symbol).getValue();\n+      if (NodeUtil.isFunction(propertyValue)) {\n+        specializableFunction = propertyValue;\n+      }\n+    } else if (symbol instanceof LiteralProperty) {\n+      // Module specialization doesn't know how to handle these\n+      // because the \"name\" of the function isn't the name\n+      // it needs to add an unspecialized version of.\n+\n+      return null;\n+    } else {\n+      Preconditions.checkState(false, \"Should be unreachable.\");\n+    }\n+\n+    if (specializableFunction != null &&\n+        specializationState.canFixupFunction(specializableFunction)) {\n+      return specializableFunction;\n+    } else {\n+      return null;\n+    }\n+  }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Set;\n+\n+/**\n+ * Uses {@link SimpleDefinitionFinder} to determine if a function has been\n+ * aliased or exposed to .call() or .apply().\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+class SimpleFunctionAliasAnalysis {\n+  private Set<Node> aliasedFunctions;\n+  \n+  private Set<Node> functionsExposedToCallOrApply;\n+  \n+  /**\n+   * Returns true if the function is aliased.\n+   * \n+   * Must only be called after {@link #analyze(SimpleDefinitionFinder)}\n+   * has been called.\n+   */\n+  public boolean isAliased(Node functionNode) {\n+    Preconditions.checkNotNull(aliasedFunctions);\n+    Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n+    \n+    return aliasedFunctions.contains(functionNode);\n+  }\n+  \n+  /**\n+   * Returns true if the function ever exposed to .call() or .apply().\n+   * \n+   * Must only be called after {@link #analyze(SimpleDefinitionFinder)}\n+   * has been called.\n+   */\n+  public boolean isExposedToCallOrApply(Node functionNode) {\n+    Preconditions.checkNotNull(functionsExposedToCallOrApply);\n+    Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n+    \n+    return functionsExposedToCallOrApply.contains(functionNode);\n+  }\n+  \n+  /**\n+   * Uses the provided {@link SimpleDefinitionFinder} to determine\n+   * which functions are aliased or exposed to .call() or .apply().\n+   */\n+  public void analyze(SimpleDefinitionFinder finder) {\n+    Preconditions.checkState(aliasedFunctions == null);\n+    \n+    aliasedFunctions = Sets.newHashSet();\n+    functionsExposedToCallOrApply = Sets.newHashSet();\n+    \n+    for (DefinitionSite definitionSite : finder.getDefinitionSites()) {\n+      Definition definition = definitionSite.definition;\n+      \n+      if (!definition.isExtern()) {\n+        Node rValue = definition.getRValue();\n+        \n+        if (rValue != null && NodeUtil.isFunction(rValue)) {\n+          // rValue is a Token.FUNCTION from a definition\n+          \n+          for (UseSite useSite : finder.getUseSites(definition)) {\n+            updateFunctionForUse(rValue, useSite.node);\n+          }          \n+        }     \n+      }\n+    }   \n+  }\n+  \n+  /**\n+   * Updates alias and exposure information based a site where the function is\n+   * used.\n+   * \n+   * Note: this method may be called multiple times per Function, each time\n+   * with a different useNode.\n+   */\n+  private void updateFunctionForUse(Node function, Node useNode) {\n+    Node useParent = useNode.getParent();\n+    int parentType = useParent.getType();\n+    \n+    if ((parentType == Token.CALL || parentType == Token.NEW)\n+        && useParent.getFirstChild() == useNode) {\n+      // Regular call sites don't count as aliases\n+    } else if (NodeUtil.isGet(useParent)) {\n+      // GET{PROP,ELEM} don't count as aliases\n+      // but we have to check for using them in .call and .apply.\n+      \n+      if (NodeUtil.isGetProp(useParent)) {\n+        Node gramps = useParent.getParent();\n+        if (NodeUtil.isFunctionObjectApply(gramps) ||\n+            NodeUtil.isFunctionObjectCall(gramps)) {\n+          functionsExposedToCallOrApply.add(function);\n+        }\n+      }\n+    } else {\n+      aliasedFunctions.add(function);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/SpecializationAwareCompilerPass.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Interface indicating a CompilerPass is specialization aware.\n+ * \n+ * See {@link SpecializeModule} for details of module specialization.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ *\n+ */\n+interface SpecializationAwareCompilerPass extends CompilerPass {\n+  public void enableSpecialization(SpecializeModule.SpecializationState state);\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Beginnings of an optimization to specialize the initial module at the cost of\n+ * increasing code in later modules. This is still very experimental.\n+ * \n+ * High-level overview:\n+ *  \n+ * This optimization replaces functions in the initial module with specialized\n+ * versions that are only safe in the initial module. The original, general,\n+ * versions of the functions are \"fixed up\" in later modules. This optimization\n+ * can shrink the initial module significantly but the fixup code in later\n+ * modules increases overall code size.\n+ * \n+ * Implementation approach:\n+ * \n+ * We take a ridiculously naive approach: remove the initial module\n+ * from the rest of the AST, optimize it with existing optimization passes\n+ * (recording which functions have been specialized), put it back in the AST, \n+ * and add fixups restoring the general versions of the functions in each module\n+ * that depends on the initial module.\n+ * \n+ * Since it is only safe to specialize functions that can be fixed up, we\n+ * don't allow specialization of local functions and functions that\n+ * are aliased.\n+ * \n+ * We currently run three optimizations on the isolated AST: InlineFunctions,\n+ * DevirtualizePrototypeMethods, and RemoveUnusedPrototypeProperties.\n+ * \n+ * These optimizations rely on a coarse-grained name-based analysis to\n+ * maintain safety properties and thus are likely to see some benefit when\n+ * applied in isolation.\n+ * \n+ * InlineFunctions is truly specializing -- it replaces functions with\n+ * versions that have calls to other functions inlined into them, while\n+ * RemoveUnusedPrototypeProperties is really just removing properties that\n+ * aren't used in the initial module and adding copies further down in the\n+ * module graph. It would probably be more elegant to give\n+ * CrossModuleMethodMotion permission to make copies of methods instead.\n+ * \n+ * There are additional passes that might benefit from being made\n+ * specialization-aware:\n+ * \n+ * - OptimizeParameters \n+ * \n+ * - Any pass that is too slow to run over the entire AST but might\n+ *      be acceptable on only the initial module:\n+ *  - RemoveUnusedNames\n+ *  \n+ *  - Also, any pass that uses the results of PureFunctionIdentifier to\n+ *  determine when it is safe to remove code might benefit (e.g. the peephole\n+ *  passes), since PureFunctionIdentifier relies on SimpleDefinitionFinder,\n+ *  which would be more precise when running on only the initial module.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class SpecializeModule implements CompilerPass {\n+  private AbstractCompiler compiler;\n+  \n+  private Map<Node, Node> specializedInputRootsByOriginal;\n+  \n+  private Map<Node, OriginalFunctionInformation>\n+      functionInfoBySpecializedFunctionNode;\n+  \n+  private SpecializationState specializationState;\n+  \n+  private final PassFactory[] specializationPassFactories;\n+  \n+  public SpecializeModule(AbstractCompiler compiler,\n+      PassFactory ...specializationPassFactories) {\n+    this.compiler = compiler;\n+    this.specializationPassFactories = specializationPassFactories;\n+  }\n+  \n+  /**\n+   * Performs initial module specialization.\n+   * \n+   * The process is as follows:\n+   * \n+   * 1) Make a copy of each of the inputs in the initial root and put them\n+   * in a fake AST that looks like it is the whole program.\n+   * \n+   * 2) Run the specializing compiler passes over the fake initial module AST\n+   * until it reaches a fixed point, recording which functions are specialized\n+   * or removed.\n+   * \n+   * 3) Replace the original input roots with the specialized input roots\n+   * \n+   * 4) For each module that directly depends on the initial module, add\n+   * fixups for the specialized and removed functions. Right now we add\n+   * fixups for for every function that was specialzed or removed -- we could\n+   * be smarter about this and for each dependent module only add the functions\n+   * that it needs.\n+   * \n+   * 5) Add dummy variables declaring the removed function to the end of\n+   * the now-specialized initial module. This is needed to keep\n+   * {@link VarCheck} from complaining.\n+   */\n+  @Override\n+  public void process(Node externs, Node root) {\n+    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n+    \n+    // Can't perform optimization without a module graph!\n+    if (moduleGraph == null) {\n+      return;\n+    }\n+    \n+    JSModule module = moduleGraph.getRootModule();\n+      \n+    Node fakeModuleRoot = copyModuleInputs(module);\n+    \n+    SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n+    \n+    defFinder.process(externs, fakeModuleRoot);\n+    \n+    SimpleFunctionAliasAnalysis initialModuleFunctionAliasAnalysis = \n+        new SimpleFunctionAliasAnalysis();\n+    \n+    initialModuleFunctionAliasAnalysis.analyze(defFinder); \n+    \n+    specializationState =\n+        new SpecializationState(initialModuleFunctionAliasAnalysis);\n+    \n+    do {\n+      specializationState.resetHasChanged();\n+         \n+      for (SpecializationAwareCompilerPass pass : createSpecializingPasses()) {\n+        pass.enableSpecialization(specializationState);\n+        pass.process(externs, fakeModuleRoot);\n+      }\n+    } while(specializationState.hasChanged()); \n+    \n+    replaceOriginalModuleInputsWithSpecialized();    \n+    addDummyVarDeclarationsToInitialModule(module);  \n+    addOriginalFunctionVersionsToDependentModules(module);   \n+  }\n+  \n+  /**\n+   * Returns a collection of new instances of specializing passes.\n+   */\n+  private Collection<SpecializationAwareCompilerPass> \n+      createSpecializingPasses() {\n+    \n+    Collection<SpecializationAwareCompilerPass> passes = Lists.newLinkedList();\n+    \n+    for (PassFactory passFactory : specializationPassFactories) {\n+      CompilerPass pass = passFactory.createInternal(compiler);\n+      \n+      Preconditions.checkState(pass instanceof \n+          SpecializationAwareCompilerPass);\n+      \n+      passes.add((SpecializationAwareCompilerPass) pass);\n+    }\n+    \n+    return passes;\n+  }\n+  \n+  /**\n+   * Creates an AST that consists solely of copies of the input roots for the\n+   * passed in module.\n+   * \n+   * Also records a map in {@link #functionInfoBySpecializedFunctionNode}\n+   * of information about the original function keyed on the copies of the\n+   * functions to specialized.\n+   */\n+  private Node copyModuleInputs(JSModule module) {\n+    \n+    specializedInputRootsByOriginal = Maps.newLinkedHashMap();\n+    \n+    functionInfoBySpecializedFunctionNode = Maps.newLinkedHashMap();\n+    \n+    Node syntheticModuleJsRoot = new Node(Token.BLOCK);\n+    syntheticModuleJsRoot.setIsSyntheticBlock(true);\n+    \n+    for (CompilerInput input : module.getInputs()) {\n+      Node originalInputRoot = input.getAstRoot(compiler);\n+      \n+      Node copiedInputRoot = originalInputRoot.cloneTree();\n+      copiedInputRoot.copyInformationFromForTree(originalInputRoot);\n+      \n+      specializedInputRootsByOriginal.put(originalInputRoot,\n+          copiedInputRoot);\n+      \n+      matchTopLevelFunctions(originalInputRoot, copiedInputRoot);\n+      \n+      syntheticModuleJsRoot.addChildToBack(copiedInputRoot);\n+    }\n+    \n+    // The jsRoot needs a parent (in a normal compilation this would be the\n+    // node that contains jsRoot and the externs).\n+    Node syntheticExternsAndJsRoot = new Node(Token.BLOCK);\n+    syntheticExternsAndJsRoot.addChildToBack(syntheticModuleJsRoot);\n+    \n+    return syntheticModuleJsRoot;\n+  }\n+  \n+  /**\n+   * Records information about original functions and creates a map from\n+   * the specialized functions to this information.\n+   * \n+   * This information is only recorded for global functions since non-global\n+   * functions cannot be inlined.\n+   * \n+   * @param original An original input root.\n+   * @param toBeSpecialized A copy of the input root (the copy to be \n+   * specialized)\n+   */\n+  private void matchTopLevelFunctions(Node original, Node toBeSpecialized) {  \n+    new NodeMatcher() {   \n+      @Override\n+      public void reportMatch(Node original, Node specialized) {\n+        if (NodeUtil.isFunction(original)) {\n+          OriginalFunctionInformation functionInfo = \n+              new OriginalFunctionInformation(original);\n+         \n+          functionInfoBySpecializedFunctionNode.put(specialized,\n+              functionInfo);\n+        }       \n+      }\n+      \n+      @Override\n+      public boolean shouldTraverse(Node n1, Node n2) {\n+        return !NodeUtil.isFunction(n1);\n+      }\n+    }.match(original, toBeSpecialized);\n+  }\n+  \n+  /**\n+   * Replaces the original input roots of the initial module with\n+   * their specialized versions.\n+   * \n+   * (Since {@link JsAst} holds a pointer to original inputs roots, we actually\n+   * replace the all the children of the root rather than swapping the\n+   * root pointers).\n+   */\n+  private void replaceOriginalModuleInputsWithSpecialized() {\n+    for (Node original : specializedInputRootsByOriginal.keySet()) {\n+      Node specialized = specializedInputRootsByOriginal.get(original);\n+      \n+      original.removeChildren();\n+      \n+      List<Node> specializedChildren = Lists.newLinkedList();\n+      \n+      while (specialized.getFirstChild() != null) {\n+        original.addChildToBack(specialized.removeFirstChild());\n+      }\n+    }\n+  }\n+  \n+  /**\n+   * Adds dummy variable declarations for all the function declarations we've \n+   * removed to the end of the initial module.\n+   * \n+   * We do this to make {@link VarCheck} happy, since it requires variables to\n+   * be declared before they are used in the whole program AST and doesn't\n+   * like it when they are declared multiple times.\n+   * \n+   * TODO(dcc): Be smarter about whether we need a VAR here or not.\n+   */\n+  private void addDummyVarDeclarationsToInitialModule(JSModule module) {    \n+    CompilerInput lastInputInFirstModule =\n+        module.getInputs().get(module.getInputs().size() - 1);\n+    \n+    Node dummyVarParent = lastInputInFirstModule.getAstRoot(compiler);\n+       \n+    for (Node modifiedFunction : functionInfoBySpecializedFunctionNode.keySet())\n+        {      \n+     if (specializationState.getRemovedFunctions().contains(modifiedFunction)) {\n+       OriginalFunctionInformation originalInfo =\n+         functionInfoBySpecializedFunctionNode.get(modifiedFunction);\n+       \n+       if (originalInfo.name != null && originalInfo.originalWasDeclaration()) {\n+         dummyVarParent.addChildToBack(originalInfo.generateDummyDeclaration());\n+       }     \n+     }\n+    }\n+  }\n+  \n+  /**\n+   * Adds a copy of the original versions of specialized/removed functions\n+   * to each of the dependents of module.\n+   * \n+   * Currently we add all of these functions to all dependents; it\n+   * would be more efficient to only add the functions that could be used.\n+   * \n+   * TODO(dcc): Only add fixup functions where needed.\n+   */\n+  private void addOriginalFunctionVersionsToDependentModules(JSModule module) {\n+    for (JSModule directDependent : getDirectDependents(module)) {\n+      CompilerInput firstInput = directDependent.getInputs().get(0);\n+      Node firstInputRootNode = firstInput.getAstRoot(compiler);\n+      \n+      // We don't iterate specializedFunctions directly because want to maintain\n+      // and specializedFunctions in source order, rather than\n+      // in the order that some optimization specialized the function.\n+      \n+      // So since we're adding to the front of the module each time, we\n+      // have to iterate in reverse source order.\n+      \n+      List<Node> possiblyModifiedFunctions =\n+        Lists.newArrayList(functionInfoBySpecializedFunctionNode.keySet());\n+      \n+      Collections.reverse(possiblyModifiedFunctions);\n+      \n+      for (Node modifiedFunction : possiblyModifiedFunctions) {   \n+        boolean declarationWasSpecialized =\n+          specializationState.getSpecializedFunctions()\n+          .contains(modifiedFunction);\n+        \n+        boolean declarationWasRemoved = \n+            specializationState.getRemovedFunctions()\n+            .contains(modifiedFunction);\n+        \n+        if (declarationWasSpecialized || declarationWasRemoved) {\n+          OriginalFunctionInformation originalInfo =\n+               functionInfoBySpecializedFunctionNode.get(modifiedFunction);\n+           \n+           // Don't add unspecialized versions of anonymous functions\n+           if (originalInfo.name != null) {\n+             Node newDefinition = \n+               originalInfo.generateFixupDefinition();\n+             \n+             firstInputRootNode.addChildrenToFront(newDefinition);\n+           }         \n+        }       \n+      }\n+    }\n+  }\n+  \n+  /**\n+   * Returns a list of modules that directly depend on the given module.\n+   * \n+   * This probably deserves to be in JSModuleGraph.\n+   */\n+  public Collection<JSModule> getDirectDependents(JSModule module) {\n+    Set<JSModule> directDependents = Sets.newHashSet();\n+    \n+    for (JSModule possibleDependent :\n+          compiler.getModuleGraph().getAllModules()) {\n+      if (possibleDependent.getDependencies().contains(module)) {\n+        directDependents.add(possibleDependent);       \n+      }\n+    }\n+    \n+    return directDependents;\n+  }\n+    \n+  /**\n+   * A simple abstract classes that takes two isomorphic ASTs and walks\n+   * each of them together, reporting matches to subclasses.\n+   * \n+   * This could probably be hardened and moved to NodeUtil\n+   */\n+  private abstract static class NodeMatcher {\n+   \n+    /**\n+     * Calls {@link #reportMatch(Node, Node)} for each pair of matching nodes\n+     * from the two ASTs.\n+     * \n+     * The two ASTs must be isomorphic. Currently no error checking is\n+     * performed to ensure that this is the case.\n+     */\n+    public void match(Node ast1, Node ast2) {\n+      // Just blunder ahead and assume that the two nodes actually match\n+        \n+      reportMatch(ast1, ast2);\n+      \n+      if (shouldTraverse(ast1, ast2)) {\n+        Node childOf1 = ast1.getFirstChild();\n+        Node childOf2 = ast2.getFirstChild();\n+        \n+        while (childOf1 != null) {\n+          match(childOf1, childOf2);\n+          childOf1 = childOf1.getNext();\n+          childOf2 = childOf2.getNext();\n+        }\n+      }\n+      \n+    }\n+    \n+    /**\n+     * Subclasses should override to add their own behavior when two nodes\n+     * are matched.\n+     * @param n1 A node from the AST passed as ast1 in \n+     * {@link #match(Node, Node)}.\n+     * @param n2 A node from the AST passed as ast1 in \n+     * {@link #match(Node, Node)}.\n+     */\n+    public abstract void reportMatch(Node n1, Node n2);\n+    \n+    /**\n+     * Subclasses should override to determine whether matching should proceed\n+     * under a subtree.\n+     */\n+    public boolean shouldTraverse(Node node1, Node n2) {\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * A class that stores information about the original version of a\n+   * function that will be/was specialized or removed.\n+   * \n+   * This class stores:\n+   * - how the function was defined\n+   * - a copy of the original function\n+   */\n+  private static class OriginalFunctionInformation {\n+    private String name;\n+    \n+    /**\n+     *  a = function() {} if true; \n+     *  function a() {} otherwise\n+     */   \n+    private boolean isAssignFunction; \n+    \n+    private boolean assignHasVar;\n+    \n+    private Node originalFunctionCopy;\n+    \n+    public OriginalFunctionInformation(Node originalFunction) {\n+      name = NodeUtil.getFunctionName(originalFunction);\n+      \n+      originalFunctionCopy = originalFunction.cloneTree();\n+      originalFunctionCopy.copyInformationFromForTree(originalFunction);\n+      \n+      Node originalParent = originalFunction.getParent();\n+      \n+      isAssignFunction = NodeUtil.isAssign(originalParent) ||\n+          NodeUtil.isName(originalParent);\n+      \n+      assignHasVar =\n+          isAssignFunction && NodeUtil.isVar(originalParent.getParent());\n+    }\n+    \n+    private Node copiedOriginalFunction() {\n+      // Copy of a copy\n+      Node copy = originalFunctionCopy.cloneTree();\n+      copy.copyInformationFromForTree(originalFunctionCopy);\n+      \n+      return copy;\n+    }\n+    \n+    /**\n+     * Did the original function add its name to scope?\n+     * (If so, and specialization removes it, then we'll have to\n+     * add a VAR for it so VarCheck doesn't complain).\n+     */\n+    private boolean originalWasDeclaration() {\n+      return (!isAssignFunction) || (assignHasVar);\n+    }\n+        \n+    /**\n+     * Generates a definition of the original function that can be added as\n+     * a fixup in the modules that directly depend on the specialized module.\n+     * \n+     * <PRE>\n+     * The trick here is that even if the original function is declared as:\n+     * \n+     * function foo() {\n+     *   // stuff\n+     * }\n+     * \n+     * the fixup will have to be of the form\n+     * \n+     * foo = function() {\n+     *   // stuff\n+     * }\n+     * </PRE>\n+     * \n+     */\n+    private Node generateFixupDefinition() {  \n+      Node functionCopy = copiedOriginalFunction();\n+  \n+      Node nameNode;\n+       \n+      if (isAssignFunction) {\n+        nameNode =\n+           NodeUtil.newQualifiedNameNode(name, functionCopy, name);\n+      } else {\n+        // Grab the name node from the original function and make that\n+        // function anonymous.\n+        nameNode = functionCopy.getFirstChild();\n+        functionCopy.replaceChild(nameNode,\n+            NodeUtil.newName(\"\", nameNode));\n+      }\n+          \n+      Node assignment = new Node(Token.ASSIGN, nameNode, functionCopy);\n+      assignment.copyInformationFrom(functionCopy);\n+\n+      return NodeUtil.newExpr(assignment);\n+    }\n+    \n+    /**\n+     * Returns a new dummy var declaration for the function with no initial\n+     * value:\n+     * \n+     * var name;\n+     */\n+    private Node generateDummyDeclaration() {\n+      Node declaration = NodeUtil.newVarNode(name, null);\n+      declaration.copyInformationFromForTree(originalFunctionCopy);\n+      \n+      return declaration;\n+    }\n+  }\n+  \n+  /**\n+   * A class to hold state during SpecializeModule. An instance of this class\n+   * is passed to specialization-aware compiler passes -- they use it to\n+   * communicate with SpecializeModule.\n+   * \n+   * SpecializationAware optimizations are required to keep track of the \n+   * functions they remove and the functions that they modify so that the fixups\n+   * can be added. However, not all functions can be fixed up.\n+   * \n+   * Specialization-aware classes *must* call \n+   * {@link #reportSpecializedFunction} when a function is modified during\n+   * specialization and {@link #reportRemovedFunction} when one is removed.\n+   * \n+   * Also, when specializing, they must query {@link #canFixupFunction}\n+   * before modifying a function.\n+   * \n+   * This two-way communication, is the reason we don't use \n+   * {@link AstChangeProxy} to report code changes.\n+   */\n+  public static class SpecializationState {\n+    \n+    /** \n+     * The functions that the pass has specialized. These functions will\n+     * be fixed up in non-specialized modules to their more general versions.\n+     * \n+     * This field is also used to determine whether specialization is enabled.\n+     * If not null, specialization is enabled, otherwise it is disabled.\n+     */\n+    private Set<Node> specializedFunctions;\n+    \n+    /**\n+     * The functions that the pass has removed. These functions will be \n+     * redefined in non-specialized modules.\n+     */\n+    private Set<Node> removedFunctions;\n+    \n+    private SimpleFunctionAliasAnalysis initialModuleAliasAnalysis;\n+    \n+    /** Will be true if any new functions have been removed or specialized since\n+     * {@link #resetHasChanged}.\n+     */\n+    private boolean hasChanged = false;\n+     \n+    public SpecializationState(SimpleFunctionAliasAnalysis \n+        initialModuleAliasAnalysis) {\n+      \n+      this.initialModuleAliasAnalysis = initialModuleAliasAnalysis;\n+      \n+      specializedFunctions = Sets.newLinkedHashSet();\n+      removedFunctions = Sets.newLinkedHashSet();\n+    }\n+    \n+    /**\n+     * Returns true if any new functions have been reported as removed or\n+     * specialized since {@link #resetHasChanged()} was last called.\n+     */\n+    private boolean hasChanged() {\n+      return hasChanged;\n+    }\n+    \n+    private void resetHasChanged() {\n+      hasChanged = false;\n+    }\n+    \n+    /**\n+     * Returns the functions specialized by this compiler pass.\n+     */\n+    public Set<Node> getSpecializedFunctions() {\n+      return specializedFunctions;\n+    }\n+    \n+    /**\n+     * Reports that a function has been specialized.\n+     * \n+     * @param functionNode A specialized AST node with type Token.FUNCTION\n+     */\n+    public void reportSpecializedFunction(Node functionNode) {\n+      hasChanged = specializedFunctions.add(functionNode);\n+    }\n+    \n+    /**\n+     * Reports that the function containing the node has been specialized.\n+     */\n+    public void reportSpecializedFunctionContainingNode(Node node) {\n+      Node containingFunction = containingFunction(node);\n+      \n+      if (containingFunction != null) {\n+        reportSpecializedFunction(containingFunction);\n+      }\n+    }\n+    \n+    /**\n+     * The functions removed by this compiler pass.\n+     */\n+    public Set<Node> getRemovedFunctions() {\n+      return removedFunctions;\n+    }\n+    \n+    /**\n+     * Reports that a function has been removed.\n+     * \n+     * @param functionNode A removed AST node with type Token.FUNCTION\n+     */\n+    public void reportRemovedFunction(Node functionNode) {\n+      hasChanged = removedFunctions.add(functionNode);\n+    }\n+    \n+    /**\n+     * Returns true if the function can be fixed up (that is, if it can be\n+     * safely removed or specialized).\n+     * \n+     * <p>In order to be safely fixed up, a function must be:\n+     * <PRE>\n+     * - in the global scope\n+     * - not aliased in the initial module\n+     * - of one of the following forms:\n+     *    function f() {}\n+     *    var f = function() {}\n+     *    f = function(){}\n+     *    var ns = {}; ns.f = function() {}\n+     *    SomeClass.prototype.foo = function() {};\n+     * </PRE>\n+     * \n+     * <p>Anonymous functions cannot be safely fixed up, nor can functions\n+     * that have been aliased.\n+     * \n+     * <p>Some functions declared as object literals could be safely fixed up,\n+     * however we do not currently support this. \n+     */\n+    public boolean canFixupFunction(Node functionNode) {\n+      Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n+      \n+      if (!nodeIsInGlobalScope(functionNode) ||\n+          initialModuleAliasAnalysis.isAliased(functionNode)) {\n+        return false;\n+      }\n+      \n+      if (NodeUtil.isStatement(functionNode)) {\n+        // function F() {}\n+        return true;\n+      }\n+      \n+      Node parent = functionNode.getParent();    \n+      Node gramps = parent.getParent();\n+      \n+      if (NodeUtil.isName(parent) && NodeUtil.isVar(gramps)) {\n+        // var f = function() {}\n+        return true;\n+      }\n+      \n+      if (NodeUtil.isExprAssign(gramps)\n+          && parent.getChildAtIndex(1) == functionNode) {\n+        // f = function() {}\n+        // ns.f = function() {}\n+        return true;\n+      }\n+      \n+      return false;\n+    }\n+    \n+    /**\n+     * Returns true if the function containing n can be fixed up.\n+     * Also returns true if n is in the global scope -- since it is always safe\n+     * to specialize the global scope.\n+     */\n+    public boolean canFixupSpecializedFunctionContainingNode(Node n) {\n+      Node containingFunction = containingFunction(n);\n+      if (containingFunction != null) {\n+        return canFixupFunction(containingFunction);\n+      } else {\n+        // Always safe to specialize the global scope\n+        return true;\n+      }\n+    }\n+    \n+    /**\n+     * Returns true if a node is in the global scope; false otherwise.\n+     */\n+    private boolean nodeIsInGlobalScope(Node node) {\n+      return containingFunction(node) == null;\n+    }\n+    \n+    /**\n+     * Returns the function containing the node, or null if none exists.\n+     */\n+    private Node containingFunction(Node node) {\n+      for (Node ancestor : node.getAncestors()) {\n+        if (NodeUtil.isFunction(ancestor)) {\n+          return ancestor;\n+        }\n+      }\n+\n+      return null;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Tests for {@link SimpleFunctionAliasAnalysis}.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {\n+  \n+  private SimpleFunctionAliasAnalysis analysis;\n+  \n+  private Compiler lastCompiler;\n+  \n+  @Override\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+      return new CompilerPass() {\n+        \n+        @Override\n+        public void process(Node externs, Node root) {\n+          SimpleDefinitionFinder finder = new SimpleDefinitionFinder(compiler);\n+          finder.process(externs, root);\n+          \n+          analysis = new SimpleFunctionAliasAnalysis();\n+          \n+          analysis.analyze(finder);  \n+          \n+          lastCompiler = compiler;\n+        }\n+      };\n+  }\n+\n+  public void testFunctionGetIsAliased() { \n+    // Aliased by VAR assignment   \n+    String source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"var D = function() {}\\n\" +\n+        \"var aliasA = A;\\n\" +\n+        \"var aliasB = ns.B;\\n\" +\n+        \"var aliasC = C;\\n\" +\n+        \"D();\";\n+      \n+    compileAndRun(source);\n+  \n+    assertFunctionAliased(true, \"A\");\n+    assertFunctionAliased(true, \"ns.B\");\n+    assertFunctionAliased(true, \"C\");\n+    assertFunctionAliased(false, \"D\");\n+    \n+    // Aliased by normal assignment   \n+    source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"ns.D = function() {}\\n\" +\n+        \"var aliasA;\\n\" +\n+        \"aliasA = A;\\n\" +\n+        \"var aliasB = {};\\n\" +\n+        \"aliasB.foo = ns.B;\\n\" +\n+        \"var aliasC;\\n\" +\n+        \"aliasC = C;\\n\" +\n+        \"ns.D();\";\n+      \n+    compileAndRun(source);\n+  \n+    assertFunctionAliased(true, \"A\");\n+    assertFunctionAliased(true, \"ns.B\");\n+    assertFunctionAliased(true, \"C\");\n+    assertFunctionAliased(false, \"ns.D\");\n+    \n+    // Aliased by passing as parameter  \n+    source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"function D() {}\\n\" +\n+        \"var foo = function(a) {}\\n\" +\n+        \"foo(A);\\n\" +\n+        \"foo(ns.B)\\n\" +\n+        \"foo(C);\\n\" +\n+        \"D();\";\n+      \n+    compileAndRun(source);\n+  \n+    assertFunctionAliased(true, \"A\");\n+    assertFunctionAliased(true, \"ns.B\");\n+    assertFunctionAliased(true, \"C\");\n+    assertFunctionAliased(false, \"D\");\n+    \n+    // Not aliased by being target of call\n+    source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"A();\\n\" +\n+        \"ns.B();\\n\" +\n+        \"C();\\n\";\n+        \n+    compileAndRun(source);\n+    \n+    assertFunctionAliased(false, \"A\");\n+    assertFunctionAliased(false, \"ns.B\");\n+    assertFunctionAliased(false, \"C\");\n+    \n+    // Not aliased by GET{PROP,ELEM}\n+    source =\n+        \"function A(){};\\n\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.B = function() {};\\n\" +\n+        \"var C = function() {}\\n\" +\n+        \"A.foo;\\n\" +\n+        \"ns.B.prototype;\\n\" +\n+        \"C[0];\\n\";\n+        \n+    compileAndRun(source);\n+    \n+    assertFunctionAliased(false, \"A\");\n+    assertFunctionAliased(false, \"ns.B\");\n+    assertFunctionAliased(false, \"C\");\n+  }\n+  \n+  public void testFunctionGetIsExposedToCallOrApply() { \n+    // Exposed to call\n+    String source =\n+        \"function A(){};\\n\" +\n+        \"function B(){};\\n\" +\n+        \"function C(){};\\n\" +\n+        \"var x;\\n\" +\n+        \"A.call(x);\\n\" +\n+        \"B.apply(x);\\n\" +\n+        \"C();\\n\";\n+    \n+    compileAndRun(source);\n+  \n+    assertFunctionExposedToCallOrApply(true, \"A\");\n+    assertFunctionExposedToCallOrApply(true, \"B\");\n+    assertFunctionExposedToCallOrApply(false, \"C\");\n+    \n+    source =\n+      \"var ns = {};\" +\n+      \"ns.A = function(){};\\n\" +\n+      \"ns.B = function(){};\\n\" +\n+      \"ns.C = function(){};\\n\" +\n+      \"var x;\\n\" +\n+      \"ns.A.call(x);\\n\" +\n+      \"ns.B.apply(x);\\n\" +\n+      \"ns.C();\\n\";\n+  \n+    compileAndRun(source);\n+\n+    assertFunctionExposedToCallOrApply(true, \"ns.A\");\n+    assertFunctionExposedToCallOrApply(true, \"ns.B\");\n+    assertFunctionExposedToCallOrApply(false, \"ns.C\");\n+  }\n+  \n+  private void assertFunctionAliased(boolean aliasStatus,\n+      String functionName) {\n+    Node function = findFunction(functionName);\n+    \n+    assertEquals(aliasStatus, analysis.isAliased(function));\n+  }\n+  \n+  private void assertFunctionExposedToCallOrApply(boolean exposure,\n+      String functionName) {\n+    Node function = findFunction(functionName);\n+    \n+    assertEquals(exposure, analysis.isExposedToCallOrApply(function));\n+  }\n+  \n+  private void compileAndRun(String source) {\n+    testSame(source, source, null);\n+  }\n+  \n+  private Node findFunction(String name) {\n+    FunctionFinder f = new FunctionFinder(name);\n+    new NodeTraversal(lastCompiler, f).traverse(lastCompiler.jsRoot);\n+    assertNotNull(\"Couldn't find \" + name, f.found);\n+    return f.found;\n+  }\n+  \n+  /**\n+   * Quick Traversal to find a given function in the AST.\n+   */\n+  private class FunctionFinder extends AbstractPostOrderCallback {\n+    Node found = null;\n+    final String target;\n+\n+    FunctionFinder(String target) {\n+      this.target = target;\n+    }\n+    \n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (NodeUtil.isFunction(n)\n+          && target.equals(NodeUtil.getFunctionName(n))) {\n+        found = n;\n+      }\n+    }\n+  }  \n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.SpecializeModule.SpecializationState;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Tests for {@link SpecializeModule}.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class SpecializeModuleTest extends CompilerTestCase {\n+\n+  private static final String SHARED_EXTERNS = \"var alert = function() {}\";\n+\n+  public SpecializeModuleTest() {\n+    super(SHARED_EXTERNS);\n+  }\n+\n+  private PassFactory inlineFunctions =\n+      new PassFactory(\"inlineFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new InlineFunctions(compiler,\n+          compiler.getUniqueNameIdSupplier(), true, false, true);\n+    }\n+  };\n+  \n+  private PassFactory removeUnusedPrototypeProperties =\n+    new PassFactory(\"removeUnusedPrototypeProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new RemoveUnusedPrototypeProperties(compiler, false, false);\n+    }\n+  };\n+  \n+  private PassFactory devirtualizePrototypeMethods =\n+    new PassFactory(\"devirtualizePrototypeMethods\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new DevirtualizePrototypeMethods(compiler);\n+    }\n+  };\n+  \n+  @Override\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+    final SpecializeModule specializeModule = new SpecializeModule(compiler,\n+        devirtualizePrototypeMethods, inlineFunctions, \n+        removeUnusedPrototypeProperties);\n+\n+    return new CompilerPass() {     \n+      @Override\n+      public void process(Node externs, Node root) {\n+        specializeModule.process(externs, root);\n+\n+        /* Make sure variables are declared before used */\n+        new VarCheck(compiler).process(externs, root);       \n+      }\n+    };\n+  }\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+\n+    enableNormalize();\n+  }\n+\n+  public void testSpecializeInline() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        /* Recursion in A() prevents inline of A*/\n+        \"var A = function() {alert(B());A()};\" + \n+        \"var B = function() {return 6};\" +\n+        \"A();\",       \n+        // m2\n+        \"A();\" +\n+        \"B();\" +\n+        \"B = function() {return 7};\" +\n+        \"A();\" +\n+        \"B();\"\n+        );\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var A = function() {alert(6);A()};\" + /* Specialized A */    \n+        \"A();\" +\n+        \"var B;\",    \n+        // m2\n+        \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n+        \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n+        \"A();\" +\n+        \"B();\" +\n+        \"B = function() {return 7};\" +\n+        \"A();\" +\n+        \"B();\"\n+    });\n+  }\n+  \n+  public void testSpecializeCascadedInline() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        /* Recursion in A() prevents inline of A*/\n+        \"var A = function() {alert(B());A()};\" + \n+        \"var B = function() {return C()};\" +\n+        \"var C = function() {return 6};\" +\n+        \"A();\",       \n+        // m2\n+        \"B = function() {return 7};\" +\n+    \"A();\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var A = function() {alert(6);A()};\" + /* Specialized A */    \n+        \"A();\" +\n+        \"var B, C;\",    \n+        // m2\n+        \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n+        \"B = function() {return C()};\" + /* Removed from m1, so add to m2 */\n+        \"C = function() {return 6};\" + /* Removed from m1, so add to m2 */\n+        \"B = function() {return 7};\" +\n+        \"A();\"\n+    });\n+  }\n+\n+  public void testSpecializeInlineWithMultipleDependents() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        /* Recursion in A() prevents inline of A*/\n+        \"var A = function() {alert(B());A()};\" + \n+        \"var B = function() {return 6};\" +\n+        \"A();\",       \n+        // m2\n+        \"B = function() {return 7};\" +\n+        \"A();\",\n+        // m3\n+        \"A();\"\n+    );\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var A = function() {alert(6);A()};\" + /* Specialized A */    \n+        \"A();\" +\n+        \"var B;\",    \n+        // m2\n+        \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n+        \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n+        \"B = function() {return 7};\" +\n+        \"A();\",\n+        \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n+        \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n+        \"A();\",\n+\n+    });\n+  }\n+\n+  public void testSpecializeInlineWithNamespaces() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        \"var ns = {};\" +\n+        /* Recursion in A() prevents inline of A*/\n+        \"ns.A = function() {alert(B());ns.A()};\" + \n+        \"var B = function() {return 6};\" +\n+        \"ns.A();\",       \n+        // m2\n+        \"B = function() {return 7};\" +\n+    \"ns.A();\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var ns = {};\" +\n+        \"ns.A = function() {alert(6);ns.A()};\" + /* Specialized A */    \n+        \"ns.A();\" +\n+        \"var B;\",    \n+        // m2\n+        \"ns.A = function() {alert(B());ns.A()};\" + /* Unspecialized A */\n+        \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n+        \"B = function() {return 7};\" +\n+        \"ns.A();\"\n+    });\n+  }\n+\n+  public void testSpecializeInlineWithRegularFunctions() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        /* Recursion in A() prevents inline of A*/\n+        \"function A() {alert(B());A()}\" + \n+        \"function B() {return 6}\" +\n+        \"A();\",       \n+        // m2\n+        \"B = function() {return 7};\" +\n+    \"A();\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"function A() {alert(6);A()}\" + /* Specialized A */    \n+        \"A();\" +\n+        \"var B;\",    \n+        // m2\n+        \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n+        \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n+        /* Start of original m2 */\n+        \"B = function() {return 7};\" +\n+        \"A();\"\n+    });\n+  }\n+\n+  public void testDontSpecializeLocalNonAnonymousFunctions() {\n+    /* normalize result, but not expected */\n+    enableNormalize(false);\n+\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        \"(function(){var noSpecialize = \" +\n+            \"function() {alert(6)};noSpecialize()})()\",       \n+        // m2\n+        \"\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"(function(){var noSpecialize = \" +\n+            \"function() {alert(6)};noSpecialize()})()\", \n+        // m2\n+        \"\"\n+    });\n+  }\n+\n+  public void testAddDummyVarsForRemovedFunctions() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        /* Recursion in A() prevents inline of A*/\n+        \"var A = function() {alert(B() + C());A()};\" + \n+        \"var B = function() {return 6};\" +\n+        \"var C = function() {return 8};\" +\n+        \"A();\",       \n+        // m2\n+        \"\" +\n+    \"A();\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var A = function() {alert(6 + 8);A()};\" + /* Specialized A */    \n+        \"A();\" +\n+        \"var B, C;\",    \n+        // m2\n+        \"A = function() {alert(B() + C());A()};\" + /* Unspecialized A */\n+        \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n+        \"C = function() {return 8};\" + /* Removed from m1, so add to m2 */\n+        \"A();\"\n+    });\n+  }\n+\n+  public void testSpecializeRemoveUnusedProperties() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        /* Recursion in A() prevents inline of A*/\n+        \"var Foo = function(){};\" + /* constructor */\n+        \"Foo.prototype.a = function() {this.a()};\" + \n+        \"Foo.prototype.b = function() {return 6};\" +\n+        \"Foo.prototype.c = function() {return 7};\" +\n+        \"var aliasA = Foo.prototype.a;\" + // Prevents devirtualization of a\n+        \"var x = new Foo();\" +\n+        \"x.a();\",       \n+        // m2\n+        \"\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var Foo = function(){};\" + /* constructor */\n+        \"Foo.prototype.a = function() {this.a()};\" +\n+        \"var aliasA = Foo.prototype.a;\" +\n+        \"var x = new Foo();\" +\n+        \"x.a();\", \n+        // m2\n+        \"Foo.prototype.b = function() {return 6};\" +\n+        \"Foo.prototype.c = function() {return 7};\"        \n+    });\n+  }\n+  \n+  public void testDontSpecializeAliasedFunctions_inline() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        /* Recursion in A() prevents inline of A*/\n+        \"function A() {alert(B());A()}\" + \n+        \"function B() {return 6}\" +\n+        \"var aliasA = A;\" +\n+        \"A();\",       \n+        // m2\n+        \"B = function() {return 7};\" +\n+        \"B();\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        /* Recursion in A() prevents inline of A*/\n+        \"function A() {alert(B());A()}\" + \n+        \"function B() {return 6}\" +\n+        \"var aliasA = A;\" +\n+        \"A();\",       \n+        // m2\n+        \"B = function() {return 7};\" +\n+        \"B();\"\n+    });\n+  }\n+\n+  public void testDontSpecializeAliasedFunctions_remove_unused_properties() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        \"var Foo = function(){};\" + /* constructor */\n+        \"Foo.prototype.a = function() {this.a()};\" + \n+        \"Foo.prototype.b = function() {return 6};\" +\n+        \"var aliasB = Foo.prototype.b;\" +\n+        \"Foo.prototype.c = function() {return 7};\" +\n+        \"Foo.prototype.d = function() {return 7};\" +\n+        \"var aliasA = Foo.prototype.a;\" + // Prevents devirtualization of a\n+        \"var x = new Foo();\" +\n+        \"x.a();\" +\n+        \"var aliasC = (new Foo).c\",       \n+        // m2\n+        \"\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var Foo = function(){};\" + /* constructor */\n+        \"Foo.prototype.a = function() {this.a()};\" +\n+        \"Foo.prototype.b = function() {return 6};\" +\n+        \"var aliasB = Foo.prototype.b;\" +\n+        \"Foo.prototype.c = function() {return 7};\" +\n+        \"var aliasA = Foo.prototype.a;\" + // Prevents devirtualization of a\n+        \"var x = new Foo();\" +\n+        \"x.a();\" +\n+        \"var aliasC = (new Foo).c\", \n+        // m2\n+        \"Foo.prototype.d = function() {return 7};\"        \n+    });\n+  }\n+  \n+  public void testSpecializeDevirtualizePrototypeMethods() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        \"/** @constructor */\" +\n+        \"var Foo = function(){};\" + /* constructor */\n+        \"Foo.prototype.a = function() {this.a();return 7};\" +\n+        \"Foo.prototype.b = function() {this.a()};\" +\n+        \"var x = new Foo();\" +\n+        \"x.a();\",\n+        // m2\n+        \"\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var Foo = function(){};\" + /* constructor */\n+        \"var JSCompiler_StaticMethods_a =\" +\n+              \"function(JSCompiler_StaticMethods_a$self) {\" + \n+           \"JSCompiler_StaticMethods_a(JSCompiler_StaticMethods_a$self);\" +\n+           \"return 7\" +\n+        \"};\" +\n+        \"var x = new Foo();\" +\n+        \"JSCompiler_StaticMethods_a(x);\",\n+        // m2\n+        \"Foo.prototype.a = function() {this.a();return 7};\" +\n+        \"Foo.prototype.b = function() {this.a()};\"\n+    });\n+  }\n+  \n+  public void testSpecializeDevirtualizePrototypeMethodsWithInline() {\n+    JSModule[] modules = createModuleStar(\n+        // m1\n+        \"/** @constructor */\" +\n+        \"var Foo = function(){};\" + /* constructor */\n+        \"Foo.prototype.a = function() {return 7};\" +\n+        \"var x = new Foo();\" +\n+        \"var z = x.a();\",\n+        // m2\n+        \"\");\n+\n+    test(modules, new String[] {\n+        // m1\n+        \"var Foo = function(){};\" + /* constructor */\n+        \"var x = new Foo();\" +\n+        \"var z = 7;\",\n+        // m2\n+        \"Foo.prototype.a = function() {return 7};\"\n+    });\n+  }\n+  \n+  /**\n+   * Tests for {@link SpecializeModule.SpecializationState}.\n+   */\n+  public static class SpecializeModuleSpecializationStateTest \n+      extends CompilerTestCase {\n+    \n+    Compiler lastCompiler;\n+    \n+    SpecializationState lastState;\n+    \n+    @Override\n+    public CompilerPass getProcessor(final Compiler compiler) {\n+      lastCompiler = compiler;\n+      \n+      return new CompilerPass() {\n+        \n+        @Override\n+        public void process(Node externs, Node root) {         \n+          SimpleDefinitionFinder defFinder = \n+              new SimpleDefinitionFinder(compiler);\n+          \n+          defFinder.process(externs, root);\n+          \n+          SimpleFunctionAliasAnalysis functionAliasAnalysis = \n+              new SimpleFunctionAliasAnalysis();\n+          \n+          functionAliasAnalysis.analyze(defFinder); \n+          \n+          lastState = new SpecializationState(functionAliasAnalysis);       \n+        }\n+      };\n+    }\n+      \n+    public void testRemovedFunctions() {\n+      testSame(\"function F(){}\\nvar G = function(a){};\");\n+      \n+      assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions());\n+      \n+      Node functionF = findFunction(\"F\");\n+      \n+      lastState.reportRemovedFunction(functionF);\n+      assertEquals(ImmutableSet.of(functionF), lastState.getRemovedFunctions());\n+\n+      Node functionG = findFunction(\"F\");\n+      \n+      lastState.reportRemovedFunction(functionG);\n+      assertEquals(ImmutableSet.of(functionF, functionG),\n+          lastState.getRemovedFunctions());\n+      \n+      assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions());\n+    }\n+    \n+    public void testSpecializedFunctions() {\n+      testSame(\"function F(){}\\nvar G = function(a){};\");\n+      \n+      assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions());\n+      \n+      Node functionF = findFunction(\"F\");\n+      \n+      lastState.reportSpecializedFunction(functionF);\n+      assertEquals(ImmutableSet.of(functionF),\n+          lastState.getSpecializedFunctions());\n+\n+      Node functionG = findFunction(\"F\");\n+      \n+      lastState.reportSpecializedFunction(functionG);\n+      assertEquals(ImmutableSet.of(functionF, functionG),\n+          lastState.getSpecializedFunctions());\n+      \n+      assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions());\n+    }\n+    \n+    public void testCanFixupFunction() {\n+      testSame(\"function F(){}\\n\" +\n+               \"var G = function(a){};\\n\" +\n+               \"var ns = {};\" +\n+               \"ns.H = function(){};\" + \n+               \"var ns2 = {I : function anon1(){}};\" +\n+               \"(function anon2(){})();\");\n+      \n+      assertTrue(lastState.canFixupFunction(findFunction(\"F\")));\n+      assertTrue(lastState.canFixupFunction(findFunction(\"G\")));\n+      assertTrue(lastState.canFixupFunction(findFunction(\"ns.H\")));\n+      assertFalse(lastState.canFixupFunction(findFunction(\"anon1\")));\n+      assertFalse(lastState.canFixupFunction(findFunction(\"anon2\")));\n+      \n+      // Can't guarantee safe fixup for aliased functions\n+      testSame(\"function A(){}\\n\" +\n+          \"var aliasA = A;\\n\");\n+\n+      assertFalse(lastState.canFixupFunction(findFunction(\"A\")));\n+    }\n+    \n+    private Node findFunction(String name) {\n+      FunctionFinder f = new FunctionFinder(name);\n+      new NodeTraversal(lastCompiler, f).traverse(lastCompiler.jsRoot);\n+      assertNotNull(\"Couldn't find \" + name, f.found);\n+      return f.found;\n+    }\n+    \n+    /**\n+     * Quick Traversal to find a given function in the AST.\n+     */\n+    private class FunctionFinder extends AbstractPostOrderCallback {\n+      Node found = null;\n+      final String target;\n+\n+      FunctionFinder(String target) {\n+        this.target = target;\n+      }\n+      \n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (NodeUtil.isFunction(n)\n+            && target.equals(NodeUtil.getFunctionName(n))) {\n+          found = n;\n+        }\n+      }\n+    }   \n+  }\n+}", "timestamp": 1281639520, "metainfo": ""}