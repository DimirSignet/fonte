{"sha": "6d374c3ee4c9c2651ffb44048924e127fd2bf37c", "log": "Fixes a bug in AmbugateProperties in the presence of interfaces.  Fixes a bug in how type information on methods of interfaces gets inherited by implementers (issue 86)  Use Joiners instead of the join() static method.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Charsets;\n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Maps;\n \n       int i = 1;\n       for (List<String> loop : loopedPassesInBestRun) {\n-        out.println(\"\\nLoop \" + i + \":\\n\" + Join.join(\"\\n\", loop));\n+        out.println(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop));\n         i++;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.BiMap;\n import com.google.common.collect.HashBiMap;\n     for (Property p : propertyMap.values()) {\n       if (!p.skipAmbiguating) {\n         ++numRenamedPropertyNames;\n-        computeRelatedTypes(p.type);\n         propsByFreq.add(p);\n       } else {\n         ++numSkippedPropertyNames;\n                 + numSkippedPropertyNames + \" properties.\");\n   }\n \n+  private BitSet getRelatedTypesOnNonUnion(JSType type) {\n+    // All of the types we encounter should have been added to the\n+    // relatedBitsets via computeRelatedTypes.\n+    if (relatedBitsets.containsKey(type)) {\n+      return relatedBitsets.get(type);\n+    } else {\n+      throw new RuntimeException(\"Related types should have been computed for\"\n+                                 + \" type: \" + type + \" but have not been.\");\n+    }\n+  }\n+\n   /** Add supertypes of the type to its JSTypeBitSet of related types. */\n   private void computeRelatedTypes(JSType type) {\n     if (type instanceof UnionType) {\n       if (typesRelatedToSet.intersects(prop.typesSet)) {\n         return false;\n       }\n-      return !getRelated(prop.type).intersects(typesInSet);\n+      return !prop.relatedTypesSet.intersects(typesInSet);\n     }\n \n     /**\n      */\n     public void addNode(Property prop) {\n       typesInSet.or(prop.typesSet);\n-      typesRelatedToSet.or(getRelated(prop.type));\n+      typesRelatedToSet.or(prop.relatedTypesSet);\n     }\n \n     /**\n       JSTypeBitSet relatedTypes = new JSTypeBitSet(intForType.size());\n       if (type instanceof UnionType) {\n         for (JSType alt : ((UnionType) type).getAlternates()) {\n-          getRelatedTypesOnNonUnion(alt, relatedTypes);\n+          intersectRelatedTypesOnNonUnion(alt, relatedTypes);\n         }\n       } else {\n-        getRelatedTypesOnNonUnion(type, relatedTypes);\n+        intersectRelatedTypesOnNonUnion(type, relatedTypes);\n       }\n       return relatedTypes;\n     }\n \n     /**\n-     * Finds all types related to the provided type and returns a BitSet with\n-     * their bits to true.  Expects a non-union type.\n+     * Finds all types related to the provided type and intersects them with\n+     * the given BitSet. Expects a non-union type.\n      */\n-    private void getRelatedTypesOnNonUnion(\n+    private void intersectRelatedTypesOnNonUnion(\n         JSType type, JSTypeBitSet relatedTypes) {\n-      // All of the types we encounter should have been added to the\n-      // relatedBitsets via computeRelatedTypes.\n-      if (relatedBitsets.containsKey(type)) {\n-        relatedTypes.or(relatedBitsets.get(type));\n-      } else {\n-        throw new RuntimeException(\"Related types should have been computed for\"\n-                                   + \"type: \" + type + \" but have not been.\");\n-      }\n+      relatedTypes.or(getRelatedTypesOnNonUnion(type));\n     }\n   }\n \n   /** Encapsulates the information needed for renaming a property. */\n   private class Property {\n     final String oldName;\n-    JSType type;\n     String newName;\n     int numOccurrences;\n     boolean skipAmbiguating;\n     JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size());\n+    JSTypeBitSet relatedTypesSet = new JSTypeBitSet(intForType.size());\n \n     Property(String name) {\n       this.oldName = name;\n         return;\n       }\n \n-      if (type == null) {\n-        type = newType;\n-      } else {\n-        // TODO(nicksantos): This line doesn't make sense. It only works if\n-        // we assume that the type hierarchy is a tree (and thus has a\n-        // single root). It doesn't work with an arbitrary lattice.\n-        //\n-        // Consider a class Chimay that extends Beer and implements Expensive.\n-        // supremum(Chimay, Expensive) == Expensive\n-        // according to the lattice's supremum op (getLeastSupertype).\n-        //\n-        // And since related types are computed from this result, this\n-        // means that we will treat Beer as unrelated to Chimay, which is\n-        // clearly not correct.\n-        type = type.getLeastSupertype(newType);\n-      }\n-\n-      typesSet.set(getIntForType(newType));\n+      int typeInt = getIntForType(newType);\n+      if (!typesSet.get(typeInt)) {\n+        computeRelatedTypes(newType);\n+        typesSet.set(typeInt);\n+        relatedTypesSet.or(getRelatedTypesOnNonUnion(newType));\n+      }\n     }\n   }\n \n   // A BitSet that stores type info. Adds pretty-print routines.\n   private class JSTypeBitSet extends BitSet {\n+    private static final long serialVersionUID = 1L;\n \n     private JSTypeBitSet(int size) {\n       super(size);\n         types.add(intForType.inverse().get(current).toString());\n         from = current + 1;\n       }\n-      return Join.join(\" && \", types);\n+      return Joiner.on(\" && \").join(types);\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.jscomp.graph.GraphColoring;\n+import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n import com.google.javascript.jscomp.graph.UndiGraph;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n-import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         return;\n       }\n       \n-      pseudoName = Join.join(\"_\", allMergedNames);\n+      pseudoName = Joiner.on(\"_\").join(allMergedNames);\n       \n       while (t.getScope().isDeclared(pseudoName, true)) {\n         pseudoName += \"$\";\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n  */\n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-\n import com.google.javascript.jscomp.DataFlowAnalysis.LatticeElement;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n       }\n       Collections.sort(names);\n \n-      return \"(\" + Join.join(\",\", names) + \")\";\n+      return \"(\" + Joiner.on(\",\").join(names) + \")\";\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n \n       if (refersTo.size() > 0) {\n         out.append(\"\\n - REFERS TO: \");\n-        out.append(Join.join(\", \", refersTo));\n+        out.append(Joiner.on(\", \").join(refersTo));\n       }\n \n       if (referencedBy.size() > 0) {\n         out.append(\"\\n - REFERENCED BY: \");\n-        out.append(Join.join(\", \", referencedBy));\n+        out.append(Joiner.on(\", \").join(referencedBy));\n       }\n       return out.toString();\n     }\n--- a/src/com/google/javascript/jscomp/ReplaceCssNames.java\n+++ b/src/com/google/javascript/jscomp/ReplaceCssNames.java\n package com.google.javascript.jscomp;\n \n import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Join;\n-import javax.annotation.Nullable;\n+import com.google.common.base.Joiner;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.Map;\n \n+import javax.annotation.Nullable;\n \n /**\n  * ReplaceCssNames replaces occurrences of goog.getCssName('foo') with a shorter\n           }\n         }\n         if (symbolMap != null) {\n-          n.setString(Join.join(\"-\", parts));\n+          n.setString(Joiner.on(\"-\").join(parts));\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n                 lvalueNode.getFirstChild().getQualifiedName());\n             if (var != null) {\n               ObjectType ownerType = ObjectType.cast(var.getType());\n+              FunctionType propType = null;\n               if (ownerType != null) {\n-                String propName = lvalueNode.getLastChild().getString();\n-                JSType propType = ownerType.getPropertyType(propName);\n-                if (propType instanceof FunctionType) {\n-                  functionType =\n-                      new FunctionTypeBuilder(\n-                          name, compiler, errorRoot, sourceName, scope)\n-                      .setSourceNode(fnRoot)\n-                      .inferFromOverriddenFunction(\n-                          (FunctionType) propType, parametersNode)\n-                      .inferThisType(info, owner)\n-                      .buildAndRegister();\n-                }\n+                propType = findOverriddenFunction(\n+                    ownerType, lvalueNode.getLastChild().getString());\n+              }\n+\n+              if (propType != null) {\n+                functionType =\n+                    new FunctionTypeBuilder(\n+                        name, compiler, errorRoot, sourceName, scope)\n+                    .setSourceNode(fnRoot)\n+                    .inferFromOverriddenFunction(propType, parametersNode)\n+                    .inferThisType(info, owner)\n+                    .buildAndRegister();\n               }\n             }\n           }\n \n       // all done\n       return functionType;\n+    }\n+\n+    /**\n+     * Find the function that's being overridden on this type, if any.\n+     */\n+    private FunctionType findOverriddenFunction(\n+        ObjectType ownerType, String propName) {\n+      // First, check to see if the property is implemented\n+      // on a superclass.\n+      JSType propType = ownerType.getPropertyType(propName);\n+      if (propType instanceof FunctionType) {\n+        return (FunctionType) propType;\n+      } else {\n+        // If it's not, then check to see if it's implemented\n+        // on an implemented interface.\n+        for (ObjectType iface :\n+                 ownerType.getCtorImplementedInterfaces()) {\n+          propType = iface.getPropertyType(propName);\n+          if (propType instanceof FunctionType) {\n+            return (FunctionType) propType;\n+          }\n+        }\n+      }\n+\n+      return null;\n     }\n \n     /**\n--- a/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n   }\n \n   @Override\n-  Iterable<ObjectType> getCtorImplementedInterfaces() {\n+  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n     return getOwnerFunction().getImplementedInterfaces();\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n   }\n \n   @Override\n-  Iterable<ObjectType> getCtorImplementedInterfaces() {\n+  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n     return getConstructor().getImplementedInterfaces();\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    * Gets the interfaces implemented by the ctor associated with this type.\n    * Intended to be overridden by subclasses.\n    */\n-  Iterable<ObjectType> getCtorImplementedInterfaces() {\n+  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n     return ImmutableSet.of();\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  Iterable<ObjectType> getCtorImplementedInterfaces() {\n+  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n     return referencedType.getCtorImplementedInterfaces();\n   }\n \n--- a/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n         + \"(new Bar).b;\";\n     test(js, output);\n   }\n+\n+  public void testImplementsAndExtends() {\n+    String js = \"\"\n+        + \"/** @interface */ function Foo() {}\\n\"\n+        + \"/**\\n\"\n+        + \" * @constructor\\n\"\n+        + \" */\\n\"\n+        + \"function Bar(){}\\n\"\n+        + \"Bar.prototype.y = function() { return 3; };\\n\"\n+        + \"/**\\n\"\n+        + \" * @constructor\\n\"\n+        + \" * @extends {Bar}\\n\"\n+        + \" * @implements {Foo}\\n\"\n+        + \" */\\n\"\n+        + \"function SubBar(){ }\\n\"\n+        + \"/** @param {Foo} x */ function f(x) { x.z = 3; }\\n\"\n+        + \"/** @param {SubBar} x */ function g(x) { x.z = 3; }\";\n+    String output = \"\"\n+        + \"function Foo(){}\\n\"\n+        + \"function Bar(){}\\n\"\n+        + \"Bar.prototype.b = function() { return 3; };\\n\"\n+        + \"function SubBar(){}\\n\"\n+        + \"function f(x) { x.a = 3; }\\n\"\n+        + \"function g(x) { x.a = 3; }\";\n+    test(js, output);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.common.flags.Flags;\n import com.google.javascript.rhino.Node;\n   private void test(String[] original, String[] compiled) {\n     Compiler compiler = compile(original);\n     assertEquals(\"Expected no warnings or errors\\n\" +\n-        \"Errors: \\n\" + Join.join(\"\\n\", compiler.getErrors()) +\n-        \"Warnings: \\n\" + Join.join(\"\\n\", compiler.getWarnings()),\n+        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n+        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n         0, compiler.getErrors().length + compiler.getWarnings().length);\n \n     Node root = compiler.getRoot().getLastChild();\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n import com.google.javascript.rhino.Node;\n \n     Node root = compiler.parseInputs();\n     assertTrue(\"Unexpected parse error(s): \" +\n-        Join.join(\"\\n\", compiler.getErrors()), root != null);\n+        Joiner.on(\"\\n\").join(compiler.getErrors()), root != null);\n \n     Node externsRoot = root.getFirstChild();\n     Node mainRoot = root.getLastChild();\n \n     if (error == null) {\n       assertEquals(\n-          \"Unexpected error(s): \" + Join.join(\"\\n\", compiler.getErrors()),\n+          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),\n           0, compiler.getErrorCount());\n \n       // Verify the symbol table.\n         assertEquals(expectedSymbolTableError, stErrors[0].getType());\n       } else {\n         assertEquals(\"Unexpected symbol table error(s): \" +\n-            Join.join(\"\\n\", stErrors),\n+            Joiner.on(\"\\n\").join(stErrors),\n             0, stErrors.length);\n       }\n \n       if (warning == null) {\n         assertEquals(\n-            \"Unexpected warning(s): \" + Join.join(\"\\n\", aggregateWarnings),\n+            \"Unexpected warning(s): \" + Joiner.on(\"\\n\").join(aggregateWarnings),\n             0, aggregateWarningCount);\n       } else {\n         assertEquals(\"There should be one warning, repeated \" + numRepetitions +\n             \"\\nResult: \" + compiler.toSource(mainRoot) +\n             \"\\n\" + explanation, explanation);\n       } else if (expected != null) {\n-        assertEquals(Join.join(\"\", expected), compiler.toSource(mainRoot));\n+        assertEquals(\n+            Joiner.on(\"\").join(expected), compiler.toSource(mainRoot));\n       }\n \n       // Verify normalization is not invalidated.\n     compiler.init(externsInputs, inputs, getOptions());\n     Node root = compiler.parseInputs();\n     assertTrue(\"Unexpected parse error(s): \" +\n-        Join.join(\"\\n\", compiler.getErrors()), root != null);\n+        Joiner.on(\"\\n\").join(compiler.getErrors()), root != null);\n     Node externsRoot = root.getFirstChild();\n     Node mainRoot = externsRoot.getNext();\n     // Only run the normalize pass, if asked.\n--- a/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CheckLevel;\n    * Combine source strings using '\\n' as the separator.\n    */\n   private static String newlineJoin(String ... parts) {\n-    return Join.join(\"\\n\", parts);\n+    return Joiner.on(\"\\n\").join(parts);\n   }\n \n   /**\n    * Combine source strings using ';' as the separator.\n    */\n   private static String semicolonJoin(String ... parts) {\n-    return Join.join(\";\", parts);\n+    return Joiner.on(\";\").join(parts);\n   }\n \n   /**\n         if (nameNode != null) {\n           JSType type = node.getJSType();\n           typeInformation.add(\n-              Join.join(\"\",\n+              Joiner.on(\"\").join(\n                         Token.name(node.getType()),\n                         \" \",\n                         nameNode.getQualifiedName(),\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n  */\n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import java.util.Set;\n import java.util.TreeMap;\n import java.util.TreeSet;\n-\n \n /**\n  * Unit test for the Compiler DisambiguateProprties pass.\n \n     Node root = compiler.parseInputs();\n     assertTrue(\"Unexpected parse error(s): \" +\n-        Join.join(\"\\n\", compiler.getErrors()), root != null);\n+        Joiner.on(\"\\n\").join(compiler.getErrors()), root != null);\n \n     Node externsRoot = root.getFirstChild();\n     Node mainRoot = externsRoot.getNext();\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.base.Pair;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.Arrays;\n-\n \n /**\n  * Tests {@link TypeCheck}.\n         \"initializing variable\\n\" +\n         \"found   : Boolean\\n\" +\n         \"required: boolean\");\n+  }\n+\n+  public void testIssue86() throws Exception {\n+    testTypes(\n+        \"/** @interface */ function I() {}\" +\n+        \"/** @return {number} */ I.prototype.get = function(){};\" +\n+        \"/** @constructor \\n * @implements {I} */ function F() {}\" +\n+        \"/** @override */ F.prototype.get = function() { return true; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n   }\n \n   /**\n     externAndJsRoot.setIsSyntheticBlock(true);\n \n     assertEquals(\"parsing error: \" +\n-        Join.join(\", \", compiler.getErrors()), 0, compiler.getErrorCount());\n+        Joiner.on(\", \").join(compiler.getErrors()),\n+        0, compiler.getErrorCount());\n \n     // For processing goog.addDependency for forward typedefs.\n     new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n \n     if (description == null) {\n       assertEquals(\n-          \"unexpected warning(s) : \" + Join.join(\", \", compiler.getWarnings()),\n+          \"unexpected warning(s) : \" +\n+          Joiner.on(\", \").join(compiler.getWarnings()),\n           0, compiler.getWarningCount());\n     } else {\n       assertEquals(1, compiler.getWarningCount());\n           new JSError[errors.length - 1]);\n     }\n     if (errors.length > 0) {\n-      fail(\"unexpected error(s):\\n\" + Join.join(\"\\n\", errors));\n+      fail(\"unexpected error(s):\\n\" + Joiner.on(\"\\n\").join(errors));\n     }\n \n     JSError[] warnings = compiler.getWarnings();\n           new JSError[warnings.length - 1]);\n     }\n     if (warnings.length > 0) {\n-      fail(\"unexpected warnings(s):\\n\" + Join.join(\"\\n\", warnings));\n+      fail(\"unexpected warnings(s):\\n\" + Joiner.on(\"\\n\").join(warnings));\n     }\n   }\n \n     externAndJsRoot.setIsSyntheticBlock(true);\n \n     assertEquals(\"parsing error: \" +\n-        Join.join(\", \", compiler.getErrors()), 0, compiler.getErrorCount());\n+        Joiner.on(\", \").join(compiler.getErrors()),\n+        0, compiler.getErrorCount());\n \n     Scope s = makeTypeCheck().processForTesting(externsNode, n);\n     return new Pair<Node, Scope>(n, s);\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n-import com.google.common.base.Join;\n+import com.google.common.base.Joiner;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState;\n-import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.EnumType;\n import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.StaticSlot;\n-import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n \n     // Parse the body of the function.\n     Node n = compiler.parseTestCode(\"function() {\" + js + \"}\");\n     assertEquals(\"parsing error: \" +\n-        Join.join(\", \", compiler.getErrors()), 0, compiler.getErrorCount());\n+        Joiner.on(\", \").join(compiler.getErrors()),\n+        0, compiler.getErrorCount());\n     n = n.getFirstChild();\n     // Create the scope with the assumptions.\n     Scope assumedScope =", "timestamp": 1262986896, "metainfo": ""}