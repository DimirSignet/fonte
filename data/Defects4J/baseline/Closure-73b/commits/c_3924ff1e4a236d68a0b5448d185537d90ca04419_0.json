{"sha": "3924ff1e4a236d68a0b5448d185537d90ca04419", "log": "Warn about all with statements, unless there's an explicit /** @suppress {with} */ tag  Refactor a bunch of stuff into PassConfigs  Add a bunch of parser tests.  Up-integrate John and Norris' latest changes to Rhino at trunk  Minor type-tightening bug fixes.     ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n *\n  */\n public abstract class AbstractCompiler implements SourceExcerptProvider {\n+  static final DiagnosticType READ_ERROR = DiagnosticType.error(\n+      \"JSC_READ_ERROR\", \"Cannot read: {0}\");\n+\n   // TODO(nicksantos): Decide if all of these are really necessary.\n   // Many of them are just accessors that should be passed to the\n   // CompilerPass's constructor.\n    * Gets the error manager.\n    */\n   abstract public ErrorManager getErrorManager();\n+\n+  /**\n+   * Set if the normalization pass has been done.\n+   * Note: non-private to enable test cases that require the Normalize pass.\n+   */\n+  abstract void setNormalized();\n+\n+  /**\n+   * Set once unnormalizing passes have been start.\n+   * Note: non-private to enable test cases that require the Normalize pass.\n+   */\n+  abstract void setUnnormalized();\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n-import java.io.FileReader;\n import java.io.IOException;\n import java.io.PrintStream;\n import java.io.Serializable;\n-import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n \n   private Map<String, CompilerInput> inputsByName_;\n \n-  /** Fully qualified function names and globally unique ids */\n-  private FunctionNames functionNames_;\n-\n-  /** The variable renaming map */\n-  private VariableMap variableMap_;\n-\n-  /** The property renaming map */\n-  private VariableMap propertyMap_;\n-\n   /** The source code map */\n   private SourceMap sourceMap_;\n \n \n   /** Whether to use threads. */\n   private boolean useThreads = true;\n-\n-  /** The naming map for anonymous functions */\n-  private VariableMap anonFunctionNameMap_;\n \n   /** The function information map */\n   private FunctionInformationMap functionInformationMap_;\n       RhinoErrorReporter.forNewRhino(this);\n \n   /** Error strings used for reporting JSErrors */\n-  public static final DiagnosticType READ_ERROR = DiagnosticType.error(\n-      \"JSC_READ_ERROR\", \"Cannot read: {0}\");\n   public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n       \"JSC_OPTIMIZE_LOOP_ERROR\",\n       \"Exceeded max number of optimization iterations: {0}\");\n   public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n       DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n           \"Exceeded max number of code motion iterations: {0}\");\n-  private static final DiagnosticType INPUT_MAP_PROP_PARSE =\n-      DiagnosticType.error(\"JSC_INPUT_MAP_PROP_PARSE\",\n-          \"Input property map parse error: {0}\");\n-  private static final DiagnosticType INPUT_VAR_PROP_PARSE =\n-      DiagnosticType.error(\"JSC_INPUT_MAP_VAR_PARSE\",\n-          \"Input variable map parse error: {0}\");\n \n   private static final long COMPILER_STACK_SIZE = 1048576L;\n \n     }\n \n     if (options_.nameAnonymousFunctionsOnly) {\n-      nameAnonymousFunctions(options_.anonymousFunctionNaming);\n+      // TODO(nicksantos): Move this into an instrument() phase maybe?\n+      check();\n       return;\n     }\n \n       return;\n     }\n \n-    if (options_.instrumentationTemplate != null ||\n-        options_.recordFunctionInformation) {\n-      computeFunctionNames();\n+    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n+    if (options_.nameAnonymousFunctionsOnly) {\n+      return;\n     }\n \n     if (options_.removeTryCatchFinally) {\n   }\n \n   /**\n-   * Alias string literals with global variables, to avoid creating lots of\n-   * transient objects.\n-   */\n-  private void aliasStrings(Set<String> aliasableStrings,\n-                            boolean aliasAllStrings,\n-                            String aliasStringsBlacklist,\n-                            boolean outputStringUsage) {\n-    logger_.info(\"Aliasing strings\");\n-    startPass(\"aliasStrings\");\n-    AliasStrings aliasStrings = new AliasStrings(\n-        this,\n-        getModuleGraph(),\n-        aliasAllStrings ? null : aliasableStrings,\n-        aliasStringsBlacklist,\n-        outputStringUsage);\n-    process(aliasStrings);\n-    endPass();\n-  }\n-\n-  private void aliasKeywords() {\n-    logger_.info(\"Aliasing true/false/null\");\n-    startPass(\"aliasKeywords\");\n-    AliasKeywords aliasKeywords = new AliasKeywords(this);\n-    process(aliasKeywords);\n-    endPass();\n-  }\n-\n-  /**\n    * Runs custom passes that are designated to run at a particular time.\n    */\n   private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    * Returns the result of the compilation.\n    */\n   public Result getResult() {\n+    PassConfig.State state = getPassConfig().getIntermediateState();\n     return new Result(getErrors(), getWarnings(), debugLog_.toString(),\n-                      variableMap_, propertyMap_, anonFunctionNameMap_,\n-                      functionInformationMap_, sourceMap_, externExports_,\n-                      getPassConfig().getCssNames());\n+        state.variableMap, state.propertyMap,\n+        state.anonymousFunctionNameMap, functionInformationMap_,\n+        sourceMap_, externExports_, state.cssNames);\n   }\n \n   /**\n    * Set if the normalization pass has been done.\n    * Note: non-private to enable test cases that require the Normalize pass.\n    */\n+  @Override\n   void setNormalized() {\n     normalized = true;\n   }\n    * Set once unnormalizing passes have been start.\n    * Note: non-private to enable test cases that require the Normalize pass.\n    */\n+  @Override\n   void setUnnormalized() {\n     normalized = false;\n   }\n     if (hasErrors()) {\n       return;\n     }\n-\n-    if (options_.flowSensitiveInlineVariables) {\n-      flowSensitiveInlineVariables();\n-    }\n-\n-    if (options_.collapseAnonymousFunctions) {\n-      collapseAnonymousFunctions();\n-    }\n-\n-    // Move functions before extracting prototype member declarations.\n-    if (options_.moveFunctionDeclarations) {\n-      moveFunctionDeclarations();\n-    }\n-\n-    if (options_.anonymousFunctionNaming ==\n-        AnonymousFunctionNamingPolicy.MAPPED) {\n-      nameAnonymousFunctions(AnonymousFunctionNamingPolicy.MAPPED);\n-    }\n-\n-    // The mapped name anonymous function pass makes use of information that\n-    // the extract prototype member declarations pass removes so the former\n-    // happens before the latter.\n-    //\n-    // Extracting prototype properties screws up the heuristic renaming\n-    // policies, so never run it when those policies are requested.\n-    if (options_.extractPrototypeMemberDeclarations &&\n-        (options_.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&\n-         options_.propertyRenaming !=\n-            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n-      extractPrototypeMemberDeclarations();\n-    }\n-\n-    if (options_.coalesceVariableNames) {\n-      coalesceVariableNames();\n-    }\n-\n-    VariableMap prevPropertyMap = null;\n-    if (options_.inputPropertyMapSerialized != null) {\n-      try {\n-        prevPropertyMap =\n-            VariableMap.fromBytes(options_.inputPropertyMapSerialized);\n-      } catch (ParseException e) {\n-        report(JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));\n-      }\n-    }\n-\n-    if (options_.ambiguateProperties && (options_.propertyRenaming\n-        == PropertyRenamingPolicy.ALL_UNQUOTED)) {\n-      ambiguateProperties(options_.anonymousFunctionNaming\n-          .getReservedCharacters());\n-    }\n-\n-    switch (options_.propertyRenaming) {\n-      case HEURISTIC:\n-        renamePrototypes(false,\n-            options_.anonymousFunctionNaming,\n-            prevPropertyMap);\n-        break;\n-      case AGGRESSIVE_HEURISTIC:\n-        renamePrototypes(true,\n-            options_.anonymousFunctionNaming,\n-            prevPropertyMap);\n-        break;\n-      case ALL_UNQUOTED:\n-        renameProperties(options_.generatePseudoNames,\n-            options_.anonymousFunctionNaming,\n-            prevPropertyMap);\n-        break;\n-    }\n-\n-    // This comes after property renaming because quoted property names must\n-    // not be renamed.\n-    if (options_.convertToDottedProperties) {\n-      convertToDottedProperties();\n-    }\n-\n-    // Property renaming must happen before this pass runs since this\n-    // pass may convert dotted properties into quoted properties.  It\n-    // is beneficial to run before alias strings, alias keywords and\n-    // variable renaming.\n-    if (options_.rewriteFunctionExpressions) {\n-      rewriteFunctionExpressions();\n-    }\n-\n-    // This comes after converting quoted property accesses to dotted property\n-    // accesses in order to avoid aliasing property names.\n-    if (!options_.aliasableStrings.isEmpty() || options_.aliasAllStrings) {\n-      aliasStrings(options_.aliasableStrings,\n-                   options_.aliasAllStrings,\n-                   options_.aliasStringsBlacklist,\n-                   options_.outputJsStringUsage);\n-    }\n-\n-    if (options_.aliasExternals) {\n-      aliasExternals();\n-    }\n-\n-    if (options_.aliasKeywords) {\n-      aliasKeywords();\n-    }\n-\n-    if (options_.collapseVariableDeclarations) {\n-      collapseVariableDeclarations();\n-    }\n-\n-    denormalize();\n-\n-    if (options_.instrumentationTemplate != null) {\n-      instrumentFunctions();\n-    }\n-\n-    if (options_.variableRenaming != VariableRenamingPolicy.ALL) {\n-      // If we're leaving some (or all) variables with their old names,\n-      // then we need to undo any of the markers we added for distinguishing\n-      // local variables (\"$$1\") or constants (\"$$constant\").\n-      invertContextualRenaming();\n-    }\n-\n-    if (options_.variableRenaming != VariableRenamingPolicy.OFF) {\n-      VariableMap prevVariableMap = null;\n-      if (options_.inputVariableMapSerialized != null) {\n-        try {\n-          prevVariableMap =\n-              VariableMap.fromBytes(options_.inputVariableMapSerialized);\n-        } catch (ParseException e) {\n-          report(JSError.make(INPUT_VAR_PROP_PARSE, e.getMessage()));\n-        }\n-      }\n-\n-      renameVars(options_.renamePrefix,\n-          options_.variableRenaming == VariableRenamingPolicy.LOCAL,\n-          options_.anonymousFunctionNaming,\n-          options_.generatePseudoNames,\n-          prevVariableMap);\n-    }\n-\n-    // This pass should run after names stop changing.\n-    if (options_.processObjectPropertyString) {\n-      objectPropertyStringPostprocess();\n-    }\n-\n-    if (options_.labelRenaming) {\n-      renameLabels();\n-    }\n-\n-    if (options_.anonymousFunctionNaming ==\n-        AnonymousFunctionNamingPolicy.UNMAPPED) {\n-      nameAnonymousFunctions(AnonymousFunctionNamingPolicy.UNMAPPED);\n-    }\n-\n-    // Safety check\n-    if (options_.checkSymbols) {\n-      sanityCheckVars();\n-    }\n   }\n \n   @Override\n   @Override\n   CssRenamingMap getCssRenamingMap() {\n     return options_.cssRenamingMap;\n-  }\n-\n-\n-  /** Checks that all variables are defined. */\n-  void sanityCheckVars() {\n-    logger_.info(\"Checking for undefined vars\");\n-    startPass(\"sanityCheckVars\");\n-    VarCheck v = new VarCheck(this, true);\n-    process(v);\n-    endPass();\n   }\n \n   /**\n   public void processDefines() {\n     (new DefaultPassConfig(options_)).processDefines.create(this)\n         .process(externsRoot, jsRoot);\n-  }\n-\n-  void computeFunctionNames() {\n-    logger_.info(\"Computing fully-qualified function names and ids\");\n-    startPass(\"computeFunctionNames\");\n-    functionNames_ = new FunctionNames(this);\n-    process(functionNames_);\n-    endPass();\n-  }\n-\n-  void flowSensitiveInlineVariables() {\n-    logger_.info(\"Flow Sensitive Inline Variables\");\n-    startPass(\"flowSensitiveInlineVariables\");\n-    process(new FlowSensitiveInlineVariables(this));\n-    endPass();\n-  }\n-\n-  void coalesceVariableNames() {\n-    logger_.info(\"Coalesce Variable Names\");\n-    startPass(\"coalesceVariableNames\");\n-    process(new CoalesceVariableNames(this));\n-    endPass();\n-  }\n-\n-  void collapseVariableDeclarations() {\n-    logger_.info(\"Collapsing variable declarations\");\n-    startPass(\"collapseVariableDeclarations\");\n-    process(new CollapseVariableDeclarations(this));\n-    setUnnormalized();\n-    endPass();\n-  }\n-\n-  void extractPrototypeMemberDeclarations() {\n-    logger_.info(\"Extracting Common Prototype Member Declarations\");\n-    startPass(\"extractPrototypeMemberDeclarations\");\n-    process(new ExtractPrototypeMemberDeclarations(this));\n-    endPass();\n-  }\n-\n-  void rewriteFunctionExpressions() {\n-    logger_.info(\"Rewrite function expressions\");\n-    startPass(\"rewriteFunctionExpressions\");\n-    process(new FunctionRewriter(this));\n-    endPass();\n-  }\n-\n-  void collapseAnonymousFunctions() {\n-    logger_.info(\"Collapsing anonymous functions\");\n-    startPass(\"collapseAnonymousFunctions\");\n-    process(new CollapseAnonymousFunctions(this));\n-    endPass();\n-  }\n-\n-\n-\n-  void moveFunctionDeclarations() {\n-    logger_.info(\"Move function declarations\");\n-    startPass(\"moveFunctionDeclarations\");\n-    process(new MoveFunctionDeclarations(this));\n-    endPass();\n   }\n \n   boolean isInliningForbidden() {\n     return cfa.getCfg();\n   }\n \n-  void nameAnonymousFunctions(AnonymousFunctionNamingPolicy policy) {\n-    logger_.info(\"Naming anonymous functions\");\n-    startPass(\"nameAnonymousFunctions\");\n-    if (policy == AnonymousFunctionNamingPolicy.UNMAPPED) {\n-      process(new NameAnonymousFunctions(this));\n-    } else if (policy == AnonymousFunctionNamingPolicy.MAPPED) {\n-      NameAnonymousFunctionsMapped naf = new NameAnonymousFunctionsMapped(this);\n-      process(naf);\n-      anonFunctionNameMap_ = naf.getFunctionMap();\n-    }\n-    endPass();\n-  }\n-\n-  void aliasExternals() {\n-    logger_.info(\"Creating alias functions for externals\");\n-    startPass(\"aliasExternals\");\n-    AliasExternals ae = new AliasExternals(this,\n-                                           getModuleGraph(),\n-                                           options_.unaliasableGlobals,\n-                                           options_.aliasableGlobals);\n-    process(ae);\n-    endPass();\n-  }\n-\n-  void objectPropertyStringPostprocess() {\n-    logger_.info(\"goog.testing.ObjectPropertyString postprocess\");\n-    startPass(\"ObjectPropertyStringPostprocess\");\n-    process(new ObjectPropertyStringPostprocess(this));\n-    endPass();\n-  }\n-\n-  void ambiguateProperties(char[] reservedCharacters) {\n-    logger_.info(\"Ambiguating properties\");\n-    startPass(\"ambiguateProperties\");\n-    process(new AmbiguateProperties(this, reservedCharacters));\n-    endPass();\n-  }\n-\n   public void normalize() {\n     logger_.info(\"Normalizing\");\n     startPass(\"normalize\");\n     endPass();\n   }\n \n-  private void denormalize() {\n-    logger_.info(\"Denormalizing\");\n-    startPass(\"denormalize\");\n-    process(new Denormalize(this));\n-    setUnnormalized();\n-    endPass();\n-  }\n-\n   @Override\n   void normalizeNodeTypes(Node root) {\n     Tracer tracer = newTracer(\"normalizeNodeTypes\");\n     stopTracer(tracer, \"annotateCodingConvention\");\n   }\n \n-  void renameVars(String renamePrefix, boolean renameLocalVarsOnly,\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\n-      boolean generatePseudoNames,\n-      VariableMap prevVariableMap) {\n-    logger_.info(\"Renaming vars\");\n-    startPass(\"renameVars\");\n-    boolean preserveAnonymousFunctionNames =\n-      anonFunctionNamePolicy != AnonymousFunctionNamingPolicy.OFF;\n-    RenameVars rn = new RenameVars(\n-        this, renamePrefix,\n-        renameLocalVarsOnly, preserveAnonymousFunctionNames,\n-        generatePseudoNames,\n-        prevVariableMap,\n-        anonFunctionNamePolicy.getReservedCharacters(),\n-        getPassConfig().getExportedNames());\n-    process(rn);\n-    variableMap_ = rn.getVariableMap();\n-    endPass();\n-  }\n-\n-  void renameProperties(boolean generatePseudoNames,\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\n-      VariableMap prevPropertyMap) {\n-    logger_.info(\"Renaming properties\");\n-    startPass(\"renameProperties\");\n-    RenameProperties rp = new RenameProperties(\n-        this, generatePseudoNames, prevPropertyMap,\n-        anonFunctionNamePolicy.getReservedCharacters());\n-    process(rp);\n-    propertyMap_ = rp.getPropertyMap();\n-    endPass();\n-  }\n-\n-  void invertContextualRenaming() {\n-    logger_.info(\"Denormalizing local names\");\n-    startPass(\"invertNames\");\n-    process(MakeDeclaredNamesUnique.getContextualRenameInverter(this));\n-    endPass();\n-  }\n-\n-  void renamePrototypes(boolean aggressive,\n-      AnonymousFunctionNamingPolicy anonFunctionNamePolicy,\n-      VariableMap prevPropertyMap) {\n-    logger_.info(\"Renaming prototypes\");\n-    startPass(\"renamePrototypes\");\n-    RenamePrototypes rp = new RenamePrototypes(this, aggressive,\n-        anonFunctionNamePolicy.getReservedCharacters(),\n-        prevPropertyMap);\n-    process(rp);\n-    propertyMap_ = rp.getPropertyMap();\n-    endPass();\n-  }\n-\n-  void renameLabels() {\n-    logger_.info(\"Renaming labels\");\n-    startPass(\"renameLabels\");\n-    RenameLabels rn = new RenameLabels(this);\n-    process(rn);\n-    endPass();\n-  }\n-\n-  void convertToDottedProperties() {\n-    logger_.info(\"Converting quoted property accesses to dot syntax\");\n-    startPass(\"convertToDottedProperties\");\n-    process(new ConvertToDottedProperties(this));\n-    endPass();\n-  }\n-\n-  void instrumentFunctions() {\n-    logger_.info(\"Instrumenting functions\");\n-    startPass(\"instrumentFunctions\");\n-    try {\n-      FileReader templateFile =\n-          new FileReader(options_.instrumentationTemplate);\n-\n-      process(new InstrumentFunctions(this,\n-                                      functionNames_,\n-                                      options_.instrumentationTemplate,\n-                                      options_.appNameStr,\n-                                      templateFile));\n-    } catch (IOException e) {\n-      report(JSError.make(READ_ERROR, options_.instrumentationTemplate));\n-    }\n-    endPass();\n-  }\n-\n   void recordFunctionInformation() {\n     logger_.info(\"Recording function information\");\n     startPass(\"recordFunctionInformation\");\n     RecordFunctionInformation recordFunctionInfoPass =\n-        new RecordFunctionInformation(this, functionNames_);\n+        new RecordFunctionInformation(\n+            this, getPassConfig().getIntermediateState().functionNames);\n     process(recordFunctionInfoPass);\n     functionInformationMap_ = recordFunctionInfoPass.getMap();\n     endPass();\n   }\n \n   VariableMap getVariableMap() {\n-    return variableMap_;\n+    return getPassConfig().getIntermediateState().variableMap;\n   }\n \n   VariableMap getPropertyMap() {\n-    return propertyMap_;\n+    return getPassConfig().getIntermediateState().propertyMap;\n   }\n \n   CompilerOptions getOptions() {\n     private CompilerInput[] externs;\n     private CompilerInput[] inputs;\n     private JSModule[] modules;\n-    private FunctionNames functionNames;\n     private PassConfig.State passConfigState;\n     private JSTypeRegistry typeRegistry;\n     private boolean normalized;\n     state.externs = externs_;\n     state.inputs = inputs_;\n     state.modules = modules_;\n-    state.functionNames = functionNames_;\n     state.passConfigState = getPassConfig().getIntermediateState();\n     state.typeRegistry = typeRegistry;\n     state.normalized = normalized;\n     externs_ = state.externs;\n     inputs_ = state.inputs;\n     modules_ = state.modules;\n-    functionNames_ = state.functionNames;\n     passes = createPassConfigInternal();\n     getPassConfig().setIntermediateState(state.passConfigState);\n     typeRegistry = state.typeRegistry;\n--- a/src/com/google/javascript/jscomp/ControlStructureCheck.java\n+++ b/src/com/google/javascript/jscomp/ControlStructureCheck.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n   static final DiagnosticType INVALID_LABEL_CONTINUE = DiagnosticType.error(\n       \"JSC_INVALID_LABEL_CONTINUE\",\n       \"continue can only target labels of loop structures\");\n+\n+  static final DiagnosticType USE_OF_WITH = DiagnosticType.warning(\n+      \"JSC_USE_OF_WITH\",\n+      \"The use of the 'with' structure should be avoided.\");\n \n   ControlStructureCheck(AbstractCompiler compiler) {\n     this.compiler = compiler;\n    */\n   private void check(Node node, boolean inLoop, boolean inSwitch) {\n     switch (node.getType()) {\n+      case Token.WITH:\n+        JSDocInfo info = node.getJSDocInfo();\n+        boolean allowWith =\n+            info != null && info.getSuppressions().contains(\"with\");\n+        if (!allowWith) {\n+          report(node, USE_OF_WITH);\n+        }\n+        break;\n+\n       case Token.FUNCTION:\n         // Save the old labels because we are in a new scope.\n         Deque<String> oldSwitchLabels = switchLabels;\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Token;\n \n import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n+import java.text.ParseException;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n /**\n  * Pass factories and meta-data for native JSCompiler passes.\n       DiagnosticType.error(\"JSC_REPORT_PATH_IO_ERROR\",\n           \"Error writing compiler report to {0}\");\n \n+  private static final DiagnosticType INPUT_MAP_PROP_PARSE =\n+      DiagnosticType.error(\"JSC_INPUT_MAP_PROP_PARSE\",\n+          \"Input property map parse error: {0}\");\n+\n+  private static final DiagnosticType INPUT_MAP_VAR_PARSE =\n+      DiagnosticType.error(\"JSC_INPUT_MAP_VAR_PARSE\",\n+          \"Input variable map parse error: {0}\");\n+\n   /**\n    * A global namespace to share across checking passes.\n    * TODO(nicksantos): This is a hack until I can get the namespace into\n    */\n   private TightenTypes tightenTypes = null;\n \n+  /** Names exported by goog.exportSymbol. */\n+  private Set<String> exportedNames = null;\n+\n+  /**\n+   * Ids for cross-module method stubbing, so that each method has\n+   * a unique id.\n+   */\n+  private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator =\n+      new CrossModuleMethodMotion.IdGenerator();\n+\n+  /**\n+   * Keys are arguments passed to getCssName() found during compilation; values\n+   * are the number of times the key appeared as an argument to getCssName().\n+   */\n+  private Map<String, Integer> cssNames = null;\n+\n+  /** The variable renaming map */\n+  private VariableMap variableMap = null;\n+\n+  /** The property renaming map */\n+  private VariableMap propertyMap = null;\n+\n+  /** The naming map for anonymous functions */\n+  private VariableMap anonymousFunctionNameMap = null;\n+\n+  /** Fully qualified function names and globally unique ids */\n+  private FunctionNames functionNames = null;\n+\n   public DefaultPassConfig(CompilerOptions options) {\n     super(options);\n+  }\n+\n+  @Override\n+  State getIntermediateState() {\n+    return new State(\n+        cssNames == null ? null : Maps.newHashMap(cssNames),\n+        exportedNames == null ? null :\n+            Collections.unmodifiableSet(exportedNames),\n+        crossModuleIdGenerator, variableMap, propertyMap,\n+        anonymousFunctionNameMap, functionNames);\n+  }\n+\n+  @Override\n+  void setIntermediateState(State state) {\n+    this.cssNames = state.cssNames == null ? null :\n+        Maps.newHashMap(state.cssNames);\n+    this.exportedNames = state.exportedNames == null ? null :\n+        Sets.newHashSet(state.exportedNames);\n+    this.crossModuleIdGenerator = state.crossModuleIdGenerator;\n+    this.variableMap = state.variableMap;\n+    this.propertyMap = state.propertyMap;\n+    this.anonymousFunctionNameMap = state.anonymousFunctionNameMap;\n+    this.functionNames = state.functionNames;\n   }\n \n   @Override\n   protected List<PassFactory> getChecks() {\n     List<PassFactory> checks = Lists.newArrayList();\n+\n+    if (options.nameAnonymousFunctionsOnly) {\n+      if (options.anonymousFunctionNaming ==\n+          AnonymousFunctionNamingPolicy.MAPPED) {\n+        checks.add(nameMappedAnonymousFunctions);\n+      } else if (options.anonymousFunctionNaming ==\n+          AnonymousFunctionNamingPolicy.UNMAPPED) {\n+        checks.add(nameUnmappedAnonymousFunctions);\n+      }\n+      return checks;\n+    }\n \n     if (options.checkSuspiciousCode) {\n       checks.add(suspiciousCode);\n \n     // Defines in code always need to be processed.\n     checks.add(processDefines);\n+\n+    if (options.instrumentationTemplate != null ||\n+        options.recordFunctionInformation) {\n+      checks.add(computeFunctionNames);\n+    }\n+\n     assertAllOneTimePasses(checks);\n     return checks;\n   }\n           CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));\n     }\n \n+    if (options.flowSensitiveInlineVariables) {\n+      passes.add(flowSensitiveInlineVariables);\n+    }\n+\n+    if (options.collapseAnonymousFunctions) {\n+      passes.add(collapseAnonymousFunctions);\n+    }\n+\n+    // Move functions before extracting prototype member declarations.\n+    if (options.moveFunctionDeclarations) {\n+      passes.add(moveFunctionDeclarations);\n+    }\n+\n+    if (options.anonymousFunctionNaming ==\n+        AnonymousFunctionNamingPolicy.MAPPED) {\n+      passes.add(nameMappedAnonymousFunctions);\n+    }\n+\n+    // The mapped name anonymous function pass makes use of information that\n+    // the extract prototype member declarations pass removes so the former\n+    // happens before the latter.\n+    //\n+    // Extracting prototype properties screws up the heuristic renaming\n+    // policies, so never run it when those policies are requested.\n+    if (options.extractPrototypeMemberDeclarations &&\n+        (options.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&\n+         options.propertyRenaming !=\n+            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n+      passes.add(extractPrototypeMemberDeclarations);\n+    }\n+\n+    if (options.coalesceVariableNames) {\n+      passes.add(coalesceVariableNames);\n+    }\n+\n+    if (options.ambiguateProperties &&\n+        (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {\n+      passes.add(ambiguateProperties);\n+    }\n+\n+    if (options.propertyRenaming != PropertyRenamingPolicy.OFF) {\n+      passes.add(renameProperties);\n+    }\n+\n+    // This comes after property renaming because quoted property names must\n+    // not be renamed.\n+    if (options.convertToDottedProperties) {\n+      passes.add(convertToDottedProperties);\n+    }\n+\n+    // Property renaming must happen before this pass runs since this\n+    // pass may convert dotted properties into quoted properties.  It\n+    // is beneficial to run before alias strings, alias keywords and\n+    // variable renaming.\n+    if (options.rewriteFunctionExpressions) {\n+      passes.add(rewriteFunctionExpressions);\n+    }\n+\n+    // This comes after converting quoted property accesses to dotted property\n+    // accesses in order to avoid aliasing property names.\n+    if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {\n+      passes.add(aliasStrings);\n+    }\n+\n+    if (options.aliasExternals) {\n+      passes.add(aliasExternals);\n+    }\n+\n+    if (options.aliasKeywords) {\n+      passes.add(aliasKeywords);\n+    }\n+\n+    if (options.collapseVariableDeclarations) {\n+      passes.add(collapseVariableDeclarations);\n+    }\n+\n+    passes.add(denormalize);\n+\n+    if (options.instrumentationTemplate != null) {\n+      passes.add(instrumentFunctions);\n+    }\n+\n+    if (options.variableRenaming != VariableRenamingPolicy.ALL) {\n+      // If we're leaving some (or all) variables with their old names,\n+      // then we need to undo any of the markers we added for distinguishing\n+      // local variables (\"$$1\") or constants (\"$$constant\").\n+      passes.add(invertContextualRenaming);\n+    }\n+\n+\n+    if (options.variableRenaming != VariableRenamingPolicy.OFF) {\n+      passes.add(renameVars);\n+    }\n+\n+    // This pass should run after names stop changing.\n+    if (options.processObjectPropertyString) {\n+      passes.add(objectPropertyStringPostprocess);\n+    }\n+\n+    if (options.labelRenaming) {\n+      passes.add(renameLabels);\n+    }\n+\n+    if (options.anonymousFunctionNaming ==\n+        AnonymousFunctionNamingPolicy.UNMAPPED) {\n+      passes.add(nameUnmappedAnonymousFunctions);\n+    }\n+\n+    // Safety check\n+    if (options.checkSymbols) {\n+      passes.add(sanityCheckVars);\n+    }\n+\n     return passes;\n   }\n \n         @Override\n         public void process(Node externs, Node root) {\n           pass.process(externs, root);\n-          setExportedNames(pass.getExportedVariableNames());\n+          exportedNames = pass.getExportedVariableNames();\n         }\n       };\n     }\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n-          Map<String, Integer> cssNames = null;\n+          Map<String, Integer> newCssNames = null;\n           if (options.gatherCssNames) {\n-            cssNames = Maps.newHashMap();\n+            newCssNames = Maps.newHashMap();\n           }\n-          (new ReplaceCssNames(compiler, cssNames)).process(\n+          (new ReplaceCssNames(compiler, newCssNames)).process(\n               externs, jsRoot);\n-          setCssNames(cssNames);\n+          cssNames = newCssNames;\n         }\n       };\n     }\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new ConstCheck(compiler);\n+    }\n+  };\n+\n+  /** Computes the names of functions for later analysis. */\n+  private final PassFactory computeFunctionNames =\n+      new PassFactory(\"computeFunctionNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return ((functionNames = new FunctionNames(compiler)));\n     }\n   };\n \n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new CrossModuleMethodMotion(\n-          compiler, getCrossModuleIdGenerator(),\n+          compiler, crossModuleIdGenerator,\n           // Only move properties in externs if we're not treating\n           // them as exports.\n           options.removeUnusedPrototypePropertiesInExterns);\n+    }\n+  };\n+\n+  /** A data-flow based variable inliner. */\n+  private final PassFactory flowSensitiveInlineVariables =\n+      new PassFactory(\"flowSensitiveInlineVariables\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new FlowSensitiveInlineVariables(compiler);\n+    }\n+  };\n+\n+  /** Uses register-allocation algorithms to use fewer variables. */\n+  private final PassFactory coalesceVariableNames =\n+      new PassFactory(\"coalesceVariableNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new CoalesceVariableNames(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Some simple, local collapses (e.g., {@code var x; var y;} becomes\n+   * {@code var x,y;}.\n+   */\n+  private final PassFactory collapseVariableDeclarations =\n+      new PassFactory(\"collapseVariableDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setUnnormalized();\n+      return new CollapseVariableDeclarations(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Extracts common sub-expressions.\n+   */\n+  private final PassFactory extractPrototypeMemberDeclarations =\n+      new PassFactory(\"extractPrototypeMemberDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ExtractPrototypeMemberDeclarations(compiler);\n+    }\n+  };\n+\n+  /** Rewrites common function definitions to be more compact. */\n+  private final PassFactory rewriteFunctionExpressions =\n+      new PassFactory(\"rewriteFunctionExpressions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new FunctionRewriter(compiler);\n+    }\n+  };\n+\n+  /** Collapses functions to not use the VAR keyword. */\n+  private final PassFactory collapseAnonymousFunctions =\n+      new PassFactory(\"collapseAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new CollapseAnonymousFunctions(compiler);\n+    }\n+  };\n+\n+  /** Moves function declarations to the top, to simulate actual hoisting. */\n+  private final PassFactory moveFunctionDeclarations =\n+      new PassFactory(\"moveFunctionDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new MoveFunctionDeclarations(compiler);\n+    }\n+  };\n+\n+  private final PassFactory nameUnmappedAnonymousFunctions =\n+      new PassFactory(\"nameAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new NameAnonymousFunctions(compiler);\n+    }\n+  };\n+\n+  private final PassFactory nameMappedAnonymousFunctions =\n+      new PassFactory(\"nameAnonymousFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          NameAnonymousFunctionsMapped naf =\n+              new NameAnonymousFunctionsMapped(compiler);\n+          naf.process(externs, root);\n+          anonymousFunctionNameMap = naf.getFunctionMap();\n+        }\n+      };\n+    }\n+  };\n+\n+  /** Alias external symbols. */\n+  private final PassFactory aliasExternals =\n+      new PassFactory(\"aliasExternals\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasExternals(compiler, compiler.getModuleGraph(),\n+          options.unaliasableGlobals, options.aliasableGlobals);\n+    }\n+  };\n+\n+  /**\n+   * Alias string literals with global variables, to avoid creating lots of\n+   * transient objects.\n+   */\n+  private final PassFactory aliasStrings =\n+      new PassFactory(\"aliasStrings\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasStrings(\n+          compiler,\n+          compiler.getModuleGraph(),\n+          options.aliasAllStrings ? null : options.aliasableStrings,\n+          options.aliasStringsBlacklist,\n+          options.outputJsStringUsage);\n+    }\n+  };\n+\n+  /** Aliases common keywords (true, false) */\n+  private final PassFactory aliasKeywords =\n+      new PassFactory(\"aliasKeywords\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AliasKeywords(compiler);\n+    }\n+  };\n+\n+  /** Handling for the ObjectPropertyString primitive. */\n+  private final PassFactory objectPropertyStringPostprocess =\n+      new PassFactory(\"ObjectPropertyStringPostprocess\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ObjectPropertyStringPostprocess(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Renames properties so that the two properties that never appear on\n+   * the same object get the same name.\n+   */\n+  private final PassFactory ambiguateProperties =\n+      new PassFactory(\"ambiguateProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new AmbiguateProperties(\n+          compiler, options.anonymousFunctionNaming.getReservedCharacters());\n+    }\n+  };\n+\n+  /** Normalizes the AST for optimizations. */\n+  private final PassFactory normalize =\n+      new PassFactory(\"normalize\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setNormalized();\n+      return new Normalize(compiler, false);\n+    }\n+  };\n+\n+  /** Denormalize the AST for code generation. */\n+  private final PassFactory denormalize =\n+      new PassFactory(\"denormalize\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setUnnormalized();\n+      return new Denormalize(compiler);\n+    }\n+  };\n+\n+  /** Inverting name normalization. */\n+  private final PassFactory invertContextualRenaming =\n+      new PassFactory(\"invertNames\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return MakeDeclaredNamesUnique.getContextualRenameInverter(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Renames properties.\n+   */\n+  private final PassFactory renameProperties =\n+      new PassFactory(\"renameProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      VariableMap map = null;\n+      if (options.inputPropertyMapSerialized != null) {\n+        try {\n+          map = VariableMap.fromBytes(options.inputPropertyMapSerialized);\n+        } catch (ParseException e) {\n+          return new ErrorPass(compiler,\n+              JSError.make(INPUT_MAP_PROP_PARSE, e.getMessage()));\n+        }\n+      }\n+\n+      final VariableMap prevPropertyMap = map;\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          propertyMap = runPropertyRenaming(\n+              compiler, prevPropertyMap, externs, root);\n+        }\n+      };\n+    }\n+  };\n+\n+  private VariableMap runPropertyRenaming(\n+      AbstractCompiler compiler, VariableMap prevPropertyMap,\n+      Node externs, Node root) {\n+    char[] reservedChars =\n+        options.anonymousFunctionNaming.getReservedCharacters();\n+    switch (options.propertyRenaming) {\n+      case HEURISTIC:\n+        RenamePrototypes rproto = new RenamePrototypes(compiler, false,\n+            reservedChars, prevPropertyMap);\n+        rproto.process(externs, root);\n+        return rproto.getPropertyMap();\n+\n+      case AGGRESSIVE_HEURISTIC:\n+        RenamePrototypes rproto2 = new RenamePrototypes(compiler, true,\n+            reservedChars, prevPropertyMap);\n+        rproto2.process(externs, root);\n+        return rproto2.getPropertyMap();\n+\n+      case ALL_UNQUOTED:\n+        RenameProperties rprop = new RenameProperties(\n+            compiler, options.generatePseudoNames, prevPropertyMap,\n+            reservedChars);\n+        rprop.process(externs, root);\n+        return rprop.getPropertyMap();\n+\n+      default:\n+        throw new IllegalStateException(\n+            \"Unrecognized property renaming policy\");\n+    }\n+  }\n+\n+  /** Renames variables. */\n+  private final PassFactory renameVars =\n+      new PassFactory(\"renameVars\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      VariableMap map = null;\n+      if (options.inputVariableMapSerialized != null) {\n+        try {\n+          map = VariableMap.fromBytes(options.inputVariableMapSerialized);\n+        } catch (ParseException e) {\n+          return new ErrorPass(compiler,\n+              JSError.make(INPUT_MAP_VAR_PARSE, e.getMessage()));\n+        }\n+      }\n+\n+      final VariableMap prevVariableMap = map;\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          variableMap = runVariableRenaming(\n+              compiler, prevVariableMap, externs, root);\n+        }\n+      };\n+    }\n+  };\n+\n+  private VariableMap runVariableRenaming(\n+      AbstractCompiler compiler, VariableMap prevVariableMap,\n+      Node externs, Node root) {\n+    char[] reservedChars =\n+        options.anonymousFunctionNaming.getReservedCharacters();\n+    boolean preserveAnonymousFunctionNames =\n+        options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF;\n+    RenameVars rn = new RenameVars(\n+        compiler,\n+        options.renamePrefix,\n+        options.variableRenaming == VariableRenamingPolicy.LOCAL,\n+        preserveAnonymousFunctionNames,\n+        options.generatePseudoNames,\n+        prevVariableMap,\n+        reservedChars,\n+        exportedNames);\n+    rn.process(externs, root);\n+    return rn.getVariableMap();\n+  }\n+\n+  /** Renames labels */\n+  private final PassFactory renameLabels =\n+      new PassFactory(\"renameLabels\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new RenameLabels(compiler);\n+    }\n+  };\n+\n+  /** Convert bracket access to dot access */\n+  private final PassFactory convertToDottedProperties =\n+      new PassFactory(\"convertToDottedProperties\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ConvertToDottedProperties(compiler);\n+    }\n+  };\n+\n+  /** Checks that all variables are defined. */\n+  private final PassFactory sanityCheckVars =\n+      new PassFactory(\"sanityCheckVars\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new VarCheck(compiler, true);\n+    }\n+  };\n+\n+  /** Adds instrumentations according to an instrumentation template. */\n+  private final PassFactory instrumentFunctions =\n+      new PassFactory(\"instrumentFunctions\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          try {\n+            FileReader templateFile =\n+                new FileReader(options.instrumentationTemplate);\n+            (new InstrumentFunctions(\n+                compiler, functionNames,\n+                options.instrumentationTemplate,\n+                options.appNameStr,\n+                templateFile)).process(externs, root);\n+          } catch (IOException e) {\n+            compiler.report(\n+                JSError.make(AbstractCompiler.READ_ERROR,\n+                    options.instrumentationTemplate));\n+          }\n+        }\n+      };\n     }\n   };\n \n   /** A compiler pass that just reports an error. */\n   private static class ErrorPass implements CompilerPass {\n     private final AbstractCompiler compiler;\n-    private final DiagnosticType error;\n+    private final JSError error;\n \n     private ErrorPass(AbstractCompiler compiler, DiagnosticType error) {\n+      this(compiler, JSError.make(error));\n+    }\n+\n+    private ErrorPass(AbstractCompiler compiler, JSError error) {\n       this.compiler = compiler;\n       this.error = error;\n     }\n \n     @Override\n     public void process(Node externs, Node root) {\n-      compiler.report(JSError.make(error));\n+      compiler.report(error);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n       parse(compiler, sourceFile.getName(), sourceFile.getCode());\n     } catch (IOException e) {\n       compiler.report(\n-          JSError.make(Compiler.READ_ERROR, sourceFile.getName()));\n+          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n     }\n   }\n \n           compiler.getDefaultErrorReporter(),\n           logger_);\n     } catch (IOException e) {\n-      compiler.report(JSError.make(Compiler.READ_ERROR, sourceName));\n+      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));\n     }\n \n     if (root == null) {\n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n package com.google.javascript.jscomp;\n \n \n-import com.google.common.collect.Maps;\n-import com.google.common.collect.Sets;\n \n import java.io.Serializable;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n   // Used by subclasses in this package.\n   final CompilerOptions options;\n \n-  /** Names exported by goog.exportSymbol. */\n-  private Set<String> exportedNames = null;\n-\n-  /**\n-   * Ids for cross-module method stubbing, so that each method has\n-   * a unique id.\n-   */\n-  private CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator =\n-      new CrossModuleMethodMotion.IdGenerator();\n-\n   /**\n    * A memoized version of scopeCreator. It must be memoized so that\n    * we can make two separate passes over the AST, one for inferring types\n   /** The global typed scope. */\n   Scope topScope = null;\n \n-  /**\n-   * Keys are arguments passed to getCssName() found during compilation; values\n-   * are the number of times the key appeared as an argument to getCssName().\n-   */\n-  private Map<String, Integer> cssNames = null;\n-\n   public PassConfig(CompilerOptions options) {\n     this.options = options;\n-  }\n-\n-  // Setters and getters for intermediate state.\n-  //\n-  // This makes it possible to start and stop the compiler mid-compile.\n-  // Each getter and setter corresponds to a type of state that is produced\n-  // by an earlier pass and consumed by a later pass. When the compiler is\n-  // stopped mid-compile, the getter should return any state which has\n-  // been produced, and the setter should restore that state when the compiler\n-  // is restarted.\n-  //\n-  // TODO(nicksantos): Perhaps we should just make PassConfig serializable.\n-\n-  /**\n-   * Gets a map of CSS names found in the JS code, to the number of times\n-   * they appear.\n-   */\n-  Map<String, Integer> getCssNames() {\n-    return cssNames == null ? null : Maps.newHashMap(cssNames);\n-  }\n-\n-  /**\n-   * Gets the symbols exported by the passes.\n-   */\n-  Set<String> getExportedNames() {\n-    return exportedNames == null ? null :\n-        Collections.unmodifiableSet(exportedNames);\n-  }\n-\n-  /**\n-   * Gets a generator for cross-module method ids, so that the ids\n-   * are stable across compiled.\n-   */\n-  CrossModuleMethodMotion.IdGenerator getCrossModuleIdGenerator() {\n-    return crossModuleIdGenerator;\n-  }\n-\n-  /**\n-   * Sets the map of CSS names found in the JS code during previous runs.\n-   */\n-  void setCssNames(Map<String, Integer> newVal) {\n-    cssNames = newVal == null ? null : Maps.newHashMap(newVal);\n-  }\n-\n-  /**\n-   * Sets the symbols exported by previous passes.\n-   */\n-  void setExportedNames(Set<String> newVal) {\n-    exportedNames = newVal == null ? null : Sets.newHashSet(newVal);\n   }\n \n   /**\n    * Get intermediate state for a running pass config, so it can\n    * be paused and started again later.\n    */\n-  State getIntermediateState() {\n-    return new State(getCssNames(), getExportedNames(),\n-                     crossModuleIdGenerator);\n-  }\n+  abstract State getIntermediateState();\n \n   /**\n    * Set the intermediate state for a pass config, to restart\n    * a compilation process that had been previously paused.\n    */\n-  void setIntermediateState(State state) {\n-    setCssNames(state.cssNames);\n-    setExportedNames(state.exportedNames);\n-    crossModuleIdGenerator = state.crossModuleIdGenerator;\n-  }\n+  abstract void setIntermediateState(State state);\n \n   /**\n    * An implementation of PassConfig that just proxies all its method calls\n       return delegate.getOptimizations();\n     }\n \n-    @Override Map<String, Integer> getCssNames() {\n-      return delegate.getCssNames();\n-    }\n-\n-    @Override Set<String> getExportedNames() {\n-      return delegate.getExportedNames();\n-    }\n-\n-    @Override void setCssNames(Map<String, Integer> newVal) {\n-      delegate.setCssNames(newVal);\n-    }\n-\n-    @Override void setExportedNames(Set<String> newVal) {\n-      delegate.setExportedNames(newVal);\n-    }\n-\n     @Override ScopeCreator getScopeCreator() {\n       return delegate.getScopeCreator();\n     }\n   static class State implements Serializable {\n     private static final long serialVersionUID = 1L;\n \n-    private final Map<String, Integer> cssNames;\n-    private final Set<String> exportedNames;\n-    private final CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator;\n-\n-    private State(Map<String, Integer> cssNames, Set<String> exportedNames,\n-                  CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator) {\n+    final Map<String, Integer> cssNames;\n+    final Set<String> exportedNames;\n+    final CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator;\n+    final VariableMap variableMap;\n+    final VariableMap propertyMap;\n+    final VariableMap anonymousFunctionNameMap;\n+    final FunctionNames functionNames;\n+\n+    State(Map<String, Integer> cssNames, Set<String> exportedNames,\n+          CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator,\n+          VariableMap variableMap, VariableMap propertyMap,\n+          VariableMap anonymousFunctionNameMap, FunctionNames functionNames) {\n       this.cssNames = cssNames;\n       this.exportedNames = exportedNames;\n       this.crossModuleIdGenerator = crossModuleIdGenerator;\n+      this.variableMap = variableMap;\n+      this.propertyMap = propertyMap;\n+      this.anonymousFunctionNameMap = anonymousFunctionNameMap;\n+      this.functionNames = functionNames;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n   private final Map<ObjectType, ConcreteInstanceType> instanceFromJSType =\n       Maps.newHashMap();\n \n+  /**\n+   * Memoized results of \"createTypeIntersection\" calls.\n+   */\n+  private final Map<ConcreteJSTypePair, ConcreteType> typeIntersectionMemos =\n+      Maps.newHashMap();\n+\n   /** Scope storing the top-level variables and functions. */\n   private ConcreteScope topScope;\n \n       assigns.add(new Assignment((ConcreteSlot) fType.getThisSlot(), thisType));\n       for (int i = 0; i < argTypes.size(); ++i) {\n         ConcreteSlot variable = (ConcreteSlot) fType.getParameterSlot(i);\n-        Preconditions.checkState(variable != null);\n-        assigns.add(new Assignment(variable, argTypes.get(i)));\n+        // TODO(johnlenz): Support \"arguments\" references in function bodies.\n+        // For now, ignore anonymous arguments.\n+        if (variable != null) {\n+          assigns.add(new Assignment(variable, argTypes.get(i)));\n+        }\n       }\n     }\n     return assigns;\n              : recvType.getFunctionInstanceTypes()) {\n           thisType = thisType.unionWith(instType);\n         }\n-        allInstantiatedTypes.add(thisType);\n+        boolean added = allInstantiatedTypes.add(thisType);\n+        if (added) {\n+          // A new type instance invalidates the cached type intersections.\n+          typeIntersectionMemos.clear();\n+        }\n       }\n \n       List<ConcreteType> argTypes = Lists.newArrayList();\n     }\n \n     public Collection<Assignment> getAssignments(ConcreteScope scope) {\n-      ConcreteType thisType = inferConcreteType(scope, firstArgument);\n+      ConcreteType thisType = (firstArgument != null)\n+          ? inferConcreteType(scope, firstArgument)\n+          : getTopScope().getTypeOfThis();\n       ConcreteType recvType = inferConcreteType(scope, receiver);\n \n       if (recvType instanceof ConcreteInstanceType &&\n \n   /** Computes the concrete types that can result from the given expression. */\n   ConcreteType inferConcreteType(ConcreteScope scope, Node expr) {\n+    Preconditions.checkNotNull(scope);\n+    Preconditions.checkNotNull(expr);\n     ConcreteType ret;\n     switch (expr.getType()) {\n       case Token.NAME:\n \n   private ConcreteType createTypeIntersection(\n       ConcreteType concreteType, JSType jsType) {\n-    ConcreteType ret;\n+    // TODO(johnlenz): Even with memoizing all the time of this pass is still \n+    // spent in this function (due to invalidation caused by changes to\n+    // allInstantiatedTypes), specifically calls to ConcreteUnionType.unionWith\n+    ConcreteJSTypePair key = new ConcreteJSTypePair(concreteType, jsType);\n+    ConcreteType ret = typeIntersectionMemos.get(key);\n+    if (ret != null) {\n+      return ret;\n+    }\n+\n     if (jsType == null || jsType.isUnknownType() || concreteType.isNone()) {\n       ret = concreteType;\n     } else if (concreteType.isUnion() || concreteType.isSingleton()) {\n       }\n     }\n \n+    typeIntersectionMemos.put(key, ret);\n     return ret;\n   }\n \n     }\n     return true;\n   }\n+\n+  /**\n+   * A simple class used to pair a concrete type and a js type.  Used to\n+   * memoize the results of a \"createTypeIntersection\" call.\n+   */\n+  static class ConcreteJSTypePair {\n+    final ConcreteType concrete;\n+    final JSType jstype;\n+    final int hashcode;\n+\n+    ConcreteJSTypePair(ConcreteType concrete, JSType jstype) {\n+      this.concrete = concrete;\n+      this.jstype = jstype;\n+      this.hashcode = concrete.hashCode() + getJSTypeHashCode();\n+    }\n+\n+    private int getJSTypeHashCode() {\n+      return jstype != null ? jstype.hashCode() : 0;\n+    }\n+\n+    private boolean equalsJSType(JSType jsType) {\n+      if (jsType == null || jstype == null) {\n+        return jstype == jsType;\n+      } else {\n+        return jsType.equals(this.jstype);\n+      }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof ConcreteJSTypePair) {\n+        ConcreteJSTypePair pair = (ConcreteJSTypePair) o;\n+        if ((pair.concrete.equals(this.concrete)\n+            && equalsJSType(pair.jstype))) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return hashcode;\n+    }\n+  }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/testing/SimpleSourceExcerptProvider.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.testing;\n+\n+import com.google.javascript.jscomp.Region;\n+import com.google.javascript.jscomp.SourceExcerptProvider;\n+import com.google.javascript.jscomp.SourceFile;\n+\n+\n+\n+/**\n+ * A simple source excerpt provider for testing.\n+*\n+ */\n+public class SimpleSourceExcerptProvider implements SourceExcerptProvider {\n+\n+  private final SourceFile sourceFile;\n+\n+  public SimpleSourceExcerptProvider(String source) {\n+    sourceFile = SourceFile.fromCode(\"input\", source);\n+  }\n+\n+  @Override\n+  public String getSourceLine(String sourceName, int lineNumber) {\n+    return sourceFile.getLine(lineNumber);\n+  }\n+\n+  @Override\n+  public Region getSourceRegion(String sourceName, int lineNumber) {\n+    return sourceFile.getRegion(lineNumber);\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/testing/TestErrorReporter.java\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.testing;\n+\n+import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n+import com.google.javascript.jscomp.mozilla.rhino.EvaluatorException;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ * <p>An error reporter for testing that verifies that messages reported to the\n+ * reporter are expected.</p>\n+ *\n+ * <p>Sample use</p>\n+ * <pre>\n+ * TestErrorReporter e =\n+ *   new TestErrorReporter(null, new String[] { \"first warning\" });\n+ * ...\n+ * assertTrue(e.hasEncounteredAllWarnings());\n+ * </pre>\n+ *\n+*\n+ */\n+public final class TestErrorReporter extends Assert implements ErrorReporter {\n+  private final String[] errors;\n+  private final String[] warnings;\n+  private int errorsIndex = 0;\n+  private int warningsIndex = 0;\n+\n+  public TestErrorReporter(String[] errors, String[] warnings) {\n+    this.errors = errors;\n+    this.warnings = warnings;\n+  }\n+\n+  public void error(String message, String sourceName, int line,\n+      String lineSource, int lineOffset) {\n+    if (errors != null && errorsIndex < errors.length) {\n+      assertEquals(errors[errorsIndex++], message);\n+    } else {\n+      fail(\"extra error: \" + message);\n+    }\n+  }\n+\n+  public void warning(String message, String sourceName, int line,\n+      String lineSource, int lineOffset) {\n+    if (warnings != null && warningsIndex < warnings.length) {\n+      assertEquals(warnings[warningsIndex++], message);\n+    } else {\n+      fail(\"extra warning: \" + message);\n+    }\n+  }\n+\n+  public EvaluatorException runtimeError(String message, String sourceName,\n+      int line, String lineSource, int lineOffset) {\n+    return new EvaluatorException(\"JSCompiler test code: \" + message);\n+  }\n+\n+  /**\n+   * Returns whether all warnings were reported to this reporter.\n+   */\n+  public boolean hasEncounteredAllWarnings() {\n+    return (warnings == null) ?\n+        warningsIndex == 0 :\n+        warnings.length == warningsIndex;\n+  }\n+\n+  /**\n+   * Returns whether all errors were reported to this reporter.\n+   */\n+  public boolean hasEncounteredAllErrors() {\n+    return (errors == null) ?\n+        errorsIndex == 0 :\n+        errors.length == errorsIndex;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/ControlStructureCheckTest.java\n+++ b/test/com/google/javascript/jscomp/ControlStructureCheckTest.java\n     assertNoError(\"a:switch(1){case(1):function f(){a:while(1){continue a;}}}\");\n   }\n \n+  public void testUseOfWith1() {\n+    testSame(\"with(a){}\", ControlStructureCheck.USE_OF_WITH);\n+  }\n+\n+  public void testUseOfWith2() {\n+    testSame(\"/** @suppress {with} */\" +\n+             \"with(a){}\");\n+  }\n+\n   private void assertNoError(String js) {\n     testSame(js);\n   }\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     }\n   };\n \n-  // A scope creator that does scope creation and type inference.\n-  private class MyScopeCreator implements ScopeCreator {\n-    private final AbstractCompiler compiler;\n-    private final TypedScopeCreator delegate;\n-\n-    MyScopeCreator(AbstractCompiler compiler) {\n-      this.compiler = compiler;\n-      this.delegate = new TypedScopeCreator(compiler);\n-    }\n-\n-    public Scope createScope(Node root, Scope parent) {\n-      Scope typedScope = delegate.createScope(root, parent);\n-\n-      TypeInference typeInference = new TypeInference(\n-          compiler, computeCfg(root),\n-          compiler.getReverseAbstractInterpreter(), typedScope);\n-      typeInference.analyze();\n-      return typedScope;\n-    }\n-\n-    private ControlFlowGraph<Node> computeCfg(Node n) {\n-      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n-      cfa.process(null, n);\n-      return cfa.getCfg();\n-    }\n-  }\n-\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     registry = compiler.getTypeRegistry();\n     return new CompilerPass() {\n       public void process(Node externs, Node root) {\n+        ScopeCreator scopeCreator =\n+            new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n+        Scope topScope = scopeCreator.createScope(root.getParent(), null);\n+        (new TypeInferencePass(\n+            compiler, compiler.getReverseAbstractInterpreter(),\n+            topScope, scopeCreator)).process(externs, root);\n         NodeTraversal t = new NodeTraversal(\n-            compiler, callback, new MyScopeCreator(compiler));\n+            compiler, callback, scopeCreator);\n         t.traverseRoots(Lists.newArrayList(externs, root));\n       }\n     };\n     assertEquals(\"number\", findNameType(\"x\", globalScope).toString());\n   }\n \n+  public void testAbstractMethod() {\n+    testSame(\n+        \"/** @type {!Function} */ var abstractMethod;\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {number} x */ Foo.prototype.bar = abstractMethod;\");\n+    assertEquals(\n+        \"Function\", findNameType(\"abstractMethod\", globalScope).toString());\n+\n+    FunctionType ctor = (FunctionType) findNameType(\"Foo\", globalScope);\n+    ObjectType instance = ctor.getInstanceType();\n+    assertEquals(\"Foo\", instance.toString());\n+\n+    ObjectType proto = instance.getImplicitPrototype();\n+    assertEquals(\"Foo.prototype\", proto.toString());\n+\n+    assertEquals(\n+        \"function (this:Foo, number): ?\",\n+        proto.getPropertyType(\"bar\").toString());\n+  }\n+\n+  public void testAbstractMethod2() {\n+    testSame(\n+        \"/** @type {!Function} */ var abstractMethod;\" +\n+        \"/** @param {number} x */ var y = abstractMethod;\");\n+    assertEquals(\n+        \"Function\",\n+        findNameType(\"y\", globalScope).toString());\n+    assertEquals(\n+        \"function (number): ?\",\n+        globalScope.getVar(\"y\").getType().toString());\n+  }\n+\n+  public void testAbstractMethod3() {\n+    testSame(\n+        \"/** @type {!Function} */ var abstractMethod;\" +\n+        \"/** @param {number} x */ var y = abstractMethod; y;\");\n+    assertEquals(\n+        \"function (number): ?\",\n+        findNameType(\"y\", globalScope).toString());\n+  }\n+\n   private JSType findNameType(String name, Scope scope) {\n     Node root = scope.getRootNode();\n     Deque<Node> queue = Lists.newLinkedList();\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.parsing;\n+\n+import com.google.javascript.jscomp.mozilla.rhino.CompilerEnvirons;\n+import com.google.javascript.jscomp.mozilla.rhino.Parser;\n+import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;\n+import com.google.javascript.jscomp.testing.TestErrorReporter;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+/**\n+ * Tests {@link IRFactory}.\n+ */\n+public class IRFactoryTest extends BaseJSTypeTestCase {\n+\n+  public void testScript() throws Exception {\n+    parse(\"\");\n+  }\n+\n+  public void testName() throws Exception {\n+    parse(\"a\");\n+  }\n+\n+  public void testArrayLiteral() throws Exception {\n+    parse(\"[a, b]\");\n+  }\n+\n+  public void testArrayLiteral2() throws Exception {\n+    parse(\"[a, , b]\");\n+  }\n+\n+  public void testArrayLiteral3() throws Exception {\n+    parse(\"[a, undefined, b]\");\n+  }\n+\n+  public void testArrayLiteral4() throws Exception {\n+    parse(\"[,,,a,,b]\");\n+  }\n+\n+  public void testAssignment() throws Exception {\n+    parse(\"a = b\");\n+  }\n+\n+  public void testAssignment2() throws Exception {\n+    parse(\"a += b\");\n+  }\n+\n+  public void testInfix() throws Exception {\n+    parse(\"a + b\");\n+  }\n+\n+  public void testScope() throws Exception {\n+    parse(\"{ a; b; c; }\");\n+  }\n+\n+  public void testConditional() throws Exception {\n+    parse(\"a ? b : c\");\n+  }\n+\n+  public void testEmpty() throws Exception {\n+    parse(\";;\");\n+  }\n+\n+  public void testIf() throws Exception {\n+    parse(\"if (a) { b }\");\n+  }\n+\n+  public void testIf2() throws Exception {\n+    parse(\"if (a) { b } else { c }\");\n+  }\n+\n+  public void testNumber() throws Exception {\n+    parse(\"0\");\n+  }\n+\n+  public void testNumber2() throws Exception {\n+    parse(\"1.2\");\n+  }\n+\n+  public void testString() throws Exception {\n+    parse(\"'a'\");\n+  }\n+\n+  public void testString2() throws Exception {\n+    parse(\"\\\"a\\\"\");\n+  }\n+\n+  public void testUnary() throws Exception {\n+    parse(\"-a\");\n+  }\n+\n+  public void testUnary2() throws Exception {\n+    parse(\"a++\");\n+  }\n+\n+  public void testUnary3() throws Exception {\n+    parse(\"++a\");\n+  }\n+\n+  public void testVar() throws Exception {\n+    parse(\"var a = 1\");\n+  }\n+\n+  public void testVar2() throws Exception {\n+    parse(\"var a = 1, b = 2\");\n+  }\n+\n+  public void testVar3() throws Exception {\n+    parse(\"var a, b = 1\");\n+  }\n+\n+  public void testElementGet() throws Exception {\n+    parse(\"a[i]\");\n+  }\n+\n+  public void testPropertyGet() throws Exception {\n+    parse(\"a.b\");\n+  }\n+\n+  public void testRegexp() throws Exception {\n+    parse(\"/ab+c/\");\n+  }\n+\n+  public void testRegexp2() throws Exception {\n+    parse(\"/ab+c/g\");\n+  }\n+\n+  public void testFunctionCall() throws Exception {\n+    parse(\"a()\");\n+  }\n+\n+  public void testFunctionCall2() throws Exception {\n+    parse(\"a(b)\");\n+  }\n+\n+  public void testFunctionCall3() throws Exception {\n+    parse(\"a(b, c)\");\n+  }\n+\n+  public void testNew() throws Exception {\n+    parse(\"new A()\");\n+  }\n+\n+  public void testNew2() throws Exception {\n+    parse(\"new A(b)\");\n+  }\n+\n+  public void testNew3() throws Exception {\n+    parse(\"new A(b, c)\");\n+  }\n+\n+  public void testTry() {\n+    parse(\"try { a(); } catch (e) { b(); }\");\n+  }\n+\n+  public void testTry2() {\n+    parse(\"try { a(); } finally { b(); }\");\n+  }\n+\n+  public void testTry3() {\n+    parse(\"try { a(); } catch (e) { b(); } finally { c(); }\");\n+  }\n+\n+  public void testTry4() {\n+    parse(\"try { a(); }\" +\n+        \"catch (e if e == 'b') { b(); } \" +\n+        \"catch (e if e == 'c') { c(); }\");\n+  }\n+\n+  public void testTry5() {\n+    parse(\"try { a(); }\" +\n+        \"catch (e if e == 'b') { b(); } \" +\n+        \"catch (e if e == 'c') { c(); } \" +\n+        \"catch (e) { d(); } \" +\n+        \"finally { f(); }\");\n+  }\n+\n+  public void testFunction() {\n+    parse(\"function f() {}\");\n+  }\n+\n+  public void testFunction2() {\n+    parse(\"function() {}\");\n+  }\n+\n+  public void testFunction3() {\n+    parse(\"function f(a) {}\");\n+  }\n+\n+  public void testFunction4() {\n+    parse(\"function(a) {}\");\n+  }\n+\n+  public void testFunction5() {\n+    parse(\"function f(a, b) {}\");\n+  }\n+\n+  public void testFunction6() {\n+    parse(\"function(a, b) {}\");\n+  }\n+\n+  public void testReturn() {\n+    parse(\"function() {return 1;}\");\n+  }\n+\n+  public void testReturn2() {\n+    parse(\"function() {return;}\");\n+  }\n+\n+  public void testReturn3() {\n+    parse(\"function(){return x?1:2}\");\n+  }\n+\n+  public void testThrow() {\n+    parse(\"throw e\");\n+  }\n+\n+  public void testWith() {\n+    parse(\"with (a) { b }\");\n+  }\n+\n+  public void testObjectLiteral() {\n+    parse(\"var o = {}\");\n+  }\n+\n+  public void testObjectLiteral2() {\n+    parse(\"var o = {a: 1}\");\n+  }\n+\n+  public void testObjectLiteral3() {\n+    parse(\"var o = {a: 1, b: 2}\");\n+  }\n+\n+  public void testObjectLiteral4() {\n+    parse(\"var o = {1: 'a'}\");\n+  }\n+\n+  public void testObjectLiteral5() {\n+    parse(\"var o = {'a': 'a'}\");\n+  }\n+\n+  public void testKeywordLiteral() {\n+    parse(\"true\");\n+  }\n+\n+  public void testWhile() {\n+    parse(\"while (!a) { a--; }\");\n+  }\n+\n+  public void testParen() {\n+    parse(\"(a)\");\n+  }\n+\n+  public void testParen2() {\n+    parse(\"(1+1)*2\");\n+  }\n+\n+  public void testFor() {\n+    parse(\"for (var i = 0; i < n; i++) { a(i); }\");\n+  }\n+\n+  public void testForIn() {\n+    parse(\"for (i in a) { b(i); }\");\n+  }\n+\n+  public void testBreak() {\n+    parse(\"while (true) { break; }\");\n+  }\n+\n+  public void testContinue() {\n+    parse(\"while (true) { continue; }\");\n+  }\n+\n+  public void testDoLoop() {\n+    parse(\"do { a() } while (b());\");\n+  }\n+\n+  public void testLabel() {\n+    parse(\"foo: bar\");\n+  }\n+\n+  public void testLabel2() {\n+    parse(\"l: while (f()) { if (g()) continue l;}\");\n+  }\n+\n+  public void testLabel3() {\n+    parse(\"Foo:Bar:X:{ break Bar; }\");\n+  }\n+\n+  public void testSwitch() {\n+    parse(\"switch (e) {\" +\n+        \"case 'a': a(); break;\" +\n+        \"case 'b': b();\" +\n+        \"case 'c': c(); }\");\n+  }\n+\n+  public void testSwitch2() {\n+    parse(\"switch (e) { case 'a': a(); break; default: b();}\");\n+  }\n+\n+  public void testSwitch3() {\n+    parse(\"function(){switch(x){default:case 1:return 2}}\");\n+  }\n+\n+  public void testDebugger() {\n+    parse(\"debugger;\");\n+  }\n+\n+  public void testCommentPositions() {\n+    Node root = newParse(\"/** @param {string} x */function a(x) {};\" +\n+        \"/** @param {string} x */function b(x) {}\");\n+    Node a = root.getFirstChild();\n+    Node b = root.getLastChild();\n+    assertMarkerPosition(a, 0, 4);\n+    assertMarkerPosition(b, 0, 45);\n+  }\n+\n+   public void testLiteralLocation() {\n+    Node root = newParse(\n+        \"\\nvar d =\\n\" +\n+        \"    \\\"foo\\\";\\n\" +\n+        \"var e =\\n\" +\n+        \"    1;\\n\" +\n+        \"var f = \\n\" +\n+        \"    1.2;\\n\" +\n+        \"var g = \\n\" +\n+        \"    2e5;\\n\" +\n+        \"var h = \\n\" +\n+        \"    'bar';\\n\");\n+\n+    Node firstStmt = root.getFirstChild();\n+    Node firstLiteral = firstStmt.getFirstChild().getFirstChild();\n+    Node secondStmt = firstStmt.getNext();\n+    Node secondLiteral = secondStmt.getFirstChild().getFirstChild();\n+    Node thirdStmt = secondStmt.getNext();\n+    Node thirdLiteral = thirdStmt.getFirstChild().getFirstChild();\n+    Node fourthStmt = thirdStmt.getNext();\n+    Node fourthLiteral = fourthStmt.getFirstChild().getFirstChild();\n+    Node fifthStmt = fourthStmt.getNext();\n+    Node fifthLiteral = fifthStmt.getFirstChild().getFirstChild();\n+\n+    assertNodePosition(2, 4, firstLiteral);\n+    assertNodePosition(4, 4, secondLiteral);\n+    assertNodePosition(6, 4, thirdLiteral);\n+    assertNodePosition(8, 4, fourthLiteral);\n+    assertNodePosition(10, 4, fifthLiteral);\n+  }\n+\n+  public void testSwitchLocation() {\n+    Node root = newParse(\n+        \"\\nswitch (a) {\\n\" +\n+        \"  //{\\n\" +\n+        \"   case 1:\\n\" +\n+        \"     b++;\\n\" +\n+        \"   case 2:\\n\" +\n+        \"   default:\\n\" +\n+        \"     b--;\\n\" +\n+        \"  }\\n\");\n+\n+    Node switchStmt = root.getFirstChild();\n+    Node switchVar = switchStmt.getFirstChild();\n+    Node firstCase = switchVar.getNext();\n+    Node caseArg = firstCase.getFirstChild();\n+    Node caseBody = caseArg.getNext();\n+    Node caseExprStmt = caseBody.getFirstChild();\n+    Node incrExpr = caseExprStmt.getFirstChild();\n+    Node incrVar = incrExpr.getFirstChild();\n+    Node secondCase = firstCase.getNext();\n+    Node defaultCase = secondCase.getNext();\n+\n+    assertNodePosition(1, 0, switchStmt);\n+    assertNodePosition(1, 8, switchVar);\n+    assertNodePosition(3, 3, firstCase);\n+    assertNodePosition(3, 8, caseArg);\n+    assertNodePosition(3, 3, caseBody);\n+    assertNodePosition(4, 5, caseExprStmt);\n+    assertNodePosition(4, 5, incrExpr);\n+    assertNodePosition(4, 5, incrVar);\n+    assertNodePosition(5, 3, secondCase);\n+    assertNodePosition(6, 3, defaultCase);\n+  }\n+\n+  public void testFunctionParamLocation() {\n+    Node root = newParse(\n+        \"\\nfunction\\n\" +\n+        \"     foo(a,\\n\" +\n+        \"     b,\\n\" +\n+        \"     c)\\n\" +\n+        \"{}\\n\");\n+\n+    Node function = root.getFirstChild();\n+    Node functionName = function.getFirstChild();\n+    Node params = functionName.getNext();\n+    Node param1 = params.getFirstChild();\n+    Node param2 = param1.getNext();\n+    Node param3 = param2.getNext();\n+    Node body = params.getNext();\n+\n+    assertNodePosition(2, 5, function);\n+    assertNodePosition(2, 5, functionName);\n+    // params corresponds to the LP token.\n+    // Can't be on a separate line because of inferred\n+    // semicolons.\n+    assertNodePosition(2, 8, params);\n+    assertNodePosition(2, 9, param1);\n+    assertNodePosition(3, 5, param2);\n+    assertNodePosition(4, 5, param3);\n+    assertNodePosition(5, 0, body);\n+  }\n+\n+  public void testVarDeclLocation() {\n+    Node root = newParse(\n+        \"\\nvar\\n\" +\n+        \"    a =\\n\" +\n+        \"    3\\n\");\n+    Node varDecl = root.getFirstChild();\n+    Node varName = varDecl.getFirstChild();\n+    Node varExpr = varName.getFirstChild();\n+\n+    assertNodePosition(1, 0, varDecl);\n+    assertNodePosition(2, 4, varName);\n+    assertNodePosition(3, 4, varExpr);\n+  }\n+\n+  public void testReturnLocation() {\n+    Node root = newParse(\n+        \"\\nfunction\\n\" +\n+        \"    foo(\\n\" +\n+        \"    a,\\n\" +\n+        \"    b,\\n\" +\n+        \"    c) {\\n\" +\n+        \"    return\\n\" +\n+        \"    4;\\n\" +\n+        \"}\\n\");\n+\n+    Node function = root.getFirstChild();\n+    Node functionName = function.getFirstChild();\n+    Node params = functionName.getNext();\n+    Node body = params.getNext();\n+    Node returnStmt = body.getFirstChild();\n+    Node exprStmt = returnStmt.getNext();\n+    Node returnVal = exprStmt.getFirstChild();\n+\n+    assertNodePosition(6, 4, returnStmt);\n+    assertNodePosition(7, 4, exprStmt);\n+    assertNodePosition(7, 4, returnVal);\n+  }\n+\n+  public void testLinenoFor() {\n+    Node root = newParse(\n+        \"\\nfor(\\n\" +\n+        \";\\n\" +\n+        \";\\n\" +\n+        \") {\\n\" +\n+        \"}\\n\");\n+\n+    Node forNode = root.getFirstChild();\n+    Node initClause= forNode.getFirstChild();\n+    Node condClause = initClause.getNext();\n+    Node incrClause = condClause.getNext();\n+\n+    assertNodePosition(1, 0, forNode);\n+    assertNodePosition(2, 0, initClause);\n+    assertNodePosition(3, 0, condClause);\n+    // TODO(user) Incorrectly gets charno position when EmptyExpression\n+    // has its absolute position on the carriage return.  For now, the\n+    // line number gets reported correctly (on the next line) but the\n+    // character position is -1, so the overall line/char pair in our tree\n+    // is -1.\n+    //assertNodePosition(4, 0, incrClause);\n+  }\n+\n+  public void testBinaryExprLocation() {\n+    Node root = newParse(\n+        \"\\nvar d = a\\n\" +\n+        \"    + \\n\" +\n+        \"    b;\\n\" +\n+        \"var\\n\" +\n+        \"    e =\\n\" +\n+        \"    a +\\n\" +\n+        \"    c;\\n\" +\n+        \"var f = b\\n\" +\n+        \"    / c;\\n\");\n+\n+    Node firstVarDecl = root.getFirstChild();\n+    Node firstVar = firstVarDecl.getFirstChild();\n+    Node firstVarAdd = firstVar.getFirstChild();\n+\n+    Node secondVarDecl = firstVarDecl.getNext();\n+    Node secondVar = secondVarDecl.getFirstChild();\n+    Node secondVarAdd = secondVar.getFirstChild();\n+\n+    Node thirdVarDecl = secondVarDecl.getNext();\n+    Node thirdVar = thirdVarDecl.getFirstChild();\n+    Node thirdVarAdd = thirdVar.getFirstChild();\n+\n+    assertNodePosition(1, 0, firstVarDecl);\n+    assertNodePosition(1, 4, firstVar);\n+    assertNodePosition(2, 4, firstVarAdd);\n+    assertNodePosition(1, 8, firstVarAdd.getFirstChild());\n+    assertNodePosition(3, 4, firstVarAdd.getLastChild());\n+\n+    assertNodePosition(4, 0, secondVarDecl);\n+    assertNodePosition(5, 4, secondVar);\n+    assertNodePosition(6, 6, secondVarAdd);\n+    assertNodePosition(6, 4, secondVarAdd.getFirstChild());\n+    assertNodePosition(7, 4, secondVarAdd.getLastChild());\n+\n+    assertNodePosition(8, 0, thirdVarDecl);\n+    assertNodePosition(8, 4, thirdVar);\n+    assertNodePosition(9, 4, thirdVarAdd);\n+    assertNodePosition(8, 8, thirdVarAdd.getFirstChild());\n+    assertNodePosition(9, 6, thirdVarAdd.getLastChild());\n+  }\n+\n+  public void testPrefixLocation() {\n+    Node root = newParse(\n+         \"\\na++;\\n\" +\n+         \"--\\n\" +\n+         \"b;\\n\");\n+\n+    Node firstStmt = root.getFirstChild();\n+    Node secondStmt = firstStmt.getNext();\n+    Node firstOp = firstStmt.getFirstChild();\n+    Node secondOp = secondStmt.getFirstChild();\n+\n+    assertNodePosition(1, 0, firstOp);\n+    assertNodePosition(2, 0, secondOp);\n+  }\n+\n+  public void testIfLocation() {\n+    Node root = newParse(\n+        \"\\nif\\n\" +\n+        \"  (a == 3)\\n\" +\n+        \"{\\n\" +\n+        \"  b = 0;\\n\" +\n+        \"}\\n\" +\n+        \"  else\\n\" +\n+        \"{\\n\" +\n+        \"  c = 1;\\n\" +\n+        \"}\\n\");\n+\n+    Node ifStmt = root.getFirstChild();\n+    Node eqClause = ifStmt.getFirstChild();\n+    Node thenClause = eqClause.getNext();\n+    Node elseClause = thenClause.getNext();\n+\n+    assertNodePosition(1, 0, ifStmt);\n+    assertNodePosition(2, 5, eqClause);\n+    assertNodePosition(3, 0, thenClause);\n+    assertNodePosition(7, 0, elseClause);\n+  }\n+\n+  public void testTryLocation() {\n+     Node root = newParse(\n+         \"\\ntry {\\n\" +\n+         \"  var x = 1;\\n\" +\n+         \"} catch\\n\" +\n+         \"   (err)\\n\" +\n+         \"{\\n\" +\n+         \"} finally {\\n\" +\n+         \"  var y = 2;\\n\" +\n+         \"}\\n\");\n+\n+    Node tryStmt = root.getFirstChild();\n+    Node tryBlock = tryStmt.getFirstChild();\n+    Node catchBlock = tryBlock.getNext();\n+    Node catchVarBlock = catchBlock.getFirstChild();\n+    Node catchVar = catchVarBlock.getFirstChild();\n+    Node finallyBlock = catchBlock.getNext();\n+    Node finallyStmt = finallyBlock.getFirstChild();\n+\n+    assertNodePosition(1, 0, tryStmt);\n+    assertNodePosition(1, 4, tryBlock);\n+    assertNodePosition(3, 2, catchVarBlock);\n+    assertNodePosition(4, 4, catchVar);\n+    assertNodePosition(3, 0, catchBlock);\n+    assertNodePosition(6, 10, finallyBlock);\n+    assertNodePosition(7, 2, finallyStmt);\n+  }\n+\n+  public void testHookLocation() {\n+    Node root = newParse(\n+        \"\\na\\n\" +\n+        \"?\\n\" +\n+        \"b\\n\" +\n+        \":\\n\" +\n+        \"c\\n\" +\n+        \";\\n\");\n+\n+    Node hookExpr = root.getFirstChild().getFirstChild();\n+    Node condExpr = hookExpr.getFirstChild();\n+    Node thenExpr = condExpr.getNext();\n+    Node elseExpr = thenExpr.getNext();\n+\n+    assertNodePosition(2, 0, hookExpr);\n+    assertNodePosition(1, 0, condExpr);\n+    assertNodePosition(3, 0, thenExpr);\n+    assertNodePosition(5, 0, elseExpr);\n+  }\n+\n+  public void testLabelLocation() {\n+    Node root = newParse(\n+        \"\\nfoo:\\n\" +\n+        \"a = 1;\\n\" +\n+        \"bar:\\n\" +\n+        \"b = 2;\\n\");\n+\n+    Node firstStmt = root.getFirstChild();\n+    Node secondStmt = firstStmt.getNext();\n+\n+    assertNodePosition(1, 0, firstStmt);\n+    assertNodePosition(3, 0, secondStmt);\n+  }\n+\n+  public void testCompareLocation() {\n+    Node root = newParse(\n+        \"\\na\\n\" +\n+        \"<\\n\" +\n+        \"b\\n\");\n+\n+    Node condClause = root.getFirstChild().getFirstChild();\n+    Node lhs = condClause.getFirstChild();\n+    Node rhs = lhs.getNext();\n+\n+    assertNodePosition(2, 0, condClause);\n+    assertNodePosition(1, 0, lhs);\n+    assertNodePosition(3, 0, rhs);\n+   }\n+\n+  public void testEqualityLocation() {\n+    Node root = newParse(\n+        \"\\na\\n\" +\n+        \"==\\n\" +\n+        \"b\\n\");\n+\n+    Node condClause = root.getFirstChild().getFirstChild();\n+    Node lhs = condClause.getFirstChild();\n+    Node rhs = lhs.getNext();\n+\n+    assertNodePosition(2, 0, condClause);\n+    assertNodePosition(1, 0, lhs);\n+    assertNodePosition(3, 0, rhs);\n+  }\n+\n+  public void testPlusEqLocation() {\n+    Node root = newParse(\n+        \"\\na\\n\" +\n+        \"+=\\n\" +\n+        \"b\\n\");\n+\n+    Node condClause = root.getFirstChild().getFirstChild();\n+    Node lhs = condClause.getFirstChild();\n+    Node rhs = lhs.getNext();\n+\n+    assertNodePosition(2, 0, condClause);\n+    assertNodePosition(1, 0, lhs);\n+    assertNodePosition(3, 0, rhs);\n+  }\n+\n+  public void testCommaLocation() {\n+    Node root = newParse(\n+        \"\\na,\\n\" +\n+        \"b,\\n\" +\n+        \"c;\\n\");\n+\n+    Node statement = root.getFirstChild();\n+    Node comma1 = statement.getFirstChild();\n+    Node comma2 = comma1.getFirstChild();\n+    Node cRef = comma2.getNext();\n+    Node aRef = comma2.getFirstChild();\n+    Node bRef = aRef.getNext();\n+\n+    assertNodePosition(1, 1, comma2);\n+    assertNodePosition(1, 0, aRef);\n+    assertNodePosition(2, 0, bRef);\n+    assertNodePosition(3, 0, cRef);\n+  }\n+\n+  public void testRegexpLocation() {\n+    Node root = newParse(\n+        \"\\nvar path =\\n\" +\n+        \"replace(\\n\" +\n+        \"/a/g,\" +\n+        \"'/');\\n\");\n+\n+    Node firstVarDecl = root.getFirstChild();\n+    Node firstVar = firstVarDecl.getFirstChild();\n+    Node firstInitializer = firstVar.getFirstChild();\n+    Node callNode = firstVar.getFirstChild();\n+    Node fnName = callNode.getFirstChild();\n+    Node regexObject = fnName.getNext();\n+    Node aString = regexObject.getFirstChild();\n+    Node endRegexString = regexObject.getNext();\n+\n+    assertNodePosition(1, 0, firstVarDecl);\n+    assertNodePosition(1, 4, firstVar);\n+    assertNodePosition(2, 7, callNode);\n+    assertNodePosition(2, 0, fnName);\n+    assertNodePosition(3, 0, regexObject);\n+    assertNodePosition(3, 0, aString);\n+    assertNodePosition(3, 5, endRegexString);\n+  }\n+\n+  public void testNestedOr() {\n+    Node root = newParse(\n+        \"\\nif (a && \\n\" +\n+        \"    b() || \\n\" +\n+        \"    /* comment */\\n\" +\n+        \"    c) {\\n\" +\n+        \"}\\n\"\n+    );\n+\n+    Node ifStmt = root.getFirstChild();\n+    Node orClause = ifStmt.getFirstChild();\n+    Node andClause = orClause.getFirstChild();\n+    Node cName = andClause.getNext();\n+\n+    assertNodePosition(1, 0, ifStmt);\n+    assertNodePosition(2, 8, orClause);\n+    assertNodePosition(1, 6, andClause);\n+    assertNodePosition(4, 4, cName);\n+\n+  }\n+\n+  public void testBitwiseOps() {\n+      Node root = newParse(\n+        \"\\nif (a & \\n\" +\n+        \"    b() | \\n\" +\n+        \"    /* comment */\\n\" +\n+        \"    c) {\\n\" +\n+        \"}\\n\"\n+    );\n+\n+    Node ifStmt = root.getFirstChild();\n+    Node bitOr = ifStmt.getFirstChild();\n+    Node bitAnd = bitOr.getFirstChild();\n+    Node cName = bitAnd.getNext();\n+\n+    assertNodePosition(1, 0, ifStmt);\n+    assertNodePosition(2, 8, bitOr);\n+    assertNodePosition(1, 6, bitAnd);\n+    assertNodePosition(4, 4, cName);\n+\n+  }\n+\n+  public void testObjectLitLocation() {\n+    Node root = newParse(\n+        \"\\nvar foo =\\n\" +\n+        \"{ \\n\" +\n+        \"'A' : 'A', \\n\" +\n+        \"'B' : 'B', \\n\" +\n+        \"'C' :\\n\" +\n+        \"    'C' \\n\" +\n+        \"};\\n\");\n+\n+    Node firstVarDecl = root.getFirstChild();\n+    Node firstVar = firstVarDecl.getFirstChild();\n+    Node firstObjectLit = firstVar.getFirstChild();\n+    Node firstKey = firstObjectLit.getFirstChild();\n+    Node firstValue = firstKey.getNext();\n+\n+    Node secondKey = firstValue.getNext();\n+    Node secondValue = secondKey.getNext();\n+\n+    Node thirdKey = secondValue.getNext();\n+    Node thirdValue = thirdKey.getNext();\n+\n+    assertNodePosition(1, 4, firstVar);\n+    assertNodePosition(2, 0, firstObjectLit);\n+\n+    assertNodePosition(3, 0, firstKey);\n+    assertNodePosition(3, 6, firstValue);\n+\n+    assertNodePosition(4, 0, secondKey);\n+    assertNodePosition(4, 6, secondValue);\n+\n+    assertNodePosition(5, 0, thirdKey);\n+    assertNodePosition(6, 4, thirdValue);\n+  }\n+\n+  public void testTryWithoutCatchLocation() {\n+     Node root = newParse(\n+         \"\\ntry {\\n\" +\n+         \"  var x = 1;\\n\" +\n+         \"} finally {\\n\" +\n+         \"  var y = 2;\\n\" +\n+         \"}\\n\");\n+\n+    Node tryStmt = root.getFirstChild();\n+    Node tryBlock = tryStmt.getFirstChild();\n+    Node catchBlock = tryBlock.getNext();\n+    Node finallyBlock = catchBlock.getNext();\n+    Node finallyStmt = finallyBlock.getFirstChild();\n+\n+    assertNodePosition(1, 0, tryStmt);\n+    assertNodePosition(1, 4, tryBlock);\n+    assertNodePosition(3, 0, catchBlock);\n+    assertNodePosition(3, 10, finallyBlock);\n+    assertNodePosition(4, 2, finallyStmt);\n+  }\n+\n+  public void testTryWithoutFinallyLocation() {\n+     Node root = newParse(\n+         \"\\ntry {\\n\" +\n+         \"  var x = 1;\\n\" +\n+         \"} catch (ex) {\\n\" +\n+         \"  var y = 2;\\n\" +\n+         \"}\\n\");\n+\n+    Node tryStmt = root.getFirstChild();\n+    Node tryBlock = tryStmt.getFirstChild();\n+    Node catchBlock = tryBlock.getNext();\n+    Node catchStmt = catchBlock.getFirstChild();\n+    Node exceptionVar = catchStmt.getFirstChild();\n+    Node catchCondition = exceptionVar.getNext();\n+    Node exceptionBlock = catchCondition.getNext();\n+    Node varDecl = exceptionBlock.getFirstChild();\n+\n+\n+    assertNodePosition(1, 0, tryStmt);\n+    assertNodePosition(1, 4, tryBlock);\n+    assertNodePosition(3, 0, catchBlock);\n+    assertNodePosition(3, 2, catchStmt);\n+    assertNodePosition(3, 9, exceptionVar);\n+    assertNodePosition(3, 9, catchCondition);\n+    assertNodePosition(3, 13, exceptionBlock);\n+    assertNodePosition(4, 2, varDecl);\n+  }\n+\n+  public void testMultilineEqLocation() {\n+    Node  root = newParse(\n+        \"\\nif\\n\" +\n+        \"    (((a == \\n\" +\n+        \"  3) && \\n\" +\n+        \"  (b == 2)) || \\n\" +\n+        \" (c == 1)) {\\n\" +\n+        \"}\\n\");\n+    Node ifStmt = root.getFirstChild();\n+    Node orTest = ifStmt.getFirstChild();\n+    Node andTest = orTest.getFirstChild();\n+    Node cTest = andTest.getNext();\n+    Node aTest = andTest.getFirstChild();\n+    Node bTest = aTest.getNext();\n+\n+    assertNodePosition(1, 0, ifStmt);\n+    assertNodePosition(4, 12, orTest);\n+    assertNodePosition(3, 5, andTest);\n+    assertNodePosition(2, 9, aTest);\n+    assertNodePosition(4, 5, bTest);\n+    assertNodePosition(5, 4, cTest);\n+  }\n+\n+  public void testMultilineBitTestLocation() {\n+    Node root = newParse(\n+        \"\\nif (\\n\" +\n+        \"      ((a \\n\" +\n+        \"        | 3 \\n\" +\n+        \"       ) == \\n\" +\n+        \"       (b \\n\" +\n+        \"        & 2)) && \\n\" +\n+        \"      ((a \\n\" +\n+        \"         ^ 0xffff) \\n\" +\n+        \"       != \\n\" +\n+        \"       (c \\n\" +\n+        \"        << 1))) {\\n\" +\n+        \"}\\n\");\n+\n+    Node ifStmt = root.getFirstChild();\n+    Node andTest = ifStmt.getFirstChild();\n+    Node eqTest = andTest.getFirstChild();\n+    Node notEqTest = eqTest.getNext();\n+\n+    Node bitOrTest = eqTest.getFirstChild();\n+    Node bitAndTest = bitOrTest.getNext();\n+\n+    Node bitXorTest = notEqTest.getFirstChild();\n+    Node bitShiftTest = bitXorTest.getNext();\n+\n+    assertNodePosition(1, 0, ifStmt);\n+\n+    assertNodePosition(4, 9, eqTest);\n+    assertNodePosition(9, 7, notEqTest);\n+\n+    assertNodePosition(3, 8, bitOrTest);\n+    assertNodePosition(6, 8, bitAndTest);\n+    assertNodePosition(8, 9, bitXorTest);\n+    assertNodePosition(11, 8, bitShiftTest);\n+  }\n+\n+  public void testCallLocation() {\n+    Node root = newParse(\n+        \"\\na.\\n\" +\n+        \"b.\\n\" +\n+        \"cccc(1);\\n\");\n+\n+    Node exprStmt = root.getFirstChild();\n+    Node functionCall = exprStmt.getFirstChild();\n+    Node functionProp = functionCall.getFirstChild();\n+    Node firstNameComponent = functionProp.getFirstChild();\n+    Node lastNameComponent = firstNameComponent.getNext();\n+\n+    assertNodePosition(3, 4, functionCall);\n+    // TODO(user) New Rhino doesn't keep the position of the dot handy.\n+    // New Rhino treats the location of the qualified name as the beginning of\n+    // the whole name.\n+    // assertNodePosition(1, 0, firstNameComponent);\n+    assertNodePosition(3, 0, lastNameComponent);\n+  }\n+\n+  public void testLinenoDeclaration() {\n+    Node root = newParse(\n+        \"\\na.\\n\" +\n+        \"b=\\n\" +\n+        \"function() {};\\n\");\n+\n+    Node exprStmt = root.getFirstChild();\n+    Node fnAssignment =  exprStmt.getFirstChild();\n+    Node aDotbName = fnAssignment.getFirstChild();\n+    Node aName = aDotbName.getFirstChild();\n+    Node bName = aName.getNext();\n+    Node fnNode = aDotbName.getNext();\n+    Node fnName = fnNode.getFirstChild();\n+\n+    assertNodePosition(2, 1, fnAssignment);\n+    // TODO(user) New Rhino doesn't keep track of the position of the dot.\n+    //assertNodePosition(1, 1, aDotbName);\n+    assertNodePosition(1, 0, aName);\n+    assertNodePosition(2, 0, bName);\n+    assertNodePosition(3, 8, fnNode);\n+    assertNodePosition(3, 8, fnName);\n+   }\n+\n+  private void assertMarkerPosition(Node n, int lineno, int charno) {\n+    int count = 0;\n+    for (JSDocInfo.Marker marker : n.getJSDocInfo().getMarkers()) {\n+      assertEquals(lineno, marker.annotation.getStartLine());\n+      assertEquals(charno, marker.annotation.getPositionOnStartLine());\n+      count++;\n+    }\n+    assertEquals(1, count);\n+  }\n+\n+  private void assertNodePosition(int lineno, int charno, Node n) {\n+    assertEquals(\"Line number\", lineno, n.getLineno());\n+    assertEquals(\"Column position\", charno, n.getCharno());\n+  }\n+\n+  private void parse(String string) {\n+    String compare = newParse(string).checkTreeEquals(oldParse(string));\n+    assertTrue(compare, compare == null);\n+  }\n+\n+  private Node newParse(String string) {\n+    CompilerEnvirons environment = new CompilerEnvirons();\n+\n+    environment.setRecordingComments(true);\n+    environment.setRecordingLocalJsDocComments(true);\n+\n+    Parser p = new Parser(environment);\n+    AstRoot script = p.parse(string, null, 0);\n+\n+    Config config = new Config(\n+        registry, ParserRunner.getAnnotationNames(), true);\n+    Node root = IRFactory.transformTree(script, string, config,\n+        new TestErrorReporter(null, null));\n+\n+    return root;\n+  }\n+\n+  private Node oldParse(String string) {\n+    com.google.javascript.rhino.CompilerEnvirons environment =\n+        new com.google.javascript.rhino.CompilerEnvirons();\n+\n+    environment.setParseJSDoc(true);\n+\n+    com.google.javascript.rhino.Parser p =\n+        new com.google.javascript.rhino.Parser(environment, null);\n+\n+    Node root = p.parse(string, null, 0);\n+\n+    return root;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.parsing;\n+\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.mozilla.rhino.CompilerEnvirons;\n+import com.google.javascript.jscomp.mozilla.rhino.Parser;\n+import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;\n+import com.google.javascript.jscomp.mozilla.rhino.ast.Comment;\n+import com.google.javascript.jscomp.testing.TestErrorReporter;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSDocInfo.Visibility;\n+import com.google.javascript.rhino.JSTypeExpression;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.NamedType;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class JsDocInfoParserTest extends BaseJSTypeTestCase {\n+\n+  private Set<String> extraAnnotations;\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    extraAnnotations = Sets.newHashSet(ParserRunner.getAnnotationNames());\n+  }\n+\n+  public void testParseTypeViaStatic1() throws Exception {\n+    Node typeNode = parseType(\"null\");\n+    assertTypeEquals(NULL_TYPE, typeNode);\n+  }\n+\n+  public void testParseTypeViaStatic2() throws Exception {\n+    Node typeNode = parseType(\"string\");\n+    assertTypeEquals(STRING_TYPE, typeNode);\n+  }\n+\n+  public void testParseTypeViaStatic3() throws Exception {\n+    Node typeNode = parseType(\"!Date\");\n+    assertTypeEquals(DATE_TYPE, typeNode);\n+  }\n+\n+  public void testParseTypeViaStatic4() throws Exception {\n+    Node typeNode = parseType(\"boolean|string\");\n+    assertTypeEquals(createUnionType(BOOLEAN_TYPE, STRING_TYPE), typeNode);\n+  }\n+\n+  public void testParseInvalidTypeViaStatic() throws Exception {\n+    Node typeNode = parseType(\"sometype.<anothertype\");\n+    assertNull(typeNode);\n+  }\n+\n+  public void testParseInvalidTypeViaStatic2() throws Exception {\n+    Node typeNode = parseType(\"\");\n+    assertNull(typeNode);\n+  }\n+\n+  public void testParseNamedType1() throws Exception {\n+    assertNull(parse(\"@type null\", \"Unexpected end of file\"));\n+  }\n+\n+  public void testParseNamedType2() throws Exception {\n+    JSDocInfo info = parse(\"@type null*/\");\n+    assertTypeEquals(NULL_TYPE, info.getType());\n+  }\n+\n+  public void testParseNamedType3() throws Exception {\n+    JSDocInfo info = parse(\"@type {string}*/\");\n+    assertTypeEquals(STRING_TYPE, info.getType());\n+  }\n+\n+  public void testParseNamedType4() throws Exception {\n+    // Multi-line @type.\n+    JSDocInfo info = parse(\"@type \\n {string}*/\");\n+    assertTypeEquals(STRING_TYPE, info.getType());\n+  }\n+\n+  public void testTypedefType1() throws Exception {\n+    JSDocInfo info = parse(\"@typedef string */\");\n+    assertTrue(info.hasTypedefType());\n+    assertTypeEquals(STRING_TYPE, info.getTypedefType());\n+  }\n+\n+  public void testTypedefType2() throws Exception {\n+    JSDocInfo info = parse(\"@typedef \\n {string}*/\");\n+    assertTrue(info.hasTypedefType());\n+    assertTypeEquals(STRING_TYPE, info.getTypedefType());\n+  }\n+\n+  public void testTypedefType3() throws Exception {\n+    JSDocInfo info = parse(\"@typedef \\n {(string|number)}*/\");\n+    assertTrue(info.hasTypedefType());\n+    assertTypeEquals(\n+        createUnionType(NUMBER_TYPE, STRING_TYPE),\n+        info.getTypedefType());\n+  }\n+\n+  public void testParseStringType1() throws Exception {\n+    assertTypeEquals(STRING_TYPE, parse(\"@type {string}*/\").getType());\n+  }\n+\n+  public void testParseStringType2() throws Exception {\n+    assertTypeEquals(STRING_OBJECT_TYPE, parse(\"@type {!String}*/\").getType());\n+  }\n+\n+  public void testParseBooleanType1() throws Exception {\n+    assertTypeEquals(BOOLEAN_TYPE, parse(\"@type {boolean}*/\").getType());\n+  }\n+\n+  public void testParseBooleanType2() throws Exception {\n+    assertTypeEquals(BOOLEAN_OBJECT_TYPE, parse(\"@type {!Boolean}*/\").getType());\n+  }\n+\n+  public void testParseNumberType1() throws Exception {\n+    assertTypeEquals(NUMBER_TYPE, parse(\"@type {number}*/\").getType());\n+  }\n+\n+  public void testParseNumberType2() throws Exception {\n+    assertTypeEquals(NUMBER_OBJECT_TYPE, parse(\"@type {!Number}*/\").getType());\n+  }\n+\n+  public void testParseNullType1() throws Exception {\n+    assertTypeEquals(NULL_TYPE, parse(\"@type {null}*/\").getType());\n+  }\n+\n+  public void testParseNullType2() throws Exception {\n+    assertTypeEquals(NULL_TYPE, parse(\"@type {Null}*/\").getType());\n+  }\n+\n+  public void testParseAllType1() throws Exception {\n+    testParseType(\"*\");\n+  }\n+\n+  public void testParseAllType2() throws Exception {\n+    testParseType(\"*?\", \"*\");\n+  }\n+\n+  public void testParseObjectType() throws Exception {\n+    assertTypeEquals(OBJECT_TYPE, parse(\"@type {!Object}*/\").getType());\n+  }\n+\n+  public void testParseDateType() throws Exception {\n+    assertTypeEquals(DATE_TYPE, parse(\"@type {!Date}*/\").getType());\n+  }\n+\n+  public void testParseFunctionType() throws Exception {\n+    assertTypeEquals(\n+        createNullableType(U2U_CONSTRUCTOR_TYPE),\n+        parse(\"@type {Function}*/\").getType());\n+  }\n+\n+  public void testParseRegExpType() throws Exception {\n+    assertTypeEquals(REGEXP_TYPE, parse(\"@type {!RegExp}*/\").getType());\n+  }\n+\n+  public void testParseErrorTypes() throws Exception {\n+    assertTypeEquals(ERROR_TYPE, parse(\"@type {!Error}*/\").getType());\n+    assertTypeEquals(URI_ERROR_TYPE, parse(\"@type {!URIError}*/\").getType());\n+    assertTypeEquals(EVAL_ERROR_TYPE, parse(\"@type {!EvalError}*/\").getType());\n+    assertTypeEquals(REFERENCE_ERROR_TYPE,\n+        parse(\"@type {!ReferenceError}*/\").getType());\n+    assertTypeEquals(TYPE_ERROR_TYPE, parse(\"@type {!TypeError}*/\").getType());\n+    assertTypeEquals(RANGE_ERROR_TYPE, parse(\"@type {!RangeError}*/\").getType());\n+    assertTypeEquals(SYNTAX_ERROR_TYPE, parse(\"@type {!SyntaxError}*/\").getType());\n+  }\n+\n+  public void testParseUndefinedType1() throws Exception {\n+    assertTypeEquals(VOID_TYPE, parse(\"@type {undefined}*/\").getType());\n+  }\n+\n+  public void testParseUndefinedType2() throws Exception {\n+    assertTypeEquals(VOID_TYPE, parse(\"@type {Undefined}*/\").getType());\n+  }\n+\n+  public void testParseUndefinedType3() throws Exception {\n+    assertTypeEquals(VOID_TYPE, parse(\"@type {void}*/\").getType());\n+  }\n+\n+  public void testParseParametrizedType1() throws Exception {\n+    JSDocInfo info = parse(\"@type !Array.<number> */\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType2() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<number>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType3() throws Exception {\n+    JSDocInfo info = parse(\"@type !Array.<(number,null)>*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType4() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<(number|null)>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType5() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<Array.<(number|null)>>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType6() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<!Array.<(number|null)>>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType7() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<function():Date>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType8() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<function():!Date>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType9() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<Date|number>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParametrizedType10() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<Date|number|boolean>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseParamterizedType11() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Object.<number>}*/\");\n+    assertTypeEquals(OBJECT_TYPE, info.getType());\n+    assertParameterTypeEquals(NUMBER_TYPE, info.getType());\n+  }\n+\n+  public void testParseParamterizedType12() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Object.<string,number>}*/\");\n+    assertTypeEquals(OBJECT_TYPE, info.getType());\n+    assertParameterTypeEquals(NUMBER_TYPE, info.getType());\n+    assertIndexTypeEquals(STRING_TYPE, info.getType());\n+  }\n+\n+  public void testParseUnionType1() throws Exception {\n+    JSDocInfo info = parse(\"@type {(boolean,null)}*/\");\n+    assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType2() throws Exception {\n+    JSDocInfo info = parse(\"@type {boolean|null}*/\");\n+    assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType3() throws Exception {\n+    JSDocInfo info = parse(\"@type {boolean||null}*/\");\n+    assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType4() throws Exception {\n+    JSDocInfo info = parse(\"@type {(Array.<boolean>,null)}*/\");\n+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType5() throws Exception {\n+    JSDocInfo info = parse(\"@type {(null, Array.<boolean>)}*/\");\n+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType6() throws Exception {\n+    JSDocInfo info = parse(\"@type {Array.<boolean>|null}*/\");\n+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType7() throws Exception {\n+    JSDocInfo info = parse(\"@type {null|Array.<boolean>}*/\");\n+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType8() throws Exception {\n+    JSDocInfo info = parse(\"@type {null||Array.<boolean>}*/\");\n+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType9() throws Exception {\n+    JSDocInfo info = parse(\"@type {Array.<boolean>||null}*/\");\n+    assertTypeEquals(createUnionType(ARRAY_TYPE, NULL_TYPE), info.getType());\n+  }\n+\n+  public void testParseUnionType10() throws Exception {\n+    parse(\"@type {string|}*/\", \"type not recognized due to syntax error\");\n+  }\n+\n+  public void testParseUnionType11() throws Exception {\n+    parse(\"@type {(string,)}*/\", \"type not recognized due to syntax error\");\n+  }\n+\n+  public void testParseUnionType12() throws Exception {\n+    parse(\"@type {()}*/\", \"type not recognized due to syntax error\");\n+  }\n+\n+  public void testParseUnionType13() throws Exception {\n+    testParseType(\n+        \"(function(this:Date),function(this:String):number)\",\n+        \"(function (this:Date): ?|function (this:String): number)\");\n+  }\n+\n+  public void testParseUnionType14() throws Exception {\n+    testParseType(\n+        \"(function(...[function(number):boolean]):number)|\" +\n+        \"function(this:String, string):number\",\n+        \"(function (...[function (number): boolean]): number|\" +\n+        \"function (this:String, string): number)\");\n+  }\n+\n+  public void testParseUnionType15() throws Exception {\n+    testParseType(\"*|number\", \"*\");\n+  }\n+\n+  public void testParseUnionType16() throws Exception {\n+    testParseType(\"number|*\", \"*\");\n+  }\n+\n+  public void testParseUnionType17() throws Exception {\n+    testParseType(\"string|number|*\", \"*\");\n+  }\n+\n+  public void testParseUnionType18() throws Exception {\n+    testParseType(\"(string,*,number)\", \"*\");\n+  }\n+\n+  public void testParseUnionTypeError1() throws Exception {\n+    parse(\"@type {(string,|number)} */\",\n+        \"type not recognized due to syntax error\");\n+  }\n+\n+  public void testParseFunctionalType1() throws Exception {\n+    testParseType(\"function (): number\");\n+  }\n+\n+  public void testParseFunctionalType2() throws Exception {\n+    testParseType(\"function (number, string): boolean\");\n+  }\n+\n+  public void testParseFunctionalType3() throws Exception {\n+    testParseType(\n+        \"function(this:Array)\", \"function (this:Array): ?\");\n+  }\n+\n+  public void testParseFunctionalType4() throws Exception {\n+    testParseType(\"function (...[number]): boolean\");\n+  }\n+\n+  public void testParseFunctionalType5() throws Exception {\n+    testParseType(\"function (number, ...[string]): boolean\");\n+  }\n+\n+  public void testParseFunctionalType6() throws Exception {\n+    testParseType(\n+        \"function (this:Date, number): (boolean|number|string)\");\n+  }\n+\n+  public void testParseFunctionalType7() throws Exception {\n+    testParseType(\"function()\", \"function (): ?\");\n+  }\n+\n+  public void testParseFunctionalType8() throws Exception {\n+    testParseType(\n+        \"function(this:Array,...[boolean])\",\n+        \"function (this:Array, ...[boolean]): ?\");\n+  }\n+\n+  public void testParseFunctionalType9() throws Exception {\n+    testParseType(\n+        \"function(this:Array,!Date,...[boolean?])\",\n+        \"function (this:Array, Date, ...[(boolean|null)]): ?\");\n+  }\n+\n+  public void testParseFunctionalType10() throws Exception {\n+    testParseType(\n+        \"function(...[Object?]):boolean?\",\n+        \"function (...[(Object|null)]): (boolean|null)\");\n+  }\n+\n+  public void testParseFunctionalType11() throws Exception {\n+    testParseType(\n+        \"function(...[[number]]):[number?]\",\n+        \"function (...[Array]): Array\");\n+  }\n+\n+  public void testParseFunctionalType12() throws Exception {\n+    testParseType(\n+        \"function(...)\",\n+        \"function (...[?]): ?\");\n+  }\n+\n+  public void testParseFunctionalType13() throws Exception {\n+    testParseType(\n+        \"function(...): void\",\n+        \"function (...[?]): undefined\");\n+  }\n+\n+  public void testParseFunctionalType14() throws Exception {\n+    testParseType(\"function (*, string, number): boolean\");\n+  }\n+\n+  public void testBug1419535() throws Exception {\n+    parse(\"@type {function(Object, string, *)?} */\");\n+    parse(\"@type {function(Object, string, *)|null} */\");\n+  }\n+\n+  public void testParseFunctionalTypeError1() throws Exception {\n+    parse(\"@type {function number):string}*/\", \"missing opening (\");\n+  }\n+\n+  public void testParseFunctionalTypeError2() throws Exception {\n+    parse(\"@type {function( number}*/\", \"missing closing )\");\n+  }\n+\n+  public void testParseFunctionalTypeError3() throws Exception {\n+    parse(\"@type {function(...[number], string)}*/\",\n+        \"variable length argument must be last\");\n+  }\n+\n+  public void testParseFunctionalTypeError4() throws Exception {\n+    parse(\"@type {function(string, ...[number], boolean):string}*/\",\n+        \"variable length argument must be last\");\n+  }\n+\n+  public void testParseFunctionalTypeError5() throws Exception {\n+    parse(\"@type {function (thi:Array)}*/\", \"missing closing )\");\n+  }\n+\n+  public void testParseFunctionalTypeError6() throws Exception {\n+    resolve(parse(\"@type {function (this:number)}*/\").getType(),\n+        \"this type must be an object type\");\n+  }\n+\n+  public void testParseFunctionalTypeError7() throws Exception {\n+    parse(\"@type {function(...[number)}*/\", \"missing closing ]\");\n+  }\n+\n+  public void testParseFunctionalTypeError8() throws Exception {\n+    parse(\"@type {function(...number])}*/\", \"missing opening [\");\n+  }\n+\n+  public void testParseArrayType1() throws Exception {\n+    testParseType(\"[number]\", \"Array\");\n+  }\n+\n+  public void testParseArrayType2() throws Exception {\n+    testParseType(\"[(number,boolean,[Object?])]\", \"Array\");\n+  }\n+\n+  public void testParseArrayType3() throws Exception {\n+    testParseType(\"[[number],[string]]?\", \"(Array|null)\");\n+  }\n+\n+  public void testParseArrayTypeError1() throws Exception {\n+    parse(\"@type {[number}*/\", \"missing closing ]\");\n+  }\n+\n+  public void testParseArrayTypeError2() throws Exception {\n+    parse(\"@type {number]}*/\", \"expected closing }\");\n+  }\n+\n+  public void testParseArrayTypeError3() throws Exception {\n+    parse(\"@type {[(number,boolean,Object?])]}*/\", \"missing closing )\");\n+  }\n+\n+  public void testParseArrayTypeError4() throws Exception {\n+    parse(\"@type {(number,boolean,[Object?)]}*/\",\n+        \"missing closing ]\");\n+  }\n+\n+  private void testParseType(String type) throws Exception {\n+    testParseType(type, type);\n+  }\n+\n+  private void testParseType(\n+      String type, String typeExpected) throws Exception {\n+    JSDocInfo info = parse(\"@type {\" + type + \"}*/\");\n+\n+    assertNotNull(info);\n+    assertTrue(info.hasType());\n+    assertEquals(typeExpected, resolve(info.getType()).toString());\n+  }\n+\n+  public void testParseNullableModifiers1() throws Exception {\n+    JSDocInfo info = parse(\"@type {string?}*/\");\n+    assertTypeEquals(createNullableType(STRING_TYPE), info.getType());\n+  }\n+\n+  public void testParseNullableModifiers2() throws Exception {\n+    JSDocInfo info = parse(\"@type {!Array.<string?>}*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseNullableModifiers3() throws Exception {\n+    JSDocInfo info = parse(\"@type {Array.<boolean>?}*/\");\n+    assertTypeEquals(createNullableType(ARRAY_TYPE), info.getType());\n+  }\n+\n+  public void testParseNullableModifiers4() throws Exception {\n+    JSDocInfo info = parse(\"@type {(string,boolean)?}*/\");\n+    assertTypeEquals(\n+        createNullableType(createUnionType(STRING_TYPE, BOOLEAN_TYPE)),\n+        info.getType());\n+  }\n+\n+  public void testParseNullableModifiers5() throws Exception {\n+    JSDocInfo info = parse(\"@type {(string?,boolean)}*/\");\n+    assertTypeEquals(\n+        createUnionType(createNullableType(STRING_TYPE), BOOLEAN_TYPE),\n+        info.getType());\n+  }\n+\n+  public void testParseNullableModifiers6() throws Exception {\n+    JSDocInfo info = parse(\"@type {(string,boolean?)}*/\");\n+    assertTypeEquals(\n+        createUnionType(STRING_TYPE, createNullableType(BOOLEAN_TYPE)),\n+        info.getType());\n+  }\n+\n+  public void testParseNullableModifiers7() throws Exception {\n+    JSDocInfo info = parse(\"@type {string?|boolean}*/\");\n+    assertTypeEquals(\n+        createUnionType(createNullableType(STRING_TYPE), BOOLEAN_TYPE),\n+        info.getType());\n+  }\n+\n+  public void testParseNullableModifiers8() throws Exception {\n+    JSDocInfo info = parse(\"@type {string|boolean?}*/\");\n+    assertTypeEquals(\n+        createUnionType(STRING_TYPE, createNullableType(BOOLEAN_TYPE)),\n+        info.getType());\n+  }\n+\n+  public void testParseNullableModifiers9() throws Exception {\n+    JSDocInfo info = parse(\"@type {foo.Hello.World?}*/\");\n+    assertTypeEquals(createNullableType(new NamedType(\n+        registry, \"foo.Hello.World\", null, -1, -1)),\n+        info.getType());\n+  }\n+\n+  public void testParseOptionalModifier() throws Exception {\n+    JSDocInfo info = parse(\"@type {function(number=)}*/\");\n+    assertTypeEquals(\n+        registry.createFunctionType(\n+            UNKNOWN_TYPE, createUnionType(VOID_TYPE, NUMBER_TYPE)),\n+        info.getType());\n+  }\n+\n+  public void testParseNewline1() throws Exception {\n+    JSDocInfo info = parse(\"@type {string\\n* }\\n*/\");\n+    assertTypeEquals(STRING_TYPE, info.getType());\n+  }\n+\n+  public void testParseNewline2() throws Exception {\n+    JSDocInfo info = parse(\"@type !Array.<\\n* number\\n* > */\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseNewline3() throws Exception {\n+    JSDocInfo info = parse(\"@type !Array.<(number,\\n* null)>*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseNewline4() throws Exception {\n+    JSDocInfo info = parse(\"@type !Array.<(number|\\n* null)>*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseNewline5() throws Exception {\n+    JSDocInfo info = parse(\"@type !Array.<function(\\n* )\\n* :\\n* Date>*/\");\n+    assertTypeEquals(ARRAY_TYPE, info.getType());\n+  }\n+\n+  public void testParseReturnType1() throws Exception {\n+    JSDocInfo info =\n+        parse(\"@return {null|string|Array.<boolean>}*/\");\n+    assertTypeEquals(\n+        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE),\n+        info.getReturnType());\n+  }\n+\n+  public void testParseReturnType2() throws Exception {\n+    JSDocInfo info =\n+        parse(\"@returns {null|(string,Array.<boolean>)}*/\");\n+    assertTypeEquals(\n+        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE),\n+        info.getReturnType());\n+  }\n+\n+  public void testParseReturnType3() throws Exception {\n+    JSDocInfo info =\n+        parse(\"@return {((null||Array.<boolean>,string),boolean)}*/\");\n+    assertTypeEquals(\n+        createUnionType(ARRAY_TYPE, NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE),\n+        info.getReturnType());\n+  }\n+\n+  public void testParseThisType1() throws Exception {\n+    JSDocInfo info =\n+        parse(\"@this {goog.foo.Bar}*/\");\n+    assertTypeEquals(\n+        new NamedType(registry, \"goog.foo.Bar\", null, -1, -1),\n+        info.getThisType());\n+  }\n+\n+  public void testParseThisType2() throws Exception {\n+    JSDocInfo info =\n+        parse(\"@this goog.foo.Bar*/\");\n+    assertTypeEquals(\n+        new NamedType(registry, \"goog.foo.Bar\", null, -1, -1),\n+        info.getThisType());\n+  }\n+\n+  public void testParseThisType3() throws Exception {\n+    parse(\"@type {number}\\n@this goog.foo.Bar*/\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testParseThisType4() throws Exception {\n+    resolve(parse(\"@this number*/\").getThisType(),\n+        \"@this must specify an object type\");\n+  }\n+\n+  public void testParseThisType5() throws Exception {\n+    parse(\"@this {Date|Error}*/\");\n+  }\n+\n+  public void testParseThisType6() throws Exception {\n+    resolve(parse(\"@this {Date|number}*/\").getThisType(),\n+        \"@this must specify an object type\");\n+  }\n+\n+  public void testParseParam1() throws Exception {\n+    JSDocInfo info = parse(\"@param {number} index*/\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(NUMBER_TYPE, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam2() throws Exception {\n+    JSDocInfo info = parse(\"@param index*/\");\n+    assertEquals(1, info.getParameterCount());\n+    assertEquals(null, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam3() throws Exception {\n+    JSDocInfo info = parse(\"@param {number} index useful comments*/\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(NUMBER_TYPE, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam4() throws Exception {\n+    JSDocInfo info = parse(\"@param index useful comments*/\");\n+    assertEquals(1, info.getParameterCount());\n+    assertEquals(null, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam5() throws Exception {\n+    // Test for multi-line @param.\n+    JSDocInfo info = parse(\"@param {number} \\n index */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(NUMBER_TYPE, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam6() throws Exception {\n+    // Test for multi-line @param.\n+    JSDocInfo info = parse(\"@param {number} \\n * index */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(NUMBER_TYPE, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam7() throws Exception {\n+    // Optional @param\n+    JSDocInfo info = parse(\"@param {number=} index */\");\n+    assertTypeEquals(\n+        registry.createOptionalType(NUMBER_TYPE),\n+        info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam8() throws Exception {\n+    // Var args @param\n+    JSDocInfo info = parse(\"@param {...number} index */\");\n+    assertTypeEquals(\n+        registry.createOptionalType(NUMBER_TYPE),\n+        info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam9() throws Exception {\n+    parse(\"@param {...number=} index */\",\n+        \"expected closing }\", \"expecting a variable name in a @param tag\");\n+  }\n+\n+  public void testParseParam10() throws Exception {\n+    parse(\"@param {...number index */\", \"expected closing }\");\n+  }\n+\n+  public void testParseParam11() throws Exception {\n+    parse(\"@param {number= index */\", \"expected closing }\");\n+  }\n+\n+  public void testParseParam12() throws Exception {\n+    JSDocInfo info = parse(\"@param {...number|string} index */\");\n+    assertTypeEquals(\n+        registry.createOptionalType(\n+            registry.createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+        info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam13() throws Exception {\n+    JSDocInfo info = parse(\"@param {...(number|string)} index */\");\n+    assertTypeEquals(\n+        registry.createOptionalType(\n+            registry.createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+        info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam14() throws Exception {\n+    JSDocInfo info = parse(\"@param {string} [index] */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(\n+        registry.createOptionalType(STRING_TYPE),\n+        info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam15() throws Exception {\n+    JSDocInfo info = parse(\"@param {string} [index */\", \"missing closing ]\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(STRING_TYPE, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam16() throws Exception {\n+    JSDocInfo info = parse(\"@param {string} index] */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(STRING_TYPE, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam17() throws Exception {\n+    JSDocInfo info = parse(\"@param {string=} [index] */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(\n+        registry.createOptionalType(STRING_TYPE),\n+        info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseParam18() throws Exception {\n+    JSDocInfo info = parse(\"@param {...string} [index] */\");\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(\n+        registry.createOptionalType(STRING_TYPE),\n+        info.getParameterType(\"index\"));\n+  }\n+\n+  public void testParseThrows1() throws Exception {\n+    JSDocInfo info = parse(\"@throws {number} Some number */\");\n+    assertEquals(1, info.getThrownTypes().size());\n+    assertTypeEquals(NUMBER_TYPE, info.getThrownTypes().get(0));\n+  }\n+\n+  public void testParseThrows2() throws Exception {\n+    JSDocInfo info = parse(\"@throws {number} Some number\\n \"\n+                           + \"*@throws {String} A string */\");\n+    assertEquals(2, info.getThrownTypes().size());\n+    assertTypeEquals(NUMBER_TYPE, info.getThrownTypes().get(0));\n+  }\n+\n+  public void testParseRecordType1() throws Exception {\n+    parseFull(\"/** @param {{x}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType2() throws Exception {\n+    parseFull(\"/** @param {{z, y}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType3() throws Exception {\n+    parseFull(\"/** @param {{z, y, x, q, hello, thisisatest}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType4() throws Exception {\n+    parseFull(\"/** @param {{a, 'a', 'hello', 2, this, do, while, for}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType5() throws Exception {\n+    parseFull(\"/** @param {{x : hello}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType6() throws Exception {\n+    parseFull(\"/** @param {{'x' : hello}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType7() throws Exception {\n+    parseFull(\"/** @param {{'x' : !hello}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType8() throws Exception {\n+    parseFull(\"/** @param {{'x' : !hello, y : bar}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType9() throws Exception {\n+    parseFull(\"/** @param {{'x' : !hello, y : {z : bar, 3 : meh}}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType10() throws Exception {\n+    parseFull(\"/** @param {{__proto__ : moo}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType11() throws Exception {\n+    parseFull(\"/** @param {{a : b} n\\n*/\",\n+              \"expected closing }\");\n+  }\n+\n+  public void testParseRecordType12() throws Exception {\n+    parseFull(\"/** @param {{!hello : hey}} n\\n*/\",\n+              \"type not recognized due to syntax error\");\n+  }\n+\n+  public void testParseRecordType13() throws Exception {\n+    parseFull(\"/** @param {{x}|number} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType14() throws Exception {\n+    parseFull(\"/** @param {{x : y}|number} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType15() throws Exception {\n+    parseFull(\"/** @param {{'x' : y}|number} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType16() throws Exception {\n+    parseFull(\"/** @param {{x, y}|number} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType17() throws Exception {\n+    parseFull(\"/** @param {{x : hello, 'y'}|number} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType18() throws Exception {\n+    parseFull(\"/** @param {number|{x : hello, 'y'}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType19() throws Exception {\n+    parseFull(\"/** @param {?{x : hello, 'y'}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType20() throws Exception {\n+    parseFull(\"/** @param {!{x : hello, 'y'}} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType21() throws Exception {\n+    parseFull(\"/** @param {{x : hello, 'y'}|boolean} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType22() throws Exception {\n+    parseFull(\"/** @param {{x : hello, 'y'}|function()} n\\n*/\");\n+  }\n+\n+  public void testParseRecordType23() throws Exception {\n+    parseFull(\"/** @param {{x : function(), 'y'}|function()} n\\n*/\");\n+  }\n+\n+  public void testParseParamError1() throws Exception {\n+    parseFull(\"/** @param\\n*/\",\n+        \"expecting a variable name in a @param tag\");\n+  }\n+\n+  public void testParseParamError2() throws Exception {\n+    parseFull(\"/** @param {Number}*/\",\n+        \"expecting a variable name in a @param tag\");\n+  }\n+\n+  public void testParseParamError3() throws Exception {\n+    parseFull(\"/** @param {Number}\\n*/\",\n+        \"expecting a variable name in a @param tag\");\n+  }\n+\n+  public void testParseParamError4() throws Exception {\n+    parseFull(\"/** @param {Number}\\n* * num */\",\n+        \"expecting a variable name in a @param tag\");\n+  }\n+\n+  public void testParseParamError5() throws Exception {\n+    parse(\"@param {number} x \\n * @param {string} x */\",\n+        \"duplicate variable name \\\"x\\\"\");\n+  }\n+\n+  public void testParseExtends1() throws Exception {\n+    assertTypeEquals(STRING_OBJECT_TYPE,\n+                     parse(\"@extends String*/\").getBaseType());\n+  }\n+\n+  public void testParseExtends2() throws Exception {\n+    JSDocInfo info = parse(\"@extends com.google.Foo.Bar.Hello.World*/\");\n+    assertTypeEquals(\n+        new NamedType(registry, \"com.google.Foo.Bar.Hello.World\", null, -1, -1),\n+        info.getBaseType());\n+  }\n+\n+  public void testParseExtendsGenerics() throws Exception {\n+    JSDocInfo info =\n+        parse(\"@extends com.google.Foo.Bar.Hello.World.<Boolean,number>*/\");\n+    assertTypeEquals(\n+        new NamedType(registry, \"com.google.Foo.Bar.Hello.World\", null, -1, -1),\n+        info.getBaseType());\n+  }\n+\n+  public void testParseImplementsGenerics() throws Exception {\n+    // we ignore things inside <> for now\n+    List<JSTypeExpression> interfaces =\n+        parse(\"@implements {SomeInterface.<*>} */\")\n+        .getImplementedInterfaces();\n+    assertEquals(1, interfaces.size());\n+    assertTypeEquals(new NamedType(registry, \"SomeInterface\", null, -1, -1),\n+        interfaces.get(0));\n+  }\n+\n+  public void testParseExtends4() throws Exception {\n+    assertTypeEquals(STRING_OBJECT_TYPE,\n+        parse(\"@extends {String}*/\").getBaseType());\n+  }\n+\n+  public void testParseExtends5() throws Exception {\n+    assertTypeEquals(STRING_OBJECT_TYPE,\n+        parse(\"@extends {String*/\", \"expected closing }\").getBaseType());\n+  }\n+\n+  public void testParseExtends6() throws Exception {\n+    // Multi-line extends\n+    assertTypeEquals(STRING_OBJECT_TYPE,\n+        parse(\"@extends \\n * {String}*/\").getBaseType());\n+  }\n+\n+  public void testParseExtendsInvalidName() throws Exception {\n+    // This looks bad, but for the time being it should be ok, as\n+    // we will not find a type with this name in the js parsed tree.\n+    // If this is fixed in the future, change this test to check for a\n+    // warning/error message.\n+    assertTypeEquals(\n+        new NamedType(registry, \"some_++#%$%_UglyString\", null, -1, -1),\n+        parse(\"@extends {some_++#%$%_UglyString} */\").getBaseType());\n+  }\n+\n+  public void testParseExtendsNullable1() throws Exception {\n+    parse(\"@extends {Base?} */\", \"expected closing }\");\n+  }\n+\n+  public void testParseExtendsNullable2() throws Exception {\n+    parse(\"@extends Base? */\", \"expected end of line or comment\");\n+  }\n+\n+  public void testParseEnum1() throws Exception {\n+    assertTypeEquals(NUMBER_TYPE, parse(\"@enum*/\").getEnumParameterType());\n+  }\n+\n+  public void testParseEnum2() throws Exception {\n+    assertTypeEquals(STRING_TYPE,\n+        parse(\"@enum {string}*/\").getEnumParameterType());\n+  }\n+\n+  public void testParseEnum3() throws Exception {\n+    assertTypeEquals(STRING_TYPE,\n+        parse(\"@enum string*/\").getEnumParameterType());\n+  }\n+\n+  public void testParseDesc1() throws Exception {\n+    assertEquals(\"hello world!\",\n+        parse(\"@desc hello world!*/\").getDescription());\n+  }\n+\n+  public void testParseDesc2() throws Exception {\n+    assertEquals(\"hello world!\",\n+        parse(\"@desc hello world!\\n*/\").getDescription());\n+  }\n+\n+  public void testParseDesc3() throws Exception {\n+    assertEquals(\"\", parse(\"@desc*/\").getDescription());\n+  }\n+\n+  public void testParseDesc4() throws Exception {\n+    assertEquals(\"\", parse(\"@desc\\n*/\").getDescription());\n+  }\n+\n+  public void testParseDesc5() throws Exception {\n+    assertEquals(\"hello world!\",\n+                 parse(\"@desc hello\\nworld!\\n*/\").getDescription());\n+  }\n+\n+  public void testParseDesc6() throws Exception {\n+    assertEquals(\"hello world!\",\n+        parse(\"@desc hello\\n* world!\\n*/\").getDescription());\n+  }\n+\n+  public void testParseDesc7() throws Exception {\n+    assertEquals(\"a b c\", parse(\"@desc a\\n\\nb\\nc*/\").getDescription());\n+  }\n+\n+  public void testParseDesc8() throws Exception {\n+    assertEquals(\"a b c d\",\n+        parse(\"@desc a\\n      *b\\n\\n  *c\\n\\nd*/\").getDescription());\n+  }\n+\n+  public void testParseDesc9() throws Exception {\n+    String comment = \"@desc\\n.\\n,\\n{\\n)\\n}\\n|\\n.<\\n>\\n<\\n?\\n~\\n+\\n-\\n;\\n:\\n*/\";\n+\n+    assertEquals(\". , { ) } | .< > < ? ~ + - ; :\",\n+        parse(comment).getDescription());\n+  }\n+\n+  public void testParseDesc10() throws Exception {\n+    String comment = \"@desc\\n?\\n?\\n?\\n?*/\";\n+\n+    assertEquals(\"? ? ? ?\", parse(comment).getDescription());\n+  }\n+\n+  public void testParseDesc11() throws Exception {\n+    String comment = \"@desc :[]*/\";\n+\n+    assertEquals(\":[]\", parse(comment).getDescription());\n+  }\n+\n+  public void testParseDesc12() throws Exception {\n+    String comment = \"@desc\\n:\\n[\\n]\\n...*/\";\n+\n+    assertEquals(\": [ ] ...\", parse(comment).getDescription());\n+  }\n+\n+  //public void testParsePreserveWithNoBuilderGivesWarning() throws Exception {\n+  //  String comment = \"@preserve Foo\\nBar\\n*/\";\n+  //  parse(comment,\n+  //      \"@preserve or @license annotation without file to associate it with\");\n+  //}\n+\n+  //public void testParsePreserve() throws Exception {\n+  //  Node node = new Node(1);\n+  //  this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n+  //  String comment = \"@preserve Foo\\nBar\\n\\nBaz*/\";\n+  //  parse(comment);\n+  //  assertEquals(\" Foo\\n Bar\\n\\n Baz\", node.getJSDocInfo().getLicense());\n+  //}\n+\n+  //public void testParseLicense() throws Exception {\n+  //  Node node = new Node(1);\n+  //  this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n+  //  String comment = \"@license Foo\\nBar\\n\\nBaz*/\";\n+  //  parse(comment);\n+  //  assertEquals(\" Foo\\n Bar\\n\\n Baz\", node.getJSDocInfo().getLicense());\n+  //}\n+\n+  public void testParseDefine1() throws Exception {\n+    assertTypeEquals(STRING_TYPE,\n+        parse(\"@define {string}*/\").getType());\n+  }\n+\n+  public void testParseDefine2() throws Exception {\n+    assertTypeEquals(STRING_TYPE,\n+        parse(\"@define {string*/\", \"expected closing }\").getType());\n+  }\n+\n+  public void testParseDefine3() throws Exception {\n+    JSDocInfo info = parse(\"@define {boolean}*/\");\n+    assertTrue(info.isConstant());\n+    assertTrue(info.isDefine());\n+    assertTypeEquals(BOOLEAN_TYPE, info.getType());\n+  }\n+\n+  public void testParseDefine4() throws Exception {\n+    assertTypeEquals(NUMBER_TYPE, parse(\"@define {number}*/\").getType());\n+  }\n+\n+  public void testParseDefine5() throws Exception {\n+    assertTypeEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE),\n+        parse(\"@define {number|boolean}*/\").getType());\n+  }\n+\n+  public void testParseDefineErrors1() throws Exception {\n+    parse(\"@enum {string}\\n @define {string} */\", \"conflicting @define tag\");\n+  }\n+\n+  public void testParseDefineErrors2() throws Exception {\n+    parse(\"@define {string}\\n @enum {string} */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testParseDefineErrors3() throws Exception {\n+    parse(\"@const\\n @define {string} */\", \"conflicting @define tag\");\n+  }\n+\n+  public void testParseDefineErrors4() throws Exception {\n+    parse(\"@type string \\n @define {string} */\", \"conflicting @define tag\");\n+  }\n+\n+  public void testParseDefineErrors5() throws Exception {\n+    parse(\"@return {string}\\n @define {string} */\", \"conflicting @define tag\");\n+  }\n+\n+  public void testParseDefineErrors6() throws Exception {\n+    parse(\"@define {String}*/\", \"@define tag only permits literal types\");\n+  }\n+\n+  public void testParseDefineErrors7() throws Exception {\n+    parse(\"@define {string}\\n @const */\", \"conflicting @const tag\");\n+  }\n+\n+  public void testParseDefineErrors8() throws Exception {\n+    parse(\"@define {string}\\n @type string */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testParseNoCheck1() throws Exception {\n+    assertTrue(parse(\"@notypecheck*/\").isNoTypeCheck());\n+  }\n+\n+  public void testParseNoCheck2() throws Exception {\n+    parse(\"@notypecheck\\n@notypecheck*/\", \"extra @notypecheck tag\");\n+  }\n+\n+  public void testParseOverride1() throws Exception {\n+    assertTrue(parse(\"@override*/\").isOverride());\n+  }\n+\n+  public void testParseOverride2() throws Exception {\n+    parse(\"@override\\n@override*/\", \"extra @override/@inheritDoc tag\");\n+  }\n+\n+  public void testParseInheritDoc1() throws Exception {\n+    assertTrue(parse(\"@inheritDoc*/\").isOverride());\n+  }\n+\n+  public void testParseInheritDoc2() throws Exception {\n+    parse(\"@override\\n@inheritDoc*/\", \"extra @override/@inheritDoc tag\");\n+  }\n+\n+  public void testParseInheritDoc3() throws Exception {\n+    parse(\"@inheritDoc\\n@inheritDoc*/\", \"extra @override/@inheritDoc tag\");\n+  }\n+\n+  public void testParseNoAlias1() throws Exception {\n+    assertTrue(parse(\"@noalias*/\").isNoAlias());\n+  }\n+\n+  public void testParseNoAlias2() throws Exception {\n+    parse(\"@noalias\\n@noalias*/\", \"extra @noalias tag\");\n+  }\n+\n+  public void testParseDeprecated1() throws Exception {\n+    assertTrue(parse(\"@deprecated*/\").isDeprecated());\n+  }\n+\n+  public void testParseDeprecated2() throws Exception {\n+    parse(\"@deprecated\\n@deprecated*/\", \"extra @deprecated tag\");\n+  }\n+\n+  public void testParseExport1() throws Exception {\n+    assertTrue(parse(\"@export*/\").isExport());\n+  }\n+\n+  public void testParseExport2() throws Exception {\n+    parse(\"@export\\n@export*/\", \"extra @export tag\");\n+  }\n+\n+  public void testParseExterns1() throws Exception {\n+    assertTrue(parseFileOverview(\"@externs*/\").isExterns());\n+  }\n+\n+  public void testParseExterns2() throws Exception {\n+    parseFileOverview(\"@externs\\n@externs*/\", \"extra @externs tag\");\n+  }\n+\n+  public void testParseExterns3() throws Exception {\n+    assertNull(parse(\"@externs*/\"));\n+  }\n+\n+  public void testBugAnnotation() throws Exception {\n+    parse(\"@bug */\");\n+  }\n+\n+  public void testDescriptionAnnotation() throws Exception {\n+    parse(\"@description */\");\n+  }\n+\n+  public void testRegression1() throws Exception {\n+    String comment =\n+        \" * @param {number} index the index of blah\\n\" +\n+        \" * @return {boolean} whatever\\n\" +\n+        \" * @private\\n\" +\n+        \" */\";\n+\n+    JSDocInfo info = parse(comment);\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(NUMBER_TYPE, info.getParameterType(\"index\"));\n+    assertTypeEquals(BOOLEAN_TYPE, info.getReturnType());\n+    assertEquals(Visibility.PRIVATE, info.getVisibility());\n+  }\n+\n+  public void testRegression2() throws Exception {\n+    String comment =\n+        \" * @return {boolean} whatever\\n\" +\n+        \" * but important\\n\" +\n+        \" *\\n\" +\n+        \" * @param {number} index the index of blah\\n\" +\n+        \" * some more comments here\\n\" +\n+        \" * @param name the name of the guy\\n\" +\n+        \" *\\n\" +\n+        \" * @protected\\n\" +\n+        \" */\";\n+\n+    JSDocInfo info = parse(comment);\n+    assertEquals(2, info.getParameterCount());\n+    assertTypeEquals(NUMBER_TYPE, info.getParameterType(\"index\"));\n+    assertEquals(null, info.getParameterType(\"name\"));\n+    assertTypeEquals(BOOLEAN_TYPE, info.getReturnType());\n+    assertEquals(Visibility.PROTECTED, info.getVisibility());\n+  }\n+\n+  public void testRegression3() throws Exception {\n+    String comment =\n+        \" * @param mediaTag this specified whether the @media tag is ....\\n\" +\n+        \" *\\n\" +\n+        \"\\n\" +\n+        \"@public\\n\" +\n+        \" *\\n\" +\n+        \"\\n\" +\n+        \" **********\\n\" +\n+        \" * @final\\n\" +\n+        \" */\";\n+\n+    JSDocInfo info = parse(comment);\n+    assertEquals(1, info.getParameterCount());\n+    assertEquals(null, info.getParameterType(\"mediaTag\"));\n+    assertEquals(Visibility.PUBLIC, info.getVisibility());\n+    assertTrue(info.isConstant());\n+  }\n+\n+  public void testRegression4() throws Exception {\n+    String comment =\n+        \" * @const\\n\" +\n+        \" * @hidden\\n\" +\n+        \" * @preserveTry\\n\" +\n+        \" * @constructor\\n\" +\n+        \" */\";\n+\n+    JSDocInfo info = parse(comment);\n+    assertTrue(info.isConstant());\n+    assertFalse(info.isDefine());\n+    assertTrue(info.isConstructor());\n+    assertTrue(info.isHidden());\n+    assertTrue(info.shouldPreserveTry());\n+  }\n+\n+  public void testRegression5() throws Exception {\n+    String comment = \"@const\\n@enum {string}\\n@public*/\";\n+\n+    JSDocInfo info = parse(comment);\n+    assertTrue(info.isConstant());\n+    assertFalse(info.isDefine());\n+    assertTypeEquals(STRING_TYPE, info.getEnumParameterType());\n+    assertEquals(Visibility.PUBLIC, info.getVisibility());\n+  }\n+\n+  public void testRegression6() throws Exception {\n+    String comment = \"@hidden\\n@enum\\n@public*/\";\n+\n+    JSDocInfo info = parse(comment);\n+    assertTrue(info.isHidden());\n+    assertTypeEquals(NUMBER_TYPE, info.getEnumParameterType());\n+    assertEquals(Visibility.PUBLIC, info.getVisibility());\n+  }\n+\n+  public void testRegression7() throws Exception {\n+    String comment =\n+        \" * @desc description here\\n\" +\n+        \" * @param {boolean} flag and some more description\\n\" +\n+        \" *     nicely formatted\\n\" +\n+        \" */\";\n+\n+    JSDocInfo info = parse(comment);\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(BOOLEAN_TYPE, info.getParameterType(\"flag\"));\n+    assertEquals(\"description here\", info.getDescription());\n+  }\n+\n+  public void testRegression8() throws Exception {\n+    String comment =\n+        \" * @name random tag here\\n\" +\n+        \" * @desc description here\\n\" +\n+        \" *\\n\" +\n+        \" * @param {boolean} flag and some more description\\n\" +\n+        \" *     nicely formatted\\n\" +\n+        \" */\";\n+\n+    JSDocInfo info = parse(comment);\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(BOOLEAN_TYPE, info.getParameterType(\"flag\"));\n+    assertEquals(\"description here\", info.getDescription());\n+  }\n+\n+  public void testRegression9() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @param {string} p0 blah blah blah\\n\" +\n+        \" */\");\n+\n+    assertNull(jsdoc.getBaseType());\n+    assertFalse(jsdoc.isConstant());\n+    assertNull(jsdoc.getDescription());\n+    assertNull(jsdoc.getEnumParameterType());\n+    assertFalse(jsdoc.isHidden());\n+    assertEquals(1, jsdoc.getParameterCount());\n+    assertTypeEquals(STRING_TYPE, jsdoc.getParameterType(\"p0\"));\n+    assertNull(jsdoc.getReturnType());\n+    assertNull(jsdoc.getType());\n+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());\n+  }\n+\n+  public void testRegression10() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @param {!String} p0 blah blah blah\\n\" +\n+        \" * @param {boolean} p1 fobar\\n\" +\n+        \" * @return {!Date} jksjkash dshad\\n\" +\n+        \" */\");\n+\n+    assertNull(jsdoc.getBaseType());\n+    assertFalse(jsdoc.isConstant());\n+    assertNull(jsdoc.getDescription());\n+    assertNull(jsdoc.getEnumParameterType());\n+    assertFalse(jsdoc.isHidden());\n+    assertEquals(2, jsdoc.getParameterCount());\n+    assertTypeEquals(STRING_OBJECT_TYPE, jsdoc.getParameterType(\"p0\"));\n+    assertTypeEquals(BOOLEAN_TYPE, jsdoc.getParameterType(\"p1\"));\n+    assertTypeEquals(DATE_TYPE, jsdoc.getReturnType());\n+    assertNull(jsdoc.getType());\n+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());\n+  }\n+\n+  public void testRegression11() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @constructor\\n\" +\n+        \" */\");\n+\n+    assertNull(jsdoc.getBaseType());\n+    assertFalse(jsdoc.isConstant());\n+    assertNull(jsdoc.getDescription());\n+    assertNull(jsdoc.getEnumParameterType());\n+    assertFalse(jsdoc.isHidden());\n+    assertEquals(0, jsdoc.getParameterCount());\n+    assertNull(jsdoc.getReturnType());\n+    assertNull(jsdoc.getType());\n+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());\n+  }\n+\n+  public void testRegression12() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @extends FooBar\\n\" +\n+        \" */\");\n+\n+    assertTypeEquals(new NamedType(registry, \"FooBar\", null, 0, 0),\n+        jsdoc.getBaseType());\n+    assertFalse(jsdoc.isConstant());\n+    assertNull(jsdoc.getDescription());\n+    assertNull(jsdoc.getEnumParameterType());\n+    assertFalse(jsdoc.isHidden());\n+    assertEquals(0, jsdoc.getParameterCount());\n+    assertNull(jsdoc.getReturnType());\n+    assertNull(jsdoc.getType());\n+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());\n+  }\n+\n+  public void testRegression13() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @type {!RegExp}\\n\" +\n+        \" * @protected\\n\" +\n+        \" */\");\n+\n+    assertNull(jsdoc.getBaseType());\n+    assertFalse(jsdoc.isConstant());\n+    assertNull(jsdoc.getDescription());\n+    assertNull(jsdoc.getEnumParameterType());\n+    assertFalse(jsdoc.isHidden());\n+    assertEquals(0, jsdoc.getParameterCount());\n+    assertNull(jsdoc.getReturnType());\n+    assertTypeEquals(REGEXP_TYPE, jsdoc.getType());\n+    assertEquals(Visibility.PROTECTED, jsdoc.getVisibility());\n+  }\n+\n+  public void testRegression14() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @const\\n\" +\n+        \" * @private\\n\" +\n+        \" */\");\n+\n+    assertNull(jsdoc.getBaseType());\n+    assertTrue(jsdoc.isConstant());\n+    assertNull(jsdoc.getDescription());\n+    assertNull(jsdoc.getEnumParameterType());\n+    assertFalse(jsdoc.isHidden());\n+    assertEquals(0, jsdoc.getParameterCount());\n+    assertNull(jsdoc.getReturnType());\n+    assertNull(jsdoc.getType());\n+    assertEquals(Visibility.PRIVATE, jsdoc.getVisibility());\n+  }\n+\n+  public void testRegression15() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @desc Hello,\\n\" +\n+        \" * World!\\n\" +\n+        \" */\");\n+\n+    assertNull(jsdoc.getBaseType());\n+    assertFalse(jsdoc.isConstant());\n+    assertEquals(\"Hello, World!\", jsdoc.getDescription());\n+    assertNull(jsdoc.getEnumParameterType());\n+    assertFalse(jsdoc.isHidden());\n+    assertEquals(0, jsdoc.getParameterCount());\n+    assertNull(jsdoc.getReturnType());\n+    assertNull(jsdoc.getType());\n+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());\n+    assertFalse(jsdoc.isExport());\n+  }\n+\n+  public void testRegression16() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" Email is plp@foo.bar\\n\" +\n+        \" @type {string}\\n\" +\n+        \" */\");\n+\n+    assertNull(jsdoc.getBaseType());\n+    assertFalse(jsdoc.isConstant());\n+    assertTypeEquals(STRING_TYPE, jsdoc.getType());\n+    assertFalse(jsdoc.isHidden());\n+    assertEquals(0, jsdoc.getParameterCount());\n+    assertNull(jsdoc.getReturnType());\n+    assertEquals(Visibility.INHERITED, jsdoc.getVisibility());\n+  }\n+\n+  public void testRegression17() throws Exception {\n+    // verifying that if no @desc is present the description is empty\n+    assertNull(parse(\"@private*/\").getDescription());\n+  }\n+\n+  public void testFullRegression1() throws Exception {\n+    parseFull(\"/** @param (string,number) foo*/function bar(foo){}\",\n+        \"expecting a variable name in a @param tag\");\n+  }\n+\n+  public void testFullRegression2() throws Exception {\n+    parseFull(\"/** @param {string,number) foo*/function bar(foo){}\",\n+        \"expected closing }\",\n+        \"expecting a variable name in a @param tag\");\n+  }\n+\n+  public void testFullRegression3() throws Exception {\n+    parseFull(\"/**..\\n*/\");\n+  }\n+\n+  public void testBug907488() throws Exception {\n+    parse(\"@type {number,null} */\",\n+        \"expected closing }\");\n+  }\n+\n+  public void testBug907494() throws Exception {\n+    parse(\"@return {Object,undefined} */\",\n+        \"expected closing }\");\n+  }\n+\n+  public void testBug909468() throws Exception {\n+    parse(\"@extends {(x)}*/\",\n+        \"expecting a type name\");\n+  }\n+\n+  public void testParseInterface() throws Exception {\n+    assertTrue(parse(\"@interface*/\").isInterface());\n+  }\n+\n+  public void testParseImplicitCast1() throws Exception {\n+    assertTrue(parse(\"@type {string} \\n * @implicitCast*/\").isImplicitCast());\n+  }\n+\n+  public void testParseImplicitCast2() throws Exception {\n+    assertFalse(parse(\"@type {string}*/\").isImplicitCast());\n+  }\n+\n+  public void testParseDuplicateImplicitCast() throws Exception {\n+    parse(\"@type {string} \\n * @implicitCast \\n * @implicitCast*/\",\n+          \"extra @implicitCast tag\");\n+  }\n+\n+  public void testParseInterfaceDoubled() throws Exception {\n+    parse(\n+        \"* @interface\\n\" +\n+        \"* @interface\\n\" +\n+        \"*/\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testParseImplements() throws Exception {\n+    List<JSTypeExpression> interfaces = parse(\"@implements {SomeInterface}*/\")\n+        .getImplementedInterfaces();\n+    assertEquals(1, interfaces.size());\n+    assertTypeEquals(new NamedType(registry, \"SomeInterface\", null, -1, -1),\n+        interfaces.get(0));\n+  }\n+\n+  public void testParseImplementsTwo() throws Exception {\n+    List<JSTypeExpression> interfaces =\n+        parse(\n+            \"* @implements {SomeInterface1}\\n\" +\n+            \"* @implements {SomeInterface2}\\n\" +\n+            \"*/\")\n+        .getImplementedInterfaces();\n+    assertEquals(2, interfaces.size());\n+    assertTypeEquals(new NamedType(registry, \"SomeInterface1\", null, -1, -1),\n+        interfaces.get(0));\n+    assertTypeEquals(new NamedType(registry, \"SomeInterface2\", null, -1, -1),\n+        interfaces.get(1));\n+  }\n+\n+  public void testParseImplementsSameTwice() throws Exception {\n+    parse(\n+        \"* @implements {Smth}\\n\" +\n+        \"* @implements {Smth}\\n\" +\n+        \"*/\",\n+        \"duplicate @implements tag\");\n+  }\n+\n+  public void testParseImplementsNoName() throws Exception {\n+    parse(\"* @implements {} */\",\n+        \"expecting a type name\");\n+  }\n+\n+  public void testParseImplementsMissingRC() throws Exception {\n+    parse(\"* @implements {Smth */\",\n+        \"expected closing }\");\n+  }\n+\n+  public void testParseImplementsNullable1() throws Exception {\n+    parse(\"@implements {Base?} */\", \"expected closing }\");\n+  }\n+\n+  public void testParseImplementsNullable2() throws Exception {\n+    parse(\"@implements Base? */\", \"expected end of line or comment\");\n+  }\n+\n+  public void testInterfaceExtends() throws Exception {\n+     JSDocInfo jsdoc = parse(\n+         \" * @interface \\n\" +\n+         \" * @extends {Extended} */\");\n+    assertTrue(jsdoc.isInterface());\n+    assertTypeEquals(new NamedType(registry, \"Extended\", null, -1, -1),\n+        jsdoc.getBaseType());\n+  }\n+\n+  public void testBadExtendsWithNullable() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@constructor\\n * @extends {Object?} */\",\n+        \"expected closing }\");\n+    assertTrue(jsdoc.isConstructor());\n+    assertTypeEquals(OBJECT_TYPE, jsdoc.getBaseType());\n+  }\n+\n+  public void testBadImplementsWithNullable() throws Exception {\n+  JSDocInfo jsdoc = parse(\"@implements {Disposable?}\\n * @constructor */\",\n+      \"expected closing }\");\n+    assertTrue(jsdoc.isConstructor());\n+    assertTypeEquals(new NamedType(registry, \"Disposable\", null, -1, -1),\n+        jsdoc.getImplementedInterfaces().get(0));\n+  }\n+\n+  public void testBadTypeDefInterfaceAndConstructor1() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@interface\\n@constructor*/\",\n+        \"cannot be both an interface and a constructor\");\n+    assertTrue(jsdoc.isInterface());\n+  }\n+\n+  public void testBadTypeDefInterfaceAndConstructor2() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@constructor\\n@interface*/\",\n+        \"cannot be both an interface and a constructor\");\n+    assertTrue(jsdoc.isConstructor());\n+  }\n+\n+  public void testDocumentationThrows() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@throws {Number} This is a description.*/\", true);\n+\n+    assertEquals(\"This is a description.\",\n+                 jsdoc.getDescriptionForThrownType(NUMBER_TYPE, null));\n+  }\n+\n+  public void testDocumentationParameter() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@param {Number} number42 This is a description.*/\", true);\n+\n+    assertTrue(jsdoc.hasDescriptionForParameter(\"number42\"));\n+    assertEquals(\"This is a description.\",\n+                 jsdoc.getDescriptionForParameter(\"number42\"));\n+  }\n+\n+  public void testMultilineDocumentationParameter() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@param {Number} number42 This is a description\"\n+                + \"\\n* on multiple \\n* lines.*/\", true);\n+\n+    assertTrue(jsdoc.hasDescriptionForParameter(\"number42\"));\n+    assertEquals(\"This is a description on multiple lines.\",\n+                 jsdoc.getDescriptionForParameter(\"number42\"));\n+\n+  }\n+\n+  public void testDocumentationMultipleParameter() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@param {Number} number42 This is a description.\"\n+                + \"\\n* @param {Integer} number87 This is another description.*/\"\n+                , true);\n+\n+    assertTrue(jsdoc.hasDescriptionForParameter(\"number42\"));\n+    assertEquals(\"This is a description.\",\n+                 jsdoc.getDescriptionForParameter(\"number42\"));\n+\n+    assertTrue(jsdoc.hasDescriptionForParameter(\"number87\"));\n+    assertEquals(\"This is another description.\",\n+                 jsdoc.getDescriptionForParameter(\"number87\"));\n+  }\n+\n+  public void testDocumentationMultipleParameter2() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@param {number} delta = 0 results in a redraw\\n\" +\n+                \"  != 0 ..... */\", true);\n+    assertTrue(jsdoc.hasDescriptionForParameter(\"delta\"));\n+    assertEquals(\"= 0 results in a redraw != 0 .....\",\n+                 jsdoc.getDescriptionForParameter(\"delta\"));\n+  }\n+\n+\n+  public void testAuthors() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@param {Number} number42 This is a description.\"\n+                + \"\\n* @param {Integer} number87 This is another description.\"\n+                + \"\\n* @author a@google.com (A Person)\"\n+                + \"\\n* @author b@google.com (B Person)\"\n+                + \"\\n* @author c@google.com (C Person)*/\"\n+                , true);\n+\n+    Collection<String> authors = jsdoc.getAuthors();\n+\n+    assertTrue(authors != null);\n+    assertTrue(authors.size() == 3);\n+\n+    assertContains(authors, \"a@google.com (A Person)\");\n+    assertContains(authors, \"b@google.com (B Person)\");\n+    assertContains(authors, \"c@google.com (C Person)\");\n+  }\n+\n+  public void testSuppress1() throws Exception {\n+    JSDocInfo info = parse(\"@suppress {x} */\");\n+    assertEquals(Sets.newHashSet(\"x\"), info.getSuppressions());\n+  }\n+\n+  public void testSuppress2() throws Exception {\n+    JSDocInfo info = parse(\"@suppress {x|y|x|z} */\");\n+    assertEquals(Sets.newHashSet(\"x\", \"y\", \"z\"), info.getSuppressions());\n+  }\n+\n+  public void testBadSuppress1() throws Exception {\n+    parse(\"@suppress {} */\", \"malformed @suppress tag\");\n+  }\n+\n+  public void testBadSuppress2() throws Exception {\n+    parse(\"@suppress {x|} */\", \"malformed @suppress tag\");\n+  }\n+\n+  public void testBadSuppress3() throws Exception {\n+    parse(\"@suppress {|x} */\", \"malformed @suppress tag\");\n+  }\n+\n+  public void testBadSuppress4() throws Exception {\n+    parse(\"@suppress {x|y */\", \"malformed @suppress tag\");\n+  }\n+\n+  public void testBadSuppress5() throws Exception {\n+    parse(\"@suppress {x,y} */\", \"malformed @suppress tag\");\n+  }\n+\n+  public void testBadSuppress6() throws Exception {\n+    parse(\"@suppress {x} \\n * @suppress {y} */\", \"duplicate @suppress tag\");\n+  }\n+\n+  //public void testNoParseFileOverview() throws Exception {\n+  //  JSDocInfo jsdoc = parseFileOverviewWithoutDoc(\"@fileoverview Hi mom! */\");\n+  //  assertNull(jsdoc.getFileOverview());\n+  //  assertTrue(jsdoc.hasFileOverview());\n+  //}\n+\n+  public void testFileOverviewSingleLine() throws Exception {\n+    JSDocInfo jsdoc = parseFileOverview(\"@fileoverview Hi mom! */\");\n+    assertEquals(\"Hi mom!\", jsdoc.getFileOverview());\n+  }\n+\n+  public void testFileOverviewMultiLine() throws Exception {\n+    JSDocInfo jsdoc = parseFileOverview(\"@fileoverview Pie is \\n * good! */\");\n+    assertEquals(\"Pie is\\n good!\", jsdoc.getFileOverview());\n+  }\n+\n+  public void testFileOverviewDuplicate() throws Exception {\n+    JSDocInfo jsdoc = parseFileOverview(\n+        \"@fileoverview Pie \\n * @fileoverview Cake */\",\n+        \"extra @fileoverview tag\");\n+  }\n+\n+  public void testReferences() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@see A cool place!\"\n+                + \"\\n* @see The world.\"\n+                + \"\\n* @see SomeClass#SomeMember\"\n+                + \"\\n* @see A boring test case*/\"\n+                , true);\n+\n+    Collection<String> references = jsdoc.getReferences();\n+\n+    assertTrue(references != null);\n+    assertTrue(references.size() == 4);\n+\n+    assertContains(references, \"A cool place!\");\n+    assertContains(references, \"The world.\");\n+    assertContains(references, \"SomeClass#SomeMember\");\n+    assertContains(references, \"A boring test case\");\n+  }\n+\n+  public void testSingleTags() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@version Some old version\"\n+                + \"\\n* @deprecated In favor of the new one!\"\n+                + \"\\n* @return {SomeType} The most important object :-)*/\"\n+                , true);\n+\n+    assertTrue(jsdoc.isDeprecated());\n+    assertEquals(\"In favor of the new one!\", jsdoc.getDeprecationReason());\n+    assertEquals(\"Some old version\", jsdoc.getVersion());\n+    assertEquals(\"The most important object :-)\", jsdoc.getReturnDescription());\n+  }\n+\n+  public void testSingleTagsReordered() throws Exception {\n+    JSDocInfo jsdoc\n+        = parse(\"@deprecated In favor of the new one!\"\n+                + \"\\n * @return {SomeType} The most important object :-)\"\n+                + \"\\n * @version Some old version*/\"\n+                , true);\n+\n+    assertTrue(jsdoc.isDeprecated());\n+    assertEquals(\"In favor of the new one!\", jsdoc.getDeprecationReason());\n+    assertEquals(\"Some old version\", jsdoc.getVersion());\n+    assertEquals(\"The most important object :-)\", jsdoc.getReturnDescription());\n+  }\n+\n+  public void testVersionDuplication() throws Exception {\n+    parse(\"* @version Some old version\"\n+          + \"\\n* @version Another version*/\", true,\n+          \"conflicting @version tag\");\n+  }\n+\n+  public void testVersionMissing() throws Exception {\n+    parse(\"* @version */\", true,\n+          \"@version tag missing version information\");\n+  }\n+\n+  public void testAuthorMissing() throws Exception {\n+    parse(\"* @author */\", true,\n+          \"@author tag missing author\");\n+  }\n+\n+  public void testSeeMissing() throws Exception {\n+    parse(\"* @see */\", true,\n+          \"@see tag missing description\");\n+  }\n+\n+  public void testSourceName() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@deprecated */\", true);\n+    assertEquals(\"testcode\", jsdoc.getSourceName());\n+  }\n+\n+  public void testParseBlockComment() throws Exception {\n+    JSDocInfo jsdoc = parse(\"this is a nice comment\\n \"\n+                            + \"* that is multiline \\n\"\n+                            + \"* @author abc@google.com */\", true);\n+\n+    assertEquals(\"this is a nice comment\\nthat is multiline\",\n+                 jsdoc.getBlockDescription());\n+\n+    assertDocumentationInMarker(\n+        assertAnnotationMarker(jsdoc, \"author\", 2, 2),\n+        \"abc@google.com\", 9, 2, 23);\n+  }\n+\n+  public void testParseBlockComment2() throws Exception {\n+    JSDocInfo jsdoc = parse(\"this is a nice comment\\n \"\n+                            + \"* that is *** multiline \\n\"\n+                            + \"* @author abc@google.com */\", true);\n+\n+    assertEquals(\"this is a nice comment\\nthat is *** multiline\",\n+                 jsdoc.getBlockDescription());\n+\n+    assertDocumentationInMarker(\n+        assertAnnotationMarker(jsdoc, \"author\", 2, 2),\n+        \"abc@google.com\", 9, 2, 23);\n+  }\n+\n+  public void testParseBlockComment3() throws Exception {\n+    JSDocInfo jsdoc = parse(\"\\n \"\n+                            + \"* hello world \\n\"\n+                            + \"* @author abc@google.com */\", true);\n+\n+    assertEquals(\"hello world\", jsdoc.getBlockDescription());\n+\n+    assertDocumentationInMarker(\n+        assertAnnotationMarker(jsdoc, \"author\", 2, 2),\n+        \"abc@google.com\", 9, 2, 23);\n+  }\n+\n+  public void testParseWithMarkers1() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@author abc@google.com */\", true);\n+\n+    assertDocumentationInMarker(\n+        assertAnnotationMarker(jsdoc, \"author\", 0, 0),\n+        \"abc@google.com\", 7, 0, 21);\n+  }\n+\n+  public void testParseWithMarkers2() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@param {Foo} somename abc@google.com */\", true);\n+\n+    assertDocumentationInMarker(\n+        assertAnnotationMarker(jsdoc, \"param\", 0, 0),\n+        \"abc@google.com\", 21, 0, 37);\n+  }\n+\n+  public void testParseWithMarkers3() throws Exception {\n+    JSDocInfo jsdoc =\n+        parse(\"@return {Foo} some long \\n * multiline\" +\n+              \" \\n * description */\", true);\n+\n+    assertDocumentationInMarker(\n+        assertAnnotationMarker(jsdoc, \"return\", 0, 0),\n+        \"some long multiline description\", 13, 2, 15);\n+  }\n+\n+  public void testParseWithMarkers4() throws Exception {\n+    JSDocInfo jsdoc =\n+        parse(\"@author foobar \\n * @param {Foo} somename abc@google.com */\",\n+              true);\n+\n+    assertAnnotationMarker(jsdoc, \"author\", 0, 0);\n+    assertAnnotationMarker(jsdoc, \"param\", 1, 3);\n+  }\n+\n+  public void testParseWithMarkerNames1() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@param {SomeType} name somedescription */\", true);\n+\n+    assertNameInMarker(\n+        assertAnnotationMarker(jsdoc, \"param\", 0, 0),\n+        \"name\", 18);\n+  }\n+\n+  public void testParseWithMarkerNames2() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@param {SomeType} name somedescription \\n\" +\n+                            \"* @param {AnotherType} anothername des */\", true);\n+\n+    assertTypeInMarker(\n+        assertNameInMarker(\n+            assertAnnotationMarker(jsdoc, \"param\", 0, 0, 0),\n+            \"name\", 18),\n+        \"SomeType\", 7, true);\n+\n+    assertTypeInMarker(\n+        assertNameInMarker(\n+            assertAnnotationMarker(jsdoc, \"param\", 1, 2, 1),\n+            \"anothername\", 23),\n+        \"AnotherType\", 9, true);\n+  }\n+\n+  public void testParseWithoutMarkerName() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@author helloworld*/\", true);\n+    assertNull(assertAnnotationMarker(jsdoc, \"author\", 0, 0).name);\n+  }\n+\n+  public void testParseWithMarkerType() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@extends {FooBar}*/\", true);\n+\n+    assertTypeInMarker(\n+        assertAnnotationMarker(jsdoc, \"extends\", 0, 0),\n+        \"FooBar\", 9, true);\n+  }\n+\n+  public void testParseWithMarkerType2() throws Exception {\n+    JSDocInfo jsdoc = parse(\"@extends FooBar*/\", true);\n+\n+    assertTypeInMarker(\n+        assertAnnotationMarker(jsdoc, \"extends\", 0, 0),\n+        \"FooBar\", 9, false);\n+  }\n+\n+  public void testTypeTagConflict1() throws Exception {\n+    parse(\"@constructor \\n * @constructor */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict2() throws Exception {\n+    parse(\"@interface \\n * @interface */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict3() throws Exception {\n+    parse(\"@constructor \\n * @interface */\",\n+        \"cannot be both an interface and a constructor\");\n+  }\n+\n+  public void testTypeTagConflict4() throws Exception {\n+    parse(\"@interface \\n * @constructor */\",\n+        \"cannot be both an interface and a constructor\");\n+  }\n+\n+  public void testTypeTagConflict5() throws Exception {\n+    parse(\"@interface \\n * @type {string} */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict6() throws Exception {\n+    parse(\"@typedef {string} \\n * @type {string} */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict7() throws Exception {\n+    parse(\"@typedef {string} \\n * @constructor */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict8() throws Exception {\n+    parse(\"@typedef {string} \\n * @return {boolean} */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict9() throws Exception {\n+    parse(\"@enum {string} \\n * @return {boolean} */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict10() throws Exception {\n+    parse(\"@this {Object} \\n * @enum {boolean} */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict11() throws Exception {\n+    parse(\"@param {Object} x \\n * @type {boolean} */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict12() throws Exception {\n+    parse(\"@typedef {boolean} \\n * @param {Object} x */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testTypeTagConflict13() throws Exception {\n+    parse(\"@typedef {boolean} \\n * @extends {Object} */\",\n+        \"type annotation incompatible with other annotations\");\n+  }\n+\n+  public void testParserWithTemplateTypeNameMisisng() {\n+    parse(\"@template */\", \"@template tag missing type name\");\n+  }\n+\n+  public void testParserWithTemplateTypeNameMissing() {\n+    parse(\"@template T\\n@template V */\", \"@template tag at most once\");\n+  }\n+\n+  public void testWhitelistedNewAnnotations() {\n+    parse(\"@foobar */\",\n+        \"illegal use of unknown JSDoc tag \\\"foobar\\\"; ignoring it\");\n+    extraAnnotations.add(\"foobar\");\n+    parse(\"@foobar */\");\n+  }\n+\n+  public void testWhitelistedConflictingAnnotation() {\n+    extraAnnotations.add(\"param\");\n+    JSDocInfo info = parse(\"@param {number} index */\");\n+    assertTypeEquals(NUMBER_TYPE, info.getParameterType(\"index\"));\n+  }\n+\n+  public void testNonIdentifierAnnotation() {\n+    // Try to whitelist an annotation that is not a valid JS identifier.\n+    // It should not work.\n+    extraAnnotations.add(\"123\");\n+    parse(\"@123 */\", \"illegal use of unknown JSDoc tag \\\"\\\"; ignoring it\");\n+  }\n+\n+  public void testUnsupportedJsDocSyntax1() {\n+    JSDocInfo info =\n+        parse(\"@param {string} [accessLevel=\\\"author\\\"] The user level */\",\n+            true);\n+    assertEquals(1, info.getParameterCount());\n+    assertTypeEquals(\n+        registry.createOptionalType(STRING_TYPE),\n+        info.getParameterType(\"accessLevel\"));\n+    assertEquals(\"The user level\",\n+        info.getDescriptionForParameter(\"accessLevel\"));\n+  }\n+\n+  public void testUnsupportedJsDocSyntax2() {\n+    JSDocInfo info =\n+        parse(\"@param userInfo The user info. \\n\" +\n+              \" * @param userInfo.name The name of the user */\", true);\n+    assertEquals(1, info.getParameterCount());\n+    assertEquals(\"The user info.\",\n+        info.getDescriptionForParameter(\"userInfo\"));\n+  }\n+\n+  public void testWhitelistedAnnotations() {\n+    parse(\n+      \"* @addon \\n\" +\n+      \"* @augments \\n\" +\n+      \"* @base \\n\" +\n+      \"* @borrows \\n\" +\n+      \"* @bug \\n\" +\n+      \"* @class \\n\" +\n+      \"* @config \\n\" +\n+      \"* @constructs \\n\" +\n+      \"* @default \\n\" +\n+      \"* @description \\n\" +\n+      \"* @event \\n\" +\n+      \"* @example \\n\" +\n+      \"* @exception \\n\" +\n+      \"* @exec \\n\" +\n+      \"* @externs \\n\" +\n+      \"* @field \\n\" +\n+      \"* @function \\n\" +\n+      \"* @id \\n\" +\n+      \"* @ignore \\n\" +\n+      \"* @inner \\n\" +\n+      \"* @lends \\n\" +\n+      \"* @link \\n\" +\n+      \"* @member \\n\" +\n+      \"* @memberOf \\n\" +\n+      \"* @modName \\n\" +\n+      \"* @mods \\n\" +\n+      \"* @name \\n\" +\n+      \"* @namespace \\n\" +\n+      \"* @property \\n\" +\n+      \"* @requires \\n\" +\n+      \"* @since \\n\" +\n+      \"* @static \\n\" +\n+      \"* @supported */\");\n+  }\n+\n+  /**\n+   * Asserts that a documentation field exists on the given marker.\n+   *\n+   * @param description The text of the documentation field expected.\n+   * @param startCharno The starting character of the text.\n+   * @param endLineno The ending line of the text.\n+   * @param endCharno The ending character of the text.\n+   * @return The marker, for chaining purposes.\n+   */\n+  private JSDocInfo.Marker assertDocumentationInMarker(JSDocInfo.Marker marker,\n+                                                       String description,\n+                                                       int startCharno,\n+                                                       int endLineno,\n+                                                       int endCharno) {\n+    assertTrue(marker.description != null);\n+    assertEquals(description, marker.description.getItem());\n+\n+    // Match positional information.\n+    assertEquals(marker.annotation.getStartLine(),\n+                 marker.description.getStartLine());\n+    assertEquals(startCharno, marker.description.getPositionOnStartLine());\n+    assertEquals(endLineno, marker.description.getEndLine());\n+    assertEquals(endCharno, marker.description.getPositionOnEndLine());\n+\n+    return marker;\n+  }\n+\n+  /**\n+   * Asserts that a type field exists on the given marker.\n+   *\n+   * @param typeName The name of the type expected in the type field.\n+   * @param startCharno The starting character of the type declaration.\n+   * @param hasBrackets Whether the type in the type field is expected\n+   *     to have brackets.\n+   * @return The marker, for chaining purposes.\n+   */\n+  private JSDocInfo.Marker assertTypeInMarker(JSDocInfo.Marker marker,\n+                                            String typeName, int startCharno,\n+                                            boolean hasBrackets) {\n+\n+    assertTrue(marker.type != null);\n+    assertTrue(marker.type.getItem().getType() == Token.STRING);\n+\n+    // Match the name and brackets information.\n+    String foundName = marker.type.getItem().getString();\n+\n+    assertEquals(typeName, foundName);\n+    assertEquals(hasBrackets, marker.type.hasBrackets);\n+\n+    // Match position information.\n+    assertEquals(startCharno, marker.type.getPositionOnStartLine());\n+\n+    int endCharno = startCharno + foundName.length();\n+\n+    if (hasBrackets) {\n+      endCharno += 1;\n+    }\n+\n+    assertEquals(endCharno, marker.type.getPositionOnEndLine());\n+    assertEquals(marker.annotation.getStartLine(), marker.type.getStartLine());\n+    assertEquals(marker.annotation.getStartLine(), marker.type.getEndLine());\n+\n+    return marker;\n+  }\n+\n+  /**\n+   * Asserts that a name field exists on the given marker.\n+   *\n+   * @param name The name expected in the name field.\n+   * @param startCharno The starting character of the text.\n+   * @return The marker, for chaining purposes.\n+   */\n+  private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker,\n+                                            String name, int startCharno) {\n+    assertTrue(marker.name != null);\n+    assertEquals(name, marker.name.getItem());\n+\n+    assertEquals(startCharno, marker.name.getPositionOnStartLine());\n+    assertEquals(startCharno + name.length(),\n+                 marker.name.getPositionOnEndLine());\n+\n+    assertEquals(marker.annotation.getStartLine(), marker.name.getStartLine());\n+    assertEquals(marker.annotation.getStartLine(), marker.name.getEndLine());\n+\n+    return marker;\n+  }\n+\n+  /**\n+   * Asserts that an annotation marker of a given annotation name\n+   * is found in the given JSDocInfo.\n+   *\n+   * @param jsdoc The JSDocInfo in which to search for the annotation marker.\n+   * @param annotationName The name/type of the annotation for which to\n+   *   search. Example: \"author\" for an \"@author\" annotation.\n+   * @param startLineno The expected starting line number of the marker.\n+   * @param startCharno The expected character on the starting line.\n+   * @return The marker found, for further testing.\n+   */\n+  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,\n+                                                  String annotationName,\n+                                                  int startLineno,\n+                                                  int startCharno) {\n+    return assertAnnotationMarker(jsdoc, annotationName, startLineno,\n+                                  startCharno, 0);\n+  }\n+\n+  /**\n+   * Asserts that the index-th annotation marker of a given annotation name\n+   * is found in the given JSDocInfo.\n+   *\n+   * @param jsdoc The JSDocInfo in which to search for the annotation marker.\n+   * @param annotationName The name/type of the annotation for which to\n+   *   search. Example: \"author\" for an \"@author\" annotation.\n+   * @param startLineno The expected starting line number of the marker.\n+   * @param startCharno The expected character on the starting line.\n+   * @param index The index of the marker.\n+   * @return The marker found, for further testing.\n+   */\n+  private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc,\n+                                                  String annotationName,\n+                                                  int startLineno,\n+                                                  int startCharno,\n+                                                  int index) {\n+\n+    Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers();\n+\n+    assertTrue(markers.size() > 0);\n+\n+    int counter = 0;\n+\n+    for (JSDocInfo.Marker marker : markers) {\n+      if (marker.annotation != null) {\n+        if (annotationName.equals(marker.annotation.getItem())) {\n+\n+          if (counter == index) {\n+            assertEquals(startLineno, marker.annotation.getStartLine());\n+            assertEquals(startCharno,\n+                         marker.annotation.getPositionOnStartLine());\n+            assertEquals(startLineno, marker.annotation.getEndLine());\n+            assertEquals(startCharno + annotationName.length(),\n+                         marker.annotation.getPositionOnEndLine());\n+\n+            return marker;\n+          }\n+\n+          counter++;\n+        }\n+      }\n+    }\n+\n+    fail(\"No marker found\");\n+    return null;\n+  }\n+\n+  private <T> void assertContains(Collection<T> collection, T item) {\n+    assertTrue(collection.contains(item));\n+  }\n+\n+  private void parseFull(String code, String... warnings) {\n+    CompilerEnvirons environment = new CompilerEnvirons();\n+\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n+    environment.setErrorReporter(testErrorReporter);\n+\n+    environment.setRecordingComments(true);\n+    environment.setRecordingLocalJsDocComments(true);\n+\n+    Parser p = new Parser(environment, testErrorReporter);\n+    AstRoot script = p.parse(code, null, 0);\n+\n+    Config config = new Config(registry, extraAnnotations, true);\n+    for (Comment comment : script.getComments()) {\n+      JsDocInfoParser jsdocParser =\n+        new JsDocInfoParser(\n+            new JsDocTokenStream(comment.getValue().substring(3),\n+                comment.getLineno()),\n+            script.getSourceName(),\n+            config,\n+            testErrorReporter);\n+      jsdocParser.parse();\n+      jsdocParser.retrieveAndResetParsedJSDocInfo();\n+    }\n+\n+    assertTrue(\"some expected warnings were not reported\",\n+        testErrorReporter.hasEncounteredAllWarnings());\n+  }\n+\n+  private JSDocInfo parseFileOverviewWithoutDoc(String comment,\n+                                                String... warnings) {\n+    return parse(comment, false, true, warnings);\n+  }\n+\n+  private JSDocInfo parseFileOverview(String comment, String... warnings) {\n+    return parse(comment, true, true, warnings);\n+  }\n+\n+  private JSDocInfo parse(String comment, String... warnings) {\n+    return parse(comment, false, warnings);\n+  }\n+\n+  private JSDocInfo parse(String comment, boolean parseDocumentation,\n+                          String... warnings) {\n+    return parse(comment, parseDocumentation, false, warnings);\n+  }\n+\n+  private JSDocInfo parse(String comment, boolean parseDocumentation,\n+      boolean parseFileOverview, String... warnings) {\n+    TestErrorReporter errorReporter = new TestErrorReporter(null, warnings);\n+\n+    Config config = new Config(\n+        registry, extraAnnotations, parseDocumentation);\n+    JsDocInfoParser jsdocParser = new JsDocInfoParser(stream(comment),\n+        \"testcode\", config, errorReporter);\n+\n+    //if (fileLevelJsDocBuilder != null) {\n+    //  jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n+    //}\n+\n+    jsdocParser.parse();\n+\n+    assertTrue(\"expected warnings were not reported\",\n+        errorReporter.hasEncounteredAllWarnings());\n+\n+    if (parseFileOverview) {\n+      return jsdocParser.getFileOverviewJSDocInfo();\n+    } else {\n+      return jsdocParser.retrieveAndResetParsedJSDocInfo();\n+    }\n+  }\n+\n+  private Node parseType(String typeComment) {\n+    return JsDocInfoParser.parseTypeString(typeComment);\n+  }\n+\n+  private JsDocTokenStream stream(String source) {\n+    return new JsDocTokenStream(source, 0);\n+  }\n+\n+  private void assertParameterTypeEquals(JSType expected, JSTypeExpression te) {\n+    assertEquals(expected, ((ObjectType) resolve(te)).getParameterType());\n+  }\n+\n+  private void assertIndexTypeEquals(JSType expected, JSTypeExpression te) {\n+    assertEquals(expected, ((ObjectType) resolve(te)).getIndexType());\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.parsing;\n+\n+import static com.google.javascript.jscomp.parsing.JsDocToken.ANNOTATION;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.BANG;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.COLON;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.COMMA;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.ELLIPSIS;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.EOC;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.EOF;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.EOL;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.EQUALS;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.GT;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.LB;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.LC;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.LP;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.LT;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.PIPE;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.QMARK;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.RB;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.RC;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.RP;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.STAR;\n+import static com.google.javascript.jscomp.parsing.JsDocToken.STRING;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.List;\n+import java.io.IOException;\n+\n+/**\n+ * Tests for {@link JsDocTokenStream}.\n+ */\n+public class JsDocTokenStreamTest extends TestCase {\n+\n+  public void testJsDocTokenization1() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        STAR, ANNOTATION, LC, STRING, RC, EOL, STAR, ANNOTATION);\n+    List<String> strings = ImmutableList.of(\"type\", \"string\", \"private\");\n+    testJSDocTokenStream(\" * @type {string}\\n * @private\", tokens, strings);\n+    testJSDocTokenStream(\" *    @type { string } \\n * @private\",\n+        tokens, strings);\n+    testJSDocTokenStream(\" * @type   {  string}\\n * @private\", tokens, strings);\n+    testJSDocTokenStream(\" * @type {string  }\\n * @private\", tokens, strings);\n+    testJSDocTokenStream(\" * @type {string}\\n *   @private\", tokens, strings);\n+    testJSDocTokenStream(\" * @type {string}   \\n * @private\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization2() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, LT, STRING, PIPE, STRING, GT, RC);\n+    List<String> strings = ImmutableList.of(\"param\", \"Array\", \"string\", \"null\");\n+    testJSDocTokenStream(\"@param {Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string |null>}\", tokens, strings);\n+    testJSDocTokenStream(\" @param {Array.<string |  null>}\", tokens, strings);\n+    testJSDocTokenStream(\" @param {Array.<string|null  >}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array  .<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param   {Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {  Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string|   null>}  \", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string|null>}\", tokens, strings);\n+    testJSDocTokenStream(\"     @param { Array .< string |null > } \",\n+        tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization3() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, LT, STRING, PIPE, STRING, GT, RC);\n+    List<String> strings = ImmutableList.of(\"param\", \"Array\", \"string\", \"null\");\n+    testJSDocTokenStream(\"@param {Array.<string||null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.< string || null> }\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<string || null >  } \",\n+        tokens, strings);\n+    testJSDocTokenStream(\"@param {Array .<string   ||null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.< string||null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {  Array.<string||null>}\", tokens, strings);\n+    testJSDocTokenStream(\" @param   {Array.<string||null>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param   {   Array.<string|| null> }\",\n+        tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization4() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, LT, LP, STRING, COMMA, STRING, RP, GT, RC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"Array\", \"string\", \"null\");\n+    testJSDocTokenStream(\"@param {Array.<(string,null)>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array  .<(string,null)> } \", tokens, strings);\n+    testJSDocTokenStream(\" @param {Array.<  (  string,null)>}\",\n+        tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<(string  , null)>}\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Array.<(string,   null)  > }  \",\n+        tokens, strings);\n+    testJSDocTokenStream(\"@param {  Array  .<  (string,null)>}   \",\n+        tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization5() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, STRING, EOC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"foo.Bar\");\n+    testJSDocTokenStream(\"@param foo.Bar*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param   foo.Bar*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param foo.Bar   */\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization6() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        ANNOTATION, EOL, ANNOTATION, EOL, ANNOTATION, EOC);\n+    List<String> strings = ImmutableList.of(\"hidden\", \"static\", \"desc\");\n+    testJSDocTokenStream(\"@hidden\\n@static\\n@desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n @static\\n@desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n@static\\n @desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n@static\\n@desc */\", tokens, strings);\n+    testJSDocTokenStream(\" @hidden \\n@static\\n @desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n@static    \\n @desc  */\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden\\n@static\\n@desc*/\", tokens, strings);\n+    testJSDocTokenStream(\"@hidden   \\n@static   \\n @desc*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization7() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        ELLIPSIS, ELLIPSIS, ELLIPSIS, ELLIPSIS, ELLIPSIS, LT, EOC);\n+    List<String> strings = ImmutableList.of();\n+\n+    testJSDocTokenStream(\"................<*/\", tokens, strings);\n+    testJSDocTokenStream(\"............... .<*/\", tokens, strings);\n+    testJSDocTokenStream(\"................< */\", tokens, strings);\n+    testJSDocTokenStream(\"............... .< */\", tokens, strings);\n+    testJSDocTokenStream(\"............... .< */ \", tokens, strings);\n+    testJSDocTokenStream(\" ............... .< */ \", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization8() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, STRING,\n+        STRING, EOL, EOC);\n+    List<String> strings = ImmutableList.of(\n+        \"param\", \"foo.Bar\", \"opt_name\", \"this\", \"parameter\", \"is\", \"a\", \"name\");\n+    testJSDocTokenStream(\n+        \" * @param foo.Bar opt_name this parameter is a name\\n\" +\n+        \" */\", tokens, strings);\n+    testJSDocTokenStream(\n+        \"  *  @param foo.Bar opt_name this parameter is a name \\n\" +\n+        \" */ \", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization9() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, ANNOTATION,\n+        STRING, EOL, EOC);\n+    List<String> strings = ImmutableList.of(\n+        \"param\", \"foo.Bar\", \"opt_name\", \"this\", \"parameter\", \"does\",\n+        \"media\", \"blah\");\n+    testJSDocTokenStream(\n+        \" * @param foo.Bar opt_name this parameter does @media blah\\n\" +\n+        \" */\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization10() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(STRING, GT, EOC);\n+    List<String> strings = ImmutableList.of(\"Array<String\");\n+    testJSDocTokenStream(\"Array<String>*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization11() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, QMARK, RC, EOC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"string\");\n+    testJSDocTokenStream(\"@param {string?}*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param {string?}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param { string?}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {string ?}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param  {string ?  } */\", tokens, strings);\n+    testJSDocTokenStream(\"@param { string  ?  }*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {string?  }*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization12() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(STRING, ELLIPSIS, EOC);\n+    List<String> strings = ImmutableList.of(\"function\");\n+\n+    testJSDocTokenStream(\"function ...*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization13() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(ELLIPSIS, LB, STRING, RB, EOC);\n+    List<String> strings = ImmutableList.of(\"number\");\n+\n+    testJSDocTokenStream(\"...[number]*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization14() throws Exception {\n+    // Since ES4 type parsing only requires to parse an ellispis when it is\n+    // followed by a comma (,) we are allowing this case to parse this way.\n+    // This is a simplification of the tokenizer, but the extra complexity is\n+    // never used.\n+    List<JsDocToken> tokens = ImmutableList.of(STRING, LB, STRING, EOC);\n+    List<String> strings = ImmutableList.of(\"foo\", \"bar...\");\n+\n+    testJSDocTokenStream(\"foo[ bar...*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization15() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        STRING, LB, STRING, COMMA, ELLIPSIS, EOC);\n+    List<String> strings = ImmutableList.of(\"foo\", \"bar\");\n+\n+    testJSDocTokenStream(\"foo[ bar,...*/\", tokens, strings);\n+    testJSDocTokenStream(\"foo[ bar ,...*/\", tokens, strings);\n+    testJSDocTokenStream(\"foo[bar, ...*/\", tokens, strings);\n+    testJSDocTokenStream(\"foo[ bar  ,   ...  */\", tokens, strings);\n+    testJSDocTokenStream(\"foo [bar,... */\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization16() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        STRING, COLON, COLON, COLON, ELLIPSIS, STRING, COLON, STRING, EOC);\n+    List<String> strings = ImmutableList.of(\"foo\", \"bar\", \"bar2\");\n+\n+    testJSDocTokenStream(\"foo:::...bar:bar2*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization17() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);\n+    List<String> strings = ImmutableList.of(\"..\");\n+\n+    testJSDocTokenStream(\"..\\n*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization18() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);\n+    List<String> strings = ImmutableList.of(\".\");\n+\n+    testJSDocTokenStream(\".\\n*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization19() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, LC, STAR, RC, EOC);\n+    List<String> strings = ImmutableList.of(\"type\", \"*\");\n+\n+    testJSDocTokenStream(\"@type {*}*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization20() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        ANNOTATION, LC, BANG, STRING, RC, EOC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"Object\");\n+    testJSDocTokenStream(\"@param {!Object}*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param {!Object}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {! Object}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param { !Object}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param  {!Object  } */\", tokens, strings);\n+    testJSDocTokenStream(\"@param {  ! Object  }*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {!Object  }*/\", tokens, strings);\n+  }\n+\n+  public void testJsDocTokenization21() throws Exception {\n+    List<JsDocToken> tokens = ImmutableList.of(\n+        ANNOTATION, LC, STRING, EQUALS, RC, EOC, EOF);\n+    List<String> strings = ImmutableList.of(\"param\", \"Object\");\n+    testJSDocTokenStream(\"@param {Object=}*/\", tokens, strings);\n+    testJSDocTokenStream(\" @param {Object=}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param { Object =}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param { Object=}*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param  {Object=  } */\", tokens, strings);\n+    testJSDocTokenStream(\"@param { Object = }*/\", tokens, strings);\n+    testJSDocTokenStream(\"@param {Object=  }*/\", tokens, strings);\n+  }\n+\n+  private void testJSDocTokenStream(String comment, List<JsDocToken> tokens,\n+      List<String> strings) throws IOException {\n+    JsDocTokenStream stream = new JsDocTokenStream(comment, 0);\n+    int stringsIndex = 0;\n+    for (JsDocToken token : tokens) {\n+      JsDocToken readToken = stream.getJsDocToken();\n+\n+      // token equality\n+      if (token != readToken) {\n+        assertEquals(token, readToken);\n+      }\n+\n+      // string equality\n+      if (token == ANNOTATION || token == STRING) {\n+        assertEquals(strings.get(stringsIndex++), stream.getString());\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.parsing;\n+\n+import com.google.common.base.Pair;\n+import com.google.common.collect.ImmutableList;\n+import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime;\n+import com.google.javascript.jscomp.testing.TestErrorReporter;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.ScriptOrFnNode;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n+\n+import java.io.IOException;\n+import java.util.logging.Logger;\n+import java.util.List;\n+\n+\n+public class ParserTest extends BaseJSTypeTestCase {\n+  private static final String TRAILING_COMMA_MESSAGE =\n+      ScriptRuntime.getMessage0(\"msg.extra.trailing.comma\");\n+\n+  private static final String BAD_PROPERTY_MESSAGE =\n+      ScriptRuntime.getMessage0(\"msg.bad.prop\");\n+\n+  private static final String MISSING_GT_MESSAGE =\n+      com.google.javascript.rhino.ScriptRuntime.getMessage0(\n+          \"msg.jsdoc.missing.gt\");\n+\n+  private JSType getNativeType(JSTypeNative typeId) {\n+    return registry.getNativeType(typeId);\n+  }\n+\n+  public void testLinenoCharnoAssign1() throws Exception {\n+    Node assign = parse(\"a = b\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.ASSIGN, assign.getType());\n+    assertEquals(1, assign.getLineno());\n+    assertEquals(2, assign.getCharno());\n+  }\n+\n+  public void testLinenoCharnoAssign2() throws Exception {\n+    Node assign = parse(\"\\n a.g.h.k    =  45\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.ASSIGN, assign.getType());\n+    assertEquals(2, assign.getLineno());\n+    assertEquals(12, assign.getCharno());\n+  }\n+\n+  public void testLinenoCharnoCall() throws Exception {\n+    Node call = parse(\"\\n foo(123);\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.CALL, call.getType());\n+    assertEquals(2, call.getLineno());\n+    assertEquals(4, call.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetProp1() throws Exception {\n+    Node getprop = parse(\"\\n foo.bar\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETPROP, getprop.getType());\n+    assertEquals(2, getprop.getLineno());\n+    assertEquals(1, getprop.getCharno());\n+\n+    Node name = getprop.getFirstChild().getNext();\n+    assertEquals(Token.STRING, name.getType());\n+    assertEquals(2, name.getLineno());\n+    assertEquals(5, name.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetProp2() throws Exception {\n+    Node getprop = parse(\"\\n foo.\\nbar\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETPROP, getprop.getType());\n+    assertEquals(2, getprop.getLineno());\n+    assertEquals(1, getprop.getCharno());\n+\n+    Node name = getprop.getFirstChild().getNext();\n+    assertEquals(Token.STRING, name.getType());\n+    assertEquals(3, name.getLineno());\n+    assertEquals(0, name.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetelem1() throws Exception {\n+    Node call = parse(\"\\n foo[123]\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETELEM, call.getType());\n+    assertEquals(2, call.getLineno());\n+    assertEquals(1, call.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetelem2() throws Exception {\n+    Node call = parse(\"\\n   \\n foo()[123]\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETELEM, call.getType());\n+    assertEquals(3, call.getLineno());\n+    assertEquals(1, call.getCharno());\n+  }\n+\n+  public void testLinenoCharnoGetelem3() throws Exception {\n+    Node call = parse(\"\\n   \\n (8 + kl)[123]\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.GETELEM, call.getType());\n+    assertEquals(3, call.getLineno());\n+    assertEquals(2, call.getCharno());\n+  }\n+\n+  public void testLinenoCharnoForComparison() throws Exception {\n+    Node lt =\n+      parse(\"for (; i < j;){}\").getFirstChild().getFirstChild().getNext();\n+\n+    assertEquals(Token.LT, lt.getType());\n+    assertEquals(1, lt.getLineno());\n+    assertEquals(9, lt.getCharno());\n+  }\n+\n+  public void testLinenoCharnoHook() throws Exception {\n+    Node n = parse(\"\\n a ? 9 : 0\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.HOOK, n.getType());\n+    assertEquals(2, n.getLineno());\n+    assertEquals(1, n.getCharno());\n+  }\n+\n+  public void testLinenoCharnoArrayLiteral() throws Exception {\n+    Node n = parse(\"\\n  [8, 9]\").getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.ARRAYLIT, n.getType());\n+    assertEquals(2, n.getLineno());\n+    assertEquals(2, n.getCharno());\n+\n+    n = n.getFirstChild();\n+\n+    assertEquals(Token.NUMBER, n.getType());\n+    assertEquals(2, n.getLineno());\n+    assertEquals(3, n.getCharno());\n+\n+    n = n.getNext();\n+\n+    assertEquals(Token.NUMBER, n.getType());\n+    assertEquals(2, n.getLineno());\n+    assertEquals(6, n.getCharno());\n+  }\n+\n+  public void testLinenoCharnoObjectLiteral() throws Exception {\n+    Node n = parse(\"\\n\\n var a = {a:0\\n,b :1};\")\n+        .getFirstChild().getFirstChild().getFirstChild();\n+\n+    assertEquals(Token.OBJECTLIT, n.getType());\n+    assertEquals(3, n.getLineno());\n+    assertEquals(9, n.getCharno());\n+\n+    n = n.getFirstChild();\n+\n+    assertEquals(Token.STRING, n.getType());\n+    assertEquals(3, n.getLineno());\n+    assertEquals(10, n.getCharno());\n+\n+    n = n.getNext();\n+\n+    assertEquals(Token.NUMBER, n.getType());\n+    assertEquals(3, n.getLineno());\n+    assertEquals(12, n.getCharno());\n+\n+    n = n.getNext();\n+\n+    assertEquals(Token.STRING, n.getType());\n+    assertEquals(4, n.getLineno());\n+    assertEquals(1, n.getCharno());\n+\n+    n = n.getNext();\n+\n+    assertEquals(Token.NUMBER, n.getType());\n+    assertEquals(4, n.getLineno());\n+    assertEquals(4, n.getCharno());\n+  }\n+\n+  public void testLinenoCharnoAdd() throws Exception {\n+    testLinenoCharnoBinop(\"+\");\n+  }\n+\n+  public void testLinenoCharnoSub() throws Exception {\n+    testLinenoCharnoBinop(\"-\");\n+  }\n+\n+  public void testLinenoCharnoMul() throws Exception {\n+    testLinenoCharnoBinop(\"*\");\n+  }\n+\n+  public void testLinenoCharnoDiv() throws Exception {\n+    testLinenoCharnoBinop(\"/\");\n+  }\n+\n+  public void testLinenoCharnoMod() throws Exception {\n+    testLinenoCharnoBinop(\"%\");\n+  }\n+\n+  public void testLinenoCharnoShift() throws Exception {\n+    testLinenoCharnoBinop(\"<<\");\n+  }\n+\n+  public void testLinenoCharnoBinaryAnd() throws Exception {\n+    testLinenoCharnoBinop(\"&\");\n+  }\n+\n+  public void testLinenoCharnoAnd() throws Exception {\n+    testLinenoCharnoBinop(\"&&\");\n+  }\n+\n+  public void testLinenoCharnoBinaryOr() throws Exception {\n+    testLinenoCharnoBinop(\"|\");\n+  }\n+\n+  public void testLinenoCharnoOr() throws Exception {\n+    testLinenoCharnoBinop(\"||\");\n+  }\n+\n+  public void testLinenoCharnoLt() throws Exception {\n+    testLinenoCharnoBinop(\"<\");\n+  }\n+\n+  public void testLinenoCharnoLe() throws Exception {\n+    testLinenoCharnoBinop(\"<=\");\n+  }\n+\n+  public void testLinenoCharnoGt() throws Exception {\n+    testLinenoCharnoBinop(\">\");\n+  }\n+\n+  public void testLinenoCharnoGe() throws Exception {\n+    testLinenoCharnoBinop(\">=\");\n+  }\n+\n+  private void testLinenoCharnoBinop(String binop) {\n+    Node op = parse(\"var a = 89 \" + binop + \" 76\").getFirstChild().\n+        getFirstChild().getFirstChild();\n+\n+    assertEquals(1, op.getLineno());\n+    assertEquals(11, op.getCharno());\n+  }\n+\n+  public void testJSDocAttachment1() {\n+    Node varNode = parse(\"/** @type number */var a;\").getFirstChild();\n+\n+    // VAR\n+    assertEquals(Token.VAR, varNode.getType());\n+    JSDocInfo info = varNode.getJSDocInfo();\n+    assertNotNull(info);\n+    assertTypeEquals(NUMBER_TYPE, info.getType());\n+\n+    // NAME\n+    Node nameNode = varNode.getFirstChild();\n+    assertEquals(Token.NAME, nameNode.getType());\n+    assertNull(nameNode.getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment2() {\n+    Node varNode = parse(\"/** @type number */var a,b;\").getFirstChild();\n+\n+    // VAR\n+    assertEquals(Token.VAR, varNode.getType());\n+    JSDocInfo info = varNode.getJSDocInfo();\n+    assertNotNull(info);\n+    assertTypeEquals(NUMBER_TYPE, info.getType());\n+\n+    // First NAME\n+    Node nameNode1 = varNode.getFirstChild();\n+    assertEquals(Token.NAME, nameNode1.getType());\n+    assertNull(nameNode1.getJSDocInfo());\n+\n+    // Second NAME\n+    Node nameNode2 = nameNode1.getNext();\n+    assertEquals(Token.NAME, nameNode2.getType());\n+    assertNull(nameNode2.getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment3() {\n+    Node assignNode = parse(\n+        \"/** @type number */goog.FOO = 5;\").getFirstChild().getFirstChild();\n+\n+    // ASSIGN\n+    assertEquals(Token.ASSIGN, assignNode.getType());\n+    JSDocInfo info = assignNode.getJSDocInfo();\n+    assertNotNull(info);\n+    assertTypeEquals(NUMBER_TYPE, info.getType());\n+  }\n+\n+  public void testJSDocAttachment4() {\n+    Node varNode = parse(\n+        \"var a, /** @define {number} */b = 5;\").getFirstChild();\n+\n+    // ASSIGN\n+    assertEquals(Token.VAR, varNode.getType());\n+    assertNull(varNode.getJSDocInfo());\n+\n+    // a\n+    Node a = varNode.getFirstChild();\n+    assertNull(a.getJSDocInfo());\n+\n+    // b\n+    Node b = a.getNext();\n+    JSDocInfo info = b.getJSDocInfo();\n+    assertNotNull(info);\n+    assertTrue(info.isDefine());\n+    assertTypeEquals(NUMBER_TYPE, info.getType());\n+  }\n+\n+  public void testJSDocAttachment5() {\n+    Node varNode = parse(\n+        \"var /** @type number */a, /** @define {number} */b = 5;\")\n+        .getFirstChild();\n+\n+    // ASSIGN\n+    assertEquals(Token.VAR, varNode.getType());\n+    assertNull(varNode.getJSDocInfo());\n+\n+    // a\n+    Node a = varNode.getFirstChild();\n+    assertNotNull(a.getJSDocInfo());\n+    JSDocInfo info = a.getJSDocInfo();\n+    assertNotNull(info);\n+    assertFalse(info.isDefine());\n+    assertTypeEquals(NUMBER_TYPE, info.getType());\n+\n+    // b\n+    Node b = a.getNext();\n+    info = b.getJSDocInfo();\n+    assertNotNull(info);\n+    assertTrue(info.isDefine());\n+    assertTypeEquals(NUMBER_TYPE, info.getType());\n+  }\n+\n+  /**\n+   * Tests that a JSDoc comment in an unexpected place of the code does not\n+   * propagate to following code due to {@link JSDocInfo} aggregation.\n+   */\n+  public void testJSDocAttachment6() throws Exception {\n+    Node functionNode = parse(\n+        \"var a = /** @param {number} index */5;\" +\n+        \"/** @return boolean */function f(index){}\")\n+        .getFirstChild().getNext();\n+\n+    assertEquals(Token.FUNCTION, functionNode.getType());\n+    JSDocInfo info = functionNode.getJSDocInfo();\n+    assertNotNull(info);\n+    assertFalse(info.hasParameter(\"index\"));\n+    assertTrue(info.hasReturnType());\n+  }\n+\n+  public void testJSDocAttachment7() {\n+    Node varNode = parse(\"/** */var a;\").getFirstChild();\n+\n+    // VAR\n+    assertEquals(Token.VAR, varNode.getType());\n+\n+    // NAME\n+    Node nameNode = varNode.getFirstChild();\n+    assertEquals(Token.NAME, nameNode.getType());\n+    assertNull(nameNode.getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment8() {\n+    Node varNode = parse(\"/** x */var a;\").getFirstChild();\n+\n+    // VAR\n+    assertEquals(Token.VAR, varNode.getType());\n+\n+    // NAME\n+    Node nameNode = varNode.getFirstChild();\n+    assertEquals(Token.NAME, nameNode.getType());\n+    assertNull(nameNode.getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment9() {\n+    Node varNode = parse(\"/** \\n x */var a;\").getFirstChild();\n+\n+    // VAR\n+    assertEquals(Token.VAR, varNode.getType());\n+\n+    // NAME\n+    Node nameNode = varNode.getFirstChild();\n+    assertEquals(Token.NAME, nameNode.getType());\n+    assertNull(nameNode.getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment10() {\n+    Node varNode = parse(\"/** x\\n */var a;\").getFirstChild();\n+\n+    // VAR\n+    assertEquals(Token.VAR, varNode.getType());\n+\n+    // NAME\n+    Node nameNode = varNode.getFirstChild();\n+    assertEquals(Token.NAME, nameNode.getType());\n+    assertNull(nameNode.getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment11() {\n+    Node varNode =\n+       parse(\"/** @type {{x : number, 'y' : string, z}} */var a;\")\n+        .getFirstChild();\n+\n+    // VAR\n+    assertEquals(Token.VAR, varNode.getType());\n+    JSDocInfo info = varNode.getJSDocInfo();\n+    assertNotNull(info);\n+\n+    assertTypeEquals(createRecordTypeBuilder().\n+                     addProperty(\"x\", NUMBER_TYPE).\n+                     addProperty(\"y\", STRING_TYPE).\n+                     addProperty(\"z\", UNKNOWN_TYPE).\n+                     build(),\n+                     info.getType());\n+\n+    // NAME\n+    Node nameNode = varNode.getFirstChild();\n+    assertEquals(Token.NAME, nameNode.getType());\n+    assertNull(nameNode.getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment12() {\n+    Node varNode =\n+       parse(\"var a = {/** @type {Object} */ b: c};\")\n+        .getFirstChild();\n+    Node objectLitNode = varNode.getFirstChild().getFirstChild();\n+    assertEquals(Token.OBJECTLIT, objectLitNode.getType());\n+    assertNotNull(objectLitNode.getFirstChild().getJSDocInfo());\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {\n+    assertNodeEquality(\n+        parse(\"var a = [1,2]\"),\n+        parse(\"/** @type Array.<number*/var a = [1,2]\",\n+            MISSING_GT_MESSAGE));\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing2() throws Exception {\n+    assertNodeEquality(\n+        parse(\"var a = [1,2]\"),\n+        parse(\"/** @type {Array.<number}*/var a = [1,2]\",\n+            MISSING_GT_MESSAGE));\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing3() throws Exception {\n+    assertNodeEquality(\n+        parse(\"C.prototype.say=function(nums) {alert(nums.join(','));};\"),\n+        parse(\"/** @param {Array.<number} nums */\" +\n+            \"C.prototype.say=function(nums) {alert(nums.join(','));};\",\n+            MISSING_GT_MESSAGE));\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing4() throws Exception {\n+    assertNodeEquality(\n+        parse(\"C.prototype.say=function(nums) {alert(nums.join(','));};\"),\n+        parse(\"/** @return boolean */\" +\n+            \"C.prototype.say=function(nums) {alert(nums.join(','));};\"));\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing5() throws Exception {\n+    assertNodeEquality(\n+        parse(\"C.prototype.say=function(nums) {alert(nums.join(','));};\"),\n+        parse(\"/** @param boolean this is some string*/\" +\n+            \"C.prototype.say=function(nums) {alert(nums.join(','));};\"));\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing6() throws Exception {\n+    assertNodeEquality(\n+        parse(\"C.prototype.say=function(nums) {alert(nums.join(','));};\"),\n+        parse(\"/** @param {bool!*%E$} */\" +\n+            \"C.prototype.say=function(nums) {alert(nums.join(','));};\",\n+              \"expected closing }\",\n+              \"expecting a variable name in a @param tag\"));\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception {\n+    assertNodeEquality(\n+        parse(\"C.prototype.say=function(nums) {alert(nums.join(','));};\"),\n+        parse(\"/** @see */\" +\n+            \"C.prototype.say=function(nums) {alert(nums.join(','));};\",\n+              \"@see tag missing description\"));\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing8() throws Exception {\n+    assertNodeEquality(\n+        parse(\"C.prototype.say=function(nums) {alert(nums.join(','));};\"),\n+        parse(\"/** @author */\" +\n+            \"C.prototype.say=function(nums) {alert(nums.join(','));};\",\n+              \"@author tag missing author\"));\n+  }\n+\n+  public void testIncorrectJSDocDoesNotAlterJSParsing9() throws Exception {\n+    assertNodeEquality(\n+        parse(\"C.prototype.say=function(nums) {alert(nums.join(','));};\"),\n+        parse(\"/** @someillegaltag */\" +\n+              \"C.prototype.say=function(nums) {alert(nums.join(','));};\",\n+              \"illegal use of unknown JSDoc tag \\\"someillegaltag\\\";\"\n+              + \" ignoring it\"));\n+  }\n+\n+  public void testUnescapedSlashInRegexpCharClass() throws Exception {\n+    // The tokenizer without the fix for this bug throws an error.\n+    parse(\"var foo = /[/]/;\");\n+    parse(\"var foo = /[hi there/]/;\");\n+    parse(\"var foo = /[/yo dude]/;\");\n+    parse(\"var foo = /\\\\/[@#$/watashi/wa/suteevu/desu]/;\");\n+  }\n+\n+  private void assertNodeEquality(Node expected, Node found) {\n+    String message = expected.checkTreeEquals(found);\n+    if (message != null) {\n+      fail(message);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testParse() {\n+    Node a = Node.newString(Token.NAME, \"a\");\n+    a.addChildToFront(Node.newString(Token.NAME, \"b\"));\n+    List<Pair<String, Node>> testCases = ImmutableList.of(\n+        Pair.of(\n+            \"3;\",\n+            createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))),\n+        Pair.of(\n+            \"var a = b;\",\n+             createScript(new Node(Token.VAR, a))),\n+        Pair.of(\n+            \"\\\"hell\\\\\\no\\\\ world\\\\\\n\\\\\\n!\\\"\",\n+             createScript(new Node(Token.EXPR_RESULT,\n+             Node.newString(Token.STRING, \"hello world!\")))));\n+\n+    for (Pair<String, Node> testCase : testCases) {\n+      assertNodeEquality(testCase.second, parse(testCase.first));\n+    }\n+  }\n+\n+  private Node createScript(Node n) {\n+    Node script = new ScriptOrFnNode(Token.SCRIPT);\n+    script.addChildToBack(n);\n+    return script;\n+  }\n+\n+  public void testTrailingCommaWarning1() {\n+    parse(\"var a = ['foo', 'bar'];\");\n+  }\n+\n+  public void testTrailingCommaWarning2() {\n+    parse(\"var a = ['foo',,'bar'];\");\n+  }\n+\n+  public void testTrailingCommaWarning3() {\n+    parse(\"var a = ['foo', 'bar',];\", TRAILING_COMMA_MESSAGE);\n+  }\n+\n+  public void testTrailingCommaWarning4() {\n+    parse(\"var a = [,];\", TRAILING_COMMA_MESSAGE);\n+  }\n+\n+  public void testTrailingCommaWarning5() {\n+    parse(\"var a = {'foo': 'bar'};\");\n+  }\n+\n+  public void testTrailingCommaWarning6() {\n+    parse(\"var a = {'foo': 'bar',};\", TRAILING_COMMA_MESSAGE);\n+  }\n+\n+  public void testTrailingCommaWarning7() {\n+    parseError(\"var a = {,};\", BAD_PROPERTY_MESSAGE);\n+  }\n+\n+  public void testConstForbidden() {\n+    parseError(\"const x = 3;\", \"Unsupported syntax: CONST\");\n+  }\n+\n+  public void testDestructuringAssignForbidden() {\n+    parseError(\"var [x, y] = foo();\", \"destructuring assignment forbidden\");\n+  }\n+\n+  public void testDestructuringAssignForbidden2() {\n+    parseError(\"var {x, y} = foo();\", \"missing : after property id\");\n+  }\n+\n+  public void testDestructuringAssignForbidden3() {\n+    parseError(\"var {x: x, y: y} = foo();\",\n+        \"destructuring assignment forbidden\");\n+  }\n+\n+  public void testDestructuringAssignForbidden4() {\n+    parseError(\"[x, y] = foo();\", \"destructuring assignment forbidden\");\n+  }\n+\n+  public void testLetForbidden() {\n+    parseError(\"function f() { let (x = 3) { alert(x); }; }\",\n+        \"missing ; before statement\", \"syntax error\");\n+  }\n+\n+  public void testYieldForbidden() {\n+    parseError(\"function f() { yield 3; }\", \"missing ; before statement\");\n+  }\n+\n+  public void testBracelessFunctionForbidden() {\n+    parseError(\"var sq = function(x) x * x;\",\n+        \"missing { before function body\");\n+  }\n+\n+  public void testGeneratorsForbidden() {\n+    parseError(\"var i = (x for (x in obj));\",\n+        \"missing ) in parenthetical\");\n+  }\n+\n+  public void testFileOverviewJSDoc1() {\n+    Node n = parse(\"/** @fileoverview Hi mom! */ function Foo() {}\");\n+    assertEquals(Token.FUNCTION, n.getFirstChild().getType());\n+    assertTrue(n.getJSDocInfo() != null);\n+    assertNull(n.getFirstChild().getJSDocInfo());\n+    assertEquals(\"Hi mom!\",\n+        n.getJSDocInfo().getFileOverview());\n+  }\n+\n+  public void testFileOverviewJSDocDoesNotHoseParsing() {\n+    assertEquals(\n+        Token.FUNCTION,\n+        parse(\"/** @fileoverview Hi mom! \\n */ function Foo() {}\")\n+            .getFirstChild().getType());\n+    assertEquals(\n+        Token.FUNCTION,\n+        parse(\"/** @fileoverview Hi mom! \\n * * * */ function Foo() {}\")\n+            .getFirstChild().getType());\n+    assertEquals(\n+        Token.FUNCTION,\n+        parse(\"/** @fileoverview \\n * x */ function Foo() {}\")\n+            .getFirstChild().getType());\n+    assertEquals(\n+        Token.FUNCTION,\n+        parse(\"/** @fileoverview \\n * x \\n */ function Foo() {}\")\n+            .getFirstChild().getType());\n+  }\n+\n+  public void testFileOverviewJSDoc2() {\n+    Node n = parse(\"/** @fileoverview Hi mom! */ \" +\n+        \"/** @constructor */ function Foo() {}\");\n+    assertTrue(n.getJSDocInfo() != null);\n+    assertEquals(\"Hi mom!\", n.getJSDocInfo().getFileOverview());\n+    assertTrue(n.getFirstChild().getJSDocInfo() != null);\n+    assertFalse(n.getFirstChild().getJSDocInfo().hasFileOverview());\n+    assertTrue(n.getFirstChild().getJSDocInfo().isConstructor());\n+  }\n+\n+  public void testObjectLiteralDoc1() {\n+    Node n = parse(\"var x = {/** @type {number} */ 1: 2};\");\n+\n+    Node objectLit = n.getFirstChild().getFirstChild().getFirstChild();\n+    assertEquals(Token.OBJECTLIT, objectLit.getType());\n+\n+    Node number = objectLit.getFirstChild();\n+    assertEquals(Token.NUMBER, number.getType());\n+    assertNotNull(number.getJSDocInfo());\n+  }\n+\n+  public void testDuplicatedParam() {\n+    parse(\"function foo(x, x) {}\", \"Duplicate parameter name \\\"x\\\".\");\n+  }\n+\n+  public void testLamestWarningEver() {\n+    // This used to be a warning.\n+    parse(\"var x = /** @type {undefined} */ (y);\");\n+    parse(\"var x = /** @type {void} */ (y);\");\n+  }\n+\n+  public void testParseBlockDescription() {\n+    Node n = parse(\"/** This is a variable. */ var x;\");\n+    Node var = n.getFirstChild();\n+    assertNotNull(var.getJSDocInfo());\n+    assertEquals(\"This is a variable.\",\n+        var.getJSDocInfo().getBlockDescription());\n+  }\n+\n+  private void parseError(String string, String... errors) {\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null);\n+    Node script = null;\n+    try {\n+      script = ParserRunner.parse(\n+          \"input\", string, true, registry,\n+          testErrorReporter, Logger.getAnonymousLogger());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    // verifying that all warnings were seen\n+    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n+    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n+  }\n+\n+  private Node parse(String string, String... warnings) {\n+    TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings);\n+    Node script = null;\n+    try {\n+      script = ParserRunner.parse(\n+          \"input\", string,  true, registry,\n+          testErrorReporter, Logger.getAnonymousLogger());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    // verifying that all warnings were seen\n+    assertTrue(testErrorReporter.hasEncounteredAllErrors());\n+    assertTrue(testErrorReporter.hasEncounteredAllWarnings());\n+\n+    return script;\n+  }\n+}", "timestamp": 1259802762, "metainfo": ""}