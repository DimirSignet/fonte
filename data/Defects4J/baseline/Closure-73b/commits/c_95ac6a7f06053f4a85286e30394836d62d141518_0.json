{"sha": "95ac6a7f06053f4a85286e30394836d62d141518", "log": "Handle bleeding functions in local scopes.  R=acleung DELTA=134  (90 added, 29 deleted, 15 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=519   ", "commit": "\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.Comparator;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import javax.annotation.Nullable;\n \n-\n /**\n  * RenameVars renames all the variables names into short names, to reduce\n  * code size and also to obfuscate the code.\n \n   /** Logs all name assignments */\n   private StringBuilder assignmentLog;\n+\n+  // Logic for bleeding functions, where the name leaks into the outer\n+  // scope on IE but not on other browsers.\n+  private Set<Var> localBleedingFunctions = Sets.newHashSet();\n+  private ArrayListMultimap<Scope, Var> localBleedingFunctionsPerScope =\n+      ArrayListMultimap.create();\n \n   class Assignment {\n     final CompilerInput input;\n    * function x(a,b) { ... }\n    * function y(a,b,c) { ... }\n    */\n-  class ProcessVars extends AbstractPostOrderCallback {\n+  class ProcessVars extends AbstractPostOrderCallback\n+      implements ScopedCallback {\n     private final boolean isExternsPass_;\n \n     ProcessVars(boolean isExterns) {\n       isExternsPass_ = isExterns;\n     }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      if (t.inGlobalScope()) return;\n+\n+      Iterator<Var> it = t.getScope().getVars();\n+      while (it.hasNext()) {\n+        Var current = it.next();\n+        if (current.isBleedingFunction()) {\n+          localBleedingFunctions.add(current);\n+          localBleedingFunctionsPerScope.put(\n+              t.getScope().getParent(), current);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {}\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n \n       if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + getLocalVarIndex(var);\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         n.setString(tempName);\n   private boolean okToRenameVar(String name, boolean isLocal) {\n     return !compiler.getCodingConvention().isExported(name, isLocal);\n   }\n+\n+  /**\n+   * Returns the index within the scope stack.\n+   * e.g. function Foo(a) { var b; function c(d) { } }\n+   * a = 0, b = 1, c = 2, d = 3\n+   */\n+  private int getLocalVarIndex(Var v) {\n+    int num = v.index;\n+    Scope s = v.scope.getParent();\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Var is not local\");\n+    }\n+\n+    boolean isBleedingIntoScope = s.getParent() != null &&\n+        localBleedingFunctions.contains(v);\n+\n+    while (s.getParent() != null) {\n+      if (isBleedingIntoScope) {\n+        num += localBleedingFunctionsPerScope.get(s).indexOf(v) + 1;\n+        isBleedingIntoScope = false;\n+      } else {\n+        num += localBleedingFunctionsPerScope.get(s).size();\n+      }\n+\n+      num += s.getVarCount();\n+      s = s.getParent();\n+    }\n+    return num;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n public class Scope implements StaticScope<JSType> {\n   private final Map<String, Var> vars = new LinkedHashMap<String, Var>();\n   private final Scope parent;\n+  private final int depth;\n   private final Node rootNode;\n \n   /** The type of {@code this} in the current scope. */\n   /** Stores info about a variable */\n   public static class Var implements StaticSlot<JSType> {\n     /** name */\n-    String name;\n+    final String name;\n \n     /** Var node */\n-    Node nameNode;\n+    final Node nameNode;\n \n     /**\n      * The variable's type.\n     /**\n      * The variable's doc info.\n      */\n-    private JSDocInfo info = null;\n+    private final JSDocInfo info;\n \n     /**\n      * Whether the variable's type has been inferred or is declared. An inferred\n     private final boolean typeInferred;\n \n     /** Input source */\n-    CompilerInput input;\n+    final CompilerInput input;\n \n     /** Whether the variable is a define */\n-    boolean isDefine;\n+    final boolean isDefine;\n \n     /**\n      * The index at which the var is declared. e..g if it's 0, it's the first\n      * declared variable in that scope\n      */\n-    int index;\n+    final int index;\n \n     /** The enclosing scope */\n-    Scope scope;\n+    final Scope scope;\n \n     /**\n      * Creates a variable.\n      *\n      * @param inferred whether its type is inferred (as opposed to declared)\n      */\n-    private Var(boolean inferred) {\n+    private Var(boolean inferred, String name, Node nameNode, JSType type,\n+                Scope scope, int index, CompilerInput input, boolean isDefine,\n+                JSDocInfo info) {\n+      this.name = name;\n+      this.nameNode = nameNode;\n+      this.type = type;\n+      this.scope = scope;\n+      this.index = index;\n+      this.input = input;\n+      this.isDefine = isDefine;\n+      this.info = info;\n       this.typeInferred = inferred;\n     }\n \n      */\n     Scope getScope() {\n       return scope;\n-    }\n-\n-    /**\n-     * Returns the index within the scope stack.\n-     * e.g. function Foo(a) { var b; function c(d) { } }\n-     * a = 0, b = 1, c = 2, d = 3\n-     */\n-    int getLocalVarIndex() {\n-      int num = index;\n-      Scope s = scope.getParent();\n-      if (s == null) {\n-        throw new IllegalArgumentException(\"Var is not local\");\n-      }\n-      while (s.getParent() != null) {\n-        num += s.getVarCount();\n-        s = s.getParent();\n-      }\n-      return num;\n     }\n \n     /**\n       thisType = parent.thisType;\n     }\n     this.isBottom = false;\n+    this.depth = parent.depth + 1;\n   }\n \n \n     this.rootNode = rootNode;\n     thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n     this.isBottom = false;\n+    this.depth = 0;\n   }\n \n   /**\n     this.rootNode = rootNode;\n     this.thisType = thisType;\n     this.isBottom = true;\n+    this.depth = 0;\n+  }\n+\n+  /** The depth of the scope. The global scope has depth 0. */\n+  int getDepth() {\n+    return depth;\n   }\n \n   /** Whether this is the bottom of the lattice. */\n     // Make sure that it's declared only once\n     Preconditions.checkState(vars.get(name) == null);\n \n-    Var var = new Var(inferred);\n-    var.name = name;\n-    var.nameNode = nameNode;\n-    var.type = type;\n-    var.scope = this;\n-    var.index = vars.size();\n-    var.input = input;\n-\n     // native variables do not have a name node.\n     // TODO(user): make Var abstract and have NativeVar, NormalVar.\n     JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);\n \n-    var.isDefine = info != null && info.isDefine();\n-    var.info = info;\n+    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input,\n+        info != null && info.isDefine(), info);\n \n     vars.put(name, var);\n     return var;\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n   }\n \n   public void testBleedingRecursiveFunctions2() {\n-    // TODO(nicksantos): Ensure a and b get separate names. Will fix this\n-    // in the CL that handles 2nd-level scopes.\n     test(\"function f() {\" +\n          \"  var x = function a(x) { return x ? 1 : a(1); };\" +\n          \"  var y = function b(x) { return x ? 2 : b(2); };\" +\n          \"}\",\n-         \"function c() {\" +\n-         \"  var d = function a(b) { return b ? 1 : a(1); };\" +\n-         \"  var e = function a(b) { return b ? 2 : a(2); };\" +\n+         \"function d() {\" +\n+         \"  var e = function b(a) { return a ? 1 : b(1); };\" +\n+         \"  var f = function a(c) { return c ? 2 : a(2); };\" +\n+         \"}\");\n+  }\n+\n+  public void testBleedingRecursiveFunctions3() {\n+    test(\"function f() {\" +\n+         \"  var x = function a(x) { return x ? 1 : a(1); };\" +\n+         \"  var y = function b(x) { return x ? 2 : b(2); };\" +\n+         \"  var z = function c(x) { return x ? y : c(2); };\" +\n+         \"}\",\n+         \"function f() {\" +\n+         \"  var g = function c(a) { return a ? 1 : c(1); };\" +\n+         \"  var d = function a(b) { return b ? 2 : a(2); };\" +\n+         \"  var h = function b(e) { return e ? d : b(2); };\" +\n          \"}\");\n   }\n ", "timestamp": 1297720231, "metainfo": ""}