{"sha": "b326ab0a322d0ece76e61955852ada034122192b", "log": "Introduces a late peephole optimization pass.  R=johnlenz DELTA=206  (116 added, 57 deleted, 33 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=783   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(renameLabels);\n     }\n \n+    if (options.foldConstants) {\n+      passes.add(latePeepholeOptimizations);\n+    }\n+\n     if (options.anonymousFunctionNaming ==\n         AnonymousFunctionNamingPolicy.UNMAPPED) {\n       passes.add(nameUnmappedAnonymousFunctions);\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new PeepholeOptimizationsPass(compiler,\n-            new PeepholeSubstituteAlternateSyntax(),\n+            new PeepholeSubstituteAlternateSyntax(true),\n             new PeepholeRemoveDeadCode(),\n+            new PeepholeFoldConstants());\n+    }\n+  };\n+\n+  /** Same as peepholeOptimizations but aggreesively merges code together */\n+  private final PassFactory latePeepholeOptimizations =\n+      new PassFactory(\"peepholeOptimizations\", false) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new PeepholeOptimizationsPass(compiler,\n+            new StatementFusion(),\n+            new PeepholeRemoveDeadCode(),\n+            new PeepholeSubstituteAlternateSyntax(false),\n             new PeepholeFoldConstants());\n     }\n   };\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.collect.ImmutableSet;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n \n  * some useless code removal, some minimizations).\n  *\n  * @author dcc@google.com (Devin Coughlin)\n+ * @author acleung@google.com (Alan Leung)(\n  */\n class PeepholeOptimizationsPass extends AbstractPostOrderCallback\n     implements CompilerPass {\n   // TODO should sort based on likelihood that a given optimzation can\n   // modify something.\n   private final AbstractPeepholeOptimization[] peepholeOptimizations;\n-\n \n   /**\n    * Creates a peephole optimization pass that runs the given\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n \n   private Node tryFoldComma(Node n) {\n     // If the left side does nothing replace the comma with the result.\n-\n     Node parent = n.getParent();\n     Node left = n.getFirstChild();\n     Node right = left.getNext();\n       parent.replaceChild(n, right);\n       reportCodeChange();\n       return right;\n-    } else {\n-      if (parent.getType() == Token.EXPR_RESULT\n-          && parent.getParent().getType() != Token.LABEL) {\n-        // split comma\n-        n.detachChildren();\n-        // Replace the original expression with the left operand.\n-        parent.replaceChild(n, left);\n-        // Add the right expression afterward.\n-        Node newStatement = new Node(Token.EXPR_RESULT, right);\n-        newStatement.copyInformationFrom(n);\n-\n-        //This modifies outside the subtree, which is not\n-        //desirable in a peephole optimization.\n-        parent.getParent().addChildAfter(newStatement, parent);\n-        reportCodeChange();\n-        return left;\n-      }\n-    }\n-\n+    }\n     return n;\n   }\n \n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n   private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n   private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n \n+  private final boolean doCommaSpliting;\n+\n   static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n     DiagnosticType.error(\n         \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n       return input.getType() != Token.FUNCTION;\n     }\n   };\n+\n+  PeepholeSubstituteAlternateSyntax(boolean doCommaSpliting) {\n+    this.doCommaSpliting = doCommaSpliting;\n+  }\n \n   /**\n    * Tries apply our various peephole minimizations on the passed in node.\n       case Token.CALL:\n         return tryFoldLiteralConstructor(node);\n \n+      case Token.COMMA:\n+        return tryFoldComma(node);\n+\n       case Token.NAME:\n         return tryReplaceUndefined(node);\n \n       default:\n         return node; //Nothing changed\n+    }\n+  }\n+\n+  private Node tryFoldComma(Node n) {\n+    if (!doCommaSpliting) {\n+      return n;\n+    }\n+    Node parent = n.getParent();\n+    Node left = n.getFirstChild();\n+    Node right = n.getLastChild();\n+\n+    if (parent.getType() == Token.EXPR_RESULT\n+        && parent.getParent().getType() != Token.LABEL) {\n+      // split comma\n+      n.detachChildren();\n+      // Replace the original expression with the left operand.\n+      parent.replaceChild(n, left);\n+      // Add the right expression afterward.\n+      Node newStatement = new Node(Token.EXPR_RESULT, right);\n+      newStatement.copyInformationFrom(n);\n+\n+      //This modifies outside the subtree, which is not\n+      //desirable in a peephole optimization.\n+      parent.getParent().addChildAfter(newStatement, parent);\n+      reportCodeChange();\n+      return left;\n+    } else {\n+      return n;\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n \n         new PeepholeOptimizationsPass(compiler,\n             new PeepholeRemoveDeadCode(),\n-            new PeepholeSubstituteAlternateSyntax(),\n+            new PeepholeSubstituteAlternateSyntax(true),\n             new PeepholeFoldConstants())\n             .process(externs, js);\n         new MinimizeExitPoints(compiler).process(externs, js);\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n  */\n public class PeepholeIntegrationTest extends CompilerTestCase {\n \n+  private boolean doCommaSplitting = true;\n+\n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private PeepholeIntegrationTest(boolean compareAsTree) {\n     super(\"\", compareAsTree);\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-\n+    this.doCommaSplitting = true;\n     enableLineNumberCheck(true);\n \n     // TODO(nicksantos): Turn this on. There are some normalizations\n   public CompilerPass getProcessor(final Compiler compiler) {\n     PeepholeOptimizationsPass peepholePass =\n       new PeepholeOptimizationsPass(compiler,\n-        new PeepholeSubstituteAlternateSyntax(),\n+        new PeepholeSubstituteAlternateSyntax(doCommaSplitting),\n         new PeepholeRemoveDeadCode(),\n         new PeepholeFoldConstants()\n       );\n     fold(\"if(!3){x()}\", \"\");\n     fold(\"if(!!3){x()}\", \"x()\");\n   }\n+\n+  public void testCommaSplitingConstantCondition() {\n+    fold(\"(b=0,b=1);if(b)x=b;\", \"b=0;b=1;x=b;\");\n+    fold(\"(b=0,b=1);if(b)x=b;\", \"b=0;b=1;x=b;\");\n+  }\n+\n+  public void testAvoidCommaSplitting() {\n+    fold(\"x(),y(),z()\", \"x();y();z()\");\n+    doCommaSplitting = false;\n+    foldSame(\"x(),y(),z()\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeOptimizationsPassTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeOptimizationsPassTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n  */\n public class PeepholeOptimizationsPassTest extends CompilerTestCase {\n \n-  private ImmutableSet<AbstractPeepholeOptimization> currentPeepholePasses;\n+  private ImmutableList<AbstractPeepholeOptimization> currentPeepholePasses;\n \n   @Override\n   public void setUp() throws Exception {\n    * optimizations are turned on.\n    */\n   public void testEmptyPass() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of();\n+    currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of();\n \n     testSame(\"var x; var y;\");\n   }\n     };\n \n     currentPeepholePasses =\n-      ImmutableSet.<AbstractPeepholeOptimization>of(note1Applied, note2Applied);\n+      ImmutableList.<\n+       AbstractPeepholeOptimization>of(note1Applied, note2Applied);\n \n     test(\"var x; var y\", \"var x; var y\");\n \n   }\n \n   public void testOptimizationRemovingSubtreeChild() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new\n+    currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(new\n           RemoveNodesNamedXUnderVarOptimization());\n \n     test(\"var x,y;\", \"var y;\");\n   }\n \n   public void testOptimizationRemovingSubtree() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new\n+    currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(new\n           RemoveNodesNamedXOptimization());\n \n     test(\"var x,y;\", \"var y;\");\n   }\n \n   public void testOptimizationRemovingSubtreeParent() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new\n+    currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(new\n           RemoveParentVarsForNodesNamedX());\n \n     test(\"var x; var y\", \"var y\");\n    * second wants to remove (the now nonexistent) parent of that node.\n    */\n   public void testOptimizationsRemoveParentAfterRemoveChild() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(\n+    currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(\n           new RemoveNodesNamedXOptimization(),\n           new RemoveParentVarsForNodesNamedX());\n \n   }\n \n   public void testOptimizationReplacingNode() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(\n+    currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(\n           new RenameYToX(),\n           new RemoveParentVarsForNodesNamedX());\n \n--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n     fold(\"a() ? b() : true\", \"a() && b()\");\n     fold(\"a() ? true : b()\", \"a() || b()\");\n \n-    fold(\"(a = true) ? b() : c()\", \"a = true; b()\");\n-    fold(\"(a = false) ? b() : c()\", \"a = false; c()\");\n+    fold(\"(a = true) ? b() : c()\", \"a = true, b()\");\n+    fold(\"(a = false) ? b() : c()\", \"a = false, c()\");\n     fold(\"do {f()} while((a = true) ? b() : c())\",\n          \"do {f()} while((a = true) , b())\");\n     fold(\"do {f()} while((a = false) ? b() : c())\",\n     fold(\"var b=/ab/;if(b)x=1;\", \"var b=/ab/;x=1\");\n     foldSame(\"var b=f();if(b)x=1;\");\n     foldSame(\"b=b++;if(b)x=b;\");\n-    fold(\"(b=0,b=1);if(b)x=b;\", \"b=0;b=1;x=b;\");\n+    fold(\"(b=0,b=1);if(b)x=b;\", \"b=0,b=1;if(b)x=b;\");\n     fold(\"b=1;if(foo,b)x=b;\",\"b=1;x=b;\");\n     foldSame(\"b=1;if(foo=1,b)x=b;\");\n   }\n \n   public void testConstantConditionWithSideEffect2() {\n-    fold(\"(b=true)?x=1:x=2;\", \"b=true;x=1\");\n-    fold(\"(b=false)?x=1:x=2;\", \"b=false;x=2\");\n+    fold(\"(b=true)?x=1:x=2;\", \"b=true,x=1\");\n+    fold(\"(b=false)?x=1:x=2;\", \"b=false,x=2\");\n     fold(\"if (b=/ab/) x=1;\", \"b=/ab/;x=1\");\n     fold(\"var b;b=/ab/;(b)?x=1:x=2;\", \"var b;b=/ab/;x=1\");\n     foldSame(\"var b;b=f();(b)?x=1:x=2;\");\n     fold(\"(1 + 2 + ''), foo()\", \"foo()\");\n   }\n \n-  public void testSplitCommaExpressions() {\n-    // Don't try to split in expressions.\n-    foldSame(\"while (foo(), true) boo()\");\n-    foldSame(\"var a = (foo(), true);\");\n-    foldSame(\"a = (foo(), true);\");\n-\n-    // Don't try to split COMMA under LABELs.\n-    foldSame(\"a:a(),b()\");\n-\n-    fold(\"(x=2), foo()\", \"x=2; foo()\");\n-    fold(\"foo(), boo();\", \"foo(); boo()\");\n-    fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");\n-    fold(\"foo(), true\", \"foo();\");\n-    fold(\"function x(){foo(), true}\", \"function x(){foo();}\");\n-  }\n \n   public void testRemoveUselessOps() {\n     // There are four place where expression results are discarded:\n \n     // Known side-effect free functions calls are removed.\n     fold(\"Math.random()\", \"\");\n-    fold(\"Math.random(f() + g())\", \"f(); g();\");\n-    fold(\"Math.random(f(),g(),h())\", \"f();g();h();\");\n+    fold(\"Math.random(f() + g())\", \"f(),g();\");\n+    fold(\"Math.random(f(),g(),h())\", \"f(),g(),h();\");\n \n     // Calls to functions with unknown side-effects are are left.\n     foldSame(\"f();\");\n     fold(\"a=(+f(),g())\", \"a=(f(),g())\");\n     fold(\"a=(true,g())\", \"a=g()\");\n     fold(\"f(),true\", \"f()\");\n-    fold(\"f() + g()\", \"f();g()\");\n+    fold(\"f() + g()\", \"f(),g()\");\n \n     fold(\"for(;;+f()){}\", \"for(;;f()){}\");\n     fold(\"for(+f();;g()){}\", \"for(f();;g()){}\");\n   }\n \n   public void testNoRemoveCall2() {\n-    test(\"a()+b()\", \"a();b()\");\n+    test(\"a()+b()\", \"a(),b()\");\n   }\n \n   public void testNoRemoveCall3() {\n \n   public void testShortCircuit4() {\n     testSame(\"a() && 1 && b()\");\n-  }\n-\n-  public void testComma1() {\n-    test(\"1, 2\", \"\");\n-  }\n-\n-  public void testComma2() {\n-    test(\"1, a()\", \"a()\");\n-  }\n-\n-  public void testComma3() {\n-    test(\"1, a(), b()\", \"a();b()\");\n-  }\n-\n-  public void testComma4() {\n-    test(\"a(), b()\", \"a();b()\");\n-  }\n-\n-  public void testComma5() {\n-    test(\"a(), b(), 1\", \"a();b()\");\n   }\n \n   public void testComplex1() {\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n       \"var RegExp = function f(a){};\\n\" +\n       \"var Array = function f(a){};\\n\";\n \n+  private boolean doCommaSplitting = true;\n+\n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private PeepholeSubstituteAlternateSyntaxTest(boolean compareAsTree) {\n     super(FOLD_CONSTANTS_TEST_EXTERNS, compareAsTree);\n \n   @Override\n   public void setUp() throws Exception {\n+    doCommaSplitting = true;\n     super.setUp();\n-\n     enableLineNumberCheck(true);\n   }\n \n   public CompilerPass getProcessor(final Compiler compiler) {\n     CompilerPass peepholePass =\n       new PeepholeOptimizationsPass(compiler,\n-          new PeepholeSubstituteAlternateSyntax());\n+          new PeepholeSubstituteAlternateSyntax(doCommaSplitting));\n \n     return peepholePass;\n   }\n         \"function f() {var undefined=2;var x = undefined;}\");\n   }\n \n-  public void testFoldIfAfterStatementFusion() {\n-    fold(\"if (x) { a,b,c } else { d,c,e }\", \"x ? (a,b,c) : (d,c,e)\");\n-    fold(\"if (x) { a() && b() } else { c() && d () }\",\n-         \"x ? a() && b() : c() && d () \");\n-    fold(\"if (x) { (a(),a()) && b() } else { d() }\",\n-         \"x ? (a(),a()) && b() : d () \");\n-    fold(\"if (x) { (a(),a()) && b() } else { (c(),c()) && d () }\",\n-         \"x ? (a(),a()) && b() : (c(),c()) && d () \");\n+  public void testSplitCommaExpressions() {\n+    // Don't try to split in expressions.\n+    foldSame(\"while (foo(), !0) boo()\");\n+    foldSame(\"var a = (foo(), !0);\");\n+    foldSame(\"a = (foo(), !0);\");\n+\n+    // Don't try to split COMMA under LABELs.\n+    foldSame(\"a:a(),b()\");\n+\n+    fold(\"(x=2), foo()\", \"x=2; foo()\");\n+    fold(\"foo(), boo();\", \"foo(); boo()\");\n+    fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");\n+    fold(\"foo(), true\", \"foo();1\");\n+    fold(\"function x(){foo(), !0}\", \"function x(){foo(); 1}\");\n+  }\n+\n+  public void testComma1() {\n+    fold(\"1, 2\", \"1; 1\");\n+    doCommaSplitting = false;\n+    foldSame(\"1, 2\");\n+  }\n+\n+  public void testComma2() {\n+    test(\"1, a()\", \"1; a()\");\n+    doCommaSplitting = false;\n+    foldSame(\"1, a()\");\n+  }\n+\n+  public void testComma3() {\n+    test(\"1, a(), b()\", \"1; a(); b()\");\n+    doCommaSplitting = false;\n+    foldSame(\"1, a(), b()\");\n+  }\n+\n+  public void testComma4() {\n+    test(\"a(), b()\", \"a();b()\");\n+    doCommaSplitting = false;\n+    foldSame(\"a(), b()\");\n+  }\n+\n+  public void testComma5() {\n+    test(\"a(), b(), 1\", \"a();b();1\");\n+    doCommaSplitting = false;\n+    foldSame(\"a(), b(), 1\");\n   }\n }", "timestamp": 1299543571, "metainfo": ""}