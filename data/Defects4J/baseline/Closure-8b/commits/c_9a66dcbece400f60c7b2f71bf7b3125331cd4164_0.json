{"sha": "9a66dcbece400f60c7b2f71bf7b3125331cd4164", "log": "Add symbol table references for closure primitives  R=acleung DELTA=136  (106 added, 8 deleted, 22 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2928   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     return preprocessorSymbolTable;\n   }\n \n+  void maybeInitializePreprocessorSymbolTable(AbstractCompiler compiler) {\n+    if (options.ideMode) {\n+      Node root = compiler.getRoot();\n+      if (preprocessorSymbolTable == null ||\n+          preprocessorSymbolTable.getRootNode() != root) {\n+        preprocessorSymbolTable = new PreprocessorSymbolTable(root);\n+      }\n+    }\n+  }\n+\n   @Override\n   protected List<PassFactory> getChecks() {\n     List<PassFactory> checks = Lists.newArrayList();\n       new HotSwapPassFactory(\"processProvidesAndRequires\", false) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+      maybeInitializePreprocessorSymbolTable(compiler);\n       final ProcessClosurePrimitives pass = new ProcessClosurePrimitives(\n           compiler,\n+          preprocessorSymbolTable,\n           options.brokenClosureRequiresLevel,\n           options.rewriteNewDateGoogNow);\n \n       new HotSwapPassFactory(\"processGoogScopeAliases\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n-      if (options.ideMode) {\n-        preprocessorSymbolTable =\n-            new PreprocessorSymbolTable(compiler.getRoot());\n-      }\n-\n+      maybeInitializePreprocessorSymbolTable(compiler);\n       return new ScopedAliases(\n           compiler,\n           preprocessorSymbolTable,\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n import java.util.Map;\n import java.util.Set;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Replaces goog.provide calls, removes goog.require calls, verifies that\n  * goog.require has a corresponding goog.provide and some closure specific\n   private final Set<String> exportedVariables = Sets.newHashSet();\n   private final CheckLevel requiresLevel;\n   private final boolean rewriteNewDateGoogNow;\n+  private final PreprocessorSymbolTable preprocessorSymbolTable;\n \n   ProcessClosurePrimitives(AbstractCompiler compiler,\n-                           CheckLevel requiresLevel,\n-                           boolean rewriteNewDateGoogNow) {\n+      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n+      CheckLevel requiresLevel,\n+      boolean rewriteNewDateGoogNow) {\n     this.compiler = compiler;\n+    this.preprocessorSymbolTable = preprocessorSymbolTable;\n     this.moduleGraph = compiler.getModuleGraph();\n     this.requiresLevel = requiresLevel;\n     this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n       // leave this here this time and let it error next time if it\n       // is still not provided.\n       if (provided != null || requiresLevel.isOn()) {\n+        maybeAddToSymbolTable(left);\n+        maybeAddStringNodeToSymbolTable(arg);\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     Node arg = left.getNext();\n     if (verifyProvide(t, left, arg)) {\n       String ns = arg.getString();\n+\n+      maybeAddToSymbolTable(left);\n+      maybeAddStringNodeToSymbolTable(arg);\n+\n       if (providedNames.containsKey(ns)) {\n         ProvidedName previouslyProvided = providedNames.get(ns);\n         if (!previouslyProvided.isExplicitlyProvided()) {\n           ? firstNode : provideStringNode;\n       newNode.copyInformationFromForTree(sourceInfoNode);\n       if (offset != 0) {\n-        newNode.setSourcePositionForTree(\n-            newNode.getSourcePosition() + offset);\n+        newNode.setSourceEncodedPositionForTree(\n+            sourceInfoNode.getSourcePosition() + offset);\n       }\n     }\n \n       && !value.hasChildren();\n   }\n \n+  /**\n+   * The string in {@code n} is a reference name. Create a synthetic\n+   * node for it with all the proper source info, and add it to the symbol\n+   * table.\n+   */\n+  private void maybeAddStringNodeToSymbolTable(Node n) {\n+    if (preprocessorSymbolTable == null) {\n+      return;\n+    }\n+\n+    String name = n.getString();\n+    Node syntheticRef = NodeUtil.newQualifiedNameNode(\n+        compiler.getCodingConvention(), name,\n+        n /* real source offsets will be filled in below */,\n+        name);\n+\n+    // Offsets to add to source. Named for documentation purposes.\n+    final int FOR_QUOTE = 1;\n+    final int FOR_DOT = 1;\n+\n+    Node current = null;\n+    for (current = syntheticRef;\n+         current.getType() == Token.GETPROP;\n+         current = current.getFirstChild()) {\n+      int fullLen = current.getQualifiedName().length();\n+      int namespaceLen = current.getFirstChild().getQualifiedName().length();\n+\n+      current.setSourceEncodedPosition(n.getSourcePosition() + FOR_QUOTE);\n+      current.setLength(fullLen);\n+\n+      current.getLastChild().setSourceEncodedPosition(\n+          n.getSourcePosition() + namespaceLen + FOR_QUOTE + FOR_DOT);\n+      current.getLastChild().setLength(\n+          current.getLastChild().getString().length());\n+    }\n+\n+    current.setSourceEncodedPosition(n.getSourcePosition() + FOR_QUOTE);\n+    current.setLength(current.getString().length());\n+\n+    maybeAddToSymbolTable(syntheticRef);\n+  }\n+\n+  /**\n+   * Add the given qualified name node to the symbol table.\n+   */\n+  private void maybeAddToSymbolTable(Node n) {\n+    if (preprocessorSymbolTable != null) {\n+      preprocessorSymbolTable.addReference(n);\n+    }\n+  }\n+\n   // -------------------------------------------------------------------------\n \n   /**\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n     }\n     if (lineno < 1 || lineno > lineOffsets.length) {\n       throw new IllegalArgumentException(\n-          \"Expected line number between 1 and \" + lineOffsets.length);\n+          \"Expected line number between 1 and \" + lineOffsets.length +\n+          \"\\nActual: \" + lineno);\n     }\n     return lineOffsets[lineno - 1];\n   }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       sourcePosition = mergeLineCharNo(getLineno(), charno);\n   }\n \n-  public void setSourcePositionForTree(int sourcePosition) {\n+  public void setSourceEncodedPosition(int sourcePosition) {\n+    this.sourcePosition = sourcePosition;\n+  }\n+\n+  public void setSourceEncodedPositionForTree(int sourcePosition) {\n     this.sourcePosition = sourcePosition;\n \n     for (Node child = getFirstChild();\n          child != null; child = child.getNext()) {\n-      child.setSourcePositionForTree(sourcePosition);\n+      child.setSourceEncodedPositionForTree(sourcePosition);\n     }\n   }\n \n         putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n     }\n \n+    if (getProp(STATIC_SOURCE_FILE) == null) {\n+      putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE));\n+    }\n+\n     if (getProp(SOURCENAME_PROP) == null) {\n       putProp(SOURCENAME_PROP, other.getProp(SOURCENAME_PROP));\n-      sourcePosition = other.sourcePosition;\n-    }\n-\n-    if (getProp(STATIC_SOURCE_FILE) == null) {\n-      putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE));\n-    }\n-\n+    }\n+\n+    sourcePosition = other.sourcePosition;\n     return this;\n   }\n \n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         0, compiler.getErrorCount());\n \n     // For processing goog.addDependency for forward typedefs.\n-    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n+    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n         .process(null, n);\n \n     CodingConvention convention = compiler.getCodingConvention();\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n \n   @Override public CompilerPass getProcessor(final Compiler compiler) {\n     if ((additionalCode == null) && (additionalEndCode == null)) {\n-      return new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true);\n+      return new ProcessClosurePrimitives(\n+          compiler, null, CheckLevel.ERROR, true);\n     } else {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n           // Process the original code.\n-          new ProcessClosurePrimitives(compiler, CheckLevel.OFF, true)\n+          new ProcessClosurePrimitives(compiler, null, CheckLevel.OFF, true)\n               .process(externs, root);\n \n           // Inject additional code at the beginning.\n           }\n \n           // Process the tree a second time.\n-          new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n+          new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n               .process(externs, root);\n         }\n       };\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n     @Override\n     public void process(Node externs, Node root) {\n       ProcessClosurePrimitives closurePass =\n-          new ProcessClosurePrimitives(compiler, CheckLevel.WARNING, true);\n+          new ProcessClosurePrimitives(\n+              compiler, null, CheckLevel.WARNING, true);\n       closurePass.process(externs, root);\n       renameVars = new RenameVars(compiler, prefix,\n           false, false, false, false, previouslyUsedMap, null,\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(2, Iterables.size(table.getReferences(googScope)));\n   }\n \n+  public void testGoogRequireReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"var goog = {};\" +\n+        \"goog.provide = function() {};\" +\n+        \"goog.require = function() {};\" +\n+        \"goog.provide('goog.dom');\" +\n+        \"goog.require('goog.dom');\");\n+    Symbol goog = getGlobalVar(table, \"goog\");\n+    assertNotNull(goog);\n+\n+    // 8 references:\n+    // 5 in code\n+    // 2 in strings\n+    // 1 created by ProcessClosurePrimitives when it processes the provide.\n+    //\n+    // NOTE(nicksantos): In the future, we may de-dupe references such\n+    // that the one in the goog.provide string and the one created by\n+    // ProcessClosurePrimitives count as the same reference.\n+    assertEquals(8, Iterables.size(table.getReferences(goog)));\n+  }\n+\n   public void testGlobalVarInExterns() throws Exception {\n     SymbolTable table = createSymbolTable(\"customExternFn(1);\");\n     Symbol fn = getGlobalVar(table, \"customExternFn\");\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         0, compiler.getErrorCount());\n \n     // For processing goog.addDependency for forward typedefs.\n-    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n+    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n         .process(null, n);\n \n     CodingConvention convention = compiler.getCodingConvention();", "timestamp": 1312836257, "metainfo": ""}