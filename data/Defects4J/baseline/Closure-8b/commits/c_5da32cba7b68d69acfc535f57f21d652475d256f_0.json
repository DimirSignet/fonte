{"sha": "5da32cba7b68d69acfc535f57f21d652475d256f", "log": "Change on 2010/04/19 by anatol          Replace {@inheritDoc} javadoc annotation with @Override.         @Override is better as it implies documentation inheritance plus checks         that the parent method exists at the compile-time.          R=nick         DELTA=137  (0 added, 70 deleted, 67 changed)  Change on 2010/04/19 by nick          Change how we resolve types.         Instead of leaving shell proxy types around, unbox the proxy types.          R=andrew,john         DELTA=103  (84 added, 5 deleted, 14 changed)  Change on 2010/04/19 by acleung          Enable Flow Sensitive Inlining by default.          R=john         DELTA=1  (0 added, 0 deleted, 1 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=pqvliw   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n     }\n \n     @Override\n-    /** {@inheritDoc} */\n     protected void aliasNode(Node throwNode, Node parent) {\n       Node name = NodeUtil.newName(getAliasName(), throwNode, getAliasName());\n       Node aliasCall = new Node(Token.CALL, name, throwNode.removeFirstChild());\n     }\n \n     @Override\n-    /** {@inheritDoc} */\n     protected int minOccurrencesRequiredToAlias() {\n       return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW;\n     }\n     }\n \n     @Override\n-    /** {@inheritDoc} */\n     protected int minOccurrencesRequiredToAlias() {\n       return MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL;\n     }\n \n     @Override\n-    /** {@inheritDoc} */\n     protected void aliasNode(Node n, Node parent) {\n       Node aliasNode = NodeUtil.newName(getAliasName(), n, getAliasName());\n       parent.replaceChild(n, aliasNode);\n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n     this.outputStringUsage = outputStringUsage;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     logger.info(\"Aliasing common strings\");\n \n     }\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() == Token.STRING &&\n         parent.getType() != Token.GETPROP &&\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n \n   /** A traversal callback that collects externed property names. */\n   private class ProcessExterns extends AbstractPostOrderCallback {\n-    /** {@inheritDoc} */\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP:\n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n         Pattern.compile(\"\\\\b(?:\" + blacklistRegex + \")\").matcher(\"\");\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() == Token.STRING &&\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n                                  typeNode.getNext());\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n   @Override\n   public boolean isOptionalParameter(Node parameter) {\n     return false;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n   @Override\n   public boolean isVarArgsParameter(Node parameter) {\n     return false;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n   @Override\n   public boolean isPrivate(String name) {\n     return false;\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     this.inlineAliases = inlineAliases;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     GlobalNamespace namespace;\n     if (collapsePropertiesOnExternTypes) {\n--- a/src/com/google/javascript/jscomp/ConstCheck.java\n+++ b/src/com/google/javascript/jscomp/ConstCheck.java\n     this.initializedConstants = new HashSet<Scope.Var>();\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n       case Token.NAME:\n--- a/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n+++ b/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n     this.compiler = compiler;\n   }\n \n-  /** {@inheritDoc} */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n-  /** {@inheritDoc} */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n       case Token.GETELEM:\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n     this.graph = graph;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     logger.info(\"Moving functions + variable into deeper modules\");\n \n     }\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() != Token.NAME) {\n       return;\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n     this.mappedPaths = Maps.newHashMap();\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     new NodeTraversal(compiler, this).traverse(root);\n \n     return sb.toString();\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n \n--- a/src/com/google/javascript/jscomp/FunctionNames.java\n+++ b/src/com/google/javascript/jscomp/FunctionNames.java\n     this.functionListExtractor = new FunctionListExtractor(functionMap);\n   }\n \n-  /** {@inheritDoc} */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, functionListExtractor);\n     AnonymousFunctionNamer namer = new AnonymousFunctionNamer(functionMap);\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n       this.nodeFilter = nodeFilter;\n     }\n \n-    /** {@inheritDoc} */\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n         return;\n       return parent == null;\n     }\n \n-    /** {@inheritDoc} */\n     @Override public String toString() {\n       return fullName() + \" (\" + type + \"): globalSets=\" + globalSets +\n           \", localSets=\" + localSets + \", totalGets=\" + totalGets +\n--- a/src/com/google/javascript/jscomp/GoogleCodeRemoval.java\n+++ b/src/com/google/javascript/jscomp/GoogleCodeRemoval.java\n     this.compiler = compiler;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new FindAbstractMethods());\n \n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n     return fs;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     Preconditions.checkState(compiler.isNormalized());\n \n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n     private class NodeAccumulator\n         implements SideEffectAccumulator {\n \n-      /** {@inheritDoc} */\n+      @Override\n       public boolean classDefiningCallsHaveSideEffects() {\n         return false;\n       }\n \n-      /** {@inheritDoc} */\n+      @Override\n       public void keepSubTree(Node original) {\n         addAllChildren(original);\n       }\n \n-      /** {@inheritDoc} */\n+      @Override\n       public void keepSimplifiedShortCircuitExpression(Node original) {\n         Node condition = original.getFirstChild();\n         Node thenBranch = condition.getNext();\n         addSimplifiedChildren(thenBranch);\n       }\n \n-      /** {@inheritDoc} */\n+      @Override\n       public void keepSimplifiedHookExpression(Node hook,\n                                                boolean thenHasSideEffects,\n                                                boolean elseHasSideEffects) {\n     this.changeProxy = new AstChangeProxy();\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, externs, new ProcessExternals());\n     NodeTraversal.traverse(compiler, root, new FindDependencyScopes());\n--- a/src/com/google/javascript/jscomp/NameAnonymousFunctions.java\n+++ b/src/com/google/javascript/jscomp/NameAnonymousFunctions.java\n     this.compiler = compiler;\n   }\n \n-  /** {@inheritDoc} */\n+  @Override\n   public void process(Node externs, Node root) {\n     AnonymousFunctionNamingCallback namingCallback =\n         new AnonymousFunctionNamingCallback(new AnonymousFunctionNamer());\n       return DELIMITER + name + DELIMITER;\n     }\n \n-    /** {@inheritDoc} */\n+    @Override\n     public final String getName(Node node) {\n       return nameExtractor.getName(node);\n     }\n \n-    /** {@inheritDoc} */\n+    @Override\n     public final void setFunctionName(String name, Node fnNode) {\n       Node fnNameNode = fnNode.getFirstChild();\n       String uniqueName = getLikelyNonConflictingName(name);\n--- a/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n+++ b/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n     renameMap = Maps.newHashMap();\n   }\n \n-  /** {@inheritDoc} */\n+  @Override\n   public void process(Node externs, Node root) {\n     AnonymousFunctionNamingCallback namingCallback =\n         new AnonymousFunctionNamingCallback(new MappedFunctionNamer());\n       implements AnonymousFunctionNamingCallback.FunctionNamer {\n     static final char DELIMITER = '.';\n \n-    /** {@inheritDoc} */\n+    @Override\n     public final String getName(Node node) {\n       switch (node.getType()) {\n         case Token.NAME:\n       }\n     }\n \n-    /** {@inheritDoc} */\n+    @Override\n     public final void setFunctionName(String name, Node fnNode) {\n       Node fnNameNode = fnNode.getFirstChild();\n       String newName = renameMap.get(name);\n       bytesUsed += newName.length();\n     }\n \n-    /** {@inheritDoc} */\n+    @Override\n     public final String getCombinedName(String lhs, String rhs) {\n       return lhs + DELIMITER + rhs;\n     }\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n     return exportedVariables;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     new NodeTraversal(compiler, this).traverse(root);\n \n     }\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     switch (n.getType()) {\n       case Token.CALL:\n--- a/src/com/google/javascript/jscomp/RenameLabels.java\n+++ b/src/com/google/javascript/jscomp/RenameLabels.java\n     }\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     // Do variable reference counting.\n     NodeTraversal.traverse(compiler, root, new ProcessLabels());\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n     this.reservedCharacters = reservedCharacters;\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, externs, new ProcessExterns());\n     NodeTraversal.traverse(compiler, root, new ProcessProperties());\n    */\n   private class ProcessExterns extends AbstractPostOrderCallback {\n \n-    /** {@inheritDoc} */\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP:\n    */\n   private class ProcessProperties extends AbstractPostOrderCallback {\n \n-    /** {@inheritDoc} */\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.GETPROP:\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n       }\n     };\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     assignmentLog = new StringBuilder();\n \n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;\n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.Map;\n-\n \n /**\n  * Scope contains information about a variable scope in javascript.\n     }\n \n     /**\n+     * Resolve this variable's type.\n+     */\n+    void resolveType(ErrorReporter errorReporter) {\n+      if (type != null) {\n+        type = type.resolve(errorReporter, scope);\n+      }\n+    }\n+\n+    /**\n      * Returns whether this variable's type is inferred. To get the variable's\n      * type, see {@link #getType()}.\n      */\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n     this.varsToRemove = Sets.newHashSet();\n   }\n \n-  /**\n-   * {@inheritDoc}\n-   */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new Strip());\n   }\n    */\n   private class Strip extends AbstractPostOrderCallback {\n \n-    /**\n-     * {@inheritDoc}\n-     */\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.VAR:\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n   public StaticScope<ConcreteType> createInstanceScope(\n       ObjectType instanceType) {\n     ConcreteScope parentScope = null;\n-    if (instanceType.getImplicitPrototype() != null) {\n-      ConcreteInstanceType prototype =\n-          createConcreteInstance(instanceType.getImplicitPrototype());\n+    ObjectType implicitProto = instanceType.getImplicitPrototype();\n+    if (implicitProto != null && !implicitProto.isUnknownType()) {\n+      ConcreteInstanceType prototype = createConcreteInstance(implicitProto);\n       parentScope = (ConcreteScope) prototype.getScope();\n     }\n     ConcreteScope scope = new ConcreteScope(parentScope);\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT;\n import static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF;\n import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n import com.google.common.annotations.VisibleForTesting;\n-import javax.annotation.Nullable;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CodingConvention.SubclassType;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * Creates the symbol table of variables available in the current scope and\n           \"Constructor expected as first argument\");\n \n   private final AbstractCompiler compiler;\n+  private final ErrorReporter typeParsingErrorReporter;\n   private final TypeValidator validator;\n   private final CodingConvention codingConvention;\n   private final JSTypeRegistry typeRegistry;\n   private Map<ObjectType, ObjectType> delegateProxyMap = Maps.newHashMap();\n+\n+  /**\n+   * Defer attachment of types to nodes until all type names\n+   * have been resolved. Then, we can resolve the type and attach it.\n+   */\n+  private class DeferredSetType {\n+    final Node node;\n+    final JSType type;\n+\n+    DeferredSetType(Node node, JSType type) {\n+      Preconditions.checkNotNull(node);\n+      Preconditions.checkNotNull(type);\n+      this.node = node;\n+      this.type = type;\n+\n+      // Other parts of this pass may read off the node.\n+      // (like when we set the LHS of an assign with a typed RHS function.)\n+      node.setJSType(type);\n+    }\n+\n+    void resolve(Scope scope) {\n+      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n+    }\n+  }\n \n   TypedScopeCreator(AbstractCompiler compiler) {\n     this(compiler, compiler.getCodingConvention());\n     this.validator = compiler.getTypeValidator();\n     this.codingConvention = codingConvention;\n     this.typeRegistry = compiler.getTypeRegistry();\n+    this.typeParsingErrorReporter = typeRegistry.getErrorReporter();\n   }\n \n   /**\n       GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope);\n       NodeTraversal.traverse(compiler, root, scopeBuilder);\n       scopeBuilder.resolveStubDeclarations();\n+      scopeBuilder.resolveTypes();\n \n       // Gather the properties in each function that we found in the\n       // global scope, if that function has a @this type that we can\n           typeRegistry, newScope, delegateProxyMap);\n     } else {\n       newScope = new Scope(parent, root);\n-      (new LocalScopeBuilder(newScope)).build();\n-    }\n-    typeRegistry.resolveTypesInScope(newScope);\n+      LocalScopeBuilder scopeBuilder = new LocalScopeBuilder(newScope);\n+      scopeBuilder.build();\n+      scopeBuilder.resolveTypes();\n+    }\n     return newScope;\n   }\n \n      */\n     final Scope scope;\n \n+    private final List<DeferredSetType> deferredSetTypes =\n+        Lists.newArrayList();\n+\n     /**\n      * The current source file that we're in.\n      */\n \n     private AbstractScopeBuilder(Scope scope) {\n       this.scope = scope;\n+    }\n+\n+    void setDeferredType(Node node, JSType type) {\n+      deferredSetTypes.add(new DeferredSetType(node, type));\n+    }\n+\n+    void resolveTypes() {\n+      // Resolve types and attach them to nodes.\n+      for (DeferredSetType deferred : deferredSetTypes) {\n+        deferred.resolve(scope);\n+      }\n+\n+      // Resolve types and attach them to scope slots.\n+      Iterator<Var> vars = scope.getVars();\n+      while (vars.hasNext()) {\n+        vars.next().resolveType(typeParsingErrorReporter);\n+      }\n+\n+      // Tell the type registry that any remaining types\n+      // are unknown.\n+      typeRegistry.resolveTypesInScope(scope);\n     }\n \n     @Override\n             getFunctionType(lvalue.getQualifiedName(), rvalue, info,\n                 lvalue);\n           } else if (info != null && info.hasEnumParameterType()) {\n-            lvalue.setJSType(\n-                getEnumType(lvalue.getQualifiedName(), n, rvalue,\n-                    info.getEnumParameterType().evaluate(scope, typeRegistry)));\n+            JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue,\n+                info.getEnumParameterType().evaluate(scope, typeRegistry));\n+            if (type != null) {\n+              setDeferredType(lvalue, type);\n+            }\n           }\n           break;\n \n \n       // assigning the function type to the function node\n       if (rValue != null) {\n-        rValue.setJSType(functionType);\n+        setDeferredType(rValue, functionType);\n       }\n \n       // all done\n             sourceName, n, parent, oldVar, variableName, type);\n       } else {\n         if (!inferred) {\n-          n.setJSType(type);\n+          setDeferredType(n, type);\n         }\n         CompilerInput input = compiler.getInput(sourceName);\n         scope.declare(variableName, n, type, input, inferred);\n             ObjectType type = ObjectType.cast(\n                 typeRegistry.getType(objectLiteralCast.typeName));\n             if (type != null && type.getConstructor() != null) {\n-              objectLiteralCast.objectNode.setJSType(type);\n+              setDeferredType(objectLiteralCast.objectNode, type);\n             } else {\n               compiler.report(JSError.make(t.getSourceName(), n,\n                                            CONSTRUCTOR_EXPECTED));\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n     this.sanityCheck = sanityCheck;\n   }\n \n-  /** {@inheritDoc} */\n+  @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());\n     NodeTraversal.traverseRoots(\n         compiler, Lists.newArrayList(externs, root), this);\n   }\n \n-  /** {@inheritDoc} */\n+  @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() != Token.NAME) {\n       return;\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n \n   @Override\n   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+\n     call = (ArrowType) safeResolve(call, t, scope);\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n     typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n     this.tolerateUndefinedValues = tolerateUndefinedValues;\n   }\n \n+  public ErrorReporter getErrorReporter() {\n+    return reporter;\n+  }\n+\n   public boolean shouldTolerateUndefinedValues() {\n     return tolerateUndefinedValues;\n   }\n     return type;\n   }\n \n+  /**\n+   * Resolve all the unresolved types in the given scope.\n+   */\n   public void resolveTypesInScope(StaticScope<JSType> scope) {\n     for (NamedType type : unresolvedNamedTypes.get(scope)) {\n       type.resolve(reporter, scope);\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n \n   @Override\n   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+\n     // Don't try to resolve native types, because it's unnecessary and\n     // there are infinite loops between native types.\n     if (implicitPrototype != null && !implicitPrototype.isNativeObjectType()) {\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n     super(EXTERNS);\n   }\n \n-  /** {@inheritDoc} */\n   @Override public CompilerPass getProcessor(Compiler compiler) {\n     return new CollapseProperties(\n         compiler, collapsePropertiesOnExternTypes, true);\n     super.enableLineNumberCheck(true);\n   }\n \n-  /** {@inheritDoc} */\n   @Override public int getNumRepetitions() {\n     return 1;\n   }\n--- a/test/com/google/javascript/jscomp/IgnoreCajaPropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/IgnoreCajaPropertiesTest.java\n          \"for (i = 0; i < 10; ++i) { f(i); }\");\n   }\n \n-  /** {@inheritDoc} */\n   @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n     return new IgnoreCajaProperties(compiler);\n--- a/test/com/google/javascript/jscomp/RemoveTryCatchTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveTryCatchTest.java\n     super(\"\", false);\n   }\n \n-  /** {@inheritDoc} */\n   @Override public CompilerPass getProcessor(Compiler compiler) {\n     return new RemoveTryCatch(compiler);\n   }\n \n-  /** {@inheritDoc} */\n   @Override public int getNumRepetitions() {\n     // Use only one repetition because test code contains JSDoc comments.\n     return 1;\n--- a/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n     return compiler;\n   }\n \n-  /** {@inheritDoc} */\n   @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n     return renameProperties =\n--- a/test/com/google/javascript/jscomp/RenamePrototypesTest.java\n+++ b/test/com/google/javascript/jscomp/RenamePrototypesTest.java\n     super(EXTERNS);\n   }\n \n-  /** {@inheritDoc} */\n   @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n     return renamePrototypes =\n--- a/test/com/google/javascript/jscomp/SanityCheckTest.java\n+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java\n     return 1;\n   }\n \n-  /** {@inheritDoc} */\n   @Override public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n       @Override public void process(Node externs, Node root) {\n--- a/test/com/google/javascript/jscomp/StripCodeTest.java\n+++ b/test/com/google/javascript/jscomp/StripCodeTest.java\n         stripNamePrefixes);\n   }\n \n-  /** {@inheritDoc} */\n   @Override public CompilerPass getProcessor(Compiler compiler) {\n     return createLoggerInstance(compiler);\n   }\n--- a/test/com/google/javascript/jscomp/TightenTypesTest.java\n+++ b/test/com/google/javascript/jscomp/TightenTypesTest.java\n     testSame(BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES\n              + \"/** @constructor */ function A() {};\\n\"\n              + \"/** @constructor \\n@extends A */ function B() {};\\n\"\n-             + \"/** @return {Object} */ Object.prototype.eval = function(code) {};\\n\"\n+             + \"/** @return {Object} */ \"\n+             + \"Object.prototype.eval = function(code) {};\\n\"\n              + \"/** @type {Object} */\\n\"\n              + \"A.prototype.a;\\n\"\n              + \"/** @return {Object} */\\n\"\n              + \"A.prototype.b = function(){};\\n\",\n              \"var a = (new A).b()\", null, null);\n-    assertType(\"(A,Array,B,Boolean,Date,Error,EvalError,Function,Number,Object,\"\n+    assertType(\"(A,ActiveXObject,Array,B,Boolean,Date,Error,EvalError,\"\n+               + \"Function,Number,Object,\"\n                + \"RangeError,ReferenceError,RegExp,String,SyntaxError,\"\n                + \"TypeError,URIError)\", getType(\"a\"));\n   }", "timestamp": 1271719735, "metainfo": ""}