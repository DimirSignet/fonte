{"sha": "ab9dfefc6f8799aa4e8f69d4e4e52d055152b25a", "log": "Create -output_bundle flag for JSCompiler to generate bundle files  R=nicksantos DELTA=223  (156 added, 7 deleted, 60 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2369   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n import com.google.common.base.Throwables;\n+import com.google.common.io.Files;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n     }\n \n     if (config.skipNormalOutputs) {\n-      // Output the manifest if requested.\n+      // Output the manifest and bundle files if requested.\n       outputManifest();\n+      outputBundle();\n       return 0;\n     } else if (result.success) {\n       if (modules == null) {\n       // Output the variable and property name maps if requested.\n       outputNameMaps(options);\n \n-      // Output the manifest if requested.\n+      // Output the manifest and bundle files if requested.\n       outputManifest();\n+      outputBundle();\n     }\n \n     // return 0 if no errors, the error count otherwise\n       return null;\n     }\n     return expandCommandLinePath(options.sourceMapOutputPath, forModule);\n-  }\n-\n-  /** Expansion function for the manifest. */\n-  private String expandManifest(JSModule forModule, String manifestName) {\n-    return expandCommandLinePath(manifestName, forModule);\n   }\n \n   /**\n   }\n \n   /**\n-   * Returns true if and only if a manifest should be generated for each\n-   * module, as opposed to one unified manifest.\n-   */\n-  private boolean shouldGenerateManifestPerModule(String outputManifest) {\n+   * Returns true if and only if a manifest or bundle should be generated\n+   * for each module, as opposed to one unified manifest.\n+   */\n+  private boolean shouldGenerateOutputPerModule(String output) {\n     return !config.module.isEmpty()\n-        && outputManifest != null\n-        && outputManifest.contains(\"%outname%\");\n-  }\n-\n-  /**\n-   * Writes the manifest of all compiler input files that survived\n+        && output != null && output.contains(\"%outname%\");\n+  }\n+\n+  /**\n+   * Writes the manifest or bundle of all compiler input files that survived\n    * manage_closure_dependencies, if requested.\n    */\n   private void outputManifest() throws IOException {\n-    List<String> outputManifests = config.outputManifests;\n-    if (outputManifests.isEmpty()) {\n+    outputManifestOrBundle(config.outputManifests, true);\n+  }\n+\n+  private void outputBundle() throws IOException {\n+    outputManifestOrBundle(config.outputBundles, false);\n+  }\n+\n+  private void outputManifestOrBundle(List<String> outputFiles,\n+      boolean isManifest) throws IOException {\n+    if (outputFiles.isEmpty()) {\n       return;\n     }\n \n-    for (String outputManifest : outputManifests) {\n-      if (outputManifest.isEmpty()) {\n+    for (String output : outputFiles) {\n+      if (output.isEmpty()) {\n         continue;\n       }\n \n       JSModuleGraph graph = compiler.getModuleGraph();\n-      if (shouldGenerateManifestPerModule(outputManifest)) {\n-        // Generate per-module manifests.\n+      if (shouldGenerateOutputPerModule(output)) {\n+        // Generate per-module manifests or bundles\n         Iterable<JSModule> modules = graph.getAllModules();\n         for (JSModule module : modules) {\n           Writer out = fileNameToOutputWriter(\n-              expandManifest(module, outputManifest));\n-          printManifestTo(module.getInputs(), out);\n+              expandCommandLinePath(output, module));\n+          if (isManifest) {\n+            printManifestTo(module.getInputs(), out);\n+          } else {\n+            printBundleTo(module.getInputs(), out);\n+          }\n           out.close();\n         }\n       } else {\n-        // Generate a single file manifest.\n+        // Generate a single file manifest or bundle.\n         Writer out = fileNameToOutputWriter(\n-            expandManifest(null, outputManifest));\n+            expandCommandLinePath(output, null));\n         if (graph == null) {\n-          printManifestTo(compiler.getInputsInOrder(), out);\n+          if (isManifest) {\n+            printManifestTo(compiler.getInputsInOrder(), out);\n+          } else {\n+            printBundleTo(compiler.getInputsInOrder(), out);\n+          }\n         } else {\n-          printModuleGraphManifestTo(graph, out);\n+          printModuleGraphManifestOrBundleTo(graph, out, isManifest);\n         }\n         out.close();\n       }\n   }\n \n   /**\n-   * Prints a set of modules to the manifest file.\n+   * Prints a set of modules to the manifest or bundle file.\n    */\n   @VisibleForTesting\n-  void printModuleGraphManifestTo(\n-      JSModuleGraph graph, Appendable out) throws IOException {\n+  void printModuleGraphManifestOrBundleTo(JSModuleGraph graph,\n+      Appendable out, boolean isManifest) throws IOException {\n     Joiner commas = Joiner.on(\",\");\n     boolean requiresNewline = false;\n     for (JSModule module : graph.getAllModulesInDependencyOrder()) {\n         out.append(\"\\n\");\n       }\n \n-      // See CommandLineRunnerTest to see what the format of this\n-      // manifest looks like.\n-      String dependencies = commas.join(module.getSortedDependencyNames());\n-      out.append(\n-          String.format(\"{%s%s}\\n\",\n-              module.getName(),\n-              dependencies.isEmpty() ? \"\" : \":\" + dependencies));\n-      printManifestTo(module.getInputs(), out);\n+      if (isManifest) {\n+        // See CommandLineRunnerTest to see what the format of this\n+        // manifest looks like.\n+        String dependencies = commas.join(module.getSortedDependencyNames());\n+        out.append(\n+            String.format(\"{%s%s}\\n\",\n+                module.getName(),\n+                dependencies.isEmpty() ? \"\" : \":\" + dependencies));\n+        printManifestTo(module.getInputs(), out);\n+      } else {\n+        printBundleTo(module.getInputs(), out);\n+      }\n       requiresNewline = true;\n     }\n   }\n     String result = Joiner.on(\"\\n\").join(names);\n     out.append(result);\n     out.append(\"\\n\");\n+  }\n+\n+  /**\n+   * Prints all the input contents, starting with a comment that specifies\n+   * the input file name before each file\n+   */\n+  private void printBundleTo(Iterable<CompilerInput> inputs, Appendable out)\n+      throws IOException {\n+    for (CompilerInput input : inputs) {\n+      out.append(\"//\" + input.getName() + \"\\n\");\n+      File file = new File(input.getName());\n+      for (String line : Files.readLines(file, Charsets.UTF_8)) {\n+        out.append(line + \"\\n\");\n+      }\n+    }\n   }\n \n   private class RunTimeStats {\n     private List<String> outputManifests = ImmutableList.of();\n \n     /**\n-     * Sets whether to print an output manifest file.\n+     * Sets whether to print output manifest files.\n      */\n     CommandLineConfig setOutputManifest(List<String> outputManifests) {\n       this.outputManifests = outputManifests;\n+      return this;\n+    }\n+\n+    private List<String> outputBundles = ImmutableList.of();\n+\n+    /**\n+     * Sets whether to print output bundle files.\n+     */\n+    CommandLineConfig setOutputBundle(List<String> outputBundles) {\n+      this.outputBundles = outputBundles;\n       return this;\n     }\n \n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n           \"var x = 3;\", \"var y = 5;\", \"var z = 7;\", \"var a = 9;\"});\n \n     StringBuilder builder = new StringBuilder();\n-    lastCommandLineRunner.printModuleGraphManifestTo(\n-        lastCompiler.getModuleGraph(), builder);\n+    lastCommandLineRunner.printModuleGraphManifestOrBundleTo(\n+        lastCompiler.getModuleGraph(), builder, true);\n     assertEquals(\n         \"{m0}\\n\" +\n         \"i0\\n\" +\n           \"var x = 3;\", \"var y = 5;\", \"var z = 7;\", \"var a = 9;\"});\n \n     StringBuilder builder = new StringBuilder();\n-    lastCommandLineRunner.printModuleGraphManifestTo(\n-        lastCompiler.getModuleGraph(), builder);\n+    lastCommandLineRunner.printModuleGraphManifestOrBundleTo(\n+        lastCompiler.getModuleGraph(), builder, true);\n     assertEquals(\n         \"{m0}\\n\" +\n         \"i0\\n\" +", "timestamp": 1308694178, "metainfo": ""}