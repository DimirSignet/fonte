{"sha": "77b7c78d4aeeb6471f2f668a06c0f61a68f95ccd", "log": "Add more unit tests for type checking.  Add phase optimization.  Fix a type inference bug.  String.prototype.split may not return null.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Tracer;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n \n import java.util.List;\n import java.util.Random;\n+import java.util.Set;\n import java.util.logging.Logger;\n \n /**\n *\n  */\n class PhaseOptimizer implements CompilerPass {\n+\n+  // This ordering is computed offline by running with compute_phase_ordering.\n+  @VisibleForTesting\n+  static final List<String> OPTIMAL_ORDER = ImmutableList.of(\n+     \"removeUnreachableCode\",\n+     \"removeUnusedVars\",\n+     \"foldConstants\",\n+     \"deadAssignmentsElimination\",\n+     \"inlineVariables\",\n+     \"inlineFunctions\",\n+     \"removeUnusedPrototypeProperties\",\n+     \"minimizeExitPoints\");\n \n   static final int MAX_LOOPS = 100;\n   static final String OPTIMIZE_LOOP_ERROR =\n    */\n   private class LoopInternal extends Loop {\n     private final List<NamedPass> myPasses = Lists.newArrayList();\n+    private final Set<String> myNames = Sets.newHashSet();\n \n     @Override\n     void addLoopedPass(PassFactory factory) {\n+      String name = factory.getName();\n+      Preconditions.checkArgument(\n+          !myNames.contains(name),\n+          \"Already a pass with name '\" + name + \"' in this loop\");\n+      myNames.add(factory.getName());\n       myPasses.add(new PassFactoryDelegate(compiler, factory));\n     }\n \n       Preconditions.checkState(!loopMutex, \"Nested loops are forbidden\");\n       loopMutex = true;\n       if (randomizeLoops) {\n-        List<NamedPass> mixedupPasses = Lists.newArrayList();\n-        Random random = new Random();\n-        while (myPasses.size() > 0) {\n-          mixedupPasses.add(\n-              myPasses.remove(random.nextInt(myPasses.size())));\n-        }\n-        myPasses.addAll(mixedupPasses);\n+        randomizePasses();\n+      } else {\n+        optimizePasses();\n       }\n \n       try {\n         loopMutex = false;\n       }\n     }\n+\n+    /** Re-arrange the passes in a random order. */\n+    private void randomizePasses() {\n+      List<NamedPass> mixedupPasses = Lists.newArrayList();\n+      Random random = new Random();\n+      while (myPasses.size() > 0) {\n+        mixedupPasses.add(\n+            myPasses.remove(random.nextInt(myPasses.size())));\n+      }\n+      myPasses.addAll(mixedupPasses);\n+    }\n+\n+    /** Re-arrange the passes in an optimal order. */\n+    private void optimizePasses() {\n+      // It's important that this ordering is deterministic, so that\n+      // multiple compiles with the same input produce exactly the same\n+      // results.\n+      //\n+      // To do this, grab any passes we recognize, and move them to the end\n+      // in an \"optimal\" order.\n+      List<NamedPass> optimalPasses = Lists.newArrayList();\n+      for (String passName : OPTIMAL_ORDER) {\n+        for (NamedPass pass : myPasses) {\n+          if (pass.name.equals(passName)) {\n+            optimalPasses.add(pass);\n+            break;\n+          }\n+        }\n+      }\n+\n+      myPasses.removeAll(optimalPasses);\n+      myPasses.addAll(optimalPasses);\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       if (var != null &&\n           !var.isTypeInferred() &&\n           !objectType.hasOwnProperty(propName) &&\n-          (!objectType.isInstanceType() || var.isExtern())) {\n+          (!objectType.isInstanceType() ||\n+           (var.isExtern() && !objectType.isNativeObjectType()))) {\n         objectType.defineDeclaredProperty(\n             propName, var.getType(), var.isExtern());\n         return true;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           boolean isExtern = t.getInput().isExtern();\n           if ((!ownerType.hasOwnProperty(propName) ||\n                ownerType.isPropertyTypeInferred(propName)) &&\n-              (isExtern || !ownerType.isInstanceType())) {\n+              ((isExtern && !ownerType.isNativeObjectType()) ||\n+               !ownerType.isInstanceType())) {\n             // If the property is undeclared or inferred, declare it now.\n             ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n           }\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n import com.google.javascript.rhino.Token;\n \n import junit.framework.TestCase;\n+\n import java.util.List;\n+import java.util.Random;\n \n /**\n  * Tests for {@link PhaseOptimizer}.\n             createPassFactory(\"b\", 0, false),\n             createPassFactory(\"c\", 0, false)));\n     assertPasses(\"a\", \"b\", \"c\");\n+  }\n+\n+  public void testDuplicateLoop() {\n+    Loop loop = optimizer.addFixedPointLoop();\n+    addLoopedPass(loop, \"x\", 1);\n+    try {\n+      addLoopedPass(loop, \"x\", 1);\n+      fail(\"Expected exception\");\n+    } catch (IllegalArgumentException e) {}\n+  }\n+\n+  public void testPassOrdering() {\n+    Loop loop = optimizer.addFixedPointLoop();\n+    List<String> optimalOrder = Lists.newArrayList(\n+        PhaseOptimizer.OPTIMAL_ORDER);\n+    Random random = new Random();\n+    while (optimalOrder.size() > 0) {\n+      addLoopedPass(\n+          loop, optimalOrder.remove(random.nextInt(optimalOrder.size())), 0);\n+    }\n+    optimizer.process(null, null);\n+    assertEquals(PhaseOptimizer.OPTIMAL_ORDER, passesRun);\n   }\n \n   public void assertPasses(String ... names) {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n+/*\n+ * Copyright 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Join;\n+import com.google.common.base.Pair;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+\n+import java.util.Arrays;\n+\n+\n+/**\n+ * Tests {@link TypeCheck}.\n+ *\n+*\n+*\n+ */\n+public class TypeCheckTest extends CompilerTypeTestCase {\n+  public void testInitialTypingScope() {\n+    Scope s = new TypedScopeCreator(compiler,\n+        new DefaultCodingConvention()).createInitialScope(null);\n+\n+    assertEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());\n+    assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n+        s.getVar(\"Boolean\").getType());\n+    assertEquals(DATE_FUNCTION_TYPE, s.getVar(\"Date\").getType());\n+    assertEquals(ERROR_FUNCTION_TYPE, s.getVar(\"Error\").getType());\n+    assertEquals(EVAL_ERROR_FUNCTION_TYPE,\n+        s.getVar(\"EvalError\").getType());\n+    assertEquals(NUMBER_OBJECT_FUNCTION_TYPE,\n+        s.getVar(\"Number\").getType());\n+    assertEquals(OBJECT_FUNCTION_TYPE, s.getVar(\"Object\").getType());\n+    assertEquals(RANGE_ERROR_FUNCTION_TYPE,\n+        s.getVar(\"RangeError\").getType());\n+    assertEquals(REFERENCE_ERROR_FUNCTION_TYPE,\n+        s.getVar(\"ReferenceError\").getType());\n+    assertEquals(REGEXP_FUNCTION_TYPE, s.getVar(\"RegExp\").getType());\n+    assertEquals(STRING_OBJECT_FUNCTION_TYPE,\n+        s.getVar(\"String\").getType());\n+    assertEquals(SYNTAX_ERROR_FUNCTION_TYPE,\n+        s.getVar(\"SyntaxError\").getType());\n+    assertEquals(TYPE_ERROR_FUNCTION_TYPE,\n+        s.getVar(\"TypeError\").getType());\n+    assertEquals(URI_ERROR_FUNCTION_TYPE,\n+        s.getVar(\"URIError\").getType());\n+  }\n+\n+  public void testTypeCheck1() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){ if (foo()) return; }\");\n+  }\n+\n+  public void testTypeCheck2() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){ foo()--; }\",\n+        \"increment/decrement\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testTypeCheck4() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){ !foo(); }\");\n+  }\n+\n+  public void testTypeCheck5() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){ var a = +foo(); }\",\n+        \"sign operator\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testTypeCheck6() throws Exception {\n+    testTypes(\n+        \"/**@return {void}*/function foo(){\" +\n+        \"/** @type {undefined|number} */var a;if (a == foo())return;}\");\n+  }\n+\n+  public void testTypeCheck7() throws Exception {\n+    testTypes(\"function foo() {delete 'abc';}\",\n+        TypeCheck.BAD_DELETE);\n+  }\n+\n+  public void testTypeCheck8() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){do {} while (foo());}\");\n+  }\n+\n+  public void testTypeCheck9() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){while (foo());}\");\n+  }\n+\n+  public void testTypeCheck10() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){for (;foo(););}\");\n+  }\n+\n+  public void testTypeCheck11() throws Exception {\n+    testTypes(\"/**@type !Number */var a;\" +\n+        \"/**@type !String */var b;\" +\n+        \"a = b;\",\n+        \"assignment\\n\" +\n+        \"found   : String\\n\" +\n+        \"required: Number\");\n+  }\n+\n+  public void testTypeCheck12() throws Exception {\n+    testTypes(\"/**@return {!Object}*/function foo(){var a = 3^foo();}\",\n+        \"bad right operand to bitwise operator\\n\" +\n+        \"found   : Object\\n\" +\n+        \"required: (boolean|null|number|string|undefined)\");\n+  }\n+\n+  public void testTypeCheck13() throws Exception {\n+    testTypes(\"/**@type {!Number|!String}*/var i; i=/xx/;\",\n+        \"assignment\\n\" +\n+        \"found   : RegExp\\n\" +\n+        \"required: (Number|String)\");\n+  }\n+\n+  public void testTypeCheck14() throws Exception {\n+    testTypes(\"/**@param opt_a*/function foo(opt_a){}\");\n+  }\n+\n+\n+  public void testTypeCheck15() throws Exception {\n+    testTypes(\"/**@type {Number|null} */var x;x=null;x=10;\",\n+        \"assignment\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: (Number|null)\");\n+  }\n+\n+  public void testTypeCheck16() throws Exception {\n+    testTypes(\"/**@type {Number|null} */var x='';\",\n+              \"initializing variable\\n\" +\n+              \"found   : string\\n\" +\n+              \"required: (Number|null)\");\n+  }\n+\n+\n+  public void testTypeCheck17() throws Exception {\n+    testTypes(\"/**@return {Number}\\n@param {Number} opt_foo */\\n\" +\n+        \"function a(opt_foo){\\nreturn /**@type {Number}*/(opt_foo);\\n}\");\n+  }\n+\n+\n+  public void testTypeCheck18() throws Exception {\n+    testTypes(\"/**@return {RegExp}\\n*/\\n function a(){return new RegExp();}\");\n+  }\n+\n+  public void testTypeCheck19() throws Exception {\n+    testTypes(\"/**@return {Array}\\n*/\\n function a(){return new Array();}\");\n+  }\n+\n+  public void testTypeCheck20() throws Exception {\n+    testTypes(\"/**@return {Date}\\n*/\\n function a(){return new Date();}\");\n+  }\n+\n+  public void testTypeCheckBasicDowncast() throws Exception {\n+    testTypes(\"/** @constructor */function foo() {}\\n\" +\n+                  \"/** @type {Object} */ var bar = new foo();\\n\");\n+  }\n+\n+  public void testTypeCheckNoDowncastToNumber() throws Exception {\n+    testTypes(\"/** @constructor */function foo() {}\\n\" +\n+                  \"/** @type {!Number} */ var bar = new foo();\\n\",\n+        \"initializing variable\\n\" +\n+        \"found   : foo\\n\" +\n+        \"required: Number\");\n+  }\n+\n+  public void testTypeCheck21() throws Exception {\n+    testTypes(\"/** @type Array.<String> */var foo;\");\n+  }\n+\n+  public void testTypeCheck22() throws Exception {\n+    testTypes(\"/** @param {Element|Object} p */\\nfunction foo(p){}\\n\" +\n+                  \"/** @constructor */function Element(){}\\n\" +\n+                  \"/** @type {Element|Object} */var v;\\n\" +\n+                  \"foo(v);\\n\");\n+  }\n+\n+  public void testTypeCheck23() throws Exception {\n+    testTypes(\"/** @type {(Object,Null)} */var foo; foo = null;\");\n+  }\n+\n+  public void testTypeCheck24() throws Exception {\n+    testTypes(\"/** @constructor */function MyType(){}\\n\" +\n+        \"/** @type {(MyType,Null)} */var foo; foo = null;\");\n+  }\n+\n+  public void testTypeCheckDefaultExterns() throws Exception {\n+    testTypes(\"/** @param {string} x */ function f(x) {}\" +\n+        \"f([].length);\" ,\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testTypeCheckCustomExterns() throws Exception {\n+    testTypes(\n+        DEFAULT_EXTERNS + \"/** @type {boolean} */ Array.prototype.oogabooga;\",\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"f([].oogabooga);\" ,\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: string\", false);\n+  }\n+\n+  public void testParameterizedArray1() throws Exception {\n+    testTypes(\"/** @param {!Array.<number>} a\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/ var f = function(a) { return a[0]; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testParameterizedArray2() throws Exception {\n+    testTypes(\"/** @param {!Array.<!Array.<number>>} a\\n\" +\n+        \"* @return {number}\\n\" +\n+        \"*/ var f = function(a) { return a[0]; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : Array\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testParameterizedArray3() throws Exception {\n+    testTypes(\"/** @param {!Array.<number>} a\\n\" +\n+        \"* @return {number}\\n\" +\n+        \"*/ var f = function(a) { a[1] = 0; return a[0]; };\");\n+  }\n+\n+  public void testParameterizedArray4() throws Exception {\n+    testTypes(\"/** @param {!Array.<number>} a\\n\" +\n+        \"*/ var f = function(a) { a[0] = 'a'; };\",\n+        \"assignment\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testParameterizedArray5() throws Exception {\n+    testTypes(\"/** @param {!Array.<*>} a\\n\" +\n+        \"*/ var f = function(a) { a[0] = 'a'; };\");\n+  }\n+\n+  public void testParameterizedArray6() throws Exception {\n+    testTypes(\"/** @param {!Array.<*>} a\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/ var f = function(a) { return a[0]; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : *\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testParameterizedArray7() throws Exception {\n+    testTypes(\"/** @param {?Array.<number>} a\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/ var f = function(a) { return a[0]; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testParameterizedObject1() throws Exception {\n+    testTypes(\"/** @param {!Object.<number>} a\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/ var f = function(a) { return a[0]; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testParameterizedObject2() throws Exception {\n+    testTypes(\"/** @param {!Object.<string,number>} a\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/ var f = function(a) { return a['x']; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testParameterizedObject3() throws Exception {\n+    testTypes(\"/** @param {!Object.<number,string>} a\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/ var f = function(a) { return a['x']; };\",\n+        \"restricted index type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testParameterizedObject4() throws Exception {\n+    testTypes(\"/** @enum {string} */ var E = {A: 'a', B: 'b'};\\n\" +\n+        \"/** @param {!Object.<E,string>} a\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/ var f = function(a) { return a['x']; };\",\n+        \"restricted index type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: E.<string>\");\n+  }\n+\n+  public void testUnionOfFunctionAndType() throws Exception {\n+    testTypes(\"/** @type {null|(function(Number):void)} */ var a;\" +\n+        \"/** @type {(function(Number):void)|null} */ var b = null; a = b;\");\n+  }\n+\n+  public void testOptionalParameterComparedToUndefined() throws Exception {\n+    testTypes(\"/**@param opt_a {Number}*/function foo(opt_a)\" +\n+        \"{if (opt_a==undefined) var b = 3;}\");\n+  }\n+\n+  public void testOptionalAllType() throws Exception {\n+    testTypes(\"/** @param {*} opt_x */function f(opt_x) { return opt_x }\\n\" +\n+        \"/** @type {*} */var y;\\n\" +\n+        \"f(y);\");\n+  }\n+\n+  public void testOptionalUnknownNamedType() throws Exception {\n+    testTypes(\"/** @param {!T} opt_x\\n@return {undefined} */\\n\" +\n+        \"function f(opt_x) { return opt_x; }\\n\" +\n+        \"/** @constructor */var T = function() {};\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (T|undefined)\\n\" +\n+        \"required: undefined\");\n+  }\n+\n+  public void testOptionalArgFunctionParam() throws Exception {\n+    testTypes(\"/** @param {function(number=)} a */\" +\n+        \"function f(a) {a()};\");\n+  }\n+\n+  public void testOptionalArgFunctionParam2() throws Exception {\n+    testTypes(\"/** @param {function(number=)} a */\" +\n+        \"function f(a) {a(3)};\");\n+  }\n+\n+  public void testOptionalArgFunctionParam3() throws Exception {\n+    testTypes(\"/** @param {function(number=)} a */\" +\n+        \"function f(a) {a(undefined)};\");\n+  }\n+\n+  public void testOptionalArgFunctionParam4() throws Exception {\n+    String expectedWarning = \"Function a: called with 2 argument(s). \" +\n+        \"Function requires at least 0 argument(s) and no more than 1 \" +\n+        \"argument(s).\";\n+\n+    testTypes(\"/** @param {function(number=)} a */function f(a) {a(3,4)};\",\n+              expectedWarning, false);\n+  }\n+\n+  public void testOptionalArgFunctionParamError() throws Exception {\n+    String expectedWarning = \"Parse error. variable length argument must be \" +\n+        \"last\";\n+    testTypes(\"/** @param {function(...[number], number=)} a */\" +\n+              \"function f(a) {};\", expectedWarning, false);\n+  }\n+\n+  public void testOptionalNullableArgFunctionParam() throws Exception {\n+    testTypes(\"/** @param {function(?number=)} a */\" +\n+              \"function f(a) {a()};\");\n+  }\n+\n+  public void testOptionalNullableArgFunctionParam2() throws Exception {\n+    testTypes(\"/** @param {function(?number=)} a */\" +\n+              \"function f(a) {a(null)};\");\n+  }\n+\n+  public void testOptionalNullableArgFunctionParam3() throws Exception {\n+    testTypes(\"/** @param {function(?number=)} a */\" +\n+              \"function f(a) {a(3)};\");\n+  }\n+\n+  public void testOptionalArgFunctionReturn() throws Exception {\n+    testTypes(\"/** @return {function(number=)} */\" +\n+              \"function f() { return function(opt_x) { }; };\" +\n+              \"f()()\");\n+  }\n+\n+  public void testOptionalArgFunctionReturn2() throws Exception {\n+    testTypes(\"/** @return {function(Object=)} */\" +\n+              \"function f() { return function(opt_x) { }; };\" +\n+              \"f()({})\");\n+  }\n+\n+  public void testBooleanType() throws Exception {\n+    testTypes(\"/**@type {boolean} */var x = 1 < 2;\");\n+  }\n+\n+  public void testBooleanReduction1() throws Exception {\n+    testTypes(\"/**@type {string} */var x; x = null || \\\"a\\\";\");\n+  }\n+\n+  public void testBooleanReduction2() throws Exception {\n+    // It's important for the type system to recognize that in no case\n+    // can the boolean expression evaluate to a boolean value.\n+    testTypes(\"/** @param {string} s\\n @return {string} */\" +\n+        \"(function(s) { return ((s == 'a') && s) || 'b'; })\");\n+  }\n+\n+  public void testBooleanReduction3() throws Exception {\n+    testTypes(\"/** @param {string} s\\n @return {string?} */\" +\n+        \"(function(s) { return s && null && 3; })\");\n+  }\n+\n+  public void testBooleanReduction4() throws Exception {\n+    testTypes(\"/** @param {Object} x\\n @return {Object} */\" +\n+        \"(function(x) { return null || x || null ; })\");\n+  }\n+\n+  public void testBooleanReduction5() throws Exception {\n+    testTypes(\"/**\\n\" +\n+        \"* @param {Array|string} x\\n\" +\n+        \"* @return {string?}\\n\" +\n+        \"*/\\n\" +\n+        \"var f = function(x) {\\n\" +\n+        \"if (!x || typeof x == 'string') {\\n\" +\n+        \"return x;\\n\" +\n+        \"}\\n\" +\n+        \"return null;\\n\" +\n+        \"};\");\n+  }\n+\n+  public void testBooleanReduction6() throws Exception {\n+    testTypes(\"/**\\n\" +\n+        \"* @param {Array|string|null} x\\n\" +\n+        \"* @return {string?}\\n\" +\n+        \"*/\\n\" +\n+        \"var f = function(x) {\\n\" +\n+        \"if (!(x && typeof x != 'string')) {\\n\" +\n+        \"return x;\\n\" +\n+        \"}\\n\" +\n+        \"return null;\\n\" +\n+        \"};\");\n+  }\n+\n+   public void testBooleanReduction7() throws Exception {\n+    testTypes(\"/** @constructor */var T = function() {};\\n\" +\n+        \"/**\\n\" +\n+        \"* @param {Array|T} x\\n\" +\n+        \"* @return {null}\\n\" +\n+        \"*/\\n\" +\n+        \"var f = function(x) {\\n\" +\n+        \"if (!x) {\\n\" +\n+        \"return x;\\n\" +\n+        \"}\\n\" +\n+        \"return null;\\n\" +\n+        \"};\");\n+  }\n+\n+  public void testNullAnd() throws Exception {\n+    testTypes(\"/** @type null */var x;\\n\" +\n+        \"/** @type number */var r = x && x;\",\n+        \"initializing variable\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testNullOr() throws Exception {\n+    testTypes(\"/** @type null */var x;\\n\" +\n+        \"/** @type number */var r = x || x;\",\n+        \"initializing variable\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBooleanPreservation1() throws Exception {\n+    testTypes(\"/**@type {string} */var x = \\\"a\\\";\" +\n+        \"x = ((x == \\\"a\\\") && x) || x == \\\"b\\\";\",\n+        \"assignment\\n\" +\n+        \"found   : (boolean|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBooleanPreservation2() throws Exception {\n+    testTypes(\"/**@type {string} */var x = \\\"a\\\"; x = (x == \\\"a\\\") || x;\",\n+        \"assignment\\n\" +\n+        \"found   : (boolean|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBooleanPreservation3() throws Exception {\n+    testTypes(\"/** @param {Function?} x\\n @return {boolean?} */\" +\n+        \"function f(x) { return x && x == \\\"a\\\"; }\");\n+  }\n+\n+  public void testBooleanPreservation4() throws Exception {\n+    testTypes(\"/** @param {Function?} x\\n @return {boolean} */\" +\n+        \"function f(x) { return x && x == \\\"a\\\"; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (boolean|null)\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testTypeOfReduction1() throws Exception {\n+    testTypes(\"/** @param {string|number} x\\n @return {string} */ \" +\n+        \"function f(x) { return typeof x == 'number' ? String(x) : x; }\");\n+  }\n+\n+  public void testTypeOfReduction2() throws Exception {\n+    testTypes(\"/** @param {string|number} x\\n @return {string} */ \" +\n+        \"function f(x) { return typeof x != 'string' ? String(x) : x; }\");\n+  }\n+\n+  public void testTypeOfReduction3() throws Exception {\n+    testTypes(\"/** @param {number|null} x\\n @return {number} */ \" +\n+        \"function f(x) { return typeof x == 'object' ? 1 : x; }\");\n+  }\n+\n+  public void testTypeOfReduction4() throws Exception {\n+    testTypes(\"/** @param {Object|undefined} x\\n @return {Object} */ \" +\n+        \"function f(x) { return typeof x == 'undefined' ? {} : x; }\");\n+  }\n+\n+  public void testTypeOfReduction5() throws Exception {\n+    testTypes(\"/** @enum {string} */ var E = {A: 'a', B: 'b'};\\n\" +\n+        \"/** @param {!E|number} x\\n @return {string} */ \" +\n+        \"function f(x) { return typeof x != 'number' ? x : 'a'; }\");\n+  }\n+\n+  public void testTypeOfReduction6() throws Exception {\n+    testTypes(\"/** @param {number|string} x\\n@return {string} */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"return typeof x == 'string' && x.length == 3 ? x : 'a';\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testTypeOfReduction7() throws Exception {\n+    testTypes(\"/** @return {string} */var f = function(x) { \" +\n+        \"return typeof x == 'number' ? x : 'a'; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testTypeOfReduction8() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @param {number|string} x\\n@return {string} */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"return goog.isString(x) && x.length == 3 ? x : 'a';\\n\" +\n+        \"}\", null);\n+  }\n+\n+  public void testTypeOfReduction9() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @param {!Array|string} x\\n@return {string} */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"return goog.isArray(x) ? 'a' : x;\\n\" +\n+        \"}\", null);\n+  }\n+\n+  public void testTypeOfReduction10() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @param {Array|string} x\\n@return {Array} */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"return goog.isArray(x) ? x : [];\\n\" +\n+        \"}\", null);\n+  }\n+\n+  public void testTypeOfReduction11() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @param {Array|string} x\\n@return {Array} */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"return goog.isObject(x) ? x : [];\\n\" +\n+        \"}\", null);\n+  }\n+\n+  public void testTypeOfReduction12() throws Exception {\n+    testTypes(\"/** @enum {string} */ var E = {A: 'a', B: 'b'};\\n\" +\n+        \"/** @param {E|Array} x\\n @return {Array} */ \" +\n+        \"function f(x) { return typeof x == 'object' ? x : []; }\");\n+  }\n+\n+  public void testTypeOfReduction13() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @enum {string} */ var E = {A: 'a', B: 'b'};\\n\" +\n+        \"/** @param {E|Array} x\\n@return {Array} */ \" +\n+        \"function f(x) { return goog.isObject(x) ? x : []; }\", null);\n+  }\n+\n+  public void testQualifiedNameReduction1() throws Exception {\n+    testTypes(\"var x = {}; /** @type {string?} */ x.a = 'a';\\n\" +\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"return x.a ? x.a : 'a'; }\");\n+  }\n+\n+  public void testQualifiedNameReduction2() throws Exception {\n+    testTypes(\"/** @param {string?} a\\n@constructor */ var T = \" +\n+        \"function(a) {this.a = a};\\n\" +\n+        \"/** @return {string} */ T.prototype.f = function() {\\n\" +\n+        \"return this.a ? this.a : 'a'; }\");\n+  }\n+\n+  public void testQualifiedNameReduction3() throws Exception {\n+    testTypes(\"/** @param {string|Array} a\\n@constructor */ var T = \" +\n+        \"function(a) {this.a = a};\\n\" +\n+        \"/** @return {string} */ T.prototype.f = function() {\\n\" +\n+        \"return typeof this.a == 'string' ? this.a : 'a'; }\");\n+  }\n+\n+  public void testQualifiedNameReduction4() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @param {string|Array} a\\n@constructor */ var T = \" +\n+        \"function(a) {this.a = a};\\n\" +\n+        \"/** @return {string} */ T.prototype.f = function() {\\n\" +\n+        \"return goog.isString(this.a) ? this.a : 'a'; }\", null);\n+  }\n+\n+  public void testInstanceOfReduction1() throws Exception {\n+    testTypes(\"/** @constructor */ var T = function() {};\\n\" +\n+        \"/** @param {T|string} x\\n@return {T} */\\n\" +\n+        \"var f = function(x) {\\n\" +\n+        \"if (x instanceof T) { return x; } else { return new T(); }\\n\" +\n+        \"};\");\n+  }\n+\n+  public void testInstanceOfReduction2() throws Exception {\n+    testTypes(\"/** @constructor */ var T = function() {};\\n\" +\n+        \"/** @param {!T|string} x\\n@return {string} */\\n\" +\n+        \"var f = function(x) {\\n\" +\n+        \"if (x instanceof T) { return ''; } else { return x; }\\n\" +\n+        \"};\");\n+  }\n+\n+  public void testPropertyInferredPropagation() throws Exception {\n+    testTypes(\"/** @return {Object} */function f() { return {}; }\\n\" +\n+         \"function g() { var x = f(); if (x.p) x.a = 'a'; else x.a = 'b'; }\\n\" +\n+         \"function h() { var x = f(); x.a = false; }\");\n+  }\n+\n+  public void testPropertyInference1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { this.x_ = true; }\" +\n+        \"/** @return {string} */\" +\n+        \"F.prototype.bar = function() { if (this.x_) return this.x_; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testPropertyInference2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { this.x_ = true; }\" +\n+        \"F.prototype.baz = function() { this.x_ = null; };\" +\n+        \"/** @return {string} */\" +\n+        \"F.prototype.bar = function() { if (this.x_) return this.x_; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testPropertyInference3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { this.x_ = true; }\" +\n+        \"F.prototype.baz = function() { this.x_ = 3; };\" +\n+        \"/** @return {string} */\" +\n+        \"F.prototype.bar = function() { if (this.x_) return this.x_; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (boolean|number)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testPropertyInference4() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { }\" +\n+        \"F.prototype.x_ = 3;\" +\n+        \"/** @return {string} */\" +\n+        \"F.prototype.bar = function() { if (this.x_) return this.x_; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testPropertyInference5() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { }\" +\n+        \"F.prototype.baz = function() { this.x_ = 3; };\" +\n+        \"/** @return {string} */\" +\n+        \"F.prototype.bar = function() { if (this.x_) return this.x_; };\");\n+  }\n+\n+  public void testPropertyInference6() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { }\" +\n+        \"(new F).x_ = 3;\" +\n+        \"/** @return {string} */\" +\n+        \"F.prototype.bar = function() { return this.x_; };\");\n+  }\n+\n+  public void testPropertyInference7() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { this.x_ = true; }\" +\n+        \"(new F).x_ = 3;\" +\n+        \"/** @return {string} */\" +\n+        \"F.prototype.bar = function() { return this.x_; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testPropertyInference8() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { \" +\n+        \"  /** @type {string} */ this.x_ = 'x';\" +\n+        \"}\" +\n+        \"(new F).x_ = 3;\" +\n+        \"/** @return {string} */\" +\n+        \"F.prototype.bar = function() { return this.x_; };\",\n+        \"assignment to property x_ of F\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testNoPersistentTypeInferenceForObjectProperties()\n+      throws Exception {\n+    testTypes(\"/** @param {Object} o\\n@param {string} x */\\n\" +\n+        \"function s1(o,x) { o.x = x; }\\n\" +\n+        \"/** @param {Object} o\\n@return {string} */\\n\" +\n+        \"function g1(o) { return typeof o.x == 'undefined' ? '' : o.x; }\\n\" +\n+        \"/** @param {Object} o\\n@param {number} x */\\n\" +\n+        \"function s2(o,x) { o.x = x; }\\n\" +\n+        \"/** @param {Object} o\\n@return {number} */\\n\" +\n+        \"function g2(o) { return typeof o.x == 'undefined' ? 0 : o.x; }\");\n+  }\n+\n+  public void testNoPersistentTypeInferenceForFunctionProperties()\n+      throws Exception {\n+    testTypes(\"/** @param {Function} o\\n@param {string} x */\\n\" +\n+        \"function s1(o,x) { o.x = x; }\\n\" +\n+        \"/** @param {Function} o\\n@return {string} */\\n\" +\n+        \"function g1(o) { return typeof o.x == 'undefined' ? '' : o.x; }\\n\" +\n+        \"/** @param {Function} o\\n@param {number} x */\\n\" +\n+        \"function s2(o,x) { o.x = x; }\\n\" +\n+        \"/** @param {Function} o\\n@return {number} */\\n\" +\n+        \"function g2(o) { return typeof o.x == 'undefined' ? 0 : o.x; }\");\n+  }\n+\n+  public void testObjectPropertyTypeInferredInLocalScope1() throws Exception {\n+    testTypes(\"/** @param {!Object} o\\n@return {string} */\\n\" +\n+        \"function f(o) { o.x = 1; return o.x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testObjectPropertyTypeInferredInLocalScope2() throws Exception {\n+    testTypes(\"/**@param {!Object} o\\n@param {number?} x\\n@return {string}*/\" +\n+        \"function f(o, x) { o.x = 'a';\\nif (x) {o.x = x;}\\nreturn o.x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testObjectPropertyTypeInferredInLocalScope3() throws Exception {\n+    testTypes(\"/**@param {!Object} o\\n@param {number?} x\\n@return {string}*/\" +\n+        \"function f(o, x) { if (x) {o.x = x;} else {o.x = 'a';}\\nreturn o.x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty1()\n+      throws Exception {\n+    testTypes(\"/** @constructor */var T = function() { this.x = ''; };\\n\" +\n+        \"/** @type {number} */ T.prototype.x = 0;\",\n+        \"assignment to property x of T\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty2()\n+      throws Exception {\n+    testTypes(\"/** @constructor */var T = function() { this.x = ''; };\\n\" +\n+        \"/** @type {number} */ T.prototype.x;\",\n+        \"assignment to property x of T\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty3()\n+      throws Exception {\n+    testTypes(\"/** @type {Object} */ var n = {};\\n\" +\n+        \"/** @constructor */ n.T = function() { this.x = ''; };\\n\" +\n+        \"/** @type {number} */ n.T.prototype.x = 0;\",\n+        \"assignment to property x of n.T\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty4()\n+      throws Exception {\n+    testTypes(\"var n = {};\\n\" +\n+        \"/** @constructor */ n.T = function() { this.x = ''; };\\n\" +\n+        \"/** @type {number} */ n.T.prototype.x = 0;\",\n+        \"assignment to property x of n.T\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testPropertyUsedBeforeDefinition1() throws Exception {\n+    testTypes(\"/** @constructor */ var T = function() {};\\n\" +\n+        \"/** @return {string} */\" +\n+        \"T.prototype.f = function() { return this.g(); };\\n\" +\n+        \"/** @return {number} */ T.prototype.g = function() { return 1; };\\n\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testPropertyUsedBeforeDefinition2() throws Exception {\n+    testTypes(\"var n = {};\\n\" +\n+        \"/** @constructor */ n.T = function() {};\\n\" +\n+        \"/** @return {string} */\" +\n+        \"n.T.prototype.f = function() { return this.g(); };\\n\" +\n+        \"/** @return {number} */ n.T.prototype.g = function() { return 1; };\\n\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testAdd1() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){var a = 'abc'+foo();}\");\n+  }\n+\n+  public void testAdd2() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){var a = foo()+4;}\");\n+  }\n+\n+  public void testAdd3() throws Exception {\n+    testTypes(\"/** @type {string} */ var a = 'a';\" +\n+        \"/** @type {string} */ var b = 'b';\" +\n+        \"/** @type {string} */ var c = a + b;\");\n+  }\n+\n+  public void testAdd4() throws Exception {\n+    testTypes(\"/** @type {number} */ var a = 5;\" +\n+        \"/** @type {string} */ var b = 'b';\" +\n+        \"/** @type {string} */ var c = a + b;\");\n+  }\n+\n+  public void testAdd5() throws Exception {\n+    testTypes(\"/** @type {string} */ var a = 'a';\" +\n+        \"/** @type {number} */ var b = 5;\" +\n+        \"/** @type {string} */ var c = a + b;\");\n+  }\n+\n+  public void testAdd6() throws Exception {\n+    testTypes(\"/** @type {number} */ var a = 5;\" +\n+        \"/** @type {number} */ var b = 5;\" +\n+        \"/** @type {number} */ var c = a + b;\");\n+  }\n+\n+  public void testAdd7() throws Exception {\n+    testTypes(\"/** @type {number} */ var a = 5;\" +\n+        \"/** @type {string} */ var b = 'b';\" +\n+        \"/** @type {number} */ var c = a + b;\",\n+        \"initializing variable\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAdd8() throws Exception {\n+    testTypes(\"/** @type {string} */ var a = 'a';\" +\n+        \"/** @type {number} */ var b = 5;\" +\n+        \"/** @type {number} */ var c = a + b;\",\n+        \"initializing variable\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAdd9() throws Exception {\n+    testTypes(\"/** @type {number} */ var a = 5;\" +\n+        \"/** @type {number} */ var b = 5;\" +\n+        \"/** @type {string} */ var c = a + b;\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testAdd10() throws Exception {\n+    // d.e.f will have unknown type.\n+    testTypes(\n+        suppressMissingProperty(\"e\", \"f\") +\n+        \"/** @type {number} */ var a = 5;\" +\n+        \"/** @type {string} */ var c = a + d.e.f;\");\n+  }\n+\n+  public void testAdd11() throws Exception {\n+    // d.e.f will have unknown type.\n+    testTypes(\n+        suppressMissingProperty(\"e\", \"f\") +\n+        \"/** @type {number} */ var a = 5;\" +\n+        \"/** @type {number} */ var c = a + d.e.f;\");\n+  }\n+\n+  public void testAdd12() throws Exception {\n+    testTypes(\"/** @return {(number,string)} */ function a() { return 5; }\" +\n+        \"/** @type {number} */ var b = 5;\" +\n+        \"/** @type {boolean} */ var c = a() + b;\",\n+        \"initializing variable\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testAdd13() throws Exception {\n+    testTypes(\"/** @type {number} */ var a = 5;\" +\n+        \"/** @return {(number,string)} */ function b() { return 5; }\" +\n+        \"/** @type {boolean} */ var c = a + b();\",\n+        \"initializing variable\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testAdd14() throws Exception {\n+    testTypes(\"/** @type {(null,string)} */ var a = null;\" +\n+        \"/** @type {number} */ var b = 5;\" +\n+        \"/** @type {boolean} */ var c = a + b;\",\n+        \"initializing variable\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testAdd15() throws Exception {\n+    testTypes(\"/** @type {number} */ var a = 5;\" +\n+        \"/** @return {(number,string)} */ function b() { return 5; }\" +\n+        \"/** @type {boolean} */ var c = a + b();\",\n+        \"initializing variable\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testAdd16() throws Exception {\n+    testTypes(\"/** @type {(undefined,string)} */ var a = undefined;\" +\n+        \"/** @type {number} */ var b = 5;\" +\n+        \"/** @type {boolean} */ var c = a + b;\",\n+        \"initializing variable\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testAdd17() throws Exception {\n+    testTypes(\"/** @type {number} */ var a = 5;\" +\n+        \"/** @type {(undefined,string)} */ var b = undefined;\" +\n+        \"/** @type {boolean} */ var c = a + b;\",\n+        \"initializing variable\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testAdd18() throws Exception {\n+    testTypes(\"function f() {};\" +\n+        \"/** @type {string} */ var a = 'a';\" +\n+        \"/** @type {number} */ var c = a + f();\",\n+        \"initializing variable\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAdd19() throws Exception {\n+    testTypes(\"/** @param {number} opt_x\\n@param {number} opt_y\\n\" +\n+        \"@return {number} */ function f(opt_x, opt_y) {\" +\n+        \"return opt_x + opt_y;}\");\n+  }\n+\n+  public void testAdd20() throws Exception {\n+    testTypes(\"/** @param {!Number} opt_x\\n@param {!Number} opt_y\\n\" +\n+        \"@return {number} */ function f(opt_x, opt_y) {\" +\n+        \"return opt_x + opt_y;}\");\n+  }\n+\n+  public void testAdd21() throws Exception {\n+    testTypes(\"/** @param {Number|Boolean} opt_x\\n\" +\n+        \"@param {number|boolean} opt_y\\n\" +\n+        \"@return {number} */ function f(opt_x, opt_y) {\" +\n+        \"return opt_x + opt_y;}\");\n+  }\n+\n+  public void testNumericComparison1() throws Exception {\n+    testTypes(\"/**@param {number} a*/ function f(a) {return a < 3;}\");\n+  }\n+\n+  public void testNumericComparison2() throws Exception {\n+    testTypes(\"/**@param {!Object} a*/ function f(a) {return a < 3;}\",\n+        \"left side of numeric comparison\\n\" +\n+        \"found   : Object\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testNumericComparison3() throws Exception {\n+    testTypes(\"/**@param {string} a*/ function f(a) {return a < 3;}\");\n+  }\n+\n+  public void testNumericComparison4() throws Exception {\n+    testTypes(\"/**@param {(number,undefined)} a*/ \" +\n+              \"function f(a) {return a < 3;}\");\n+  }\n+\n+  public void testNumericComparison5() throws Exception {\n+    testTypes(\"/**@param {*} a*/ function f(a) {return a < 3;}\",\n+        \"left side of numeric comparison\\n\" +\n+        \"found   : *\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testNumericComparison6() throws Exception {\n+    testTypes(\"/**@return void*/ function foo() { if (3 >= foo()) return; }\",\n+        \"right side of numeric comparison\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testStringComparison1() throws Exception {\n+    testTypes(\"/**@param {string} a*/ function f(a) {return a < 'x';}\");\n+  }\n+\n+  public void testStringComparison2() throws Exception {\n+    testTypes(\"/**@param {Object} a*/ function f(a) {return a < 'x';}\");\n+  }\n+\n+  public void testStringComparison3() throws Exception {\n+    testTypes(\"/**@param {number} a*/ function f(a) {return a < 'x';}\");\n+  }\n+\n+  public void testStringComparison4() throws Exception {\n+    testTypes(\"/**@param {string|undefined} a*/ \" +\n+                  \"function f(a) {return a < 'x';}\");\n+  }\n+\n+  public void testStringComparison5() throws Exception {\n+    testTypes(\"/**@param {*} a*/ \" +\n+                  \"function f(a) {return a < 'x';}\");\n+  }\n+\n+  public void testStringComparison6() throws Exception {\n+    testTypes(\"/**@return void*/ function foo() { if ('a' >= foo()) return; }\",\n+        \"right side of comparison\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testValueOfComparison1() throws Exception {\n+    testTypes(\"/** @constructor */function O() {};\" +\n+        \"/**@override*/O.prototype.valueOf = function() { return 1; };\" +\n+        \"/**@param {!O} a\\n@param {!O} b*/ function f(a,b) { return a < b; }\");\n+  }\n+\n+  public void testValueOfComparison2() throws Exception {\n+    testTypes(\"/** @constructor */function O() {};\" +\n+        \"/**@override*/O.prototype.valueOf = function() { return 1; };\" +\n+        \"/**@param {!O} a\\n@param {number} b*/\" +\n+        \"function f(a,b) { return a < b; }\");\n+  }\n+\n+  public void testValueOfComparison3() throws Exception {\n+    testTypes(\"/** @constructor */function O() {};\" +\n+        \"/**@override*/O.prototype.toString = function() { return 'o'; };\" +\n+        \"/**@param {!O} a\\n@param {string} b*/\" +\n+        \"function f(a,b) { return a < b; }\");\n+  }\n+\n+  public void testGenericRelationalExpression() throws Exception {\n+    testTypes(\"/**@param {*} a\\n@param {*} b*/ \" +\n+                  \"function f(a,b) {return a < b;}\");\n+  }\n+\n+  public void testInstanceof1() throws Exception {\n+    testTypes(\"function foo(){\" +\n+        \"if (bar instanceof 3)return;}\",\n+        \"instanceof requires an object\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testInstanceof2() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){\" +\n+        \"if (foo() instanceof Object)return;}\",\n+        \"deterministic instanceof yields false\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: NoObject\");\n+  }\n+\n+  public void testInstanceof3() throws Exception {\n+    testTypes(\"/**@return {*} */function foo(){\" +\n+        \"if (foo() instanceof Object)return;}\");\n+  }\n+\n+  public void testInstanceof4() throws Exception {\n+    testTypes(\"/**@return {(Object|number)} */function foo(){\" +\n+        \"if (foo() instanceof Object)return 3;}\");\n+  }\n+\n+  public void testInstanceof5() throws Exception {\n+    // No warning for unknown types.\n+    testTypes(\"function foo(){\" +\n+        \"if (foo() instanceof Object)return;}\");\n+  }\n+\n+  public void testInstanceof6() throws Exception {\n+    testTypes(\"/**@return {(Array|number)} */function foo(){\" +\n+        \"if (foo() instanceof Object)return 3;}\");\n+  }\n+\n+  public void testInstanceOfReduction3() throws Exception {\n+    testTypes(\n+        \"/** \\n\" +\n+        \" * @param {Object} x \\n\" +\n+        \" * @param {Function} y \\n\" +\n+        \" * @return {boolean} \\n\" +\n+        \" */\\n\" +\n+        \"var f = function(x, y) {\\n\" +\n+        \"  return x instanceof y;\\n\" +\n+        \"};\");\n+  }\n+\n+  public void testScoping1() throws Exception {\n+    testTypes(\n+        \"/**@param {string} a*/function foo(a){\" +\n+        \"  /**@param {Array|string} a*/function bar(a){\" +\n+        \"    if (a instanceof Array)return;\" +\n+        \"  }\" +\n+        \"}\");\n+  }\n+\n+  public void testScoping2() throws Exception {\n+    testTypes(\n+        \"/** @type number */ var a;\" +\n+        \"function Foo() {\" +\n+        \"  /** @type string */ var a;\" +\n+        \"}\");\n+  }\n+\n+  public void testScoping3() throws Exception {\n+    testTypes(\"\\n\\n/** @type{Number}*/var b;\\n/** @type{!String} */var b;\",\n+        \"variable b redefined with type String, original \" +\n+        \"definition at  [testcode] :3 with type (Number|null)\");\n+  }\n+\n+  public void testScoping4() throws Exception {\n+    testTypes(\"/** @type{Number}*/var b; if (true) /** @type{!String} */var b;\",\n+        \"variable b redefined with type String, original \" +\n+        \"definition at  [testcode] :1 with type (Number|null)\");\n+  }\n+\n+  public void testScoping5() throws Exception {\n+    // multiple definitions are not checked by the type checker but by a\n+    // subsequent pass\n+    testTypes(\"if (true) var b; var b;\");\n+  }\n+\n+  public void testScoping6() throws Exception {\n+    // multiple definitions are not checked by the type checker but by a\n+    // subsequent pass\n+    testTypes(\"if (true) var b; if (true) var b;\");\n+  }\n+\n+  public void testScoping7() throws Exception {\n+    testTypes(\"/** @constructor */function A() {\" +\n+        \"  /** @type !A */this.a = null;\" +\n+        \"}\",\n+        \"assignment to property a of A\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: A\");\n+  }\n+\n+  public void testScoping8() throws Exception {\n+    testTypes(\"/** @constructor */function A() {}\" +\n+        \"/** @constructor */function B() {\" +\n+        \"  /** @type !A */this.a = null;\" +\n+        \"}\",\n+        \"assignment to property a of B\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: A\");\n+  }\n+\n+  public void testScoping9() throws Exception {\n+    testTypes(\"/** @constructor */function B() {\" +\n+        \"  /** @type !A */this.a = null;\" +\n+        \"}\" +\n+        \"/** @constructor */function A() {}\",\n+        \"assignment to property a of B\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: A\");\n+  }\n+\n+  public void testScoping10() throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\"var a = function b(){};\");\n+\n+    // a declared, b is not\n+    assertTrue(p.second.isDeclared(\"a\", false));\n+    assertFalse(p.second.isDeclared(\"b\", false));\n+\n+    // checking that a has the correct assigned type\n+    assertEquals(\"function (): ?\", p.second.getVar(\"a\").getType().toString());\n+  }\n+\n+  public void testScoping11() throws Exception {\n+    // named anonymous functions create a binding in their body only\n+    // the return is wrong but the assignment is ok since the type of b is ?\n+    testTypes(\n+        \"/** @return number */var a = function b(){ return b };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : function (): number\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testFunctionArguments1() throws Exception {\n+    testFunctionType(\n+        \"/** @param {number} a\\n@return string */\" +\n+        \"function f(a) {}\",\n+        \"function (number): string\");\n+  }\n+\n+  public void testFunctionArguments2() throws Exception {\n+    testFunctionType(\n+        \"/** @param {number} opt_a\\n@return string */\" +\n+        \"function f(opt_a) {}\",\n+        \"function ((number|undefined)): string\");\n+  }\n+\n+  public void testFunctionArguments3() throws Exception {\n+    testFunctionType(\n+        \"/** @param {number} b\\n@return string */\" +\n+        \"function f(a,b) {}\",\n+        \"function (?, number): string\");\n+  }\n+\n+  public void testFunctionArguments4() throws Exception {\n+    testFunctionType(\n+        \"/** @param {number} opt_a\\n@return string */\" +\n+        \"function f(a,opt_a) {}\",\n+        \"function (?, (number|undefined)): string\");\n+  }\n+\n+  public void testFunctionArguments5() throws Exception {\n+    testTypes(\n+        \"function a(opt_a,a) {}\",\n+        \"optional arguments must be at the end\");\n+  }\n+\n+  public void testFunctionArguments6() throws Exception {\n+    testTypes(\n+        \"function a(var_args,a) {}\",\n+        \"variable length argument must be last\");\n+  }\n+\n+  public void testFunctionArguments7() throws Exception {\n+    testTypes(\n+        \"/** @param {number} opt_a\\n@return string */\" +\n+        \"function a(a,opt_a,var_args) {}\");\n+  }\n+\n+  public void testFunctionArguments8() throws Exception {\n+    testTypes(\n+        \"function a(a,opt_a,var_args,b) {}\",\n+        \"variable length argument must be last\");\n+  }\n+\n+  public void testFunctionArguments9() throws Exception {\n+    // testing that only one error is reported\n+    testTypes(\n+        \"function a(a,opt_a,var_args,b,c) {}\",\n+        \"variable length argument must be last\");\n+  }\n+\n+  public void testFunctionArguments10() throws Exception {\n+    // testing that only one error is reported\n+    testTypes(\n+        \"function a(a,opt_a,b,c) {}\",\n+        \"optional arguments must be at the end\");\n+  }\n+\n+  public void testFunctionArguments11() throws Exception {\n+    testTypes(\n+        \"function a(a,opt_a,b,c,var_args,d) {}\",\n+        \"optional arguments must be at the end\");\n+  }\n+\n+  public void testFunctionArguments12() throws Exception {\n+    testTypes(\"/** @param foo {String} */function bar(baz){}\",\n+        \"parameter foo does not appear in bar's parameter list\");\n+  }\n+\n+  public void testFunctionArguments13() throws Exception {\n+    // verifying that the argument type have inferable types\n+    testTypes(\n+        \"/** @return {boolean} */ function u() { return true; }\" +\n+        \"/** @param {boolean} b\\n@return boolean */\" +\n+        \"function f(b) { if (u()) { b = null; } return b; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (boolean|null)\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testFunctionArguments14() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {string} x\\n\" +\n+        \" * @param {number} opt_y\\n\" +\n+        \" * @param {boolean} var_args\\n\" +\n+        \" */ function f(x, opt_y, var_args) {}\" +\n+        \"f('3'); f('3', 2); f('3', 2, true); f('3', 2, true, false);\");\n+  }\n+\n+  public void testFunctionArguments15() throws Exception {\n+    testTypes(\n+        \"/** @param {?function(*)} f */\" +\n+        \"function g(f) { f(1, 2); }\",\n+        \"Function f: called with 2 argument(s). \" +\n+        \"Function requires at least 1 argument(s) \" +\n+        \"and no more than 1 argument(s).\");\n+  }\n+\n+  public void testPrintFunctionName1() throws Exception {\n+    // Ensures that the function name is pretty.\n+    testTypes(\n+        \"var goog = {}; goog.run = function(f) {};\" +\n+        \"goog.run();\",\n+        \"Function goog.run: called with 0 argument(s). \" +\n+        \"Function requires at least 1 argument(s) \" +\n+        \"and no more than 1 argument(s).\");\n+  }\n+\n+  public void testPrintFunctionName2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {}; \" +\n+        \"Foo.prototype.run = function(f) {};\" +\n+        \"(new Foo).run();\",\n+        \"Function Foo.prototype.run: called with 0 argument(s). \" +\n+        \"Function requires at least 1 argument(s) \" +\n+        \"and no more than 1 argument(s).\");\n+  }\n+\n+  public void testFunctionInference1() throws Exception {\n+    testFunctionType(\n+        \"function f(a) {}\",\n+        \"function (?): ?\");\n+  }\n+\n+  public void testFunctionInference2() throws Exception {\n+    testFunctionType(\n+        \"function f(a,b) {}\",\n+        \"function (?, ?): ?\");\n+  }\n+\n+  public void testFunctionInference3() throws Exception {\n+    testFunctionType(\n+        \"function f(var_args) {}\",\n+        \"function (...[?]): ?\");\n+  }\n+\n+  public void testFunctionInference4() throws Exception {\n+    testFunctionType(\n+        \"function f(a,b,c,var_args) {}\",\n+        \"function (?, ?, ?, ...[?]): ?\");\n+  }\n+\n+  public void testFunctionInference5() throws Exception {\n+    testFunctionType(\n+        \"/** @this Date\\n@return string */function f(a) {}\",\n+        \"function (this:Date, ?): string\");\n+  }\n+\n+  public void testFunctionInference6() throws Exception {\n+    testFunctionType(\n+        \"/** @this Date\\n@return string */function f(opt_a) {}\",\n+        \"function (this:Date, ?): string\");\n+  }\n+\n+  public void testFunctionInference7() throws Exception {\n+    testFunctionType(\n+        \"/** @this Date */function f(a,b,c,var_args) {}\",\n+        \"function (this:Date, ?, ?, ?, ...[?]): ?\");\n+  }\n+\n+  public void testFunctionInference8() throws Exception {\n+    testFunctionType(\n+        \"function f() {}\",\n+        \"function (): ?\");\n+  }\n+\n+  public void testFunctionInference9() throws Exception {\n+    testFunctionType(\n+        \"var f = function() {};\",\n+        \"function (): ?\");\n+  }\n+\n+  public void testFunctionInference10() throws Exception {\n+    testFunctionType(\n+        \"/** @this Date\\n@param {boolean} b\\n@return string */\" +\n+        \"var f = function(a,b) {};\",\n+        \"function (this:Date, ?, boolean): string\");\n+  }\n+\n+  public void testFunctionInference11() throws Exception {\n+    testFunctionType(\n+        \"var goog = {};\" +\n+        \"/** @return number*/goog.f = function(){};\",\n+        \"goog.f\",\n+        \"function (): number\");\n+  }\n+\n+  public void testFunctionInference12() throws Exception {\n+    testFunctionType(\n+        \"var goog = {};\" +\n+        \"goog.f = function(){};\",\n+        \"goog.f\",\n+        \"function (): ?\");\n+  }\n+\n+  public void testFunctionInference13() throws Exception {\n+    testFunctionType(\n+        \"var goog = {};\" +\n+        \"/** @constructor */ goog.Foo = function(){};\" +\n+        \"/** @param {!goog.Foo} f */function eatFoo(f){};\",\n+        \"eatFoo\",\n+        \"function (goog.Foo): ?\");\n+  }\n+\n+  public void testFunctionInference14() throws Exception {\n+    testFunctionType(\n+        \"var goog = {};\" +\n+        \"/** @constructor */ goog.Foo = function(){};\" +\n+        \"/** @return {!goog.Foo} */function eatFoo(){ return new goog.Foo; };\",\n+        \"eatFoo\",\n+        \"function (): goog.Foo\");\n+  }\n+\n+  public void testFunctionInference15() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() {};\" +\n+        \"f.prototype.foo = function(){};\",\n+        \"f.prototype.foo\",\n+        \"function (this:f): ?\");\n+  }\n+\n+  public void testFunctionInference16() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() {};\" +\n+        \"f.prototype.foo = function(){};\",\n+        \"(new f).foo\",\n+        \"function (this:f): ?\");\n+  }\n+\n+  public void testFunctionInference17() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() {}\" +\n+        \"function abstractMethod() {}\" +\n+        \"/** @param {number} x */ f.prototype.foo = abstractMethod;\",\n+        \"(new f).foo\",\n+        \"function (this:f, number): ?\");\n+  }\n+\n+  public void testFunctionInference18() throws Exception {\n+    testFunctionType(\n+        \"var goog = {};\" +\n+        \"/** @this {Date} */ goog.eatWithDate;\",\n+        \"goog.eatWithDate\",\n+        \"function (this:Date): ?\");\n+  }\n+\n+  public void testFunctionInference19() throws Exception {\n+    testFunctionType(\n+        \"/** @param {string} x */ var f;\",\n+        \"f\",\n+        \"function (string): ?\");\n+  }\n+\n+  public void testFunctionInference20() throws Exception {\n+    testFunctionType(\n+        \"/** @this {Date} */ var f;\",\n+        \"f\",\n+        \"function (this:Date): ?\");\n+  }\n+\n+  public void testAbstractMethodHandling1() throws Exception {\n+    testTypes(\n+        \"/** @type {Function} */ var abstractFn = function() {};\" +\n+        \"abstractFn(1);\");\n+  }\n+\n+  public void testAbstractMethodHandling2() throws Exception {\n+    testTypes(\n+        \"var abstractFn = function() {};\" +\n+        \"abstractFn(1);\",\n+        \"Function abstractFn: called with 1 argument(s). \" +\n+        \"Function requires at least 0 argument(s) \" +\n+        \"and no more than 0 argument(s).\");\n+  }\n+\n+  public void testAbstractMethodHandling3() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @type {Function} */ goog.abstractFn = function() {};\" +\n+        \"goog.abstractFn(1);\");\n+  }\n+\n+  public void testAbstractMethodHandling4() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"goog.abstractFn = function() {};\" +\n+        \"goog.abstractFn(1);\",\n+        \"Function goog.abstractFn: called with 1 argument(s). \" +\n+        \"Function requires at least 0 argument(s) \" +\n+        \"and no more than 0 argument(s).\");\n+  }\n+\n+  public void testAbstractMethodHandling5() throws Exception {\n+    testTypes(\n+        \"/** @type {Function} */ var abstractFn = function() {};\" +\n+        \"/** @param {number} x */ var f = abstractFn;\" +\n+        \"f('x');\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAbstractMethodHandling6() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @type {Function} */ goog.abstractFn = function() {};\" +\n+        \"/** @param {number} x */ goog.f = abstractFn;\" +\n+        \"goog.f('x');\",\n+        \"actual parameter 1 of goog.f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMethodInference1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** @return {number} */ F.prototype.foo = function() { return 3; };\" +\n+        \"/** @constructor \\n * @extends {F} */ \" +\n+        \"function G() {}\" +\n+        \"/** @override */ G.prototype.foo = function() { return true; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMethodInference2() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @constructor */ goog.F = function() {};\" +\n+        \"/** @return {number} */ goog.F.prototype.foo = \" +\n+        \"    function() { return 3; };\" +\n+        \"/** @constructor \\n * @extends {goog.F} */ \" +\n+        \"goog.G = function() {};\" +\n+        \"/** @override */ goog.G.prototype.foo = function() { return true; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMethodInference3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** @param {boolean} x \\n * @return {number} */ \" +\n+        \"F.prototype.foo = function(x) { return 3; };\" +\n+        \"/** @constructor \\n * @extends {F} */ \" +\n+        \"function G() {}\" +\n+        \"/** @override */ \" +\n+        \"G.prototype.foo = function(x) { return x; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMethodInference4() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** @param {boolean} x \\n * @return {number} */ \" +\n+        \"F.prototype.foo = function(x) { return 3; };\" +\n+        \"/** @constructor \\n * @extends {F} */ \" +\n+        \"function G() {}\" +\n+        \"/** @override */ \" +\n+        \"G.prototype.foo = function(y) { return y; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMethodInference5() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** @param {number} x \\n * @return {string} */ \" +\n+        \"F.prototype.foo = function(x) { return 'x'; };\" +\n+        \"/** @constructor \\n * @extends {F} */ \" +\n+        \"function G() {}\" +\n+        \"/** @type {number} */ G.prototype.num = 3;\" +\n+        \"/** @override */ \" +\n+        \"G.prototype.foo = function(y) { return this.num + y; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testMethodInference6() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n+        \"/** @constructor \\n * @extends {F} */ \" +\n+        \"function G() {}\" +\n+        \"/** @override */ G.prototype.foo = function() { };\" +\n+        \"(new G()).foo(1);\",\n+        \"Function G.prototype.foo: called with 1 argument(s). \" +\n+        \"Function requires at least 0 argument(s) \" +\n+        \"and no more than 0 argument(s).\");\n+  }\n+\n+  public void testMethodInference7() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"F.prototype.foo = function() { };\" +\n+        \"/** @constructor \\n * @extends {F} */ \" +\n+        \"function G() {}\" +\n+        \"/** @override */ G.prototype.foo = function(x, y) { };\" +\n+        \"(new G()).foo();\",\n+        \"Function G.prototype.foo: called with 0 argument(s). \" +\n+        \"Function requires at least 2 argument(s) \" +\n+        \"and no more than 2 argument(s).\");\n+  }\n+\n+  public void testMethodInference8() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"F.prototype.foo = function() { };\" +\n+        \"/** @constructor \\n * @extends {F} */ \" +\n+        \"function G() {}\" +\n+        \"/** @override */ \" +\n+        \"G.prototype.foo = function(a, opt_b, var_args) { };\" +\n+        \"(new G()).foo();\",\n+        \"Function G.prototype.foo: called with 0 argument(s). \" +\n+        \"Function requires at least 1 argument(s).\");\n+  }\n+\n+  public void testMethodInference9() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() {}\" +\n+        \"F.prototype.foo = function() { };\" +\n+        \"/** @constructor \\n * @extends {F} */ \" +\n+        \"function G() {}\" +\n+        \"/** @override */ \" +\n+        \"G.prototype.foo = function(a, var_args, opt_b) { };\",\n+        \"variable length argument must be last\");\n+  }\n+\n+  public void testStaticMethodDeclaration1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function F() { F.foo(true); }\" +\n+        \"/** @param {number} x */ F.foo = function(x) {};\",\n+        \"actual parameter 1 of F.foo does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testStaticMethodDeclaration2() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {}; function f() { goog.foo(true); }\" +\n+        \"/** @param {number} x */ goog.foo = function(x) {};\",\n+        \"actual parameter 1 of goog.foo does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testStaticMethodDeclaration3() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {}; function f() { goog.foo(true); }\" +\n+        \"goog.foo = function() {};\",\n+        \"Function goog.foo: called with 1 argument(s). Function requires \" +\n+        \"at least 0 argument(s) and no more than 0 argument(s).\");\n+  }\n+\n+  public void testDuplicateStaticMethodDecl1() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @param {number} x */ goog.foo = function(x) {};\" +\n+        \"/** @param {number} x */ goog.foo = function(x) {};\",\n+        \"variable goog.foo redefined with type function (number): ?, \" +\n+        \"original definition at  [testcode] :1 with type function (number): ?\");\n+  }\n+\n+  public void testDuplicateStaticMethodDecl2() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @param {number} x */ goog.foo = function(x) {};\" +\n+        \"/** @param {number} x \\n * @suppress {duplicate} */ \" +\n+        \"goog.foo = function(x) {};\");\n+  }\n+\n+  public void testDuplicateStaticMethodDecl3() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"goog.foo = function(x) {};\" +\n+        \"goog.foo = function(x) {};\");\n+  }\n+\n+  public void testDuplicateStaticMethodDecl4() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @type {Function} */ goog.foo = function(x) {};\" +\n+        \"goog.foo = function(x) {};\");\n+  }\n+\n+  public void testDuplicateStaticMethodDecl5() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"goog.foo = function(x) {};\" +\n+        \"/** @return {undefined} */ goog.foo = function(x) {};\",\n+        \"variable goog.foo redefined with type function (?): undefined, \" +\n+        \"original definition at  [testcode] :1 with type function (?): ?\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl1() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @type {Foo} */ goog.foo;\" +\n+        \"/** @type {Foo} */ goog.foo;\" +\n+        \"/** @constructor */ function Foo() {}\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl2() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @type {Foo} */ goog.foo;\" +\n+        \"/** @type {Foo} \\n * @suppress {duplicate} */ goog.foo;\" +\n+        \"/** @constructor */ function Foo() {}\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl3() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @type {!Foo} */ goog.foo;\" +\n+        \"/** @type {string} */ goog.foo;\" +\n+        \"/** @constructor */ function Foo() {}\",\n+        \"variable goog.foo redefined with type string, \" +\n+        \"original definition at  [testcode] :1 with type Foo\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl4() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @type {!Foo} */ goog.foo;\" +\n+        \"/** @type {string} */ goog.foo = 'x';\" +\n+        \"/** @constructor */ function Foo() {}\",\n+        \"variable goog.foo redefined with type string, \" +\n+        \"original definition at  [testcode] :1 with type Foo\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl5() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @type {!Foo} */ goog.foo;\" +\n+        \"/** @type {string}\\n * @suppress {duplicate} */ goog.foo = 'x';\" +\n+        \"/** @constructor */ function Foo() {}\",\n+        \"variable goog.foo redefined with type string, \" +\n+        \"original definition at  [testcode] :1 with type Foo\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl6() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @type {string} */ goog.foo = 'y';\" +\n+        \"/** @type {string}\\n * @suppress {duplicate} */ goog.foo = 'x';\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl7() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @param {string} x */ goog.foo;\" +\n+        \"/** @type {function(string)} */ goog.foo;\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl8() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @return {EventCopy} */ goog.foo;\" +\n+        \"/** @constructor */ function EventCopy() {}\" +\n+        \"/** @return {EventCopy} */ goog.foo;\");\n+  }\n+\n+  public void testDuplicateStaticPropertyDecl9() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @return {EventCopy} */ goog.foo;\" +\n+        \"/** @return {EventCopy} */ goog.foo;\" +\n+        \"/** @constructor */ function EventCopy() {}\");\n+  }\n+\n+  public void testDuplicateLocalVarDecl() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x */\\n\" +\n+        \"function f(x) { /** @type {string} */ var x = ''; }\",\n+        \"variable x redefined with type string, \" +\n+        \"original definition at  [testcode] :2 with type number\");\n+  }\n+\n+  public void testStubFunctionDeclaration1() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() {};\" +\n+        \"/** @param {number} x \\n * @param {string} y \\n\" +\n+        \"  * @return {number} */ f.prototype.foo;\",\n+        \"(new f).foo\",\n+        \"function (this:f, number, string): number\");\n+  }\n+\n+  public void testStubFunctionDeclaration2() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() {};\" +\n+        \"/** @constructor \\n * @extends {f} */ f.subclass;\",\n+        \"f.subclass\",\n+        \"function (this:f.subclass): ?\");\n+  }\n+\n+  public void testStubFunctionDeclaration3() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() {};\" +\n+        \"/** @return {undefined} */ f.foo;\",\n+        \"f.foo\",\n+        \"function (): undefined\");\n+  }\n+\n+  public void testStubFunctionDeclaration4() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() { \" +\n+        \"  /** @return {number} */ this.foo;\" +\n+        \"}\",\n+        \"(new f).foo\",\n+        \"function (this:f): number\");\n+  }\n+\n+  public void testStubFunctionDeclaration5() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() { \" +\n+        \"  /** @type {Function} */ this.foo;\" +\n+        \"}\",\n+        \"(new f).foo\",\n+        createNullableType(U2U_CONSTRUCTOR_TYPE).toString());\n+  }\n+\n+  public void testStubFunctionDeclaration6() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() {} \" +\n+        \"/** @type {Function} */ f.prototype.foo;\",\n+        \"(new f).foo\",\n+        createNullableType(U2U_CONSTRUCTOR_TYPE).toString());\n+  }\n+\n+  public void testStubFunctionDeclaration7() throws Exception {\n+    testFunctionType(\n+        \"/** @constructor */ function f() {} \" +\n+        \"/** @type {Function} */ f.prototype.foo = function() {};\",\n+        \"(new f).foo\",\n+        createNullableType(U2U_CONSTRUCTOR_TYPE).toString());\n+  }\n+\n+  public void testStubFunctionDeclaration8() throws Exception {\n+    /** TODO(user): This is not exactly correct yet. The var\n+            itself is nullable. */\n+    testFunctionType(\n+        \"/** @type {Function} */ var f = function() {}; \",\n+        \"f\",\n+        createNullableType(U2U_CONSTRUCTOR_TYPE).\n+          restrictByNotNullOrUndefined().toString());\n+  }\n+\n+  public void testStubFunctionDeclaration9() throws Exception {\n+    testFunctionType(\n+        \"/** @type {function():number} */ var f; \",\n+        \"f\",\n+        \"function (): number\");\n+  }\n+\n+  public void testStubFunctionDeclaration10() throws Exception {\n+    testFunctionType(\n+        \"/** @type {function(number):number} */ var f = function(x) {};\",\n+        \"f\",\n+        \"function (number): number\");\n+  }\n+\n+  public void testNestedFunctionInference1() throws Exception {\n+    String nestedAssignOfFooAndBar =\n+        \"/** @constructor */ function f() {};\" +\n+        \"f.prototype.foo = f.prototype.bar = function(){};\";\n+    testFunctionType(nestedAssignOfFooAndBar, \"(new f).bar\",\n+        \"function (this:f): ?\");\n+  }\n+\n+  /**\n+   * Tests the type of a function definition. The function defined by\n+   * {@code functionDef} should be named {@code \"f\"}.\n+   */\n+  private void testFunctionType(String functionDef, String functionType)\n+      throws Exception {\n+    testFunctionType(functionDef, \"f\", functionType);\n+  }\n+\n+  /**\n+   * Tests the type of a function definition. The function defined by\n+   * {@code functionDef} should be named {@code functionName}.\n+   */\n+  private void testFunctionType(String functionDef, String functionName,\n+      String functionType) throws Exception {\n+    // using the variable initialization check to verify the function's type\n+    testTypes(\n+        functionDef +\n+        \"/** @type number */var a=\" + functionName + \";\",\n+        \"initializing variable\\n\" +\n+        \"found   : \" + functionType + \"\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testTypeRedefinition() throws Exception {\n+    testTypes(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n+        + \"/** @constructor */ a.A = function() {}\",\n+        \"variable a.A redefined with type function (this:a.A): ?, \" +\n+        \"original definition at  [testcode] :1 with type enum{a.A}\");\n+  }\n+\n+  public void testIn1() throws Exception {\n+    testTypes(\"'foo' in Object\");\n+  }\n+\n+  public void testIn2() throws Exception {\n+    testTypes(\"3 in Object\");\n+  }\n+\n+  public void testIn3() throws Exception {\n+    testTypes(\"undefined in Object\");\n+  }\n+\n+  public void testIn4() throws Exception {\n+    testTypes(\"Date in Object\",\n+        \"left side of 'in'\\n\" +\n+        \"found   : function (this:Date, ?, ?, ?, ?, ?, ?, ?): string\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testIn5() throws Exception {\n+    testTypes(\"'x' in null\",\n+        \"'in' requires an object\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  // TODO(nicksantos): change this to something that makes sense.\n+//   public void testComparison1() throws Exception {\n+//     testTypes(\"/**@type null */var a;\" +\n+//         \"/**@type !Date */var b;\" +\n+//         \"if (a==b) {}\",\n+//         \"condition always evaluates to false\\n\" +\n+//         \"left : null\\n\" +\n+//         \"right: Date\");\n+//   }\n+\n+  public void testComparison2() throws Exception {\n+    testTypes(\"/**@type number*/var a;\" +\n+        \"/**@type !Date */var b;\" +\n+        \"if (a!==b) {}\",\n+        \"condition always evaluates to the same value\\n\" +\n+        \"left : number\\n\" +\n+        \"right: Date\");\n+  }\n+\n+  public void testComparison3() throws Exception {\n+    // Since null == undefined in JavaScript, this code is reasonable.\n+    testTypes(\"/** @type {(Object,undefined)} */var a;\" +\n+        \"var b = a == null\");\n+  }\n+\n+  public void testComparison4() throws Exception {\n+    testTypes(\"/** @type {(!Object,undefined)} */var a;\" +\n+        \"/** @type {!Object} */var b;\" +\n+        \"var c = a == b\");\n+  }\n+\n+  public void testComparison5() throws Exception {\n+    testTypes(\"/** @type null */var a;\" +\n+        \"/** @type null */var b;\" +\n+        \"a == b\",\n+        \"condition always evaluates to true\\n\" +\n+        \"left : null\\n\" +\n+        \"right: null\");\n+  }\n+\n+  public void testComparison6() throws Exception {\n+    testTypes(\"/** @type null */var a;\" +\n+        \"/** @type null */var b;\" +\n+        \"a != b\",\n+        \"condition always evaluates to false\\n\" +\n+        \"left : null\\n\" +\n+        \"right: null\");\n+  }\n+\n+  public void testComparison7() throws Exception {\n+    testTypes(\"var a;\" +\n+        \"var b;\" +\n+        \"a == b\",\n+        \"condition always evaluates to true\\n\" +\n+        \"left : undefined\\n\" +\n+        \"right: undefined\");\n+  }\n+\n+  public void testComparison8() throws Exception {\n+    testTypes(\"/** @type {Array.<string>} */ var a = [];\" +\n+        \"a[0] == null || a[1] == undefined\");\n+  }\n+\n+  public void testComparison9() throws Exception {\n+    testTypes(\"/** @type {Array.<undefined>} */ var a = [];\" +\n+        \"a[0] == null\",\n+        \"condition always evaluates to true\\n\" +\n+        \"left : undefined\\n\" +\n+        \"right: null\");\n+  }\n+\n+  public void testComparison10() throws Exception {\n+    testTypes(\"/** @type {Array.<undefined>} */ var a = [];\" +\n+        \"a[0] === null\");\n+  }\n+\n+  public void testEnumStaticMethod1() throws Exception {\n+    testTypes(\n+        \"/** @enum */ var Foo = {AAA: 1};\" +\n+        \"/** @param {number} x */ Foo.method = function(x) {};\" +\n+        \"Foo.method(true);\",\n+        \"actual parameter 1 of Foo.method does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testEnumStaticMethod2() throws Exception {\n+    testTypes(\n+        \"/** @enum */ var Foo = {AAA: 1};\" +\n+        \"/** @param {number} x */ Foo.method = function(x) {};\" +\n+        \"function f() { Foo.method(true); }\",\n+        \"actual parameter 1 of Foo.method does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testEnum1() throws Exception {\n+    testTypes(\"/**@enum*/var a={BB:1,CC:2};\\n\" +\n+        \"/**@type {a}*/var d;d=a.BB;\");\n+  }\n+\n+  public void testEnum2() throws Exception {\n+    testTypes(\"/**@enum*/var a={b:1}\",\n+        \"enum key b must be a syntactic constant\");\n+  }\n+\n+  public void testEnum3() throws Exception {\n+    testTypes(\"/**@enum*/var a={BB:1,BB:2}\",\n+        \"enum element BB already defined\", true);\n+  }\n+\n+  public void testEnum4() throws Exception {\n+    testTypes(\"/**@enum*/var a={BB:'string'}\",\n+        \"element type must match enum's type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testEnum5() throws Exception {\n+    testTypes(\"/**@enum {String}*/var a={BB:'string'}\",\n+        \"element type must match enum's type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: (String|null)\");\n+  }\n+\n+  public void testEnum6() throws Exception {\n+    testTypes(\"/**@enum*/var a={BB:1,CC:2};\\n/**@type {!Array}*/var d;d=a.BB;\",\n+        \"assignment\\n\" +\n+        \"found   : a.<number>\\n\" +\n+        \"required: Array\");\n+  }\n+\n+  public void testEnum7() throws Exception {\n+    testTypes(\"/** @enum */var a={AA:1,BB:2,CC:3};\" +\n+        \"/** @type a */var b=a.D;\",\n+        \"element D does not exist on this enum\");\n+  }\n+\n+  public void testEnum8() throws Exception {\n+    testTypes(\"/** @enum */var a=8;\",\n+        \"enum initializer must be an object literal or an enum\");\n+  }\n+\n+  public void testEnum9() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @enum */goog.a=8;\",\n+        \"enum initializer must be an object literal or an enum\");\n+  }\n+\n+  public void testEnum10() throws Exception {\n+    testTypes(\n+        \"/** @enum {number} */\" +\n+        \"goog.K = { A : 3 };\");\n+  }\n+\n+  public void testEnum11() throws Exception {\n+    testTypes(\n+        \"/** @enum {number} */\" +\n+        \"goog.K = { 502 : 3 };\");\n+  }\n+\n+  public void testEnum12() throws Exception {\n+    testTypes(\n+        \"/** @enum {number} */ var a = {};\" +\n+        \"/** @enum */ var b = a;\");\n+  }\n+\n+  public void testEnum13() throws Exception {\n+    testTypes(\n+        \"/** @enum {number} */ var a = {};\" +\n+        \"/** @enum {string} */ var b = a;\",\n+        \"incompatible enum element types\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testEnum14() throws Exception {\n+    testTypes(\n+        \"/** @enum {number} */ var a = {FOO:5};\" +\n+        \"/** @enum */ var b = a;\" +\n+        \"var c = b.FOO;\");\n+  }\n+\n+  public void testEnum15() throws Exception {\n+    testTypes(\n+        \"/** @enum {number} */ var a = {FOO:5};\" +\n+        \"/** @enum */ var b = a;\" +\n+        \"var c = b.BAR;\",\n+        \"element BAR does not exist on this enum\");\n+  }\n+\n+  public void testEnum16() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/**@enum*/goog.a={BB:1,BB:2}\",\n+        \"enum element BB already defined\", true);\n+  }\n+\n+  public void testEnum17() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/**@enum*/goog.a={BB:'string'}\",\n+        \"element type must match enum's type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testEnum18() throws Exception {\n+    testTypes(\"/**@enum*/ var E = {A: 1, B: 2};\" +\n+        \"/** @param {!E} x\\n@return {number} */\\n\" +\n+        \"var f = function(x) { return x; };\");\n+  }\n+\n+  public void testEnum19() throws Exception {\n+    testTypes(\"/**@enum*/ var E = {A: 1, B: 2};\" +\n+        \"/** @param {number} x\\n@return {!E} */\\n\" +\n+        \"var f = function(x) { return x; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: E.<number>\");\n+  }\n+\n+  public void testEnum20() throws Exception {\n+    testTypes(\"/**@enum*/ var E = {A: 1, B: 2}; var x = []; x[E.A] = 0;\");\n+  }\n+\n+  public void testEnum21() throws Exception {\n+    Node n = parseAndTypeCheck(\n+        \"/** @enum {string} */ var E = {A : 'a', B : 'b'};\\n\" +\n+        \"/** @param {!E} x\\n@return {!E} */ function f(x) { return x; }\");\n+    Node nodeX = n.getLastChild().getLastChild().getLastChild().getLastChild();\n+    JSType typeE = nodeX.getJSType();\n+    assertFalse(typeE.isObject());\n+    assertFalse(typeE.isNullable());\n+  }\n+\n+  public void testEnum22() throws Exception {\n+    testTypes(\"/**@enum*/ var E = {A: 1, B: 2};\" +\n+        \"/** @param {E} x \\n* @return {number} */ function f(x) {return x}\");\n+  }\n+\n+  public void testEnum23() throws Exception {\n+    testTypes(\"/**@enum*/ var E = {A: 1, B: 2};\" +\n+        \"/** @param {E} x \\n* @return {string} */ function f(x) {return x}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : E.<number>\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testEnum24() throws Exception {\n+    testTypes(\"/**@enum {Object} */ var E = {A: {}};\" +\n+        \"/** @param {E} x \\n* @return {!Object} */ function f(x) {return x}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : E.<(Object|null)>\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testEnum25() throws Exception {\n+    testTypes(\"/**@enum {!Object} */ var E = {A: {}};\" +\n+        \"/** @param {E} x \\n* @return {!Object} */ function f(x) {return x}\");\n+  }\n+\n+  public void testEnum26() throws Exception {\n+    testTypes(\"var a = {}; /**@enum*/ a.B = {A: 1, B: 2};\" +\n+        \"/** @param {a.B} x \\n* @return {number} */ function f(x) {return x}\");\n+  }\n+\n+  public void testEnum27() throws Exception {\n+    // x is unknown\n+    testTypes(\"/** @enum */ var A = {B: 1, C: 2}; \" +\n+        \"function f(x) { return A == x; }\");\n+  }\n+\n+  public void testEnum28() throws Exception {\n+    // x is unknown\n+    testTypes(\"/** @enum */ var A = {B: 1, C: 2}; \" +\n+        \"function f(x) { return A.B == x; }\");\n+  }\n+\n+  public void testEnum29() throws Exception {\n+    testTypes(\"/** @enum */ var A = {B: 1, C: 2}; \" +\n+        \"/** @return {number} */ function f() { return A; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : enum{A}\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testEnum30() throws Exception {\n+    testTypes(\"/** @enum */ var A = {B: 1, C: 2}; \" +\n+        \"/** @return {number} */ function f() { return A.B; }\");\n+  }\n+\n+  public void testEnum31() throws Exception {\n+    testTypes(\"/** @enum */ var A = {B: 1, C: 2}; \" +\n+        \"/** @return {A} */ function f() { return A; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : enum{A}\\n\" +\n+        \"required: A.<number>\");\n+  }\n+\n+  public void testEnum32() throws Exception {\n+    testTypes(\"/** @enum */ var A = {B: 1, C: 2}; \" +\n+        \"/** @return {A} */ function f() { return A.B; }\");\n+  }\n+\n+  public void testEnum34() throws Exception {\n+    testTypes(\"/** @enum */ var A = {B: 1, C: 2}; \" +\n+        \"/** @param {number} x */ function f(x) { return x == A.B; }\");\n+  }\n+\n+  public void testEnum35() throws Exception {\n+    testTypes(\"var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};\" +\n+              \"/** @return {a.b} */ function f() { return a.b.C; }\");\n+  }\n+\n+  public void testEnum36() throws Exception {\n+    testTypes(\"var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};\" +\n+              \"/** @return {!a.b} */ function f() { return 1; }\",\n+              \"inconsistent return type\\n\" +\n+              \"found   : number\\n\" +\n+              \"required: a.b.<number>\");\n+  }\n+\n+  public void testEnum37() throws Exception {\n+    testTypes(\n+        \"var goog = goog || {};\" +\n+        \"/** @enum {number} */ goog.a = {};\" +\n+        \"/** @enum */ var b = goog.a;\");\n+  }\n+\n+  public void testEnum38() throws Exception {\n+    testTypes(\n+        \"/** @enum {MyEnum} */ var MyEnum = {};\" +\n+        \"/** @param {MyEnum} x */ function f(x) {}\",\n+        \"Parse error. Cycle detected in inheritance chain \" +\n+        \"of type MyEnum\");\n+  }\n+\n+  public void testEnum39() throws Exception {\n+    testTypes(\n+        \"/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};\" +\n+        \"/** @param {MyEnum} x \\n * @return {number} */\" +\n+        \"function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testEnum40() throws Exception {\n+    testTypes(\n+        \"/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};\" +\n+        \"/** @param {number} x \\n * @return {number} */\" +\n+        \"function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAliasedEnum1() throws Exception {\n+    testTypes(\n+        \"/** @enum */ var YourEnum = {FOO: 3};\" +\n+        \"/** @enum */ var MyEnum = YourEnum;\" +\n+        \"/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);\");\n+  }\n+\n+  public void testAliasedEnum2() throws Exception {\n+    testTypes(\n+        \"/** @enum */ var YourEnum = {FOO: 3};\" +\n+        \"/** @enum */ var MyEnum = YourEnum;\" +\n+        \"/** @param {YourEnum} x */ function f(x) {} f(MyEnum.FOO);\");\n+  }\n+\n+  public void testAliasedEnum3() throws Exception {\n+    testTypes(\n+        \"/** @enum */ var YourEnum = {FOO: 3};\" +\n+        \"/** @enum */ var MyEnum = YourEnum;\" +\n+        \"/** @param {MyEnum} x */ function f(x) {} f(YourEnum.FOO);\");\n+  }\n+\n+  public void testAliasedEnum4() throws Exception {\n+    testTypes(\n+        \"/** @enum */ var YourEnum = {FOO: 3};\" +\n+        \"/** @enum */ var MyEnum = YourEnum;\" +\n+        \"/** @param {YourEnum} x */ function f(x) {} f(YourEnum.FOO);\");\n+  }\n+\n+  public void testAliasedEnum5() throws Exception {\n+    testTypes(\n+        \"/** @enum */ var YourEnum = {FOO: 3};\" +\n+        \"/** @enum */ var MyEnum = YourEnum;\" +\n+        \"/** @param {string} x */ function f(x) {} f(MyEnum.FOO);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : YourEnum.<number>\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBackwardsEnumUse1() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */ function f() { return MyEnum.FOO; }\" +\n+        \"/** @enum {string} */ var MyEnum = {FOO: 'x'};\");\n+  }\n+\n+  public void testBackwardsEnumUse2() throws Exception {\n+    testTypes(\n+        \"/** @return {number} */ function f() { return MyEnum.FOO; }\" +\n+        \"/** @enum {string} */ var MyEnum = {FOO: 'x'};\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : MyEnum.<string>\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBackwardsEnumUse3() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */ function f() { return MyEnum.FOO; }\" +\n+        \"/** @enum {string} */ var YourEnum = {FOO: 'x'};\" +\n+        \"/** @enum {string} */ var MyEnum = YourEnum;\");\n+  }\n+\n+  public void testBackwardsEnumUse4() throws Exception {\n+    testTypes(\n+        \"/** @return {number} */ function f() { return MyEnum.FOO; }\" +\n+        \"/** @enum {string} */ var YourEnum = {FOO: 'x'};\" +\n+        \"/** @enum {string} */ var MyEnum = YourEnum;\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : YourEnum.<string>\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBackwardsEnumUse5() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */ function f() { return MyEnum.BAR; }\" +\n+        \"/** @enum {string} */ var YourEnum = {FOO: 'x'};\" +\n+        \"/** @enum {string} */ var MyEnum = YourEnum;\",\n+        \"element BAR does not exist on this enum\");\n+  }\n+\n+  public void testBackwardsConstructor1() throws Exception {\n+    testTypes(\n+        \"function f() { (new Foo(true)); }\" +\n+        \"/** \\n * @constructor \\n * @param {number} x */\" +\n+        \"var Foo = function(x) {};\",\n+        \"actual parameter 1 of Foo does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBackwardsConstructor2() throws Exception {\n+    testTypes(\n+        \"function f() { (new Foo(true)); }\" +\n+        \"/** \\n * @constructor \\n * @param {number} x */\" +\n+        \"var YourFoo = function(x) {};\" +\n+        \"/** \\n * @constructor \\n * @param {number} x */\" +\n+        \"var Foo = YourFoo;\",\n+        \"actual parameter 1 of Foo does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testMinimalConstructorAnnotation() throws Exception {\n+    testTypes(\"/** @constructor */function Foo(){}\");\n+  }\n+\n+  public void testGoodExtends1() throws Exception {\n+    // A minimal @extends example\n+    testTypes(\"/** @constructor */function base() {}\\n\" +\n+        \"/** @constructor\\n * @extends {base} */function derived() {}\\n\");\n+  }\n+\n+  public void testGoodExtends2() throws Exception {\n+    testTypes(\"/** @constructor\\n * @extends base */function derived() {}\\n\" +\n+        \"/** @constructor */function base() {}\\n\");\n+  }\n+\n+  public void testGoodExtends3() throws Exception {\n+    testTypes(\"/** @constructor\\n * @extends {Object} */function base() {}\\n\" +\n+        \"/** @constructor\\n * @extends {base} */function derived() {}\\n\");\n+  }\n+\n+  public void testGoodExtends4() throws Exception {\n+    // Ensure that @extends actually sets the base type of a constructor\n+    // correctly. Because this isn't part of the human-readable Function\n+    // definition, we need to crawl the prototype chain (eww).\n+    Node n = parseAndTypeCheck(\n+        \"var goog = {};\\n\" +\n+        \"/** @constructor */goog.Base = function(){};\\n\" +\n+        \"/** @constructor\\n\" +\n+        \"  * @extends {goog.Base} */goog.Derived = function(){};\\n\");\n+    Node subTypeName = n.getLastChild().getLastChild().getFirstChild();\n+    assertEquals(\"goog.Derived\", subTypeName.getQualifiedName());\n+\n+    FunctionType subCtorType =\n+        (FunctionType) subTypeName.getNext().getJSType();\n+    assertEquals(\"goog.Derived\", subCtorType.getInstanceType().toString());\n+\n+    JSType superType = subCtorType.getPrototype().getImplicitPrototype();\n+    assertEquals(\"goog.Base\", superType.toString());\n+  }\n+\n+  public void testGoodExtends5() throws Exception {\n+    // we allow for the extends annotation to be placed first\n+    testTypes(\"/** @constructor */function base() {}\\n\" +\n+        \"/** @extends {base}\\n * @constructor */function derived() {}\\n\");\n+  }\n+\n+  public void testGoodExtends6() throws Exception {\n+    testFunctionType(\n+        CLOSURE_DEFS +\n+        \"/** @constructor */function base() {}\\n\" +\n+        \"/** @return {number} */ \" +\n+        \"  base.prototype.foo = function() { return 1; };\\n\" +\n+        \"/** @extends {base}\\n * @constructor */function derived() {}\\n\" +\n+        \"goog.inherits(derived, base);\",\n+        \"derived.superClass_.foo\",\n+        \"function (this:base): number\");\n+  }\n+\n+  public void testGoodExtends7() throws Exception {\n+    testFunctionType(\n+        \"Function.prototype.inherits = function(x) {};\" +\n+        \"/** @constructor */function base() {}\\n\" +\n+        \"/** @extends {base}\\n * @constructor */function derived() {}\\n\" +\n+        \"derived.inherits(base);\",\n+        \"(new derived).constructor\",\n+        \"function (this:derived): ?\");\n+  }\n+\n+  public void testGoodExtends8() throws Exception {\n+    testTypes(\"/** @constructor \\n @extends {Base} */ function Sub() {}\" +\n+        \"/** @return {number} */ function f() { return (new Sub()).foo; }\" +\n+        \"/** @constructor */ function Base() {}\" +\n+        \"/** @type {boolean} */ Base.prototype.foo = true;\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBadExtends1() throws Exception {\n+    testTypes(\"/** @constructor */function base() {}\\n\" +\n+        \"/** @constructor\\n * @extends {not_base} */function derived() {}\\n\",\n+        \"Parse error. Unknown type not_base\");\n+  }\n+\n+  public void testBadExtends2() throws Exception {\n+    testTypes(\"/** @constructor */function base() {\\n\" +\n+        \"/** @type {!Number}*/\\n\" +\n+        \"this.baseMember = new Number(4);\\n\" +\n+        \"}\\n\" +\n+        \"/** @constructor\\n\" +\n+        \"  * @extends {base} */function derived() {}\\n\" +\n+        \"/** @param {!String} x*/\\n\" +\n+        \"function foo(x){ }\\n\" +\n+        \"/** @type {!derived}*/var y;\\n\" +\n+        \"foo(y.baseMember);\\n\",\n+        \"actual parameter 1 of foo does not match formal parameter\\n\" +\n+        \"found   : Number\\n\" +\n+        \"required: String\");\n+  }\n+\n+  public void testBadExtends3() throws Exception {\n+    testTypes(\"/** @extends {Object} */function base() {}\",\n+        \"@extends used without @constructor or @interface for base\");\n+  }\n+\n+  public void testLateExtends() throws Exception {\n+    testTypes(\n+        CLOSURE_DEFS +\n+        \"/** @constructor */ function Foo() {}\\n\" +\n+        \"Foo.prototype.foo = function() {};\\n\" +\n+        \"/** @constructor */function Bar() {}\\n\" +\n+        \"goog.inherits(Foo, Bar);\\n\",\n+        \"Missing @extends tag on type Foo\");\n+  }\n+\n+  public void testSuperclassMatch() throws Exception {\n+    compiler.options_.setCodingConvention(new GoogleCodingConvention());\n+    testTypes(\"/** @constructor */ var Foo = function() {};\\n\" +\n+        \"/** @constructor \\n @extends Foo */ var Bar = function() {};\\n\" +\n+        \"Bar.inherits = function(x){};\" +\n+        \"Bar.inherits(Foo);\\n\");\n+  }\n+\n+  public void testSuperclassMatchWithMixin() throws Exception {\n+    compiler.options_.setCodingConvention(new GoogleCodingConvention());\n+    testTypes(\"/** @constructor */ var Foo = function() {};\\n\" +\n+        \"/** @constructor */ var Baz = function() {};\\n\" +\n+        \"/** @constructor \\n @extends Foo */ var Bar = function() {};\\n\" +\n+        \"Bar.inherits = function(x){};\" +\n+        \"Bar.mixin = function(y){};\" +\n+        \"Bar.inherits(Foo);\\n\" +\n+        \"Bar.mixin(Baz);\\n\");\n+  }\n+\n+  public void testSuperclassMismatch1() throws Exception {\n+    compiler.options_.setCodingConvention(new GoogleCodingConvention());\n+    testTypes(\"/** @constructor */ var Foo = function() {};\\n\" +\n+        \"/** @constructor \\n @extends Object */ var Bar = function() {};\\n\" +\n+        \"Bar.inherits = function(x){};\" +\n+        \"Bar.inherits(Foo);\\n\",\n+        \"Missing @extends tag on type Bar\");\n+  }\n+\n+  public void testSuperclassMismatch2() throws Exception {\n+    compiler.options_.setCodingConvention(new GoogleCodingConvention());\n+    testTypes(\"/** @constructor */ var Foo = function(){};\\n\" +\n+        \"/** @constructor */ var Bar = function(){};\\n\" +\n+        \"Bar.inherits = function(x){};\" +\n+        \"Bar.inherits(Foo);\",\n+        \"Missing @extends tag on type Bar\");\n+  }\n+\n+  public void testSuperClassDefinedAfterSubClass1() throws Exception {\n+    testTypes(\n+        \"/** @constructor \\n * @extends {Base} */ function A() {}\" +\n+        \"/** @constructor \\n * @extends {Base} */ function B() {}\" +\n+        \"/** @constructor */ function Base() {}\" +\n+        \"/** @param {A|B} x \\n * @return {B|A} */ \" +\n+        \"function foo(x) { return x; }\");\n+  }\n+\n+  public void testSuperClassDefinedAfterSubClass2() throws Exception {\n+    testTypes(\n+        \"/** @constructor \\n * @extends {Base} */ function A() {}\" +\n+        \"/** @constructor \\n * @extends {Base} */ function B() {}\" +\n+        \"/** @param {A|B} x \\n * @return {B|A} */ \" +\n+        \"function foo(x) { return x; }\" +\n+        \"/** @constructor */ function Base() {}\");\n+  }\n+\n+  public void testDirectPrototypeAssignment1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Base() {}\" +\n+        \"Base.prototype.foo = 3;\" +\n+        \"/** @constructor \\n * @extends {Base} */ function A() {}\" +\n+        \"A.prototype = new Base();\" +\n+        \"/** @return {string} */ function foo() { return (new A).foo; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testDirectPrototypeAssignment2() throws Exception {\n+    // This ensures that we don't attach property 'foo' onto the Base\n+    // instance object.\n+    testTypes(\n+        \"/** @constructor */ function Base() {}\" +\n+        \"/** @constructor \\n * @extends {Base} */ function A() {}\" +\n+        \"A.prototype = new Base();\" +\n+        \"A.prototype.foo = 3;\" +\n+        \"/** @return {string} */ function foo() { return (new Base).foo; }\");\n+  }\n+\n+  public void testGoodImplements1() throws Exception {\n+    testTypes(\"/** @interface */function Disposable() {}\\n\" +\n+        \"/** @implements {Disposable}\\n * @constructor */function f() {}\");\n+  }\n+\n+  public void testGoodImplements2() throws Exception {\n+    testTypes(\"/** @interface */function Base1() {}\\n\" +\n+        \"/** @interface */function Base2() {}\\n\" +\n+        \"/** @constructor\\n\" +\n+        \" * @implements {Base1}\\n\" +\n+        \" * @implements {Base2}\\n\" +\n+        \" */ function derived() {}\");\n+  }\n+\n+  public void testGoodImplements3() throws Exception {\n+    testTypes(\"/** @interface */function Disposable() {}\\n\" +\n+        \"/** @implements {Disposable}\\n * @interface */function f() {}\");\n+  }\n+\n+  public void testBadImplements1() throws Exception {\n+    testTypes(\"/** @interface */function Base1() {}\\n\" +\n+        \"/** @interface */function Base2() {}\\n\" +\n+        \"/** @constructor\\n\" +\n+        \" * @implements {nonExistent}\\n\" +\n+        \" * @implements {Base2}\\n\" +\n+        \" */ function derived() {}\",\n+        \"Parse error. Unknown type nonExistent\");\n+  }\n+\n+  public void testBadImplements2() throws Exception {\n+    testTypes(\"/** @interface */function Disposable() {}\\n\" +\n+        \"/** @implements {Disposable}\\n */function f() {}\",\n+        \"@implements used without @constructor or @interface for f\");\n+  }\n+\n+  public void testInterfaceExtends() throws Exception {\n+    testTypes(\"/** @interface */function A() {}\\n\" +\n+        \"/** @interface \\n * @extends {A} */function B() {}\\n\" +\n+        \"/** @constructor\\n\" +\n+        \" * @implements {B}\\n\" +\n+        \" */ function derived() {}\");\n+  }\n+\n+  public void testBadInterfaceExtends1() throws Exception {\n+    testTypes(\"/** @interface \\n * @extends {nonExistent} */function A() {}\",\n+        \"Parse error. Unknown type nonExistent\");\n+  }\n+\n+  public void testBadInterfaceExtends2() throws Exception {\n+    testTypes(\"/** @constructor */function A() {}\\n\" +\n+        \"/** @interface \\n * @extends {A} */function B() {}\",\n+        \"B cannot extend this type; a constructor can only extend objects \" +\n+        \"and an interface can only extend interfaces\");\n+  }\n+\n+  public void testBadInterfaceExtends3() throws Exception {\n+    testTypes(\"/** @interface */function A() {}\\n\" +\n+        \"/** @constructor \\n * @extends {A} */function B() {}\",\n+        \"B cannot extend this type; a constructor can only extend objects \" +\n+        \"and an interface can only extend interfaces\");\n+  }\n+\n+  public void testBadInterfaceExtends4() throws Exception {\n+    // TODO(user): This should be detected as an error. Even if we enforce\n+    // that A cannot be used in the assignment, we should still detect the\n+    // inheritance chain as invalid.\n+    testTypes(\"/** @interface */function A() {}\\n\" +\n+        \"/** @constructor */function B() {}\\n\" +\n+        \"B.prototype = A;\");\n+  }\n+\n+  public void testBadInterfaceExtends5() throws Exception {\n+    // TODO(user): This should be detected as an error. Even if we enforce\n+    // that A cannot be used in the assignment, we should still detect the\n+    // inheritance chain as invalid.\n+    testTypes(\"/** @constructor */function A() {}\\n\" +\n+        \"/** @interface */function B() {}\\n\" +\n+        \"B.prototype = A;\");\n+  }\n+\n+  public void testBadImplementsAConstructor() throws Exception {\n+    testTypes(\"/** @constructor */function A() {}\\n\" +\n+        \"/** @constructor \\n * @implements {A} */function B() {}\",\n+        \"can only implement interfaces\");\n+  }\n+\n+  public void testBadImplementsNonInterfaceType() throws Exception {\n+    testTypes(\"/** @constructor \\n * @implements {Boolean} */function B() {}\",\n+        \"can only implement interfaces\");\n+  }\n+\n+  public void testBadImplementsNonObjectType() throws Exception {\n+    testTypes(\"/** @constructor \\n * @implements {string} */function S() {}\",\n+        \"can only implement interfaces\");\n+  }\n+\n+  public void testInterfaceAssignment1() throws Exception {\n+    testTypes(\"/** @interface */var I = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I} */var T = function() {};\\n\" +\n+        \"var t = new T();\\n\" +\n+        \"/** @type {!I} */var i = t;\");\n+  }\n+\n+  public void testInterfaceAssignment2() throws Exception {\n+    testTypes(\"/** @interface */var I = function() {};\\n\" +\n+        \"/** @constructor */var T = function() {};\\n\" +\n+        \"var t = new T();\\n\" +\n+        \"/** @type {!I} */var i = t;\",\n+        \"initializing variable\\n\" +\n+        \"found   : T\\n\" +\n+        \"required: I\");\n+  }\n+\n+  public void testInterfaceAssignment3() throws Exception {\n+    testTypes(\"/** @interface */var I = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I} */var T = function() {};\\n\" +\n+        \"var t = new T();\\n\" +\n+        \"/** @type {I|number} */var i = t;\");\n+  }\n+\n+  public void testInterfaceAssignment4() throws Exception {\n+    testTypes(\"/** @interface */var I1 = function() {};\\n\" +\n+        \"/** @interface */var I2 = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I1} */var T = function() {};\\n\" +\n+        \"var t = new T();\\n\" +\n+        \"/** @type {I1|I2} */var i = t;\");\n+  }\n+\n+  public void testInterfaceAssignment5() throws Exception {\n+    testTypes(\"/** @interface */var I1 = function() {};\\n\" +\n+        \"/** @interface */var I2 = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I1}\\n@implements {I2}*/\" +\n+        \"var T = function() {};\\n\" +\n+        \"var t = new T();\\n\" +\n+        \"/** @type {I1} */var i1 = t;\\n\" +\n+        \"/** @type {I2} */var i2 = t;\\n\");\n+  }\n+\n+  public void testInterfaceAssignment6() throws Exception {\n+    testTypes(\"/** @interface */var I1 = function() {};\\n\" +\n+        \"/** @interface */var I2 = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I1} */var T = function() {};\\n\" +\n+        \"/** @type {!I1} */var i1 = new T();\\n\" +\n+        \"/** @type {!I2} */var i2 = i1;\\n\",\n+        \"initializing variable\\n\" +\n+        \"found   : I1\\n\" +\n+        \"required: I2\");\n+  }\n+\n+  public void testInterfaceAssignment7() throws Exception {\n+    testTypes(\"/** @interface */var I1 = function() {};\\n\" +\n+        \"/** @interface\\n@extends {I1}*/var I2 = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I2}*/var T = function() {};\\n\" +\n+        \"var t = new T();\\n\" +\n+        \"/** @type {I1} */var i1 = t;\\n\" +\n+        \"/** @type {I2} */var i2 = t;\\n\" +\n+        \"i1 = i2;\\n\");\n+  }\n+\n+  public void testInterfaceAssignment8() throws Exception {\n+    testTypes(\"/** @interface */var I = function() {};\\n\" +\n+        \"/** @type {I} */var i;\\n\" +\n+        \"/** @type {Object} */var o = i;\");\n+  }\n+\n+  public void testInterfaceAssignment9() throws Exception {\n+    testTypes(\"/** @interface */var I = function() {};\\n\" +\n+        \"/** @return {I?} */function f() { return null; }\\n\" +\n+        \"/** @type {!I} */var i = f();\\n\",\n+        \"initializing variable\\n\" +\n+        \"found   : (I|null)\\n\" +\n+        \"required: I\");\n+  }\n+\n+  public void testInterfaceAssignment10() throws Exception {\n+    testTypes(\"/** @interface */var I1 = function() {};\\n\" +\n+        \"/** @interface */var I2 = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I2} */var T = function() {};\\n\" +\n+        \"/** @return {!I1|!I2} */function f() { return new T(); }\\n\" +\n+        \"/** @type {!I1} */var i1 = f();\\n\",\n+        \"initializing variable\\n\" +\n+        \"found   : (I1|I2)\\n\" +\n+        \"required: I1\");\n+  }\n+\n+  public void testInterfaceAssignment11() throws Exception {\n+    testTypes(\"/** @interface */var I1 = function() {};\\n\" +\n+        \"/** @interface */var I2 = function() {};\\n\" +\n+        \"/** @constructor */var T = function() {};\\n\" +\n+        \"/** @return {!I1|!I2|!T} */function f() { return new T(); }\\n\" +\n+        \"/** @type {!I1} */var i1 = f();\\n\",\n+        \"initializing variable\\n\" +\n+        \"found   : (I1|I2|T)\\n\" +\n+        \"required: I1\");\n+  }\n+\n+  public void testInterfaceAssignment12() throws Exception {\n+    testTypes(\"/** @interface */var I = function() {};\\n\" +\n+              \"/** @constructor\\n@implements{I}*/var T1 = function() {};\\n\" +\n+              \"/** @constructor\\n@extends {T1}*/var T2 = function() {};\\n\" +\n+              \"/** @return {I} */function f() { return new T2(); }\");\n+  }\n+\n+  public void testInterfaceAssignment13() throws Exception {\n+    testTypes(\"/** @interface */var I = function() {};\\n\" +\n+        \"/** @constructor\\n@implements {I}*/var T = function() {};\\n\" +\n+        \"/** @constructor */function Super() {};\\n\" +\n+        \"/** @return {I} */Super.prototype.foo = \" +\n+        \"function() { return new T(); };\\n\" +\n+        \"/** @constructor\\n@extends {Super} */function Sub() {}\\n\" +\n+        \"/** @override\\n@return {T} */Sub.prototype.foo = \" +\n+        \"function() { return new T(); };\\n\");\n+  }\n+\n+  public void testGetprop1() throws Exception {\n+    testTypes(\"/** @return {void}*/function foo(){foo().bar;}\",\n+        \"undefined has no properties\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testArrayAccess1() throws Exception {\n+    testTypes(\"var a = []; var b = a['hi'];\");\n+  }\n+\n+  public void testArrayAccess2() throws Exception {\n+    testTypes(\"var a = []; var b = a[[1,2]];\",\n+        \"array access\\n\" +\n+        \"found   : Array\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testArrayAccess3() throws Exception {\n+    testTypes(\"var bar = [];\" +\n+        \"/** @return {void} */function baz(){};\" +\n+        \"var foo = bar[baz()];\",\n+        \"array access\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testArrayAccess4() throws Exception {\n+    testTypes(\"/**@return {!Array}*/function foo(){};var bar = foo()[foo()];\",\n+        \"array access\\n\" +\n+        \"found   : Array\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testArrayAccess6() throws Exception {\n+    testTypes(\"var bar = null[1];\",\n+        \"only arrays or objects can be accessed\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testArrayAccess7() throws Exception {\n+    testTypes(\"var bar = void 0; bar[0];\",\n+        \"only arrays or objects can be accessed\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testArrayAccess8() throws Exception {\n+    // Verifies that we don't emit two warnings, because\n+    // the var has been dereferenced after the first one.\n+    testTypes(\"var bar = void 0; bar[0]; bar[1];\",\n+        \"only arrays or objects can be accessed\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testPropAccess() throws Exception {\n+    testTypes(\"/** @param {*} x */var f = function(x) {\\n\" +\n+        \"var o = String(x);\\n\" +\n+        \"if (typeof o['a'] != 'undefined') { return o['a']; }\\n\" +\n+        \"return null;\\n\" +\n+        \"};\");\n+  }\n+\n+  public void testPropAccess2() throws Exception {\n+    testTypes(\"var bar = void 0; bar.baz;\",\n+        \"undefined has no properties\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testPropAccess3() throws Exception {\n+    // Verifies that we don't emit two warnings, because\n+    // the var has been dereferenced after the first one.\n+    testTypes(\"var bar = void 0; bar.baz; bar.bax;\",\n+        \"undefined has no properties\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testPropAccess4() throws Exception {\n+    testTypes(\"/** @param {*} x */ function f(x) { return x['hi']; }\");\n+  }\n+\n+  public void testSwitchCase1() throws Exception {\n+    testTypes(\"/**@type number*/var a;\" +\n+        \"/**@type string*/var b;\" +\n+        \"switch(a){case b:;}\",\n+        \"case expression doesn't match switch\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testSwitchCase2() throws Exception {\n+    testTypes(\"var a = null; switch (typeof a) { case 'foo': }\");\n+  }\n+\n+  public void testVar1() throws Exception {\n+    Pair<Node, Scope> p =\n+        parseAndTypeCheckWithScope(\"/** @type {(string,null)} */var a = null\");\n+\n+    assertEquals(createUnionType(STRING_TYPE, NULL_TYPE),\n+        p.getSecond().getVar(\"a\").getType());\n+  }\n+\n+  public void testVar2() throws Exception {\n+    testTypes(\"/** @type {Function} */ var a = function(){}\");\n+  }\n+\n+  public void testVar3() throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\"var a = 3;\");\n+\n+    assertEquals(NUMBER_TYPE, p.second.getVar(\"a\").getType());\n+  }\n+\n+  public void testVar4() throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+        \"var a = 3; a = 'string';\");\n+\n+    assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n+        p.second.getVar(\"a\").getType());\n+  }\n+\n+  public void testVar5() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @type string */goog.foo = 'hello';\" +\n+        \"/** @type number */var a = goog.foo;\",\n+        \"initializing variable\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testVar6() throws Exception {\n+    testTypes(\n+        \"function f() {\" +\n+        \"  return function() {\" +\n+        \"    /** @type {!Date} */\" +\n+        \"    var a = 7;\" +\n+        \"  };\" +\n+        \"}\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: Date\");\n+  }\n+\n+  public void testVar7() throws Exception {\n+    testTypes(\"/** @type number */var a, b;\",\n+        \"declaration of multiple variables with shared type information\");\n+  }\n+\n+  public void testVar8() throws Exception {\n+    testTypes(\"var a, b;\");\n+  }\n+\n+  public void testVar9() throws Exception {\n+    testTypes(\"/** @enum */var a;\",\n+        \"enum initializer must be an object literal or an enum\");\n+  }\n+\n+  public void testVar10() throws Exception {\n+    testTypes(\"/** @type !Number */var foo = 'abc';\",\n+        \"initializing variable\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: Number\");\n+  }\n+\n+  public void testVar11() throws Exception {\n+    testTypes(\"var /** @type !Date */foo = 'abc';\",\n+        \"initializing variable\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: Date\");\n+  }\n+\n+  public void testVar12() throws Exception {\n+    testTypes(\"var /** @type !Date */foo = 'abc', \" +\n+        \"/** @type !RegExp */bar = 5;\",\n+        new String[] {\n+        \"initializing variable\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: Date\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: RegExp\"});\n+  }\n+\n+  public void testVar13() throws Exception {\n+    // this caused an NPE\n+    testTypes(\"var /** @type number */a,a;\");\n+  }\n+\n+  public void testVar14() throws Exception {\n+    testTypes(\"/** @return {number} */ function f() { var x; return x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testVar15() throws Exception {\n+    testTypes(\"/** @return {number} */\" +\n+        \"function f() { var x = x || {}; return x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : {...}\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAssign1() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @type number */goog.foo = 'hello';\",\n+        \"assignment to property foo of goog\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAssign2() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @type number */goog.foo = 3;\" +\n+        \"goog.foo = 'hello';\",\n+        \"assignment to property foo of goog\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAssign3() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @type number */goog.foo = 3;\" +\n+        \"goog.foo = 4;\");\n+  }\n+\n+  public void testAssign4() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"goog.foo = 3;\" +\n+        \"goog.foo = 'hello';\");\n+  }\n+\n+  public void testAssignInference() throws Exception {\n+    testTypes(\n+        \"/**\" +\n+        \" * @param {Array} x\" +\n+        \" * @return {number}\" +\n+        \" */\" +\n+        \"function f(x) {\" +\n+        \"  var y = null;\" +\n+        \"  y = x[0];\" +\n+        \"  if (y == null) { return 4; } else { return 6; }\" +\n+        \"}\");\n+  }\n+\n+  public void testOr1() throws Exception {\n+    testTypes(\"/** @type number */var a;\" +\n+        \"/** @type number */var b;\" +\n+        \"a + b || undefined;\");\n+  }\n+\n+  public void testOr2() throws Exception {\n+    testTypes(\"/** @type number */var a;\" +\n+        \"/** @type number */var b;\" +\n+        \"/** @type number */var c = a + b || undefined;\",\n+        \"initializing variable\\n\" +\n+        \"found   : (number|undefined)\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testOr3() throws Exception {\n+    testTypes(\"/** @type {(number, undefined)} */var a;\" +\n+        \"/** @type number */var c = a || 3;\");\n+  }\n+\n+  /**\n+   * Test that type inference continues with the right side,\n+   * when no short-circuiting is possible.\n+   * See bugid 1205387 for more details.\n+   */\n+  public void testOr4() throws Exception {\n+     testTypes(\"/**@type {number} */var x;x=null || \\\"a\\\";\",\n+         \"assignment\\n\" +\n+         \"found   : string\\n\" +\n+         \"required: number\");\n+  }\n+\n+  /**\n+   * @see #testOr4()\n+   */\n+  public void testOr5() throws Exception {\n+     testTypes(\"/**@type {number} */var x;x=undefined || \\\"a\\\";\",\n+         \"assignment\\n\" +\n+         \"found   : string\\n\" +\n+         \"required: number\");\n+  }\n+\n+  public void testAnd1() throws Exception {\n+    testTypes(\"/** @type number */var a;\" +\n+        \"/** @type number */var b;\" +\n+        \"a + b && undefined;\");\n+  }\n+\n+  public void testAnd2() throws Exception {\n+    testTypes(\"/** @type number */var a;\" +\n+        \"/** @type number */var b;\" +\n+        \"/** @type number */var c = a + b && undefined;\",\n+        \"initializing variable\\n\" +\n+        \"found   : (number|undefined)\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAnd3() throws Exception {\n+    testTypes(\"/** @type {(!Array, undefined)} */var a;\" +\n+        \"/** @type number */var c = a && undefined;\",\n+        \"initializing variable\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testAnd4() throws Exception {\n+    testTypes(\"/** @param {number} x */function f(x){};\\n\" +\n+        \"/** @type null */var x; /** @type {number?} */var y;\\n\" +\n+        \"if (x && y) { f(y) }\");\n+  }\n+\n+  public void testAnd5() throws Exception {\n+    testTypes(\"/** @param {number} x\\n@param {string} y*/function f(x,y){};\\n\" +\n+        \"/** @type {number?} */var x; /** @type {string?} */var y;\\n\" +\n+        \"if (x && y) { f(x, y) }\");\n+  }\n+\n+  public void testAnd6() throws Exception {\n+    testTypes(\"/** @param {number} x */function f(x){};\\n\" +\n+        \"/** @type {number|undefined} */var x;\\n\" +\n+        \"if (x && f(x)) { f(x) }\");\n+  }\n+\n+  public void testAnd7() throws Exception {\n+    // TODO(user): a deterministic warning should be generated for this\n+    // case since x && x is always false. The implementation of this requires\n+    // a more precise handling of a null value within a variable's type.\n+    // Currently, a null value defaults to ? which passes every check.\n+    testTypes(\"/** @type null */var x; if (x && x) {}\");\n+  }\n+\n+  public void testHook() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){ var x=foo()?a:b; }\");\n+  }\n+\n+  public void testHookRestrictsType1() throws Exception {\n+    testTypes(\"/** @return {(string,null)} */\" +\n+        \"function f() { return null;}\" +\n+        \"/** @type {(string,null)} */ var a = f();\" +\n+        \"/** @type string */\" +\n+        \"var b = a ? a : 'default';\");\n+  }\n+\n+  public void testHookRestrictsType2() throws Exception {\n+    testTypes(\"/** @type {String} */\" +\n+        \"var a = null;\" +\n+        \"/** @type null */\" +\n+        \"var b = a ? null : a;\");\n+  }\n+\n+  public void testHookRestrictsType3() throws Exception {\n+    testTypes(\"/** @type {String} */\" +\n+        \"var a;\" +\n+        \"/** @type null */\" +\n+        \"var b = (!a) ? a : null;\");\n+  }\n+\n+  public void testHookRestrictsType4() throws Exception {\n+    testTypes(\"/** @type {(boolean,undefined)} */\" +\n+        \"var a;\" +\n+        \"/** @type boolean */\" +\n+        \"var b = a != null ? a : true;\");\n+  }\n+\n+  public void testHookRestrictsType5() throws Exception {\n+    testTypes(\"/** @type {(boolean,undefined)} */\" +\n+        \"var a;\" +\n+        \"/** @type {(undefined)} */\" +\n+        \"var b = a == null ? a : undefined;\");\n+  }\n+\n+  public void testHookRestrictsType6() throws Exception {\n+    testTypes(\"/** @type {(number,null,undefined)} */\" +\n+        \"var a;\" +\n+        \"/** @type {number} */\" +\n+        \"var b = a == null ? 5 : a;\");\n+  }\n+\n+  public void testHookRestrictsType7() throws Exception {\n+    testTypes(\"/** @type {(number,null,undefined)} */\" +\n+        \"var a;\" +\n+        \"/** @type {number} */\" +\n+        \"var b = a == undefined ? 5 : a;\");\n+  }\n+\n+  public void testWhileRestrictsType1() throws Exception {\n+    testTypes(\"/** @param {null} x */ function g(x) {}\" +\n+        \"/** @param {number?} x */\\n\" +\n+        \"function f(x) {\\n\" +\n+        \"while (x) {\\n\" +\n+        \"if (g(x)) { x = 1; }\\n\" +\n+        \"x = x-1;\\n}\\n}\",\n+        \"actual parameter 1 of g does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: null\");\n+  }\n+\n+  public void testWhileRestrictsType2() throws Exception {\n+    testTypes(\"/** @param {number?} x\\n@return {number}*/\\n\" +\n+        \"function f(x) {\\n/** @type {number} */var y = 0;\" +\n+        \"while (x) {\\n\" +\n+        \"y = x;\\n\" +\n+        \"x = x-1;\\n}\\n\" +\n+        \"return y;}\");\n+  }\n+\n+  public void testHigherOrderFunctions1() throws Exception {\n+    testTypes(\n+        \"/** @type {function(number)} */var f;\" +\n+        \"f(true);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testHigherOrderFunctions2() throws Exception {\n+    testTypes(\n+        \"/** @type {function():!Date} */var f;\" +\n+        \"/** @type boolean */var a = f();\",\n+        \"initializing variable\\n\" +\n+        \"found   : Date\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testHigherOrderFunctions3() throws Exception {\n+    testTypes(\n+        \"/** @type {function(this:Error):Date} */var f; new f\",\n+        \"cannot instantiate non-constructor\");\n+  }\n+\n+  public void testHigherOrderFunctions4() throws Exception {\n+    testTypes(\n+        \"/** @type {function(this:Error,...[number]):Date} */var f; new f\",\n+        \"cannot instantiate non-constructor\");\n+  }\n+\n+  public void testConstructorAlias1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {};\" +\n+        \"/** @type {number} */ Foo.prototype.bar = 3;\" +\n+        \"/** @constructor */ var FooAlias = Foo;\" +\n+        \"/** @return {string} */ function foo() { \" +\n+        \"  return (new FooAlias()).bar; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testConstructorAlias2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {};\" +\n+        \"/** @constructor */ var FooAlias = Foo;\" +\n+        \"/** @type {number} */ FooAlias.prototype.bar = 3;\" +\n+        \"/** @return {string} */ function foo() { \" +\n+        \"  return (new Foo()).bar; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testConstructorAlias3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {};\" +\n+        \"/** @type {number} */ Foo.prototype.bar = 3;\" +\n+        \"var FooAlias = Foo;\" +\n+        \"/** @return {string} */ function foo() { \" +\n+        \"  return (new FooAlias()).bar; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testConstructorAlias4() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {};\" +\n+        \"var FooAlias = Foo;\" +\n+        \"/** @type {number} */ FooAlias.prototype.bar = 3;\" +\n+        \"/** @return {string} */ function foo() { \" +\n+        \"  return (new Foo()).bar; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testConstructorAlias5() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {};\" +\n+        \"/** @constructor */ var FooAlias = Foo;\" +\n+        \"/** @return {FooAlias} */ function foo() { \" +\n+        \"  return new Foo(); }\");\n+  }\n+\n+  public void testConstructorAlias6() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {};\" +\n+        \"/** @constructor */ var FooAlias = Foo;\" +\n+        \"/** @return {Foo} */ function foo() { \" +\n+        \"  return new FooAlias(); }\");\n+  }\n+\n+  public void testConstructorAlias7() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @constructor */ goog.Foo = function() {};\" +\n+        \"/** @constructor */ goog.FooAlias = goog.Foo;\" +\n+        \"/** @return {number} */ function foo() { \" +\n+        \"  return new goog.FooAlias(); }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : goog.Foo\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testConstructorAlias8() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/**\\n * @param {number} x \\n * @constructor */ goog.Foo = function(x) {};\" +\n+        \"/**\\n * @param {number} x \\n * @constructor */ goog.FooAlias = goog.Foo;\" +\n+        \"/** @return {number} */ function foo() { \" +\n+        \"  return new goog.FooAlias(1); }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : goog.Foo\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testConstructorAlias9() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/**\\n * @param {number} x \\n * @constructor */ goog.Foo = function(x) {};\" +\n+        \"/** @constructor */ goog.FooAlias = goog.Foo;\" +\n+        \"/** @return {number} */ function foo() { \" +\n+        \"  return new goog.FooAlias(1); }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : goog.Foo\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testConstructorAlias10() throws Exception {\n+    testTypes(\n+        \"/**\\n * @param {number} x \\n * @constructor */ var Foo = function(x) {};\" +\n+        \"/** @constructor */ var FooAlias = Foo;\" +\n+        \"/** @return {number} */ function foo() { \" +\n+        \"  return new FooAlias(1); }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : Foo\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testClosure1() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {string|undefined} */var a;\" +\n+        \"/** @type string */\" +\n+        \"var b = goog.isDef(a) ? a : 'default';\",\n+        null);\n+  }\n+\n+  public void testClosure2() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {string?} */var a;\" +\n+        \"/** @type string */\" +\n+        \"var b = goog.isNull(a) ? 'default' : a;\",\n+        null);\n+  }\n+\n+  public void testClosure3() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {string|null|undefined} */var a;\" +\n+        \"/** @type string */\" +\n+        \"var b = goog.isDefAndNotNull(a) ? a : 'default';\",\n+        null);\n+  }\n+\n+  public void testClosure4() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {string|undefined} */var a;\" +\n+        \"/** @type string */\" +\n+        \"var b = !goog.isDef(a) ? 'default' : a;\",\n+        null);\n+  }\n+\n+  public void testClosure5() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {string?} */var a;\" +\n+        \"/** @type string */\" +\n+        \"var b = !goog.isNull(a) ? a : 'default';\",\n+        null);\n+  }\n+\n+  public void testClosure6() throws Exception {\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"/** @type {string|null|undefined} */var a;\" +\n+        \"/** @type string */\" +\n+        \"var b = !goog.isDefAndNotNull(a) ? 'default' : a;\",\n+        null);\n+  }\n+\n+  public void testReturn1() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){ return 3; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: undefined\");\n+  }\n+\n+  public void testReturn2() throws Exception {\n+    testTypes(\"/**@return {!Number}*/function foo(){ return; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : undefined\\n\" +\n+        \"required: Number\");\n+  }\n+\n+  public void testReturn3() throws Exception {\n+    testTypes(\"/**@return {!Number}*/function foo(){ return 'abc'; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: Number\");\n+  }\n+\n+  public void testReturn4() throws Exception {\n+    testTypes(\"/**@return {!Number}\\n*/\\n function a(){return new Array();}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : Array\\n\" +\n+        \"required: Number\");\n+  }\n+\n+  public void testReturn5() throws Exception {\n+    testTypes(\"/** @param {number} n\\n\" +\n+        \"@constructor */function n(n){return};\");\n+  }\n+\n+  public void testReturn6() throws Exception {\n+    testTypes(\n+        \"/** @param {number} opt_a\\n@return string */\" +\n+        \"function a(opt_a) { return opt_a }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|undefined)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testReturn7() throws Exception {\n+    testTypes(\"/** @constructor */var A = function() {};\\n\" +\n+        \"/** @constructor */var B = function() {};\\n\" +\n+        \"/** @return {!B} */A.f = function() { return 1; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: B\");\n+  }\n+\n+  public void testReturn8() throws Exception {\n+    testTypes(\"/** @constructor */var A = function() {};\\n\" +\n+        \"/** @constructor */var B = function() {};\\n\" +\n+        \"/** @return {!B} */A.prototype.f = function() { return 1; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: B\");\n+  }\n+\n+  public void testThis1() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @constructor */goog.A = function(){};\" +\n+        \"/** @return number */goog.A.prototype.n = function() { return this };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : goog.A\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testThis2() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @constructor */goog.A = function(){\" +\n+        \"  this.foo = null;\" +\n+        \"};\" +\n+        \"/** @return number */\" +\n+        \"goog.A.prototype.n = function() { return this.foo };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testThis3() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @constructor */goog.A = function(){\" +\n+        \"  this.foo = null;\" +\n+        \"  this.foo = 5;\" +\n+        \"};\");\n+  }\n+\n+  public void testThis4() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @constructor */goog.A = function(){\" +\n+        \"  /** @type {string?} */this.foo = null;\" +\n+        \"};\" +\n+        \"/** @return number */goog.A.prototype.n = function() {\" +\n+        \"  return this.foo };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (null|string)\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testThis5() throws Exception {\n+    testTypes(\"/** @this Date\\n@return number*/function h() { return this }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : Date\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testThis6() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @constructor\\n@return !Date */\" +\n+        \"goog.A = function(){ return this };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : goog.A\\n\" +\n+        \"required: Date\");\n+  }\n+\n+  public void testThis7() throws Exception {\n+    testTypes(\"/** @constructor */function A(){};\" +\n+        \"/** @return number */A.prototype.n = function() { return this };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : A\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testThis8() throws Exception {\n+    testTypes(\"/** @constructor */function A(){\" +\n+        \"  /** @type {string?} */this.foo = null;\" +\n+        \"};\" +\n+        \"/** @return number */A.prototype.n = function() {\" +\n+        \"  return this.foo };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (null|string)\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testThis9() throws Exception {\n+    // In A.bar, the type of {@code this} is unknown.\n+    testTypes(\"/** @constructor */function A(){};\" +\n+        \"A.prototype.foo = 3;\" +\n+        \"/** @return {string} */ A.bar = function() { return this.foo; };\");\n+  }\n+\n+  public void testThis10() throws Exception {\n+    // In A.bar, the type of {@code this} is inferred from the @this tag.\n+    testTypes(\"/** @constructor */function A(){};\" +\n+        \"A.prototype.foo = 3;\" +\n+        \"/** @this {A}\\n@return {string} */\" +\n+        \"A.bar = function() { return this.foo; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testGlobalThis1() throws Exception {\n+    testTypes(\"/** @constructor */ function Window() {}\" +\n+        \"/** @param {string} msg */ \" +\n+        \"Window.prototype.alert = function(msg) {};\" +\n+        \"this.alert(3);\",\n+        \"actual parameter 1 of Window.prototype.alert \" +\n+        \"does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testGlobalThis2() throws Exception {\n+    testTypes(\"/** @constructor */ function Bindow() {}\" +\n+        \"/** @param {string} msg */ \" +\n+        \"Bindow.prototype.alert = function(msg) {};\" +\n+        \"this.alert = 3;\" +\n+        \"(new Bindow()).alert(this.alert)\",\n+        \"actual parameter 1 of Bindow.prototype.alert \" +\n+        \"does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testGlobalThis3() throws Exception {\n+    testTypes(\n+        \"/** @param {string} msg */ \" +\n+        \"function alert(msg) {};\" +\n+        \"this.alert(3);\",\n+        \"actual parameter 1 of this.alert \" +\n+        \"does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testGlobalThis4() throws Exception {\n+    testTypes(\n+        \"/** @param {string} msg */ \" +\n+        \"var alert = function(msg) {};\" +\n+        \"this.alert(3);\",\n+        \"actual parameter 1 of this.alert \" +\n+        \"does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testGlobalThis5() throws Exception {\n+    testTypes(\n+        \"function f() {\" +\n+        \"  /** @param {string} msg */ \" +\n+        \"  var alert = function(msg) {};\" +\n+        \"}\" +\n+        \"this.alert(3);\",\n+        \"Property alert never defined on this\");\n+  }\n+\n+  public void testGlobalThis6() throws Exception {\n+    testTypes(\n+        \"/** @param {string} msg */ \" +\n+        \"var alert = function(msg) {};\" +\n+        \"var x = 3;\" +\n+        \"x = 'msg';\" +\n+        \"this.alert(this.x);\");\n+  }\n+\n+  public void testControlFlowRestrictsType1() throws Exception {\n+    testTypes(\"/** @return {String?} */ function f() { return null; }\" +\n+        \"/** @type {String?} */ var a = f();\" +\n+        \"/** @type String */ var b = new String('foo');\" +\n+        \"/** @type null */ var c = null;\" +\n+        \"if (a) {\" +\n+        \"  b = a;\" +\n+        \"} else {\" +\n+        \"  c = a;\" +\n+        \"}\");\n+  }\n+\n+  public void testControlFlowRestrictsType2() throws Exception {\n+    testTypes(\"/** @return {(string,null)} */ function f() { return null; }\" +\n+        \"/** @type {(string,null)} */ var a = f();\" +\n+        \"/** @type string */ var b = 'foo';\" +\n+        \"/** @type null */ var c = null;\" +\n+        \"if (a) {\" +\n+        \"  b = a;\" +\n+        \"} else {\" +\n+        \"  c = a;\" +\n+        \"}\",\n+        \"assignment\\n\" +\n+        \"found   : (null|string)\\n\" +\n+        \"required: null\");\n+  }\n+\n+  public void testControlFlowRestrictsType3() throws Exception {\n+    testTypes(\"/** @type {(string,void)} */\" +\n+        \"var a;\" +\n+        \"/** @type string */\" +\n+        \"var b = 'foo';\" +\n+        \"if (a) {\" +\n+        \"  b = a;\" +\n+        \"}\");\n+  }\n+\n+  public void testControlFlowRestrictsType4() throws Exception {\n+    testTypes(\"/** @param {string} a */ function f(a){}\" +\n+        \"/** @type {(string,undefined)} */ var a;\" +\n+        \"a && f(a);\");\n+  }\n+\n+  public void testControlFlowRestrictsType5() throws Exception {\n+    testTypes(\"/** @param {undefined} a */ function f(a){}\" +\n+        \"/** @type {(!Array,undefined)} */ var a;\" +\n+        \"a || f(a);\");\n+  }\n+\n+  public void testControlFlowRestrictsType6() throws Exception {\n+    testTypes(\"/** @param {undefined} x */ function f(x) {}\" +\n+        \"/** @type {(string,undefined)} */ var a;\" +\n+        \"a && f(a);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: undefined\");\n+  }\n+\n+  public void testControlFlowRestrictsType7() throws Exception {\n+    testTypes(\"/** @param {undefined} x */ function f(x) {}\" +\n+        \"/** @type {(string,undefined)} */ var a;\" +\n+        \"a && f(a);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: undefined\");\n+  }\n+\n+  public void testControlFlowRestrictsType8() throws Exception {\n+    testTypes(\"/** @param {undefined} a */ function f(a){}\" +\n+        \"/** @type {(!Array,undefined)} */ var a;\" +\n+        \"if (a || f(a)) {}\");\n+  }\n+\n+  public void testControlFlowRestrictsType9() throws Exception {\n+    testTypes(\"/** @param {number?} x\\n * @return {number}*/\\n\" +\n+        \"var f = function(x) {\\n\" +\n+        \"if (!x || x == 1) { return 1; } else { return x; }\\n\" +\n+        \"};\");\n+  }\n+\n+  public void testSwitchCase3() throws Exception {\n+    testTypes(\"/** @type String */\" +\n+        \"var a = new String('foo');\" +\n+        \"switch (a) { case 'A': }\");\n+  }\n+\n+  public void testSwitchCase4() throws Exception {\n+    testTypes(\"/** @type {(string,Null)} */\" +\n+        \"var a = 'foo';\" +\n+        \"switch (a) { case 'A':break; case null:break; }\");\n+  }\n+\n+  public void testSwitchCase5() throws Exception {\n+    testTypes(\"/** @type {(String,Null)} */\" +\n+        \"var a = new String('foo');\" +\n+        \"switch (a) { case 'A':break; case null:break; }\");\n+  }\n+\n+  public void testSwitchCase6() throws Exception {\n+    testTypes(\"/** @type {(Number,Null)} */\" +\n+        \"var a = new Number(5);\" +\n+        \"switch (a) { case 5:break; case null:break; }\");\n+  }\n+\n+  public void testNoTypeCheck1() throws Exception {\n+    testTypes(\"/** @notypecheck */function foo() { new 4 }\");\n+  }\n+\n+  public void testNoTypeCheck2() throws Exception {\n+    testTypes(\"/** @notypecheck */var foo = function() { new 4 }\");\n+  }\n+\n+  public void testNoTypeCheck3() throws Exception {\n+    testTypes(\"/** @notypecheck */var foo = function bar() { new 4 }\");\n+  }\n+\n+  public void testNoTypeCheck4() throws Exception {\n+    testTypes(\"var foo;\" +\n+        \"/** @notypecheck */foo = function() { new 4 }\");\n+  }\n+\n+  public void testNoTypeCheck5() throws Exception {\n+    testTypes(\"var foo;\" +\n+        \"foo = /** @notypecheck */function() { new 4 }\");\n+  }\n+\n+  public void testNoTypeCheck6() throws Exception {\n+    testTypes(\"var foo;\" +\n+        \"/** @notypecheck */foo = function bar() { new 4 }\");\n+  }\n+\n+  public void testNoTypeCheck7() throws Exception {\n+    testTypes(\"var foo;\" +\n+        \"foo = /** @notypecheck */function bar() { new 4 }\");\n+  }\n+\n+  public void testNoTypeCheck8() throws Exception {\n+    testTypes(\"/** @fileoverview \\n * @notypecheck */ var foo;\" +\n+        \"var bar = 3; /** @param {string} x */ function f(x) {} f(bar);\");\n+  }\n+\n+  public void testImplicitCast() throws Exception {\n+    testTypes(\"/** @constructor */ function Element() {};\\n\" +\n+             \"/** @type {string}\\n\" +\n+             \"  * @implicitCast */\" +\n+             \"Element.prototype.innerHTML;\",\n+             \"(new Element).innerHTML = new Array();\", null, false);\n+  }\n+\n+  public void testImplicitCastSubclassAccess() throws Exception {\n+    testTypes(\"/** @constructor */ function Element() {};\\n\" +\n+             \"/** @type {string}\\n\" +\n+             \"  * @implicitCast */\" +\n+             \"Element.prototype.innerHTML;\" +\n+             \"/** @constructor \\n @extends Element */\" +\n+             \"function DIVElement() {};\",\n+             \"(new DIVElement).innerHTML = new Array();\", null, false);\n+  }\n+\n+  public void testImplicitCastNotInExterns() throws Exception {\n+    testTypes(\"/** @constructor */ function Element() {};\\n\" +\n+             \"/** @type {string}\\n\" +\n+             \"  * @implicitCast */\" +\n+             \"Element.prototype.innerHTML;\" +\n+             \"(new Element).innerHTML = new Array();\",\n+             new String[] {\n+               \"Illegal annotation on innerHTML. @implicitCast may only be \" +\n+               \"used in externs.\",\n+               \"assignment to property innerHTML of Element\\n\" +\n+               \"found   : Array\\n\" +\n+               \"required: string\"});\n+  }\n+\n+  public void testNumberNode() throws Exception {\n+    Node n = typeCheck(Node.newNumber(0));\n+\n+    assertEquals(NUMBER_TYPE, n.getJSType());\n+  }\n+\n+  public void testStringNode() throws Exception {\n+    Node n = typeCheck(Node.newString(\"hello\"));\n+\n+    assertEquals(STRING_TYPE, n.getJSType());\n+  }\n+\n+  public void testBooleanNodeTrue() throws Exception {\n+    Node trueNode = typeCheck(new Node(Token.TRUE));\n+\n+    assertEquals(BOOLEAN_TYPE, trueNode.getJSType());\n+  }\n+\n+  public void testBooleanNodeFalse() throws Exception {\n+    Node falseNode = typeCheck(new Node(Token.FALSE));\n+\n+    assertEquals(BOOLEAN_TYPE, falseNode.getJSType());\n+  }\n+\n+  public void testUndefinedNode() throws Exception {\n+    Node p = new Node(Token.ADD);\n+    Node n = Node.newString(Token.NAME, \"undefined\");\n+    p.addChildToBack(n);\n+    p.addChildToBack(Node.newNumber(5));\n+    typeCheck(p);\n+\n+    assertEquals(VOID_TYPE, n.getJSType());\n+  }\n+\n+  public void testNumberAutoboxing() throws Exception {\n+    testTypes(\"/** @type Number */var a = 4;\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: (Number|null)\");\n+  }\n+\n+  public void testNumberUnboxing() throws Exception {\n+    testTypes(\"/** @type number */var a = new Number(4);\",\n+        \"initializing variable\\n\" +\n+        \"found   : Number\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testStringAutoboxing() throws Exception {\n+    testTypes(\"/** @type String */var a = 'hello';\",\n+        \"initializing variable\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: (String|null)\");\n+  }\n+\n+  public void testStringUnboxing() throws Exception {\n+    testTypes(\"/** @type string */var a = new String('hello');\",\n+        \"initializing variable\\n\" +\n+        \"found   : String\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBooleanAutoboxing() throws Exception {\n+    testTypes(\"/** @type Boolean */var a = true;\",\n+        \"initializing variable\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: (Boolean|null)\");\n+  }\n+\n+  public void testBooleanUnboxing() throws Exception {\n+    testTypes(\"/** @type boolean */var a = new Boolean(false);\",\n+        \"initializing variable\\n\" +\n+        \"found   : Boolean\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  /**\n+   * Tests that the || operator is type checked correctly, that is of\n+   * the type of the first argument or of the second argument. See\n+   * bugid 592170 for more details.\n+   */\n+  public void testBug592170() throws Exception {\n+    testTypes(\n+        \"/** @param {Function} opt_f ... */\" +\n+        \"function foo(opt_f) {\" +\n+        \"  /** @type {Function} */\" +\n+        \"  return opt_f || function () {};\" +\n+        \"}\");\n+  }\n+\n+  /**\n+   * Tests that undefined can be compared shallowly to a value of type\n+   * (number,undefined) regardless of the side on which the undefined\n+   * value is.\n+   */\n+  public void testBug901455() throws Exception {\n+    testTypes(\"/** @return {(number,undefined)} */ function a() { return 3; }\" +\n+        \"var b = undefined === a()\");\n+    testTypes(\"/** @return {(number,undefined)} */ function a() { return 3; }\" +\n+        \"var b = a() === undefined\");\n+  }\n+\n+  /**\n+   * Tests that the match method of strings returns nullable arrays.\n+   */\n+  public void testBug908701() throws Exception {\n+    testTypes(\"/** @type {String} */var s = new String('foo');\" +\n+        \"var b = s.match(/a/) != null;\");\n+  }\n+\n+  /**\n+   * Tests that named types play nicely with subtyping.\n+   */\n+  public void testBug908625() throws Exception {\n+    testTypes(\"/** @constructor */function A(){}\" +\n+        \"/** @constructor\\n * @extends A */function B(){}\" +\n+        \"/** @param {B} b\" +\n+        \"\\n @return {(A,undefined)} */function foo(b){return b}\");\n+  }\n+\n+  /**\n+   * Tests that assigning two untyped functions to a variable whose type is\n+   * inferred and calling this variable is legal.\n+   */\n+  public void testBug911118() throws Exception {\n+    // verifying the type assigned to anonymous functions assigned variables\n+    Scope s = parseAndTypeCheckWithScope(\"var a = function(){};\").second;\n+    JSType type = s.getVar(\"a\").getType();\n+    assertEquals(\"function (): ?\", type.toString());\n+\n+    // verifying the bug example\n+    testTypes(\"function nullFunction() {};\" +\n+        \"var foo = nullFunction;\" +\n+        \"foo = function() {};\" +\n+        \"foo();\");\n+  }\n+\n+  public void testBug909000() throws Exception {\n+    testTypes(\"/** @constructor */function A(){}\\n\" +\n+        \"/** @param {!A} a\\n\" +\n+        \"@return boolean*/\\n\" +\n+        \"function y(a) { return a }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : A\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testBug930117() throws Exception {\n+    testTypes(\n+        \"/** @param {boolean} x */function f(x){}\" +\n+        \"f(null);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testBug1484445() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @type {number?} */ Foo.prototype.bar = null;\" +\n+        \"/** @type {number?} */ Foo.prototype.baz = null;\" +\n+        \"/** @param {Foo} foo */\" +\n+        \"function f(foo) {\" +\n+        \"  while (true) {\" +\n+        \"    if (foo.bar == null && foo.baz == null) {\" +\n+        \"      foo.bar;\" +\n+        \"    }\" +\n+        \"  }\" +\n+        \"}\");\n+  }\n+\n+  public void testBug1859535() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {Function} childCtor Child class.\\n\" +\n+        \" * @param {Function} parentCtor Parent class.\\n\" +\n+        \" */\" +\n+        \"var inherits = function(childCtor, parentCtor) {\" +\n+        \"  /** @constructor */\" +\n+        \"  function tempCtor() {};\" +\n+        \"  tempCtor.prototype = parentCtor.prototype;\" +\n+        \"  childCtor.superClass_ = parentCtor.prototype;\" +\n+        \"  childCtor.prototype = new tempCtor();\" +\n+        \"  /** @override */ childCtor.prototype.constructor = childCtor;\" +\n+        \"};\" +\n+        \"/**\" +\n+        \" * @param {Function} constructor\\n\" +\n+        \" * @param {Object} var_args\\n\" +\n+        \" * @return {Object}\\n\" +\n+        \" */\" +\n+        \"var factory = function(constructor, var_args) {\" +\n+        \"  /** @constructor */\" +\n+        \"  var tempCtor = function() {};\" +\n+        \"  tempCtor.prototype = constructor.prototype;\" +\n+        \"  var obj = new tempCtor();\" +\n+        \"  constructor.apply(obj, arguments);\" +\n+        \"  return obj;\" +\n+        \"};\");\n+  }\n+\n+  public void testBug1940591() throws Exception {\n+    testTypes(\n+        \"/** @type {Object} */\" +\n+        \"var a = {};\\n\" +\n+        \"/** @type {number} */\\n\" +\n+        \"a.name = 0;\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {Function} x anything.\\n\" +\n+        \" */\\n\" +\n+        \"a.g = function(x) { x.name = 'a'; }\");\n+  }\n+\n+  public void testBug1942972() throws Exception {\n+    testTypes(\n+        \"var google = {\\n\"+\n+        \"  gears: {\\n\" +\n+        \"    factory: {},\\n\" +\n+        \"    workerPool: {}\\n\" +\n+        \"  }\\n\" +\n+        \"};\\n\" +\n+        \"\\n\" +\n+        \"google.gears = {factory: {}};\\n\");\n+  }\n+\n+  public void testBug1943776() throws Exception {\n+    testTypes(\n+        \"/** @return  {{foo: Array}} */\" +\n+        \"function bar() {\" +\n+        \"  return {foo: []};\" +\n+        \"}\");\n+  }\n+\n+  public void testBug1987544() throws Exception {\n+    testTypes(\n+        \"/** @param {string} x */ function foo(x) {}\" +\n+        \"var duration;\" +\n+        \"if (true && !(duration = 3)) {\" +\n+        \" foo(duration);\" +\n+        \"}\",\n+        \"actual parameter 1 of foo does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBug1940769() throws Exception {\n+    testTypes(\n+        \"/** @return {!Object} */ \" +\n+        \"function proto(obj) { return obj.prototype; }\" +\n+        \"/** @constructor */ function Map() {}\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Map}\\n\" +\n+        \" */\" +\n+        \"function Map2() { Map.call(this); };\" +\n+        \"Map2.prototype = proto(Map);\");\n+  }\n+\n+  public void testBug2335992() throws Exception {\n+    testTypes(\n+        \"/** @return {*} */ function f() { return 3; }\" +\n+        \"var x = f();\" +\n+        \"/** @type {string} */\" +\n+        \"x.y = 3;\",\n+        \"assignment to property y of x\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testScopedConstructors() throws Exception {\n+    testTypes(\n+        \"function foo1() { \" +\n+        \"  /** @constructor */ function Bar() { \" +\n+        \"    /** @type {number} */ this.x = 3;\" +\n+        \"  }\" +\n+        \"}\" +\n+        \"function foo2() { \" +\n+        \"  /** @constructor */ function Bar() { \" +\n+        \"    /** @type {string} */ this.x = 'y';\" +\n+        \"  }\" +\n+        \"  /** \" +\n+        \"   * @param {Bar} b\\n\" +\n+        \"   * @return {number}\\n\" +\n+        \"   */\" +\n+        \"  function baz(b) { return b.x; }\" +\n+        \"}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testQualifiedNameInference1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @type {number?} */ Foo.prototype.bar = null;\" +\n+        \"/** @type {number?} */ Foo.prototype.baz = null;\" +\n+        \"/** @param {Foo} foo */\" +\n+        \"function f(foo) {\" +\n+        \"  while (true) {\" +\n+        \"    if (!foo.baz) break; \" +\n+        \"    foo.bar = null;\" +\n+        \"  }\" +\n+        // Tests a bug where this condition always evaluated to true.\n+        \"  return foo.bar == null;\" +\n+        \"}\");\n+  }\n+\n+  public void testQualifiedNameInference2() throws Exception {\n+    testTypes(\n+        \"var x = {};\" +\n+        \"x.y = c;\" +\n+        \"function f(a, b) {\" +\n+        \"  if (a) {\" +\n+        \"    if (b) \" +\n+        \"      x.y = 2;\" +\n+        \"    else \" +\n+        \"      x.y = 1;\" +\n+        \"  }\" +\n+        \"  return x.y == null;\" +\n+        \"}\");\n+  }\n+\n+  public void testQualifiedNameInference3() throws Exception {\n+    testTypes(\n+        \"var x = {};\" +\n+        \"x.y = c;\" +\n+        \"function f(a, b) {\" +\n+        \"  if (a) {\" +\n+        \"    if (b) \" +\n+        \"      x.y = 2;\" +\n+        \"    else \" +\n+        \"      x.y = 1;\" +\n+        \"  }\" +\n+        \"  return x.y == null;\" +\n+        \"} function g() { x.y = null; }\");\n+  }\n+\n+  public void testQualifiedNameInference4() throws Exception {\n+    testTypes(\n+        \"/** @param {string} x */ function f(x) {}\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {?string} x \\n\" +\n+        \" * @constructor\\n\" +\n+        \" */\" +\n+        \"function Foo(x) { this.x_ = x; }\\n\" +\n+        \"Foo.prototype.bar = function() {\" +\n+        \"  if (this.x_) { f(this.x_); }\" +\n+        \"};\");\n+  }\n+\n+  public void testSheqRefinedScope() throws Exception {\n+    Node n = parseAndTypeCheck(\n+        \"/** @constructor */function A() {}\\n\" +\n+        \"/** @constructor \\n @extends A */ function B() {}\\n\" +\n+        \"/** @return number */\\n\" +\n+        \"B.prototype.p = function() { return 1; }\\n\" +\n+        \"/** @param {A} a\\n @param {B} b */\\n\" +\n+        \"function f(a, b) {\\n\" +\n+        \"  b.p();\\n\" +\n+        \"  if (a === b) {\\n\" +\n+        \"    b.p();\\n\" +\n+        \"  }\\n\" +\n+        \"}\");\n+    Node nodeC = n.getLastChild().getLastChild().getLastChild().getLastChild()\n+        .getLastChild().getLastChild();\n+    JSType typeC = nodeC.getJSType();\n+    assertTrue(typeC.isNumber());\n+\n+    Node nodeB = nodeC.getFirstChild().getFirstChild();\n+    JSType typeB = nodeB.getJSType();\n+    assertEquals(\"B\", typeB.toString());\n+  }\n+\n+  public void testAssignToUntypedVariable() throws Exception {\n+    Node n = parseAndTypeCheck(\"var z; z = 1;\");\n+\n+    Node assign = n.getLastChild().getFirstChild();\n+    Node node = assign.getFirstChild();\n+    assertFalse(node.getJSType().isUnknownType());\n+    assertEquals(\"number\", node.getJSType().toString());\n+  }\n+\n+  public void testAssignToUntypedProperty() throws Exception {\n+    Node n = parseAndTypeCheck(\n+        \"/** @constructor */ function Foo() {}\\n\" +\n+        \"Foo.prototype.a = 1;\" +\n+        \"(new Foo).a;\");\n+\n+    Node node = n.getLastChild().getFirstChild();\n+    assertFalse(node.getJSType().isUnknownType());\n+    assertTrue(node.getJSType().isNumber());\n+  }\n+\n+  public void testNew1() throws Exception {\n+    testTypes(\"new 4\", TypeCheck.NOT_A_CONSTRUCTOR);\n+  }\n+\n+  public void testNew2() throws Exception {\n+    testTypes(\"var Math = {}; new Math()\", TypeCheck.NOT_A_CONSTRUCTOR);\n+  }\n+\n+  public void testNew3() throws Exception {\n+    testTypes(\"new Date()\");\n+  }\n+\n+  public void testNew4() throws Exception {\n+    testTypes(\"/** @constructor */function A(){}; new A();\");\n+  }\n+\n+  public void testNew5() throws Exception {\n+    testTypes(\"function A(){}; new A();\", TypeCheck.NOT_A_CONSTRUCTOR);\n+  }\n+\n+  public void testNew6() throws Exception {\n+    Pair<Node, Scope> p =\n+      parseAndTypeCheckWithScope(\"/** @constructor */function A(){};\" +\n+      \"var a = new A();\");\n+\n+    JSType aType = p.getSecond().getVar(\"a\").getType();\n+    assertTrue(aType instanceof ObjectType);\n+    ObjectType aObjectType = (ObjectType) aType;\n+    assertEquals(\"A\", aObjectType.getConstructor().getReferenceName());\n+  }\n+\n+  public void testNew7() throws Exception {\n+    testTypes(\"/** @param {Function} opt_constructor */\" +\n+        \"function foo(opt_constructor) {\" +\n+        \"if (opt_constructor) { new opt_constructor; }\" +\n+        \"}\");\n+  }\n+\n+  public void testNew8() throws Exception {\n+    testTypes(\"/** @param {Function} opt_constructor */\" +\n+        \"function foo(opt_constructor) {\" +\n+        \"new opt_constructor;\" +\n+        \"}\");\n+  }\n+\n+  public void testNew9() throws Exception {\n+    testTypes(\"/** @param {Function} opt_constructor */\" +\n+        \"function foo(opt_constructor) {\" +\n+        \"new (opt_constructor || Array);\" +\n+        \"}\");\n+  }\n+\n+  public void testNew10() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @param {Function} opt_constructor */\" +\n+        \"goog.Foo = function (opt_constructor) {\" +\n+        \"new (opt_constructor || Array);\" +\n+        \"}\");\n+  }\n+\n+  public void testNew11() throws Exception {\n+    testTypes(\"/** @param {Function} c1 */\" +\n+        \"function f(c1) {\" +\n+        \"  var c2 = function(){};\" +\n+        \"  c1.prototype = new c2;\" +\n+        \"}\", TypeCheck.NOT_A_CONSTRUCTOR);\n+  }\n+\n+  public void testNew12() throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\"var a = new Array();\");\n+    Var a = p.second.getVar(\"a\");\n+\n+    assertEquals(ARRAY_TYPE, a.getType());\n+  }\n+\n+  public void testNew13() throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+        \"/** @constructor */function FooBar(){};\" +\n+        \"var a = new FooBar();\");\n+    Var a = p.second.getVar(\"a\");\n+\n+    assertTrue(a.getType() instanceof ObjectType);\n+    assertEquals(\"FooBar\", a.getType().toString());\n+  }\n+\n+  public void testNew14() throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+        \"/** @constructor */var FooBar = function(){};\" +\n+        \"var a = new FooBar();\");\n+    Var a = p.second.getVar(\"a\");\n+\n+    assertTrue(a.getType() instanceof ObjectType);\n+    assertEquals(\"FooBar\", a.getType().toString());\n+  }\n+\n+  public void testNew15() throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+        \"var goog = {};\" +\n+        \"/** @constructor */goog.A = function(){};\" +\n+        \"var a = new goog.A();\");\n+    Var a = p.second.getVar(\"a\");\n+\n+    assertTrue(a.getType() instanceof ObjectType);\n+    assertEquals(\"goog.A\", a.getType().toString());\n+  }\n+\n+  public void testNew16() throws Exception {\n+    testTypes(\n+        \"/** \\n\" +\n+        \" * @param {string} x \\n\" +\n+        \" * @constructor \\n\" +\n+        \" */\" +\n+        \"function Foo(x) {}\" +\n+        \"function g() { new Foo(1); }\",\n+        \"actual parameter 1 of Foo does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testName1() throws Exception {\n+    assertEquals(VOID_TYPE, testNameNode(\"undefined\"));\n+  }\n+\n+  public void testName2() throws Exception {\n+    assertEquals(OBJECT_FUNCTION_TYPE, testNameNode(\"Object\"));\n+  }\n+\n+  public void testName3() throws Exception {\n+    assertEquals(ARRAY_FUNCTION_TYPE, testNameNode(\"Array\"));\n+  }\n+\n+  public void testName4() throws Exception {\n+    assertEquals(DATE_FUNCTION_TYPE, testNameNode(\"Date\"));\n+  }\n+\n+  public void testName5() throws Exception {\n+    assertEquals(REGEXP_FUNCTION_TYPE, testNameNode(\"RegExp\"));\n+  }\n+\n+  /**\n+   * Type checks a NAME node and retrieve its type.\n+   */\n+  private JSType testNameNode(String name) {\n+    Node node = Node.newString(Token.NAME, name);\n+    Node parent = new Node(Token.SCRIPT, node);\n+\n+    Node externs = new Node(Token.BLOCK);\n+    Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n+    externAndJsRoot.setIsSyntheticBlock(true);\n+\n+    makeTypeCheck().processForTesting(null, parent);\n+    return node.getJSType();\n+  }\n+\n+  public void testBitOperation1() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){ ~foo(); }\",\n+        \"operator ~ cannot be applied to undefined\");\n+  }\n+\n+  public void testBitOperation2() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){var a = foo()<<3;}\",\n+        \"operator << cannot be applied to undefined\");\n+  }\n+\n+  public void testBitOperation3() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){var a = 3<<foo();}\",\n+        \"operator << cannot be applied to undefined\");\n+  }\n+\n+  public void testBitOperation4() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){var a = foo()>>>3;}\",\n+        \"operator >>> cannot be applied to undefined\");\n+  }\n+\n+  public void testBitOperation5() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){var a = 3>>>foo();}\",\n+        \"operator >>> cannot be applied to undefined\");\n+  }\n+\n+  public void testBitOperation6() throws Exception {\n+    testTypes(\"/**@return {!Object}*/function foo(){var a = foo()&3;}\",\n+        \"bad left operand to bitwise operator\\n\" +\n+        \"found   : Object\\n\" +\n+        \"required: (boolean|null|number|string|undefined)\");\n+  }\n+\n+  public void testBitOperation7() throws Exception {\n+    testTypes(\"var x = null; x |= undefined; x &= 3; x ^= '3'; x |= true;\");\n+  }\n+\n+  public void testBitOperation8() throws Exception {\n+    testTypes(\"var x = void 0; x |= new Number(3);\");\n+  }\n+\n+  public void testBitOperation9() throws Exception {\n+    testTypes(\"var x = void 0; x |= {};\",\n+        \"bad right operand to bitwise operator\\n\" +\n+        \"found   : {...}\\n\" +\n+        \"required: (boolean|null|number|string|undefined)\");\n+  }\n+\n+  public void testCall1() throws Exception {\n+    testTypes(\"3();\", \"number expressions are not callable\");\n+  }\n+\n+  public void testCall2() throws Exception {\n+    testTypes(\"/** @param {!Number} foo*/function bar(foo){ bar('abc'); }\",\n+        \"actual parameter 1 of bar does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: Number\");\n+  }\n+\n+  public void testCall3() throws Exception {\n+    // We are checking that an unresolved named type can successfully\n+    // meet with a functional type to produce a callable type.\n+    testTypes(\"/** @type {Function|undefined} */var opt_f;\" +\n+        \"/** @type {some.unknown.type} */var f1;\" +\n+        \"var f2 = opt_f || f1;\" +\n+        \"f2();\",\n+        \"Parse error. Unknown type some.unknown.type\");\n+  }\n+\n+  public void testCall4() throws Exception {\n+    testTypes(\"/**@param {!RegExp} a*/var foo = function bar(a){ bar('abc'); }\",\n+        \"actual parameter 1 of bar does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: RegExp\");\n+  }\n+\n+  public void testCall5() throws Exception {\n+    testTypes(\"/**@param {!RegExp} a*/var foo = function bar(a){ foo('abc'); }\",\n+        \"actual parameter 1 of foo does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: RegExp\");\n+  }\n+\n+  public void testCall6() throws Exception {\n+    testTypes(\"/** @param {!Number} foo*/function bar(foo){}\" +\n+        \"bar('abc');\",\n+        \"actual parameter 1 of bar does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: Number\");\n+  }\n+\n+  public void testCall7() throws Exception {\n+    testTypes(\"/** @param {!RegExp} a*/var foo = function bar(a){};\" +\n+        \"foo('abc');\",\n+        \"actual parameter 1 of foo does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: RegExp\");\n+  }\n+\n+  public void testCall8() throws Exception {\n+    testTypes(\"/** @type {Function|number} */var f;f();\",\n+        \"(Function|number) expressions are \" +\n+        \"not callable\");\n+  }\n+\n+  public void testCall9() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @constructor */ goog.Foo = function() {};\" +\n+        \"/** @param {!goog.Foo} a */ var bar = function(a){};\" +\n+        \"bar('abc');\",\n+        \"actual parameter 1 of bar does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: goog.Foo\");\n+  }\n+\n+  public void testCall10() throws Exception {\n+    testTypes(\"/** @type {Function} */var f;f();\");\n+  }\n+\n+  public void testCall11() throws Exception {\n+    testTypes(\"var f = new Function(); f();\");\n+  }\n+\n+  public void testFunctionCall1() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x */ var foo = function(x) {};\" +\n+        \"foo.call(null, 3);\");\n+  }\n+\n+  public void testFunctionCall2() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x */ var foo = function(x) {};\" +\n+        \"foo.call(null, 'bar');\",\n+        \"actual parameter 2 of foo.call does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testFunctionCall3() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x \\n * @constructor */ \" +\n+        \"var Foo = function(x) { this.bar.call(null, x); };\" +\n+        \"/** @type {function(number)} */ Foo.prototype.bar;\");\n+  }\n+\n+  public void testFunctionCall4() throws Exception {\n+    testTypes(\n+        \"/** @param {string} x \\n * @constructor */ \" +\n+        \"var Foo = function(x) { this.bar.call(null, x); };\" +\n+        \"/** @type {function(number)} */ Foo.prototype.bar;\",\n+        \"actual parameter 2 of this.bar.call \" +\n+        \"does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testFunctionCall5() throws Exception {\n+    testTypes(\n+        \"/** @param {Function} handler \\n * @constructor */ \" +\n+        \"var Foo = function(handler) { handler.call(this, x); };\");\n+  }\n+\n+  public void testFunctionCall6() throws Exception {\n+    testTypes(\n+        \"/** @param {Function} handler \\n * @constructor */ \" +\n+        \"var Foo = function(handler) { handler.apply(this, x); };\");\n+  }\n+\n+  public void testFunctionCall7() throws Exception {\n+    testTypes(\n+        \"/** @param {Function} handler \\n * @param {Object} opt_context */ \" +\n+        \"var Foo = function(handler, opt_context) { \" +\n+        \"  handler.call(opt_context, x);\" +\n+        \"};\");\n+  }\n+\n+  public void testFunctionCall8() throws Exception {\n+    testTypes(\n+        \"/** @param {Function} handler \\n * @param {Object} opt_context */ \" +\n+        \"var Foo = function(handler, opt_context) { \" +\n+        \"  handler.apply(opt_context, x);\" +\n+        \"};\");\n+  }\n+\n+  public void testCast2() throws Exception {\n+    // can upcast to a base type.\n+    testTypes(\"/** @constructor */function base() {}\\n\" +\n+        \"/** @constructor\\n @extends {base} */function derived() {}\\n\" +\n+        \"/** @type {base} */ var baz = new derived();\\n\");\n+  }\n+\n+  public void testCast3() throws Exception {\n+    // cannot downcast\n+    testTypes(\"/** @constructor */function base() {}\\n\" +\n+        \"/** @constructor @extends {base} */function derived() {}\\n\" +\n+        \"/** @type {!derived} */ var baz = new base();\\n\",\n+        \"initializing variable\\n\" +\n+        \"found   : base\\n\" +\n+        \"required: derived\");\n+  }\n+\n+  public void testCast4() throws Exception {\n+    // downcast must be explicit\n+    testTypes(\"/** @constructor */function base() {}\\n\" +\n+        \"/** @constructor\\n * @extends {base} */function derived() {}\\n\" +\n+        \"/** @type {!derived} */ var baz = \" +\n+        \"/** @type {!derived} */(new base());\\n\");\n+  }\n+\n+  public void testCast5() throws Exception {\n+    // cannot explicitly cast to an unrelated type\n+    testTypes(\"/** @constructor */function foo() {}\\n\" +\n+        \"/** @constructor */function bar() {}\\n\" +\n+        \"var baz = /** @type {!foo} */(new bar);\\n\",\n+        \"invalid cast - must be a subtype or supertype\\n\" +\n+        \"from: bar\\n\" +\n+        \"to  : foo\");\n+  }\n+\n+  public void testCast6() throws Exception {\n+    // can explicitly cast to a subtype or supertype\n+    testTypes(\"/** @constructor */function foo() {}\\n\" +\n+        \"/** @constructor \\n @extends foo */function bar() {}\\n\" +\n+        \"var baz = /** @type {!bar} */(new bar);\\n\" +\n+        \"var baz = /** @type {!foo} */(new foo);\\n\" +\n+        \"var baz = /** @type {bar} */(new bar);\\n\" +\n+        \"var baz = /** @type {foo} */(new foo);\\n\" +\n+        \"var baz = /** @type {!foo} */(new bar);\\n\" +\n+        \"var baz = /** @type {!bar} */(new foo);\\n\" +\n+        \"var baz = /** @type {foo} */(new bar);\\n\" +\n+        \"var baz = /** @type {bar} */(new foo);\\n\");\n+  }\n+\n+  public void testCast7() throws Exception {\n+    testTypes(\"var x = /** @type {foo} */ (new Object());\",\n+        \"Parse error. Unknown type foo\");\n+  }\n+\n+  public void testCast8() throws Exception {\n+    testTypes(\"function f() { return /** @type {foo} */ (new Object()); }\",\n+        \"Parse error. Unknown type foo\");\n+  }\n+\n+  public void testNestedCasts() throws Exception {\n+    testTypes(\"/** @constructor */var T = function() {};\\n\" +\n+        \"/** @constructor */var V = function() {};\\n\" +\n+        \"/**\\n\" +\n+        \"* @param {boolean} b\\n\" +\n+        \"* @return {T|V}\\n\" +\n+        \"*/\\n\" +\n+        \"function f(b) { return b ? new T() : new V(); }\\n\" +\n+        \"/**\\n\" +\n+        \"* @param {boolean} b\\n\" +\n+        \"* @return {boolean|undefined}\\n\" +\n+        \"*/\\n\" +\n+        \"function g(b) { return b ? true : undefined; }\\n\" +\n+        \"/* @return {T} */\\n\" +\n+        \"function h() {\\n\" +\n+        \"return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testNativeCast1() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x */ function f(x) {}\" +\n+        \"f(String(true));\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testNativeCast2() throws Exception {\n+    testTypes(\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"f(Number(true));\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testNativeCast3() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x */ function f(x) {}\" +\n+        \"f(Boolean(''));\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testNativeCast4() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x */ function f(x) {}\" +\n+        \"f(Error(''));\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : Error\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testBadConstructorCall() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo();\",\n+        \"Constructor function (this:Foo): ? should be called \" +\n+        \"with the \\\"new\\\" keyword\");\n+  }\n+\n+  public void testTypeof() throws Exception {\n+    testTypes(\"/**@return {void}*/function foo(){ var a = typeof foo(); }\");\n+  }\n+\n+  public void testConstructorType1() throws Exception {\n+    testTypes(\"/**@constructor*/function Foo(){}\" +\n+        \"/**@type{!Foo}*/var f = new Date();\",\n+        \"initializing variable\\n\" +\n+        \"found   : Date\\n\" +\n+        \"required: Foo\");\n+  }\n+\n+  public void testConstructorType2() throws Exception {\n+    testTypes(\"/**@constructor*/function Foo(){\\n\" +\n+        \"/**@type{Number}*/this.bar = new Number(5);\\n\" +\n+        \"}\\n\" +\n+        \"/**@type{Foo}*/var f = new Foo();\\n\" +\n+        \"/**@type{Number}*/var n = f.bar;\");\n+  }\n+\n+  public void testConstructorType3() throws Exception {\n+    // Reverse the declaration order so that we know that Foo is getting set\n+    // even on an out-of-order declaration sequence.\n+    testTypes(\"/**@type{Foo}*/var f = new Foo();\\n\" +\n+        \"/**@type{Number}*/var n = f.bar;\" +\n+        \"/**@constructor*/function Foo(){\\n\" +\n+        \"/**@type{Number}*/this.bar = new Number(5);\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testConstructorType4() throws Exception {\n+    testTypes(\"/**@constructor*/function Foo(){\\n\" +\n+        \"/**@type{!Number}*/this.bar = new Number(5);\\n\" +\n+        \"}\\n\" +\n+        \"/**@type{!Foo}*/var f = new Foo();\\n\" +\n+        \"/**@type{!String}*/var n = f.bar;\",\n+        \"initializing variable\\n\" +\n+        \"found   : Number\\n\" +\n+        \"required: String\");\n+  }\n+\n+  public void testConstructorType5() throws Exception {\n+    testTypes(\"/**@constructor*/function Foo(){}\\n\" +\n+        \"if (Foo){}\\n\");\n+  }\n+\n+  public void testConstructorType6() throws Exception {\n+    testTypes(\"/** @constructor */\\n\" +\n+        \"function bar() {}\\n\" +\n+        \"function _foo() {\\n\" +\n+        \" /** @param {bar} x */\\n\" +\n+        \"  function f(x) {}\\n\" +\n+        \"}\");\n+  }\n+\n+  public void testConstructorType7() throws Exception {\n+    Pair<Node, Scope> p =\n+        parseAndTypeCheckWithScope(\"/** @constructor */function A(){};\");\n+\n+    JSType type = p.getSecond().getVar(\"A\").getType();\n+    assertTrue(type instanceof FunctionType);\n+    FunctionType fType = (FunctionType) type;\n+    assertEquals(\"A\", fType.getReferenceName());\n+  }\n+\n+  public void testAnonymousType1() throws Exception {\n+    testTypes(\"function f() {}\" +\n+        \"/** @constructor */\\n\" +\n+        \"f().bar = function() {};\");\n+  }\n+\n+  public void testAnonymousType2() throws Exception {\n+    testTypes(\"function f() {}\" +\n+        \"/** @interface */\\n\" +\n+        \"f().bar = function() {};\");\n+  }\n+\n+  public void testAnonymousType3() throws Exception {\n+    testTypes(\"function f() {}\" +\n+        \"/** @enum */\\n\" +\n+        \"f().bar = {FOO: 1};\");\n+  }\n+\n+  public void testBang1() throws Exception {\n+    testTypes(\"/** @param {Object} x\\n@return {!Object} */\\n\" +\n+        \"function f(x) { return x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (Object|null)\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testBang2() throws Exception {\n+    testTypes(\"/** @param {Object} x\\n@return {!Object} */\\n\" +\n+        \"function f(x) { return x ? x : new Object(); }\");\n+  }\n+\n+  public void testBang3() throws Exception {\n+    testTypes(\"/** @param {Object} x\\n@return {!Object} */\\n\" +\n+        \"function f(x) { return /** @type {!Object} */ (x); }\");\n+  }\n+\n+  public void testBang4() throws Exception {\n+    testTypes(\"/**@param {Object} x\\n@param {Object} y\\n@return {boolean}*/\\n\" +\n+        \"function f(x, y) {\\n\" +\n+        \"if (typeof x != 'undefined') { return x == y; }\\n\" +\n+        \"else { return x != y; }\\n}\");\n+  }\n+\n+  public void testBang5() throws Exception {\n+    testTypes(\"/**@param {Object} x\\n@param {Object} y\\n@return {boolean}*/\\n\" +\n+        \"function f(x, y) { return !!x && x == y; }\");\n+  }\n+\n+  public void testBang6() throws Exception {\n+    testTypes(\"/** @param {Object?} x\\n@return {Object} */\\n\" +\n+        \"function f(x) { return x; }\");\n+  }\n+\n+  public void testBang7() throws Exception {\n+    testTypes(\"/**@param {(Object,string,null)} x\\n\" +\n+        \"@return {(Object,string)}*/function f(x) { return x; }\");\n+  }\n+\n+  public void testDefinePropertyOnNullableObject1() throws Exception {\n+    testTypes(\"/** @type {Object} */ var n = {};\\n\" +\n+        \"/** @type {number} */ n.x = 1;\\n\" +\n+        \"/** @return {boolean} */function f() { return n.x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testDefinePropertyOnNullableObject2() throws Exception {\n+    testTypes(\"/** @constructor */ var T = function() {};\\n\" +\n+        \"/** @param {T} t\\n@return {boolean} */function f(t) {\\n\" +\n+        \"t.x = 1; return t.x; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: boolean\");\n+  }\n+\n+  public void testUnknownConstructorInstanceType1() throws Exception {\n+    testTypes(\"/** @return Array */ function g(f) { return new f(); }\");\n+  }\n+\n+  public void testUnknownConstructorInstanceType2() throws Exception {\n+    testTypes(\"function g(f) { return /** @type Array */ new f(); }\");\n+  }\n+\n+  public void testUnknownConstructorInstanceType3() throws Exception {\n+    testTypes(\"function g(f) { var x = new f(); x.a = 1; return x; }\");\n+  }\n+\n+  public void testUnknownPrototypeChain() throws Exception {\n+    testTypes(\"/**\\n\" +\n+              \"* @param {Object} co\\n\" +\n+              \" * @return {Object}\\n\" +\n+              \" */\\n\" +\n+              \"function inst(co) {\\n\" +\n+              \" /** @constructor */\\n\" +\n+              \" var c = function() {};\\n\" +\n+              \" c.prototype = co.prototype;\\n\" +\n+              \" return new c;\\n\" +\n+              \"}\");\n+  }\n+\n+  public void testNamespacedConstructor() throws Exception {\n+    Node root = parseAndTypeCheck(\n+        \"var goog = {};\" +\n+        \"/** @constructor */ goog.MyClass = function() {};\" +\n+        \"/** @return {!goog.MyClass} */ \" +\n+        \"function foo() { return new goog.MyClass(); }\");\n+\n+    JSType typeOfFoo = root.getLastChild().getJSType();\n+    assert(typeOfFoo instanceof FunctionType);\n+\n+    JSType retType = ((FunctionType) typeOfFoo).getReturnType();\n+    assert(retType instanceof ObjectType);\n+    assertEquals(\"goog.MyClass\", ((ObjectType) retType).getReferenceName());\n+  }\n+\n+  public void testComplexNamespace() throws Exception {\n+    String js =\n+      \"var goog = {};\" +\n+      \"goog.foo = {};\" +\n+      \"goog.foo.bar = 5;\";\n+\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(js);\n+\n+    // goog type in the scope\n+    JSType googScopeType = p.second.getVar(\"goog\").getType();\n+    assertTrue(googScopeType instanceof ObjectType);\n+    assertTrue(\"foo property not present on goog type\",\n+        ((ObjectType) googScopeType).hasProperty(\"foo\"));\n+    assertFalse(\"bar property present on goog type\",\n+        ((ObjectType) googScopeType).hasProperty(\"bar\"));\n+\n+    // goog type on the VAR node\n+    Node varNode = p.first.getFirstChild();\n+    assertEquals(Token.VAR, varNode.getType());\n+    JSType googNodeType = varNode.getFirstChild().getJSType();\n+    assertTrue(googNodeType instanceof ObjectType);\n+\n+    // goog scope type and goog type on VAR node must be the same\n+    assertTrue(googScopeType == googNodeType);\n+\n+    // goog type on the left of the GETPROP node (under fist ASSIGN)\n+    Node getpropFoo1 = varNode.getNext().getFirstChild().getFirstChild();\n+    assertEquals(Token.GETPROP, getpropFoo1.getType());\n+    assertEquals(\"goog\", getpropFoo1.getFirstChild().getString());\n+    JSType googGetpropFoo1Type = getpropFoo1.getFirstChild().getJSType();\n+    assertTrue(googGetpropFoo1Type instanceof ObjectType);\n+\n+    // still the same type as the one on the variable\n+    assertTrue(googGetpropFoo1Type == googScopeType);\n+\n+    // the foo property should be defined on goog\n+    JSType googFooType = ((ObjectType) googScopeType).getPropertyType(\"foo\");\n+    assertTrue(googFooType instanceof ObjectType);\n+\n+    // goog type on the left of the GETPROP lower level node\n+    // (under second ASSIGN)\n+    Node getpropFoo2 = varNode.getNext().getNext()\n+        .getFirstChild().getFirstChild().getFirstChild();\n+    assertEquals(Token.GETPROP, getpropFoo2.getType());\n+    assertEquals(\"goog\", getpropFoo2.getFirstChild().getString());\n+    JSType googGetpropFoo2Type = getpropFoo2.getFirstChild().getJSType();\n+    assertTrue(googGetpropFoo2Type instanceof ObjectType);\n+\n+    // still the same type as the one on the variable\n+    assertTrue(googGetpropFoo2Type == googScopeType);\n+\n+    // goog.foo type on the left of the top level GETPROP node\n+    // (under second ASSIGN)\n+    JSType googFooGetprop2Type = getpropFoo2.getJSType();\n+    assertTrue(\"goog.foo incorrectly annotated in goog.foo.bar selection\",\n+        googFooGetprop2Type instanceof ObjectType);\n+    ObjectType googFooGetprop2ObjectType = (ObjectType) googFooGetprop2Type;\n+    assertFalse(\"foo property present on goog.foo type\",\n+        googFooGetprop2ObjectType.hasProperty(\"foo\"));\n+    assertTrue(\"bar property not present on goog.foo type\",\n+        googFooGetprop2ObjectType.hasProperty(\"bar\"));\n+    assertEquals(\"bar property on goog.foo type incorrectly inferred\",\n+        NUMBER_TYPE, googFooGetprop2ObjectType.getPropertyType(\"bar\"));\n+  }\n+\n+  public void testAddingMethodsUsingPrototypeIdiomSimpleNamespace()\n+      throws Exception {\n+    Node js1Node = parseAndTypeCheck(\n+        \"/** @constructor */function A() {}\" +\n+        \"A.prototype.m1 = 5\");\n+\n+    ObjectType instanceType = getInstanceType(js1Node);\n+    assertEquals(NATIVE_PROPERTIES_COUNT + 1,\n+        instanceType.getPropertiesCount());\n+    checkObjectType(instanceType, \"m1\", NUMBER_TYPE);\n+  }\n+\n+  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace1()\n+      throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+        \"var goog = {};\" +\n+        \"goog.A = /** @constructor */function() {};\" +\n+        \"/** @type number */goog.A.prototype.m1 = 5\");\n+\n+    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);\n+  }\n+\n+  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace2()\n+      throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\n+        \"var goog = {};\" +\n+        \"/** @constructor */goog.A = function() {};\" +\n+        \"/** @type number */goog.A.prototype.m1 = 5\");\n+\n+    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);\n+  }\n+\n+  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(\n+      Pair<Node, Scope> p) {\n+    ObjectType goog = (ObjectType) p.second.getVar(\"goog\").getType();\n+    assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount());\n+    JSType googA = goog.getPropertyType(\"A\");\n+    assertNotNull(googA);\n+    assertTrue(googA instanceof FunctionType);\n+    FunctionType googAFunction = (FunctionType) googA;\n+    ObjectType classA = googAFunction.getInstanceType();\n+    assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount());\n+    checkObjectType(classA, \"m1\", NUMBER_TYPE);\n+  }\n+\n+  public void testAddingMethodsPrototypeIdiomAndObjectLiteralSimpleNamespace()\n+      throws Exception {\n+    Node js1Node = parseAndTypeCheck(\n+        \"/** @constructor */function A() {}\" +\n+        \"A.prototype = {m1: 5, m2: true}\");\n+\n+    ObjectType instanceType = getInstanceType(js1Node);\n+    assertEquals(NATIVE_PROPERTIES_COUNT + 2,\n+        instanceType.getPropertiesCount());\n+    checkObjectType(instanceType, \"m1\", NUMBER_TYPE);\n+    checkObjectType(instanceType, \"m2\", BOOLEAN_TYPE);\n+  }\n+\n+  public void testDontAddMethodsIfNoConstructor()\n+      throws Exception {\n+    Node js1Node = parseAndTypeCheck(\n+        \"function A() {}\" +\n+        \"A.prototype = {m1: 5, m2: true}\");\n+\n+    JSType functionAType = js1Node.getFirstChild().getJSType();\n+    assertEquals(\"function (): ?\", functionAType.toString());\n+    assertEquals(UNKNOWN_TYPE,\n+        U2U_FUNCTION_TYPE.getPropertyType(\"m1\"));\n+    assertEquals(UNKNOWN_TYPE,\n+        U2U_FUNCTION_TYPE.getPropertyType(\"m2\"));\n+  }\n+\n+  public void testFunctionAssignement() throws Exception {\n+    testTypes(\"/**\" +\n+        \"* @param {string} ph0\" +\n+        \"* @param {string} ph1\" +\n+        \"* @return {string}\" +\n+        \"*/\" +\n+        \"function MSG_CALENDAR_ACCESS_ERROR(ph0, ph1) {return ''}\" +\n+        \"/** @type {Function} */\" +\n+        \"var MSG_CALENDAR_ADD_ERROR = MSG_CALENDAR_ACCESS_ERROR;\");\n+  }\n+\n+  public void testAddMethodsPrototypeTwoWays() throws Exception {\n+    Node js1Node = parseAndTypeCheck(\n+        \"/** @constructor */function A() {}\" +\n+        \"A.prototype = {m1: 5, m2: true};\" +\n+        \"A.prototype.m3 = 'third property!';\");\n+\n+    ObjectType instanceType = getInstanceType(js1Node);\n+    assertEquals(\"A\", instanceType.toString());\n+    assertEquals(NATIVE_PROPERTIES_COUNT + 3,\n+        instanceType.getPropertiesCount());\n+    checkObjectType(instanceType, \"m1\", NUMBER_TYPE);\n+    checkObjectType(instanceType, \"m2\", BOOLEAN_TYPE);\n+    checkObjectType(instanceType, \"m3\", STRING_TYPE);\n+  }\n+\n+  public void testPrototypePropertyTypes() throws Exception {\n+    Node js1Node = parseAndTypeCheck(\n+        \"/** @constructor */function A() {\\n\" +\n+        \"  /** @type string */ this.m1;\\n\" +\n+        \"  /** @type Object? */ this.m2 = {};\\n\" +\n+        \"  /** @type boolean */ this.m3;\\n\" +\n+        \"}\\n\" +\n+        \"/** @type string */ A.prototype.m4;\\n\" +\n+        \"/** @type number */ A.prototype.m5 = 0;\\n\" +\n+        \"/** @type boolean */ A.prototype.m6;\\n\");\n+\n+    ObjectType instanceType = getInstanceType(js1Node);\n+    assertEquals(NATIVE_PROPERTIES_COUNT + 6,\n+        instanceType.getPropertiesCount());\n+    checkObjectType(instanceType, \"m1\", STRING_TYPE);\n+    checkObjectType(instanceType, \"m2\",\n+        createUnionType(OBJECT_TYPE, NULL_TYPE));\n+    checkObjectType(instanceType, \"m3\", BOOLEAN_TYPE);\n+    checkObjectType(instanceType, \"m4\", STRING_TYPE);\n+    checkObjectType(instanceType, \"m5\", NUMBER_TYPE);\n+    checkObjectType(instanceType, \"m6\", BOOLEAN_TYPE);\n+  }\n+\n+  public void testValueTypeBuiltInPrototypePropertyType() throws Exception {\n+    Node node = parseAndTypeCheck(\"\\\"x\\\".charAt(0)\");\n+    assertEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType());\n+  }\n+\n+  public void testDeclareBuiltInConstructor() throws Exception {\n+    // Built-in prototype properties should be accessible\n+    // even if the built-in constructor is declared.\n+    Node node = parseAndTypeCheck(\n+        \"/** @constructor */ var String = function(opt_str) {};\\n\" +\n+        \"(new String(\\\"x\\\")).charAt(0)\");\n+    assertEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType());\n+  }\n+\n+  public void testExtendBuiltInType1() throws Exception {\n+    String externs =\n+        \"/** @constructor */ var String = function(opt_str) {};\\n\" +\n+        \"/**\\n\" +\n+        \"* @param {number} start\\n\" +\n+        \"* @param {number} opt_length\\n\"  +\n+        \"* @return {string}\\n\" +\n+        \"*/\\n\" +\n+        \"String.prototype.substr = function(start, opt_length) {};\\n\";\n+    Node n1 = parseAndTypeCheck(externs + \"(new String(\\\"x\\\")).substr(0,1);\");\n+    assertEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType());\n+  }\n+\n+  public void testExtendBuiltInType2() throws Exception {\n+    String externs =\n+        \"/** @constructor */ var String = function(opt_str) {};\\n\" +\n+        \"/**\\n\" +\n+        \"* @param {number} start\\n\" +\n+        \"* @param {number} opt_length\\n\"  +\n+        \"* @return {string}\\n\" +\n+        \"*/\\n\" +\n+        \"String.prototype.substr = function(start, opt_length) {};\\n\";\n+    Node n2 = parseAndTypeCheck(externs + \"\\\"x\\\".substr(0,1);\");\n+    assertEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType());\n+  }\n+\n+  public void testExtendFunction1() throws Exception {\n+    Node n = parseAndTypeCheck(\"/**@return {number}*/Function.prototype.f = \" +\n+        \"function() { return 1; };\\n\" +\n+        \"(new Function()).f();\");\n+    JSType type = n.getLastChild().getLastChild().getJSType();\n+    assertEquals(NUMBER_TYPE, type);\n+  }\n+\n+  public void testExtendFunction2() throws Exception {\n+    Node n = parseAndTypeCheck(\"/**@return {number}*/Function.prototype.f = \" +\n+        \"function() { return 1; };\\n\" +\n+        \"(function() {}).f();\");\n+    JSType type = n.getLastChild().getLastChild().getJSType();\n+    assertEquals(NUMBER_TYPE, type);\n+  }\n+\n+  public void testInheritanceCheck1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"Sub.prototype.foo = function() {};\");\n+  }\n+\n+  public void testInheritanceCheck2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo = function() {};\",\n+        \"property foo not defined on any superclass of Sub\");\n+  }\n+\n+  public void testInheritanceCheck3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"Super.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"Sub.prototype.foo = function() {};\",\n+        \"property foo already defined on superclass Super; \" +\n+        \"use @override to override it\");\n+  }\n+\n+  public void testInheritanceCheck4() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"Super.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo = function() {};\");\n+  }\n+\n+  public void testInheritanceCheck5() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Root() {};\" +\n+        \"Root.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @extends {Root} */function Super() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"Sub.prototype.foo = function() {};\",\n+        \"property foo already defined on superclass Root; \" +\n+        \"use @override to override it\");\n+  }\n+\n+  public void testInheritanceCheck6() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Root() {};\" +\n+        \"Root.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @extends {Root} */function Super() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo = function() {};\");\n+  }\n+\n+  public void testInheritanceCheck7() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @constructor */goog.Super = function() {};\" +\n+        \"goog.Super.prototype.foo = 3;\" +\n+        \"/** @constructor\\n @extends {goog.Super} */goog.Sub = function() {};\" +\n+        \"goog.Sub.prototype.foo = 5;\",\n+        \"property foo already defined on superclass goog.Super; \" +\n+        \"use @override to override it\");\n+  }\n+\n+  public void testInheritanceCheck8() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @constructor */goog.Super = function() {};\" +\n+        \"goog.Super.prototype.foo = 3;\" +\n+        \"/** @constructor\\n @extends {goog.Super} */goog.Sub = function() {};\" +\n+        \"/** @override */goog.Sub.prototype.foo = 5;\");\n+  }\n+\n+  public void testInheritanceCheck9_1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"Super.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override\\n @return number */Sub.prototype.foo =\\n\" +\n+        \"function() { return 1; };\");\n+  }\n+\n+  public void testInheritanceCheck9_2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"/** @return number */Super.prototype.foo = function() { return 1; };\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo =\\n\" +\n+        \"function() {};\");\n+  }\n+\n+  public void testInheritanceCheck9_3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"/** @return number */Super.prototype.foo = function() { return 1; };\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override\\n @return string */Sub.prototype.foo =\\n\" +\n+        \"function() { return \\\"some string\\\" };\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from superclass Super\\n\" +\n+        \"original: function (this:Super): number\\n\" +\n+        \"override: function (this:Sub): string\");\n+  }\n+\n+  public void testInheritanceCheck10_1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Root() {};\" +\n+        \"Root.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @extends {Root} */function Super() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override\\n @return number */Sub.prototype.foo =\\n\" +\n+        \"function() { return 1; };\");\n+  }\n+\n+  public void testInheritanceCheck10_2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Root() {};\" +\n+        \"/** @return number */Root.prototype.foo = function() { return 1; };\" +\n+        \"/** @constructor\\n @extends {Root} */function Super() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo =\\n\" +\n+        \"function() {};\");\n+  }\n+\n+  public void testInheritanceCheck10_3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Root() {};\" +\n+        \"/** @return number */Root.prototype.foo = function() { return 1; };\" +\n+        \"/** @constructor\\n @extends {Root} */function Super() {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override\\n @return string */Sub.prototype.foo =\\n\" +\n+        \"function() { return \\\"some string\\\" };\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from superclass Root\\n\" +\n+        \"original: function (this:Root): number\\n\" +\n+        \"override: function (this:Sub): string\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck11() throws Exception {\n+    testTypes(\n+        \"/** @constructor */function Super() {};\" +\n+        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n+        \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n+        \"function(bar) {};\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from superclass Super\\n\" +\n+        \"original: function (this:Super, number): ?\\n\" +\n+        \"override: function (this:Sub, string): ?\");\n+  }\n+\n+  public void testInheritanceCheck12() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @constructor */goog.Super = function() {};\" +\n+        \"goog.Super.prototype.foo = 3;\" +\n+        \"/** @constructor\\n @extends {goog.Super} */goog.Sub = function() {};\" +\n+        \"/** @override */goog.Sub.prototype.foo = \\\"some string\\\";\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from superclass goog.Super\\n\" +\n+        \"original: number\\n\" +\n+        \"override: string\");\n+  }\n+\n+  public void testInheritanceCheck13() throws Exception {\n+    testTypes(\n+        \"var goog = {};\\n\" +\n+        \"/** @constructor\\n @extends {goog.Missing} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo = function() {};\",\n+        \"Parse error. Unknown type goog.Missing\");\n+  }\n+\n+  public void testInheritanceCheck14() throws Exception {\n+    testTypes(\n+        \"var goog = {};\\n\" +\n+        \"/** @constructor\\n @extends {goog.Missing} */\\n\" +\n+        \"goog.Super = function() {};\\n\" +\n+        \"/** @constructor\\n @extends {goog.Super} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo = function() {};\",\n+        \"Parse error. Unknown type goog.Missing\");\n+  }\n+\n+  // TODO(user): We should support this way of declaring properties as it is\n+  // widely used.\n+  //public void testInheritanceCheck15() throws Exception {\n+  //  testTypes(\n+  //      \"/** @constructor */function Super() {};\" +\n+  //      \"/** @param {number} bar */Super.prototype.foo;\" +\n+  //      \"/** @constructor\\n @extends {Super} */function Sub() {};\" +\n+  //      \"/** @override\\n  @param {number} bar */Sub.prototype.foo =\\n\" +\n+  //      \"function(bar) {};\");\n+  //}\n+\n+//   public void testInterfacePropertyOverride1() throws Exception {\n+//     testTypes(\n+//         \"/** @interface */function Super() {};\" +\n+//         \"/** @desc description */Super.prototype.foo = function() {};\" +\n+//         \"/** @interface\\n @extends {Super} */function Sub() {};\" +\n+//         \"/** @desc description */Sub.prototype.foo = function() {};\",\n+//         \"property foo is already defined by the Super extended interface\");\n+//   }\n+\n+//   public void testInterfacePropertyOverride2() throws Exception {\n+//     testTypes(\n+//         \"/** @interface */function Root() {};\" +\n+//         \"/** @desc description */Root.prototype.foo = function() {};\" +\n+//         \"/** @interface\\n @extends {Root} */function Super() {};\" +\n+//         \"/** @interface\\n @extends {Super} */function Sub() {};\" +\n+//         \"/** @desc description */Sub.prototype.foo = function() {};\",\n+//         \"property foo is already defined by the Root extended interface\");\n+//   }\n+\n+  public void testInterfaceInheritanceCheck1() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Super() {};\" +\n+        \"/** @desc description */Super.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n+        \"Sub.prototype.foo = function() {};\",\n+        \"property foo already defined on interface Super; use @override to \" +\n+        \"override it\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck2() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Super() {};\" +\n+        \"/** @desc description */Super.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo = function() {};\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck3() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Root() {};\" +\n+        \"/** @return {number} */Root.prototype.foo = function() {};\" +\n+        \"/** @interface\\n @extends {Root} */function Super() {};\" +\n+        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n+        \"/** @return {number} */Sub.prototype.foo = function() { return 1;};\",\n+        \"property foo already defined on interface Root; use @override to \" +\n+        \"override it\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck4() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Root() {};\" +\n+        \"/** @return {number} */Root.prototype.foo = function() {};\" +\n+        \"/** @interface\\n @extends {Root} */function Super() {};\" +\n+        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n+        \"/** @override\\n * @return {number} */Sub.prototype.foo =\\n\" +\n+        \"function() { return 1;};\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck5() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Super() {};\" +\n+        \"/** @return string */Super.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n+        \"/** @override\\n @return number */Sub.prototype.foo =\\n\" +\n+        \"function() { return 1; };\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from interface Super\\n\" +\n+        \"original: function (this:Super): string\\n\" +\n+        \"override: function (this:Sub): number\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck6() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Root() {};\" +\n+        \"/** @return string */Root.prototype.foo = function() {};\" +\n+        \"/** @interface\\n @extends {Root} */function Super() {};\" +\n+        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n+        \"/** @override\\n @return number */Sub.prototype.foo =\\n\" +\n+        \"function() { return 1; };\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from interface Root\\n\" +\n+        \"original: function (this:Root): string\\n\" +\n+        \"override: function (this:Sub): number\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck7() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Super() {};\" +\n+        \"/** @param {number} bar */Super.prototype.foo = function(bar) {};\" +\n+        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n+        \"/** @override\\n  @param {string} bar */Sub.prototype.foo =\\n\" +\n+        \"function(bar) {};\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from interface Super\\n\" +\n+        \"original: function (this:Super, number): ?\\n\" +\n+        \"override: function (this:Sub, string): ?\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck8() throws Exception {\n+    testTypes(\n+        \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n+        \"/** @override */Sub.prototype.foo = function() {};\",\n+        new String[] {\n+          \"Parse error. Unknown type Super\",\n+          \"property foo not defined on any superclass of Sub\"\n+        });\n+  }\n+\n+  public void testInterfacePropertyNotImplemented() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Int() {};\" +\n+        \"/** @desc description */Int.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @implements {Int} */function Foo() {};\",\n+        \"property foo on interface Int is not implemented by type Foo\");\n+  }\n+\n+  public void testInterfacePropertyNotImplemented2() throws Exception {\n+    testTypes(\n+        \"/** @interface */function Int() {};\" +\n+        \"/** @desc description */Int.prototype.foo = function() {};\" +\n+        \"/** @interface \\n @extends {Int} */function Int2() {};\" +\n+        \"/** @constructor\\n @implements {Int2} */function Foo() {};\",\n+        \"property foo on interface Int is not implemented by type Foo\");\n+  }\n+\n+  public void testStubConstructorImplementingInterface() throws Exception {\n+    // This does not throw a warning for unimplemented property because Foo is\n+    // just a stub.\n+    testTypes(\"/** @interface */ function Int() {}\\n\" +\n+        \"/** @desc description */Int.prototype.foo = function() {};\" +\n+        \"/** @constructor \\n @implements {Int} */ var Foo;\\n\");\n+  }\n+\n+  public void testObjectLiteral() throws Exception {\n+    Node n = parseAndTypeCheck(\"var a = {m1: 7, m2: 'hello'}\");\n+\n+    Node nameNode = n.getFirstChild().getFirstChild();\n+    Node objectNode = nameNode.getFirstChild();\n+\n+    // node extraction\n+    assertEquals(Token.NAME, nameNode.getType());\n+    assertEquals(Token.OBJECTLIT, objectNode.getType());\n+\n+    // value's type\n+    ObjectType objectType =\n+        (ObjectType) objectNode.getJSType();\n+    assertEquals(NUMBER_TYPE, objectType.getPropertyType(\"m1\"));\n+    assertEquals(STRING_TYPE, objectType.getPropertyType(\"m2\"));\n+\n+    // variable's type\n+    assertEquals(objectType, nameNode.getJSType());\n+  }\n+\n+  public void testObjectLiteralDeclaration1() throws Exception {\n+    testTypes(\n+        \"var x = {\" +\n+        \"/** @type {boolean} */ abc: true,\" +\n+        \"/** @type {number} */ 'def': 0,\" +\n+        \"/** @type {string} */ 3: 'fgh'\" +\n+        \"};\");\n+  }\n+\n+  public void testCallDateConstructorAsFunction() throws Exception {\n+    // ECMA-262 15.9.2: When Date is called as a function rather than as a\n+    // constructor, it returns a string.\n+    Node n = parseAndTypeCheck(\"Date()\");\n+    assertEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType());\n+  }\n+\n+  // According to ECMA-262, Error & Array function calls are equivalent to\n+  // constructor calls.\n+\n+  public void testCallErrorConstructorAsFunction() throws Exception {\n+    Node n = parseAndTypeCheck(\"Error('x')\");\n+    assertEquals(ERROR_TYPE,\n+                 n.getFirstChild().getFirstChild().getJSType());\n+  }\n+\n+  public void testCallArrayConstructorAsFunction() throws Exception {\n+    Node n = parseAndTypeCheck(\"Array()\");\n+    assertEquals(ARRAY_TYPE,\n+                 n.getFirstChild().getFirstChild().getJSType());\n+  }\n+\n+  public void testPropertyTypeOfUnionType() throws Exception {\n+    testTypes(\"var a = {};\" +\n+        \"/** @constructor */ a.N = function() {};\\n\" +\n+        \"a.N.prototype.p = 1;\\n\" +\n+        \"/** @constructor */ a.S = function() {};\\n\" +\n+        \"a.S.prototype.p = 'a';\\n\" +\n+        \"/** @param {!a.N|!a.S} x\\n@return {string} */\\n\" +\n+        \"var f = function(x) { return x.p; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  // TODO(user): We should flag these as invalid. This will probably happen\n+  // when we make sure the interface is never referenced outside of its\n+  // definition. We might want more specific and helpful error messages.\n+  //public void testWarningOnInterfacePrototype() throws Exception {\n+  //  testTypes(\"/** @interface */ u.T = function() {};\\n\" +\n+  //      \"/** @return {number} */ u.T.prototype = function() { };\",\n+  //      \"cannot reference an interface ouside of its definition\");\n+  //}\n+  //\n+  //public void testBadPropertyOnInterface1() throws Exception {\n+  //  testTypes(\"/** @interface */ u.T = function() {};\\n\" +\n+  //      \"/** @return {number} */ u.T.f = function() { return 1;};\",\n+  //      \"cannot reference an interface ouside of its definition\");\n+  //}\n+  //\n+  //public void testBadPropertyOnInterface2() throws Exception {\n+  //  testTypes(\"/** @interface */ function T() {};\\n\" +\n+  //      \"/** @return {number} */ T.f = function() { return 1;};\",\n+  //      \"cannot reference an interface ouside of its definition\");\n+  //}\n+  //\n+  //public void testBadPropertyOnInterface3() throws Exception {\n+  //  testTypes(\"/** @interface */ u.T = function() {}; u.T.x\",\n+  //      \"cannot reference an interface ouside of its definition\");\n+  //}\n+  //\n+  //public void testBadPropertyOnInterface4() throws Exception {\n+  //  testTypes(\"/** @interface */ function T() {}; T.x;\",\n+  //      \"cannot reference an interface ouside of its definition\");\n+  //}\n+\n+  public void testAnnotatedPropertyOnInterface1() throws Exception {\n+    // For interfaces we must allow function definitions that don't have a\n+    // return statement, even though they declare a returned type.\n+    testTypes(\"/** @interface */ u.T = function() {};\\n\" +\n+        \"/** @return {number} */ u.T.prototype.f = function() {};\");\n+  }\n+\n+  public void testAnnotatedPropertyOnInterface2() throws Exception {\n+    testTypes(\"/** @interface */ u.T = function() {};\\n\" +\n+        \"/** @return {number} */ u.T.prototype.f = function() { };\");\n+  }\n+\n+  public void testAnnotatedPropertyOnInterface3() throws Exception {\n+    testTypes(\"/** @interface */ function T() {};\\n\" +\n+        \"/** @return {number} */ T.prototype.f = function() { };\");\n+  }\n+\n+  public void testAnnotatedPropertyOnInterface4() throws Exception {\n+    testTypes(\n+        CLOSURE_DEFS +\n+        \"/** @interface */ function T() {};\\n\" +\n+        \"/** @return {number} */ T.prototype.f = goog.abstractMethod;\");\n+  }\n+\n+  // TODO(user): If we want to support this syntax we have to warn about\n+  // missing annotations.\n+  //public void testWarnUnannotatedPropertyOnInterface1() throws Exception {\n+  //  testTypes(\"/** @interface */ u.T = function () {}; u.T.prototype.x;\",\n+  //      \"interface property x is not annotated\");\n+  //}\n+  //\n+  //public void testWarnUnannotatedPropertyOnInterface2() throws Exception {\n+  //  testTypes(\"/** @interface */ function T() {}; T.prototype.x;\",\n+  //      \"interface property x is not annotated\");\n+  //}\n+\n+  public void testWarnUnannotatedPropertyOnInterface5() throws Exception {\n+    testTypes(\"/** @interface */ u.T = function () {};\\n\" +\n+        \"/** @desc x does something */u.T.prototype.x = function() {};\");\n+  }\n+\n+  public void testWarnUnannotatedPropertyOnInterface6() throws Exception {\n+    testTypes(\"/** @interface */ function T() {};\\n\" +\n+        \"/** @desc x does something */T.prototype.x = function() {};\");\n+  }\n+\n+  // TODO(user): If we want to support this syntax we have to warn about\n+  // the invalid type of the interface member.\n+  //public void testWarnDataPropertyOnInterface1() throws Exception {\n+  //  testTypes(\"/** @interface */ u.T = function () {};\\n\" +\n+  //      \"/** @type {number} */u.T.prototype.x;\",\n+  //      \"interface members can only be plain functions\");\n+  //}\n+  //\n+  //public void testWarnDataPropertyOnInterface2() throws Exception {\n+  //  testTypes(\"/** @interface */ function T() {};\\n\" +\n+  //      \"/** @type {number} */T.prototype.x;\",\n+  //      \"interface members can only be plain functions\");\n+  //}\n+\n+  public void testWarnDataPropertyOnInterface3() throws Exception {\n+    testTypes(\"/** @interface */ u.T = function () {};\\n\" +\n+        \"/** @type {number} */u.T.prototype.x = 1;\",\n+        \"interface members can only be plain functions\" +\n+        \" or goog.abstractMethod\");\n+  }\n+\n+  public void testWarnDataPropertyOnInterface4() throws Exception {\n+    testTypes(\"/** @interface */ function T() {};\\n\" +\n+        \"/** @type {number} */T.prototype.x = 1;\",\n+        \"interface members can only be plain functions\" +\n+        \" or goog.abstractMethod\");\n+  }\n+\n+  // TODO(user): If we want to support this syntax we should warn about the\n+  // mismatching types in the two tests below.\n+  //public void testErrorMismatchingPropertyOnInterface1() throws Exception {\n+  //  testTypes(\"/** @interface */ u.T = function () {};\\n\" +\n+  //      \"/** @param {Number} foo */u.T.prototype.x =\\n\" +\n+  //      \"/** @param {String} foo */function(foo) {};\",\n+  //      \"found   : \\n\" +\n+  //      \"required: \");\n+  //}\n+  //\n+  //public void testErrorMismatchingPropertyOnInterface2() throws Exception {\n+  //  testTypes(\"/** @interface */ function T() {};\\n\" +\n+  //      \"/** @return {number} */T.prototype.x =\\n\" +\n+  //      \"/** @return {string} */function() {};\",\n+  //      \"found   : \\n\" +\n+  //      \"required: \");\n+  //}\n+\n+  // TODO(user): We should warn about this (bar is missing an annotation). We\n+  // probably don't want to warn about all missing parameter annotations, but\n+  // we should be as strict as possible regarding interfaces.\n+  //public void testErrorMismatchingPropertyOnInterface3() throws Exception {\n+  //  testTypes(\"/** @interface */ u.T = function () {};\\n\" +\n+  //      \"/** @param {Number} foo */u.T.prototype.x =\\n\" +\n+  //      \"function(foo, bar) {};\",\n+  //      \"found   : \\n\" +\n+  //      \"required: \");\n+  //}\n+\n+  public void testErrorMismatchingPropertyOnInterface4() throws Exception {\n+    testTypes(\"/** @interface */ u.T = function () {};\\n\" +\n+        \"/** @param {Number} foo */u.T.prototype.x =\\n\" +\n+        \"function() {};\",\n+        \"parameter foo does not appear in u.T.prototype.x's parameter list\");\n+  }\n+\n+  public void testErrorMismatchingPropertyOnInterface5() throws Exception {\n+    testTypes(\"/** @interface */ function T() {};\\n\" +\n+        \"/** @type {number} */T.prototype.x = function() { };\",\n+        \"assignment to property x of T.prototype\\n\" +\n+        \"found   : function (): ?\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testErrorMismatchingPropertyOnInterface6() throws Exception {\n+    testTypes(\"/** @interface */ function T() {};\\n\" +\n+        \"/** @return {number} */T.prototype.x = 1\",\n+        \"interface members can only be plain functions or goog.abstractMethod\"\n+        );\n+  }\n+\n+  public void testInterfaceNonEmptyFunction() throws Exception {\n+    testTypes(\"/** @interface */ function T() {};\\n\" +\n+        \"T.prototype.x = function() { return 'foo'; }\",\n+        \"interface member functions must have an empty body\"\n+        );\n+  }\n+\n+  public void testDoubleNestedInterface() throws Exception {\n+    testTypes(\"/** @interface */ var I1 = function() {};\\n\" +\n+              \"/** @interface */ I1.I2 = function() {};\\n\" +\n+              \"/** @interface */ I1.I2.I3 = function() {};\\n\");\n+  }\n+\n+  public void testStaticDataPropertyOnNestedInterface() throws Exception {\n+    testTypes(\"/** @interface */ var I1 = function() {};\\n\" +\n+              \"/** @interface */ I1.I2 = function() {};\\n\" +\n+              \"/** @type {number} */ I1.I2.x = 1;\\n\");\n+  }\n+\n+  public void testInterfaceInstantiation() throws Exception {\n+    testTypes(\"/** @interface */var f; new f\",\n+              \"cannot instantiate non-constructor\");\n+  }\n+\n+  public void testPrototypeLoop() throws Exception {\n+    testTypes(\n+        suppressMissingProperty(\"foo\") +\n+        \"/** @constructor \\n * @extends {T} */var T = function() {};\" +\n+        \"alert((new T).foo);\",\n+        \"Parse error. Cycle detected in inheritance chain of type T\");\n+  }\n+\n+  public void testDirectPrototypeAssign() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @constructor */ function Bar() {}\" +\n+        \"/** @type {Array} */ Bar.prototype = new Foo()\",\n+        \"assignment to property prototype of Bar\\n\" +\n+        \"found   : Foo\\n\" +\n+        \"required: (Array|null)\");\n+  }\n+\n+  // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only\n+  // be resolved via the registry and not via properties.\n+\n+  public void testResolutionViaRegistry1() throws Exception {\n+    testTypes(\"/** @constructor */ u.T = function() {};\\n\" +\n+        \"/** @type {(number|string)} */ u.T.prototype.a;\\n\" +\n+        \"/**\\n\" +\n+        \"* @param {u.T} t\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/\\n\" +\n+        \"var f = function(t) { return t.a; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testResolutionViaRegistry2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ u.T = function() {\" +\n+        \"  this.a = 0; };\\n\" +\n+        \"/**\\n\" +\n+        \"* @param {u.T} t\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/\\n\" +\n+        \"var f = function(t) { return t.a; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testResolutionViaRegistry3() throws Exception {\n+    testTypes(\"/** @constructor */ u.T = function() {};\\n\" +\n+        \"/** @type {(number|string)} */ u.T.prototype.a = 0;\\n\" +\n+        \"/**\\n\" +\n+        \"* @param {u.T} t\\n\" +\n+        \"* @return {string}\\n\" +\n+        \"*/\\n\" +\n+        \"var f = function(t) { return t.a; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testResolutionViaRegistry4() throws Exception {\n+    testTypes(\"/** @constructor */ u.A = function() {};\\n\" +\n+        \"/**\\n* @constructor\\n* @extends {u.A}\\n*/\\nu.A.A = function() {}\\n;\" +\n+        \"/**\\n* @constructor\\n* @extends {u.A}\\n*/\\nu.A.B = function() {};\\n\" +\n+        \"var ab = new u.A.B();\\n\" +\n+        \"/** @type {!u.A} */ var a = ab;\\n\" +\n+        \"/** @type {!u.A.A} */ var aa = ab;\\n\",\n+        \"initializing variable\\n\" +\n+        \"found   : u.A.B\\n\" +\n+        \"required: u.A.A\");\n+  }\n+\n+  public void testResolutionViaRegistry5() throws Exception {\n+    Node n = parseAndTypeCheck(\"/** @constructor */ u.T = function() {}; u.T\");\n+    JSType type = n.getLastChild().getLastChild().getJSType();\n+    assertFalse(type.isUnknownType());\n+    assertTrue(type instanceof FunctionType);\n+    assertEquals(\"u.T\",\n+        ((FunctionType) type).getInstanceType().getReferenceName());\n+  }\n+\n+  public void testGatherProperyWithoutAnnotation1() throws Exception {\n+    Node n = parseAndTypeCheck(\"/** @constructor */ var T = function() {};\" +\n+        \"/** @type {!T} */var t; t.x; t;\");\n+    JSType type = n.getLastChild().getLastChild().getJSType();\n+    assertFalse(type.isUnknownType());\n+    assertTrue(type instanceof ObjectType);\n+    ObjectType objectType = (ObjectType) type;\n+    assertFalse(objectType.hasProperty(\"x\"));\n+    assertEquals(\n+        Sets.newHashSet(objectType),\n+        registry.getTypesWithProperty(\"x\"));\n+  }\n+\n+  public void testGatherProperyWithoutAnnotation2() throws Exception {\n+    Pair<Node, Scope> ns =\n+        parseAndTypeCheckWithScope(\"/** @type {!Object} */var t; t.x; t;\");\n+    Node n = ns.getFirst();\n+    Scope s = ns.getSecond();\n+    JSType type = n.getLastChild().getLastChild().getJSType();\n+    assertFalse(type.isUnknownType());\n+    assertEquals(type, OBJECT_TYPE);\n+    assertTrue(type instanceof ObjectType);\n+    ObjectType objectType = (ObjectType) type;\n+    assertFalse(objectType.hasProperty(\"x\"));\n+    assertEquals(\n+        Sets.newHashSet(OBJECT_TYPE),\n+        registry.getTypesWithProperty(\"x\"));\n+  }\n+\n+  public void testFunctionMasksVariableBug() throws Exception {\n+    testTypes(\"var x = 4; var f = function x(b) { return b ? 1 : x(true); };\",\n+        \"function x masks variable (IE bug)\");\n+  }\n+\n+  public void testDfa1() throws Exception {\n+    testTypes(\"var x = null;\\n x = 1;\\n /** @type number */ var y = x;\");\n+  }\n+\n+  public void testDfa2() throws Exception {\n+    testTypes(\"function u() {}\\n\" +\n+        \"/** @return {number} */ function f() {\\nvar x = 'todo';\\n\" +\n+        \"if (u()) { x = 1; } else { x = 2; } return x;\\n}\");\n+  }\n+\n+  public void testDfa3() throws Exception {\n+    testTypes(\"function u() {}\\n\" +\n+        \"/** @return {number} */ function f() {\\n\" +\n+        \"/** @type {number|string} */ var x = 'todo';\\n\" +\n+        \"if (u()) { x = 1; } else { x = 2; } return x;\\n}\");\n+  }\n+\n+  public void testDfa4() throws Exception {\n+    testTypes(\"/** @param {Date?} d */ function f(d) {\\n\" +\n+        \"if (!d) { return; }\\n\" +\n+        \"/** @type {!Date} */ var e = d;\\n}\");\n+  }\n+\n+  public void testDfa5() throws Exception {\n+    testTypes(\"/** @return {string?} */ function u() {return 'a';}\\n\" +\n+        \"/** @param {string?} x\\n@return {string} */ function f(x) {\\n\" +\n+        \"while (!x) { x = u(); }\\nreturn x;\\n}\");\n+  }\n+\n+  public void testDfa6() throws Exception {\n+    testTypes(\"/** @return {Object?} */ function u() {return {};}\\n\" +\n+        \"/** @param {Object?} x */ function f(x) {\\n\" +\n+        \"while (x) { x = u(); if (!x) { x = u(); } }\\n}\");\n+  }\n+\n+  public void testDfa7() throws Exception {\n+    testTypes(\"/** @constructor */ var T = function() {};\\n\" +\n+        \"/** @type {Date?} */ T.prototype.x = null;\\n\" +\n+        \"/** @param {!T} t */ function f(t) {\\n\" +\n+        \"if (!t.x) { return; }\\n\" +\n+        \"/** @type {!Date} */ var e = t.x;\\n}\");\n+  }\n+\n+  public void testDfa8() throws Exception {\n+    testTypes(\"/** @constructor */ var T = function() {};\\n\" +\n+        \"/** @type {number|string} */ T.prototype.x = '';\\n\" +\n+        \"function u() {}\\n\" +\n+        \"/** @param {!T} t\\n@return {number} */ function f(t) {\\n\" +\n+        \"if (u()) { t.x = 1; } else { t.x = 2; } return t.x;\\n}\");\n+  }\n+\n+  public void testDfa9() throws Exception {\n+    testTypes(\"function f() {\\n/** @type {string?} */var x;\\nx = null;\\n\" +\n+        \"if (x == null) { return 0; } else { return 1; } }\",\n+        \"condition always evaluates to true\\n\" +\n+        \"left : null\\n\" +\n+        \"right: null\");\n+  }\n+\n+  public void testDfa10() throws Exception {\n+    testTypes(\"/** @param {null} x */ function g(x) {}\" +\n+        \"/** @param {string?} x */function f(x) {\\n\" +\n+        \"if (!x) { x = ''; }\\n\" +\n+        \"if (g(x)) { return 0; } else { return 1; } }\",\n+        \"actual parameter 1 of g does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: null\");\n+  }\n+\n+  public void testDfa11() throws Exception {\n+    testTypes(\"/** @param {string} opt_x\\n@return {string} */\\n\" +\n+        \"function f(opt_x) { if (!opt_x) { \" +\n+        \"throw new Error('x cannot be empty'); } return opt_x; }\");\n+  }\n+\n+  public void testDfa12() throws Exception {\n+    testTypes(\"/** @param {string} x \\n * @constructor \\n */\" +\n+        \"var Bar = function(x) {};\" +\n+        \"/** @param {string} x */ function g(x) {}\" +\n+        \"/** @param {string|number} opt_x */ \" +\n+        \"function f(opt_x) { \" +\n+        \"  if (opt_x) { new Bar(g(opt_x) && 'x'); }\" +\n+        \"}\",\n+        \"actual parameter 1 of g does not match formal parameter\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testDfa13() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {string} x \\n\" +\n+        \" * @param {number} y \\n\" +\n+        \" * @param {number} z \\n\" +\n+        \" */\" +\n+        \"function g(x, y, z) {}\" +\n+        \"function f() { \" +\n+        \"  var x = 'a'; g(x, x = 3, x);\" +\n+        \"}\");\n+  }\n+\n+  public void testTypeInferenceWithCast1() throws Exception {\n+    testTypes(\n+        \"/**@return {(number,null,undefined)}*/function u(x) {return null;}\" +\n+        \"/**@param {number?} x\\n@return {number?}*/function f(x) {return x;}\" +\n+        \"/**@return {number?}*/function g(x) {\" +\n+        \"var y = /**@type {number?}*/(u(x)); return f(y);}\");\n+  }\n+\n+  public void testTypeInferenceWithCast2() throws Exception {\n+    testTypes(\n+        \"/**@return {(number,null,undefined)}*/function u(x) {return null;}\" +\n+        \"/**@param {number?} x\\n@return {number?}*/function f(x) {return x;}\" +\n+        \"/**@return {number?}*/function g(x) {\" +\n+        \"var y; y = /**@type {number?}*/(u(x)); return f(y);}\");\n+  }\n+\n+  public void testTypeInferenceWithCast3() throws Exception {\n+    testTypes(\n+        \"/**@return {(number,null,undefined)}*/function u(x) {return 1;}\" +\n+        \"/**@return {number}*/function g(x) {\" +\n+        \"return /**@type {number}*/(u(x));}\");\n+  }\n+\n+  public void testTypeInferenceWithCast4() throws Exception {\n+    testTypes(\n+        \"/**@return {(number,null,undefined)}*/function u(x) {return 1;}\" +\n+        \"/**@return {number}*/function g(x) {\" +\n+        \"return /**@type {number}*/(u(x)) && 1;}\");\n+  }\n+\n+  public void testTypeInferenceWithCast5() throws Exception {\n+    testTypes(\n+        \"/** @param {number} x */ function foo(x) {}\" +\n+        \"/** @param {{length:*}} y */ function bar(y) {\" +\n+        \"  /** @type {string} */ y.length;\" +\n+        \"  foo(y.length);\" +\n+        \"}\",\n+        \"actual parameter 1 of foo does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testTypeInferenceWithClosure1() throws Exception {\n+    testTypes(\n+        \"/** @return {boolean} */\" +\n+        \"function f() {\" +\n+        \"  /** @type {?string} */ var x = null;\" +\n+        \"  function g() { x = 'y'; } g(); \" +\n+        \"  return x == null;\" +\n+        \"}\");\n+  }\n+\n+  public void testTypeInferenceWithClosure2() throws Exception {\n+    testTypes(\n+        \"/** @return {boolean} */\" +\n+        \"function f() {\" +\n+        \"  /** @type {?string} */ var x = null;\" +\n+        \"  function g() { x = 'y'; } g(); \" +\n+        \"  return x === 3;\" +\n+        \"}\",\n+        \"condition always evaluates to the same value\\n\" +\n+        \"left : (null|string)\\n\" +\n+        \"right: number\");\n+  }\n+\n+  public void testForwardPropertyReference() throws Exception {\n+    testTypes(\"/** @constructor */ var Foo = function() { this.init(); };\" +\n+        \"/** @return {string} */\" +\n+        \"Foo.prototype.getString = function() {\" +\n+        \"  return this.number_;\" +\n+        \"};\" +\n+        \"Foo.prototype.init = function() {\" +\n+        \"  /** @type {number} */\" +\n+        \"  this.number_ = 3;\" +\n+        \"};\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testNoForwardTypeDeclaration() throws Exception {\n+    testTypes(\n+        \"/** @param {MyType} x */ function f(x) {}\",\n+        \"Parse error. Unknown type MyType\");\n+  }\n+\n+  public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {\n+    // To better support third-party code, we do not warn when\n+    // there are no braces around an unknown type name.\n+    testTypes(\"/** @return The result. */ function f() {}\");\n+  }\n+\n+  public void testForwardTypeDeclaration1() throws Exception {\n+    testClosureTypes(\n+        // malformed addDependency calls shouldn't cause a crash\n+        \"goog.addDependency();\" +\n+        \"goog.addDependency('y', [goog]);\" +\n+\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType} x \\n * @return {number} */\" +\n+        \"function f(x) { return x; }\", null);\n+  }\n+\n+  public void testForwardTypeDeclaration2() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType} x */ function f(x) { }\" +\n+        \"f(3);\", null);\n+  }\n+\n+  public void testForwardTypeDeclaration3() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MyType'], []);\" +\n+        \"/** @param {MyType} x */ function f(x) { return x; }\" +\n+        \"/** @constructor */ var MyType = function() {};\" +\n+        \"f(3);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: (MyType|null)\");\n+  }\n+\n+  public void testMalformedOldTypeDef() throws Exception {\n+    testTypes(\n+        \"var goog = {}; goog.typedef = true;\" +\n+        \"goog.Bar = goog.typedef\",\n+        \"Typedef for goog.Bar does not have any type information\");\n+  }\n+\n+  public void testDuplicateOldTypeDef() throws Exception {\n+    testTypes(\n+        \"var goog = {}; goog.typedef = true;\" +\n+        \"/** @constructor */ goog.Bar = function() {};\" +\n+        \"/** @type {number} */ goog.Bar = goog.typedef\",\n+        \"variable goog.Bar redefined with type number, \" +\n+        \"original definition at  [testcode] :1 \" +\n+        \"with type function (this:goog.Bar): ?\");\n+  }\n+\n+  public void testOldTypeDef1() throws Exception {\n+    testTypes(\n+        \"var goog = {}; goog.typedef = true;\" +\n+        \"/** @type {number} */ goog.Bar = goog.typedef;\" +\n+        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n+        \"f(3);\");\n+  }\n+\n+  public void testOldTypeDef2() throws Exception {\n+    testTypes(\n+        \"var goog = {}; goog.typedef = true;\" +\n+        \"/** @type {number} */ goog.Bar = goog.typedef;\" +\n+        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n+        \"f('3');\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testOldTypeDef3() throws Exception {\n+    testTypes(\n+        \"var goog = {}; goog.typedef = true;\" +\n+        \"/** @type {number} */ var Bar = goog.typedef;\" +\n+        \"/** @param {Bar} x */ function f(x) {}\" +\n+        \"f('3');\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testCircularOldTypeDef() throws Exception {\n+    testTypes(\n+        \"var goog = {}; goog.typedef = true;\" +\n+        \"/** @type {number|Array.<goog.Bar>} */ goog.Bar = goog.typedef;\" +\n+        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n+        \"f(3); f([3]); f([[3]]);\");\n+  }\n+\n+  public void testDuplicateTypeDef() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @constructor */ goog.Bar = function() {};\" +\n+        \"/** @typedef {number} */ goog.Bar;\",\n+        \"variable goog.Bar redefined with type None, \" +\n+        \"original definition at  [testcode] :1 \" +\n+        \"with type function (this:goog.Bar): ?\");\n+  }\n+\n+  public void testTypeDef1() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @typedef {number} */ goog.Bar;\" +\n+        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n+        \"f(3);\");\n+  }\n+\n+  public void testTypeDef2() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @typedef {number} */ goog.Bar;\" +\n+        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n+        \"f('3');\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testTypeDef3() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @typedef {number} */ var Bar;\" +\n+        \"/** @param {Bar} x */ function f(x) {}\" +\n+        \"f('3');\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testCircularTypeDef() throws Exception {\n+    testTypes(\n+        \"var goog = {};\" +\n+        \"/** @typedef {number|Array.<goog.Bar>} */ goog.Bar;\" +\n+        \"/** @param {goog.Bar} x */ function f(x) {}\" +\n+        \"f(3); f([3]); f([[3]]);\");\n+  }\n+\n+  public void testGetTypedPercent1() throws Exception {\n+    String js = \"var id = function(x) { return x; }\\n\" +\n+                \"var id2 = function(x) { return id(x); }\";\n+    assertEquals(50.0, getTypedPercent(js), 0.1);\n+  }\n+\n+  public void testGetTypedPercent2() throws Exception {\n+    String js = \"var x = {}; x.y = 1;\";\n+    assertEquals(100.0, getTypedPercent(js), 0.1);\n+  }\n+\n+  public void testGetTypedPercent3() throws Exception {\n+    String js = \"var f = function(x) { x.a = x.b; }\";\n+    assertEquals(50.0, getTypedPercent(js), 0.1);\n+  }\n+\n+  public void testGetTypedPercent4() throws Exception {\n+    String js = \"var n = {};\\n /** @constructor */ n.T = function() {};\\n\" +\n+        \"/** @type n.T */ var x = new n.T();\";\n+    assertEquals(100.0, getTypedPercent(js), 0.1);\n+  }\n+\n+  private double getTypedPercent(String js) throws Exception {\n+    Node n = compiler.parseTestCode(js);\n+\n+    Node externs = new Node(Token.BLOCK);\n+    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n+    externAndJsRoot.setIsSyntheticBlock(true);\n+\n+    TypeCheck t = makeTypeCheck();\n+    t.processForTesting(null, n);\n+    return t.getTypedPercent();\n+  }\n+\n+  private ObjectType getInstanceType(Node js1Node) {\n+    JSType type = js1Node.getFirstChild().getJSType();\n+    assertNotNull(type);\n+    assertTrue(type instanceof FunctionType);\n+    FunctionType functionType = (FunctionType) type;\n+    assertTrue(functionType.isConstructor());\n+    return functionType.getInstanceType();\n+  }\n+\n+  public void testPrototypePropertyReference() throws Exception {\n+    Pair<Node, Scope> p = parseAndTypeCheckWithScope(\"\"\n+        + \"/** @constructor */\\n\"\n+        + \"function Foo() {}\\n\"\n+        + \"/** @param {number} a */\\n\"\n+        + \"Foo.prototype.bar = function(a){};\\n\"\n+        + \"/** @param {Foo} f */\\n\"\n+        + \"function baz(f) {\\n\"\n+        + \"  Foo.prototype.bar.call(f, 3);\\n\"\n+        + \"}\");\n+    assertEquals(0, compiler.getErrorCount());\n+    assertEquals(0, compiler.getWarningCount());\n+\n+    assertTrue(p.second.getVar(\"Foo\").getType() instanceof FunctionType);\n+    FunctionType fooType = (FunctionType) p.second.getVar(\"Foo\").getType();\n+    assertEquals(\"function (this:Foo, number): ?\",\n+                 fooType.getPrototype().getPropertyType(\"bar\").toString());\n+  }\n+\n+  public void testResolvingNamedTypes() throws Exception {\n+    String js = \"\"\n+        + \"/** @constructor */\\n\"\n+        + \"var Foo = function() {}\\n\"\n+        + \"/** @param {number} a */\\n\"\n+        + \"Foo.prototype.foo = function(a) {\\n\"\n+        + \"  return this.baz().toString();\\n\"\n+        + \"};\\n\"\n+        + \"/** @return {Baz} */\\n\"\n+        + \"Foo.prototype.baz = function() { return new Baz(); };\\n\"\n+        + \"/** @constructor\\n\"\n+        + \"  * @extends Foo */\\n\"\n+        + \"var Bar = function() {};\"\n+        + \"/** @constructor */\\n\"\n+        + \"var Baz = function() {};\";\n+    assertEquals(100.0, getTypedPercent(js), 0.1);\n+  }\n+\n+  public void testMissingProperty1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() { return this.a; };\" +\n+        \"Foo.prototype.baz = function() { this.a = 3; };\");\n+  }\n+\n+  public void testMissingProperty2() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() { return this.a; };\" +\n+        \"Foo.prototype.baz = function() { this.b = 3; };\",\n+        \"Property a never defined on Foo\");\n+  }\n+\n+  public void testMissingProperty3() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() { return this.a; };\" +\n+        \"(new Foo).a = 3;\");\n+  }\n+\n+  public void testMissingProperty4() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() { return this.a; };\" +\n+        \"(new Foo).b = 3;\",\n+        \"Property a never defined on Foo\");\n+  }\n+\n+  public void testMissingProperty5() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() { return this.a; };\" +\n+        \"/** @constructor */ function Bar() { this.a = 3; };\",\n+        \"Property a never defined on Foo\");\n+  }\n+\n+  public void testMissingProperty6() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() { return this.a; };\" +\n+        \"/** @constructor \\n * @extends {Foo} */ \" +\n+        \"function Bar() { this.a = 3; };\");\n+  }\n+\n+  public void testMissingProperty7() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} obj */\" +\n+        \"function foo(obj) { return obj.impossible; }\",\n+        \"Property impossible never defined on Object\");\n+  }\n+\n+  public void testMissingProperty8() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} obj */\" +\n+        \"function foo(obj) { return typeof obj.impossible; }\");\n+  }\n+\n+  public void testMissingProperty9() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} obj */\" +\n+        \"function foo(obj) { if (obj.impossible) { return true; } }\");\n+  }\n+\n+  public void testMissingProperty10() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} obj */\" +\n+        \"function foo(obj) { while (obj.impossible) { return true; } }\");\n+  }\n+\n+  public void testMissingProperty11() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} obj */\" +\n+        \"function foo(obj) { for (;obj.impossible;) { return true; } }\");\n+  }\n+\n+  public void testMissingProperty12() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} obj */\" +\n+        \"function foo(obj) { do { } while (obj.impossible); }\");\n+  }\n+\n+  public void testMissingProperty13() throws Exception {\n+    testTypes(\n+        \"var goog = {}; goog.isDef = function(x) { return false; };\" +\n+        \"/** @param {Object} obj */\" +\n+        \"function foo(obj) { return goog.isDef(obj.impossible); }\");\n+  }\n+\n+  public void testMissingProperty14() throws Exception {\n+    testTypes(\n+        \"var goog = {}; goog.isDef = function(x) { return false; };\" +\n+        \"/** @param {Object} obj */\" +\n+        \"function foo(obj) { return goog.isNull(obj.impossible); }\",\n+        \"Property isNull never defined on goog\");\n+  }\n+\n+  public void testMissingProperty15() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} x */\" +\n+        \"function f(x) { if (x.foo) { x.foo(); } }\");\n+  }\n+\n+  public void testMissingProperty16() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} x */\" +\n+        \"function f(x) { x.foo(); if (x.foo) {} }\",\n+        \"Property foo never defined on Object\");\n+  }\n+\n+  public void testMissingProperty17() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} x */\" +\n+        \"function f(x) { if (typeof x.foo == 'function') { x.foo(); } }\");\n+  }\n+\n+  public void testMissingProperty18() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} x */\" +\n+        \"function f(x) { if (x.foo instanceof Function) { x.foo(); } }\");\n+  }\n+\n+  public void testMissingProperty19() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} x */\" +\n+        \"function f(x) { if (x.bar) { if (x.foo) {} } else { x.foo(); } }\",\n+        \"Property foo never defined on Object\");\n+  }\n+\n+  public void testMissingProperty20() throws Exception {\n+    // NOTE(nicksantos): In the else branch, we know that x.foo is a\n+    // CHECKED_UNKNOWN (UNKNOWN restricted to a falsey value). We could\n+    // do some more sophisticated analysis here. Obviously, if x.foo is false,\n+    // then x.foo cannot possibly be called. For example, you could imagine a\n+    // VagueType that was like UnknownType, but had some constraints on it\n+    // so that we knew it could never be a function.\n+    //\n+    // For now, we just punt on this issue.\n+    testTypes(\n+        \"/** @param {Object} x */\" +\n+        \"function f(x) { if (x.foo) { } else { x.foo(); } }\");\n+  }\n+\n+  public void testMissingProperty21() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} x */\" +\n+        \"function f(x) { x.foo && x.foo(); }\");\n+  }\n+\n+  public void testMissingProperty22() throws Exception {\n+    testTypes(\n+        \"/** @param {Object} x \\n * @return {boolean} */\" +\n+        \"function f(x) { return x.foo ? x.foo() : true; }\");\n+  }\n+\n+  public void testMissingProperty23() throws Exception {\n+    testTypes(\n+        \"function f(x) { x.impossible(); }\",\n+        \"Property impossible never defined on x\");\n+  }\n+\n+  public void testMissingProperty24() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MissingType'], []);\" +\n+        \"/** @param {MissingType} x */\" +\n+        \"function f(x) { x.impossible(); }\", null);\n+  }\n+\n+  public void testMissingProperty25() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {};\" +\n+        \"Foo.prototype.bar = function() {};\" +\n+        \"/** @constructor */ var FooAlias = Foo;\" +\n+        \"(new FooAlias()).bar();\");\n+  }\n+\n+  public void testMissingProperty26() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ var Foo = function() {};\" +\n+        \"/** @constructor */ var FooAlias = Foo;\" +\n+        \"FooAlias.prototype.bar = function() {};\" +\n+        \"(new Foo()).bar();\");\n+  }\n+\n+  public void testMissingProperty27() throws Exception {\n+    testClosureTypes(\n+        \"goog.addDependency('zzz.js', ['MissingType'], []);\" +\n+        \"/** @param {?MissingType} x */\" +\n+        \"function f(x) {\" +\n+        \"  for (var parent = x; parent; parent = parent.getParent()) {}\" +\n+        \"}\", null);\n+  }\n+\n+  public void testMissingProperty28() throws Exception {\n+    testTypes(\n+        \"function f(obj) {\" +\n+        \"  /** @type {*} */ obj.foo;\" +\n+        \"  return obj.foo;\" +\n+        \"}\");\n+    testTypes(\n+        \"function f(obj) {\" +\n+        \"  /** @type {*} */ obj.foo;\" +\n+        \"  return obj.foox;\" +\n+        \"}\",\n+        \"Property foox never defined on obj\");\n+  }\n+\n+  public void testMissingProperty29() throws Exception {\n+    // This used to emit a warning.\n+    testTypes(\n+        // externs\n+        \"/** @constructor */ var Foo;\" +\n+        \"Foo.prototype.opera;\" +\n+        \"Foo.prototype.opera.postError;\",\n+        \"\",\n+        null,\n+        false);\n+  }\n+\n+  public void testDeclaredNativeTypeEquality() throws Exception {\n+    Node n = parseAndTypeCheck(\"/** @constructor */ function Object() {};\");\n+    assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),\n+                 n.getFirstChild().getJSType());\n+  }\n+\n+  public void testUndefinedVar() throws Exception {\n+    Node n = parseAndTypeCheck(\"var undefined;\");\n+    assertEquals(registry.getNativeType(JSTypeNative.VOID_TYPE),\n+                 n.getFirstChild().getFirstChild().getJSType());\n+  }\n+\n+  public void testFlowScopeBug1() throws Exception {\n+    Node n = parseAndTypeCheck(\"/** @param {number} a \\n\"\n+        + \"* @param {number} b */\\n\"\n+        + \"function f(a, b) {\\n\"\n+        + \"/** @type number */\"\n+        + \"var i = 0;\"\n+        + \"for (; (i + a) < b; ++i) {}}\");\n+\n+    // check the type of the add node for i + f\n+    assertEquals(registry.getNativeType(JSTypeNative.NUMBER_TYPE),\n+        n.getFirstChild().getLastChild().getLastChild().getFirstChild()\n+        .getNext().getFirstChild().getJSType());\n+  }\n+\n+  public void testFlowScopeBug2() throws Exception {\n+    Node n = parseAndTypeCheck(\"/** @constructor */ function Foo() {};\\n\"\n+        + \"Foo.prototype.hi = false;\"\n+        + \"function foo(a, b) {\\n\"\n+        + \"  /** @type Array */\"\n+        + \"  var arr;\"\n+        + \"  /** @type number */\"\n+        + \"  var iter;\"\n+        + \"  for (iter = 0; iter < arr.length; ++ iter) {\"\n+        + \"    /** @type Foo */\"\n+        + \"    var afoo = arr[iter];\"\n+        + \"    afoo;\"\n+        + \"  }\"\n+        + \"}\");\n+\n+    // check the type of afoo when referenced\n+    assertEquals(registry.createNullableType(registry.getType(\"Foo\")),\n+        n.getLastChild().getLastChild().getLastChild().getLastChild()\n+        .getLastChild().getLastChild().getJSType());\n+  }\n+\n+  public void testAddSingletonGetter() {\n+    Node n = parseAndTypeCheck(\n+        \"/** @constructor */ function Foo() {};\\n\" +\n+        \"goog.addSingletonGetter(Foo);\");\n+    ObjectType o = (ObjectType) n.getFirstChild().getJSType();\n+    assertEquals(\"function (): Foo\",\n+        o.getPropertyType(\"getInstance\").toString());\n+    assertEquals(\"Foo\", o.getPropertyType(\"instance_\").toString());\n+  }\n+\n+  public void testTypeCheckStandaloneAST() throws Exception {\n+    Node n = compiler.parseTestCode(\"function Foo() { }\");\n+    typeCheck(n);\n+    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);\n+    Scope topScope = scopeCreator.createScope(n, null);\n+\n+    Node second = compiler.parseTestCode(\"new Foo\");\n+\n+    Node externs = new Node(Token.BLOCK);\n+    Node externAndJsRoot = new Node(Token.BLOCK, externs, second);\n+    externAndJsRoot.setIsSyntheticBlock(true);\n+\n+    new TypeCheck(\n+        compiler,\n+        new SemanticReverseAbstractInterpreter(\n+            compiler.getCodingConvention(), registry),\n+        registry, topScope, scopeCreator, CheckLevel.WARNING, CheckLevel.OFF)\n+        .process(null, second);\n+\n+    assertEquals(1, compiler.getWarningCount());\n+    assertEquals(\"cannot instantiate non-constructor\",\n+        compiler.getWarnings()[0].description);\n+  }\n+\n+  public void testBadTemplateType1() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \"* @param {T} x\\n\" +\n+        \"* @param {T} y\\n\" +\n+        \"* @param {function(this:T, ...)} z\\n\" +\n+        \"* @template T\\n\" +\n+        \"*/\\n\" +\n+        \"function f(x, y, z) {}\\n\" +\n+        \"f(this, this, function() {});\",\n+        FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(), true);\n+  }\n+\n+  public void testBadTemplateType2() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \"* @param {T} x\\n\" +\n+        \"* @param {function(this:T, ...)} y\\n\" +\n+        \"* @template T\\n\" +\n+        \"*/\\n\" +\n+        \"function f(x, y) {}\\n\" +\n+        \"f(0, function() {});\",\n+        TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(), true);\n+  }\n+\n+  public void testBadTemplateType3() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \" * @param {T} x\\n\" +\n+        \" * @template T\\n\" +\n+        \"*/\\n\" +\n+        \"function f(x) {}\\n\" +\n+        \"f(this);\",\n+        TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(), true);\n+  }\n+\n+  public void testBadTemplateType4() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \"* @template T\\n\" +\n+        \"*/\\n\" +\n+        \"function f() {}\\n\" +\n+        \"f();\",\n+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);\n+  }\n+\n+  public void testBadTemplateType5() throws Exception {\n+    testTypes(\n+        \"/**\\n\" +\n+        \"* @template T\\n\" +\n+        \"* @return {T}\\n\" +\n+        \"*/\\n\" +\n+        \"function f() {}\\n\" +\n+        \"f();\",\n+        FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(), true);\n+  }\n+\n+  private void checkObjectType(ObjectType objectType, String propertyName,\n+        JSType expectedType) {\n+    assertTrue(\"Expected \" + objectType.getReferenceName() +\n+        \" to have property \" +\n+        propertyName, objectType.hasProperty(propertyName));\n+    assertEquals(\"Expected \" + objectType.getReferenceName() +\n+        \"'s property \" +\n+        propertyName + \" to have type \" + expectedType,\n+        expectedType, objectType.getPropertyType(propertyName));\n+  }\n+\n+  private void testTypes(String js) throws Exception {\n+    testTypes(js, (String) null);\n+  }\n+\n+  private void testTypes(String js, String description) throws Exception {\n+    testTypes(js, description, false);\n+  }\n+\n+  private void testTypes(String js, DiagnosticType type) throws Exception {\n+    testTypes(js, type.format(), false);\n+  }\n+\n+  private void testClosureTypes(String js, String description)\n+      throws Exception {\n+    Node n = compiler.parseTestCode(js);\n+    Node externs = new Node(Token.BLOCK);\n+    Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n+    externAndJsRoot.setIsSyntheticBlock(true);\n+\n+    assertEquals(\"parsing error: \" +\n+        Join.join(\", \", compiler.getErrors()), 0, compiler.getErrorCount());\n+\n+    // For processing goog.addDependency for forward typedefs.\n+    new ProcessClosurePrimitives(compiler, CheckLevel.ERROR, true)\n+        .process(null, n);\n+\n+    CodingConvention convention = compiler.getCodingConvention();\n+    new TypeCheck(compiler,\n+        new ClosureReverseAbstractInterpreter(\n+            convention, registry).append(\n+                new SemanticReverseAbstractInterpreter(\n+                    convention, registry))\n+            .getFirst(),\n+        registry)\n+        .processForTesting(null, n);\n+\n+    assertEquals(0, compiler.getErrorCount());\n+\n+    if (description == null) {\n+      assertEquals(\n+          \"unexpected warning(s) : \" + Join.join(\", \", compiler.getWarnings()),\n+          0, compiler.getWarningCount());\n+    } else {\n+      assertEquals(1, compiler.getWarningCount());\n+      assertEquals(description, compiler.getWarnings()[0].description);\n+    }\n+  }\n+\n+  void testTypes(String js, String description, boolean isError)\n+      throws Exception {\n+    testTypes(DEFAULT_EXTERNS, js, description, isError);\n+  }\n+\n+  void testTypes(String externs, String js, String description, boolean isError)\n+      throws Exception {\n+    Node n = parseAndTypeCheck(externs, js);\n+\n+    JSError[] errors = compiler.getErrors();\n+    if (description != null && isError) {\n+      assertTrue(\"expected an error\", errors.length > 0);\n+      assertEquals(description, errors[0].description);\n+      errors = Arrays.asList(errors).subList(1, errors.length).toArray(\n+          new JSError[errors.length - 1]);\n+    }\n+    if (errors.length > 0) {\n+      fail(\"unexpected error(s):\\n\" + Join.join(\"\\n\", errors));\n+    }\n+\n+    JSError[] warnings = compiler.getWarnings();\n+    if (description != null && !isError) {\n+      assertTrue(\"expected a warning\", warnings.length > 0);\n+      assertEquals(description, warnings[0].description);\n+      warnings = Arrays.asList(warnings).subList(1, warnings.length).toArray(\n+          new JSError[warnings.length - 1]);\n+    }\n+    if (warnings.length > 0) {\n+      fail(\"unexpected warnings(s):\\n\" + Join.join(\"\\n\", warnings));\n+    }\n+  }\n+\n+  /**\n+   * Parses and type checks the JavaScript code.\n+   */\n+  private Node parseAndTypeCheck(String js) {\n+    return parseAndTypeCheck(DEFAULT_EXTERNS, js);\n+  }\n+\n+  private Node parseAndTypeCheck(String externs, String js) {\n+    return parseAndTypeCheckWithScope(externs, js).getFirst();\n+  }\n+\n+  /**\n+   * Parses and type checks the JavaScript code and returns the Scope used\n+   * whilst type checking.\n+   */\n+  private Pair<Node, Scope> parseAndTypeCheckWithScope(String js) {\n+    return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js);\n+  }\n+\n+  private Pair<Node, Scope> parseAndTypeCheckWithScope(String externs,\n+                                                       String js) {\n+    Node externsNode = compiler.parseTestCode(externs);\n+    Node n = compiler.parseTestCode(js);\n+    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n+    externAndJsRoot.setIsSyntheticBlock(true);\n+\n+    assertEquals(\"parsing error: \" +\n+        Join.join(\", \", compiler.getErrors()), 0, compiler.getErrorCount());\n+\n+    Scope s = makeTypeCheck().processForTesting(externsNode, n);\n+    return new Pair<Node, Scope>(n, s);\n+  }\n+\n+  private Node typeCheck(Node n) {\n+    Node externsNode = new Node(Token.BLOCK);\n+    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n+    externAndJsRoot.setIsSyntheticBlock(true);\n+\n+    makeTypeCheck().processForTesting(null, n);\n+    return n;\n+  }\n+\n+  private TypeCheck makeTypeCheck() {\n+    return new TypeCheck(\n+        compiler,\n+        new SemanticReverseAbstractInterpreter(\n+            compiler.getCodingConvention(), registry),\n+        registry);\n+  }\n+\n+  void testTypes(String js, String[] warnings) throws Exception {\n+    Node n = compiler.parseTestCode(js);\n+    assertEquals(0, compiler.getErrorCount());\n+    Node externsNode = new Node(Token.BLOCK);\n+    Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n+\n+    makeTypeCheck().processForTesting(null, n);\n+    assertEquals(0, compiler.getErrorCount());\n+    if (warnings != null) {\n+      assertEquals(warnings.length, compiler.getWarningCount());\n+      JSError[] messages = compiler.getWarnings();\n+      for (int i = 0; i < warnings.length && i < compiler.getWarningCount();\n+           i++) {\n+        assertEquals(warnings[i], messages[i].description);\n+      }\n+    } else {\n+      assertEquals(0, compiler.getWarningCount());\n+    }\n+  }\n+\n+  String suppressMissingProperty(String ... props) {\n+    String result = \"function dummy(x) { \";\n+    for (String prop : props) {\n+      result += \"x.\" + prop + \" = 3;\";\n+    }\n+    return result + \"}\";\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertTrue(externProto.isPropertyInExterns(\"foo\"));\n   }\n \n+  public void testPropertyInExterns1() {\n+    testSame(\n+        \"/** @constructor */ function Extern() {}\" +\n+        \"/** @type {Extern} */ var extern;\" +\n+        \"/** @return {number} */ extern.one;\",\n+        \"/** @constructor */ function Normal() {}\" +\n+        \"/** @type {Normal} */ var normal;\" +\n+        \"/** @return {number} */ normal.one;\", null);\n+\n+    JSType e = globalScope.getVar(\"Extern\").getType();\n+    ObjectType externInstance = ((FunctionType) e).getInstanceType();\n+    assertTrue(externInstance.hasOwnProperty(\"one\"));\n+    assertTrue(externInstance.isPropertyTypeDeclared(\"one\"));\n+    assertTypeEquals(\"function (): number\",\n+        externInstance.getPropertyType(\"one\"));\n+\n+    JSType n = globalScope.getVar(\"Normal\").getType();\n+    ObjectType normalInstance = ((FunctionType) n).getInstanceType();\n+    assertFalse(normalInstance.hasOwnProperty(\"one\"));\n+  }\n+\n+  public void testPropertyInExterns2() {\n+    testSame(\n+        \"/** @type {Object} */ var extern;\" +\n+        \"/** @return {number} */ extern.one;\",\n+        \"/** @type {Object} */ var normal;\" +\n+        \"/** @return {number} */ normal.one;\", null);\n+\n+    JSType e = globalScope.getVar(\"extern\").getType();\n+    assertFalse(e.dereference().hasOwnProperty(\"one\"));\n+\n+    JSType normal = globalScope.getVar(\"normal\").getType();\n+    assertFalse(normal.dereference().hasOwnProperty(\"one\"));\n+  }\n+\n+  public void testPropertyInExterns3() {\n+    testSame(\n+        \"/** @constructor \\n * @param {*} x */ function Object(x) {}\" +\n+        \"/** @type {number} */ Object.one;\", null);\n+\n+    ObjectType obj = globalScope.getVar(\"Object\").getType().dereference();\n+    assertTrue(obj.hasOwnProperty(\"one\"));\n+    assertTypeEquals(\"number\", obj.getPropertyType(\"one\"));\n+  }\n+\n   public void testTypedStubsInExterns() {\n     testSame(\n         \"/** @constructor \\n * @param {*} var_args */ \" +\n   private ObjectType getNativeObjectType(JSTypeNative type) {\n     return (ObjectType) registry.getNativeType(type);\n   }\n+\n+  private void assertTypeEquals(String s, JSType type) {\n+    assertEquals(s, type.toString());\n+  }\n }", "timestamp": 1262636301, "metainfo": ""}