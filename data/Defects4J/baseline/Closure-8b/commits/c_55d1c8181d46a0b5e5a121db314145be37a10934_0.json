{"sha": "55d1c8181d46a0b5e5a121db314145be37a10934", "log": "Change on 2010/05/14 by nick          update maps api v3. fixes issue 153.         contributed by chad killingsworth          R=alan         DELTA=403  (309 added, 71 deleted, 23 changed)  Change on 2010/05/14 by alan          Temporary rename variables to L_0 when gathering name usages.          R=nick         DELTA=46  (27 added, 5 deleted, 14 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=1003   ", "commit": "\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n \n package com.google.javascript.jscomp;\n \n-import javax.annotation.Nullable;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import javax.annotation.Nullable;\n \n \n /**\n \n   /** List of local NAME nodes */\n   private final ArrayList<Node> localNameNodes = new ArrayList<Node>();\n-\n-  /** List of local names that corresponds to the localNameNodes */\n-  private final ArrayList<String> localTempNames = new ArrayList<String>();\n+  \n+  /**\n+   * Maps a name node to its pseudo name, null if we are not generating so\n+   * there will not no overhead unless we are debugging.\n+   */\n+  private final Map<Node, String> pseudoNameMap;\n \n   /** Set of extern variable names */\n   private final Set<String> externNames = new HashSet<String>();\n    * @see NameAnonymousFunctions\n    */\n   private boolean preserveFunctionExpressionNames;\n-\n-  /** Generate pseudo names for variables for debugging purposes */\n-  private boolean generatePseudoNames;\n \n   /** Characters that shouldn't be used in variable names. */\n   private final char[] reservedCharacters;\n     this.prefix = prefix == null ? \"\" : prefix;\n     this.localRenamingOnly = localRenamingOnly;\n     this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n-    this.generatePseudoNames = generatePseudoNames;\n+    if (generatePseudoNames) {\n+      this.pseudoNameMap = Maps.newHashMap();\n+    } else {\n+      this.pseudoNameMap = null;\n+    }\n     this.prevUsedRenameMap = prevUsedRenameMap;\n     this.reservedCharacters = reservedCharacters;\n     if (reservedNames == null) {\n         return;\n       }\n \n+      if (pseudoNameMap != null) {\n+        recordPseudoName(n);\n+      }\n+      \n       if (local) {\n         // Local var: assign a new name\n         String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n-        localTempNames.add(tempName);\n+        n.setString(tempName);\n       } else if (var != null) {  // Not an extern\n         // If it's global, increment global count\n         incCount(name, var.input);\n     // Rename the locals!\n     int count = 0;\n     for (Node n : localNameNodes) {\n-      String newName = getNewLocalName(n, count);\n+      String newName = getNewLocalName(n);\n       if (newName != null) {\n         n.setString(newName);\n         changed = true;\n     String oldName = n.getString();\n     Assignment a = assignments.get(oldName);\n     if (a.newName != null && !a.newName.equals(oldName)) {\n-      if (generatePseudoNames) {\n-        return getPseudoName(oldName);\n+      if (pseudoNameMap != null) {\n+        return pseudoNameMap.get(n);\n       }\n       return a.newName;\n     } else {\n     }\n   }\n \n-  private String getNewLocalName(Node n, int index) {\n-    String oldTempName = localTempNames.get(index);\n+  private String getNewLocalName(Node n) {\n+    String oldTempName = n.getString();\n     Assignment a = assignments.get(oldTempName);\n     if (!a.newName.equals(oldTempName)) {\n-      if (generatePseudoNames) {\n-        return getPseudoName(n.getString());\n+      if (pseudoNameMap != null) {\n+        return pseudoNameMap.get(n);\n       }\n       return a.newName;\n     }\n     return null;\n   }\n \n-  private String getPseudoName(String s) {\n-    Preconditions.checkState(generatePseudoNames);\n+  private void recordPseudoName(Node n) {\n     // Variable names should be in a different name space than\n     // property pseudo names.\n-    return '$' + s + \"$$\";\n+    pseudoNameMap.put(n, '$' + n.getString() + \"$$\" );\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n     generatePseudoNames = true;\n     test(\"var foo = function(a, b, c){}\",\n          \"var $foo$$ = function($a$$, $b$$, $c$$){}\");\n+    \n+    test(\"var a = function(a, b, c){}\",\n+         \"var $a$$ = function($a$$, $b$$, $c$$){}\");\n   }\n \n   private void testRenameMapUsingOldMap(String input, String expected,", "timestamp": 1273888960, "metainfo": ""}