{"sha": "2ea78e73e6ace693e18d535560606dfd49c3f9bc", "log": "Clean up type discovery by refactoring to the following algorithm. 1) When we see a function literal, create the authoritative type for it. 2) When we see an object literal, create the authoritative type for it. 3) When we declare a symbol, check to see if it's assigned to an object or function literal, and use that type if it make sense to do so. Otherwise, fall back on the JSDoc info. This should make it a lot easier to give accurate types to object literal properties. I didn't intend to create any functional changes in this CL, but some minor ones were inevitable.  R=johnlenz DELTA=618  (320 added, 249 deleted, 49 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=392   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n    * @param type The type of this.\n    */\n   FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {\n-    ObjectType objType = ObjectType.cast(type);\n-    if (objType != null && (info == null || !info.hasType())) {\n-      thisType = objType;\n-    }\n+    // Look at the @this annotation first.\n+    inferThisType(info, (Node) null);\n+\n+    if (thisType == null) {\n+      ObjectType objType = ObjectType.cast(type);\n+      if (objType != null && (info == null || !info.hasType())) {\n+        thisType = objType;\n+      }\n+    }\n+\n     return this;\n   }\n \n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n             nonExternFunctions.add(n);\n           }\n \n-          // VARs and ASSIGNs are handled in different branches of this\n-          // switch statement.\n-          if (parent.getType() != Token.ASSIGN &&\n-              parent.getType() != Token.NAME) {\n-            defineDeclaredFunction(n, parent);\n-          }\n-\n+          defineFunctionLiteral(n, parent);\n           break;\n \n         case Token.ASSIGN:\n-          // Handle constructor and enum definitions.\n-          defineNamedTypeAssign(n, parent);\n-\n           // Handle initialization of properties.\n           Node firstChild = n.getFirstChild();\n           if (firstChild.getType() == Token.GETPROP &&\n           break;\n \n         case Token.OBJECTLIT:\n-          processObjectLit(t, n);\n+          defineObjectLiteral(t, n);\n           break;\n \n           // NOTE(nicksantos): If we ever support Array tuples,\n       }\n     }\n \n-    private void processObjectLit(NodeTraversal t, Node objectLit) {\n+    private void defineObjectLiteral(NodeTraversal t, Node objectLit) {\n+      // Handle the @lends annotation.\n+      JSType type = null;\n       JSDocInfo info = objectLit.getJSDocInfo();\n       if (info != null &&\n           info.getLendsName() != null) {\n           compiler.report(\n               JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName));\n         } else {\n-          JSType type = lendsVar.getType();\n+          type = lendsVar.getType();\n           if (type == null) {\n             type = typeRegistry.getNativeType(UNKNOWN_TYPE);\n           }\n             compiler.report(\n                 JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT,\n                     lendsName, type.toString()));\n+            type = null;\n           } else {\n             objectLit.setJSType(type);\n           }\n         }\n       }\n \n-      if (objectLit.getJSType() == null) {\n-        objectLit.setJSType(typeRegistry.createAnonymousObjectType());\n-      }\n+      info = getBestJSDocInfo(objectLit);\n+      Node lValue = getBestLValue(objectLit);\n+      String lValueName = getBestLValueName(lValue);\n+      if (info != null && info.hasEnumParameterType()) {\n+        type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue);\n+      }\n+\n+      if (type == null) {\n+        type = typeRegistry.createAnonymousObjectType();\n+      }\n+\n+      setDeferredType(objectLit, type);\n \n       processObjectLitProperties(\n           t, objectLit, ObjectType.cast(objectLit.getJSType()));\n           jsType = info.getType().evaluate(scope, typeRegistry);\n         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n           String fnName = node.getQualifiedName();\n-\n-          // constructors are often handled separately.\n-          if (info.isConstructor() && typeRegistry.getType(fnName) != null) {\n-            return null;\n+          jsType = createFunctionTypeFromNodes(\n+              null, fnName, info, node);\n+        }\n+      }\n+      return jsType;\n+    }\n+\n+    /**\n+     * Asserts that it's ok to define this node's name.\n+     * The node should have a source name and be of the specified type.\n+     */\n+    void assertDefinitionNode(Node n, int type) {\n+      Preconditions.checkState(sourceName != null);\n+      Preconditions.checkState(n.getType() == type);\n+    }\n+\n+    /**\n+     * Defines a catch parameter.\n+     */\n+    void defineCatch(Node n, Node parent) {\n+      assertDefinitionNode(n, Token.CATCH);\n+      Node catchName = n.getFirstChild();\n+      defineSlot(catchName, n, null);\n+    }\n+\n+    /**\n+     * Defines a VAR initialization.\n+     */\n+    void defineVar(Node n, Node parent) {\n+      assertDefinitionNode(n, Token.VAR);\n+      JSDocInfo info = n.getJSDocInfo();\n+      if (n.hasMoreThanOneChild()) {\n+        if (info != null) {\n+          // multiple children\n+          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n+        }\n+        for (Node name : n.children()) {\n+          defineName(name, n, parent, name.getJSDocInfo());\n+        }\n+      } else {\n+        Node name = n.getFirstChild();\n+        defineName(name, n, parent,\n+            (info != null) ? info : name.getJSDocInfo());\n+      }\n+    }\n+\n+    /**\n+     * Defines a function literal.\n+     */\n+    void defineFunctionLiteral(Node n, Node parent) {\n+      assertDefinitionNode(n, Token.FUNCTION);\n+\n+      // Determine the name and JSDocInfo and lvalue for the function.\n+      // Any of these may be null.\n+      Node lValue = getBestLValue(n);\n+      JSDocInfo info = getBestJSDocInfo(n);\n+      String functionName = getBestLValueName(lValue);\n+      FunctionType functionType =\n+          createFunctionTypeFromNodes(n, functionName, info, lValue);\n+\n+      // Assigning the function type to the function node\n+      setDeferredType(n, functionType);\n+\n+      // Declare this symbol in the current scope iff it's a function\n+      // declaration. Otherwise, the declaration will happen in other\n+      // code paths.\n+      if (NodeUtil.isFunctionDeclaration(n)) {\n+        defineSlot(n.getFirstChild(), n, functionType);\n+      }\n+    }\n+\n+    /**\n+     * Defines a variable based on the {@link Token#NAME} node passed.\n+     * @param name The {@link Token#NAME} node.\n+     * @param var The parent of the {@code name} node, which must be a\n+     *     {@link Token#VAR} node.\n+     * @param parent {@code var}'s parent.\n+     * @param info the {@link JSDocInfo} information relating to this\n+     *     {@code name} node.\n+     */\n+    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n+      Node value = name.getFirstChild();\n+\n+      // variable's type\n+      JSType type = null;\n+\n+      // If a variable is assigned a function in the global scope,\n+      // make that a declared type (even if there's no doc info).\n+      // There's only one exception to this rule:\n+      // if the return type is inferred, and we're in a local\n+      // scope, we should assume the whole function is inferred.\n+      if (value != null && value.getType() == Token.FUNCTION) {\n+        FunctionType valueType = (FunctionType) value.getJSType();\n+        if (info != null || scope.isGlobal() ||\n+            !valueType.isReturnTypeInferred()) {\n+          type = value.getJSType();\n+        }\n+      }\n+\n+      if (type == null) {\n+        if (info == null) {\n+          // the variable's type will be inferred\n+          CompilerInput input = compiler.getInput(sourceName);\n+          Preconditions.checkNotNull(input, sourceName);\n+          type = input.isExtern() ?\n+              getNativeType(UNKNOWN_TYPE) : null;\n+        } else if (info.hasEnumParameterType()) {\n+          if (value != null && value.getType() == Token.OBJECTLIT) {\n+            // If this is an object literal, than an enum type\n+            // has already been created for it.\n+            type = value.getJSType();\n+          } else {\n+            type = createEnumTypeFromNodes(\n+                value, name.getString(), info, name);\n+          }\n+        } else if (info.isConstructor()) {\n+          type = createFunctionTypeFromNodes(\n+              value, name.getString(), info, name);\n+        } else {\n+          type = getDeclaredTypeInAnnotation(sourceName, name, info);\n+        }\n+      }\n+\n+      defineSlot(name, var, type);\n+    }\n+\n+    /**\n+     * Creates a new function type, based on the given nodes.\n+     *\n+     * This handles two cases that are semantically very different, but\n+     * are not mutually exclusive:\n+     * - A function literal that needs a type attached to it.\n+     * - An assignment expression with function-type info in the jsdoc.\n+     *\n+     * All parameters are optional, and we will do the best we can to create\n+     * a function type.\n+     *\n+     * This function will always create a function type, so only call it if\n+     * you're sure that's what you want.\n+     *\n+     * @param rValue The function node.\n+     * @param name the function's name\n+     * @param info the {@link JSDocInfo} attached to the function definition\n+     * @param lvalueNode The node where this function is being\n+     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n+     *     determine that this function is a method of A.prototype. May be\n+     *     null to indicate that this is not being assigned to a qualified name.\n+     */\n+    private FunctionType createFunctionTypeFromNodes(\n+        @Nullable Node rValue,\n+        @Nullable String name,\n+        @Nullable JSDocInfo info,\n+        @Nullable Node lvalueNode) {\n+\n+      FunctionType functionType = null;\n+\n+      // Global ctor aliases should be registered with the type registry.\n+      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n+        Var var = scope.getVar(rValue.getQualifiedName());\n+        if (var != null && var.getType() instanceof FunctionType) {\n+          FunctionType aliasedType  = (FunctionType) var.getType();\n+          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n+              !aliasedType.isNativeObjectType()) {\n+            functionType = aliasedType;\n+\n+            if (name != null && scope.isGlobal()) {\n+              typeRegistry.declareType(name, functionType.getInstanceType());\n+            }\n+          }\n+        }\n+      }\n+\n+      if (functionType == null) {\n+        Node errorRoot = rValue == null ? lvalueNode : rValue;\n+        boolean isFnLiteral =\n+            rValue != null && rValue.getType() == Token.FUNCTION;\n+        Node fnRoot = isFnLiteral ? rValue : null;\n+        Node parametersNode = isFnLiteral ?\n+            rValue.getFirstChild().getNext() : null;\n+        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n+\n+        if (info != null && info.hasType()) {\n+          JSType type = info.getType().evaluate(scope, typeRegistry);\n+\n+          // Known to be not null since we have the FUNCTION token there.\n+          type = type.restrictByNotNullOrUndefined();\n+          if (type.isFunctionType()) {\n+            functionType = (FunctionType) type;\n+            functionType.setJSDocInfo(info);\n+          }\n+        }\n+\n+        if (functionType == null) {\n+          // Find the type of any overridden function.\n+          FunctionType overriddenPropType = null;\n+          if (lvalueNode != null &&\n+              lvalueNode.getType() == Token.GETPROP &&\n+              lvalueNode.isQualifiedName()) {\n+            Var var = scope.getVar(\n+                lvalueNode.getFirstChild().getQualifiedName());\n+            if (var != null) {\n+              ObjectType ownerType = ObjectType.cast(var.getType());\n+              if (ownerType != null) {\n+                String propName = lvalueNode.getLastChild().getString();\n+                overriddenPropType = findOverriddenFunction(ownerType, propName);\n+              }\n+            }\n           }\n \n           FunctionTypeBuilder builder =\n-              new FunctionTypeBuilder(\n-                  fnName, compiler, node, sourceName, scope)\n+              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n+                  scope)\n+              .setSourceNode(fnRoot)\n+              .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n               .inferTemplateTypeName(info)\n               .inferReturnType(info)\n-              .inferParameterTypes(info)\n               .inferInheritance(info);\n \n           // Infer the context type.\n           boolean searchedForThisType = false;\n-          if (objNode != null) {\n+          if (lvalueNode != null &&\n+              lvalueNode.getType() == Token.GETPROP) {\n+            Node objNode = lvalueNode.getFirstChild();\n             if (objNode.getType() == Token.GETPROP &&\n                 objNode.getLastChild().getString().equals(\"prototype\")) {\n               builder.inferThisType(info, objNode.getFirstChild());\n             builder.inferThisType(info, (Node) null);\n           }\n \n-          jsType = builder.buildAndRegister();\n-        }\n-      }\n-      return jsType;\n-    }\n-\n-    /**\n-     * Asserts that it's ok to define this node's name.\n-     * The node should have a source name and be of the specified type.\n-     */\n-    void assertDefinitionNode(Node n, int type) {\n-      Preconditions.checkState(sourceName != null);\n-      Preconditions.checkState(n.getType() == type);\n-    }\n-\n-    /**\n-     * Defines a catch parameter.\n-     */\n-    void defineCatch(Node n, Node parent) {\n-      assertDefinitionNode(n, Token.CATCH);\n-      Node catchName = n.getFirstChild();\n-      defineSlot(catchName, n, null);\n-    }\n-\n-    /**\n-     * Defines a VAR initialization.\n-     */\n-    void defineVar(Node n, Node parent) {\n-      assertDefinitionNode(n, Token.VAR);\n-      JSDocInfo info = n.getJSDocInfo();\n-      if (n.hasMoreThanOneChild()) {\n-        if (info != null) {\n-          // multiple children\n-          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n-        }\n-        for (Node name : n.children()) {\n-          defineName(name, n, parent, name.getJSDocInfo());\n-        }\n-      } else {\n-        Node name = n.getFirstChild();\n-        defineName(name, n, parent,\n-            (info != null) ? info : name.getJSDocInfo());\n-      }\n-    }\n-\n-    /**\n-     * Defines a declared function.\n-     */\n-    void defineDeclaredFunction(Node n, Node parent) {\n-      assertDefinitionNode(n, Token.FUNCTION);\n-\n-      JSDocInfo info = n.getJSDocInfo();\n-      int parentType = parent.getType();\n-      Preconditions.checkState(\n-          (scope.isLocal() || parentType != Token.ASSIGN) &&\n-          parentType != Token.NAME,\n-          \"function defined as standalone function when it is being \" +\n-          \"assigned\");\n-      String functionName = n.getFirstChild().getString();\n-      FunctionType functionType = getFunctionType(functionName, n, info,\n-          null);\n-      if (NodeUtil.isFunctionDeclaration(n)) {\n-        defineSlot(n.getFirstChild(), n, functionType);\n-      }\n-    }\n-\n-    /**\n-     * Defines a qualified name assign to an enum or constructor.\n-     */\n-    void defineNamedTypeAssign(Node n, Node parent) {\n-      assertDefinitionNode(n, Token.ASSIGN);\n-      JSDocInfo info = n.getJSDocInfo();\n-\n-      // TODO(nicksantos): We should support direct assignment to a\n-      // prototype, as in:\n-      // Foo.prototype = {\n-      //   a: function() { ... },\n-      //   b: function() { ... }\n-      // };\n-      // Right now (6/23/08), we understand most of this syntax, but we\n-      // don't tie the \"a\" and \"b\" methods to the context of Foo.\n-\n-      Node rvalue = n.getLastChild();\n-      Node lvalue = n.getFirstChild();\n-      info = (info != null) ? info : rvalue.getJSDocInfo();\n-      if (rvalue.getType() == Token.FUNCTION ||\n-          info != null && info.isConstructor()) {\n-        getFunctionType(lvalue.getQualifiedName(), rvalue, info,\n-            lvalue);\n-      } else if (info != null && info.hasEnumParameterType()) {\n-        JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue,\n-            info.getEnumParameterType().evaluate(scope, typeRegistry));\n-        if (type != null) {\n-          setDeferredType(lvalue, type);\n-        }\n-      }\n-    }\n-\n-    /**\n-     * Defines a variable based on the {@link Token#NAME} node passed.\n-     * @param name The {@link Token#NAME} node.\n-     * @param var The parent of the {@code name} node, which must be a\n-     *     {@link Token#VAR} node.\n-     * @param parent {@code var}'s parent.\n-     * @param info the {@link JSDocInfo} information relating to this\n-     *     {@code name} node.\n-     */\n-    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n-      Node value = name.getFirstChild();\n-\n-      if (value != null && value.getType() == Token.FUNCTION) {\n-        // function\n-        String functionName = name.getString();\n-        FunctionType functionType =\n-            getFunctionType(functionName, value, info, null);\n-        if (functionType.isReturnTypeInferred() &&\n-            scope.isLocal()) {\n-          defineSlot(name, var, null);\n-        } else {\n-          defineSlot(name, var, functionType);\n-        }\n-      } else {\n-        // variable's type\n-        JSType type = null;\n-        if (info == null) {\n-          // the variable's type will be inferred\n-          CompilerInput input = compiler.getInput(sourceName);\n-          Preconditions.checkNotNull(input, sourceName);\n-          type = input.isExtern() ?\n-              getNativeType(UNKNOWN_TYPE) : null;\n-        } else if (info.hasEnumParameterType()) {\n-          type = getEnumType(name.getString(), var, value,\n-              info.getEnumParameterType().evaluate(scope, typeRegistry));\n-        } else if (info.isConstructor()) {\n-          type = getFunctionType(name.getString(), value, info, name);\n-        } else {\n-          type = getDeclaredTypeInAnnotation(sourceName, name, info);\n-        }\n-\n-        defineSlot(name, var, type);\n-      }\n-    }\n-\n-    /**\n-     * Gets the function type from the function node and its attached\n-     * {@link JSDocInfo}.\n-     * @param name the function's name\n-     * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n-     * @param info the {@link JSDocInfo} attached to the function definition\n-     * @param lvalueNode The node where this function is being\n-     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n-     *     determine that this function is a method of A.prototype. May be\n-     *     null to indicate that this is not being assigned to a qualified name.\n-     */\n-    private FunctionType getFunctionType(String name,\n-        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n-      FunctionType functionType = null;\n-\n-      // Global function aliases should be registered with the type registry.\n-      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n-        Var var = scope.getVar(rValue.getQualifiedName());\n-        if (var != null && var.getType() instanceof FunctionType) {\n-          functionType = (FunctionType) var.getType();\n-          if (functionType != null &&\n-              (functionType.isConstructor() || functionType.isInterface())) {\n-            typeRegistry.declareType(name, functionType.getInstanceType());\n-          }\n-        }\n-        return functionType;\n-      }\n-\n-      Node owner = null;\n-      if (lvalueNode != null) {\n-        owner = getPrototypePropertyOwner(lvalueNode);\n-      }\n-\n-      Node errorRoot = rValue == null ? lvalueNode : rValue;\n-      boolean isFnLiteral =\n-          rValue != null && rValue.getType() == Token.FUNCTION;\n-      Node fnRoot = isFnLiteral ? rValue : null;\n-      Node parametersNode = isFnLiteral ?\n-          rValue.getFirstChild().getNext() : null;\n-      Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n-\n-      if (functionType == null && info != null && info.hasType()) {\n-        JSType type = info.getType().evaluate(scope, typeRegistry);\n-\n-        // Known to be not null since we have the FUNCTION token there.\n-        type = type.restrictByNotNullOrUndefined();\n-        if (type.isFunctionType()) {\n-          functionType = (FunctionType) type;\n-          functionType.setJSDocInfo(info);\n-        }\n-      }\n-\n-      if (functionType == null) {\n-        // Find the type of any overridden function.\n-        FunctionType overriddenPropType = null;\n-        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n-            lvalueNode.isQualifiedName()) {\n-          Var var = scope.getVar(\n-              lvalueNode.getFirstChild().getQualifiedName());\n-          if (var != null) {\n-            ObjectType ownerType = ObjectType.cast(var.getType());\n-            if (ownerType != null) {\n-              String propName = lvalueNode.getLastChild().getString();\n-              overriddenPropType = findOverriddenFunction(ownerType, propName);\n-            }\n-          }\n-        }\n-\n-        functionType =\n-            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n-                scope)\n-            .setSourceNode(fnRoot)\n-            .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n-            .inferTemplateTypeName(info)\n-            .inferReturnType(info)\n-            .inferInheritance(info)\n-            .inferThisType(info, owner)\n-            .inferParameterTypes(parametersNode, info)\n-            .inferReturnStatementsAsLastResort(fnBlock)\n-            .buildAndRegister();\n-      }\n-\n-      // assigning the function type to the function node\n-      if (rValue != null) {\n-        setDeferredType(rValue, functionType);\n+          functionType = builder\n+              .inferParameterTypes(parametersNode, info)\n+              .inferReturnStatementsAsLastResort(fnBlock)\n+              .buildAndRegister();\n+        }\n       }\n \n       // all done\n     }\n \n     /**\n-     * Gets an enum type. If the definition is correct, the object literal used\n-     * to define the enum is traversed to gather the elements name, and this\n-     * method checks for duplicates. This method also enforces that all\n-     * elements' name be syntactic constants according to the\n-     * {@link CodingConvention} used.\n+     * Creates a new enum type, based on the given nodes.\n      *\n-     * @param name the enum's name such as {@code HELLO} or {@code goog.foo.BAR}\n-     * @param value the enum's original value. This value may be {@code null}.\n-     * @param parent the value's parent\n-     * @param elementsType the type of the elements of this enum\n-     * @return the enum type\n-     */\n-    private EnumType getEnumType(String name, Node parent,\n-        Node value, JSType elementsType) {\n+     * This handles two cases that are semantically very different, but\n+     * are not mutually exclusive:\n+     * - An object literal that needs an enum type attached to it.\n+     * - An assignment expression with an enum tag in the jsdoc.\n+     *\n+     * This function will always create an enum type, so only call it if\n+     * you're sure that's what you want.\n+     *\n+     * @param rValue The node of the enum.\n+     * @param name The enum's name\n+     * @param info The {@link JSDocInfo} attached to the enum definition.\n+     * @param lvalueNode The node where this function is being\n+     *     assigned.\n+     */\n+    private EnumType createEnumTypeFromNodes(Node rValue, String name,\n+        JSDocInfo info, Node lValueNode) {\n+      Preconditions.checkNotNull(info);\n+      Preconditions.checkState(info.hasEnumParameterType());\n+\n       EnumType enumType = null;\n-\n-      // no value with @enum\n-      if (value != null) {\n-        if (value.getType() == Token.OBJECTLIT) {\n+      if (rValue != null && rValue.isQualifiedName()) {\n+        // Handle an aliased enum.\n+        Var var = scope.getVar(rValue.getQualifiedName());\n+        if (var != null && var.getType() instanceof EnumType) {\n+          enumType = (EnumType) var.getType();\n+        }\n+      }\n+\n+      if (enumType == null) {\n+        JSType elementsType =\n+            info.getEnumParameterType().evaluate(scope, typeRegistry);\n+        enumType = typeRegistry.createEnumType(name, elementsType);\n+\n+        if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n           // collect enum elements\n-          enumType = typeRegistry.createEnumType(name, elementsType);\n-\n-          // populate the enum type.\n-          Node key = value.getFirstChild();\n+          Node key = rValue.getFirstChild();\n           while (key != null) {\n             String keyName = NodeUtil.getStringValue(key);\n             if (keyName == null) {\n             }\n             key = key.getNext();\n           }\n-        } else if (value.isQualifiedName()) {\n-          Var var = scope.getVar(value.getQualifiedName());\n-          if (var != null && var.getType() instanceof EnumType) {\n-            enumType = (EnumType) var.getType();\n-          }\n-        }\n-      }\n-\n-      if (enumType == null) {\n-        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n-      } else if (scope.isGlobal()) {\n-        if (name != null && !name.isEmpty()) {\n-          typeRegistry.declareType(name, enumType.getElementsType());\n-        }\n+        }\n+      }\n+\n+      if (name != null && scope.isGlobal()) {\n+        typeRegistry.declareType(name, enumType.getElementsType());\n       }\n \n       return enumType;\n                 isExtern, n);\n           } else {\n             globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n+          }\n+        }\n+\n+        if (type instanceof EnumType) {\n+          Node initialValue = newVar.getInitialValue();\n+          boolean isValidValue = initialValue != null &&\n+              (initialValue.getType() == Token.OBJECTLIT ||\n+               initialValue.isQualifiedName());\n+          if (!isValidValue) {\n+            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n           }\n         }\n \n         Node n, @Nullable Node rhsValue) {\n       if (info != null && info.hasType()) {\n         return getDeclaredTypeInAnnotation(t, n, info);\n+      } else if (rhsValue != null && rhsValue.getType() == Token.FUNCTION) {\n+        return rhsValue.getJSType();\n       } else if (info != null && info.hasEnumParameterType()) {\n-        return n.getJSType();\n-      } else if (rhsValue != null &&\n-          rhsValue.getType() == Token.FUNCTION) {\n-        return rhsValue.getJSType();\n+        if (rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) {\n+          return rhsValue.getJSType();\n+        } else {\n+          return createEnumTypeFromNodes(\n+              rhsValue, n.getQualifiedName(), info, n);\n+        }\n+      } else if (info != null &&\n+                 (info.isConstructor() || info.isInterface())) {\n+        return createFunctionTypeFromNodes(\n+            rhsValue, n.getQualifiedName(), info, n);\n       } else {\n         return getDeclaredTypeInAnnotation(t, n, info);\n       }\n       }\n     } // end declareArguments\n   } // end LocalScopeBuilder\n+\n+\n+  /** Find the best JSDoc for the given node. */\n+  static JSDocInfo getBestJSDocInfo(Node n) {\n+    JSDocInfo info = n.getJSDocInfo();\n+    if (info == null) {\n+      Node parent = n.getParent();\n+      int parentType = parent.getType();\n+      if (parentType == Token.NAME) {\n+        info = parent.getJSDocInfo();\n+        if (info == null && parent.getParent().hasOneChild()) {\n+          info = parent.getParent().getJSDocInfo();\n+        }\n+      } else if (parentType == Token.ASSIGN) {\n+        info = parent.getJSDocInfo();\n+      } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n+        info = parent.getJSDocInfo();\n+      }\n+    }\n+    return info;\n+  }\n+\n+  /** Find the l-value that the given r-value is being assigned to. */\n+  private static Node getBestLValue(Node n) {\n+    Node parent = n.getParent();\n+    int parentType = parent.getType();\n+    boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n);\n+    if (isFunctionDeclaration) {\n+      return n.getFirstChild();\n+    } else if (parentType == Token.NAME) {\n+      return parent;\n+    } else if (parentType == Token.ASSIGN) {\n+      return parent.getFirstChild();\n+    } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n+      return parent;\n+    }\n+    return null;\n+  }\n+\n+  /** Get the name of the given l-value node. */\n+  private static String getBestLValueName(@Nullable Node lValue) {\n+    return lValue == null ? null : lValue.getQualifiedName();\n+  }\n }\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n         + \"var EA=En.A;\"\n         + \"var EB=En.B;\"\n         + \"function Foo(){};\"\n-        + \"Foo.prototype.A=0;\"\n-        + \"Foo.prototype.B=0\";\n+        + \"Foo.prototype.Foo_prototype$A=0;\"\n+        + \"Foo.prototype.Foo_prototype$B=0\";\n     String ttOutput = \"\"\n         + \"var En={A:'first',B:'second'};\"\n         + \"var EA=En.A;\"\n         + \"function Foo(){};\"\n         + \"Foo.prototype.Foo_prototype$A=0;\"\n         + \"Foo.prototype.Foo_prototype$B=0\";\n-    testSets(false, js, output, \"{}\");\n+    testSets(false, js, output, \"{A=[[Foo.prototype]], B=[[Foo.prototype]]}\");\n     testSets(true, js, ttOutput, \"{A=[[Foo.prototype]], B=[[Foo.prototype]]}\");\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   public void testGoodImplements3() throws Exception {\n     testTypes(\"/** @interface */function Disposable() {}\\n\" +\n         \"/** @implements {Disposable}\\n * @interface */function f() {}\");\n+  }\n+\n+  public void testGoodImplements4() throws Exception {\n+    testTypes(\"var goog = {};\" +\n+        \"/** @type {!Function} */\" +\n+        \"goog.abstractMethod = function() {};\" +\n+        \"/** @interface */\\n\" +\n+        \"goog.Disposable = goog.abstractMethod;\" +\n+        \"goog.Disposable.prototype.dispose = goog.abstractMethod;\" +\n+        \"/** @implements {goog.Disposable}\\n * @constructor */\" +\n+        \"goog.SubDisposable = function() {};\" +\n+        \"/** @inheritDoc */ \" +\n+        \"goog.SubDisposable.prototype.dispose = function() {};\");\n   }\n \n   public void testBadImplements1() throws Exception {", "timestamp": 1296490105, "metainfo": ""}