{"sha": "c590fe51732eea3b712c7f894ba3f5a9d23613e1", "log": "Minor changes to the last cl. This isn't functionally different in any way (getLeastSupertype usually just creates a union), but are slightly more semantically correct  R=zhuyi DELTA=11  (3 added, 1 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2000   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n     if (constraintObj != null && constraintObj.isRecordType()) {\n       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      for (String prop : constraintObj.getOwnPropertyNames()) {\n-        JSType propType = constraintObj.getPropertyType(prop);\n-        if (objType != null && !objType.isPropertyTypeDeclared(prop)) {\n-          JSType typeToInfer = propType;\n-          if (!objType.hasProperty(prop)) {\n-            typeToInfer = registry.createUnionType(\n-                getNativeType(VOID_TYPE), propType);\n+      if (objType != null) {\n+        for (String prop : constraintObj.getOwnPropertyNames()) {\n+          JSType propType = constraintObj.getPropertyType(prop);\n+          if (!objType.isPropertyTypeDeclared(prop)) {\n+            JSType typeToInfer = propType;\n+            if (!objType.hasProperty(prop)) {\n+              typeToInfer =\n+                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n+            }\n+            objType.defineInferredProperty(prop, typeToInfer, false, null);\n           }\n-          objType.defineInferredProperty(prop, typeToInfer, false, null);\n         }\n       }\n     }", "timestamp": 1306258624, "metainfo": ""}