{"sha": "64857ce3eaa6d9ab630a509ec16cb2bc6360633b", "log": "Add the experimental source map format. This basically compresses the Maps source map from 50MB to a little less than 9MB (less when using using the SYMBOLS node filter):  It does this in a couple of ways: 1) It removes pulls filenames into a common section, and uses ids to map to them. 2) It uses an alternate encoding for the line maps to take advantage of some of the properties of them to reduce the redundancy there.  R=jschorr DELTA=2987  (2415 added, 558 deleted, 14 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=194043   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n       return this;\n     }\n \n+    private SourceMap.Format sourceMapFormat =\n+      SourceMap.Format.LEGACY;\n+\n+    /**\n+     * The detail supplied in the source map file, if generated.\n+     */\n+    CommandLineConfig setSourceMapFormat(SourceMap.Format format) {\n+      this.sourceMapFormat = format;\n+      return this;\n+    }\n+\n     private final List<String> jscompError = Lists.newArrayList();\n \n     /**\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   private void initBasedOnOptions() {\n     // Create the source map if necessary.\n     if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n+      sourceMap = options.sourceMapFormat.getInstance();\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   /** The detail level for the generated source map. */\n   public SourceMap.DetailLevel sourceMapDetailLevel =\n       SourceMap.DetailLevel.SYMBOLS;\n+\n+  /** The source map file format */\n+  public SourceMap.Format sourceMapFormat =\n+      SourceMap.Format.LEGACY;\n \n   /**\n    * Charset to use when generating code.  If null, then output ASCII.\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n-import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n import java.io.IOException;\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-import java.util.List;\n \n /**\n  * Collects information mapping the generated (compiled) source back to\n  *\n  * @author johnlenz@google.com (John Lenz)\n  */\n-public class SourceMap {\n+public interface SourceMap {\n \n-  private final static int UNMAPPED = -1;\n+  enum Format {\n+     LEGACY {\n+       @Override SourceMap getInstance() {\n+         return new SourceMapLegacy();\n+       }\n+     },\n+     EXPERIMENTIAL {\n+       @Override SourceMap getInstance() {\n+         return new SourceMap2();\n+       }\n+     };\n+     abstract SourceMap getInstance();\n+  }\n \n   /**\n    * Source maps can be very large different levels of detail can be specified.\n   }\n \n   /**\n-   * A mapping from a given position in an input source file to a given position\n-   * in the generated code.\n+   * Appends the source map to the given buffer.\n+   *\n+   * @param out The stream to which the map will be appended.\n+   * @param name The name of the generated source file that this source map\n+   *   represents.\n    */\n-  static class Mapping {\n-    /**\n-     * A unique ID for this mapping for record keeping purposes.\n-     */\n-    int id = UNMAPPED;\n-\n-    /**\n-     * The input source file.\n-     */\n-    String sourceFile;\n-\n-    /**\n-     * The position of the code in the input source file. Both\n-     * the line number and the character index are indexed by\n-     * 1 for legacy reasons via the Rhino Node class.\n-     */\n-    Position originalPosition;\n-\n-    /**\n-     * The starting position of the code in the generated source\n-     * file which this mapping represents. Indexed by 0.\n-     */\n-    Position startPosition;\n-\n-    /**\n-     * The ending position of the code in the generated source\n-     * file which this mapping represents. Indexed by 0.\n-     */\n-    Position endPosition;\n-\n-    /**\n-     * The original name of the token found at the position\n-     * represented by this mapping (if any).\n-     */\n-    String originalName;\n-\n-    /**\n-     * Whether the mapping is actually used by the source map.\n-     */\n-    boolean used = false;\n-  }\n-\n-  private class MappingWriter {\n-    /**\n-     * Cache of escaped source file name.\n-     */\n-    private String lastSourceFile = null;\n-    private String lastSourceFileEscaped = null;\n-    private int lastLine = 0;\n-    private String lastLineString = String.valueOf(0);\n-\n-    /**\n-     * Appends the mapping to the given buffer.\n-     */\n-    private void appendMappingTo(\n-        Mapping m, Appendable out) throws IOException {\n-      out.append(\"[\");\n-\n-      String sourceFile = m.sourceFile;\n-      // The source file rarely changes, so cache the escaped string.\n-      String escapedSourceFile;\n-      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)\n-        lastSourceFile = sourceFile;\n-        lastSourceFileEscaped = escapeString(sourceFile);\n-      }\n-      escapedSourceFile = lastSourceFileEscaped;\n-\n-      out.append(escapedSourceFile);\n-      out.append(\",\");\n-\n-      int line = m.originalPosition.getLineNumber();\n-      if (line != lastLine) {\n-        lastLineString = String.valueOf(line);\n-      }\n-      String lineValue = lastLineString;\n-\n-      out.append(lineValue);\n-\n-      out.append(\",\");\n-      out.append(String.valueOf(\n-          m.originalPosition.getCharacterIndex()));\n-\n-      if (m.originalName != null) {\n-        out.append(\",\");\n-        out.append(escapeString(m.originalName));\n-      }\n-\n-      out.append(\"]\\n\");\n-    }\n-\n-    /**\n-     * Add used mappings to the supplied Appendable.\n-     */\n-    void appendMappings(Appendable out) throws IOException {\n-      for (Mapping m : mappings) {\n-        if (m.used) {\n-          appendMappingTo(m, out);\n-        }\n-      }\n-    }\n-  }\n+  void appendTo(Appendable out, String name) throws IOException;\n \n   /**\n-   * A pre-order traversal ordered list of mappings stored in this map.\n+   * Resets the source map for reuse. A reset needs to be called between\n+   * each generated output file.\n    */\n-  private List<Mapping> mappings = Lists.newArrayList();\n-\n-  /**\n-   * For validation store the start of the last mapping added.\n-   */\n-  private Mapping lastMapping;\n-\n-  /**\n-   * The position that the current source map is offset in the\n-   * buffer being used to generated the compiled source file.\n-   */\n-  private Position offsetPosition = new Position(0, 0);\n-\n-  /**\n-   * The position that the current source map is offset in the\n-   * generated the compiled source file by the addition of a\n-   * an output wrapper prefix.\n-   */\n-  private Position prefixPosition = new Position(0, 0);\n-\n-  /**\n-   * Escapes the given string for JSON.\n-   */\n-  private static String escapeString(String value) {\n-    return CodeGenerator.escapeToDoubleQuotedJsString(value);\n-  }\n+  void reset();\n \n   /**\n    * Adds a mapping for the given node.  Mappings must be added in order.\n    * @param startPosition The position on the starting line\n    * @param endPosition The position on the ending line.\n    */\n-  void addMapping(Node node, Position startPosition, Position endPosition) {\n-    String sourceFile = (String)node.getProp(Node.SOURCENAME_PROP);\n-\n-    // If the node does not have an associated source file or\n-    // its line number is -1, then the node does not have sufficient\n-    // information for a mapping to be useful.\n-    if (sourceFile == null || node.getLineno() < 0) {\n-      return;\n-    }\n-\n-    // Create the new mapping.\n-    Mapping mapping = new Mapping();\n-    mapping.sourceFile = sourceFile;\n-    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n-\n-    String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n-    if (originalName != null) {\n-      mapping.originalName = originalName;\n-    }\n-\n-    if (offsetPosition.getLineNumber() == 0\n-        && offsetPosition.getCharacterIndex() == 0) {\n-      mapping.startPosition = startPosition;\n-      mapping.endPosition = endPosition;\n-    } else {\n-      // If the mapping is found on the first line, we need to offset\n-      // its character position by the number of characters found on\n-      // the *last* line of the source file to which the code is\n-      // being generated.\n-      int offsetLine = offsetPosition.getLineNumber();\n-      int startOffsetPosition = offsetPosition.getCharacterIndex();\n-      int endOffsetPosition = offsetPosition.getCharacterIndex();\n-\n-      if (startPosition.getLineNumber() > 0) {\n-        startOffsetPosition = 0;\n-      }\n-\n-      if (endPosition.getLineNumber() > 0) {\n-        endOffsetPosition = 0;\n-      }\n-\n-      mapping.startPosition =\n-          new Position(startPosition.getLineNumber() + offsetLine,\n-                       startPosition.getCharacterIndex() + startOffsetPosition);\n-\n-      mapping.endPosition =\n-          new Position(endPosition.getLineNumber() + offsetLine,\n-                       endPosition.getCharacterIndex() + endOffsetPosition);\n-    }\n-\n-    // Validate the mappings are in a proper order.\n-    if (lastMapping != null) {\n-      int lastLine = lastMapping.startPosition.getLineNumber();\n-      int lastColumn = lastMapping.startPosition.getCharacterIndex();\n-      int nextLine = mapping.startPosition.getLineNumber();\n-      int nextColumn = mapping.startPosition.getCharacterIndex();\n-      Preconditions.checkState(nextLine > lastLine\n-          || (nextLine == lastLine && nextColumn >= lastColumn),\n-          \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n-          + \"new : (%s,%s)\\nnode : %s\",\n-          lastLine, lastColumn, nextLine, nextColumn, node);\n-    }\n-\n-    lastMapping = mapping;\n-    mappings.add(mapping);\n-  }\n+  void addMapping(Node node, Position startPosition, Position endPosition);\n \n   /**\n    * Sets the prefix used for wrapping the generated source file before\n-   * it is output. This ensures that the source map is adjusted as\n-   * needed.\n+   * it is written. This ensures that the source map is adjusted for the\n+   * change in character offsets.\n    *\n    * @param prefix The prefix that is added before the generated source code.\n    */\n-  void setWrapperPrefix(String prefix) {\n-    // Determine the current line and character position.\n-    int prefixLine = 0;\n-    int prefixIndex = 0;\n-\n-    for (int i = 0; i < prefix.length(); ++i) {\n-      if (prefix.charAt(i) == '\\n') {\n-        prefixLine++;\n-        prefixIndex = 0;\n-      } else {\n-        prefixIndex++;\n-      }\n-    }\n-\n-    prefixPosition = new Position(prefixLine, prefixIndex);\n-  }\n+  void setWrapperPrefix(String prefix);\n \n   /**\n-   * Sets the source code that exists in the buffer to which the\n+   * Sets the source code that exists in the buffer for which the\n    * generated code is being generated. This ensures that the source map\n    * accurately reflects the fact that the source is being appended to\n    * an existing buffer and as such, does not start at line 0, position 0\n    * @param offsetLine The index of the current line being printed.\n    * @param offsetIndex The column index of the current character being printed.\n    */\n-  void setStartingPosition(int offsetLine, int offsetIndex) {\n-    Preconditions.checkState(offsetLine >= 0);\n-    Preconditions.checkState(offsetIndex >= 0);\n-    offsetPosition = new Position(offsetLine, offsetIndex);\n-  }\n+  void setStartingPosition(int offsetLine, int offsetIndex);\n \n-  /**\n-   * Resets the source map for reuse for the generation of a new source file.\n-   */\n-  public void reset() {\n-    mappings = Lists.newArrayList();\n-    lastMapping = null;\n-    offsetPosition = new Position(0, 0);\n-    prefixPosition = new Position(0, 0);\n-  }\n-\n-  /**\n-   * Appends the source map in LavaBug format to the given buffer.\n-   *\n-   * @param out The stream to which the map will be appended.\n-   * @param name The name of the generated source file that this source map\n-   *   represents.\n-   */\n-  public void appendTo(Appendable out, String name) throws IOException {\n-    // Write the mappings out to the file. The format of the generated\n-    // source map is three sections, each deliminated by a magic comment.\n-    //\n-    // The first section contains an array for each line of the generated\n-    // code, where each element in the array is the ID of the mapping which\n-    // best represents the index-th character found on that line of the\n-    // generated source code.\n-    //\n-    // The second section contains an array per generated line. Unused.\n-    //\n-    // The third and final section contains an array per line, each of which\n-    // represents a mapping with a unique ID. The mappings are added in order.\n-    // The array itself contains a tuple representing\n-    // ['source file', line, col (, 'original name')]\n-    //\n-    // Example for 2 lines of generated code (with line numbers added for\n-    // readability):\n-    //\n-    // 1)  /** Begin line maps. **/{ \"count\": 2 }\n-    // 2)  [0,0,0,0,0,0,1,1,1,1,2]\n-    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n-    // 4)  /** Begin file information. **/\n-    // 5)  []\n-    // 6)  []\n-    // 7)  /** Begin mapping definitions. **/\n-    // 8)  [\"a.js\", 1, 34]\n-    // 9)  [\"a.js\", 5, 2]\n-    // 10) [\"b.js\", 1, 3, \"event\"]\n-    // 11) [\"c.js\", 1, 4]\n-    // 12) [\"d.js\", 3, 78, \"foo\"]\n-\n-    int maxLine = prepMappings();\n-\n-    // Add the line character maps.\n-    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n-    out.append(escapeString(name));\n-    out.append(\", \\\"count\\\": \");\n-    out.append(String.valueOf(maxLine + 1));\n-    out.append(\" }\\n\");\n-    (new LineMapper(out)).appendLineMappings();\n-\n-    // Add the source file maps.\n-    out.append(\"/** Begin file information. **/\\n\");\n-\n-    // This section is unused but we need one entry per line to\n-    // prevent changing the format.\n-    for (int i = 0; i <= maxLine; ++i) {\n-      out.append(\"[]\\n\");\n-    }\n-\n-    // Add the mappings themselves.\n-    out.append(\"/** Begin mapping definitions. **/\\n\");\n-\n-    (new MappingWriter()).appendMappings(out);\n-  }\n-\n-  /**\n-   * Assigns sequential ids to used mappings, and returns the last line mapped.\n-   */\n-  private int prepMappings() throws IOException {\n-    // Mark any unused mappings.\n-    (new MappingTraversal()).traverse(new UsedMappingCheck());\n-\n-    // Renumber used mappings and keep track of the last line.\n-    int id = 0;\n-    int maxLine = 0;\n-    for (Mapping m : mappings) {\n-      if (m.used) {\n-        m.id = id++;\n-        int endPositionLine = m.endPosition.getLineNumber();\n-        maxLine = Math.max(maxLine, endPositionLine);\n-      }\n-    }\n-\n-    // Adjust for the prefix.\n-    return maxLine + prefixPosition.getLineNumber();\n-  }\n-\n-  private class LineMapper implements MappingVisitor {\n-    // The destination.\n-    private final Appendable out;\n-\n-    // Whether the current line has had a value written yet.\n-    private boolean firstChar = true;\n-\n-    private final static String UNMAPPED_STRING = \"-1\";\n-\n-    private int lastId = UNMAPPED;\n-    private String lastIdString = UNMAPPED_STRING;\n-\n-    LineMapper(Appendable out) {\n-      this.out = out;\n-    }\n-\n-    /**\n-     * As each segment is visited write out the appropriate line mapping.\n-     */\n-    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n-      throws IOException {\n-\n-      int id = (m != null) ? m.id : UNMAPPED;\n-      if (lastId != id) {\n-        // Prevent the creation of unnecessary temporary stings for often\n-        // repeated values.\n-        lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n-        lastId = id;\n-      }\n-      String idString = lastIdString;\n-\n-      for (int i = line; i <= nextLine; i++) {\n-        if (i == nextLine) {\n-          for (int j = col; j < nextCol; j++) {\n-            addCharEntry(idString);\n-          }\n-          break;\n-        }\n-\n-        closeLine();\n-        openLine();\n-\n-        // Set the starting location for the next line.\n-        col = 0;\n-      }\n-    }\n-\n-    // Append the line mapping entries.\n-    void appendLineMappings() throws IOException {\n-      // Start the first line.\n-      openLine();\n-\n-      (new MappingTraversal()).traverse(this);\n-\n-      // And close the final line.\n-      closeLine();\n-    }\n-\n-    /**\n-     * Begin the entry for a new line.\n-     */\n-    private void openLine() throws IOException {\n-      if (out != null) {\n-        out.append(\"[\");\n-        this.firstChar = true;\n-      }\n-    }\n-\n-    /**\n-     * End the entry for a line.\n-     */\n-    private void closeLine() throws IOException {\n-      if (out != null) {\n-        out.append(\"]\\n\");\n-      }\n-    }\n-\n-    /**\n-     * Add a new char position entry.\n-     * @param id The mapping id to record.\n-     */\n-    private void addCharEntry(String id) throws IOException {\n-      if (out != null) {\n-        if (firstChar) {\n-          firstChar = false;\n-        } else {\n-          out.append(\",\");\n-        }\n-        out.append(id);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Mark any visited mapping as \"used\".\n-   */\n-  private class UsedMappingCheck implements MappingVisitor {\n-    /**\n-     * @throws IOException\n-     */\n-    @Override\n-    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n-        throws IOException {\n-      if (m != null) {\n-        m.used = true;\n-      }\n-    }\n-  }\n-\n-  private interface MappingVisitor {\n-    /**\n-     * @param m The mapping for the current code segment. null if the segment\n-     *     is unmapped.\n-     * @param line The starting line for this code segment.\n-     * @param col The starting column for this code segment.\n-     * @param endLine The ending line\n-     * @param endCol The ending column\n-     * @throws IOException\n-     */\n-    void visit(Mapping m, int line, int col, int endLine, int endCol)\n-        throws IOException;\n-  }\n-\n-  /**\n-   * Walk the mappings and visit each segment of the mappings, unmapped\n-   * segments are visited with a null mapping, unused mapping are not visited.\n-   */\n-  private class MappingTraversal {\n-    // The last line and column written\n-    private int line;\n-    private int col;\n-\n-    MappingTraversal() {\n-    }\n-\n-    // Append the line mapping entries.\n-    void traverse(MappingVisitor v) throws IOException {\n-      // The mapping list is ordered as a pre-order traversal.  The mapping\n-      // positions give us enough information to rebuild the stack and this\n-      // allows the building of the source map in O(n) time.\n-      Deque<Mapping> stack = new ArrayDeque<Mapping>();\n-      for (Mapping m : mappings) {\n-        // Find the closest ancestor of the current mapping:\n-        // An overlapping mapping is an ancestor of the current mapping, any\n-        // non-overlapping mappings are siblings (or cousins) and must be\n-        // closed in the reverse order of when they encountered.\n-        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n-          Mapping previous = stack.pop();\n-          maybeVisit(v, previous);\n-        }\n-\n-        // Any gaps between the current line position and the start of the\n-        // current mapping belong to the parent.\n-        Mapping parent = stack.peek();\n-        maybeVisitParent(v, parent, m);\n-\n-        stack.push(m);\n-      }\n-\n-      // There are no more children to be had, simply close the remaining\n-      // mappings in the reverse order of when they encountered.\n-      while (!stack.isEmpty()) {\n-        Mapping m = stack.pop();\n-        maybeVisit(v, m);\n-      }\n-    }\n-\n-    /**\n-     * @return The line adjusted for the prefix position.\n-     */\n-    private int getAdjustedLine(Position p) {\n-      return p.getLineNumber() + prefixPosition.getLineNumber();\n-    }\n-\n-    /**\n-     * @return The column adjusted for the prefix position.\n-     */\n-    private int getAdjustedCol(Position p) {\n-      int rawLine = p.getLineNumber();\n-      int rawCol = p.getCharacterIndex();\n-      // Only the first line needs the character position adjusted.\n-      return (rawLine != 0)\n-          ? rawCol : rawCol + prefixPosition.getCharacterIndex();\n-    }\n-\n-    /**\n-     * @return Whether m1 ends before m2 starts.\n-     */\n-    private boolean isOverlapped(Mapping m1, Mapping m2) {\n-      // No need to use adjusted values here, relative positions are sufficient.\n-      int l1 = m1.endPosition.getLineNumber();\n-      int l2 = m2.startPosition.getLineNumber();\n-      int c1 = m1.endPosition.getCharacterIndex();\n-      int c2 = m2.startPosition.getCharacterIndex();\n-\n-      return (l1 == l2 && c1 >= c2) || l1 > l2;\n-    }\n-\n-    /**\n-     * Write any needed entries from the current position to the end of the\n-     * provided mapping.\n-     */\n-    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {\n-      int nextLine = getAdjustedLine(m.endPosition);\n-      int nextCol = getAdjustedCol(m.endPosition);\n-      // If this anything remaining in this mapping beyond the\n-      // current line and column position, write it out now.\n-      if (line < nextLine || (line == nextLine && col < nextCol)) {\n-        visit(v, m, nextLine, nextCol);\n-      }\n-    }\n-\n-    /**\n-     * Write any needed entries to complete the provided mapping.\n-     */\n-    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)\n-        throws IOException {\n-      int nextLine = getAdjustedLine(m.startPosition);\n-      int nextCol = getAdjustedCol(m.startPosition);\n-      // If the previous value is null, no mapping exists.\n-      Preconditions.checkState(line < nextLine || col <= nextCol);\n-      if (line < nextLine || (line == nextLine && col < nextCol)) {\n-        visit(v, parent, nextLine, nextCol);\n-      }\n-    }\n-\n-    /**\n-     * Write any entries needed between the current position the next position\n-     * and update the current position.\n-     */\n-    private void visit(MappingVisitor v, Mapping m,\n-        int nextLine, int nextCol)\n-        throws IOException {\n-      Preconditions.checkState(line <= nextLine);\n-      Preconditions.checkState(line < nextLine || col < nextCol);\n-\n-      if (line == nextLine && col == nextCol) {\n-        // Nothing to do.\n-        Preconditions.checkState(false);\n-        return;\n-      }\n-\n-      v.visit(m, line, col, nextLine, nextCol);\n-\n-      line = nextLine;\n-      col = nextCol;\n-    }\n-  }\n }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/SourceMap2.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.Node;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map.Entry;\n+\n+/**\n+ * Collects information mapping the generated (compiled) source back to\n+ * its original source for debugging purposes.\n+ *\n+ * @see CodeConsumer\n+ * @see CodeGenerator\n+ * @see CodePrinter\n+ *\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMap2 implements SourceMap {\n+\n+  private boolean validate = false;\n+\n+  private final static int UNMAPPED = -1;\n+\n+  /**\n+   *  A map used to convert integer values in the range 0-63 to their base64\n+   *  values.\n+   */\n+  private static final String BASE64_MAP =\n+      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n+      \"abcdefghijklmnopqrstuvwzyz\" +\n+      \"0123456789+/\";\n+\n+  /**\n+   * A pre-order traversal ordered list of mappings stored in this map.\n+   */\n+  private List<Mapping> mappings = Lists.newArrayList();\n+\n+  /**\n+   * A map of source names to source name index\n+   */\n+  private LinkedHashMap<String, Integer> source_file_map =\n+      Maps.newLinkedHashMap();\n+\n+  /**\n+   * Cache of the last mappings source name.\n+   */\n+  private String lastSourceFile = null;\n+\n+  /**\n+   * Cache of the last mappings source name index.\n+   */\n+  private int lastSourceFileIndex = -1;\n+\n+  /**\n+   * For validation store the last mapping added.\n+   */\n+  private Mapping lastMapping;\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * buffer being used to generated the compiled source file.\n+   */\n+  private Position offsetPosition = new Position(0, 0);\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * generated the compiled source file by the addition of a\n+   * an output wrapper prefix.\n+   */\n+  private Position prefixPosition = new Position(0, 0);\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  public void reset() {\n+    mappings.clear();\n+    lastMapping = null;\n+    source_file_map.clear();\n+    lastSourceFile = null;\n+    lastSourceFileIndex = -1;\n+    offsetPosition = new Position(0, 0);\n+    prefixPosition = new Position(0, 0);\n+  }\n+\n+  /**\n+   * @param validate Whether to perform (potentially costly) validation on the\n+   * generated source map.\n+   */\n+  @VisibleForTesting\n+  void validate(boolean validate) {\n+    this.validate = validate;\n+  }\n+\n+  /**\n+   * Sets the prefix used for wrapping the generated source file before\n+   * it is written. This ensures that the source map is adjusted for the\n+   * change in character offsets.\n+   *\n+   * @param prefix The prefix that is added before the generated source code.\n+   */\n+  public void setWrapperPrefix(String prefix) {\n+    // Determine the current line and character position.\n+    int prefixLine = 0;\n+    int prefixIndex = 0;\n+\n+    for (int i = 0; i < prefix.length(); ++i) {\n+      if (prefix.charAt(i) == '\\n') {\n+        prefixLine++;\n+        prefixIndex = 0;\n+      } else {\n+        prefixIndex++;\n+      }\n+    }\n+\n+    prefixPosition = new Position(prefixLine, prefixIndex);\n+  }\n+\n+  /**\n+   * Sets the source code that exists in the buffer for which the\n+   * generated code is being generated. This ensures that the source map\n+   * accurately reflects the fact that the source is being appended to\n+   * an existing buffer and as such, does not start at line 0, position 0\n+   * but rather some other line and position.\n+   *\n+   * @param offsetLine The index of the current line being printed.\n+   * @param offsetIndex The column index of the current character being printed.\n+   */\n+  public void setStartingPosition(int offsetLine, int offsetIndex) {\n+    Preconditions.checkState(offsetLine >= 0);\n+    Preconditions.checkState(offsetIndex >= 0);\n+    offsetPosition = new Position(offsetLine, offsetIndex);\n+  }\n+\n+  /**\n+   * Adds a mapping for the given node.  Mappings must be added in order.\n+   *\n+   * @param node The node that the new mapping represents.\n+   * @param startPosition The position on the starting line\n+   * @param endPosition The position on the ending line.\n+   */\n+  public void addMapping(Node node, Position startPosition, Position endPosition) {\n+    String sourceFile = (String)node.getProp(Node.SOURCENAME_PROP);\n+\n+    // If the node does not have an associated source file or\n+    // its line number is -1, then the node does not have sufficient\n+    // information for a mapping to be useful.\n+    if (sourceFile == null || node.getLineno() < 0) {\n+      return;\n+    }\n+\n+    if (sourceFile != lastSourceFile) {\n+      lastSourceFile = sourceFile;\n+      Integer index = source_file_map.get(sourceFile);\n+      if (index != null) {\n+        lastSourceFileIndex = index;\n+      } else {\n+        lastSourceFileIndex = source_file_map.size();\n+        source_file_map.put(sourceFile, lastSourceFileIndex);\n+      }\n+    }\n+\n+    // Create the new mapping.\n+    Mapping mapping = new Mapping();\n+    mapping.sourceFile = lastSourceFileIndex;\n+    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n+\n+    String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n+    if (originalName != null) {\n+      mapping.originalName = originalName;\n+    }\n+\n+    if (offsetPosition.getLineNumber() == 0\n+        && offsetPosition.getCharacterIndex() == 0) {\n+      mapping.startPosition = startPosition;\n+      mapping.endPosition = endPosition;\n+    } else {\n+      // If the mapping is found on the first line, we need to offset\n+      // its character position by the number of characters found on\n+      // the *last* line of the source file to which the code is\n+      // being generated.\n+      int offsetLine = offsetPosition.getLineNumber();\n+      int startOffsetPosition = offsetPosition.getCharacterIndex();\n+      int endOffsetPosition = offsetPosition.getCharacterIndex();\n+\n+      if (startPosition.getLineNumber() > 0) {\n+        startOffsetPosition = 0;\n+      }\n+\n+      if (endPosition.getLineNumber() > 0) {\n+        endOffsetPosition = 0;\n+      }\n+\n+      mapping.startPosition =\n+          new Position(startPosition.getLineNumber() + offsetLine,\n+                       startPosition.getCharacterIndex() + startOffsetPosition);\n+\n+      mapping.endPosition =\n+          new Position(endPosition.getLineNumber() + offsetLine,\n+                       endPosition.getCharacterIndex() + endOffsetPosition);\n+    }\n+\n+    // Validate the mappings are in a proper order.\n+    if (lastMapping != null) {\n+      int lastLine = lastMapping.startPosition.getLineNumber();\n+      int lastColumn = lastMapping.startPosition.getCharacterIndex();\n+      int nextLine = mapping.startPosition.getLineNumber();\n+      int nextColumn = mapping.startPosition.getCharacterIndex();\n+      Preconditions.checkState(nextLine > lastLine\n+          || (nextLine == lastLine && nextColumn >= lastColumn),\n+          \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n+          + \"new : (%s,%s)\\nnode : %s\",\n+          lastLine, lastColumn, nextLine, nextColumn, node);\n+    }\n+\n+    lastMapping = mapping;\n+    mappings.add(mapping);\n+  }\n+\n+  /**\n+   * Writes out the source map in the following format (line numbers are for\n+   * reference only and are not part of the format):\n+   *\n+   * 1.  {\n+   * 2.    version: 2,\n+   * 3.    file: \u201cout.js\u201d\n+   * 4.    lineCount: 2\n+   * 5.    lineMaps: [\n+   * 6.        \"ABAAA\",\n+   * 7.        \"ABAA\"\n+   * 8.     ],\n+   * 9.    sourceRoot: \"\",\n+   * 10.   sources: [\"foo.js\", \"bar.js\"],\n+   * 11.   names: [\"src\", \"maps\", \"are\", \"fun\"],\n+   * 12.   mappings: [\n+   * 13.       [1, 1, 2, 4],\n+   * 14.       [2, 1, 2, \"yack\"],\n+   * 15.   ],\n+   * 16.  }\n+   *\n+   * Line 1: The entire file is a single JSON object\n+   * Line 2: File revision (always the first entry in the object)\n+   * Line 3: The name of the file that this source map is associated with.\n+   * Line 4: The number of lines represented in the sourcemap.\n+   * Line 5: \u201clineMaps\u201d field is a JSON array, where each entry represents a\n+   *     line in the generated text.\n+   * Line 6: A line entry, representing a series of line segments, where each\n+   *     segment encodes an mappings-id and repetition count.\n+   * Line 9: An optional source root, useful for relocating source files on a\n+   *     server or removing repeated prefix values in the \u201csources\u201d entry.\n+   * Line 10: A list of sources used by the \u201cmappings\u201d entry relative to the\n+   *     sourceRoot.\n+   * Line 11: A list of symbol names used by the \u201cmapping\u201d entry.  This list\n+   *     may be incomplete.\n+   * Line 12: The mappings field.\n+   * Line 13: Each entry represent a block of text in the original source, and\n+   *     consists four fields:\n+   *     The source file name\n+   *     The line in the source file the text begins\n+   *     The column in the line that the text begins\n+   *     An optional name (from the original source) that this entry represents.\n+   *     This can either be an string or index into the \u201cnames\u201d field.\n+   */\n+  public void appendTo(Appendable out, String name) throws IOException {\n+    int maxLine = prepMappings();\n+\n+    // Add the header fields.\n+    out.append(\"{\\n\");\n+    appendFirstField(out, \"version\", \"2\");\n+    appendField(out, \"file\", escapeString(name));\n+    appendField(out, \"lineCount\", String.valueOf(maxLine + 1));\n+\n+    // Add the line character maps.\n+    appendFieldStart(out, \"lineMaps\");\n+    out.append(\"[\");\n+    (new LineMapper(out)).appendLineMappings();\n+    out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    // Files names\n+    appendFieldStart(out, \"sources\");\n+    out.append(\"[\");\n+    addSourceNameMap(out);\n+    out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    // Add the mappings themselves.\n+    appendFieldStart(out, \"mappings\");\n+    out.append(\"[\");\n+    (new MappingWriter()).appendMappings(out);\n+    out.append(\"]\");\n+    appendFieldEnd(out);\n+\n+    out.append(\"\\n}\\n\");\n+  }\n+\n+  /**\n+   * Writes the source name map to 'out'.\n+   */\n+  private void addSourceNameMap(Appendable out) throws IOException {\n+    int i = 0;\n+    for (Entry<String, Integer> entry : source_file_map.entrySet()) {\n+      String key = entry.getKey();\n+      if (i != 0) {\n+        out.append(\",\");\n+      }\n+      out.append(\"\\\"\");\n+      out.append(key);\n+      out.append(\"\\\"\");\n+      i++;\n+    }\n+  }\n+\n+  /**\n+   * Escapes the given string for JSON.\n+   */\n+  private static String escapeString(String value) {\n+    return CodeGenerator.escapeToDoubleQuotedJsString(value);\n+  }\n+\n+  // Source map field helpers.\n+\n+  private void appendFirstField(Appendable out, String name, String value)\n+      throws IOException {\n+    out.append(\"\\\"\");\n+    out.append(name);\n+    out.append(\"\\\"\");\n+    out.append(\":\");\n+    out.append(value);\n+  }\n+\n+  private void appendField(Appendable out, String name, String value)\n+      throws IOException {\n+    out.append(\",\\n\");\n+    out.append(\"\\\"\");\n+    out.append(name);\n+    out.append(\"\\\"\");\n+    out.append(\":\");\n+    out.append(value);\n+  }\n+\n+  private void appendFieldStart(Appendable out, String name)\n+      throws IOException {\n+    appendField(out, name, \"\");\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  private void appendFieldEnd(Appendable out)\n+     throws IOException {\n+  }\n+\n+  /**\n+   * Assigns sequential ids to used mappings, and returns the last line mapped.\n+   */\n+  private int prepMappings() throws IOException {\n+    // Mark any unused mappings.\n+    (new MappingTraversal()).traverse(new UsedMappingCheck());\n+\n+    // Renumber used mappings and keep track of the last line.\n+    int id = 0;\n+    int maxLine = 0;\n+    for (Mapping m : mappings) {\n+      if (m.used) {\n+        m.id = id++;\n+        int endPositionLine = m.endPosition.getLineNumber();\n+        maxLine = Math.max(maxLine, endPositionLine);\n+      }\n+    }\n+\n+    // Adjust for the prefix.\n+    return maxLine + prefixPosition.getLineNumber();\n+  }\n+\n+  /**\n+   * A mapping from a given position in an input source file to a given position\n+   * in the generated code.\n+   */\n+  static class Mapping {\n+    /**\n+     * A unique ID for this mapping for record keeping purposes.\n+     */\n+    int id = UNMAPPED;\n+\n+    /**\n+     * The source file index.\n+     */\n+    int sourceFile;\n+\n+    /**\n+     * The position of the code in the input source file. Both\n+     * the line number and the character index are indexed by\n+     * 1 for legacy reasons via the Rhino Node class.\n+     */\n+    Position originalPosition;\n+\n+    /**\n+     * The starting position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    Position startPosition;\n+\n+    /**\n+     * The ending position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    Position endPosition;\n+\n+    /**\n+     * The original name of the token found at the position\n+     * represented by this mapping (if any).\n+     */\n+    String originalName;\n+\n+    /**\n+     * Whether the mapping is actually used by the source map.\n+     */\n+    boolean used = false;\n+  }\n+\n+  private class MappingWriter {\n+    /**\n+     * Cache of escaped source file name.\n+     */\n+    private int lastLine = 0;\n+    private String lastLineString = String.valueOf(0);\n+\n+    /**\n+     * Appends the mapping to the given buffer.\n+     */\n+    private void appendMappingTo(\n+        Mapping m, Appendable out) throws IOException {\n+      out.append(\"[\");\n+\n+      out.append(String.valueOf(m.sourceFile));\n+      out.append(\",\");\n+\n+      int line = m.originalPosition.getLineNumber();\n+      if (line != lastLine) {\n+        lastLineString = String.valueOf(line);\n+      }\n+      String lineValue = lastLineString;\n+\n+      out.append(lineValue);\n+\n+      out.append(\",\");\n+      out.append(String.valueOf(\n+          m.originalPosition.getCharacterIndex()));\n+\n+      if (m.originalName != null) {\n+        out.append(\",\");\n+        out.append(escapeString(m.originalName));\n+      }\n+\n+      out.append(\"],\\n\");\n+    }\n+\n+    /**\n+     * Add used mappings to the supplied Appendable.\n+     */\n+    void appendMappings(Appendable out) throws IOException {\n+      for (Mapping m : mappings) {\n+        if (m.used) {\n+          appendMappingTo(m, out);\n+        }\n+      }\n+    }\n+  }\n+\n+  private class LineMapper implements MappingVisitor {\n+    // The destination.\n+    private final Appendable out;\n+\n+    // Whether the current line has had a value written yet.\n+    private int lastId = UNMAPPED;\n+\n+    LineMapper(Appendable out) {\n+      this.out = out;\n+    }\n+\n+    /**\n+     * As each segment is visited write out the appropriate line mapping.\n+     */\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+      throws IOException {\n+\n+      int id = (m != null) ? m.id : UNMAPPED;\n+\n+      for (int i = line; i <= nextLine; i++) {\n+        if (i == nextLine) {\n+          closeEntry(id, nextCol-col);\n+          break;\n+        }\n+\n+        closeLine(false);\n+        openLine();\n+\n+        // Set the starting location for the next line.\n+        col = 0;\n+      }\n+    }\n+\n+    // Append the line mapping entries.\n+    void appendLineMappings() throws IOException {\n+      // Start the first line.\n+      openLine();\n+\n+      (new MappingTraversal()).traverse(this);\n+\n+      // And close the final line.\n+      closeLine(true);\n+    }\n+\n+    /**\n+     * Begin the entry for a new line.\n+     */\n+    private void openLine() throws IOException {\n+      out.append(\"\\\"\");\n+      // The first id of the line is not relative.\n+      this.lastId = 0;\n+    }\n+\n+    /**\n+     * End the entry for a line.\n+     */\n+    private void closeLine(boolean finalEntry) throws IOException {\n+      if (finalEntry) {\n+        out.append(\"\\\"\");\n+      } else {\n+        out.append(\"\\\",\\n\");\n+      }\n+    }\n+\n+    private void closeEntry(int id, int reps) throws IOException {\n+      if (reps == 0) {\n+        return;\n+      }\n+\n+      StringBuilder sb = new StringBuilder();\n+      LineMapEncoder.encodeEntry(sb, id, lastId, reps);\n+\n+      if (validate) {\n+        LineMapDecoder.LineEntry entry = LineMapDecoder.decodeLineEntry(\n+            sb.toString(), lastId);\n+        Preconditions.checkState(entry.id == id && entry.reps == reps,\n+            \"expected (%s,%s) but got (%s,%s)\",\n+            id, reps, entry.id, entry.reps);\n+      }\n+\n+      out.append(sb);\n+      lastId = id;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static class LineMapEncoder {\n+    /**\n+     * The source map line map is consists of a series of entries each\n+     * representing a map entry and a repetition count of that entry.\n+     *\n+     * @param out The entry destination.\n+     * @param id  The id for the entry.\n+     * @param lastId The previous id written, used to generate a relative\n+     *     map id.\n+     * @param reps The number of times the id is repeated in the map.\n+     * @throws IOException\n+     */\n+    static void encodeEntry(Appendable out, int id, int lastId, int reps)\n+        throws IOException {\n+      Preconditions.checkState(reps > 0);\n+      int relativeIdLength = getRelativeMappingIdLength(id, lastId);\n+      int relativeId = getRelativeMappingId(id, relativeIdLength, lastId);\n+\n+      String relativeIdString = valueToBase64(relativeId, relativeIdLength);\n+\n+      // If we can, we use a single base64 digit to encode both the id length\n+      // and the repetition count.  The current best division of the base64\n+      // digit (which has 6 bits) is 2 bits for the id length (1-4 digits) and\n+      // 4 bit for the repetition count (1-16 repetitions).  If either of these\n+      // two values are exceeded a \"!\" is written (a non-base64 character) to\n+      // signal the a full base64 character is used for repetition count and\n+      // the mapping id length.  As the repetition count can exceed 64, we\n+      // allow the \"escape\" (\"!\") to be repeated to signal additional\n+      // repetition count length characters.  It is extremely unlikely that\n+      // mapping id length will exceed 64 base64 characters in length so\n+      // additional \"!\" don't signal additional id length characters.\n+      if (reps > 16 || relativeIdLength > 4) {\n+        String repsString = valueToBase64(reps -1, 1);\n+        for (int i = 0; i < repsString.length(); i++) {\n+          // TODO(johnlenz): update this to whatever is agreed to.\n+          out.append('!');\n+        }\n+        String sizeId = valueToBase64(relativeIdString.length() -1, 1);\n+\n+        out.append(sizeId);\n+        out.append(repsString);\n+      } else {\n+        int prefix = ((reps -1) << 2) + (relativeIdString.length() -1);\n+        Preconditions.checkState(prefix < 64 && prefix >= 0,\n+            \"prefix (%s) reps(%s) map id size(%s)\",\n+            prefix, reps, relativeIdString.length());\n+        out.append(valueToBase64(prefix, 1));\n+      }\n+      out.append(relativeIdString);\n+    }\n+\n+    /**\n+     * @param idLength the length relative id, when encoded in as a base64\n+     *     value. @see #getRelativeMappingIdLength\n+     * @return A value relative to the the lastId.  Negative value are\n+     * represented as a two-complement value.\n+     */\n+    static int getRelativeMappingId(int id, int idLength, int lastId) {\n+      int base = 1 << (idLength *6);\n+      int relativeId = id - lastId;\n+      return (relativeId < 0) ? relativeId + base : relativeId;\n+    }\n+\n+    /**\n+     * @return The length of the base64 number needed to include the id.\n+     */\n+    static int getRelativeMappingIdLength(int rawId, int lastId) {\n+      Preconditions.checkState(rawId >= 0 || rawId == UNMAPPED);\n+      int relativeId = rawId - lastId;\n+      int id = (relativeId < 0 ? Math.abs(relativeId) -1 : relativeId) << 1;\n+      int digits = 1;\n+      int base = 64;\n+      while (id >= base) {\n+        digits++;\n+        base *= 64;\n+      }\n+      return digits;\n+    }\n+\n+    /**\n+     * @return return the base64 number encoding the provided value,\n+     *    padded if necessary to create a number with the given minimum length.\n+     */\n+    static String valueToBase64(int value, int minimumSize) {\n+      int size = 0;\n+      char chars[] = new char[4];\n+      do {\n+        int charValue = value & 63; // base64 chars\n+        value = value >>> 6; // get the next value;\n+        chars[size++] = BASE64_MAP.charAt(charValue);\n+      } while (value > 0);\n+\n+      StringBuilder sb = new StringBuilder(size);\n+\n+      while (minimumSize > size) {\n+        sb.append(BASE64_MAP.charAt(0));\n+        minimumSize--;\n+      }\n+      while (size > 0) {\n+        sb.append(chars[--size]);\n+      }\n+      return sb.toString();\n+    }\n+  }\n+\n+  /**\n+   * A line mapping decoder class used for testing and validation.\n+   */\n+  @VisibleForTesting\n+  static class LineMapDecoder {\n+    private static LineEntry decodeLineEntry(String in, int lastId) {\n+      return decodeLineEntry(new StringParser(in), lastId);\n+    }\n+\n+    private static LineEntry decodeLineEntry(StringParser reader, int lastId) {\n+      int repDigits = 0;\n+\n+      // Determine the number of digits used for the repetition count.\n+      // Each \"!\" indicates another base64 digit.\n+      for (char peek = reader.peek(); peek == '!'; peek = reader.peek()) {\n+        repDigits++;\n+        reader.next(); // consume the \"!\"\n+      }\n+\n+      int idDigits = 0;\n+      int reps = 0;\n+      if (repDigits == 0) {\n+        // No repetition digit escapes, so the next character represents the\n+        // number of digits in the id (bottom 2 bits) and the number of\n+        // repetitions (top 4 digits).\n+        char digit = reader.next();\n+        int value = addBase64Digit(digit, 0);\n+        reps = (value >> 2);\n+        idDigits = (value & 3);\n+      } else {\n+        char digit = reader.next();\n+        idDigits = addBase64Digit(digit, 0);\n+\n+        int value = 0;\n+        for (int i = 0; i < repDigits; i++) {\n+          digit = reader.next();\n+          value = addBase64Digit(digit, value);\n+        }\n+        reps = value;\n+      }\n+\n+      // Adjust for 1 offset encoding.\n+      reps += 1;\n+      idDigits += 1;\n+\n+      // Decode the id token.\n+      int value = 0;\n+      for (int i = 0; i < idDigits; i++) {\n+        char digit = reader.next();\n+        value = addBase64Digit(digit, value);\n+      }\n+      int mappingId = getIdFromRelativeId(value, idDigits, lastId);\n+      return new LineEntry(mappingId, reps);\n+    }\n+\n+    static List<Integer> decodeLine(String lineSource) {\n+      return decodeLine(new StringParser(lineSource));\n+    }\n+\n+    static private List<Integer> decodeLine(StringParser reader) {\n+      List<Integer> result = Lists.newArrayListWithCapacity(512);\n+      int lastId = 0;\n+      do {\n+        LineEntry entry = decodeLineEntry(reader, lastId);\n+        lastId = entry.id;\n+\n+        for (int i=0; i < entry.reps; i++) {\n+          result.add(entry.id);\n+        }\n+      } while(reader.hasNext());\n+\n+      return result;\n+    }\n+\n+    /**\n+     * Build base64 number a digit at a time, most significant digit first.\n+     */\n+    private static int addBase64Digit(char digit, int previousValue) {\n+      return (previousValue * 64) + BASE64_MAP.indexOf(digit);\n+    }\n+\n+    /**\n+     * @return the id from the relative id.\n+     */\n+    static int getIdFromRelativeId(int rawId, int digits, int lastId) {\n+      // The value range depends on the number of digits\n+      int base = 1 << (digits * 6);\n+      return ((rawId >= base/2) ? rawId - base : rawId) + lastId;\n+      // return (rawId - (base/2)) + lastId;\n+    }\n+\n+    static class LineEntry {\n+      final int id;\n+      final int reps;\n+      public LineEntry(int id, int reps) {\n+        this.id = id;\n+        this.reps = reps;\n+      }\n+    }\n+\n+    /**\n+     * A simple class for maintaining the current location\n+     * in the input.\n+     */\n+    static class StringParser {\n+      final String content;\n+      int current = 0;\n+\n+      StringParser(String content) {\n+        this.content = content;\n+      }\n+\n+      char next() {\n+        return content.charAt(current++);\n+      }\n+\n+      char peek() {\n+        return content.charAt(current);\n+      }\n+\n+      boolean hasNext() {\n+        return  current < content.length() -1;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Mark any visited mapping as \"used\".\n+   */\n+  private class UsedMappingCheck implements MappingVisitor {\n+    /**\n+     * @throws IOException\n+     */\n+    @Override\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+        throws IOException {\n+      if (m != null) {\n+        m.used = true;\n+      }\n+    }\n+  }\n+\n+  private interface MappingVisitor {\n+    /**\n+     * @param m The mapping for the current code segment. null if the segment\n+     *     is unmapped.\n+     * @param line The starting line for this code segment.\n+     * @param col The starting column for this code segment.\n+     * @param endLine The ending line\n+     * @param endCol The ending column\n+     * @throws IOException\n+     */\n+    void visit(Mapping m, int line, int col, int endLine, int endCol)\n+        throws IOException;\n+  }\n+\n+  /**\n+   * Walk the mappings and visit each segment of the mappings, unmapped\n+   * segments are visited with a null mapping, unused mapping are not visited.\n+   */\n+  private class MappingTraversal {\n+    // The last line and column written\n+    private int line;\n+    private int col;\n+\n+    MappingTraversal() {\n+    }\n+\n+    // Append the line mapping entries.\n+    void traverse(MappingVisitor v) throws IOException {\n+      // The mapping list is ordered as a pre-order traversal.  The mapping\n+      // positions give us enough information to rebuild the stack and this\n+      // allows the building of the source map in O(n) time.\n+      Deque<Mapping> stack = new ArrayDeque<Mapping>();\n+      for (Mapping m : mappings) {\n+        // Find the closest ancestor of the current mapping:\n+        // An overlapping mapping is an ancestor of the current mapping, any\n+        // non-overlapping mappings are siblings (or cousins) and must be\n+        // closed in the reverse order of when they encountered.\n+        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n+          Mapping previous = stack.pop();\n+          maybeVisit(v, previous);\n+        }\n+\n+        // Any gaps between the current line position and the start of the\n+        // current mapping belong to the parent.\n+        Mapping parent = stack.peek();\n+        maybeVisitParent(v, parent, m);\n+\n+        stack.push(m);\n+      }\n+\n+      // There are no more children to be had, simply close the remaining\n+      // mappings in the reverse order of when they encountered.\n+      while (!stack.isEmpty()) {\n+        Mapping m = stack.pop();\n+        maybeVisit(v, m);\n+      }\n+    }\n+\n+    /**\n+     * @return The line adjusted for the prefix position.\n+     */\n+    private int getAdjustedLine(Position p) {\n+      return p.getLineNumber() + prefixPosition.getLineNumber();\n+    }\n+\n+    /**\n+     * @return The column adjusted for the prefix position.\n+     */\n+    private int getAdjustedCol(Position p) {\n+      int rawLine = p.getLineNumber();\n+      int rawCol = p.getCharacterIndex();\n+      // Only the first line needs the character position adjusted.\n+      return (rawLine != 0)\n+          ? rawCol : rawCol + prefixPosition.getCharacterIndex();\n+    }\n+\n+    /**\n+     * @return Whether m1 ends before m2 starts.\n+     */\n+    private boolean isOverlapped(Mapping m1, Mapping m2) {\n+      // No need to use adjusted values here, relative positions are sufficient.\n+      int l1 = m1.endPosition.getLineNumber();\n+      int l2 = m2.startPosition.getLineNumber();\n+      int c1 = m1.endPosition.getCharacterIndex();\n+      int c2 = m2.startPosition.getCharacterIndex();\n+\n+      return (l1 == l2 && c1 >= c2) || l1 > l2;\n+    }\n+\n+    /**\n+     * Write any needed entries from the current position to the end of the\n+     * provided mapping.\n+     */\n+    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {\n+      int nextLine = getAdjustedLine(m.endPosition);\n+      int nextCol = getAdjustedCol(m.endPosition);\n+      // If this anything remaining in this mapping beyond the\n+      // current line and column position, write it out now.\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, m, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any needed entries to complete the provided mapping.\n+     */\n+    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)\n+        throws IOException {\n+      int nextLine = getAdjustedLine(m.startPosition);\n+      int nextCol = getAdjustedCol(m.startPosition);\n+      // If the previous value is null, no mapping exists.\n+      Preconditions.checkState(line < nextLine || col <= nextCol);\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, parent, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any entries needed between the current position the next position\n+     * and update the current position.\n+     */\n+    private void visit(MappingVisitor v, Mapping m,\n+        int nextLine, int nextCol)\n+        throws IOException {\n+      Preconditions.checkState(line <= nextLine);\n+      Preconditions.checkState(line < nextLine || col < nextCol);\n+\n+      if (line == nextLine && col == nextCol) {\n+        // Nothing to do.\n+        Preconditions.checkState(false);\n+        return;\n+      }\n+\n+      v.visit(m, line, col, nextLine, nextCol);\n+\n+      line = nextLine;\n+      col = nextCol;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/SourceMapLegacy.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.Node;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.List;\n+\n+/**\n+ * Collects information mapping the generated (compiled) source back to\n+ * its original source for debugging purposes.\n+ *\n+ * @see CodeConsumer\n+ * @see CodeGenerator\n+ * @see CodePrinter\n+ *\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMapLegacy implements SourceMap {\n+\n+  private final static int UNMAPPED = -1;\n+\n+\n+  /**\n+   * A mapping from a given position in an input source file to a given position\n+   * in the generated code.\n+   */\n+  static class Mapping {\n+    /**\n+     * A unique ID for this mapping for record keeping purposes.\n+     */\n+    int id = UNMAPPED;\n+\n+    /**\n+     * The input source file.\n+     */\n+    String sourceFile;\n+\n+    /**\n+     * The position of the code in the input source file. Both\n+     * the line number and the character index are indexed by\n+     * 1 for legacy reasons via the Rhino Node class.\n+     */\n+    Position originalPosition;\n+\n+    /**\n+     * The starting position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    Position startPosition;\n+\n+    /**\n+     * The ending position of the code in the generated source\n+     * file which this mapping represents. Indexed by 0.\n+     */\n+    Position endPosition;\n+\n+    /**\n+     * The original name of the token found at the position\n+     * represented by this mapping (if any).\n+     */\n+    String originalName;\n+\n+    /**\n+     * Whether the mapping is actually used by the source map.\n+     */\n+    boolean used = false;\n+  }\n+\n+  private class MappingWriter {\n+    /**\n+     * Cache of escaped source file name.\n+     */\n+    private String lastSourceFile = null;\n+    private String lastSourceFileEscaped = null;\n+    private int lastLine = 0;\n+    private String lastLineString = String.valueOf(0);\n+\n+    /**\n+     * Appends the mapping to the given buffer.\n+     */\n+    private void appendMappingTo(\n+        Mapping m, Appendable out) throws IOException {\n+      out.append(\"[\");\n+\n+      String sourceFile = m.sourceFile;\n+      // The source file rarely changes, so cache the escaped string.\n+      String escapedSourceFile;\n+      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)\n+        lastSourceFile = sourceFile;\n+        lastSourceFileEscaped = escapeString(sourceFile);\n+      }\n+      escapedSourceFile = lastSourceFileEscaped;\n+\n+      out.append(escapedSourceFile);\n+      out.append(\",\");\n+\n+      int line = m.originalPosition.getLineNumber();\n+      if (line != lastLine) {\n+        lastLineString = String.valueOf(line);\n+      }\n+      String lineValue = lastLineString;\n+\n+      out.append(lineValue);\n+\n+      out.append(\",\");\n+      out.append(String.valueOf(\n+          m.originalPosition.getCharacterIndex()));\n+\n+      if (m.originalName != null) {\n+        out.append(\",\");\n+        out.append(escapeString(m.originalName));\n+      }\n+\n+      out.append(\"]\\n\");\n+    }\n+\n+    /**\n+     * Add used mappings to the supplied Appendable.\n+     */\n+    void appendMappings(Appendable out) throws IOException {\n+      for (Mapping m : mappings) {\n+        if (m.used) {\n+          appendMappingTo(m, out);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A pre-order traversal ordered list of mappings stored in this map.\n+   */\n+  private List<Mapping> mappings = Lists.newArrayList();\n+\n+  /**\n+   * For validation store the start of the last mapping added.\n+   */\n+  private Mapping lastMapping;\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * buffer being used to generated the compiled source file.\n+   */\n+  private Position offsetPosition = new Position(0, 0);\n+\n+  /**\n+   * The position that the current source map is offset in the\n+   * generated the compiled source file by the addition of a\n+   * an output wrapper prefix.\n+   */\n+  private Position prefixPosition = new Position(0, 0);\n+\n+  /**\n+   * Escapes the given string for JSON.\n+   */\n+  private static String escapeString(String value) {\n+    return CodeGenerator.escapeToDoubleQuotedJsString(value);\n+  }\n+\n+  /**\n+   * Adds a mapping for the given node.  Mappings must be added in order.\n+   *\n+   * @param node The node that the new mapping represents.\n+   * @param startPosition The position on the starting line\n+   * @param endPosition The position on the ending line.\n+   */\n+  public void addMapping(Node node, Position startPosition, Position endPosition) {\n+    String sourceFile = (String)node.getProp(Node.SOURCENAME_PROP);\n+\n+    // If the node does not have an associated source file or\n+    // its line number is -1, then the node does not have sufficient\n+    // information for a mapping to be useful.\n+    if (sourceFile == null || node.getLineno() < 0) {\n+      return;\n+    }\n+\n+    // Create the new mapping.\n+    Mapping mapping = new Mapping();\n+    mapping.sourceFile = sourceFile;\n+    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n+\n+    String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n+    if (originalName != null) {\n+      mapping.originalName = originalName;\n+    }\n+\n+    if (offsetPosition.getLineNumber() == 0\n+        && offsetPosition.getCharacterIndex() == 0) {\n+      mapping.startPosition = startPosition;\n+      mapping.endPosition = endPosition;\n+    } else {\n+      // If the mapping is found on the first line, we need to offset\n+      // its character position by the number of characters found on\n+      // the *last* line of the source file to which the code is\n+      // being generated.\n+      int offsetLine = offsetPosition.getLineNumber();\n+      int startOffsetPosition = offsetPosition.getCharacterIndex();\n+      int endOffsetPosition = offsetPosition.getCharacterIndex();\n+\n+      if (startPosition.getLineNumber() > 0) {\n+        startOffsetPosition = 0;\n+      }\n+\n+      if (endPosition.getLineNumber() > 0) {\n+        endOffsetPosition = 0;\n+      }\n+\n+      mapping.startPosition =\n+          new Position(startPosition.getLineNumber() + offsetLine,\n+                       startPosition.getCharacterIndex() + startOffsetPosition);\n+\n+      mapping.endPosition =\n+          new Position(endPosition.getLineNumber() + offsetLine,\n+                       endPosition.getCharacterIndex() + endOffsetPosition);\n+    }\n+\n+    // Validate the mappings are in a proper order.\n+    if (lastMapping != null) {\n+      int lastLine = lastMapping.startPosition.getLineNumber();\n+      int lastColumn = lastMapping.startPosition.getCharacterIndex();\n+      int nextLine = mapping.startPosition.getLineNumber();\n+      int nextColumn = mapping.startPosition.getCharacterIndex();\n+      Preconditions.checkState(nextLine > lastLine\n+          || (nextLine == lastLine && nextColumn >= lastColumn),\n+          \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n+          + \"new : (%s,%s)\\nnode : %s\",\n+          lastLine, lastColumn, nextLine, nextColumn, node);\n+    }\n+\n+    lastMapping = mapping;\n+    mappings.add(mapping);\n+  }\n+\n+  /**\n+   * Sets the prefix used for wrapping the generated source file before\n+   * it is output. This ensures that the source map is adjusted as\n+   * needed.\n+   *\n+   * @param prefix The prefix that is added before the generated source code.\n+   */\n+  public void setWrapperPrefix(String prefix) {\n+    // Determine the current line and character position.\n+    int prefixLine = 0;\n+    int prefixIndex = 0;\n+\n+    for (int i = 0; i < prefix.length(); ++i) {\n+      if (prefix.charAt(i) == '\\n') {\n+        prefixLine++;\n+        prefixIndex = 0;\n+      } else {\n+        prefixIndex++;\n+      }\n+    }\n+\n+    prefixPosition = new Position(prefixLine, prefixIndex);\n+  }\n+\n+  /**\n+   * Sets the source code that exists in the buffer to which the\n+   * generated code is being generated. This ensures that the source map\n+   * accurately reflects the fact that the source is being appended to\n+   * an existing buffer and as such, does not start at line 0, position 0\n+   * but rather some other line and position.\n+   *\n+   * @param offsetLine The index of the current line being printed.\n+   * @param offsetIndex The column index of the current character being printed.\n+   */\n+  public void setStartingPosition(int offsetLine, int offsetIndex) {\n+    Preconditions.checkState(offsetLine >= 0);\n+    Preconditions.checkState(offsetIndex >= 0);\n+    offsetPosition = new Position(offsetLine, offsetIndex);\n+  }\n+\n+  /**\n+   * Resets the source map for reuse for the generation of a new source file.\n+   */\n+  public void reset() {\n+    mappings = Lists.newArrayList();\n+    lastMapping = null;\n+    offsetPosition = new Position(0, 0);\n+    prefixPosition = new Position(0, 0);\n+  }\n+\n+  /**\n+   * Appends the source map in LavaBug format to the given buffer.\n+   *\n+   * @param out The stream to which the map will be appended.\n+   * @param name The name of the generated source file that this source map\n+   *   represents.\n+   */\n+  public void appendTo(Appendable out, String name) throws IOException {\n+    // Write the mappings out to the file. The format of the generated\n+    // source map is three sections, each deliminated by a magic comment.\n+    //\n+    // The first section contains an array for each line of the generated\n+    // code, where each element in the array is the ID of the mapping which\n+    // best represents the index-th character found on that line of the\n+    // generated source code.\n+    //\n+    // The second section contains an array per generated line. Unused.\n+    //\n+    // The third and final section contains an array per line, each of which\n+    // represents a mapping with a unique ID. The mappings are added in order.\n+    // The array itself contains a tuple representing\n+    // ['source file', line, col (, 'original name')]\n+    //\n+    // Example for 2 lines of generated code (with line numbers added for\n+    // readability):\n+    //\n+    // 1)  /** Begin line maps. **/{ \"count\": 2 }\n+    // 2)  [0,0,0,0,0,0,1,1,1,1,2]\n+    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n+    // 4)  /** Begin file information. **/\n+    // 5)  []\n+    // 6)  []\n+    // 7)  /** Begin mapping definitions. **/\n+    // 8)  [\"a.js\", 1, 34]\n+    // 9)  [\"a.js\", 5, 2]\n+    // 10) [\"b.js\", 1, 3, \"event\"]\n+    // 11) [\"c.js\", 1, 4]\n+    // 12) [\"d.js\", 3, 78, \"foo\"]\n+\n+    int maxLine = prepMappings();\n+\n+    // Add the line character maps.\n+    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n+    out.append(escapeString(name));\n+    out.append(\", \\\"count\\\": \");\n+    out.append(String.valueOf(maxLine + 1));\n+    out.append(\" }\\n\");\n+    (new LineMapper(out)).appendLineMappings();\n+\n+    // Add the source file maps.\n+    out.append(\"/** Begin file information. **/\\n\");\n+\n+    // This section is unused but we need one entry per line to\n+    // prevent changing the format.\n+    for (int i = 0; i <= maxLine; ++i) {\n+      out.append(\"[]\\n\");\n+    }\n+\n+    // Add the mappings themselves.\n+    out.append(\"/** Begin mapping definitions. **/\\n\");\n+\n+    (new MappingWriter()).appendMappings(out);\n+  }\n+\n+  /**\n+   * Assigns sequential ids to used mappings, and returns the last line mapped.\n+   */\n+  private int prepMappings() throws IOException {\n+    // Mark any unused mappings.\n+    (new MappingTraversal()).traverse(new UsedMappingCheck());\n+\n+    // Renumber used mappings and keep track of the last line.\n+    int id = 0;\n+    int maxLine = 0;\n+    for (Mapping m : mappings) {\n+      if (m.used) {\n+        m.id = id++;\n+        int endPositionLine = m.endPosition.getLineNumber();\n+        maxLine = Math.max(maxLine, endPositionLine);\n+      }\n+    }\n+\n+    // Adjust for the prefix.\n+    return maxLine + prefixPosition.getLineNumber();\n+  }\n+\n+  private class LineMapper implements MappingVisitor {\n+    // The destination.\n+    private final Appendable out;\n+\n+    // Whether the current line has had a value written yet.\n+    private boolean firstChar = true;\n+\n+    private final static String UNMAPPED_STRING = \"-1\";\n+\n+    private int lastId = UNMAPPED;\n+    private String lastIdString = UNMAPPED_STRING;\n+\n+    LineMapper(Appendable out) {\n+      this.out = out;\n+    }\n+\n+    /**\n+     * As each segment is visited write out the appropriate line mapping.\n+     */\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+      throws IOException {\n+\n+      int id = (m != null) ? m.id : UNMAPPED;\n+      if (lastId != id) {\n+        // Prevent the creation of unnecessary temporary stings for often\n+        // repeated values.\n+        lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n+        lastId = id;\n+      }\n+      String idString = lastIdString;\n+\n+      for (int i = line; i <= nextLine; i++) {\n+        if (i == nextLine) {\n+          for (int j = col; j < nextCol; j++) {\n+            addCharEntry(idString);\n+          }\n+          break;\n+        }\n+\n+        closeLine();\n+        openLine();\n+\n+        // Set the starting location for the next line.\n+        col = 0;\n+      }\n+    }\n+\n+    // Append the line mapping entries.\n+    void appendLineMappings() throws IOException {\n+      // Start the first line.\n+      openLine();\n+\n+      (new MappingTraversal()).traverse(this);\n+\n+      // And close the final line.\n+      closeLine();\n+    }\n+\n+    /**\n+     * Begin the entry for a new line.\n+     */\n+    private void openLine() throws IOException {\n+      if (out != null) {\n+        out.append(\"[\");\n+        this.firstChar = true;\n+      }\n+    }\n+\n+    /**\n+     * End the entry for a line.\n+     */\n+    private void closeLine() throws IOException {\n+      if (out != null) {\n+        out.append(\"]\\n\");\n+      }\n+    }\n+\n+    /**\n+     * Add a new char position entry.\n+     * @param id The mapping id to record.\n+     */\n+    private void addCharEntry(String id) throws IOException {\n+      if (out != null) {\n+        if (firstChar) {\n+          firstChar = false;\n+        } else {\n+          out.append(\",\");\n+        }\n+        out.append(id);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Mark any visited mapping as \"used\".\n+   */\n+  private class UsedMappingCheck implements MappingVisitor {\n+    /**\n+     * @throws IOException\n+     */\n+    @Override\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+        throws IOException {\n+      if (m != null) {\n+        m.used = true;\n+      }\n+    }\n+  }\n+\n+  private interface MappingVisitor {\n+    /**\n+     * @param m The mapping for the current code segment. null if the segment\n+     *     is unmapped.\n+     * @param line The starting line for this code segment.\n+     * @param col The starting column for this code segment.\n+     * @param endLine The ending line\n+     * @param endCol The ending column\n+     * @throws IOException\n+     */\n+    void visit(Mapping m, int line, int col, int endLine, int endCol)\n+        throws IOException;\n+  }\n+\n+  /**\n+   * Walk the mappings and visit each segment of the mappings, unmapped\n+   * segments are visited with a null mapping, unused mapping are not visited.\n+   */\n+  private class MappingTraversal {\n+    // The last line and column written\n+    private int line;\n+    private int col;\n+\n+    MappingTraversal() {\n+    }\n+\n+    // Append the line mapping entries.\n+    void traverse(MappingVisitor v) throws IOException {\n+      // The mapping list is ordered as a pre-order traversal.  The mapping\n+      // positions give us enough information to rebuild the stack and this\n+      // allows the building of the source map in O(n) time.\n+      Deque<Mapping> stack = new ArrayDeque<Mapping>();\n+      for (Mapping m : mappings) {\n+        // Find the closest ancestor of the current mapping:\n+        // An overlapping mapping is an ancestor of the current mapping, any\n+        // non-overlapping mappings are siblings (or cousins) and must be\n+        // closed in the reverse order of when they encountered.\n+        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n+          Mapping previous = stack.pop();\n+          maybeVisit(v, previous);\n+        }\n+\n+        // Any gaps between the current line position and the start of the\n+        // current mapping belong to the parent.\n+        Mapping parent = stack.peek();\n+        maybeVisitParent(v, parent, m);\n+\n+        stack.push(m);\n+      }\n+\n+      // There are no more children to be had, simply close the remaining\n+      // mappings in the reverse order of when they encountered.\n+      while (!stack.isEmpty()) {\n+        Mapping m = stack.pop();\n+        maybeVisit(v, m);\n+      }\n+    }\n+\n+    /**\n+     * @return The line adjusted for the prefix position.\n+     */\n+    private int getAdjustedLine(Position p) {\n+      return p.getLineNumber() + prefixPosition.getLineNumber();\n+    }\n+\n+    /**\n+     * @return The column adjusted for the prefix position.\n+     */\n+    private int getAdjustedCol(Position p) {\n+      int rawLine = p.getLineNumber();\n+      int rawCol = p.getCharacterIndex();\n+      // Only the first line needs the character position adjusted.\n+      return (rawLine != 0)\n+          ? rawCol : rawCol + prefixPosition.getCharacterIndex();\n+    }\n+\n+    /**\n+     * @return Whether m1 ends before m2 starts.\n+     */\n+    private boolean isOverlapped(Mapping m1, Mapping m2) {\n+      // No need to use adjusted values here, relative positions are sufficient.\n+      int l1 = m1.endPosition.getLineNumber();\n+      int l2 = m2.startPosition.getLineNumber();\n+      int c1 = m1.endPosition.getCharacterIndex();\n+      int c2 = m2.startPosition.getCharacterIndex();\n+\n+      return (l1 == l2 && c1 >= c2) || l1 > l2;\n+    }\n+\n+    /**\n+     * Write any needed entries from the current position to the end of the\n+     * provided mapping.\n+     */\n+    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {\n+      int nextLine = getAdjustedLine(m.endPosition);\n+      int nextCol = getAdjustedCol(m.endPosition);\n+      // If this anything remaining in this mapping beyond the\n+      // current line and column position, write it out now.\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, m, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any needed entries to complete the provided mapping.\n+     */\n+    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)\n+        throws IOException {\n+      int nextLine = getAdjustedLine(m.startPosition);\n+      int nextCol = getAdjustedCol(m.startPosition);\n+      // If the previous value is null, no mapping exists.\n+      Preconditions.checkState(line < nextLine || col <= nextCol);\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, parent, nextLine, nextCol);\n+      }\n+    }\n+\n+    /**\n+     * Write any entries needed between the current position the next position\n+     * and update the current position.\n+     */\n+    private void visit(MappingVisitor v, Mapping m,\n+        int nextLine, int nextCol)\n+        throws IOException {\n+      Preconditions.checkState(line <= nextLine);\n+      Preconditions.checkState(line < nextLine || col < nextCol);\n+\n+      if (line == nextLine && col == nextCol) {\n+        // Nothing to do.\n+        Preconditions.checkState(false);\n+        return;\n+      }\n+\n+      v.visit(m, line, col, nextLine, nextCol);\n+\n+      line = nextLine;\n+      col = nextCol;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/SourceMap2Test.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.SourceMap.DetailLevel;\n+import com.google.javascript.jscomp.SourceMap2.LineMapDecoder;\n+import com.google.javascript.jscomp.SourceMap2.LineMapEncoder;\n+\n+import junit.framework.TestCase;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Tests for {@link SourceMap}.\n+ *\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class SourceMap2Test extends TestCase {\n+  private static final JSSourceFile[] EXTERNS = {\n+      JSSourceFile.fromCode(\"externs\", \"\")\n+  };\n+\n+  private DetailLevel detailLevel = SourceMap.DetailLevel.ALL;\n+\n+  @Override\n+  public void setUp() {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+  }\n+\n+  public void testBasicMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__() { }\");\n+  }\n+\n+  public void testBasicMappingGoldenOutput() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"function __BASIC__() { }\",\n+\n+                   //\"/** Source Map **/\\n\" +\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"cAkBEBEB\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9],\\n\" +\n+                   \"[0,1,9,\\\"__BASIC__\\\"],\\n\" +\n+                   \"[0,1,18],\\n\" +\n+                   \"[0,1,21],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testLiteralMappings() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n+                    \"var __VAR__ = '__STR__'; }\");\n+  }\n+\n+  public void testLiteralMappingsGoldenOutput() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"function __BASIC__(__PARAM1__, __PARAM2__) { \" +\n+                   \"var __VAR__ = '__STR__'; }\",\n+\n+                   //\"/** Source Map **/\\n\" +\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"cAkBABkBA/kCA+ADMBcBgBA9\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9],\\n\" +\n+                   \"[0,1,9,\\\"__BASIC__\\\"],\\n\" +\n+                   \"[0,1,18],\\n\" +\n+                   \"[0,1,19,\\\"__PARAM1__\\\"],\\n\" +\n+                   \"[0,1,31,\\\"__PARAM2__\\\"],\\n\" +\n+                   \"[0,1,43],\\n\" +\n+                   \"[0,1,45],\\n\" +\n+                   \"[0,1,49,\\\"__VAR__\\\"],\\n\" +\n+                   \"[0,1,59],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testMultilineMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = '__STR__';\\n\" +\n+                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n+                    \"}\");\n+  }\n+\n+  public void testMultiFunctionMapping() throws Exception {\n+    compileAndCheck(\"function __BASIC__(__PARAM1__, __PARAM2__) {\\n\" +\n+                    \"var __VAR__ = '__STR__';\\n\" +\n+                    \"var __ANO__ = \\\"__STR2__\\\";\\n\" +\n+                    \"}\\n\\n\" +\n+\n+                    \"function __BASIC2__(__PARAM3__, __PARAM4__) {\\n\" +\n+                    \"var __VAR2__ = '__STR2__';\\n\" +\n+                    \"var __ANO2__ = \\\"__STR3__\\\";\\n\" +\n+                    \"}\\n\\n\");\n+  }\n+\n+  public void testGoldenOutput0() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput1() throws Exception {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":\" +\n+                       \"[\\\"cAEBABIBA/ICA+ADICA/ICA+IDA9AEYBMBA5\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9],\\n\" +\n+                   \"[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,10],\\n\" +\n+                   \"[0,1,11,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,16,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,21],\\n\" +\n+                   \"[0,1,23],\\n\" +\n+                   \"[0,1,23,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,29,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,35,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,41],\\n\" +\n+                   \"[0,1,44],\\n\" +\n+                   \"[0,1,51,\\\"foo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+\n+    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n+\n+    checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"cAEBA/ICA+IDE9IEA8IFA7IGg6MHA5\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9],\\n\" +\n+                   \"[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,11,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,16,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,23,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,29,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,35,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,51,\\\"foo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput2() throws Exception {\n+    checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n+                   \"\\nreturn foo;\\n}\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":\" +\n+                       \"[\\\"cAEBABIBA/ICA+ADICA/ICA+IDA9IEYBMBA5\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"testcode\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,9],\\n\" +\n+                   \"[0,1,9,\\\"f\\\"],\\n\" +\n+                   \"[0,1,10],\\n\" +\n+                   \"[0,1,11,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,16,\\\"bar\\\"],\\n\" +\n+                   \"[0,1,21],\\n\" +\n+                   \"[0,5,0],\\n\" +\n+                   \"[0,5,0,\\\"foo\\\"],\\n\" +\n+                   \"[0,5,6,\\\"foo\\\"],\\n\" +\n+                   \"[0,5,12,\\\"bar\\\"],\\n\" +\n+                   \"[0,5,18,\\\"foo\\\"],\\n\" +\n+                   \"[0,6,0],\\n\" +\n+                   \"[0,6,7,\\\"foo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput3() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"IA\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"c:\\\\myfile.js\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,0,\\\"foo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput4() throws Exception {\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"foo;   boo;   goo;\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":1,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"IAMBMB\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"c:\\\\myfile.js\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,1,0,\\\"foo\\\"],\\n\" +\n+                   \"[0,1,7,\\\"boo\\\"],\\n\" +\n+                   \"[0,1,14,\\\"goo\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+  }\n+\n+  public void testGoldenOutput5() throws Exception {\n+    detailLevel = SourceMap.DetailLevel.ALL;\n+\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+                   \"/** @preserve\\n\" +\n+                   \" * this is a test.\\n\" +\n+                   \" */\\n\" +\n+                   \"var foo=a + 'this is a really long line that will force the\"\n+                   + \" mapping to span multiple lines 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \" 123456789 123456789 123456789 123456789 123456789\"\n+                   + \"' + c + d + e;\",\n+\n+                   \"{\\n\" +\n+                   \"\\\"version\\\":2,\\n\" +\n+                   \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+                   \"\\\"lineCount\\\":6,\\n\" +\n+                   \"\\\"lineMaps\\\":[\\\"\\\",\\n\" +\n+                   \"\\\"\\\",\\n\" +\n+                   \"\\\"\\\",\\n\" +\n+                   \"\\\"\\\",\\n\" +\n+                   \"\\\"MAMBABA/!!AUSC\\\",\\n\" +\n+                   \"\\\"AEA9AEA8AF\\\"],\\n\" +\n+                   \"\\\"sources\\\":[\\\"c:\\\\myfile.js\\\"],\\n\" +\n+                   \"\\\"mappings\\\":[[0,4,0],\\n\" +\n+                   \"[0,4,4,\\\"foo\\\"],\\n\" +\n+                   \"[0,4,8,\\\"a\\\"],\\n\" +\n+                   \"[0,4,12],\\n\" +\n+                   \"[0,4,1314,\\\"c\\\"],\\n\" +\n+                   \"[0,4,1318,\\\"d\\\"],\\n\" +\n+                   \"[0,4,1322,\\\"e\\\"],\\n\" +\n+                   \"]\\n\" +\n+                   \"}\\n\");\n+\n+    detailLevel = SourceMap.DetailLevel.SYMBOLS;\n+\n+    checkSourceMap(\"c:\\\\myfile.js\",\n+        \"/** @preserve\\n\" +\n+        \" * this is a test.\\n\" +\n+        \" */\\n\" +\n+        \"var foo=a + 'this is a really long line that will force the\"\n+        + \" mapping to span multiple lines 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \" 123456789 123456789 123456789 123456789 123456789\"\n+        + \"' + c + d + e;\",\n+\n+        \"{\\n\" +\n+        \"\\\"version\\\":2,\\n\" +\n+        \"\\\"file\\\":\\\"testcode\\\",\\n\" +\n+        \"\\\"lineCount\\\":6,\\n\" +\n+        \"\\\"lineMaps\\\":[\\\"\\\",\\n\" +\n+        \"\\\"\\\",\\n\" +\n+        \"\\\"\\\",\\n\" +\n+        \"\\\"\\\",\\n\" +\n+        \"\\\"M/MBAB\\\",\\n\" +\n+        \"\\\"ACA+ADA9AE\\\"],\\n\" +\n+        \"\\\"sources\\\":[\\\"c:\\\\myfile.js\\\"],\\n\" +\n+        \"\\\"mappings\\\":[[0,4,4,\\\"foo\\\"],\\n\" +\n+        \"[0,4,8,\\\"a\\\"],\\n\" +\n+        \"[0,4,1314,\\\"c\\\"],\\n\" +\n+        \"[0,4,1318,\\\"d\\\"],\\n\" +\n+        \"[0,4,1322,\\\"e\\\"],\\n\" +\n+        \"]\\n\" +\n+        \"}\\n\");\n+  }\n+\n+  public void testBasicDeterminism() throws Exception {\n+    RunResult result1 = compile(\"file1\", \"foo;\", \"file2\", \"bar;\");\n+    RunResult result2 = compile(\"file2\", \"foo;\", \"file1\", \"bar;\");\n+\n+    String map1 = getSourceMap(result1);\n+    String map2 = getSourceMap(result2);\n+\n+    // Assert that the files section of the maps are the same. The actual\n+    // entries will differ, so we cannot do a simple full comparison.\n+\n+    // Line 5 has the file information.\n+    String files1 = map1.split(\"\\n\")[4];\n+    String files2 = map2.split(\"\\n\")[4];\n+\n+    assertEquals(files1, files2);\n+  }\n+\n+  private int getRelativeId(int id, int lastId) {\n+    int length = LineMapEncoder.getRelativeMappingIdLength(id, lastId);\n+    int result = LineMapEncoder.getRelativeMappingId(id, length, lastId);\n+    int inverse = LineMapDecoder.getIdFromRelativeId(result, length, lastId);\n+    assertEquals(id, inverse);\n+    return result;\n+  }\n+\n+  public void testEncodingRelativeId() {\n+    assertEquals(0, getRelativeId(0, 0));\n+    assertEquals(64 + (-1), getRelativeId(-1, 0));\n+    assertEquals(64 + (-32), getRelativeId(0, 32));\n+    assertEquals(31, getRelativeId(31, 0));\n+    assertEquals(4096 + (-33), getRelativeId(0, 33));\n+    assertEquals(32, getRelativeId(32, 0));\n+  }\n+\n+  public void testEncodingIdLength() {\n+    assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(0, 0));\n+    assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(-1, 0));\n+    assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(0, 32));\n+    assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(31, 0));\n+    assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(0, 33));\n+    assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(32, 0));\n+\n+    assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(2047, 0));\n+    assertEquals(3, LineMapEncoder.getRelativeMappingIdLength(2048, 0));\n+    assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(0, 2048));\n+    assertEquals(3, LineMapEncoder.getRelativeMappingIdLength(0, 2049));\n+  }\n+\n+  private String getEntry(int id, int lastId, int reps) throws IOException {\n+    StringBuilder sb = new StringBuilder();\n+    LineMapEncoder.encodeEntry(sb, id, lastId, reps);\n+    return sb.toString();\n+  }\n+\n+  public void testEncoding() throws IOException {\n+    assertEquals(\"AA\", getEntry(0, 0, 1));\n+    assertEquals(\"EA\", getEntry(0, 0, 2));\n+    assertEquals(\"8A\", getEntry(0, 0, 16));\n+    assertEquals(\"!AQA\", getEntry(0, 0, 17));\n+    assertEquals(\"!ARA\", getEntry(0, 0, 18));\n+    assertEquals(\"!A+A\", getEntry(0, 0, 63));\n+    assertEquals(\"!A/A\", getEntry(0, 0, 64));\n+    assertEquals(\"!!ABAA\", getEntry(0, 0, 65));\n+    assertEquals(\"!!A//A\", getEntry(0, 0, 4096));\n+    assertEquals(\"!!!ABAAA\", getEntry(0, 0, 4097));\n+\n+    assertEquals(\"Af\", getEntry(31, 0, 1));\n+    assertEquals(\"BAg\", getEntry(32, 0, 1));\n+    assertEquals(\"AB\", getEntry(32, 31, 1));\n+\n+    assertEquals(\"!AQf\", getEntry(31, 0, 17));\n+    assertEquals(\"!BQAg\", getEntry(32, 0, 17));\n+    assertEquals(\"!AQB\", getEntry(32, 31, 17));\n+\n+    assertEquals(\"!A/B\", getEntry(32, 31, 64));\n+    assertEquals(\"!!ABAB\", getEntry(32, 31, 65));\n+  }\n+\n+  /**\n+   * Creates a source map for the given JS code and asserts it is\n+   * equal to the expected golden map.\n+   */\n+  private void checkSourceMap(String js, String expectedMap)\n+      throws IOException {\n+    checkSourceMap(\"testcode\", js, expectedMap);\n+  }\n+\n+  private String getSourceMap(RunResult result) throws IOException {\n+    StringBuilder sb = new StringBuilder();\n+    result.sourceMap.appendTo(sb, \"testcode\");\n+    return sb.toString();\n+  }\n+\n+  private void checkSourceMap(String fileName, String js, String expectedMap)\n+      throws IOException {\n+    RunResult result = compile(js, fileName);\n+    assertEquals(expectedMap, result.sourceMapFileContent);\n+    assertEquals(result.sourceMapFileContent, getSourceMap(result));\n+  }\n+\n+  private static class RunResult {\n+    String generatedSource;\n+    SourceMap sourceMap;\n+    public String sourceMapFileContent;\n+  }\n+\n+  private static class Token {\n+    String tokenName;\n+    Position position;\n+  }\n+\n+  /**\n+   * Finds the all the __XX__ tokens in the given Javascript\n+   * string.\n+   */\n+  private Map<String, Token> findTokens(String js) {\n+    Map<String, Token> tokens = Maps.newLinkedHashMap();\n+\n+    int currentLine = 0;\n+    int positionOffset = 0;\n+\n+    for (int i = 0; i < js.length(); ++i) {\n+      char current = js.charAt(i);\n+\n+      if (current == '\\n') {\n+        positionOffset = i + 1;\n+        currentLine++;\n+        continue;\n+      }\n+\n+      if (current == '_' && (i < js.length() - 5)) {\n+        // Check for the _ token.\n+        if (js.charAt(i + 1) != '_') {\n+          continue;\n+        }\n+\n+        // Loop until we have another _ token.\n+        String tokenName = \"\";\n+\n+        int j = i + 2;\n+        for (; j < js.length(); ++j) {\n+          if (js.charAt(j) == '_') {\n+            break;\n+          }\n+\n+          tokenName += js.charAt(j);\n+        }\n+\n+        if (tokenName.length() > 0) {\n+          Token token = new Token();\n+          token.tokenName = tokenName;\n+          int currentPosition = i - positionOffset;\n+          token.position = new Position(currentLine, currentPosition);\n+          tokens.put(tokenName, token);\n+        }\n+\n+        i = j;\n+      }\n+    }\n+\n+    return tokens;\n+  }\n+\n+  private void compileAndCheck(String js) {\n+    RunResult result = compile(js);\n+\n+    // Find all instances of the __XXX__ pattern in the original\n+    // source code.\n+    Map<String, Token> originalTokens = findTokens(js);\n+\n+    // Find all instances of the __XXX__ pattern in the generated\n+    // source code.\n+    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n+\n+    // Ensure that the generated instances match via the source map\n+    // to the original source code.\n+\n+    // Ensure the token counts match.\n+    assertEquals(originalTokens.size(), resultTokens.size());\n+\n+    SourceMapReader reader = new SourceMapReader();\n+    try {\n+      reader.parse(result.sourceMapFileContent);\n+    } catch (SourceMapParseException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+    // Map the tokens from the generated source back to the\n+    // input source and ensure that the map is correct.\n+    for (Token token : resultTokens.values()) {\n+      OriginalMapping mapping = reader.getMappingForLine(\n+          token.position.getLineNumber() + 1,\n+          token.position.getCharacterIndex() + 1);\n+\n+      assertNotNull(mapping);\n+\n+      // Find the associated token in the input source.\n+      Token inputToken = originalTokens.get(token.tokenName);\n+      assertNotNull(inputToken);\n+\n+      // Ensure that the map correctly points to the token (we add 1\n+      // to normalize versus the Rhino line number indexing scheme).\n+      assertEquals(mapping.position.getLineNumber(),\n+                   inputToken.position.getLineNumber() + 1);\n+\n+      // Ensure that if the token name does not being with an 'STR' (meaning a\n+      // string) it has an original name.\n+      if (!inputToken.tokenName.startsWith(\"STR\")) {\n+        assertTrue(!mapping.originalName.isEmpty());\n+      }\n+\n+      // Ensure that if the mapping has a name, it matches the token.\n+      if (!mapping.originalName.isEmpty()) {\n+        assertEquals(mapping.originalName, \"__\" + inputToken.tokenName + \"__\");\n+      }\n+    }\n+  }\n+\n+  private RunResult compile(String js) {\n+    return compile(js, \"testcode\");\n+  }\n+\n+  private RunResult compile(String js, String fileName) {\n+    return compile(js, fileName, null, null);\n+  }\n+\n+  private RunResult compile(String js1, String fileName1, String js2,\n+      String fileName2) {\n+    Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    options.sourceMapOutputPath = \"testcode_source_map.out\";\n+    options.sourceMapFormat = SourceMap.Format.EXPERIMENTIAL;\n+    options.sourceMapDetailLevel = detailLevel;\n+\n+    // Turn on IDE mode to get rid of optimizations.\n+    options.ideMode = true;\n+\n+    JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName1, js1) };\n+\n+    if (js2 != null && fileName2 != null) {\n+      JSSourceFile[] multiple =  { JSSourceFile.fromCode(fileName1, js1),\n+                                   JSSourceFile.fromCode(fileName2, js2) };\n+      inputs = multiple;\n+    }\n+\n+    Result result = compiler.compile(EXTERNS, inputs, options);\n+\n+    assertTrue(result.success);\n+    String source = compiler.toSource();\n+\n+    StringBuilder sb = new StringBuilder();\n+    try {\n+      ((SourceMap2)result.sourceMap).validate(true);\n+      result.sourceMap.appendTo(sb, \"testcode\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"unexpected exception\", e);\n+    }\n+\n+    RunResult rr = new RunResult();\n+    rr.generatedSource = source;\n+    rr.sourceMap = result.sourceMap;\n+    rr.sourceMapFileContent = sb.toString();\n+    return rr;\n+  }\n+\n+  public static class SourceMapParseException extends IOException {\n+    private static final long serialVersionUID = 1L;\n+\n+    public SourceMapParseException(String message) {\n+      super(message);\n+    }\n+\n+    public SourceMapParseException(String message, Exception ex) {\n+      super(message, ex);\n+    }\n+  }\n+\n+  public static class OriginalMapping {\n+    public final String srcfile;\n+    public final Position position;\n+    public final String originalName;\n+\n+    OriginalMapping(String srcfile, int line, int column, String name) {\n+      this.srcfile = srcfile;\n+      this.position = new Position(line, column);\n+      this.originalName = name;\n+    }\n+  }\n+\n+  /**\n+   * Class for parsing and representing a SourceMap\n+   * TODO(johnlenz): This would be best as a seperate open-source component.\n+   *     Remove this when it is.\n+   */\n+  public class SourceMapReader {\n+    private List<List<Integer>> characterMap = null;\n+\n+    /**\n+     * Map of Mapping IDs to the actual mapping object.\n+     */\n+    private List<OriginalMapping> mappings;\n+    private List<String> sources;\n+    private List<String> names;\n+\n+    public SourceMapReader() {\n+    }\n+\n+    /**\n+     * Parses the given contents containing a source map.\n+     * @throws IOException\n+     */\n+    public void parse(String contents) throws IOException {\n+      characterMap = null;\n+      mappings = null;\n+      sources = null;\n+      names = null;\n+\n+      try {\n+        JSONObject sourceMapRoot = new JSONObject(contents);\n+\n+        int version = sourceMapRoot.getInt(\"version\");\n+        if (version != 2) {\n+          throw new SourceMapParseException(\"unknown version\");\n+        }\n+\n+        String file = sourceMapRoot.getString(\"file\");\n+        if (file.isEmpty()) {\n+          throw new SourceMapParseException(\"file entry is missing or empty\");\n+        }\n+\n+        int lineCount = sourceMapRoot.getInt(\"lineCount\");\n+        JSONArray lineMaps = sourceMapRoot.getJSONArray(\"lineMaps\");\n+        if (lineCount != lineMaps.length()) {\n+          throw new SourceMapParseException(\n+              \"lineMaps lenght does not match lineCount\");\n+        }\n+\n+        characterMap = Lists.newArrayListWithCapacity(lineCount);\n+\n+        for (int i=0; i< lineMaps.length(); i++) {\n+          String lineEntry = lineMaps.getString(i);\n+          List<Integer> entries = SourceMap2.LineMapDecoder.decodeLine(\n+              lineEntry);\n+          String msg = \"line: \" + entries;\n+          System.err.println(msg);\n+          characterMap.add(entries);\n+        }\n+\n+        sources = jsonArrayToJavaArray(\n+            sourceMapRoot.getJSONArray(\"sources\"));\n+\n+        if (sourceMapRoot.has(\"names\")) {\n+          names = jsonArrayToJavaArray(\n+              sourceMapRoot.getJSONArray(\"names\"));\n+        } else {\n+          names = Collections.emptyList();\n+        }\n+\n+        JSONArray jsonMappings = sourceMapRoot.getJSONArray(\"mappings\");\n+        mappings = Lists.newArrayListWithCapacity(lineCount);\n+        for (int i = 0; i < jsonMappings.length(); i++) {\n+          JSONArray entry = jsonMappings.getJSONArray(i);\n+\n+          String name;\n+          try {\n+            int nameIndex = entry.getInt(3);\n+            name = names.get(nameIndex);\n+          } catch (JSONException e) {\n+            name = entry.optString(3, \"\");\n+          }\n+\n+          OriginalMapping mapping = new OriginalMapping(\n+            sources.get(entry.getInt(0)), // srcfile\n+            entry.getInt(1),    // line\n+            entry.getInt(2),    // column\n+            name); // identifier\n+          mappings.add(mapping);\n+        }\n+      } catch (JSONException ex) {\n+        throw new SourceMapParseException(\"JSON parse exception\", ex);\n+      }\n+    }\n+\n+    private List<String> jsonArrayToJavaArray(JSONArray jsonArray)\n+        throws JSONException {\n+      List<String> result = Lists.newArrayListWithCapacity(jsonArray.length());\n+      for (int i=0; i< jsonArray.length(); i++) {\n+        String source = jsonArray.getString(i);\n+        result.add(source);\n+      }\n+      return result;\n+    }\n+\n+    public OriginalMapping getMappingForLine(int lineNumber, int columnIndex) {\n+      Preconditions.checkNotNull(characterMap, \"parse() must be called first\");\n+\n+      List<Integer> mapIds = characterMap.get(lineNumber - 1);\n+      if (mapIds == null) {\n+        return null;\n+      }\n+\n+      int columnPosition = columnIndex - 1;\n+      if (columnPosition >= mapIds.size() || columnPosition < 0) {\n+        return null;\n+      }\n+\n+      int mapId = mapIds.get(columnPosition);\n+\n+      return mappings.get(mapId);\n+    }\n+  }\n+}", "timestamp": 1282770024, "metainfo": ""}