{"sha": "f58f7523c285197df175ad780dbe6288c67bc08c", "log": "Add a coding convention interface that allow for certain functions or mehtods to be un-inlineable.  R=nicksantos DELTA=496  (302 added, 188 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4640   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n   public void applySingletonGetter(FunctionType functionType,\n       FunctionType getterType, ObjectType objectType);\n \n+  /**\n+   * @return Whether the function is inlinable by convention.\n+   */\n+  public boolean isInlinableFunction(Node n);\n+\n+  /**\n+   * @return the delegate relationship created by the call or null.\n+   */\n   public DelegateRelationship getDelegateRelationship(Node callNode);\n \n   /**\n--- a/src/com/google/javascript/jscomp/CodingConventions.java\n+++ b/src/com/google/javascript/jscomp/CodingConventions.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n     }\n \n     @Override\n+    public boolean isInlinableFunction(Node n) {\n+      return nextConvention.isInlinableFunction(n);\n+    }\n+\n+    @Override\n     public DelegateRelationship getDelegateRelationship(Node callNode) {\n       return nextConvention.getDelegateRelationship(callNode);\n     }\n-\n \n     @Override\n     public void applyDelegateRelationship(\n     public void applySingletonGetter(FunctionType functionType,\n         FunctionType getterType, ObjectType objectType) {\n       // do nothing.\n+    }\n+\n+    @Override\n+    public boolean isInlinableFunction(Node n) {\n+      Preconditions.checkState(n.isFunction());\n+      return true;\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n     Node block = NodeUtil.getFunctionBody(fnNode);\n \n     // Basic restrictions on functions that can be inlined:\n+    // 0) The function is inlinable by convention\n     // 1) It contains a reference to itself.\n     // 2) It uses its parameters indirectly using \"arguments\" (it isn't\n     //    handled yet.\n     // 3) It references \"eval\". Inline a function containing eval can have\n     //    large performance implications.\n+\n+    if (!compiler.getCodingConvention().isInlinableFunction(fnNode)) {\n+      return false;\n+    }\n \n     final String fnRecursionName = fnNode.getFirstChild().getString();\n     Preconditions.checkState(fnRecursionName != null);\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n       } else if (initialization.isDeclaration()) {\n         // The reference is a FUNCTION declaration or normal VAR declaration\n         // with a value.\n-        return NodeUtil.isFunctionDeclaration(initialization.getParent())\n-            || initialization.getNode().getFirstChild() != null;\n+        if (!NodeUtil.isFunctionDeclaration(initialization.getParent())\n+            && initialization.getNode().getFirstChild() == null) {\n+          return false;\n+        }\n       } else {\n         Node parent = initialization.getParent();\n         Preconditions.checkState(\n             parent.isAssign()\n             && parent.getFirstChild() == initialization.getNode());\n-        return true;\n-      }\n+      }\n+\n+      Node n = initialization.getAssignedValue();\n+      if (n.isFunction()) {\n+        return compiler.getCodingConvention().isInlinableFunction(n);\n+      }\n+\n+      return true;\n     }\n \n     /**\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Joiner;\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-\n-import junit.framework.TestCase;\n-\n-import java.util.List;\n \n /**\n  * Tests for {@link PassFactory}.\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-public class IntegrationTest extends TestCase {\n-\n-  /** Externs for the test */\n-  private final List<SourceFile> DEFAULT_EXTERNS = ImmutableList.of(\n-    SourceFile.fromCode(\"externs\",\n-        \"var arguments;\\n\"\n-        + \"/** @constructor */ function Window() {}\\n\"\n-        + \"/** @type {string} */ Window.prototype.name;\\n\"\n-        + \"/** @type {string} */ Window.prototype.offsetWidth;\\n\"\n-        + \"/** @type {Window} */ var window;\\n\"\n-        + \"/** @nosideeffects */ function noSideEffects() {}\\n\"\n-        + \"/** @constructor\\n * @nosideeffects */ function Widget() {}\\n\"\n-        + \"/** @modifies {this} */ Widget.prototype.go = function() {};\\n\"\n-        + \"/** @return {string} */ var widgetToken = function() {};\\n\"));\n-\n-  private List<SourceFile> externs = DEFAULT_EXTERNS;\n+public class IntegrationTest extends IntegrationTestCase {\n \n   private static final String CLOSURE_BOILERPLATE =\n       \"/** @define {boolean} */ var COMPILED = false; var goog = {};\" +\n \n   private static final String CLOSURE_COMPILED =\n       \"var COMPILED = true; var goog$exportSymbol = function() {};\";\n-\n-  // The most recently used compiler.\n-  private Compiler lastCompiler;\n-\n-  @Override\n-  public void setUp() {\n-    externs = DEFAULT_EXTERNS;\n-    lastCompiler = null;\n-  }\n \n   public void testBug1949424() {\n     CompilerOptions options = createCompilerOptions();\n     assertEquals(1, compiler.getWarnings().length);\n   }\n \n-  private void testSame(CompilerOptions options, String original) {\n-    testSame(options, new String[] { original });\n-  }\n-\n-  private void testSame(CompilerOptions options, String[] original) {\n-    test(options, original, original);\n-  }\n-\n-  /**\n-   * Asserts that when compiling with the given compiler options,\n-   * {@code original} is transformed into {@code compiled}.\n-   */\n-  private void test(CompilerOptions options,\n-      String original, String compiled) {\n-    test(options, new String[] { original }, new String[] { compiled });\n-  }\n-\n-  /**\n-   * Asserts that when compiling with the given compiler options,\n-   * {@code original} is transformed into {@code compiled}.\n-   */\n-  private void test(CompilerOptions options,\n-      String[] original, String[] compiled) {\n-    Compiler compiler = compile(options, original);\n-    assertEquals(\"Expected no warnings or errors\\n\" +\n-        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n-        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n-        0, compiler.getErrors().length + compiler.getWarnings().length);\n-\n-    Node root = compiler.getRoot().getLastChild();\n-    Node expectedRoot = parse(compiled, options);\n-    String explanation = expectedRoot.checkTreeEquals(root);\n-    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n-        \"\\nResult: \" + compiler.toSource(root) +\n-        \"\\n\" + explanation, explanation);\n-  }\n-\n-  /**\n-   * Asserts that when compiling with the given compiler options,\n-   * there is an error or warning.\n-   */\n-  private void test(CompilerOptions options,\n-      String original, DiagnosticType warning) {\n-    test(options, new String[] { original }, warning);\n-  }\n-\n-  private void test(CompilerOptions options,\n-      String original, String compiled, DiagnosticType warning) {\n-    test(options, new String[] { original }, new String[] { compiled },\n-         warning);\n-  }\n-\n-  private void test(CompilerOptions options,\n-      String[] original, DiagnosticType warning) {\n-    test(options, original, null, warning);\n-  }\n-\n-  /**\n-   * Asserts that when compiling with the given compiler options,\n-   * there is an error or warning.\n-   */\n-  private void test(CompilerOptions options,\n-      String[] original, String[] compiled, DiagnosticType warning) {\n-    Compiler compiler = compile(options, original);\n-    checkUnexpectedErrorsOrWarnings(compiler, 1);\n-    assertEquals(\"Expected exactly one warning or error\",\n-        1, compiler.getErrors().length + compiler.getWarnings().length);\n-    if (compiler.getErrors().length > 0) {\n-      assertEquals(warning, compiler.getErrors()[0].getType());\n-    } else {\n-      assertEquals(warning, compiler.getWarnings()[0].getType());\n-    }\n-\n-    if (compiled != null) {\n-      Node root = compiler.getRoot().getLastChild();\n-      Node expectedRoot = parse(compiled, options);\n-      String explanation = expectedRoot.checkTreeEquals(root);\n-      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n-          \"\\nResult: \" + compiler.toSource(root) +\n-          \"\\n\" + explanation, explanation);\n-    }\n-  }\n-\n-  /**\n-   * Asserts that when compiling with the given compiler options,\n-   * there is an error or warning.\n-   */\n-  private void test(CompilerOptions options,\n-      String[] original, String[] compiled, DiagnosticType[] warnings) {\n-    Compiler compiler = compile(options, original);\n-    checkUnexpectedErrorsOrWarnings(compiler, warnings.length);\n-\n-    if (compiled != null) {\n-      Node root = compiler.getRoot().getLastChild();\n-      Node expectedRoot = parse(compiled, options);\n-      String explanation = expectedRoot.checkTreeEquals(root);\n-      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n-          \"\\nResult: \" + compiler.toSource(root) +\n-          \"\\n\" + explanation, explanation);\n-    }\n-  }\n-\n-  private void checkUnexpectedErrorsOrWarnings(\n-      Compiler compiler, int expected) {\n-    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n-    if (actual != expected) {\n-      String msg = \"\";\n-      for (JSError err : compiler.getErrors()) {\n-        msg += \"Error:\" + err.toString() + \"\\n\";\n-      }\n-      for (JSError err : compiler.getWarnings()) {\n-        msg += \"Warning:\" + err.toString() + \"\\n\";\n-      }\n-      assertEquals(\"Unexpected warnings or errors.\\n \" + msg,\n-        expected, actual);\n-    }\n-  }\n-\n-  private Compiler compile(CompilerOptions options, String original) {\n-    return compile(options, new String[] { original });\n-  }\n-\n-  private Compiler compile(CompilerOptions options, String[] original) {\n-    Compiler compiler = lastCompiler = new Compiler();\n-    List<SourceFile> inputs = Lists.newArrayList();\n-    for (int i = 0; i < original.length; i++) {\n-      inputs.add(SourceFile.fromCode(\"input\" + i, original[i]));\n-    }\n-    compiler.compileModules(\n-        externs, Lists.newArrayList(CompilerTestCase.createModuleChain(original)),\n-        options);\n-    return compiler;\n-  }\n-\n-  private Node parse(String[] original, CompilerOptions options) {\n-    Compiler compiler = new Compiler();\n-    List<SourceFile> inputs = Lists.newArrayList();\n-    for (int i = 0; i < original.length; i++) {\n-      inputs.add(SourceFile.fromCode(\"input\" + i, original[i]));\n-    }\n-    compiler.init(externs, inputs, options);\n-    checkUnexpectedErrorsOrWarnings(compiler, 0);\n-    Node all = compiler.parseInputs();\n-    checkUnexpectedErrorsOrWarnings(compiler, 0);\n-    Node n = all.getLastChild();\n-    Node externs = all.getFirstChild();\n-\n-    (new CreateSyntheticBlocks(\n-        compiler, \"synStart\", \"synEnd\")).process(externs, n);\n-    (new Normalize(compiler, false)).process(externs, n);\n-    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n-        externs, n);\n-    (new Denormalize(compiler)).process(externs, n);\n-    return n;\n-  }\n-\n   /** Creates a CompilerOptions object with google coding conventions. */\n-  private CompilerOptions createCompilerOptions() {\n+  @Override\n+  protected CompilerOptions createCompilerOptions() {\n     CompilerOptions options = new CompilerOptions();\n     options.setCodingConvention(new GoogleCodingConvention());\n     return options;\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/IntegrationTestCase.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.List;\n+\n+/**\n+ * Framework for end-to-end test cases.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+abstract class IntegrationTestCase extends TestCase {\n+\n+  /** Externs for the test */\n+  protected final List<SourceFile> DEFAULT_EXTERNS = ImmutableList.of(\n+    SourceFile.fromCode(\"externs\",\n+        \"var arguments;\\n\"\n+        + \"/** @constructor */ function Window() {}\\n\"\n+        + \"/** @type {string} */ Window.prototype.name;\\n\"\n+        + \"/** @type {string} */ Window.prototype.offsetWidth;\\n\"\n+        + \"/** @type {Window} */ var window;\\n\"\n+        + \"/** @nosideeffects */ function noSideEffects() {}\\n\"\n+        + \"/** @constructor\\n * @nosideeffects */ function Widget() {}\\n\"\n+        + \"/** @modifies {this} */ Widget.prototype.go = function() {};\\n\"\n+        + \"/** @return {string} */ var widgetToken = function() {};\\n\"\n+        + \"function alert(x) {}\"));\n+\n+  protected List<SourceFile> externs = DEFAULT_EXTERNS;\n+\n+  // The most recently used compiler.\n+  protected Compiler lastCompiler;\n+\n+  @Override\n+  public void setUp() {\n+    externs = DEFAULT_EXTERNS;\n+    lastCompiler = null;\n+  }\n+\n+  protected void testSame(CompilerOptions options, String original) {\n+    testSame(options, new String[] { original });\n+  }\n+\n+  protected void testSame(CompilerOptions options, String[] original) {\n+    test(options, original, original);\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * {@code original} is transformed into {@code compiled}.\n+   */\n+  protected void test(CompilerOptions options,\n+      String original, String compiled) {\n+    test(options, new String[] { original }, new String[] { compiled });\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * {@code original} is transformed into {@code compiled}.\n+   */\n+  protected void test(CompilerOptions options,\n+      String[] original, String[] compiled) {\n+    Compiler compiler = compile(options, original);\n+    assertEquals(\"Expected no warnings or errors\\n\" +\n+        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n+        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n+        0, compiler.getErrors().length + compiler.getWarnings().length);\n+\n+    Node root = compiler.getRoot().getLastChild();\n+    Node expectedRoot = parse(compiled, options);\n+    String explanation = expectedRoot.checkTreeEquals(root);\n+    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+        \"\\nResult: \" + compiler.toSource(root) +\n+        \"\\n\" + explanation, explanation);\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * there is an error or warning.\n+   */\n+  protected void test(CompilerOptions options,\n+      String original, DiagnosticType warning) {\n+    test(options, new String[] { original }, warning);\n+  }\n+\n+  protected void test(CompilerOptions options,\n+      String original, String compiled, DiagnosticType warning) {\n+    test(options, new String[] { original }, new String[] { compiled },\n+         warning);\n+  }\n+\n+  protected void test(CompilerOptions options,\n+      String[] original, DiagnosticType warning) {\n+    test(options, original, null, warning);\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * there is an error or warning.\n+   */\n+  protected void test(CompilerOptions options,\n+      String[] original, String[] compiled, DiagnosticType warning) {\n+    Compiler compiler = compile(options, original);\n+    checkUnexpectedErrorsOrWarnings(compiler, 1);\n+    assertEquals(\"Expected exactly one warning or error\",\n+        1, compiler.getErrors().length + compiler.getWarnings().length);\n+    if (compiler.getErrors().length > 0) {\n+      assertEquals(warning, compiler.getErrors()[0].getType());\n+    } else {\n+      assertEquals(warning, compiler.getWarnings()[0].getType());\n+    }\n+\n+    if (compiled != null) {\n+      Node root = compiler.getRoot().getLastChild();\n+      Node expectedRoot = parse(compiled, options);\n+      String explanation = expectedRoot.checkTreeEquals(root);\n+      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+          \"\\nResult: \" + compiler.toSource(root) +\n+          \"\\n\" + explanation, explanation);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * there is an error or warning.\n+   */\n+  protected void test(CompilerOptions options,\n+      String[] original, String[] compiled, DiagnosticType[] warnings) {\n+    Compiler compiler = compile(options, original);\n+    checkUnexpectedErrorsOrWarnings(compiler, warnings.length);\n+\n+    if (compiled != null) {\n+      Node root = compiler.getRoot().getLastChild();\n+      Node expectedRoot = parse(compiled, options);\n+      String explanation = expectedRoot.checkTreeEquals(root);\n+      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+          \"\\nResult: \" + compiler.toSource(root) +\n+          \"\\n\" + explanation, explanation);\n+    }\n+  }\n+\n+  protected void checkUnexpectedErrorsOrWarnings(\n+      Compiler compiler, int expected) {\n+    int actual = compiler.getErrors().length + compiler.getWarnings().length;\n+    if (actual != expected) {\n+      String msg = \"\";\n+      for (JSError err : compiler.getErrors()) {\n+        msg += \"Error:\" + err.toString() + \"\\n\";\n+      }\n+      for (JSError err : compiler.getWarnings()) {\n+        msg += \"Warning:\" + err.toString() + \"\\n\";\n+      }\n+      assertEquals(\"Unexpected warnings or errors.\\n \" + msg,\n+        expected, actual);\n+    }\n+  }\n+\n+  protected Compiler compile(CompilerOptions options, String original) {\n+    return compile(options, new String[] { original });\n+  }\n+\n+  protected Compiler compile(CompilerOptions options, String[] original) {\n+    Compiler compiler = lastCompiler = new Compiler();\n+    List<SourceFile> inputs = Lists.newArrayList();\n+    for (int i = 0; i < original.length; i++) {\n+      inputs.add(SourceFile.fromCode(\"input\" + i, original[i]));\n+    }\n+    compiler.compileModules(\n+        externs, Lists.newArrayList(CompilerTestCase.createModuleChain(original)),\n+        options);\n+    return compiler;\n+  }\n+\n+  protected Node parse(String[] original, CompilerOptions options) {\n+    Compiler compiler = new Compiler();\n+    List<SourceFile> inputs = Lists.newArrayList();\n+    for (int i = 0; i < original.length; i++) {\n+      inputs.add(SourceFile.fromCode(\"input\" + i, original[i]));\n+    }\n+    compiler.init(externs, inputs, options);\n+    checkUnexpectedErrorsOrWarnings(compiler, 0);\n+    Node all = compiler.parseInputs();\n+    checkUnexpectedErrorsOrWarnings(compiler, 0);\n+    Node n = all.getLastChild();\n+    Node externs = all.getFirstChild();\n+\n+    (new CreateSyntheticBlocks(\n+        compiler, \"synStart\", \"synEnd\")).process(externs, n);\n+    (new Normalize(compiler, false)).process(externs, n);\n+    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n+        externs, n);\n+    (new Denormalize(compiler)).process(externs, n);\n+    return n;\n+  }\n+\n+  /** Creates a CompilerOptions object with google coding conventions. */\n+  abstract CompilerOptions createCompilerOptions();\n+}", "timestamp": 1335829240, "metainfo": ""}