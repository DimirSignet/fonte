{"sha": "a54f481f17f75d540426b958dd381f1556586960", "log": "Automated g4 rollback.  *** Reason for rollback ***  causes runtime errors in gmail. added a test case demonstrating the issue  *** Original change description ***  Prescreen variable for live range check. Makes CoalesceVariableNames 10times faster.  R=acleung DELTA=111  (31 added, 80 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2078   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n       NodeTraversal t, ControlFlowGraph<Node> cfg, Set<Var> escaped) {\n     UndiGraph<Var, Void> interferenceGraph =\n         LinkedUndirectedGraph.create();\n-\n-    // For all variables V not in unsafeCrossRange,\n-    // LiveRangeChecker(V, X) and LiveRangeChecker(Y, V) will never add a edge\n-    // to the interferenceGraph. In other words, we don't need to use\n-    // LiveRangeChecker on variable pair (A, B) if both A and B are not\n-    // in the unsafeCrossRangeSet. See PrescreenCrossLiveRange for details.\n-    Set<Var> unsafeCrossRangeSet = Sets.newHashSet();\n     Scope scope = t.getScope();\n-\n-    for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n-      if (cfg.isImplicitReturn(cfgNode)) {\n-        continue;\n-      }\n-\n-      for (Iterator<Var> i = scope.getVars(); i.hasNext();) {\n-        final Var v = i.next();\n-\n-        if (!unsafeCrossRangeSet.contains(v)) {\n-          FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n-          PrescreenCrossLiveRange check =\n-              new PrescreenCrossLiveRange(v, state.getOut());\n-\n-          NodeTraversal.traverse(compiler, cfgNode.getValue(), check);\n-\n-          if (!check.isSafe()) {\n-            unsafeCrossRangeSet.add(v);\n-          }\n-        }\n-      }\n-    }\n \n     // First create a node for each non-escaped variable.\n     for (Iterator<Var> i = scope.getVars(); i.hasNext();) {\n         // v1 and v2 might not have an edge between them! woohoo. there's\n         // one last sanity check that we have to do: we have to check\n         // if there's a collision *within* the cfg node.\n-        if (!unsafeCrossRangeSet.contains(v1) &&\n-            !unsafeCrossRangeSet.contains(v2)) {\n-          continue NEXT_VAR_PAIR;\n-        }\n-\n         NEXT_INTRA_CFG_NODE:\n         for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n           if (cfg.isImplicitReturn(cfgNode)) {\n             continue NEXT_INTRA_CFG_NODE;\n           }\n+\n           FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n           boolean v1OutLive = state.getOut().isLive(v1);\n           boolean v2OutLive = state.getOut().isLive(v2);\n           !NodeUtil.isVarOrSimpleAssignLhs(name, name.getParent());\n     }\n   }\n-\n-  /**\n-   * The crossed live range check is pretty traversal happy and it needs to\n-   * live range crossing between all coalescing candidate x and y at each\n-   * CFG node. Since this type of live range crossing within a CFG node happens\n-   * rarely, we can pre-screen the variables' usages and eliminate the\n-   * cross live range check if it can never cross another variable's live range\n-   * within a CFG node.\n-   */\n-  private static class PrescreenCrossLiveRange\n-      extends AbstractCfgNodeTraversalCallback {\n-    private int count;\n-    private final LiveVariableLattice lattice;\n-    private final Var var;\n-\n-    // Dead assignments has a strange effect on variable name coalescing.\n-    // Consider y = 3; x = 2; print(y)\n-    // Since x is never live, it would appear x and y's live range never\n-    // intersects. However, merging x and y means the = 2 assignment suddenly\n-    // becomes live so we need to do the live range check when that happens.\n-    private boolean hasDeadAssignment = false;\n-\n-    public PrescreenCrossLiveRange(Var var, LiveVariableLattice lattice) {\n-      this.lattice = lattice;\n-      this.var = var;\n-    }\n-\n-    @Override\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (!NodeUtil.isName(n) || !var.name.equals(n.getString())) {\n-        return;\n-      }\n-      count++;\n-      if (// is a=b or var a=b\n-          ((NodeUtil.isAssign(parent) && parent.getFirstChild() == n) ||\n-          (NodeUtil.isVar(parent) && n.hasChildren()))\n-\n-          && !lattice.isLive(var)) {\n-        hasDeadAssignment = true;\n-      }\n-    }\n-\n-    private boolean isSafe() {\n-      return count < 2 && !hasDeadAssignment;\n-    }\n-  }\n }\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n         \"   this.load();\");\n   }\n \n+  public void testCannotReuseAnyParamsBug() {\n+    testSame(\"function handleKeyboardShortcut(e, key, isModifierPressed) {\\n\" +\n+        \"  if (!isModifierPressed) {\\n\" +\n+        \"    return false;\\n\" +\n+        \"  }\\n\" +\n+        \"  var command;\\n\" +\n+        \"  switch (key) {\\n\" +\n+        \"    case 'b': // Ctrl+B\\n\" +\n+        \"      command = COMMAND.BOLD;\\n\" +\n+        \"      break;\\n\" +\n+        \"    case 'i': // Ctrl+I\\n\" +\n+        \"      command = COMMAND.ITALIC;\\n\" +\n+        \"      break;\\n\" +\n+        \"    case 'u': // Ctrl+U\\n\" +\n+        \"      command = COMMAND.UNDERLINE;\\n\" +\n+        \"      break;\\n\" +\n+        \"    case 's': // Ctrl+S\\n\" +\n+        \"      return true;\\n\" +\n+        \"  }\\n\" +\n+        \"\\n\" +\n+        \"  if (command) {\\n\" +\n+        \"    this.fieldObject.execCommand(command);\\n\" +\n+        \"    return true;\\n\" +\n+        \"  }\\n\" +\n+        \"\\n\" +\n+        \"  return false;\\n\" +\n+        \"};\");\n+  }\n+\n+\n   public void testUsePseduoNames() {\n     usePseudoName = true;\n     inFunction(\"var x   = 0; print(x  ); var   y = 1; print(  y)\",", "timestamp": 1306523252, "metainfo": ""}