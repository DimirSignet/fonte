{"sha": "b2c12cd9f4284d58450d1a487e29d6b6a065105e", "log": "Change on 2010/07/12 11:35:39 by nicksantos  \tclean up RemoveUnusedVars. Update old naming conventions, \tand remove a logger that was no longer really accurate.  \tR=johnlenz \tDELTA=35  (0 added, 18 deleted, 17 changed)  Change on 2010/07/12 11:37:59 by johnlenz  \tStub out an unused section of the source map, which results in \tslightly smaller, faster, and simplified logic.  \tR=jschorr \tDELTA=68  (18 added, 41 deleted, 9 changed)  Change on 2010/07/12 11:39:24 by gboyer  \tClipboardData is a property of Event in IE.  \tDefinition copied from ie_dom.js.  I added a |undefined because it is \tnot defined in other browsers.  \tFixes warning in Trog's paste interceptor.  \tR=nicksantos,skobes \tDELTA=5  (5 added, 0 deleted, 0 changed)  Change on 2010/07/12 12:42:29 by nicksantos  \tClean up AliasExternals and make it work with normalization.  \tR=johnlenz \tDELTA=43  (24 added, 0 deleted, 19 changed)  Change on 2010/07/12 12:58:26 by nicksantos  \tfix ScopedAliases when the type of a parameter is null.  \tR=robbyw \tDELTA=13  (11 added, 0 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=48008   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n       getArrayNotationNameFor(\"prototype\");\n \n   /** Map of all properties that we may be renaming */\n-  private final Map<String, Property> props = Maps.newHashMap();\n+  private final Map<String, Symbol> props = Maps.newHashMap();\n \n   /** Holds the properties that can be renamed to GETPROP_ */\n   private final List<Node> accessors = Lists.newArrayList();\n     new IdentityHashMap<Node, Node>();\n \n   /** Map of all globals that we may aliasing */\n-  private final Map<String, Property> globals = Maps.newHashMap();\n+  private final Map<String, Symbol> globals = Maps.newHashMap();\n \n   /** Holds all of the globals that can be aliased to GLOBAL_ */\n   private final List<Node> globalUses = Lists.newArrayList();\n     // Get the reserved names, filtered by the whitelist.\n     NodeTraversal.traverse(compiler, externs,\n                            new GetAliasableNames(aliasableGlobals));\n-    props.put(\"prototype\", new Property(\"prototype\"));\n+    props.put(\"prototype\", newSymbolForProperty(\"prototype\"));\n \n     // Find the props that can be changed\n     NodeTraversal.traverse(compiler, root, new PropertyGatherer());\n     // Iterate through the reserved names, decide what to change\n     // This could have been done during property traversal, but\n     // This gives opportunity for review & modification if needed\n-    for (Property prop : props.values()) {\n+    for (Symbol prop : props.values()) {\n       if (prop.name.length() >= MIN_PROP_SIZE) {\n         if (prop.accessorCount >= requiredUsage) {\n           prop.aliasAccessor = true;\n     // And add the accessor and mutator functions, if needed. Property names are\n     // grouped together so that the CollapseVariableDeclarations pass can put\n     // them in a single variable declaration statement.\n-    for (Property prop : props.values()) {\n+    for (Symbol prop : props.values()) {\n       if (prop.aliasAccessor) {\n         addAccessorPropName(prop.name, getAddingRoot(prop.deepestModuleAccess));\n       }\n     }\n \n-    for (Property prop : props.values()) {\n+    for (Symbol prop : props.values()) {\n       if (prop.aliasMutator) {\n         addMutatorFunction(prop.name, getAddingRoot(prop.deepestModuleMutate));\n       }\n     Node propNameNode = getPropNode.getLastChild();\n     Node parentNode = getPropNode.getParent();\n \n-    Property prop = props.get(propNameNode.getString());\n+    Symbol prop = props.get(propNameNode.getString());\n     if (prop.aliasMutator) {\n       Node propSrc = getPropNode.getFirstChild();\n       Node propDest = parentNode.getLastChild();\n           Node dest = n.getFirstChild().getNext();\n           if (dest.getType() == Token.STRING &&\n               (whitelist.isEmpty() || whitelist.contains(dest.getString()))) {\n-            props.put(dest.getString(), new Property(dest.getString()));\n+            props.put(dest.getString(), newSymbolForProperty(dest.getString()));\n           }\n       }\n     }\n     NodeTraversal.traverse(compiler, root, new GlobalGatherer());\n \n     // Iterate through the used globals, decide what to change.\n-    for (Property global : globals.values()) {\n+    for (Symbol global : globals.values()) {\n       if (global.mutatorCount > 0) {\n         continue;\n       }\n       replaceGlobalUse(globalUse);\n     }\n \n-    for (Property global : globals.values()) {\n+    for (Symbol global : globals.values()) {\n       if (global.aliasAccessor) {\n-        addGlobalAliasNode(global.name,\n+        addGlobalAliasNode(global,\n                            getAddingRoot(global.deepestModuleAccess));\n       }\n     }\n           Scope.Var var = t.getScope().getVar(name);\n \n           if (var != null && !var.isLocal()) {\n-            globals.put(name, new Property(name));\n+            globals.put(name, newSymbolForGlobalVar(dest));\n           }\n         }\n       }\n           return;\n         }\n \n-        Property global = globals.get(name);\n+        Symbol global = globals.get(name);\n         if (global != null) {\n           boolean isFirst = parent.getFirstChild() == n;\n           // If a global is being assigned to or otherwise modified, then we\n     String globalName = globalUse.getString();\n     if (globals.get(globalName).aliasAccessor) {\n       globalUse.setString(\"GLOBAL_\" + globalName);\n+\n+      // None of the aliases are marked as @const.\n+      // Because we're reusing the original ref node,\n+      // we need to update it to reflect this.\n+      globalUse.putBooleanProp(Node.IS_CONSTANT_NAME, false);\n+\n       compiler.reportCodeChange();\n     }\n   }\n    * @param globalName Name of global\n    * @param root Root of output tree that function can be added to\n    */\n-  private void addGlobalAliasNode(String globalName, Node root) {\n+  private void addGlobalAliasNode(Symbol global, Node root) {\n     /*\n      *  Target:\n \n         name GLOBAL_window\n             name window\n      */\n-    Node globalValue = Node.newString(Token.NAME, globalName);\n+\n+    String globalName = global.name;\n+    Node globalValue = Node.newString(Token.NAME, global.name);\n+    globalValue.putBooleanProp(Node.IS_CONSTANT_NAME, global.isConstant);\n+\n     Node globalNameNode =\n       Node.newString(Token.NAME, \"GLOBAL_\" + globalName);\n     globalNameNode.addChildToFront(globalValue);\n     compiler.reportCodeChange();\n   }\n \n+  private Symbol newSymbolForGlobalVar(Node name) {\n+    return new Symbol(\n+        name.getString(), name.getBooleanProp(Node.IS_CONSTANT_NAME));\n+  }\n+\n+  private Symbol newSymbolForProperty(String name) {\n+    return new Symbol(name, false);\n+  }\n+\n   /** Struct to hold information about properties & usage */\n-  private class Property {\n-    public String name;\n+  private class Symbol {\n+    public final String name;\n     public int accessorCount = 0;\n     public int mutatorCount = 0;\n     public boolean aliasMutator = false;\n     public boolean aliasAccessor = false;\n+    public final boolean isConstant;\n \n     JSModule deepestModuleAccess = null;\n     JSModule deepestModuleMutate = null;\n \n-    public Property(String name) {\n+    private Symbol(String name, boolean isConstant) {\n       this.name = name;\n+      this.isConstant = isConstant;\n     }\n \n     void recordAccessor(NodeTraversal t) {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n *\n  */\n class RemoveUnusedVars implements CompilerPass {\n-  private static final Logger logger_ =\n+  private static final Logger logger =\n     Logger.getLogger(RemoveUnusedVars.class.getName());\n \n-  private final AbstractCompiler compiler_;\n+  private final AbstractCompiler compiler;\n \n   /** Keeps track of the number of variables removed per instance. */\n-  private int numRemoved_ = 0;\n+  private int numRemoved = 0;\n \n   private final boolean removeGlobals;\n \n   private boolean preserveFunctionExpressionNames;\n-\n-  /**\n-   * Keeps track of what variables we've warned about, so that we don't do it\n-   * on subsequent traversals.\n-   */\n-  private final Set<Var> warnedVars_ = Sets.newHashSet();\n \n   /**\n    * Keep track of variables that we've referenced.\n       AbstractCompiler compiler,\n       boolean removeGlobals,\n       boolean preserveFunctionExpressionNames) {\n-    compiler_ = compiler;\n+    this.compiler = compiler;\n     this.removeGlobals = removeGlobals;\n     this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n   }\n    * may occur to ensure all unused variables are removed.\n    */\n   public void process(Node externs, Node root) {\n-    warnedVars_.clear();\n-    numRemoved_ = 0;\n+    numRemoved = 0;\n     referenced.clear();\n \n     traverseAndRemoveUnusedReferences(root);\n \n-    if (numRemoved_ > 0) {\n-      compiler_.reportCodeChange();\n+    if (numRemoved > 0) {\n+      compiler.reportCodeChange();\n     }\n   }\n \n    * Traverses a node recursively. Call this once per pass.\n    */\n   private void traverseAndRemoveUnusedReferences(Node root) {\n-    Scope scope = new SyntacticScopeCreator(compiler_).createScope(root, null);\n+    Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n     traverseNode(root, null, scope);\n \n     if (removeGlobals) {\n     // If we aren't removing global names, assume that all global functions\n     // are exported.\n     return (!removeGlobals && scope.isGlobal()) ||\n-        compiler_.getCodingConvention().isExported(\n+        compiler.getCodingConvention().isExported(\n            n.getFirstChild().getString());\n   }\n \n     Preconditions.checkState(body.getNext() == null &&\n             body.getType() == Token.BLOCK);\n \n-    Scope fnScope = new SyntacticScopeCreator(compiler_).createScope(n, scope);\n+    Scope fnScope = new SyntacticScopeCreator(compiler).createScope(n, scope);\n     traverseNode(body, n, fnScope);\n \n     removeUnreferencedFunctionArgs(n, fnScope);\n         }\n         argList.removeChild(lastArg);\n         fnScope.undeclare(var);\n-        numRemoved_++;\n+        numRemoved++;\n       } else {\n         break;\n       }\n    * Removes any vars in the scope that were not referenced.\n    */\n   private void removeUnreferencedVars(Scope scope) {\n-    CodingConvention convention = compiler_.getCodingConvention();\n+    CodingConvention convention = compiler.getCodingConvention();\n \n     for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n       Var var = it.next();\n       if (!referenced.contains(var) &&\n           (var.isLocal() || !convention.isExported(var.name))) {\n \n-        compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n+        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n         Node nameNode = var.nameNode;\n         Node toRemove = nameNode.getParent();\n         Node parent = toRemove.getParent();\n         } else if (NodeUtil.isFunctionExpression(toRemove)) {\n           if (!preserveFunctionExpressionNames) {\n             toRemove.getFirstChild().setString(\"\");\n-            compiler_.reportCodeChange();\n+            compiler.reportCodeChange();\n           }\n           // Don't remove bleeding functions.\n         } else if (parent != null &&\n         } else if (toRemove.getType() == Token.VAR &&\n                    nameNode.hasChildren() &&\n                    NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n-          if (!warnedVars_.contains(var)) {\n-            warnedVars_.add(var);\n-            String inputName = var.input != null\n-                               ? var.input.getName()\n-                               : \"<unknown>\";\n-            logger_.info(\"Unused var \" + var.name +\n-                         \" declared in \" + inputName +\n-                         \" at line \" + toRemove.getLineno() +\n-                         \" may have side effects and can't be removed\");\n-          }\n-\n           // If this is a single var declaration, we can at least remove the\n           // declaration itself and just leave the value, e.g.,\n           // var a = foo(); => foo();\n           if (toRemove.getChildCount() == 1) {\n             parent.replaceChild(toRemove,\n                 new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n-            numRemoved_++;\n+            numRemoved++;\n           }\n         } else if (toRemove.getType() == Token.VAR &&\n                    toRemove.getChildCount() > 1) {\n           // For var declarations with multiple names (i.e. var a, b, c),\n           // only remove the unreferenced name\n           toRemove.removeChild(nameNode);\n-          numRemoved_++;\n+          numRemoved++;\n         } else if (parent != null) {\n           NodeUtil.removeChild(parent, toRemove);\n-          numRemoved_++;\n+          numRemoved++;\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n    */\n   private static class LineMapping {\n     /**\n-     * The list of input files which created the code on this line.\n-     */\n-    List<String> files = Lists.newArrayList();\n-\n-    /**\n      * The line number of this line (indexed by 0).\n      */\n     int lineNumber;\n         if (current == null) {\n           out.append(\"-1\");\n         } else {\n-          out.append(current.basisMapping.id + \"\");\n-        }\n-      }\n-\n-      out.append(\"]\");\n-    }\n-\n-    /**\n-     * Appends the line mapping's file map to the given\n-     * buffer.\n-     */\n-    void appendFileMapTo(Appendable out) throws IOException {\n-      // Sort the files list for deterministic consistency.\n-      Collections.sort(files);\n-\n-      out.append(\"[\");\n-\n-      for (int j = 0; j < files.size(); ++j) {\n-        if (j > 0) {\n-          out.append(\",\");\n-        }\n-\n-        out.append(escapeString(files.get(j)));\n+          out.append(String.valueOf(current.basisMapping.id));\n+        }\n       }\n \n       out.append(\"]\");\n         lcm.endCharacter = endCharacter;\n         lcm.basisMapping = mapping;\n \n-        if (!lineMapping.files.contains(mapping.sourceFile)) {\n-          lineMapping.files.add(mapping.sourceFile);\n-        }\n-\n         lineMapping.characterMappings.add(lcm);\n       }\n     }\n     // best represents the index-th character found on that line of the\n     // generated source code.\n     //\n-    // The second section contains an array per generated line that contains\n-    // all the paths of the input source files that caused the code on the given\n-    // generated line to be generated. This is a simple array of Javascript\n-    // strings.\n+    // The second section contains an array per generated line. Unused.\n     //\n     // The third and final section contains an array per line, each of which\n     // represents a mapping with a unique ID. The mappings are added in order.\n     // 2)  [0,0,0,0,0,0,1,1,1,1,2]\n     // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n     // 4)  /** Begin file information. **/\n-    // 5)  [\"a.js\", \"b.js\"]\n-    // 6)  [\"b.js\", \"c.js\", \"d.js\"]\n+    // 5)  []\n+    // 6)  []\n     // 7)  /** Begin mapping definitions. **/\n     // 8)  [\"a.js\", 1, 34]\n     // 9)  [\"a.js\", 5, 2]\n     // Add the source file maps.\n     out.append(\"/** Begin file information. **/\\n\");\n \n+    // Add legacy file mapping section.  This data is never used but it is\n+    // need for the current file format.\n     for (int i = 0; i <= maxLine; ++i) {\n-      LineMapping lineMapping = lineMappings.get(i);\n-\n-      if (lineMapping == null) {\n-        out.append(\"[]\");\n-      } else {\n-        lineMapping.appendFileMapTo(out);\n-      }\n-\n-      out.append(\"\\n\");\n+      out.append(\"[]\\n\");\n     }\n \n     // Add the mappings themselves.\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n \n       if (info.parameters != null) {\n         for (JSTypeExpression parameterType : info.parameters.values()) {\n-          nodes.add(parameterType.getRoot());\n+          if (parameterType != null) {\n+            nodes.add(parameterType.getRoot());\n+          }\n         }\n       }\n \n       if (info.thrownTypes != null) {\n         for (JSTypeExpression thrownType : info.thrownTypes) {\n-          nodes.add(thrownType.getRoot());\n+          if (thrownType != null) {\n+            nodes.add(thrownType.getRoot());\n+          }\n         }\n       }\n     }\n--- a/test/com/google/javascript/jscomp/AliasExternalsTest.java\n+++ b/test/com/google/javascript/jscomp/AliasExternalsTest.java\n \n   private static String EXTERNS =\n     // Globals\n-    \"var window;var document;var arguments;var _USER_ID;var ActiveXObject;\" +\n+    \"/** @const */ var window;\" +\n+    \"/** @const */ var document;\" +\n+    \"var arguments;var _USER_ID;var ActiveXObject;\" +\n     \"function eval(x) {}\" +\n     // Properties\n     \"window.setTimeout;\" +\n   @Override\n   public void setUp() {\n     super.enableLineNumberCheck(false);\n+    super.enableNormalize();\n     unaliasableGlobals = null;\n     aliasableGlobals = null;\n   }\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n       fail(\"Test types should fail here.\");\n     } catch (AssertionError e) {\n     }\n+  }\n+\n+  public void testNullType() {\n+    testTypes(\n+        \"var x = goog.Timer;\",\n+        \"/** @param draggable */ types.actual;\"\n+        + \"/** @param draggable */ types.expected;\");\n   }\n \n   // TODO(robbyw): What if it's recursive?  var goog = goog.dom;\n--- a/test/com/google/javascript/jscomp/SourceMapTest.java\n+++ b/test/com/google/javascript/jscomp/SourceMapTest.java\n                     \"}\\n\\n\");\n   }\n \n+  public void testGoldenOutput0() throws Exception {\n+    // Empty source map test\n+    checkSourceMap(\"\",\n+\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\",\" +\n+                   \" \\\"count\\\": 1 }\\n\" +\n+\n+                   \"[0]\\n\" +\n+\n+                   \"/** Begin file information. **/\\n\" +\n+                   \"[]\\n\" +\n+\n+                   \"/** Begin mapping definitions. **/\\n\" +\n+                   \"[\\\"testcode\\\",1,0]\\n\");\n+  }\n+\n   public void testGoldenOutput1() throws Exception {\n     checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n \n                    \"10,10,10,10,11,11,12,12,12,12,12,12,13,13,13,13,13,6]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n-                   \"[\\\"testcode\\\"]\\n\" +\n+                   \"[]\\n\" +\n                    \"/** Begin mapping definitions. **/\\n\" +\n                    \"[\\\"testcode\\\",1,0]\\n\" +\n                    \"[\\\"testcode\\\",1,9]\\n\" +\n                    \"13,13,6]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n-                   \"[\\\"testcode\\\"]\\n\" +\n+                   \"[]\\n\" +\n                    \"/** Begin mapping definitions. **/\\n\" +\n                    \"[\\\"testcode\\\",1,0]\\n\" +\n                    \"[\\\"testcode\\\",1,9]\\n\" +\n                    \"[2,2,2,2]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n-                   \"[\\\"c:\\\\\\\\myfile.js\\\"]\\n\" +\n+                   \"[]\\n\" +\n                    \"/** Begin mapping definitions. **/\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +", "timestamp": 1278973222, "metainfo": ""}