{"sha": "b09e9b1e0be9e010eb46d4cb3555c6407e223866", "log": "cut about 25% of the runtime off dead assignments elimination  R=acleung DELTA=43  (33 added, 2 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=294307   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-\n \n /**\n  * Removes local variable assignments that are useless based on information from\n   private final AbstractCompiler compiler;\n   private LiveVariablesAnalysis liveness;\n \n+  // Matches all assignment operators and increment/decrement operators.\n+  // Does *not* match VAR initialization, since RemoveUnusedVariables\n+  // will already remove variables that are initialized but unused.\n+  private static final Predicate<Node> matchRemovableAssigns =\n+      new Predicate<Node>() {\n+    @Override\n+    public boolean apply(Node n) {\n+      return (NodeUtil.isAssignmentOp(n) &&\n+              n.getFirstChild().getType() == Token.NAME) ||\n+          n.getType() == Token.INC || n.getType() == Token.DEC;\n+    }\n+  };\n+\n   public DeadAssignmentsElimination(AbstractCompiler compiler) {\n     this.compiler = compiler;\n   }\n     // We are not going to do any dead assignment elimination in when there is\n     // at least one inner function because in most browsers, when there is a\n     // closure, ALL the variables are saved (escaped).\n-    if (!NodeUtil.containsFunction(\n-        t.getScopeRoot().getLastChild())) {\n-      // Computes liveness information first.\n-      ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n-      liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n-      liveness.analyze();\n-      tryRemoveDeadAssignments(t, cfg);\n-    }\n+    Node fnBlock = t.getScopeRoot().getLastChild();\n+    if (NodeUtil.containsFunction(fnBlock)) {\n+      return;\n+    }\n+\n+    // We don't do any dead assignment elimination if there are no assigns\n+    // to eliminate. :)\n+    if (!NodeUtil.has(fnBlock, matchRemovableAssigns,\n+            Predicates.<Node>alwaysTrue())) {\n+      return;\n+    }\n+\n+    // Computes liveness information first.\n+    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n+    liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n+    liveness.analyze();\n+    tryRemoveDeadAssignments(t, cfg);\n   }\n \n   @Override", "timestamp": 1286306468, "metainfo": ""}