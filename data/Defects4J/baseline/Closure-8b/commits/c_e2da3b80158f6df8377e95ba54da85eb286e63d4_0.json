{"sha": "e2da3b80158f6df8377e95ba54da85eb286e63d4", "log": "Making global typed scope regeneration, hot-swappable.  R=nicksantos DELTA=163  (130 added, 16 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2142   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     }\n     @Override\n     public void hotSwapScript(Node scriptRoot) {\n-      // We have to rebuild the global scope.\n-      // If this is not fast enough, we'll need to change the interface\n-      // of ScopeCreator so that it can patch new variables into an existing\n-      // scope (right now it can only create new scopes).\n-      regenerateGlobalTypedScope(compiler, compiler.getRoot());\n+      patchGlobalTypedScope(compiler, scriptRoot);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Iterables;\n-import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.GraphvizGraph;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.Node;\n \n import java.io.Serializable;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n    */\n   private MemoizedScopeCreator typedScopeCreator;\n \n+  /**\n+   * This is the scope creator that {@code TypedScopeCreator} delegates to.\n+   */\n+  private TypedScopeCreator internalScopeCreator;\n+\n   /** The global typed scope. */\n   Scope topScope = null;\n \n   }\n \n   /**\n-   * Regenerates the top scope.\n+   * Regenerates the top scope from scratch.\n+   *\n+   * @param compiler The compiler for which the global scope is regenerated.\n+   * @param root The root of the AST.\n    */\n   void regenerateGlobalTypedScope(AbstractCompiler compiler, Node root) {\n-    MemoizedScopeCreator oldScopeCreator = typedScopeCreator;\n-    typedScopeCreator =\n-        new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n+    internalScopeCreator = new TypedScopeCreator(compiler);\n+    typedScopeCreator = new MemoizedScopeCreator(internalScopeCreator);\n     topScope = typedScopeCreator.createScope(root, null);\n-\n-    if (oldScopeCreator != null) {\n-      Scope oldTopScope = oldScopeCreator.getScopeIfMemoized(root);\n-      if (oldTopScope != null) {\n-        // For each variable declared with the VAR keyword, we want to grab\n-        // its old inferred type.\n-        //\n-        // This is purely a heuristic. There are probably better ones we\n-        // can use to increase the accuracy (like checking if a variable\n-        // has been modified in the current script).\n-        Iterator<Var> varIt =\n-            topScope.getDeclarativelyUnboundVarsWithoutTypes();\n-        while (varIt.hasNext()) {\n-          Var newVar = varIt.next();\n-          Var oldVar = oldTopScope.getVar(newVar.getName());\n-          if (oldVar != null) {\n-            newVar.setType(oldVar.getType());\n-          }\n-        }\n-      }\n-    }\n+  }\n+\n+  /**\n+   * Regenerates the top scope potentially only for a sub-tree of AST and then\n+   * copies information for the old global scope.\n+   *\n+   * @param compiler The compiler for which the global scope is generated.\n+   * @param scriptRoot The root of the AST used to generate global scope.\n+   */\n+  void patchGlobalTypedScope(AbstractCompiler compiler, Node scriptRoot) {\n+    Preconditions.checkNotNull(internalScopeCreator);\n+    internalScopeCreator.patchGlobalScope(topScope, scriptRoot);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n    * Creates a scope with all types declared. Declares newly discovered types\n    * and type properties in the type registry.\n    */\n+  @Override\n   public Scope createScope(Node root, Scope parent) {\n     // Constructing the global scope is very different than constructing\n     // inner scopes, because only global scopes can contain named classes that\n           typeRegistry, newScope, delegateProxyPrototypes);\n     }\n     return newScope;\n+  }\n+\n+  /**\n+   * Patches a given global scope by removing variables previously declared in\n+   * a script and re-traversing a new version of that script.\n+   *\n+   * @param globalScope The global scope generated by {@code createScope}.\n+   * @param scriptRoot The script that is modified.\n+   */\n+  void patchGlobalScope(Scope globalScope, Node scriptRoot) {\n+    // Preconditions: This is supposed to be called only on (named) SCRIPT nodes\n+    // and a global typed scope should have been generated already.\n+    Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);\n+    Preconditions.checkNotNull(globalScope);\n+    Preconditions.checkState(globalScope.isGlobal());\n+\n+    // TODO(bashir): Variable declaration is not the only side effect of last\n+    // global scope generation but here we only wipe that part off!\n+\n+    // Remove all variables that were previously declared in this scripts.\n+    String scriptName = NodeUtil.getSourceName(scriptRoot);\n+    Preconditions.checkNotNull(scriptName);\n+    // First find all vars to remove then remove them because of iterator!\n+    Iterator<Var> varIter = globalScope.getVars();\n+    List<Var> varsToRemove = Lists.newArrayList();\n+    while (varIter.hasNext()) {\n+      Var oldVar = varIter.next();\n+      if (scriptName.equals(oldVar.getInputName())) {\n+        varsToRemove.add(oldVar);\n+      }\n+    }\n+    for (Var var : varsToRemove) {\n+      globalScope.undeclare(var);\n+    }\n+\n+    // Now re-traverse the given script.\n+    GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(globalScope);\n+    NodeTraversal.traverse(compiler, scriptRoot, scopeBuilder);\n   }\n \n   /**\n      * @param rValue The node of the enum.\n      * @param name The enum's name\n      * @param info The {@link JSDocInfo} attached to the enum definition.\n-     * @param lvalueNode The node where this function is being\n+     * @param lValueNode The node where this function is being\n      *     assigned.\n      */\n     private EnumType createEnumTypeFromNodes(Node rValue, String name,", "timestamp": 1307031033, "metainfo": ""}