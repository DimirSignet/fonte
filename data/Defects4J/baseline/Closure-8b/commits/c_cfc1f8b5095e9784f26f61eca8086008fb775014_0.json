{"sha": "cfc1f8b5095e9784f26f61eca8086008fb775014", "log": "Slightly better global property checks.  R=johnlenz DELTA=125  (71 added, 21 deleted, 33 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5012   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n \n     JSModuleGraph moduleGraph = compiler.getModuleGraph();\n     for (Ref ref : name.getRefs()) {\n+      // Don't worry about global exprs.\n+      boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n+\n       if (!isDefined && !isTypedef(ref)) {\n-        reportRefToUndefinedName(name, ref);\n+        if (!isGlobalExpr) {\n+          reportRefToUndefinedName(name, ref);\n+        }\n       } else if (declaration != null &&\n           ref.getModule() != declaration.getModule() &&\n           !moduleGraph.dependsOn(\n    * must be initialized with its full qualified name.\n    */\n   private boolean propertyMustBeInitializedByFullName(Name name) {\n-    // If an object literal in the global namespace is never aliased,\n-    // then all of its properties must be defined using its full qualified\n-    // name. This implies that its properties must all be in the global\n-    // namespace as well.\n+    // If an object or function literal in the global namespace is never\n+    // aliased, then its properties can only come from one of 2 places:\n+    // 1) From its prototype chain, or\n+    // 2) From an assignment to its fully qualified name.\n+    // If we assume #1 is not the case, then #2 implies that its\n+    // properties must all be modeled in the GlobalNamespace as well.\n     //\n-    // The same is not true for FUNCTION and OTHER types, because their\n-    // implicit prototypes have properties that are not captured by the global\n-    // namespace.\n+    // We assume that for global object literals and types (constructors and\n+    // interfaces), we can find all the properties inherited from the prototype\n+    // chain of functions and objects.\n     //\n-    // This comment will be fixed in a subsequent cl.\n-    return name.parent != null && name.parent.aliasingGets == 0 &&\n-        name.parent.type == Name.Type.OBJECTLIT &&\n-        !objectPrototypeProps.contains(name.getBaseName());\n+    // We could improve this check by classifying aliasing gets. For example,\n+    // goog.inherits is an aliasing get that adds a known set of properties.\n+    if (name.parent == null || name.parent.aliasingGets > 0) {\n+      return false;\n+    }\n+\n+    if (objectPrototypeProps.contains(name.getBaseName())) {\n+      return false;\n+    }\n+\n+    if (name.parent.type == Name.Type.OBJECTLIT) {\n+      return true;\n+    }\n+\n+    if (name.parent.type == Name.Type.FUNCTION &&\n+        name.parent.isDeclaredType() &&\n+        !functionPrototypeProps.contains(name.getBaseName())) {\n+      return true;\n+    }\n+\n+    return false;\n   }\n }\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n             currentPreOrderIndex++);\n         nameObj.addRef(get);\n         Ref.markTwins(set, get);\n-      } else if (isConstructorOrEnumDeclaration(n, parent)) {\n+      } else if (isTypeDeclaration(n, parent)) {\n         // Names with a @constructor or @enum annotation are always collapsed\n-        nameObj.setIsClassOrEnum();\n+        nameObj.setDeclaredType();\n       }\n     }\n \n     /**\n      * Determines whether a set operation is a constructor or enumeration\n-     * declaration. The set operation may either be an assignment to a name,\n-     * a variable declaration, or an object literal key mapping.\n+     * or interface declaration. The set operation may either be an assignment\n+     * to a name, a variable declaration, or an object literal key mapping.\n      *\n      * @param n The node that represents the name being set\n      * @param parent Parent node of {@code n} (an ASSIGN, VAR, or OBJLIT node)\n      * @return Whether the set operation is either a constructor or enum\n      *     declaration\n      */\n-    private boolean isConstructorOrEnumDeclaration(Node n, Node parent) {\n-      JSDocInfo info;\n-      int valueNodeType;\n-      switch (parent.getType()) {\n-        case Token.ASSIGN:\n-          info = parent.getJSDocInfo();\n-          valueNodeType = n.getNext().getType();\n-          break;\n-        case Token.VAR:\n-          info = n.getJSDocInfo();\n-          if (info == null) {\n-            info = parent.getJSDocInfo();\n-          }\n-          Node valueNode = n.getFirstChild();\n-          valueNodeType = valueNode != null ? valueNode.getType() : Token.VOID;\n-          break;\n-        default:\n-          if (NodeUtil.isFunctionDeclaration(parent)) {\n-            info = parent.getJSDocInfo();\n-            valueNodeType = Token.FUNCTION;\n-            break;\n-          }\n-          return false;\n-      }\n+    private boolean isTypeDeclaration(Node n, Node parent) {\n+      Node valueNode = NodeUtil.getRValueOfLValue(n);\n+      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n       // Heed the annotations only if they're sensibly used.\n-      return info != null &&\n-             (info.isConstructor() && valueNodeType == Token.FUNCTION ||\n-              info.hasEnumParameterType() && valueNodeType == Token.OBJECTLIT);\n+      return info != null && valueNode != null &&\n+             (info.isConstructor() && valueNode.isFunction() ||\n+              info.isInterface() && valueNode.isFunction() ||\n+              info.hasEnumParameterType() && valueNode.isObjectLit());\n     }\n \n     /**\n     private List<Ref> refs;\n \n     Type type;\n-    private boolean isClassOrEnum = false;\n-    private boolean hasClassOrEnumDescendant = false;\n+    private boolean declaredType = false;\n+    private boolean hasDeclaredTypeDescendant = false;\n     int globalSets = 0;\n     int localSets = 0;\n     int aliasingGets = 0;\n     }\n \n     boolean canCollapse() {\n-      return !inExterns && !isGetOrSetDefinition() && (isClassOrEnum ||\n+      return !inExterns && !isGetOrSetDefinition() && (declaredType ||\n           (parent == null || parent.canCollapseUnannotatedChildNames()) &&\n           (globalSets > 0 || localSets > 0) &&\n           deleteProps == 0);\n         return false;\n       }\n \n-      if (isClassOrEnum) {\n+      if (declaredType) {\n         return true;\n       }\n \n       return globalSets == 0 && localSets > 0;\n     }\n \n-    void setIsClassOrEnum() {\n-      isClassOrEnum = true;\n+    void setDeclaredType() {\n+      declaredType = true;\n       for (Name ancestor = parent; ancestor != null;\n            ancestor = ancestor.parent) {\n-        ancestor.hasClassOrEnumDescendant = true;\n-      }\n+        ancestor.hasDeclaredTypeDescendant = true;\n+      }\n+    }\n+\n+    boolean isDeclaredType() {\n+      return declaredType;\n     }\n \n     /**\n      * considered namespaces.\n      */\n     boolean isNamespace() {\n-      return hasClassOrEnumDescendant && type == Type.OBJECTLIT;\n+      return hasDeclaredTypeDescendant && type == Type.OBJECTLIT;\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     return null;\n   }\n \n+  /** Gets the r-value of a node returned by getBestLValue. */\n+  static Node getRValueOfLValue(Node n) {\n+    Node parent = n.getParent();\n+    switch (parent.getType()) {\n+      case Token.ASSIGN:\n+        return n.getNext();\n+      case Token.VAR:\n+        return n.getFirstChild();\n+      case Token.FUNCTION:\n+        return parent;\n+    }\n+    return null;\n+  }\n+\n   /** Get the owner of the given l-value node. */\n   static Node getBestLValueOwner(@Nullable Node lValue) {\n     if (lValue == null || lValue.getParent() == null) {\n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n   public CheckGlobalNamesTest() {\n     super(\"function alert() {}\" +\n           \"/** @constructor */ function Object(){}\" +\n-          \"Object.prototype.hasOwnProperty = function() {};\");\n+          \"Object.prototype.hasOwnProperty = function() {};\" +\n+          \"/** @constructor */ function Function(){}\" +\n+          \"Function.prototype.call = function() {};\");\n   }\n \n   @Override\n         \"}\", NAME_DEFINED_LATE_WARNING);\n   }\n \n+  public void testOkGlobalDeclExpr() {\n+    testSame(\"var x = {}; /** @type {string} */ x.foo;\");\n+  }\n+\n+  public void testBadInterfacePropRef() {\n+    testSame(\n+        \"/** @interface */ function F() {}\" +\n+         \"F.bar();\",\n+         UNDEFINED_NAME_WARNING);\n+  }\n+\n+  public void testInterfaceFunctionPropRef() {\n+    testSame(\n+        \"/** @interface */ function F() {}\" +\n+         \"F.call(); F.hasOwnProperty('z');\");\n+  }\n+\n   public void testObjectPrototypeProperties() {\n     testSame(\"var x = {}; var y = x.hasOwnProperty('z');\");\n   }\n     testSame(\"Object.prototype.seal = function() {};\" +\n         \"var x = {}; x.seal();\");\n   }\n+\n+  public void testFunctionPrototypeProperties() {\n+    testSame(\"var x = {}; var y = x.hasOwnProperty('z');\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n \n   public void testPropertyOnGlobalCtor() {\n     test(\"/** @constructor */ function Map() {} Map.foo = 3; Map;\",\n+         \"function Map() {} var Map$foo = 3; Map;\");\n+  }\n+\n+  public void testPropertyOnGlobalInterface() {\n+    test(\"/** @interface */ function Map() {} Map.foo = 3; Map;\",\n          \"function Map() {} var Map$foo = 3; Map;\");\n   }\n ", "timestamp": 1339685268, "metainfo": ""}