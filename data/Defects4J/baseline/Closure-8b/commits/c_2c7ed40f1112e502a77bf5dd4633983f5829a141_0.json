{"sha": "2c7ed40f1112e502a77bf5dd4633983f5829a141", "log": "Add support for indirectly defined properties to the global names check.  R=johnlenz DELTA=65  (60 added, 1 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5015   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n     Preconditions.checkState(namespace.hasExternsRoot());\n     findPrototypeProps(\"Object\", objectPrototypeProps);\n     findPrototypeProps(\"Function\", functionPrototypeProps);\n+    objectPrototypeProps.addAll(\n+        compiler.getCodingConvention().getIndirectlyDeclaredProperties());\n \n     for (Name name : namespace.getNameForest()) {\n       // Skip extern names. Externs are often not runnable as real code,\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import java.util.List;\n import java.util.Set;\n \n-\n /**\n  * This describes the Closure-specific JavaScript coding conventions.\n  *\n       \"JSC_REFLECT_OBJECTLIT_EXPECTED\",\n       \"Object literal expected as second argument\");\n \n+  private final Set<String> indirectlyDeclaredProperties;\n+\n   public ClosureCodingConvention() {\n     this(CodingConventions.getDefault());\n   }\n \n   public ClosureCodingConvention(CodingConvention wrapped) {\n     super(wrapped);\n+\n+    Set<String> props = Sets.newHashSet(\n+        \"superClass_\",\n+        \"instance_\",\n+        \"getInstance\");\n+    props.addAll(wrapped.getIndirectlyDeclaredProperties());\n+    indirectlyDeclaredProperties = ImmutableSet.copyOf(props);\n   }\n \n   /**\n   @Override\n   public void applySubclassRelationship(FunctionType parentCtor,\n       FunctionType childCtor, SubclassType type) {\n+    super.applySubclassRelationship(parentCtor, childCtor, type);\n     if (type == SubclassType.INHERITS) {\n       childCtor.defineDeclaredProperty(\"superClass_\",\n           parentCtor.getPrototype(), childCtor.getSource());\n    */\n   @Override\n   public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n+    SubclassRelationship relationship =\n+        super.getClassesDefinedByCall(callNode);\n+    if (relationship != null) return relationship;\n+\n     Node callName = callNode.getFirstChild();\n     SubclassType type = typeofClassDefiningName(callName);\n     if (type != null) {\n \n   @Override\n   public boolean isSuperClassReference(String propertyName) {\n-    return \"superClass_\".equals(propertyName);\n+    return \"superClass_\".equals(propertyName) ||\n+        super.isSuperClassReference(propertyName);\n   }\n \n   /**\n         return typeNames;\n       }\n     }\n-    return null;\n+    return super.identifyTypeDeclarationCall(n);\n   }\n \n   @Override\n     if (!(\"goog.addSingletonGetter\".equals(callName) ||\n           \"goog$addSingletonGetter\".equals(callName)) ||\n         callNode.getChildCount() != 2) {\n-      return null;\n+      return super.getSingletonGetterClassName(callNode);\n     }\n \n     return callArg.getNext().getQualifiedName();\n   @Override\n   public void applySingletonGetter(FunctionType functionType,\n       FunctionType getterType, ObjectType objectType) {\n+    super.applySingletonGetter(functionType, getterType, objectType);\n     functionType.defineDeclaredProperty(\"getInstance\", getterType,\n         functionType.getSource());\n     functionType.defineDeclaredProperty(\"instance_\", objectType,\n   public boolean isPropertyTestFunction(Node call) {\n     Preconditions.checkArgument(call.isCall());\n     return propertyTestFunctions.contains(\n-        call.getFirstChild().getQualifiedName());\n+        call.getFirstChild().getQualifiedName()) ||\n+        super.isPropertyTestFunction(call);\n   }\n \n   @Override\n   public ObjectLiteralCast getObjectLiteralCast(Node callNode) {\n     Preconditions.checkArgument(callNode.isCall());\n+    ObjectLiteralCast proxyCast = super.getObjectLiteralCast(callNode);\n+    if (proxyCast != null) {\n+      return proxyCast;\n+    }\n+\n     Node callName = callNode.getFirstChild();\n     if (!\"goog.reflect.object\".equals(callName.getQualifiedName()) ||\n         callNode.getChildCount() != 3) {\n     }\n \n     return null;\n+  }\n+\n+  @Override\n+  public Collection<String> getIndirectlyDeclaredProperties() {\n+    return indirectlyDeclaredProperties;\n   }\n \n   private Node safeNext(Node n) {\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n   public ObjectLiteralCast getObjectLiteralCast(Node callNode);\n \n   /**\n+   * Gets a collection of all properties that are defined indirectly on global\n+   * objects. (For example, Closure defines superClass_ in the goog.inherits\n+   * call).\n+   */\n+  public Collection<String> getIndirectlyDeclaredProperties();\n+\n+  /**\n    * Returns the set of AssertionFunction.\n    */\n   public Collection<AssertionFunctionSpec> getAssertionFunctions();\n--- a/src/com/google/javascript/jscomp/CodingConventions.java\n+++ b/src/com/google/javascript/jscomp/CodingConventions.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n     @Override\n     public ObjectLiteralCast getObjectLiteralCast(Node callNode) {\n       return nextConvention.getObjectLiteralCast(callNode);\n+    }\n+\n+    @Override\n+    public Collection<String> getIndirectlyDeclaredProperties() {\n+      return nextConvention.getIndirectlyDeclaredProperties();\n     }\n   }\n \n       return null;\n     }\n \n+    @Override\n+    public Collection<String> getIndirectlyDeclaredProperties() {\n+      return ImmutableList.of();\n+    }\n+\n     private Node safeNext(Node n) {\n       if (n != null) {\n         return n.getNext();\n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n   public void testFunctionPrototypeProperties() {\n     testSame(\"var x = {}; var y = x.hasOwnProperty('z');\");\n   }\n+\n+  public void testIndirectlyDeclaredProperties() {\n+    testSame(\n+        \"Function.prototype.inherits = function(ctor) {\" +\n+        \"  this.superClass_ = ctor;\" +\n+        \"};\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() {};\" +\n+        \"/** @constructor */ function SubFoo() {}\" +\n+        \"SubFoo.inherits(Foo);\" +\n+        \"SubFoo.superClass_.bar();\");\n+  }\n }", "timestamp": 1339706078, "metainfo": ""}