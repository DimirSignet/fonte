{"sha": "f9fbad23b8fb59464e395c164197750abb5db296", "log": "Get rid of the goog.now optimization. This is a weird micro-optimization that will break if we change to implementation of goog.now to use high-resolution timers.  R=chrishenry DELTA=61  (1 added, 50 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5132   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Processes jQuery aliases */\n   public boolean jqueryPass;\n-\n-  /** Rewrite new Date(goog.now()) to new Date().  */\n-  boolean rewriteNewDateGoogNow;\n \n   /** Remove goog.abstractMethod assignments. */\n   boolean removeAbstractMethods;\n     removeTryCatchFinally = false;\n     closurePass = false;\n     jqueryPass = false;\n-    rewriteNewDateGoogNow = true;\n     removeAbstractMethods = true;\n     removeClosureAsserts = false;\n     stripTypes = Collections.emptySet();\n         Lists.newArrayList(functionDescriptors);\n   }\n \n+  @Deprecated\n   public void setRewriteNewDateGoogNow(boolean rewrite) {\n-    this.rewriteNewDateGoogNow = rewrite;\n   }\n \n   public void setRemoveAbstractMethods(boolean remove) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       final ProcessClosurePrimitives pass = new ProcessClosurePrimitives(\n           compiler,\n           preprocessorSymbolTable,\n-          options.brokenClosureRequiresLevel,\n-          options.rewriteNewDateGoogNow);\n+          options.brokenClosureRequiresLevel);\n \n       return new HotSwapCompilerPass() {\n         @Override\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       Lists.newArrayList();\n   private final Set<String> exportedVariables = Sets.newHashSet();\n   private final CheckLevel requiresLevel;\n-  private final boolean rewriteNewDateGoogNow;\n   private final PreprocessorSymbolTable preprocessorSymbolTable;\n \n   ProcessClosurePrimitives(AbstractCompiler compiler,\n       @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n-      CheckLevel requiresLevel,\n-      boolean rewriteNewDateGoogNow) {\n+      CheckLevel requiresLevel) {\n     this.compiler = compiler;\n     this.preprocessorSymbolTable = preprocessorSymbolTable;\n     this.moduleGraph = compiler.getModuleGraph();\n     this.requiresLevel = requiresLevel;\n-    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n \n     // goog is special-cased because it is provided in Closure's base library.\n     providedNames.put(GOOG,\n         }\n         break;\n \n-      case Token.NEW:\n-        trySimplifyNewDate(t, n, parent);\n-        break;\n-\n       case Token.GETPROP:\n         if (n.getFirstChild().isName() &&\n             !parent.isCall() &&\n     }\n   }\n \n-\n-  /**\n-   * Try to simplify \"new Date(goog.now())\" to \"new Date()\".\n-   */\n-  private void trySimplifyNewDate(NodeTraversal t, Node n, Node parent) {\n-    if (!rewriteNewDateGoogNow) {\n-      return;\n-    }\n-    Preconditions.checkArgument(n.isNew());\n-    Node date = n.getFirstChild();\n-    if (!date.isName() || !\"Date\".equals(date.getString())) {\n-      return;\n-    }\n-    Node callGoogNow = date.getNext();\n-    if (callGoogNow == null || !callGoogNow.isCall() ||\n-        callGoogNow.getNext() != null) {\n-      return;\n-    }\n-    Node googNow = callGoogNow.getFirstChild();\n-    String googNowQName = googNow.getQualifiedName();\n-    if (googNowQName == null || !\"goog.now\".equals(googNowQName)\n-        || googNow.getNext() != null) {\n-      return;\n-    }\n-    n.removeChild(callGoogNow);\n-    compiler.reportCodeChange();\n-  }\n-\n   /**\n    * Verifies that a provide method call has exactly one argument,\n    * and that it's a string literal and that the contents of the string are\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n         // Only run process closure primitives once, if asked.\n         if (closurePassEnabled && i == 0) {\n           recentChange.reset();\n-          new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n+          new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n               .process(null, mainRoot);\n           hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged();\n         }\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         0, compiler.getErrorCount());\n \n     // For processing goog.addDependency for forward typedefs.\n-    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n+    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n         .process(null, n);\n \n     CodingConvention convention = compiler.getCodingConvention();\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n   @Override public CompilerPass getProcessor(final Compiler compiler) {\n     if ((additionalCode == null) && (additionalEndCode == null)) {\n       return new ProcessClosurePrimitives(\n-          compiler, null, CheckLevel.ERROR, true);\n+          compiler, null, CheckLevel.ERROR);\n     } else {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n           // Process the original code.\n-          new ProcessClosurePrimitives(compiler, null, CheckLevel.OFF, true)\n+          new ProcessClosurePrimitives(compiler, null, CheckLevel.OFF)\n               .process(externs, root);\n \n           // Inject additional code at the beginning.\n           }\n \n           // Process the tree a second time.\n-          new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n+          new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n               .process(externs, root);\n         }\n       };\n          MISSING_PROVIDE_ERROR);\n   }\n \n-  public void testNewDateGoogNowSimplification() {\n-    test(\"var x = new Date(goog.now());\", \"var x = new Date();\");\n-    testSame(\"var x = new Date(goog.now() + 1);\");\n-    testSame(\"var x = new Date(goog.now(1));\");\n-    testSame(\"var x = new Date(1, goog.now());\");\n-    testSame(\"var x = new Date(1);\");\n-    testSame(\"var x = new Date();\");\n-  }\n-\n   public void testAddDependency() {\n     test(\"goog.addDependency('x.js', ['A', 'B'], []);\", \"0\");\n \n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n     public void process(Node externs, Node root) {\n       ProcessClosurePrimitives closurePass =\n           new ProcessClosurePrimitives(\n-              compiler, null, CheckLevel.WARNING, true);\n+              compiler, null, CheckLevel.WARNING);\n       closurePass.process(externs, root);\n       renameVars = new RenameVars(compiler, prefix,\n           false, false, false, false, previouslyUsedMap, null,\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         0, compiler.getErrorCount());\n \n     // For processing goog.addDependency for forward typedefs.\n-    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR, true)\n+    new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR)\n         .process(null, n);\n \n     CodingConvention convention = compiler.getCodingConvention();", "timestamp": 1341869062, "metainfo": ""}