{"sha": "b347ce3a71e23a4ab92dc0a6c07d43e2f497c953", "log": "Remove var declarations when name functions are in the same scope. Fixes Issue 33 (John) R=nick DELTA=206  (155 added, 16 deleted, 35 changed)  Assorted API fixes. Fixes issue 127. (Nick) R=robert DELTA=7  (0 added, 1 deleted, 6 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n    */\n   protected abstract B createOptions();\n \n-  protected DiagnosticGroups getDiagnoticGroups() {\n+  protected DiagnosticGroups getDiagnosticGroups() {\n     return new DiagnosticGroups();\n   }\n \n   protected void initOptionsFromFlags(CompilerOptions options) {\n \n-    DiagnosticGroups diagnosticGroups = getDiagnoticGroups();\n+    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n \n     diagnosticGroups.setWarningLevels(\n         options, config.jscompError, CheckLevel.ERROR);\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n   /**\n    * Report an error or warning.\n    */\n-  abstract void report(JSError error);\n+  public abstract void report(JSError error);\n \n   /**\n    * Report an internal error.\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   //------------------------------------------------------------------------\n \n   @Override\n-  void report(JSError error) {\n+  public void report(JSError error) {\n     CheckLevel level = error.level;\n     WarningsGuard guard = options_.getWarningsGuard();\n     if (guard != null) {\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n   }\n \n   /** Find the diagnostic group registered under the given name. */\n-  DiagnosticGroup forName(String name) {\n+  protected DiagnosticGroup forName(String name) {\n     return groupsByName.get(name);\n   }\n \n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n  * This pass currently does the following:\n  * 1) Simplifies the AST by splitting var statements, moving initializiers\n  *    out of for loops, and converting whiles to fors.\n- * 2) Makes all variable names globally unique (extern or otherwise) so that\n+ * 2) Moves hoisted functions to the top of function scopes.\n+ * 3) Rewrites unhoisted named function declarations to be var declarations.\n+ * 4) Makes all variable names globally unique (extern or otherwise) so that\n  *    no value is ever shadowed (note: \"arguments\" may require special\n  *    handling).\n- * 3) Removes duplicate variable declarations.\n- * 4) Marks constants with the IS_CONSTANT_NAME annotation.\n+ * 5) Removes duplicate variable declarations.\n+ * 6) Marks constants with the IS_CONSTANT_NAME annotation.\n  *\n  * @author johnlenz@google.com (johnlenz)\n  */\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n     // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function \n+    // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n     // cases where a function scope variable conflict with a exception name:\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes. \n+    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n     removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n             reportCodeChange(\"WHILE node\");\n           }\n           break;\n-      }\n+\n+        case Token.FUNCTION:\n+          normalizeFunctionDeclaration(n);\n+          break;\n+      }\n+    }\n+\n+    /**\n+     * Rewrite named unhoisted functions declarations to a known\n+     * consistent behavior so we don't to different logic paths for the same\n+     * code. From:\n+     *    function f() {}\n+     * to:\n+     *    var f = function () {};\n+     */\n+    private void normalizeFunctionDeclaration(Node n) {\n+      Preconditions.checkState(n.getType() == Token.FUNCTION);\n+      if (!NodeUtil.isFunctionAnonymous(n)\n+          && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n+        rewriteFunctionDeclaration(n);\n+      }\n+    }\n+\n+    /**\n+     * Rewrite the function declaration from:\n+     *   function x() {}\n+     *   FUNCTION\n+     *     NAME\n+     *     LP\n+     *     BLOCK\n+     * to:\n+     *   var x = function() {};\n+     *   VAR\n+     *     NAME\n+     *       FUNCTION\n+     *         NAME (w/ empty string)\n+     *         LP\n+     *         BLOCK\n+     */\n+    private void rewriteFunctionDeclaration(Node n) {\n+      // Prepare a spot for the function.\n+      Node oldNameNode = n.getFirstChild();\n+      Node fnNameNode = oldNameNode.cloneNode();\n+      Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno());\n+      var.copyInformationFrom(n);\n+\n+      // Prepare the function\n+      oldNameNode.setString(\"\");\n+\n+      // Move the function\n+      Node parent = n.getParent();\n+      parent.replaceChild(n, var);\n+      fnNameNode.addChildToFront(n);\n+\n+      reportCodeChange(\"Function declaration\");\n     }\n \n     /**\n         Scope s, String name, Node n, Node parent, Node gramps,\n         Node nodeWithLineNumber) {\n       Preconditions.checkState(n.getType() == Token.NAME);\n-      if (parent.getType() == Token.VAR) {\n+      Var v = s.getVar(name);\n+      // If name is \"arguments\", Var maybe null.\n+      Preconditions.checkState(\n+          v == null || v.getParentNode().getType() != Token.CATCH);\n+      if (v != null && parent.getType() == Token.FUNCTION) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+          s.undeclare(v);\n+          s.declare(name, n, n.getJSType(), v.input);\n+          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n+              v.getParentNode().getParent());\n+        }\n+      } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n \n-        //\n-        // Remove the parent VAR. There are three cases that need to be handled:\n-        //  1) \"var a = b;\" which is replaced with \"a = b\"\n-        //  2) \"label:var a;\" which is replaced with \"label:;\".  Ideally, the\n-        //     label itself would be removed but that is not possible in the\n-        //     context in which \"onRedeclaration\" is called.\n-        //  3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n-        // Cases we don't need to handle are VARs with multiple children,\n-        // which have already been split into separate declarations, so there\n-        // is no need to handle that here, and \"for (var a;;);\", which has\n-        // been moved out of the loop.\n-        //\n-        // The result of this is that in each case the parent node is replaced\n-        // which is generally dangerous in a traversal but is fine here with\n-        // the scope creator, as the next node of interest is the parent's\n-        // next sibling.\n-        //\n-        if (n.hasChildren()) {\n-          // The var is being initialize, preserve the new value.\n+        replaceVarWithAssignment(n, parent, gramps);\n+      }\n+    }\n+\n+    /**\n+     * Remove the parent VAR. There are three cases that need to be handled:\n+     *   1) \"var a = b;\" which is replaced with \"a = b\"\n+     *   2) \"label:var a;\" which is replaced with \"label:;\". Ideally, the\n+     *      label itself would be removed but that is not possible in the\n+     *      context in which \"onRedeclaration\" is called.\n+     *   3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n+     *      Cases we don't need to handle are VARs with multiple children,\n+     *      which have already been split into separate declarations, so there\n+     *      is no need to handle that here, and \"for (var a;;);\", which has\n+     *      been moved out of the loop.\n+     *      The result of this is that in each case the parent node is replaced\n+     *      which is generally dangerous in a traversal but is fine here with\n+     *      the scope creator, as the next node of interest is the parent's\n+     *      next sibling.\n+     */\n+    private void replaceVarWithAssignment(Node n, Node parent, Node gramps) {\n+      if (n.hasChildren()) {\n+        // The  *  is being initialize, preserve the new value.\n+        parent.removeChild(n);\n+        // Convert \"var name = value\" to \"name = value\"\n+        Node value = n.getFirstChild();\n+        n.removeChild(value);\n+        Node replacement = new Node(Token.ASSIGN, n, value);\n+        gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement));\n+      } else {\n+        // It is an empty reference remove it.\n+        if (NodeUtil.isStatementBlock(gramps)) {\n+          gramps.removeChild(parent);\n+        } else if (gramps.getType() == Token.FOR) {\n+          // This is the \"for (var a in b)...\" case.  We don't need to worry\n+          // about initializers in \"for (var a;;)...\" as those are moved out\n+          // as part of the other normalizations.\n           parent.removeChild(n);\n-          // Convert \"var name = value\" to \"name = value\"\n-          Node value = n.getFirstChild();\n-          n.removeChild(value);\n-          Node replacement = new Node(Token.ASSIGN, n, value);\n-          gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement));\n+          gramps.replaceChild(parent, n);\n         } else {\n-          // It is an empty reference remove it.\n-          if (NodeUtil.isStatementBlock(gramps)) {\n-            gramps.removeChild(parent);\n-          } else if (gramps.getType() == Token.FOR) {\n-            // This is the \"for (var a in b)...\" case.  We don't need to worry\n-            // about initializers in \"for (var a;;)...\" as those are moved out\n-            // as part of the other normalizations.\n-            parent.removeChild(n);\n-            gramps.replaceChild(parent, n);\n-          } else {\n-            Preconditions.checkState(gramps.getType() == Token.LABEL);\n-            gramps.replaceChild(parent, new Node(Token.EMPTY));\n-          }\n-        }\n-        reportCodeChange(\"Duplicate VAR declaration\");\n-      }\n-    }\n-\n+          Preconditions.checkState(gramps.getType() == Token.LABEL);\n+          gramps.replaceChild(parent, new Node(Token.EMPTY));\n+        }\n+      }\n+      reportCodeChange(\"Duplicate VAR declaration\");\n+    }\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n   public void testMoveFunctions2() throws Exception {\n     testSame(\"function f() { function foo() {} }\");\n     test(\"function f() { f(); a:function bar() {} }\",\n-         \"function f() { f(); a:{function bar() {}}}\");\n-    testSame(\"function f() { f(); {function bar() {}}}\");\n-    testSame(\"function f() { f(); if (true) {function bar() {}}}\");\n-  }\n+         \"function f() { f(); a:{ var bar = function () {} }}\");\n+    test(\"function f() { f(); {function bar() {}}}\",\n+         \"function f() { f(); {var bar = function () {}}}\");\n+    test(\"function f() { f(); if (true) {function bar() {}}}\",\n+         \"function f() { f(); if (true) {var bar = function () {}}}\");\n+  }\n+\n+  private String inFunction(String code) {\n+    return \"(function(){\" + code + \"})\";\n+  }\n+\n+  private void testSameInFunction(String code) {\n+    testSame(inFunction(code));\n+  }\n+\n+  private void testInFunction(String code, String expected) {\n+    test(inFunction(code), inFunction(expected));\n+  }\n+\n+  public void testNormalizeFunctionDeclarations() throws Exception {\n+    testSame(\"function f() {}\");\n+    testSame(\"var f = function () {}\");\n+    test(\"var f = function f() {}\",\n+         \"var f = function f$$1() {}\");\n+    testSame(\"var f = function g() {}\");\n+    test(\"a:function g() {}\",\n+         \"a:{ var g = function () {} }\");\n+    test(\"{function g() {}}\",\n+         \"{var g = function () {}}\");\n+    testSame(\"if (function g() {}) {}\");\n+    test(\"if (true) {function g() {}}\",\n+         \"if (true) {var g = function () {}}\");\n+    test(\"if (true) {} else {function g() {}}\",\n+         \"if (true) {} else {var g = function () {}}\");\n+    testSame(\"switch (function g() {}) {}\");\n+    test(\"switch (1) { case 1: function g() {}}\",\n+         \"switch (1) { case 1: var g = function () {}}\");\n+\n+\n+    testSameInFunction(\"function f() {}\");\n+    testInFunction(\"f(); a:function g() {}\",\n+                   \"f(); a:{ var g = function () {} }\");\n+    testInFunction(\"f(); {function g() {}}\",\n+                   \"f(); {var g = function () {}}\");\n+    testInFunction(\"f(); if (true) {function g() {}}\",\n+                   \"f(); if (true) {var g = function () {}}\");\n+    testInFunction(\"if (true) {} else {function g() {}}\",\n+                   \"if (true) {} else {var g = function () {}}\");\n+  }\n+\n \n   public void testMakeLocalNamesUnique() {\n     if (!Normalize.MAKE_LOCAL_NAMES_UNIQUE) {\n     test(\"var e = 1; function f(){ try {} catch (e) {} var e = 2 }\",\n          \"var e = 1; function f(){ try {} catch (e$$2) {} var e$$1 = 2 }\");\n   }\n-  \n+\n+  public void testRemoveDuplicateVarDeclarations3() {\n+    test(\"var f = 1; function f(){}\",\n+         \"f = 1; function f(){}\");\n+    test(\"var f; function f(){}\",\n+         \"function f(){}\");\n+    test(\"if (a) { var f = 1; } else { function f(){} }\",\n+         \"if (a) { var f = 1; } else { f = function (){} }\");\n+\n+    test(\"function f(){} var f = 1;\",\n+         \"function f(){} f = 1;\");\n+    test(\"function f(){} var f;\",\n+         \"function f(){}\");\n+    test(\"if (a) { function f(){} } else { var f = 1; }\",\n+         \"if (a) { var f = function (){} } else { f = 1; }\");\n+\n+    // TODO(johnlenz): Do we need to handle this differently for \"third_party\"\n+    // mode? Remove the previous function definitions?\n+    test(\"function f(){} function f(){}\",\n+         \"function f(){} function f(){}\",\n+         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+    test(\"if (a) { function f(){} } else { function f(){} }\",\n+         \"if (a) { var f = function (){} } else { f = function (){} }\");\n+  }\n+\n   public void testRenamingConstants() {\n     test(\"var ACONST = 4;var b = ACONST;\",\n          \"var ACONST = 4; var b = ACONST;\");", "timestamp": 1269298534, "metainfo": ""}