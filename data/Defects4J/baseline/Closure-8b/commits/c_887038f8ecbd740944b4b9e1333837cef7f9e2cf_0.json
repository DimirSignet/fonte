{"sha": "887038f8ecbd740944b4b9e1333837cef7f9e2cf", "log": "SourceFile is OK  R=johnlenz DELTA=436  (107 added, 104 deleted, 225 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4320   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   private String legacyOutputCharset;\n \n   private boolean testMode = false;\n-  private Supplier<List<JSSourceFile>> externsSupplierForTesting = null;\n-  private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null;\n+  private Supplier<List<SourceFile>> externsSupplierForTesting = null;\n+  private Supplier<List<SourceFile>> inputsSupplierForTesting = null;\n   private Supplier<List<JSModule>> modulesSupplierForTesting = null;\n   private Function<Integer, Boolean> exitCodeReceiverForTesting = null;\n   private Map<String, String> rootRelativePathsMap = null;\n    */\n   @VisibleForTesting\n   void enableTestMode(\n-      Supplier<List<JSSourceFile>> externsSupplier,\n-      Supplier<List<JSSourceFile>> inputsSupplier,\n+      Supplier<List<SourceFile>> externsSupplier,\n+      Supplier<List<SourceFile>> inputsSupplier,\n       Supplier<List<JSModule>> modulesSupplier,\n       Function<Integer, Boolean> exitCodeReceiver) {\n     Preconditions.checkArgument(\n    *        stdin. If true, '-' is only allowed to appear once.\n    * @return An array of inputs\n    */\n-  protected List<JSSourceFile> createInputs(List<String> files,\n+  protected List<SourceFile> createInputs(List<String> files,\n       boolean allowStdIn) throws FlagUsageException, IOException {\n-    List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size());\n+    List<SourceFile> inputs = new ArrayList<SourceFile>(files.size());\n     boolean usingStdin = false;\n     for (String filename : files) {\n       if (!\"-\".equals(filename)) {\n-        JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset);\n+        SourceFile newFile = SourceFile.fromFile(filename, inputCharset);\n         inputs.add(newFile);\n       } else {\n         if (!allowStdIn) {\n           throw new FlagUsageException(\"Bundle files cannot be generated \" +\n               \"when the input is from stdin.\");\n         }\n-        inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in));\n+        inputs.add(SourceFile.fromInputStream(\"stdin\", System.in));\n         usingStdin = true;\n       }\n     }\n   /**\n    * Creates js source code inputs from a list of files.\n    */\n-  private List<JSSourceFile> createSourceInputs(List<String> files)\n+  private List<SourceFile> createSourceInputs(List<String> files)\n       throws FlagUsageException, IOException {\n     if (isInTestMode()) {\n       return inputsSupplierForTesting.get();\n   /**\n    * Creates js extern inputs from a list of files.\n    */\n-  private List<JSSourceFile> createExternInputs(List<String> files)\n+  private List<SourceFile> createExternInputs(List<String> files)\n       throws FlagUsageException, IOException {\n     if (files.isEmpty()) {\n-      return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\"));\n+      return ImmutableList.of(SourceFile.fromCode(\"/dev/null\", \"\"));\n     }\n     try {\n       return createInputs(files, false);\n       }\n       List<String> moduleJsFiles =\n           jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);\n-      for (JSSourceFile input : createInputs(moduleJsFiles, false)) {\n+      for (SourceFile input : createInputs(moduleJsFiles, false)) {\n         module.add(input);\n       }\n       nextJsFileIndex += numJsFiles;\n   protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n \n-    List<JSSourceFile> externs = createExterns();\n+    List<SourceFile> externs = createExterns();\n \n     compiler = createCompiler();\n     B options = createOptions();\n         result = compiler.compileModules(externs, modules, options);\n       }\n     } else {\n-      List<JSSourceFile> inputs = createSourceInputs(jsFiles);\n+      List<SourceFile> inputs = createSourceInputs(jsFiles);\n       if (config.skipNormalOutputs) {\n         compiler.init(externs, inputs, options);\n       } else {\n     return Charsets.UTF_8;\n   }\n \n-  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n+  protected List<SourceFile> createExterns() throws FlagUsageException,\n       IOException {\n     return isInTestMode() ? externsSupplierForTesting.get() :\n         createExternInputs(config.externs);\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n   }\n \n   @Override\n-  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n+  protected List<SourceFile> createExterns() throws FlagUsageException,\n       IOException {\n-    List<JSSourceFile> externs = super.createExterns();\n+    List<SourceFile> externs = super.createExterns();\n     if (flags.use_only_custom_externs || isInTestMode()) {\n       return externs;\n     } else {\n-      List<JSSourceFile> defaultExterns = getDefaultExterns();\n+      List<SourceFile> defaultExterns = getDefaultExterns();\n       defaultExterns.addAll(externs);\n       return defaultExterns;\n     }\n    * @return a mutable list\n    * @throws IOException\n    */\n-  public static List<JSSourceFile> getDefaultExterns() throws IOException {\n+  public static List<SourceFile> getDefaultExterns() throws IOException {\n     InputStream input = CommandLineRunner.class.getResourceAsStream(\n         \"/externs.zip\");\n     ZipInputStream zip = new ZipInputStream(input);\n-    Map<String, JSSourceFile> externsMap = Maps.newHashMap();\n+    Map<String, SourceFile> externsMap = Maps.newHashMap();\n     for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) {\n       BufferedInputStream entryStream = new BufferedInputStream(\n           new LimitInputStream(zip, entry.getSize()));\n       externsMap.put(entry.getName(),\n-          JSSourceFile.fromInputStream(\n+          SourceFile.fromInputStream(\n               // Give the files an odd prefix, so that they do not conflict\n               // with the user's files.\n               \"externs.zip//\" + entry.getName(),\n \n     // Order matters, so the resources must be added to the result list\n     // in the expected order.\n-    List<JSSourceFile> externs = Lists.newArrayList();\n+    List<SourceFile> externs = Lists.newArrayList();\n     for (String key : DEFAULT_EXTERNS_NAMES) {\n       externs.add(externsMap.get(key));\n     }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n+  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n+      List<T1> externs,\n+      List<T2> inputs,\n       CompilerOptions options) {\n     JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n-    for (JSSourceFile input : inputs) {\n+    for (SourceFile input : inputs) {\n       module.add(input);\n     }\n \n    */\n   public void init(JSSourceFile[] externs, JSModule[] modules,\n       CompilerOptions options) {\n-    initModules(Lists.<JSSourceFile>newArrayList(externs),\n+    initModules(Lists.<SourceFile>newArrayList(externs),\n          Lists.<JSModule>newArrayList(modules), options);\n   }\n \n    * Initializes the instance state needed for a compile job if the sources\n    * are in modules.\n    */\n-  public void initModules(\n-      List<JSSourceFile> externs, List<JSModule> modules,\n-      CompilerOptions options) {\n+  public <T extends SourceFile> void initModules(\n+      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n     initOptions(options);\n \n     checkFirstModule(modules);\n     }\n   }\n \n-  private List<CompilerInput> makeCompilerInput(\n-      List<JSSourceFile> files, boolean isExtern) {\n+  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n+      List<T> files, boolean isExtern) {\n     List<CompilerInput> inputs = Lists.newArrayList();\n-    for (JSSourceFile file : files) {\n+    for (T file : files) {\n       inputs.add(new CompilerInput(file, isExtern));\n     }\n     return inputs;\n   private static void fillEmptyModules(List<JSModule> modules) {\n     for (JSModule module : modules) {\n       if (module.getInputs().isEmpty()) {\n-        module.add(JSSourceFile.fromCode(\n+        module.add(SourceFile.fromCode(\n             createFillFileName(module.getName()), \"\"));\n       }\n     }\n   }\n \n   public Result compile(\n-      JSSourceFile extern, JSSourceFile input, CompilerOptions options) {\n-     return compile(extern, new JSSourceFile[] { input }, options);\n+      SourceFile extern, SourceFile input, CompilerOptions options) {\n+     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n   }\n \n   public Result compile(\n-      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n-     return compile(new JSSourceFile[] { extern }, input, options);\n+      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n+     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n   }\n \n   public Result compile(\n       JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n-     return compile(new JSSourceFile[] { extern }, modules, options);\n+     return compileModules(\n+         Lists.newArrayList(extern), Lists.newArrayList(modules), options);\n   }\n \n   /**\n   public Result compile(JSSourceFile[] externs,\n                         JSSourceFile[] inputs,\n                         CompilerOptions options) {\n-    return compile(Lists.<JSSourceFile>newArrayList(externs),\n-        Lists.<JSSourceFile>newArrayList(inputs),\n+    return compile(Lists.<SourceFile>newArrayList(externs),\n+        Lists.<SourceFile>newArrayList(inputs),\n         options);\n   }\n \n   /**\n    * Compiles a list of inputs.\n    */\n-  public Result compile(List<JSSourceFile> externs,\n-      List<JSSourceFile> inputs, CompilerOptions options) {\n+  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n+      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n     // The compile method should only be called once.\n     Preconditions.checkState(jsRoot == null);\n \n   public Result compile(JSSourceFile[] externs,\n                         JSModule[] modules,\n                         CompilerOptions options) {\n-    return compileModules(Lists.<JSSourceFile>newArrayList(externs),\n+    return compileModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules),\n         options);\n   }\n   /**\n    * Compiles a list of modules.\n    */\n-  public Result compileModules(List<JSSourceFile> externs,\n+  public <T extends SourceFile> Result compileModules(List<T> externs,\n       List<JSModule> modules, CompilerOptions options) {\n     // The compile method should only be called once.\n     Preconditions.checkState(jsRoot == null);\n     }\n   }\n \n-  public Node parse(JSSourceFile file) {\n+  public Node parse(SourceFile file) {\n     initCompilerOptionsIfTesting();\n     addToDebugLog(\"Parsing: \" + file.getName());\n     return new JsAst(file).getAstRoot(this);\n   @Override\n   Node parseSyntheticCode(String js) {\n     CompilerInput input = new CompilerInput(\n-        JSSourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n+        SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n     inputsById.put(input.getInputId(), input);\n     return input.getAstRoot(this);\n   }\n   @Override\n   Node parseSyntheticCode(String fileName, String js) {\n     initCompilerOptionsIfTesting();\n-    return parse(JSSourceFile.fromCode(fileName, js));\n+    return parse(SourceFile.fromCode(fileName, js));\n   }\n \n   @Override\n   Node parseTestCode(String js) {\n     initCompilerOptionsIfTesting();\n     CompilerInput input = new CompilerInput(\n-        JSSourceFile.fromCode(\" [testcode] \", js));\n+        SourceFile.fromCode(\" [testcode] \", js));\n     if (inputsById == null) {\n       inputsById = Maps.newHashMap();\n     }\n    * different output targets without having to perform checking multiple times.\n    *\n    * NOTE: This does not include all parts of the compiler's internal state. In\n-   * particular, JSSourceFiles and CompilerOptions are not recorded. In\n+   * particular, SourceFiles and CompilerOptions are not recorded. In\n    * order to recreate a Compiler instance from scratch, you would need to\n    * call {@code init} with the same arguments as in the initial creation before\n    * restoring intermediate state.\n     InputId inputId = ast.getInputId();\n     emptyScript.setInputId(inputId);\n     emptyScript.setStaticSourceFile(\n-        JSSourceFile.fromCode(inputId.getIdName(), \"\"));\n+        SourceFile.fromCode(inputId.getIdName(), \"\"));\n \n     processNewScript(ast, emptyScript);\n   }\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n     }\n   }\n \n-  public CompilerInput(JSSourceFile file) {\n+  public CompilerInput(SourceFile file) {\n     this(file, false);\n   }\n \n-  public CompilerInput(JSSourceFile file, boolean isExtern) {\n+  public CompilerInput(SourceFile file, boolean isExtern) {\n     this(new JsAst(file), isExtern);\n   }\n \n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n   }\n \n   /** Adds a source file input to this module. */\n-  public void add(JSSourceFile file) {\n+  public void add(SourceFile file) {\n     add(new CompilerInput(file));\n   }\n \n   /** Adds a source file input to this module. */\n-  public void addFirst(JSSourceFile file) {\n+  public void addFirst(SourceFile file) {\n     addFirst(new CompilerInput(file));\n   }\n \n--- a/src/com/google/javascript/jscomp/JSSourceFile.java\n+++ b/src/com/google/javascript/jscomp/JSSourceFile.java\n  * @author nicksantos@google.com (Nick Santos)\n  * @author moedinger@google.com (Andrew Moedinger)\n  */\n+// TODO(nicksantos): Delete this file.\n public class JSSourceFile extends SourceFile implements Serializable {\n   private static final long serialVersionUID = 1L;\n \n--- a/src/com/google/javascript/jscomp/JsMessageExtractor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageExtractor.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n   /**\n    * Extracts js messages from javascript code.\n    */\n-  public Collection<JsMessage> extractMessages(JSSourceFile... inputs)\n+  public Collection<JsMessage> extractMessages(SourceFile... inputs)\n       throws IOException {\n     return extractMessages(ImmutableList.copyOf(inputs));\n   }\n    * @throws RuntimeException if there are problems parsing the js code or the\n    *     js messages, or if two messages have the same key\n    */\n-  public Collection<JsMessage> extractMessages(\n-      Iterable<JSSourceFile> inputs) throws IOException {\n+  public <T extends SourceFile> Collection<JsMessage> extractMessages(\n+      Iterable<T> inputs) throws IOException {\n \n     Compiler compiler = new Compiler();\n     compiler.init(\n-        new JSSourceFile[] {},\n-        Iterables.toArray(inputs, JSSourceFile.class),\n+        ImmutableList.<SourceFile>of(),\n+        Lists.newArrayList(inputs),\n         new CompilerOptions());\n \n     ExtractMessagesVisitor extractCompilerPass =\n         new ExtractMessagesVisitor(compiler);\n-    for (JSSourceFile input : inputs) {\n+    for (SourceFile input : inputs) {\n       // Parse the js files individually, to prevent out-of-memory\n       // problems.\n       Node root = new JsAst(input).getAstRoot(compiler);\n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n import com.google.javascript.jscomp.CompilerOptions;\n import com.google.javascript.jscomp.DiagnosticGroup;\n import com.google.javascript.jscomp.DiagnosticGroups;\n-import com.google.javascript.jscomp.JSSourceFile;\n+import com.google.javascript.jscomp.SourceFile;\n import com.google.javascript.jscomp.MessageFormatter;\n import com.google.javascript.jscomp.Result;\n import com.google.javascript.jscomp.WarningLevel;\n     CompilerOptions options = createCompilerOptions();\n     Compiler compiler = createCompiler(options);\n \n-    JSSourceFile[] externs = findExternFiles();\n-    JSSourceFile[] sources = findSourceFiles();\n+    List<SourceFile> externs = findExternFiles();\n+    List<SourceFile> sources = findSourceFiles();\n \n     if (isStale() || forceRecompile) {\n-      log(\"Compiling \" + sources.length + \" file(s) with \" +\n-          externs.length + \" extern(s)\");\n+      log(\"Compiling \" + sources.size() + \" file(s) with \" +\n+          externs.size() + \" extern(s)\");\n \n       Result result = compiler.compile(externs, sources, options);\n       if (result.success) {\n     return compiler;\n   }\n \n-  private JSSourceFile[] findExternFiles() {\n-    List<JSSourceFile> files = Lists.newLinkedList();\n+  private List<SourceFile> findExternFiles() {\n+    List<SourceFile> files = Lists.newLinkedList();\n     if (!this.customExternsOnly) {\n       files.addAll(getDefaultExterns());\n     }\n       files.addAll(findJavaScriptFiles(list));\n     }\n \n-    return files.toArray(new JSSourceFile[files.size()]);\n-  }\n-\n-  private JSSourceFile[] findSourceFiles() {\n-    List<JSSourceFile> files = Lists.newLinkedList();\n+    return files;\n+  }\n+\n+  private List<SourceFile> findSourceFiles() {\n+    List<SourceFile> files = Lists.newLinkedList();\n \n     for (FileList list : this.sourceFileLists) {\n       files.addAll(findJavaScriptFiles(list));\n       files.addAll(findJavaScriptFiles(list));\n     }\n \n-    return files.toArray(new JSSourceFile[files.size()]);\n+    return files;\n   }\n \n   /**\n    * Translates an Ant file list into the file format that the compiler\n    * expects.\n    */\n-  private List<JSSourceFile> findJavaScriptFiles(FileList fileList) {\n-    List<JSSourceFile> files = Lists.newLinkedList();\n+  private List<SourceFile> findJavaScriptFiles(FileList fileList) {\n+    List<SourceFile> files = Lists.newLinkedList();\n     File baseDir = fileList.getDir(getProject());\n \n     for (String included : fileList.getFiles(getProject())) {\n-      files.add(JSSourceFile.fromFile(new File(baseDir, included),\n+      files.add(SourceFile.fromFile(new File(baseDir, included),\n           Charset.forName(encoding)));\n     }\n \n    * Translates an Ant Path into the file list format that the compiler\n    * expects.\n    */\n-  private List<JSSourceFile> findJavaScriptFiles(Path path) {\n-    List<JSSourceFile> files = Lists.newArrayList();\n+  private List<SourceFile> findJavaScriptFiles(Path path) {\n+    List<SourceFile> files = Lists.newArrayList();\n \n     for (String included : path.list()) {\n-      files.add(JSSourceFile.fromFile(new File(included),\n+      files.add(SourceFile.fromFile(new File(included),\n           Charset.forName(encoding)));\n     }\n \n    *\n    * Adapted from {@link CommandLineRunner}.\n    */\n-  private List<JSSourceFile> getDefaultExterns() {\n+  private List<SourceFile> getDefaultExterns() {\n     try {\n       return CommandLineRunner.getDefaultExterns();\n     } catch (IOException e) {\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   private List<String> args = Lists.newArrayList();\n \n   /** Externs for the test */\n-  private final List<JSSourceFile> DEFAULT_EXTERNS = ImmutableList.of(\n-    JSSourceFile.fromCode(\"externs\",\n+  private final List<SourceFile> DEFAULT_EXTERNS = ImmutableList.of(\n+    SourceFile.fromCode(\"externs\",\n         \"var arguments;\"\n         + \"/**\\n\"\n         + \" * @constructor\\n\"\n         + \"/** @nosideeffects */ function noSideEffects() {}\")\n   );\n \n-  private List<JSSourceFile> externs;\n+  private List<SourceFile> externs;\n \n   @Override\n   public void setUp() throws Exception {\n \n   public void testSyntheticExterns() {\n     externs = ImmutableList.of(\n-        JSSourceFile.fromCode(\"externs\", \"myVar.property;\"));\n+        SourceFile.fromCode(\"externs\", \"myVar.property;\"));\n     test(\"var theirVar = {}; var myVar = {}; var yourVar = {};\",\n          VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n \n   private Compiler compile(String[] original) {\n     CommandLineRunner runner = createCommandLineRunner(original);\n     assertTrue(runner.shouldRunCompiler());\n-    Supplier<List<JSSourceFile>> inputsSupplier = null;\n+    Supplier<List<SourceFile>> inputsSupplier = null;\n     Supplier<List<JSModule>> modulesSupplier = null;\n \n     if (useModules == ModulePattern.NONE) {\n-      List<JSSourceFile> inputs = Lists.newArrayList();\n+      List<SourceFile> inputs = Lists.newArrayList();\n       for (int i = 0; i < original.length; i++) {\n         inputs.add(JSSourceFile.fromCode(getFilename(i), original[i]));\n       }\n     }\n \n     runner.enableTestMode(\n-        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n+        Suppliers.<List<SourceFile>>ofInstance(externs),\n         inputsSupplier,\n         modulesSupplier,\n         new Function<Integer, Boolean>() {", "timestamp": 1330969404, "metainfo": ""}