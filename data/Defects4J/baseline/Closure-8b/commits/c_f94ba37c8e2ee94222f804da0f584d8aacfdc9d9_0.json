{"sha": "f94ba37c8e2ee94222f804da0f584d8aacfdc9d9", "log": "properly register warnings to fix  R=acleung DELTA=54  (10 added, 12 deleted, 32 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4682   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n \n import static com.google.common.base.Preconditions.checkState;\n \n+import com.google.common.base.Joiner;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.LinkedHashMultimap;\n  *\n  */\n class DisambiguateProperties<T> implements CompilerPass {\n+  // To prevent the logs from filling up, we cap the number of warnings\n+  // that we tell the user to fix per-property.\n+  private static final int MAX_INVALDIATION_WARNINGS_PER_PROPERTY = 10;\n+\n   private static final Logger logger = Logger.getLogger(\n       DisambiguateProperties.class.getName());\n \n   @Override\n   public void process(Node externs, Node root) {\n     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n-      addInvalidatingType(mis.typeA);\n-      addInvalidatingType(mis.typeB);\n-      recordInvalidationError(mis.typeA, mis.src);\n-      recordInvalidationError(mis.typeB, mis.src);\n+      addInvalidatingType(mis.typeA, mis.src);\n+      addInvalidatingType(mis.typeB, mis.src);\n     }\n \n     StaticScope<T> scope = typeSystem.getRootScope();\n     if (!t.isObject()) {\n       return;\n     }\n-    if (t.isUnionType()) {\n-      for (JSType alt : t.toMaybeUnionType().getAlternates()) {\n-        recordInvalidationError(alt, error);\n-      }\n-      return;\n-    }\n     if (invalidationMap != null) {\n       invalidationMap.put(t, error);\n     }\n   /**\n    * Invalidates the given type, so that no properties on it will be renamed.\n    */\n-  private void addInvalidatingType(JSType type) {\n+  private void addInvalidatingType(JSType type, JSError error) {\n     type = type.restrictByNotNullOrUndefined();\n     if (type.isUnionType()) {\n       for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n-        addInvalidatingType(alt);\n+        addInvalidatingType(alt, error);\n       }\n     } else if (type.isEnumElementType()) {\n-      addInvalidatingType(type.toMaybeEnumElementType().getPrimitiveType());\n+      addInvalidatingType(\n+          type.toMaybeEnumElementType().getPrimitiveType(), error);\n     } else {\n       typeSystem.addInvalidatingType(type);\n+      recordInvalidationError(type, error);\n       ObjectType objType = ObjectType.cast(type);\n       if (objType != null && objType.getImplicitPrototype() != null) {\n         typeSystem.addInvalidatingType(objType.getImplicitPrototype());\n+        recordInvalidationError(objType.getImplicitPrototype(), error);\n       }\n     }\n   }\n                     \" if you know it's type.\";\n               }\n             } else {\n-              StringBuilder sb = new StringBuilder();\n-              printErrorLocations(sb, jsType);\n-              if (sb.length() != 0) {\n-                suggestion = \"Consider fixing errors for the following types: \";\n-                suggestion += sb.toString();\n+              List<String> errors = Lists.newArrayList();\n+              printErrorLocations(errors, jsType);\n+              if (!errors.isEmpty()) {\n+                suggestion = \"Consider fixing errors for the following types:\\n\";\n+                suggestion += Joiner.on(\"\\n\").join(errors);\n               }\n             }\n           }\n       }\n     }\n \n-    private void printErrorLocations(StringBuilder sb, JSType t) {\n-      if (!t.isObject() || t.isAllType() || t.isUnionType()) {\n+    private void printErrorLocations(List<String> errors, JSType t) {\n+      if (!t.isObject() || t.isAllType()) {\n         return;\n       }\n+\n       if (t.isUnionType()) {\n         for (JSType alt : t.toMaybeUnionType().getAlternates()) {\n-          printErrorLocations(sb, alt);\n+          printErrorLocations(errors, alt);\n         }\n         return;\n       }\n+\n       for (JSError error : invalidationMap.get(t)) {\n-        if(sb.length() != 0) {\n-          sb.append(\", \");\n-        }\n-        sb.append(t.toString());\n-        sb.append(\" at \");\n-        sb.append(error.sourceName);\n-        sb.append(\":\");\n-        sb.append(error.lineNumber);\n+        if (errors.size() > MAX_INVALDIATION_WARNINGS_PER_PROPERTY) {\n+          return;\n+        }\n+\n+        errors.add(\n+            t.toString() + \" at \" + error.sourceName + \":\" + error.lineNumber);\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n   }\n \n   public void testErrorOnProtectedProperty() {\n-    String js = \"function addSingletonGetter(foo) { foo.foobar = 'a'; };\";\n-\n-    Compiler compiler = new Compiler();\n-    CompilerOptions options = new CompilerOptions();\n-    compiler.init(ImmutableList.of(SourceFile.fromCode(\"externs\", \"\")),\n-        ImmutableList.of(SourceFile.fromCode(\"testcode\", js)),\n-        options);\n-\n-    Node root = compiler.parseInputs();\n-    Node externsRoot = root.getFirstChild();\n-    Node mainRoot = externsRoot.getNext();\n-    getProcessor(compiler).process(externsRoot, mainRoot);\n-\n-    assertEquals(1, compiler.getErrors().length);\n-    assertTrue(compiler.getErrors()[0].toString().contains(\"foobar\"));\n+    test(\"function addSingletonGetter(foo) { foo.foobar = 'a'; };\", null,\n+         DisambiguateProperties.Warnings.INVALIDATION);\n+    assertTrue(getLastCompiler().getErrors()[0].toString().contains(\"foobar\"));\n+  }\n+\n+  public void testMismatchForbiddenInvalidation() {\n+    test(\"/** @constructor */ function F() {}\" +\n+         \"/** @type {number} */ F.prototype.foobar = 3;\" +\n+         \"/** @return {number} */ function g() { return new F(); }\",\n+         null,\n+         DisambiguateProperties.Warnings.INVALIDATION);\n+    assertTrue(getLastCompiler().getErrors()[0].toString()\n+        .contains(\"Consider fixing errors\"));\n   }\n \n   public void runFindHighestTypeInChain() {", "timestamp": 1336070123, "metainfo": ""}