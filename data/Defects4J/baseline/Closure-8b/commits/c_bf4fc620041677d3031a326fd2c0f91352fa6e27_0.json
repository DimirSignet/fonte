{"sha": "bf4fc620041677d3031a326fd2c0f91352fa6e27", "log": "Workaround for Opera bug.  R=johnlenz DELTA=335  (328 added, 5 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1226   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   String replaceStringsPlaceholderToken;\n   // A list of strings that should not be used as replacements\n   Set<String> replaceStringsReservedStrings;\n+\n+  // Fixes open source issue: 390\n+  boolean operaCompoundAssignFix;\n \n   //--------------------------------\n   // Output options\n \n     // Debugging\n     aliasHandler = NULL_ALIAS_TRANSFORMATION_HANDLER;\n+\n+    operaCompoundAssignFix = true;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(nameUnmappedAnonymousFunctions);\n     }\n \n+    if (options.operaCompoundAssignFix) {\n+      passes.add(operaCompoundAssignFix);\n+    }\n+\n     // Safety check\n     if (options.checkSymbols) {\n       passes.add(sanityCheckVars);\n           anonymousFunctionNameMap = naf.getFunctionMap();\n         }\n       };\n+    }\n+  };\n+\n+  private final PassFactory operaCompoundAssignFix =\n+      new PassFactory(\"operaCompoundAssignFix\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new OperaCompoundAssignFix(compiler);\n     }\n   };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/OperaCompoundAssignFix.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Deque;\n+import java.util.List;\n+\n+/**\n+ * Temp fix to decompose nested assignment bug in Opera.\n+ *\n+ * See open source issue: 390\n+ *\n+ *\n+ * The conditions for which this Opera-specific bug will hit is\n+ *\n+ * v = rhs\n+ *\n+ * where 'rhs' contains a compound assignment of the form  a[i] or obj.p _and_\n+ * 'v' is also used in 'rhs'. i.e., for the above example,\n+ *\n+ * z = bar[z] = bar[z] || [];\n+ *\n+ * or\n+ *\n+ * x = foo.bar += x.baz;\n+ *\n+ * Opera 11.10 final will have the fix included, but if emitting constructs like\n+ * the above is common and can be readily avoided, that'd be very helpful. More\n+ * than happy to supply extra information & work through the details to make\n+ * this happen, if needed.\n+ * --sof / sof@opera.com\n+ *\n+ */\n+class OperaCompoundAssignFix extends AbstractPostOrderCallback\n+    implements CompilerPass, ScopedCallback {\n+  private AbstractCompiler compiler;\n+  private final Deque<VariableNameGenerator> names;\n+\n+  @Override\n+  public void enterScope(NodeTraversal t) {\n+    names.push(new VariableNameGenerator(t.getScope()));\n+  }\n+\n+  @Override\n+  public void exitScope(NodeTraversal t) {\n+    names.pop();\n+  }\n+\n+  OperaCompoundAssignFix(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+    names = Lists.newLinkedList();\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    List<Node> code = Lists.newArrayList(externs, root);\n+    NodeTraversal.traverseRoots(compiler, code, this);\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (!NodeUtil.isName(n)) {\n+      return;\n+    }\n+\n+    if (!NodeUtil.isGet(parent)) {\n+      return;\n+    }\n+\n+    boolean nested = false;\n+    boolean reassign = false;\n+    Node lastAssign = null;\n+    Node prevParent = n;\n+\n+    while (!(NodeUtil.isExpressionNode(parent) ||\n+             NodeUtil.isStatementBlock(parent))) {\n+      if (NodeUtil.isAssign(parent) &&\n+          NodeUtil.isName(parent.getFirstChild()) &&\n+          parent.getFirstChild().getString().equals(n.getString()) &&\n+          nested) {\n+        reassign = true;\n+        break;\n+      } else if (NodeUtil.isAssignmentOp(parent) &&\n+          parent.getLastChild() == prevParent) {\n+        if (lastAssign == null) {\n+          nested = true;\n+        }\n+        lastAssign = parent;\n+      }\n+      prevParent = parent;\n+      parent = parent.getParent();\n+    }\n+\n+    if (!(reassign && nested)) {\n+      return;\n+    }\n+\n+    applyWorkAround(parent, t);\n+  }\n+\n+  private void applyWorkAround(Node assign, NodeTraversal t) {\n+//System.out.println(\"applyWorkAround: \" + assign.toStringTree());\n+    Preconditions.checkArgument(NodeUtil.isAssign(assign));\n+    Node parent = assign.getParent();\n+    Node comma = new Node(Token.COMMA);\n+    comma.copyInformationFrom(assign);\n+    parent.replaceChild(assign, comma);\n+\n+    String newName = names.peek().getNextNewName();\n+    Node newAssign = new Node(Token.ASSIGN,\n+        Node.newString(Token.NAME, newName));\n+    newAssign.copyInformationFromForTree(assign);\n+    newAssign.addChildToBack(assign.getLastChild().detachFromParent());\n+    comma.addChildrenToBack(newAssign);\n+    assign.addChildrenToBack(\n+        Node.newString(Token.NAME, newName).copyInformationFrom(assign));\n+    comma.addChildrenToBack(assign);\n+\n+    Node root = t.getScopeRoot();\n+    Node var = new Node(Token.VAR, Node.newString(Token.NAME, newName));\n+    var.copyInformationFromForTree(assign);\n+\n+    if (NodeUtil.isStatementBlock(root)) {\n+      root = compiler.getNodeForCodeInsertion(t.getModule());\n+      root.addChildrenToFront(var);\n+    } else {\n+      root.getLastChild().addChildrenToFront(var);\n+    }\n+    compiler.reportCodeChange();\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/VariableNameGenerator.java\n+++ b/src/com/google/javascript/jscomp/VariableNameGenerator.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.Scope.Var;\n \n-import java.util.Iterator;\n import java.util.Set;\n \n /**\n  */\n class VariableNameGenerator {\n   private final NameGenerator names;\n+  private final Scope scope;\n   VariableNameGenerator(Scope scope) {\n+    this.scope = scope;\n     Set<String> usedNames = Sets.newHashSet();\n-    for (Iterator<Var> i = scope.getVars(); i.hasNext();) {\n-      usedNames.add(i.next().getName());\n-    }\n     names = new NameGenerator(usedNames, \"\", null);\n   }\n \n-  String getNameNewName() {\n-    return names.generateNextName();\n+  String getNextNewName() {\n+    String name = null;\n+    while (scope.isDeclared(name = names.generateNextName(), true)) {}\n+    return name;\n   }\n }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/OperaCompoundAssignFixTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link OperaCompoundAssignFix}\n+ *\n+ */\n+public class OperaCompoundAssignFixTest extends CompilerTestCase {\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new OperaCompoundAssignFix(compiler);\n+  }\n+\n+  public void testNoFix() {\n+    testSame(\"x = x\");\n+    testSame(\"x = x = x\");\n+    testSame(\"x = x = x(x)\");\n+  }\n+\n+  public void testFix() {\n+    test(\"       var a,b,x; x = a[x] = b[x]\",\n+         \"var c; var a,b,x; c = a[x] = b[x], x = c\");\n+    test(\"       var a,b,x; x = a[1] = x.b\",\n+         \"var c; var a,b,x; c = a[1] = x.b, x = c\");\n+  }\n+\n+  public void testCombinedFix() {\n+    test(\"       var a,b,c, x; x = a[x] = b[x] = c[x]\",\n+         \"var d; var a,b,c, x; d = a[x] = b[x] = c[x], x = d\");\n+    test(\"       var a,b,c, x; x = a[1] = b[1] = x[1]\",\n+         \"var d; var a,b,c, x; d = a[1] = b[1] = x[1], x = d\");\n+  }\n+\n+  public void testNestedFix1() {\n+    test(\"            var a,b,c,x,y;y= x = a[x] = b[y] = c[x];\",\n+         \"var e;var d;var a,b,c,x,y;d=(e = a[x] = b[y] = c[x], x=e), y=d;\");\n+  }\n+\n+  public void testNestedFix2() {\n+    test(\"            var a,b,c,x,y;y=a[x]= x=a[x]=b[y]=c[x];\",\n+         \"var e;var d;var a,b,c,x,y;d=a[x]=(e=a[x]=b[y]=c[x], x=e), y=d;\");\n+  }\n+\n+  public void testJqueryTest() {\n+    test(\"       z = bar[z] = bar[z] || [];\",\n+         \"var a; a = bar[z] = bar[z] || [], z=a\");\n+  }\n+\n+  public void testNoCrossingScope() {\n+    testSame(\"x = function(x) { return a[x] + b[x] }\");\n+  }\n+\n+  public void testForLoops() {\n+    test(\"       var a,b,x;for(x = a[x] = b[x];;)        {}\",\n+         \"var c; var a,b,x;for(c = a[x] = b[x], x = c;;) {}\");\n+  }\n+\n+  public void testForInLoops() {\n+    test(\"       var a,b,x;for(var j in  x = a[x] = b[x])         {}\",\n+         \"var c; var a,b,x;for(var j in (c = a[x] = b[x], x = c)) {}\");\n+  }\n+\n+  public void testUsedInCondition() {\n+    test(\"       var a,b,x;if(x = a[x] = b[x]) {}\",\n+         \"var c; var a,b,x;if((c = a[x] = b[x], x = c)) {}\");\n+  }\n+\n+  public void testUsedInExpression() {\n+    test(\"       var a,b,x; FOO( x = a[x] = b[x]);\",\n+         \"var c; var a,b,x; FOO((c = a[x] = b[x], x = c));\");\n+  }\n+\n+  public void testLocalScope() {\n+    test(\"function FOO() {       var a,b,x; x = a[x] = b[x]}\",\n+         \"function FOO() {var c; var a,b,x; c = a[x] = b[x], x = c}\");\n+    test(\"function FOO() {       var a,b,x; x = a[1] = x.b}\",\n+         \"function FOO() {var c; var a,b,x; c = a[1] = x.b, x = c}\");\n+  }\n+\n+  public void testProperNames1() {\n+    test(\"var a,b,c,d,x;\" +\n+         \"function f() {\" +\n+         \"  function g() { return a }\" +\n+         \"  x = a[x] = b[x];\" +\n+         \"  return g();\" +\n+         \"}\",\n+\n+         \"var a,b,c,d,x;\" +\n+         \"function f() {\" +\n+         \"  var e;\" +\n+         \"  function g() { return a }\" +\n+         \"  e = a[x] = b[x], x = e;\" +\n+         \"  return g();\" +\n+         \"}\");\n+  }\n+\n+  public void testProperNames2() {\n+    test(\"var a;\",\n+         \"function f() {\" +\n+         \" var b,x; x = a[x] = b[x];\" +\n+         \" return g();\" +\n+         \"}\",\n+\n+         \"function f() {\" +\n+         \" var c;\" +\n+         \" var b,x; c = a[x] = b[x], x = c;\" +\n+         \" return g();\" +\n+         \"}\", null, null);\n+  }\n+\n+  public void testSaveShadowing() {\n+    // We could reuse any new temps in an inner scope.\n+    test(\"       var a,b,x; x = a[x] = b[x];\" +\n+         \"function FOO() {       var a,b,x; x = a[x] = b[x]}\",\n+\n+         \"var c; var a,b,x; c = a[x] = b[x], x = c;\" +\n+         \"function FOO() {var c; var a,b,x; c = a[x] = b[x], x = c}\");\n+\n+  }\n+}", "timestamp": 1301694769, "metainfo": ""}