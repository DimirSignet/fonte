{"sha": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4", "log": "Remove circular dependency between error-reporting and the rest of the compiler. (Nick) R=alan DELTA=152  (27 added, 28 deleted, 97 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n \n         if (!deprecationInfo.isEmpty()) {\n             compiler.report(\n-                JSError.make(t, n, DEPRECATED_CLASS_REASON,\n-                             type.toString(), deprecationInfo));\n+                t.makeError(n, DEPRECATED_CLASS_REASON,\n+                    type.toString(), deprecationInfo));\n         } else {\n           compiler.report(\n-              JSError.make(t, n, DEPRECATED_CLASS, type.toString()));\n+              t.makeError(n, DEPRECATED_CLASS, type.toString()));\n         }\n       }\n     }\n \n       if (docInfo.getDeprecationReason() != null) {\n         compiler.report(\n-            JSError.make(t, n, DEPRECATED_NAME_REASON, n.getString(),\n-                         docInfo.getDeprecationReason()));\n+            t.makeError(n, DEPRECATED_NAME_REASON, n.getString(),\n+                docInfo.getDeprecationReason()));\n       } else {\n         compiler.report(\n-            JSError.make(t, n, DEPRECATED_NAME, n.getString()));\n+            t.makeError(n, DEPRECATED_NAME, n.getString()));\n       }\n     }\n   }\n \n         if (!deprecationInfo.isEmpty()) {\n           compiler.report(\n-              JSError.make(t, n, DEPRECATED_PROP_REASON, propertyName,\n+              t.makeError(n, DEPRECATED_PROP_REASON, propertyName,\n                   validator.getReadableJSTypeName(n.getFirstChild(), true),\n                   deprecationInfo));\n         } else {\n           compiler.report(\n-              JSError.make(t, n, DEPRECATED_PROP, propertyName,\n+              t.makeError(n, DEPRECATED_PROP, propertyName,\n                   validator.getReadableJSTypeName(n.getFirstChild(), true)));\n         }\n       }\n           }\n \n           compiler.report(\n-              JSError.make(t, name, BAD_PRIVATE_GLOBAL_ACCESS,\n+              t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n                   name.getString(), docInfo.getSourceName()));\n         }\n       }\n         // visibility of the original property.\n         if (visibility == Visibility.PRIVATE && !sameInput) {\n           compiler.report(\n-              JSError.make(t, getprop, PRIVATE_OVERRIDE,\n+              t.makeError(getprop, PRIVATE_OVERRIDE,\n                   objectType.toString()));\n         } else if (overridingVisibility != Visibility.INHERITED &&\n             overridingVisibility != visibility) {\n           compiler.report(\n-              JSError.make(t, getprop, VISIBILITY_MISMATCH,\n+              t.makeError(getprop, VISIBILITY_MISMATCH,\n                   visibility.name(), objectType.toString(),\n                   overridingVisibility.name()));\n         }\n           // private access is not allowed outside the file from a different\n           // enclosing class.\n           compiler.report(\n-              JSError.make(t, getprop,\n+              t.makeError(getprop,\n                   BAD_PRIVATE_PROPERTY_ACCESS,\n                   propertyName,\n                   validator.getReadableJSTypeName(\n           // The first two have already been checked for.\n           if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n             compiler.report(\n-                JSError.make(t, getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n+                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                     propertyName,\n                     validator.getReadableJSTypeName(\n                         getprop.getFirstChild(), true)));\n--- a/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n+++ b/src/com/google/javascript/jscomp/CheckAccidentalSemicolon.java\n         // children are considered OK.\n         if (child.wasEmptyNode()) {\n           t.getCompiler().report(\n-              JSError.make(t, n, level, SUSPICIOUS_SEMICOLON));\n+              t.makeError(n, level, SUSPICIOUS_SEMICOLON));\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n \n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (assignLhsChild != null && n.getType() == Token.THIS) {\n-      compiler.report(JSError.make(t, n, level, GLOBAL_THIS));\n+      compiler.report(t.makeError(n, level, GLOBAL_THIS));\n     }\n     if (n == assignLhsChild) {\n       assignLhsChild = null;\n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n         if (insideAssignmentToIdConstant(n, parent)) {\n           continue;\n         }\n-        compiler.report(JSError.make(t, n, level, MISSING_GETCSSNAME,\n-                                     blacklist.group()));\n+        compiler.report(t.makeError(n, level, MISSING_GETCSSNAME,\n+                blacklist.group()));\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n \n     if (!test.allPathsSatisfyPredicate()) {\n       compiler.report(\n-          JSError.make(t, t.getScopeRoot(), level, MISSING_RETURN_STATEMENT));\n+          t.makeError(t.getScopeRoot(), level, MISSING_RETURN_STATEMENT));\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/CheckProvides.java\n+++ b/src/com/google/javascript/jscomp/CheckProvides.java\n       for (String ctorName : ctors.keySet()) {\n         if (!provides.containsKey(ctorName)) {\n           compiler.report(\n-              JSError.make(t, ctors.get(ctorName), checkLevel,\n-                           MISSING_PROVIDE_WARNING, ctorName));\n+              t.makeError(ctors.get(ctorName), checkLevel,\n+                  MISSING_PROVIDE_WARNING, ctorName));\n         }\n       }\n       provides.clear();\n--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n             && (requires == null || !requires.contains(className))\n             && !classNames.contains(className)) {\n           compiler.report(\n-              JSError.make(t, node, level, MISSING_REQUIRE_WARNING, className));\n+              t.makeError(node, level, MISSING_REQUIRE_WARNING, className));\n           classNames.add(className);\n         }\n       }\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n       }\n \n       t.getCompiler().report(\n-          JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n+          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n+++ b/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n       if (n.getLineno() != -1 &&\n           // Allow spurious semi-colons and spurious breaks.\n           n.getType() != Token.EMPTY && n.getType() != Token.BREAK) {\n-        compiler.report(JSError.make(t, n, level, UNREACHABLE_CODE));\n+        compiler.report(t.makeError(n, level, UNREACHABLE_CODE));\n         // From now on, we are going to assume the user fixed the error and not\n         // give more warning related to code section reachable from this node.\n         new GraphReachability<Node, ControlFlowGraph.Branch>(\n--- a/src/com/google/javascript/jscomp/ConstCheck.java\n+++ b/src/com/google/javascript/jscomp/ConstCheck.java\n    * Reports a reassigned constant error.\n    */\n   void reportError(NodeTraversal t, Node n, String name) {\n-    compiler.report(JSError.make(t, n, CONST_REASSIGNED_VALUE_ERROR, name));\n+    compiler.report(t.makeError(n, CONST_REASSIGNED_VALUE_ERROR, name));\n   }\n }\n--- a/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n+++ b/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n       }\n \n       if (startMarkerStack.isEmpty()) {\n-        compiler.report(JSError.make(t, n, UNMATCHED_END_MARKER,\n+        compiler.report(t.makeError(n, UNMATCHED_END_MARKER,\n             startMarkerName, endMarkerName));\n         return;\n       }\n         if (type == Token.SCRIPT || type == Token.BLOCK) {\n           if (ancestor != startMarker.ancestorBlock) {\n             // The end marker isn't in the same block as the start marker.\n-            compiler.report(JSError.make(t, n, UNMATCHED_END_MARKER,\n+            compiler.report(t.makeError(n, UNMATCHED_END_MARKER,\n                 startMarkerName, endMarkerName));\n             return;\n           }\n--- a/src/com/google/javascript/jscomp/FindExportableNodes.java\n+++ b/src/com/google/javascript/jscomp/FindExportableNodes.java\n       if (export != null) {\n         exports.put(export, context);\n       } else {\n-        compiler.report(JSError.make(t, n, NON_GLOBAL_ERROR));\n+        compiler.report(t.makeError(n, NON_GLOBAL_ERROR));\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n   }\n \n   private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) {\n-    t.getCompiler().report(JSError.make(t, n, diagnostic, n.toString()));\n+    t.getCompiler().report(t.makeError(n, diagnostic, n.toString()));\n   }\n \n   /**\n       double index = right.getDouble();\n       int intIndex = (int) index;\n       if (intIndex != index) {\n-        t.getCompiler().report(JSError.make(t, right,\n+        t.getCompiler().report(t.makeError(right,\n             INVALID_GETELEM_INDEX_ERROR, String.valueOf(index)));\n         return;\n       }\n \n       if (intIndex < 0) {\n-        t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR,\n+        t.getCompiler().report(t.makeError(n, INDEX_OUT_OF_BOUNDS_ERROR,\n             String.valueOf(intIndex)));\n         return;\n       }\n       }\n \n       if (elem == null) {\n-        t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR,\n+        t.getCompiler().report(t.makeError(n, INDEX_OUT_OF_BOUNDS_ERROR,\n             String.valueOf(intIndex)));\n         return;\n       }\n--- a/src/com/google/javascript/jscomp/JSError.java\n+++ b/src/com/google/javascript/jscomp/JSError.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.CheckLevel;\n-import com.google.javascript.jscomp.NodeTraversal;\n import com.google.javascript.rhino.Node;\n \n /**\n \n     return new JSError(sourceName, n.getLineno(), n.getCharno(), type, level,\n         arguments);\n-  }\n-\n-  /**\n-   * Creates a JSError during NodeTraversal.\n-   *\n-   * @param t Determines source file name containing current script\n-   * @param n Determines the line and char position within the source file name\n-   * @param type The DiagnosticType\n-   * @param arguments Arguments to be incorporated into the message\n-   */\n-  public static JSError make(NodeTraversal t, Node n,\n-      CheckLevel level, DiagnosticType type, String... arguments) {\n-    return new JSError(t.getSourceName(), n.getLineno(), n.getCharno(), type,\n-        level, arguments);\n-  }\n-\n-  /**\n-   * Creates a JSError during NodeTraversal.\n-   *\n-   * @param t Determines source file name containing current script\n-   * @param n Determines the line and char position within the source file name\n-   * @param type The DiagnosticType\n-   * @param arguments Arguments to be incorporated into the message\n-   */\n-  public static JSError make(NodeTraversal t, Node n,\n-                             DiagnosticType type, String... arguments) {\n-    return new JSError(t.getSourceName(), n, type, arguments);\n   }\n \n   //\n--- a/src/com/google/javascript/jscomp/LineNumberCheck.java\n+++ b/src/com/google/javascript/jscomp/LineNumberCheck.java\n         // The tree version of the node is really the best diagnostic\n         // info we have to offer here.\n         compiler.report(\n-            JSError.make(t, n, MISSING_LINE_INFO,\n+            t.makeError(n, MISSING_LINE_INFO,\n                 n.toStringTree()));\n       }\n     }\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n     String name = (String) n.getProp(Node.SOURCENAME_PROP);\n     return name == null ? \"\" : name;\n   }\n+\n+  /**\n+   * Creates a JSError during NodeTraversal.\n+   *\n+   * @param n Determines the line and char position within the source file name\n+   * @param type The DiagnosticType\n+   * @param arguments Arguments to be incorporated into the message\n+   */\n+  public JSError makeError(Node n, CheckLevel level, DiagnosticType type,\n+      String... arguments) {\n+    return JSError.make(getSourceName(), n.getLineno(), n.getCharno(), level,\n+        type, arguments);\n+  }\n+\n+  /**\n+   * Creates a JSError during NodeTraversal.\n+   *\n+   * @param n Determines the line and char position within the source file name\n+   * @param type The DiagnosticType\n+   * @param arguments Arguments to be incorporated into the message\n+   */\n+  public JSError makeError(Node n, DiagnosticType type, String... arguments) {\n+    return JSError.make(getSourceName(), n, type, arguments);\n+  }\n }\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n       }\n \n       if (n.getChildCount() != 3) {\n-        compiler.report(JSError.make(t, n, INVALID_NUM_ARGUMENTS_ERROR,\n+        compiler.report(t.makeError(n, INVALID_NUM_ARGUMENTS_ERROR,\n             \"\" + n.getChildCount()));\n         return;\n       }\n \n       Node firstArgument = objectName.getNext();\n       if (!firstArgument.isQualifiedName()) {\n-        compiler.report(JSError.make(t, firstArgument,\n+        compiler.report(t.makeError(firstArgument,\n             QUALIFIED_NAME_EXPECTED_ERROR,\n             Token.name(firstArgument.getType())));\n         return;\n \n       Node secondArgument = firstArgument.getNext();\n       if (secondArgument.getType() != Token.STRING) {\n-        compiler.report(JSError.make(t, secondArgument,\n+        compiler.report(t.makeError(secondArgument,\n             STRING_LITERAL_EXPECTED_ERROR,\n             Token.name(secondArgument.getType())));\n         return;\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n           String name = n.getFirstChild().getString();\n           ProvidedName pn = providedNames.get(name);\n           if (pn != null) {\n-            compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n+            compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n           }\n         }\n         break;\n             !compiler.getModuleGraph().dependsOn(module,\n                 provided.firstModule)) {\n           compiler.report(\n-              JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns,\n+              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                   provided.firstModule.getName(),\n                   module.getName()));\n         }\n           previouslyProvided.addProvide(parent, t.getModule(), true);\n         } else {\n           compiler.report(\n-              JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n+              t.makeError(n, DUPLICATE_NAMESPACE_ERROR, ns));\n         }\n       } else {\n         registerAnyProvidedPrefixes(ns, parent, t.getModule());\n   /** Reports an incorrect use of super-method calling. */\n   private void reportBadBaseClassUse(\n       NodeTraversal t, Node n, String extraMessage) {\n-    compiler.report(JSError.make(t, n, BASE_CLASS_ERROR, extraMessage));\n+    compiler.report(t.makeError(n, BASE_CLASS_ERROR, extraMessage));\n   }\n \n   /**\n         if (key.getType() != Token.STRING\n             || value == null\n             || value.getType() != Token.STRING) {\n-          error = JSError.make(t, n,\n+          error = t.makeError(n,\n               NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR);\n         }\n         if (error != null) {\n \n     for (String part : arg.getString().split(\"\\\\.\")) {\n       if (!NodeUtil.isValidPropertyName(part)) {\n-        compiler.report(JSError.make(t, arg, INVALID_PROVIDE_ERROR, part));\n+        compiler.report(t.makeError(arg, INVALID_PROVIDE_ERROR, part));\n         return false;\n       }\n     }\n     }\n     if (diagnostic != null) {\n       compiler.report(\n-          JSError.make(t, methodName,\n-                       diagnostic, methodName.getQualifiedName()));\n+          t.makeError(methodName,\n+              diagnostic, methodName.getQualifiedName()));\n       return false;\n     }\n     return true;\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n               // For defines, it's an error if a simple name is assigned\n               // before it's declared\n               compiler.report(\n-                  JSError.make(t, val, INVALID_DEFINE_INIT_ERROR, fullName));\n+                  t.makeError(val, INVALID_DEFINE_INIT_ERROR, fullName));\n             } else if (processDefineAssignment(t, fullName, val, valParent)) {\n               // remove the assignment so that the variable is still declared,\n               // but no longer assigned to a value, e.g.,\n           n.getJSDocInfo() != null && n.getJSDocInfo().isDefine()) {\n         // warn about @define annotations in local scopes\n         compiler.report(\n-            JSError.make(t, n, NON_GLOBAL_DEFINE_INIT_ERROR, \"\"));\n+            t.makeError(n, NON_GLOBAL_DEFINE_INIT_ERROR, \"\"));\n       }\n \n       if (lvalueToRemoveLater == n) {\n       if (value == null || !NodeUtil.isValidDefineValue(value,\n                                                         allDefines.keySet())) {\n         compiler.report(\n-            JSError.make(t, value, INVALID_DEFINE_INIT_ERROR, name));\n+            t.makeError(value, INVALID_DEFINE_INIT_ERROR, name));\n       } else if (!isAssignAllowed()) {\n         compiler.report(\n-            JSError.make(t, valueParent, NON_GLOBAL_DEFINE_INIT_ERROR, name));\n+            t.makeError(valueParent, NON_GLOBAL_DEFINE_INIT_ERROR, name));\n       } else {\n         DefineInfo info = allDefines.get(name);\n         if (info == null) {\n           // The define was already initialized, and this is an unsafe\n           // re-assignment.\n           compiler.report(\n-              JSError.make(t, valueParent, DEFINE_NOT_ASSIGNABLE_ERROR,\n-                           name, info.getReasonWhyNotAssignable()));\n+              t.makeError(valueParent, DEFINE_NOT_ASSIGNABLE_ERROR,\n+                  name, info.getReasonWhyNotAssignable()));\n         }\n       }\n \n--- a/src/com/google/javascript/jscomp/ReplaceCssNames.java\n+++ b/src/com/google/javascript/jscomp/ReplaceCssNames.java\n               parent.replaceChild(n, first);\n               compiler.reportCodeChange();\n             } else {\n-              compiler.report(JSError.make(t, n, STRING_LITERAL_EXPECTED_ERROR,\n+              compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR,\n                   Token.name(first.getType())));\n             }\n             break;\n             Node second = first.getNext();\n \n             if (first.getType() == Token.STRING) {\n-              compiler.report(JSError.make(\n-                  t, n, UNEXPECTED_STRING_LITERAL_ERROR,\n+              compiler.report(t.makeError(\n+                  n, UNEXPECTED_STRING_LITERAL_ERROR,\n                   first.getString(), second.getString()));\n \n             } else if (second.getType() == Token.STRING) {\n               compiler.reportCodeChange();\n \n             } else {\n-              compiler.report(JSError.make(t, n, STRING_LITERAL_EXPECTED_ERROR,\n+              compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR,\n                   Token.name(second.getType())));\n             }\n             break;\n \n           default:\n-            compiler.report(JSError.make(\n-                t, n, INVALID_NUM_ARGUMENTS_ERROR, String.valueOf(count)));\n+            compiler.report(t.makeError(\n+                n, INVALID_NUM_ARGUMENTS_ERROR, String.valueOf(count)));\n         }\n       }\n     }\n             String replacement = symbolMap.get(parts[i]);\n             if (replacement == null) {\n               // If we can't encode all parts, don't encode any of it.\n-              compiler.report(JSError.make(\n-                  t, n, UNKNOWN_SYMBOL_WARNING, parts[i], n.getString()));\n+              compiler.report(t.makeError(\n+                  n, UNKNOWN_SYMBOL_WARNING, parts[i], n.getString()));\n               return;\n             }\n             parts[i] = replacement;\n--- a/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n+++ b/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n \n       if (!t.inGlobalScope()) {\n         // Warn about calls not in the global scope.\n-        compiler.report(JSError.make(t, n, NON_GLOBAL_ID_GENERATOR_CALL));\n+        compiler.report(t.makeError(n, NON_GLOBAL_ID_GENERATOR_CALL));\n         return;\n       }\n \n       for (Node ancestor : n.getAncestors()) {\n         if (NodeUtil.isControlStructure(ancestor)) {\n           // Warn about conditional calls.\n-          compiler.report(JSError.make(t, n, CONDITIONAL_ID_GENERATOR_CALL));\n+          compiler.report(t.makeError(n, CONDITIONAL_ID_GENERATOR_CALL));\n           return;\n         }\n       }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       if (reportUnknownTypes.isOn()) {\n         String unresolvedReference = getUnresolvedReference(type);\n         if (unresolvedReference != null) {\n-          compiler.report(JSError.make(t, n, reportUnknownTypes,\n-                                       UNRESOLVED_TYPE, unresolvedReference));\n+          compiler.report(\n+              t.makeError(n, reportUnknownTypes,\n+                  UNRESOLVED_TYPE, unresolvedReference));\n         } else {\n-          compiler.report(JSError.make(t, n, reportUnknownTypes,\n-                                       UNKNOWN_EXPR_TYPE));\n+          compiler.report(\n+              t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n         }\n       }\n       unknownCount++;\n             interfaceHasProperty) {\n           // @override not present, but the property does override an interface\n           // property\n-          compiler.report(JSError.make(t, n, reportMissingOverride,\n+          compiler.report(t.makeError(n, reportMissingOverride,\n               HIDDEN_INTERFACE_PROPERTY, propertyName,\n               interfaceType.getTopMostDefiningType(propertyName).toString()));\n         }\n           JSType interfacePropType =\n               interfaceType.getPrototype().getPropertyType(propertyName);\n           if (!propertyType.canAssignTo(interfacePropType)) {\n-            compiler.report(JSError.make(t, n,\n+            compiler.report(t.makeError(n,\n                 HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,\n                 interfaceType.getTopMostDefiningType(propertyName).toString(),\n                 interfacePropType.toString(), propertyType.toString()));\n         !declaredOverride && superClassHasProperty) {\n       // @override not present, but the property does override a superclass\n       // property\n-      compiler.report(JSError.make(t, n, reportMissingOverride,\n+      compiler.report(t.makeError(n, reportMissingOverride,\n           HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n           topInstanceType.toString()));\n     }\n           superClass.getPrototype().getPropertyType(propertyName);\n       if (!propertyType.canAssignTo(superClassPropType)) {\n         compiler.report(\n-            JSError.make(t, n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n+            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                 propertyName, topInstanceType.toString(),\n                 superClassPropType.toString(), propertyType.toString()));\n       }\n     } else if (!foundInterfaceProperty) {\n       // there is no superclass nor interface implementation\n       compiler.report(\n-          JSError.make(t, n, UNKNOWN_OVERRIDE,\n-                       propertyName, ctorType.getInstanceType().toString()));\n+          t.makeError(n, UNKNOWN_OVERRIDE,\n+              propertyName, ctorType.getInstanceType().toString()));\n     }\n   }\n \n     if (!rvalueType.isOrdinaryFunction() &&\n         !(rvalue.isQualifiedName() &&\n           rvalue.getQualifiedName().equals(abstractMethodName))) {\n-      compiler.report(JSError.make(t, object, INTERFACE_FUNCTION_MEMBERS_ONLY,\n-                                   abstractMethodName));\n+      compiler.report(\n+          t.makeError(object, INTERFACE_FUNCTION_MEMBERS_ONLY,\n+              abstractMethodName));\n     }\n \n     if (assign.getLastChild().getType() == Token.FUNCTION\n         && !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) {\n-      compiler.report(JSError.make(t, object, INTERFACE_FUNCTION_NOT_EMPTY,\n-                                   abstractMethodName));\n+      compiler.report(\n+          t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY,\n+              abstractMethodName));\n     }\n   }\n \n           (baseConstructor.isConstructor() && functionType.isInterface() ||\n            baseConstructor.isInterface() && functionType.isConstructor())) {\n         compiler.report(\n-            JSError.make(t, n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n+            t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n       }\n \n       for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n     int maxArgs = functionType.getMaxArguments();\n     if (minArgs > numArgs || maxArgs < numArgs) {\n       t.getCompiler().report(\n-          JSError.make(t, call, WRONG_ARGUMENT_COUNT,\n+          t.makeError(call, WRONG_ARGUMENT_COUNT,\n               validator.getReadableJSTypeName(call.getFirstChild(), false),\n               String.valueOf(numArgs), String.valueOf(minArgs),\n               maxArgs != Integer.MAX_VALUE ?\n         String propName = n.getType() == Token.GETPROP ?\n             n.getLastChild().getString() : \"(missing)\";\n         compiler.report(\n-            JSError.make(t, n, ILLEGAL_IMPLICIT_CAST, propName));\n+            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n       compiler.getTypeRegistry().resolveTypesInScope(scope);\n \n     } catch (DataFlowAnalysis.MaxIterationsExceededException e) {\n-      compiler.report(JSError.make(t, n, DATAFLOW_ERROR));\n+      compiler.report(t.makeError(n, DATAFLOW_ERROR));\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n     if (!overridingType.canAssignTo(hiddenType)) {\n       registerMismatch(overridingType, hiddenType);\n       compiler.report(\n-          JSError.make(t, n, HIDDEN_PROPERTY_MISMATCH,\n+          t.makeError(n, HIDDEN_PROPERTY_MISMATCH,\n               propertyName, ownerType.toString(),\n               hiddenType.toString(), overridingType.toString()));\n     }\n     if (!declaredSuper.equals(superObject)) {\n       if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) {\n         compiler.report(\n-            JSError.make(t, n, MISSING_EXTENDS_TAG_WARNING,\n+            t.makeError(n, MISSING_EXTENDS_TAG_WARNING,\n                 subObject.toString()));\n         registerMismatch(superObject, declaredSuper);\n       } else {\n \n     if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n       compiler.report(\n-          JSError.make(t, n, INVALID_CAST,\n+          t.makeError(n, INVALID_CAST,\n               castType.toString(), type.toString()));\n       registerMismatch(type, castType);\n     }\n--- a/src/com/google/javascript/jscomp/VariableShadowDeclarationCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableShadowDeclarationCheck.java\n         Var var = vars.next();\n \n         if (externalNoShadowVariableNames.contains(var.getName())) {\n-          compiler.report(JSError.make(t, var.nameNode, checkLevel,\n-                                       SHADOW_VAR_ERROR,\n-                                       var.getName()));\n+          compiler.report(\n+              t.makeError(var.nameNode, checkLevel,\n+                  SHADOW_VAR_ERROR, var.getName()));\n           continue;\n         }\n \n         Var shadowedVar = parentScope.getVar(var.getName());\n         if ((shadowedVar != null) &&\n             (shadowedVar.isNoShadow() || shadowedVar.isLocal())) {\n-          compiler.report(JSError.make(t, var.nameNode, checkLevel,\n-                                       SHADOW_VAR_ERROR,\n-                                       var.getName()));\n+          compiler.report(\n+              t.makeError(var.nameNode, checkLevel,\n+                  SHADOW_VAR_ERROR, var.getName()));\n           continue;\n         }\n       }", "timestamp": 1269871493, "metainfo": ""}