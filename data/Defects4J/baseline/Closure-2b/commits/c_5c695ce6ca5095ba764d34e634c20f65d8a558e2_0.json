{"sha": "5c695ce6ca5095ba764d34e634c20f65d8a558e2", "log": "Proper source information for function prototypes  R=acleung DELTA=343  (190 added, 106 deleted, 47 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3216   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n       }\n     }\n \n-    // Create symbols for their properties.\n-    for (Symbol s : Iterables.concat(types, instances)) {\n+    // Create a property scope for each symbol, and populate\n+    // it with that symbol's properties.\n+    //\n+    // The order of operations here is significant.\n+    //\n+    // When we add properties to Foo, we'll remove Foo.prototype from\n+    // the symbol table and replace it with a fresh symbol in Foo's\n+    // property scope. So the symbol for Foo.prototype in\n+    // {@code instances} will be stale.\n+    //\n+    // To prevent this, we always populate {@code instances} before\n+    // their constructors.\n+    for (Symbol s : instances) {\n+      createPropertyScopeFor(s);\n+    }\n+\n+    for (Symbol s : types) {\n       createPropertyScopeFor(s);\n     }\n \n     Iterable<String> propNames = type.getOwnPropertyNames();\n     if (instanceType.isFunctionPrototypeType()) {\n       // Merge the properties of \"Foo.prototype\" and \"new Foo()\" together.\n-      instanceType =\n-          ((ObjectType) instanceType)\n-          .getOwnerFunction().getInstanceType();\n+      instanceType = instanceType.getOwnerFunction().getInstanceType();\n       Set<String> set = Sets.newHashSet(propNames);\n       Iterables.addAll(set, instanceType.getOwnPropertyNames());\n       propNames = set;\n         removeSymbol(oldProp);\n       }\n \n-      copySymbolTo(newProp, s.propertyScope);\n+      Symbol newSym = copySymbolTo(newProp, s.propertyScope);\n+      if (oldProp != null) {\n+        newSym.propertyScope = oldProp.propertyScope;\n+        for (Reference ref : oldProp.references.values()) {\n+          newSym.defineReferenceAt(ref.getNode());\n+        }\n+      }\n     }\n   }\n \n         return own;\n       }\n \n-      return parent == null ? null : parent.getSlot(name);\n+      Symbol ancestor = parent == null ? null : parent.getSlot(name);\n+      if (ancestor != null) {\n+        return ancestor;\n+      }\n+\n+      int dot = name.lastIndexOf('.');\n+      if (dot != -1) {\n+        Symbol owner = getSlot(name.substring(0, dot));\n+        if (owner != null && owner.getPropertyScope() != null) {\n+          return owner.getPropertyScope().getSlot(name.substring(dot + 1));\n+        }\n+      }\n+      return null;\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n \n import java.util.Iterator;\n import java.util.List;\n               !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n             // Declare var.prototype in the scope chain.\n             FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n-                fnType.getPrototype(), input,\n+            StaticSlot<JSType> prototypeSlot = fnType.getSlot(\"prototype\");\n+\n+            // It's not really important what node we declare the prototype\n+            // at. It's more important that the Var node is consistent with\n+            // the node that the type system uses internally.\n+            Node prototypeNode = n;\n+            if (prototypeSlot.getDeclaration() != null) {\n+              prototypeNode = prototypeSlot.getDeclaration().getNode();\n+            }\n+\n+            scopeToDeclareIn.declare(variableName + \".prototype\",\n+                prototypeNode, prototypeSlot.getType(), input,\n                 /* declared iff there's an explicit supertype */\n                 superClassCtor == null ||\n                 superClassCtor.getInstanceType().equals(\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n \n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n+import static com.google.javascript.rhino.jstype.ObjectType.Property;\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n    * initializing this field is that there are cycles in the native types\n    * graph, so some prototypes must temporarily be {@code null} during\n    * the construction of the graph.\n-   */\n-  private PrototypeObjectType prototype;\n-\n-  private SimpleSlot prototypeSlot;\n+   *\n+   * If non-null, the type must be a PrototypeObjectType.\n+   */\n+  private Property prototypeSlot;\n \n   /**\n    * Whether a function is a constructor, an interface, or just an ordinary\n    * to expose the prototype for ordinary functions.\n    */\n   public Set<String> getOwnPropertyNames() {\n-    if (prototype == null) {\n+    if (prototypeSlot == null) {\n       return super.getOwnPropertyNames();\n     } else {\n       Set<String> names = Sets.newHashSet(\"prototype\");\n    */\n   public ObjectType getPrototype() {\n     // lazy initialization of the prototype field\n-    if (prototype == null) {\n+    if (prototypeSlot == null) {\n       setPrototype(\n           new PrototypeObjectType(\n               registry,\n               this.getReferenceName() + \".prototype\",\n               registry.getNativeObjectType(OBJECT_TYPE),\n-              isNativeObjectType()));\n-    }\n-    return prototype;\n+              isNativeObjectType()),\n+          null);\n+    }\n+    return (ObjectType) prototypeSlot.getType();\n   }\n \n   /**\n    * @param baseType The base type.\n    */\n   public void setPrototypeBasedOn(ObjectType baseType) {\n+    setPrototypeBasedOn(baseType, null);\n+  }\n+\n+  void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) {\n     // This is a bit weird. We need to successfully handle these\n     // two cases:\n     // Foo.prototype = new Bar();\n       baseType = new PrototypeObjectType(\n           registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n+    setPrototype((PrototypeObjectType) baseType, propertyNode);\n   }\n \n   /**\n    * @param prototype the prototype. If this value is {@code null} it will\n    *        silently be discarded.\n    */\n-  public boolean setPrototype(PrototypeObjectType prototype) {\n+  boolean setPrototype(PrototypeObjectType prototype, Node propertyNode) {\n     if (prototype == null) {\n       return false;\n     }\n       return false;\n     }\n \n-    PrototypeObjectType oldPrototype = this.prototype;\n+    PrototypeObjectType oldPrototype = prototypeSlot == null\n+        ? null : (PrototypeObjectType) prototypeSlot.getType();\n     boolean replacedPrototype = oldPrototype != null;\n \n-    this.prototype = prototype;\n-    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n-    this.prototype.setOwnerFunction(this);\n+    this.prototypeSlot = new Property(\"prototype\", prototype, true,\n+        propertyNode == null ? source : propertyNode);\n+    prototype.setOwnerFunction(this);\n \n     if (oldPrototype != null) {\n       // Disassociating the old prototype makes this easier to debug--\n     if (\"prototype\".equals(name)) {\n       ObjectType objType = type.toObjectType();\n       if (objType != null) {\n-        if (objType.isEquivalentTo(prototype)) {\n+        if (prototypeSlot != null &&\n+            objType.isEquivalentTo(prototypeSlot.getType())) {\n           return true;\n         }\n-        this.setPrototypeBasedOn(objType);\n+        this.setPrototypeBasedOn(objType, propertyNode);\n         return true;\n       } else {\n         return false;\n         getInstanceType().clearCachedValues();\n       }\n \n-      if (prototype != null) {\n-        prototype.clearCachedValues();\n+      if (prototypeSlot != null) {\n+        ((PrototypeObjectType) prototypeSlot.getType()).clearCachedValues();\n       }\n     }\n   }\n \n   @Override\n   public boolean hasCachedValues() {\n-    return prototype != null || super.hasCachedValues();\n+    return prototypeSlot != null || super.hasCachedValues();\n   }\n \n   /**\n     setResolvedTypeInternal(this);\n \n     call = (ArrowType) safeResolve(call, t, scope);\n-    prototype = (PrototypeObjectType) safeResolve(prototype, t, scope);\n+    if (prototypeSlot != null) {\n+      prototypeSlot.setType(\n+          (PrototypeObjectType) safeResolve(prototypeSlot.getType(), t, scope));\n+    }\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n             createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n             null, null, true, true);\n \n-    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE);\n+    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n     registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n \n     ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-\n+import com.google.javascript.rhino.jstype.StaticReference;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+\n+import java.io.Serializable;\n import java.util.Set;\n \n /**\n   public Iterable<ObjectType> getCtorExtendedInterfaces() {\n     return ImmutableSet.of();\n   }\n+\n+  static final class Property\n+      implements Serializable, StaticSlot<JSType>, StaticReference<JSType> {\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Property's name.\n+     */\n+    private final String name;\n+\n+    /**\n+     * Property's type.\n+     */\n+    private JSType type;\n+\n+    /**\n+     * Whether the property's type is inferred.\n+     */\n+    private final boolean inferred;\n+\n+    /**\n+     * The node corresponding to this property, e.g., a GETPROP node that\n+     * declares this property.\n+     */\n+    private final Node propertyNode;\n+\n+    /**  The JSDocInfo for this property. */\n+    private JSDocInfo docInfo = null;\n+\n+    Property(String name, JSType type, boolean inferred,\n+        Node propertyNode) {\n+      this.name = name;\n+      this.type = type;\n+      this.inferred = inferred;\n+      this.propertyNode = propertyNode;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public Node getNode() {\n+      return propertyNode;\n+    }\n+\n+    @Override\n+    public StaticSourceFile getSourceFile() {\n+      return propertyNode == null ? null : propertyNode.getStaticSourceFile();\n+    }\n+\n+    @Override\n+    public Property getSymbol() {\n+      return this;\n+    }\n+\n+    @Override\n+    public Property getDeclaration() {\n+      return propertyNode == null ? null : this;\n+    }\n+\n+    @Override\n+    public JSType getType() {\n+      return type;\n+    }\n+\n+    @Override\n+    public boolean isTypeInferred() {\n+      return inferred;\n+    }\n+\n+    boolean isFromExterns() {\n+      return propertyNode == null ? false : propertyNode.isFromExterns();\n+    }\n+\n+    void setType(JSType type) {\n+      this.type = type;\n+    }\n+\n+    JSDocInfo getJSDocInfo() {\n+      return this.docInfo;\n+    }\n+\n+    void setJSDocInfo(JSDocInfo info) {\n+      this.docInfo = info;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n package com.google.javascript.rhino.jstype;\n \n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.javascript.rhino.jstype.ObjectType.Property;\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n \n-import java.io.Serializable;\n import java.util.Map;\n import java.util.Set;\n \n     if (oldProp != null) {\n       // This is to keep previously inferred jsdoc info, e.g., in a\n       // replaceScript scenario.\n-      newProp.docInfo = oldProp.docInfo;\n+      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n     }\n     properties.put(name, newProp);\n     return true;\n   public Node getPropertyNode(String propertyName) {\n     Property p = properties.get(propertyName);\n     if (p != null) {\n-      return p.propertyNode;\n+      return p.getNode();\n     }\n     ObjectType implicitPrototype = getImplicitPrototype();\n     if (implicitPrototype != null) {\n   public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n     Property p = properties.get(propertyName);\n     if (p != null) {\n-      return p.docInfo;\n+      return p.getJSDocInfo();\n     }\n     return null;\n   }\n       // We probably don't want to attach any JSDoc to it anyway.\n       Property property = properties.get(propertyName);\n       if (property != null) {\n-        property.docInfo = info;\n+        property.setJSDocInfo(info);\n       }\n     }\n   }\n     return false;\n   }\n \n-  private static final class Property\n-      implements Serializable, StaticSlot<JSType>, StaticReference<JSType> {\n-    private static final long serialVersionUID = 1L;\n-\n-    /**\n-     * Property's name.\n-     */\n-    private String name;\n-\n-    /**\n-     * Property's type.\n-     */\n-    private JSType type;\n-\n-    /**\n-     * Whether the property's type is inferred.\n-     */\n-    private final boolean inferred;\n-\n-    /**\n-     * The node corresponding to this property, e.g., a GETPROP node that\n-     * declares this property.\n-     */\n-    private final Node propertyNode;\n-\n-    /**  The JSDocInfo for this property. */\n-    private JSDocInfo docInfo = null;\n-\n-    private Property(String name, JSType type, boolean inferred,\n-        Node propertyNode) {\n-      this.name = name;\n-      this.type = type;\n-      this.inferred = inferred;\n-      this.propertyNode = propertyNode;\n-    }\n-\n-    @Override\n-    public String getName() {\n-      return name;\n-    }\n-\n-    @Override\n-    public Node getNode() {\n-      return propertyNode;\n-    }\n-\n-    @Override\n-    public StaticSourceFile getSourceFile() {\n-      return propertyNode == null ? null : propertyNode.getStaticSourceFile();\n-    }\n-\n-    @Override\n-    public Property getSymbol() {\n-      return this;\n-    }\n-\n-    @Override\n-    public Property getDeclaration() {\n-      return propertyNode == null ? null : this;\n-    }\n-\n-    @Override\n-    public JSType getType() {\n-      return type;\n-    }\n-\n-    @Override\n-    public boolean isTypeInferred() {\n-      return inferred;\n-    }\n-\n-    boolean isFromExterns() {\n-      return propertyNode == null ? false : propertyNode.isFromExterns();\n-    }\n-  }\n-\n   @Override\n   public boolean hasCachedValues() {\n     return super.hasCachedValues();\n           (ObjectType) implicitPrototype.resolve(t, scope);\n     }\n     for (Property prop : properties.values()) {\n-      prop.type = safeResolve(prop.type, t, scope);\n+      prop.setType(safeResolve(prop.getType(), t, scope));\n     }\n     return this;\n   }\n--- a/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n  * @author nicksantos@google.com (Nick Santos)\n  */\n public class SimpleSlot implements StaticSlot<JSType>, Serializable {\n+  private static final long serialVersionUID = 1L;\n+\n   final String name;\n   final JSType type;\n   final boolean inferred;\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertNotNull(domHelper);\n \n     Symbol domHelperNamespacedMethod = getGlobalVar(table, \"DomHelper.method\");\n-    assertNull(domHelperNamespacedMethod);\n+    assertEquals(\"method\", domHelperNamespacedMethod.getName());\n \n     Symbol domHelperMethod = domHelper.getPropertyScope().getSlot(\"method\");\n     assertNotNull(domHelperMethod);\n     assertEquals(fn, table.getSymbolForScope(scope));\n   }\n \n-  public void testPrototypeSymbol() throws Exception {\n-    SymbolTable table = createSymbolTable(\n-        \"/** @constructor */ function Foo() {}\");\n-    Symbol fooPrototype = getGlobalVar(table, \"Foo.prototype\");\n-    assertNotNull(fooPrototype);\n-    assertEquals(1, Iterables.size(table.getReferences(fooPrototype)));\n-  }\n-\n   public void testSymbolsForType() throws Exception {\n     SymbolTable table = createSymbolTable(\n         \"function random() { return 1; }\" +\n         \"  (new DomHelper()).method(); (new DomHelper()).method(); };\");\n \n     Symbol method =\n-        getGlobalVar(table, \"DomHelper.prototype\")\n-        .getPropertyScope().getSlot(\"method\");\n+        getGlobalVar(table, \"DomHelper.prototype.method\");\n     assertEquals(\n         3, Iterables.size(table.getReferences(method)));\n   }\n         \"function f() { \" +\n         \"  return (new DomHelper()).field + (new DomHelper()).field; };\");\n \n-    Symbol field =\n-        getGlobalVar(table, \"DomHelper.prototype\")\n-        .getPropertyScope().getSlot(\"field\");\n+    Symbol field = getGlobalVar(table, \"DomHelper.prototype.field\");\n     assertEquals(\n         3, Iterables.size(table.getReferences(field)));\n   }\n         \"  return x.field;\" +\n         \"}\");\n \n-    Symbol field =\n-        getGlobalVar(table, \"DomHelper.prototype\")\n-        .getPropertyScope().getSlot(\"field\");\n+    Symbol field = getGlobalVar(table, \"DomHelper.prototype.field\");\n     assertNull(field);\n   }\n \n     List<Reference> refs = Lists.newArrayList(table.getReferences(prototype));\n \n     // One of the refs is implicit in the declaration of the function.\n-    assertEquals(2, refs.size());\n+    assertEquals(refs.toString(), 2, refs.size());\n   }\n \n   public void testPrototypeReferences2() throws Exception {\n     assertNotNull(prototype);\n \n     List<Reference> refs = Lists.newArrayList(table.getReferences(prototype));\n-\n-    // TODO(nicksantos): This is a bug and should be fixed.\n-    // It has to do with some weirdness with how prototypes are handled\n-    // in our type system.\n+    assertEquals(2, refs.size());\n+  }\n+\n+  public void testPrototypeReferences3() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ function Foo() {}\");\n+    Symbol fooPrototype = getGlobalVar(table, \"Foo.prototype\");\n+    assertNotNull(fooPrototype);\n+\n+    List<Reference> refs = Lists.newArrayList(\n+        table.getReferences(fooPrototype));\n     assertEquals(1, refs.size());\n+    assertEquals(Token.FUNCTION, refs.get(0).getNode().getType());\n+  }\n+\n+  public void testPrototypeReferences4() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype = {bar: 3}\");\n+    Symbol fooPrototype = getGlobalVar(table, \"Foo.prototype\");\n+    assertNotNull(fooPrototype);\n+\n+    List<Reference> refs = Lists.newArrayList(\n+        table.getReferences(fooPrototype));\n+    assertEquals(1, refs.size());\n+    assertEquals(Token.GETPROP, refs.get(0).getNode().getType());\n+    assertEquals(\"Foo.prototype\", refs.get(0).getNode().getQualifiedName());\n   }\n \n   private Symbol getGlobalVar(SymbolTable table, String name) {\n-    for (Symbol symbol : table.getAllSymbols()) {\n-      if (symbol.getName().equals(name) &&\n-          table.getScope(symbol).getParentScope() == null) {\n-        return symbol;\n-      }\n-    }\n-    return null;\n+    return table.getGlobalScope().getSlot(name);\n   }\n \n   private Symbol getLocalVar(SymbolTable table, String name) {\n \n     Compiler compiler = new Compiler();\n     compiler.compile(externs, inputs, options);\n-    return compiler.buildKnownSymbolTable();\n+    return assertSymbolTableValid(compiler.buildKnownSymbolTable());\n+  }\n+\n+  /**\n+   * Asserts that the symbol table meets some invariants.\n+   * Returns the same table for easy chaining.\n+   */\n+  private SymbolTable assertSymbolTableValid(SymbolTable table) {\n+    for (Symbol sym : table.getAllSymbols()) {\n+      // Make sure that grabbing the symbol's scope and looking it up\n+      // again produces the same symbol.\n+      assertEquals(sym, table.getScope(sym).getSlot(sym.getName()));\n+\n+      for (Reference ref : table.getReferences(sym)) {\n+        // Make sure that the symbol and reference are mutually linked.\n+        assertEquals(sym, ref.getSymbol());\n+      }\n+    }\n+\n+    return table;\n   }\n }", "timestamp": 1315491356, "metainfo": ""}