{"sha": "e29ffb609354f6df02a1f2acb3a41a00bd1d3261", "log": "improve inference for goog.bind  Tested: yes  R=johnlenz DELTA=403  (281 added, 85 deleted, 37 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4711   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n   }\n \n   @Override\n-  public Bind describeFunctionBind(Node n) {\n-    Bind result = super.describeFunctionBind(n);\n+  public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n+    Bind result = super.describeFunctionBind(n, useTypeInfo);\n     if (result != null) {\n       return result;\n     }\n-\n-    // It would be nice to be able to identify a fn.bind call\n-    // but that requires knowing the type of \"fn\".\n \n     if (!n.isCall()) {\n       return null;\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n    */\n   public Bind describeFunctionBind(Node n);\n \n+  /**\n+   * A Bind instance or null.\n+   * @param useTypeInfo If we believe type information is reliable enough\n+   *     to use to figure out what the bind function is.\n+   */\n+  public Bind describeFunctionBind(Node n, boolean useTypeInfo);\n+\n   public static class Bind {\n     // The target of the bind action\n     final Node target;\n       this.thisValue = thisValue;\n       this.parameters = parameters;\n     }\n+\n+    /**\n+     * The number of parameters bound (not including the 'this' value).\n+     */\n+    int getBoundParameterCount() {\n+      if (parameters == null) {\n+        return 0;\n+      }\n+      Node paramParent = parameters.getParent();\n+      return paramParent.getChildCount() -\n+          paramParent.getIndexOfChild(parameters);\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CodingConventions.java\n+++ b/src/com/google/javascript/jscomp/CodingConventions.java\n \n     @Override\n     public Bind describeFunctionBind(Node n) {\n-      return nextConvention.describeFunctionBind(n);\n+      return describeFunctionBind(n, false);\n+    }\n+\n+    @Override\n+    public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n+      return nextConvention.describeFunctionBind(n, useTypeInfo);\n     }\n \n     @Override\n \n     @Override\n     public Bind describeFunctionBind(Node n) {\n-      // It would be nice to be able to identify a fn.bind call\n-      // but that requires knowing the type of \"fn\".\n-\n+      return describeFunctionBind(n, false);\n+    }\n+\n+    @Override\n+    public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n       if (!n.isCall()) {\n         return null;\n       }\n       }\n \n       if (callTarget.isGetProp()\n-          && callTarget.getLastChild().getString().equals(\"bind\")\n-          && callTarget.getFirstChild().isFunction()) {\n-        // (function(){}).bind(self, args...);\n-        Node fn = callTarget.getFirstChild();\n-        Node thisValue = callTarget.getNext();\n-        Node parameters = safeNext(thisValue);\n-        return new Bind(fn, thisValue, parameters);\n+          && callTarget.getLastChild().getString().equals(\"bind\")) {\n+        Node maybeFn = callTarget.getFirstChild();\n+        JSType maybeFnType = maybeFn.getJSType();\n+        FunctionType fnType = null;\n+        if (useTypeInfo && maybeFnType != null) {\n+          fnType = maybeFnType.restrictByNotNullOrUndefined()\n+              .toMaybeFunctionType();\n+        }\n+\n+        if (fnType != null || maybeFn.isFunction()) {\n+          // (function(){}).bind(self, args...);\n+          Node thisValue = callTarget.getNext();\n+          Node parameters = safeNext(thisValue);\n+          return new Bind(maybeFn, thisValue, parameters);\n+        }\n       }\n \n       return null;\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n     // Rewriting \"(fn.bind(a,b))()\" to \"fn.call(a,b)\" makes it inlinable\n     Preconditions.checkState(n.isCall());\n     Node callTarget = n.getFirstChild();\n-    Bind bind = getCodingConvention().describeFunctionBind(callTarget);\n+    Bind bind = getCodingConvention().describeFunctionBind(callTarget, false);\n     if (bind != null) {\n       // replace the call target\n       bind.target.detachFromParent();\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n    * \"bound\" function by looking at the number of parameters in the call site.\n    */\n   private void updateBind(Node n, FunctionType fnType) {\n-    // TODO(nicksantos): Use the coding convention, so that we get goog.bind\n-    // for free.\n-    Node calledFn = n.getFirstChild();\n-    boolean looksLikeBind = calledFn.isGetProp()\n-        && calledFn.getLastChild().getString().equals(\"bind\");\n-    if (!looksLikeBind) {\n+    CodingConvention.Bind bind =\n+        compiler.getCodingConvention().describeFunctionBind(n, true);\n+    if (bind == null) {\n       return;\n     }\n \n-    Node callTarget = calledFn.getFirstChild();\n-    FunctionType callTargetFn = getJSType(callTarget)\n+    FunctionType callTargetFn = getJSType(bind.target)\n         .restrictByNotNullOrUndefined().toMaybeFunctionType();\n     if (callTargetFn == null) {\n       return;\n     }\n \n-    n.setJSType(callTargetFn.getBindReturnType(n.getChildCount() - 1));\n+    n.setJSType(\n+        callTargetFn.getBindReturnType(\n+            // getBindReturnType expects the 'this' argument to be included.\n+            bind.getBoundParameterCount() + 1));\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   }\n \n   public void testGoogBind1() throws Exception {\n-    // We currently do not support goog.bind natively.\n     testClosureTypes(\n         \"var goog = {}; goog.bind = function(var_args) {};\" +\n         \"/** @type {function(number): boolean} */\" +\n+        \"function f(x, y) { return true; }\" +\n+        \"f(goog.bind(f, null, 'x')());\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testGoogBind2() throws Exception {\n+    // TODO(nicksantos): We do not currently type-check the arguments\n+    // of the goog.bind.\n+    testClosureTypes(\n+        \"var goog = {}; goog.bind = function(var_args) {};\" +\n+        \"/** @type {function(boolean): boolean} */\" +\n         \"function f(x, y) { return true; }\" +\n         \"f(goog.bind(f, null, 'x')());\",\n         null);", "timestamp": 1336495222, "metainfo": ""}