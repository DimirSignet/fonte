{"sha": "ddb4d1112eaf5e16c7ac36a820faa0dcd53d89b8", "log": "Fix DisambiguateProperties whenever an inferface was unioned with a constructor. The problem is that processProperty would recurse twice--once to get the alternates of the union and once to get the interface implementations--and the related type would not get passed up the recursion stack. (Nick)   Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n \n       Iterable<T> alternatives = typeSystem.getTypeAlternatives(type);\n       if (alternatives != null) {\n-        T firstType = null;\n+        T firstType = relatedType;\n         for (T subType : alternatives) {\n           T lastType = processProperty(t, prop, subType, firstType);\n           if (lastType != null) {\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n     testSets(true, js, \"{a=[[Foo.prototype], [I.prototype]]}\");\n   }\n \n+  public void testInterfaceUnionWithCtor() {\n+    String js = \"\"\n+        + \"/** @interface */ function I() {};\\n\"\n+        + \"/** @type {!Function} */ I.prototype.addEventListener;\\n\"\n+        + \"/** @constructor \\n * @implements {I} */ function Impl() {};\\n\"\n+        + \"/** @type {!Function} */ Impl.prototype.addEventListener;\"\n+        + \"/** @constructor */ function C() {};\\n\"\n+        + \"/** @type {!Function} */ C.prototype.addEventListener;\"\n+        + \"/** @param {C|I} x */\"\n+        + \"function f(x) { x.addEventListener(); };\\n\"\n+        + \"f(new C()); f(new Impl());\";\n+\n+    testSets(false, js, js,\n+        \"{addEventListener=[[C.prototype, I.prototype, Impl.prototype]]}\");\n+\n+    // In the tightened case, the disambiguator is smart enough to\n+    // disambiguate Impl's method from the interface method.\n+    String tightenedOutput = \"\"\n+        + \"function I() {};\\n\"\n+        + \"I.prototype.I_prototype$addEventListener;\\n\"\n+        + \"function Impl() {};\\n\"\n+        + \"Impl.prototype.C_prototype$addEventListener;\"\n+        + \"function C() {};\\n\"\n+        + \"C.prototype.C_prototype$addEventListener;\"\n+        + \"/** @param {C|I} x */\"\n+        + \"function f(x) { x.C_prototype$addEventListener(); };\\n\"\n+        + \"f(new C()); f(new Impl());\";\n+\n+    testSets(true, js, tightenedOutput,\n+        \"{addEventListener=[[C.prototype, Impl.prototype], [I.prototype]]}\");\n+  }\n+\n+  public void testExternInterfaceUnionWithCtor() {\n+    String externs = \"\"\n+        + \"/** @interface */ function I() {};\\n\"\n+        + \"/** @type {!Function} */ I.prototype.addEventListener;\\n\"\n+        + \"/** @constructor \\n * @implements {I} */ function Impl() {};\\n\"\n+        + \"/** @type {!Function} */ Impl.prototype.addEventListener;\";\n+\n+    String js = \"\"\n+        + \"/** @constructor */ function C() {};\\n\"\n+        + \"/** @type {!Function} */ C.prototype.addEventListener;\"\n+        + \"/** @param {C|I} x */\"\n+        + \"function f(x) { x.addEventListener(); };\\n\"\n+        + \"f(new C()); f(new Impl());\";\n+\n+    testSets(false, externs, js, js, \"{}\");\n+    testSets(true, externs, js, js, \"{}\");\n+  }\n+\n   /**\n    * Tests that the type based version skips renaming on types that have a\n    * mismatch, and the type tightened version continues to work as normal.", "timestamp": 1267579622, "metainfo": ""}