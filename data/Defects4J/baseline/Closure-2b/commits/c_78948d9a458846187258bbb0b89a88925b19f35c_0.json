{"sha": "78948d9a458846187258bbb0b89a88925b19f35c", "log": "fix up a malformed syntax tree  R=johnlenz DELTA=50  (9 added, 40 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4010   ", "commit": "\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n     DiagnosticType.warning(\n       \"JSC_UNDEFINED_EXTERN_VAR_ERROR\",\n       \"name {0} is not undefined in the externs.\");\n-\n-  static final DiagnosticType INVALID_FUNCTION_DECL =\n-    DiagnosticType.error(\"JSC_INVALID_FUNCTION_DECL\",\n-        \"Syntax error: function declaration must have a name\");\n \n   private CompilerInput synthesizedExternsInput = null;\n   private Node synthesizedExternsRoot = null;\n     // Only a function can have an empty name.\n     if (varName.isEmpty()) {\n       Preconditions.checkState(parent.isFunction());\n-\n-      // A function declaration with an empty name passes Rhino,\n-      // but is supposed to be a syntax error according to the spec.\n-      if (!NodeUtil.isFunctionExpression(parent)) {\n-        t.report(n, INVALID_FUNCTION_DECL);\n-      }\n+      Preconditions.checkState(NodeUtil.isFunctionExpression(parent));\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n             \"unnamed function statement\",\n             sourceName,\n             functionNode.getLineno(), \"\", 0);\n+\n+          // Return the bare minimum to put the AST in a valid state.\n+          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n         }\n         name = new Name();\n         name.setIdentifier(\"\");\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n     test(\"var a = {b:5}; with (a){b;}\", null, VarCheck.UNDEFINED_VAR_ERROR);\n   }\n \n-  public void testInvalidFunctionDecl1() {\n-    // This test deliberately sets up an invalid AST.\n-    super.enableAstValidation(false);\n-\n-    final CompilerTestCase testcase = this;\n-\n-    // A compiler pass that create invalid function names.\n-    testSetupPass = new CompilerPass() {\n-\n-      void visit(Node n) {\n-        if (n.isName()\n-            && !n.getString().isEmpty()\n-            && n.getParent().isFunction()) {\n-          n.setString(\"\");\n-          testcase.getLastCompiler().reportCodeChange();\n-        }\n-        for (Node c : n.children()) {\n-          visit(c);\n-        }\n-      }\n-\n-      @Override\n-      public void process(Node externs, Node root) {\n-        visit(root);\n-      }\n-    };\n-\n-    test(\"function f() {};\", null, VarCheck.INVALID_FUNCTION_DECL);\n-    test(\"if (true) { function f(){}; }\", null, VarCheck.INVALID_FUNCTION_DECL);\n-  }\n-\n   public void testValidFunctionExpr() {\n     testSame(\"(function() {});\");\n   }", "timestamp": 1324418459, "metainfo": ""}