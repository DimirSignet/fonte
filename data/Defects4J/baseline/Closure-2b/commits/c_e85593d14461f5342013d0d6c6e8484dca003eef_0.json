{"sha": "e85593d14461f5342013d0d6c6e8484dca003eef", "log": "fix vertical tab encoding fixes issue 601  R=johnlenz DELTA=147  (119 added, 0 deleted, 28 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3787   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n           if (!Double.isNaN(d)) {\n             cc.addNumber(d);\n           } else {\n-            addJsString(n.getString());\n+            addJsString(n);\n           }\n         }\n \n           throw new IllegalStateException(\n               \"Unexpected String children: \" + n.getParent().toStringTree());\n         }\n-        addJsString(n.getString());\n+        addJsString(n);\n         break;\n \n       case Token.DELPROP:\n   }\n \n   /** Outputs a js string, using the optimal (single/double) quote character */\n-  void addJsString(String s) {\n-    String cached = ESCAPED_JS_STRINGS.get(s);\n-    if (cached == null) {\n-      cached = jsString(s);\n-      ESCAPED_JS_STRINGS.put(s, cached);\n-    }\n-    add(cached);\n-  }\n-\n-  String jsString(String s) {\n+  private void addJsString(Node n) {\n+    String s = n.getString();\n+    boolean useSlashV = n.getBooleanProp(Node.SLASH_V);\n+    if (useSlashV) {\n+      add(jsString(n.getString(), useSlashV));\n+    } else {\n+      String cached = ESCAPED_JS_STRINGS.get(s);\n+      if (cached == null) {\n+        cached = jsString(n.getString(), useSlashV);\n+        ESCAPED_JS_STRINGS.put(s, cached);\n+      }\n+      add(cached);\n+    }\n+  }\n+\n+  private String jsString(String s, boolean useSlashV) {\n     int singleq = 0, doubleq = 0;\n \n     // could count the quotes and pick the optimal quote character\n     }\n \n     return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n-        outputCharsetEncoder);\n+        outputCharsetEncoder, useSlashV);\n   }\n \n   /** Escapes regular expression */\n   static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n-    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder);\n+    return strEscape(s, '/', \"\\\"\", \"'\", \"\\\\\", outputCharsetEncoder, false);\n   }\n \n   /**\n    * Escapes the given string to a double quoted (\") JavaScript/JSON string\n    */\n   static String escapeToDoubleQuotedJsString(String s) {\n-    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n+    return strEscape(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null, false);\n   }\n \n   /* If the user doesn't want to specify an output charset encoder, assume\n   }\n \n   /** Helper to escape javascript string as well as regular expression */\n-  static String strEscape(String s, char quote,\n-                          String doublequoteEscape,\n-                          String singlequoteEscape,\n-                          String backslashEscape,\n-                          CharsetEncoder outputCharsetEncoder) {\n+  private static String strEscape(\n+      String s, char quote,\n+      String doublequoteEscape,\n+      String singlequoteEscape,\n+      String backslashEscape,\n+      CharsetEncoder outputCharsetEncoder,\n+      boolean useSlashV) {\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n         case '\\0': sb.append(\"\\\\x00\"); break;\n+        case '\\u000B':\n+          if (useSlashV) {\n+            sb.append(\"\\\\v\");\n+          } else {\n+            sb.append(\"\\\\x0B\");\n+          }\n+          break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n         if (Token.STRING != right.getType()) {\n           return n;  // Only eval if they are the same type\n         }\n+\n+        TernaryValue ternary = TernaryValue.UNKNOWN;\n         switch (op) {\n           case Token.SHEQ:\n           case Token.EQ:\n-            result = left.getString().equals(right.getString());\n+            ternary = areStringsEqual(left.getString(), right.getString());\n             break;\n \n           case Token.SHNE:\n           case Token.NE:\n-            result = !left.getString().equals(right.getString());\n+            ternary =\n+                areStringsEqual(left.getString(), right.getString()).not();\n             break;\n-\n-          default:\n-            return n;  // we only handle == and != here\n-        }\n+        }\n+\n+        if (ternary == TernaryValue.UNKNOWN) {\n+          return n;\n+        }\n+        result = ternary.toBoolean(true);\n         break;\n \n       case Token.NUMBER:\n     reportCodeChange();\n \n     return newNode;\n+  }\n+\n+  /** Returns whether two JS strings are equal. */\n+  private TernaryValue areStringsEqual(String a, String b) {\n+    // In JS, browsers parse \\v differently. So do not consider strings\n+    // equal if one containts \\v.\n+    if (a.indexOf('\\u000B') != -1 ||\n+        b.indexOf('\\u000B') != -1) {\n+      return TernaryValue.UNKNOWN;\n+    } else {\n+      return a.equals(b) ? TernaryValue.TRUE : TernaryValue.FALSE;\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n     @Override\n     Node processStringLiteral(StringLiteral literalNode) {\n-      Node n = newStringNode(literalNode.getValue());\n+      String value = literalNode.getValue();\n+      Node n = newStringNode(value);\n+      if (value.indexOf('\\u000B') != -1) {\n+        // NOTE(nicksantos): In JavaScript, there are 3 ways to\n+        // represent a vertical tab: \\v, \\x0B, \\u000B.\n+        // The \\v notation was added later, and is not understood\n+        // on IE. So we need to preserve it as-is. This is really\n+        // obnoxious, because we do not have a good way to represent\n+        // how the original string was encoded without making the\n+        // representation of strings much more complicated.\n+        //\n+        // To handle this, we look at the original source test, and\n+        // mark the string as \\v-encoded or not. If a string is\n+        // \\v encoded, then all the vertical tabs in that string\n+        // will be encoded with a \\v.\n+        int start = literalNode.getAbsolutePosition();\n+        int end = start + literalNode.getLength();\n+        if (start < sourceString.length() &&\n+            (sourceString.substring(\n+                 start, Math.min(sourceString.length(), end))\n+             .indexOf(\"\\\\v\") != -1)) {\n+          n.putBooleanProp(Node.SLASH_V, true);\n+        }\n+      }\n       return n;\n     }\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n                                   // this node.\n       INPUT_ID           = 53,    // The id of the input associated with this\n                                   // node.\n-      LAST_PROP          = 53;\n+      SLASH_V            = 54,    // Whether a STRING node contains a \\v\n+                                  // vertical tab escape. This is a total hack.\n+                                  // See comments in IRFactory about this.\n+      LAST_PROP          = 54;\n \n   public static final int   // flags for INCRDECR_PROP\n       DECR_FLAG = 0x1,\n       if (quoted1 != quoted2) {\n         return false;\n       }\n+\n+      int slashV1 = this.getIntProp(SLASH_V);\n+      int slashV2 = node.getIntProp(SLASH_V);\n+      if (slashV1 != slashV2) {\n+        return false;\n+      }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n         return false;\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n   public void testIssue582() {\n     assertPrint(\"var x = -0.0;\", \"var x=-0.0\");\n   }\n+\n+  public void testIssue601() {\n+    assertPrint(\"'\\\\v' == 'v'\", \"\\\"\\\\v\\\"==\\\"v\\\"\");\n+    assertPrint(\"'\\\\u000B' == '\\\\v'\", \"\\\"\\\\x0B\\\"==\\\"\\\\v\\\"\");\n+    assertPrint(\"'\\\\x0B' == '\\\\v'\", \"\\\"\\\\x0B\\\"==\\\"\\\\v\\\"\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n          \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);\n   }\n \n+  public void testIssue601() {\n+    args.add(\"--compilation_level=WHITESPACE_ONLY\");\n+    test(\"function f() { return '\\\\v' == 'v'; } window['f'] = f;\",\n+         \"function f(){return'\\\\v'=='v'}window['f']=f\");\n+  }\n+\n+  public void testIssue601b() {\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n+    test(\"function f() { return '\\\\v' == 'v'; } window['f'] = f;\",\n+         \"window.f=function(){return'\\\\v'=='v'}\");\n+  }\n+\n+  public void testIssue601c() {\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n+    test(\"function f() { return '\\\\u000B' == 'v'; } window['f'] = f;\",\n+         \"window.f=function(){return'\\\\u000B'=='v'}\");\n+  }\n+\n   public void testDebugFlag1() {\n     args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n     args.add(\"--debug=false\");\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     test(\"(![1])\", \"false\");\n     test(\"(![a])\", \"false\");\n     testSame(\"(![foo()])\");\n+  }\n+\n+  public void testIssue601() {\n+    testSame(\"'\\\\v' == 'v'\");\n+    testSame(\"'v' == '\\\\v'\");\n+    testSame(\"'\\\\u000B' == '\\\\v'\");\n   }\n \n   public void testFoldObjectLiteralRef1() {\n--- a/test/com/google/javascript/rhino/NodeTest.java\n+++ b/test/com/google/javascript/rhino/NodeTest.java\n   public void testCheckTreeEqualsBooleanDifferent() {\n     Node node1 = new Node(1);\n     Node node2 = new Node(2);\n+    assertEquals(false, node1.isEquivalentTo(node2));\n+  }\n+\n+  public void testCheckTreeEqualsSlashVDifferent() {\n+    Node node1 = Node.newString(\"\\u000B\");\n+    node1.putBooleanProp(Node.SLASH_V, true);\n+    Node node2 = Node.newString(\"\\u000B\");\n     assertEquals(false, node1.isEquivalentTo(node2));\n   }\n ", "timestamp": 1321905775, "metainfo": ""}