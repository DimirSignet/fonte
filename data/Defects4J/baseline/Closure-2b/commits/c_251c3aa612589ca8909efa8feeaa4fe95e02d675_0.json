{"sha": "251c3aa612589ca8909efa8feeaa4fe95e02d675", "log": "Start working type information into the symbol table  R=acleung DELTA=326  (164 added, 4 deleted, 158 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3080   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Table;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.SimpleReference;\n import com.google.javascript.rhino.jstype.SimpleSlot;\n import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.StaticSymbolTable;\n+import com.google.javascript.rhino.jstype.UnionType;\n \n import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n \n import javax.annotation.Nullable;\n  * this symbol table that indexes symbols or references by the desired lookup\n  * key.\n  *\n+ * By design, this symbol table conflates \"type Foo\" with \"the constructor\n+ * that creates objects of type Foo\" when looking up types. JSCompiler\n+ * internally treats these as distinct objects, but we assume that most\n+ * clients will not care about the distinction.\n+ *\n  * @see #addSymbolsFrom For more information on how to write plugins for this\n  *    symbol table.\n  *\n    * they're declared.\n    */\n   private final Map<Node, SymbolScope> scopes = Maps.newHashMap();\n+\n+  private SymbolScope globalScope = null;\n \n   /**\n    * Clients should get a symbol table by asking the compiler at the end\n     String name = NodeUtil.getBestLValueName(\n         NodeUtil.getBestLValue(rootNode));\n     return name == null ? null : scope.getParentScope().getSlot(name);\n+  }\n+\n+  /**\n+   * Get all symbols associated with the type of the given symbol.\n+   *\n+   * For example, given a variable x declared as\n+   * /* @type {Array|Date} /\n+   * var x = f();\n+   * this will return the constructors for Array and Date.\n+   */\n+  public Iterable<Symbol> getAllSymbolsForTypeOf(Symbol sym) {\n+    return getAllSymbolsForType(sym.getType(), sym.scope);\n+  }\n+\n+  /**\n+   * Gets the symbol for the given constuctor or interface.\n+   */\n+  public Symbol getSymbolDeclaredBy(FunctionType fn) {\n+    Preconditions.checkState(fn.isConstructor() || fn.isInterface());\n+    ObjectType instanceType = fn.getInstanceType();\n+    String name = instanceType.getReferenceName();\n+    if (name == null || globalScope == null) {\n+      return null;\n+    }\n+\n+    Node source = fn.getSource();\n+    return (source == null ?\n+        globalScope : getEnclosingScope(source)).getSlot(name);\n+  }\n+\n+  private List<Symbol> getAllSymbolsForType(\n+      JSType type, SymbolScope scope) {\n+    if (type == null) {\n+      return ImmutableList.of();\n+    }\n+    UnionType unionType = type.toMaybeUnionType();\n+    if (unionType != null) {\n+      List<Symbol> result = Lists.newArrayListWithExpectedSize(2);\n+      for (JSType alt : unionType.getAlternates()) {\n+        result.addAll(getAllSymbolsForType(alt, scope));\n+      }\n+      return result;\n+    }\n+\n+    FunctionType fnType = type.toMaybeFunctionType();\n+    if (fnType != null) {\n+      Symbol result = globalScope.getSlot(\"Function\");\n+      return result == null ?\n+          ImmutableList.<Symbol>of() : ImmutableList.of(result);\n+    }\n+\n+    ObjectType objType = type.toObjectType();\n+    if (objType != null) {\n+      String name = objType.getReferenceName();\n+      Symbol result = scope.getSlot(\n+          (name == null || !objType.isInstanceType())\n+          ? \"Object\" : name);\n+      return result == null\n+          ? ImmutableList.<Symbol>of() : ImmutableList.of(result);\n+    }\n+\n+    // TODO(nicksantos): Create symbols for value types (number, string).\n+    return ImmutableList.of();\n   }\n \n   public String toDebugString() {\n       if (otherScopeParent == null) {\n         // The global scope must be created before any local scopes.\n         Preconditions.checkState(\n-            scopes.isEmpty(), \"Global scopes found at different roots\");\n+            globalScope == null, \"Global scopes found at different roots\");\n       }\n \n       myScope = new SymbolScope(\n           otherScopeParent == null ? null : createScopeFrom(otherScopeParent),\n           otherScope.getTypeOfThis());\n       scopes.put(otherScopeRoot, myScope);\n+      if (myScope.isGlobalScope()) {\n+        globalScope = myScope;\n+      }\n     }\n     return myScope;\n   }\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n \n   /** A default set of externs for testing. */\n   static final String DEFAULT_EXTERNS =\n+      \"/** @constructor \\n * @param {*=} opt_value */ \" +\n+      \"function Object(opt_value) {}\" +\n       \"/** @constructor \\n * @param {*} var_args */ \" +\n       \"function Function(var_args) {}\" +\n       \"/** @type {!Function} */ Function.prototype.apply;\" +\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(1, Iterables.size(table.getReferences(fooPrototype)));\n   }\n \n+  public void testSymbolsForType() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"function random() { return 1; }\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @constructor */ function Bar() {}\" +\n+        \"var x = random() ? new Foo() : new Bar();\");\n+\n+    Symbol x = getGlobalVar(table, \"x\");\n+    Symbol foo = getGlobalVar(table, \"Foo\");\n+    Symbol bar = getGlobalVar(table, \"Bar\");\n+    Symbol fooPrototype = getGlobalVar(table, \"Foo.prototype\");\n+    Symbol fn = getGlobalVar(table, \"Function\");\n+    Symbol obj = getGlobalVar(table, \"Object\");\n+    assertEquals(\n+        Lists.newArrayList(foo, bar), table.getAllSymbolsForTypeOf(x));\n+    assertEquals(\n+        Lists.newArrayList(fn), table.getAllSymbolsForTypeOf(foo));\n+    assertEquals(\n+        Lists.newArrayList(obj), table.getAllSymbolsForTypeOf(fooPrototype));\n+    assertEquals(\n+        foo,\n+        table.getSymbolDeclaredBy(\n+            foo.getType().toMaybeFunctionType()));\n+  }\n+\n   private Symbol getGlobalVar(SymbolTable table, String name) {\n     for (Symbol symbol : table.getAllSymbols()) {\n       if (symbol.getName().equals(name) &&", "timestamp": 1313782961, "metainfo": ""}