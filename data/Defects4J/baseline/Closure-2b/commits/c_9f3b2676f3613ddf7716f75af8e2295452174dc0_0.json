{"sha": "9f3b2676f3613ddf7716f75af8e2295452174dc0", "log": "Disambiguate properties fixups for GET/SET property definitions.  R=nicksantos DELTA=104  (101 added, 0 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=479   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n    */\n   private class FindExternProperties extends AbstractScopingCallback {\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+      // TODO(johnlenz): Support object-literal property definitions.\n       if (n.getType() == Token.GETPROP) {\n         String field = n.getLastChild().getString();\n         T type = typeSystem.getType(getScope(), n.getFirstChild(), field);\n     private void handleObjectLit(NodeTraversal t, Node n) {\n       Node child = n.getFirstChild();\n       while (child != null) {\n-        if (child.getType() == Token.STRING) {\n+        // Maybe STRING, NUMBER, GET, SET\n+        if (child.getType() != Token.NUMBER) {\n           // We should never see a mix of numbers and strings.\n           String name = child.getString();\n           T type = typeSystem.getType(getScope(), n, name);\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n     return 1;\n   }\n \n-  public void testOneType() {\n+  public void testOneType1() {\n     String js = \"\"\n         + \"/** @constructor */ function Foo() {}\\n\"\n         + \"Foo.prototype.a = 0;\\n\"\n     testSets(true, js, js, \"{a=[[Foo.prototype]]}\");\n   }\n \n+  public void testOneType2() {\n+    String js = \"\"\n+        + \"/** @constructor */ function Foo() {}\\n\"\n+        + \"Foo.prototype = {a: 0};\\n\"\n+        + \"/** @type Foo */\\n\"\n+        + \"var F = new Foo;\\n\"\n+        + \"F.a = 0;\";\n+    // TODO(johnlenz): fix this. Doing nothing is safe, but\n+    // handling this would be better.\n+    String desired = \"{a=[[Foo.prototype]]}\";\n+    String expected = \"{}\";\n+    testSets(false, js, js, expected);\n+\n+    // Tighten types fails here.\n+    // testSets(true, js, js, expected);\n+  }\n+\n+  public void testOneType3() {\n+    String js = \"\"\n+        + \"/** @constructor */ function Foo() {}\\n\"\n+        + \"Foo.prototype = { get a() {return  0},\"\n+        + \"                  set a(b) {} };\\n\"\n+        + \"/** @type Foo */\\n\"\n+        + \"var F = new Foo;\\n\"\n+        + \"F.a = 0;\";\n+    // TODO(johnlenz): fix this. Doing nothing is safe, but\n+    // handling this would be better.\n+    String desired = \"{a=[[Foo.prototype]]}\";\n+    String expected = \"{}\";\n+    testSets(false, js, js, expected);\n+\n+    // Tighten types fails here.\n+    // testSets(true, js, js, expected);\n+  }\n+\n   public void testPrototypeAndInstance() {\n     String js = \"\"\n         + \"/** @constructor */ function Foo() {}\\n\"\n     testSets(true, js, js, \"{a=[[Foo.prototype]]}\");\n   }\n \n-  public void testTwoTypes() {\n+  public void testTwoTypes1() {\n     String js = \"\"\n         + \"/** @constructor */ function Foo() {}\\n\"\n         + \"Foo.prototype.a = 0;\"\n         + \"B.Bar_prototype$a=0\";\n     testSets(false, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n     testSets(true, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+  }\n+\n+  public void testTwoTypes2() {\n+    String js = \"\"\n+        + \"/** @constructor */ function Foo() {}\\n\"\n+        + \"Foo.prototype = {a: 0};\"\n+        + \"/** @type Foo */\\n\"\n+        + \"var F = new Foo;\\n\"\n+        + \"F.a = 0;\"\n+        + \"/** @constructor */ function Bar() {}\\n\"\n+        + \"Bar.prototype = {a: 0};\"\n+        + \"/** @type Bar */\\n\"\n+        + \"var B = new Bar;\\n\"\n+        + \"B.a = 0;\";\n+\n+    String output = \"\"\n+        + \"function Foo(){}\"\n+        + \"Foo.prototype = {Foo_prototype$a: 0};\"\n+        + \"var F=new Foo;\"\n+        + \"F.Foo_prototype$a=0;\"\n+        + \"function Bar(){}\"\n+        + \"Bar.prototype = {Bar_prototype$a: 0};\"\n+        + \"var B=new Bar;\"\n+        + \"B.Bar_prototype$a=0\";\n+\n+    // Would like it to be (but doing nothing is safe):\n+    // testSets(false, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+    testSets(false, js, js, \"{}\");\n+    // TODO(johnlenz): If tighten types is completed, this needs to be fixed.\n+    // testSets(true, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+  }\n+\n+  public void testTwoTypes3() {\n+    String js = \"\"\n+        + \"/** @constructor */ function Foo() {}\\n\"\n+        + \"Foo.prototype = { get a() {return  0},\"\n+        + \"                  set a(b) {} };\\n\"\n+        + \"/** @type Foo */\\n\"\n+        + \"var F = new Foo;\\n\"\n+        + \"F.a = 0;\"\n+        + \"/** @constructor */ function Bar() {}\\n\"\n+        + \"Bar.prototype = { get a() {return  0},\"\n+        + \"                  set a(b) {} };\\n\"\n+        + \"/** @type Bar */\\n\"\n+        + \"var B = new Bar;\\n\"\n+        + \"B.a = 0;\";\n+\n+    String output = \"\"\n+        + \"function Foo(){}\"\n+        + \"Foo.prototype = { get Foo_prototype$a() {return  0},\"\n+        + \"                  set Foo_prototype$a(b) {} };\\n\"\n+        + \"var F=new Foo;\"\n+        + \"F.Foo_prototype$a=0;\"\n+        + \"function Bar(){}\"\n+        + \"Bar.prototype = { get Bar_prototype$a() {return  0},\"\n+        + \"                  set Bar_prototype$a(b) {} };\\n\"\n+        + \"var B=new Bar;\"\n+        + \"B.Bar_prototype$a=0\";\n+\n+    // Would like it to be (but doing nothing is safe):\n+    // testSets(false, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+    testSets(false, js, js, \"{}\");\n+    // TODO(johnlenz): If tighten types is completed, this needs to be fixed.\n+    // testSets(true, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n   }\n \n   public void testTwoFields() {", "timestamp": 1297212718, "metainfo": ""}