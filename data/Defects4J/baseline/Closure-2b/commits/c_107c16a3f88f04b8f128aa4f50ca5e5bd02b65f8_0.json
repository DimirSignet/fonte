{"sha": "107c16a3f88f04b8f128aa4f50ca5e5bd02b65f8", "log": "Change on 2010/06/10 by nicksantos  \tadd firebugIgnore to externs.  \tR=jparent \tDELTA=7  (7 added, 0 deleted, 0 changed)  Change on 2010/06/11 by nicksantos  \tcreate an externs file for the top-level google namespace.  \tR=jschorr \tDELTA=36  (36 added, 0 deleted, 0 changed)  Change on 2010/06/11 by jschorr  \tRemove non-determinism in the source map generator.  \tR=nicksantos \tDELTA=63  (58 added, 3 deleted, 2 changed)  Change on 2010/06/13 by acleung  \tRemove indentity assignments.  \tR=dcc \tDELTA=20  (20 added, 0 deleted, 0 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=27010   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n         return;\n       }\n       Var var = scope.getVar(name);\n+\n       if (liveness.getEscapedLocals().contains(var)) {\n         return; // Local variable that might be escaped due to closures.\n       }\n+\n+      // If we have an identity assignment such as a=a, always remove it\n+      // regardless of what the liveness results because it\n+      // does not change the result afterward.\n+      if (rhs != null &&\n+          NodeUtil.isName(rhs) &&\n+          rhs.getString().equals(var.name) &&\n+          NodeUtil.isAssign(n)) {\n+        n.removeChild(rhs);\n+        n.getParent().replaceChild(n, rhs);\n+        compiler.reportCodeChange();\n+        return;\n+      }\n+\n       if (state.getOut().isLive(var)) {\n         return; // Variable not dead.\n       }\n+\n       if (state.getIn().isLive(var) &&\n           isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {\n         // The variable is killed here but it is also live before it.\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n import java.io.IOException;\n \n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n \n      * buffer.\n      */\n     void appendFileMapTo(Appendable out) throws IOException {\n+      // Sort the files list for deterministic consistency.\n+      Collections.sort(files);\n+\n       out.append(\"[\");\n \n       for (int j = 0; j < files.size(); ++j) {\n     mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n \n     Object originalName = node.getProp(Node.ORIGINALNAME_PROP);\n-\n     if (originalName != null) {\n       mapping.originalName = originalName.toString();\n     }\n+\n \n     // If the mapping is found on the first line, we need to offset\n     // its character position by the number of characters found on\n       for (int i = 0; i <= lineMapping.length; ++i) {\n         int minLength = Integer.MAX_VALUE;\n         LineCharMapping current = null;\n+\n+        Collections.sort(lineMapping.characterMappings,\n+            new Comparator<LineCharMapping>() {\n+            @Override\n+            public int compare(LineCharMapping first, LineCharMapping second) {\n+              Mapping firstBasis = first.basisMapping;\n+              Mapping secondBasis = second.basisMapping;\n+\n+              String firstName = firstBasis.originalName;\n+              String secondName = secondBasis.originalName;\n+\n+              firstName = firstName == null ? \"\" : firstName;\n+              secondName = secondName == null ? \"\" : secondName;\n+\n+              return firstName.compareTo(secondName);\n+            }\n+          });\n \n         for (LineCharMapping lcm : lineMapping.characterMappings) {\n           // Ignore LCMs that do not include the current character.\n--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n     inFunction(\"for(;1;x+=1){foo(x)}\");\n   }\n \n+  public void testIdentityAssignments() {\n+    inFunction(\"var x; x=x\", \"var x; x\");\n+  }\n+\n   private void inFunction(String src) {\n     inFunction(src, src);\n   }\n--- a/test/com/google/javascript/jscomp/SourceMapTest.java\n+++ b/test/com/google/javascript/jscomp/SourceMapTest.java\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\");\n   }\n \n+  public void testBasicDeterminism() throws Exception {\n+    RunResult result1 = compile(\"file1\", \"foo;\", \"file2\", \"bar;\");\n+    RunResult result2 = compile(\"file2\", \"foo;\", \"file1\", \"bar;\");\n+\n+    String map1 = getSourceMap(result1);\n+    String map2 = getSourceMap(result2);\n+\n+    // Assert that the files section of the maps are the same. The actual\n+    // entries will differ, so we cannot do a simple full comparison.\n+\n+    // Line 5 has the file information.\n+    String files1 = map1.split(\"\\n\")[4];\n+    String files2 = map2.split(\"\\n\")[4];\n+\n+    assertEquals(files1, files2);\n+  }\n+\n   /**\n    * Creates a source map for the given JS code and asserts it is\n    * equal to the expected golden map.\n     checkSourceMap(\"testcode\", js, expectedMap);\n   }\n \n+  private String getSourceMap(RunResult result) throws IOException {\n+    StringBuilder sb = new StringBuilder();\n+    result.sourceMap.appendTo(sb, \"testMap\");\n+    return sb.toString();\n+  }\n+\n   private void checkSourceMap(String fileName, String js, String expectedMap)\n       throws IOException {\n     RunResult result = compile(js, fileName);\n-    StringBuilder sb = new StringBuilder();\n-    result.sourceMap.appendTo(sb, \"testMap\");\n-    assertEquals(expectedMap, sb.toString());\n+    assertEquals(expectedMap, getSourceMap(result));\n   }\n \n   private static class RunResult {\n   }\n \n   private RunResult compile(String js, String fileName) {\n+    return compile(js, fileName, null, null);\n+  }\n+\n+  private RunResult compile(String js1, String fileName1, String js2,\n+      String fileName2) {\n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n     options.sourceMapOutputPath = \"testcode_source_map.out\";\n     // Turn on IDE mode to get rid of optimizations.\n     options.ideMode = true;\n \n-    JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName, js) };\n+    JSSourceFile[] inputs = { JSSourceFile.fromCode(fileName1, js1) };\n+\n+    if (js2 != null && fileName2 != null) {\n+      JSSourceFile[] multiple =  { JSSourceFile.fromCode(fileName1, js1),\n+                                   JSSourceFile.fromCode(fileName2, js2) };\n+      inputs = multiple;\n+    }\n+\n     Result result = compiler.compile(EXTERNS, inputs, options);\n \n     assertTrue(result.success);", "timestamp": 1276548521, "metainfo": ""}