{"sha": "83f6917e503ec7b32570af9e986ad749042d9dcf", "log": "Change on 2010/07/27 09:25:39 by dcc  \tChange NameReferenceGraph#getDefinitionsReferencedAt() to return null when there are no definitions found for a node. \tThis had previously been returning a singleton list with an UnknownDefinition, which is used to mean \"we found a \tdefinition, but we don't know what kind of definition is is\" in other contexts.  \tR=acleung \tDELTA=22  (19 added, 3 deleted, 0 changed)  Change on 2010/07/27 09:30:41 by nicksantos  \tWhen checking provide/require order, always use the module \twhere there was an explicit goog.provide.  \tR=johnlenz \tDELTA=53  (49 added, 1 deleted, 3 changed)  Change on 2010/07/27 09:49:50 by dcc  \tInitial sketch of a side effects analysis.  \tR=acleung \tDELTA=558  (558 added, 0 deleted, 0 changed)  Change on 2010/07/27 09:49:51 by johnlenz  \tFirst phase of supporting data member on interface type declarations.  \tR=nicksantos \tDELTA=45  (20 added, 1 deleted, 24 changed)  Change on 2010/07/27 10:29:17 by dhans  \tMinor typo in a comment fixed.  \tR=johnlenz \tDELTA=1  (0 added, 0 deleted, 1 changed)  Change on 2010/07/27 14:43:46 by chrisn  \tFix module set compilation to generate per-jsmodule sourcemaps by calling reset. Necessitates making reset public.  \tR=kevinz,johnlenz \tDELTA=34  (4 added, 12 deleted, 18 changed)  Change on 2010/07/27 17:13:04 by acleung  \tMapsTest Update  \tR=asalaev,johnlenz   Revision created by MOE tool push_codebase. MOE_MIGRATION=73001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NameReferenceGraph.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraph.java\n import com.google.javascript.jscomp.DefinitionsRemover.AssignmentDefinition;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.DefinitionsRemover.NamedFunctionDefinition;\n-import com.google.javascript.jscomp.DefinitionsRemover.UnknownDefinition;\n import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.Node;\n       List<Definition> decls = nameRef.getDeclarations();\n       if (!decls.isEmpty()) {\n         result.addAll(decls);\n-      } else {\n-        result.add(new UnknownDefinition(useSite, false));\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n         unrecognizedRequires.add(\n             new UnrecognizedRequire(n, ns, t.getSourceName()));\n       } else {\n+        JSModule providedModule = provided.explicitModule;\n+\n+        // This must be non-null, because there was an explicit provide.\n+        Preconditions.checkNotNull(providedModule);\n+\n         JSModule module = t.getModule();\n         if (moduleGraph != null &&\n-            module != provided.firstModule /* covers null case */ &&\n-            !moduleGraph.dependsOn(module,\n-                provided.firstModule)) {\n+            module != providedModule &&\n+            !moduleGraph.dependsOn(module, providedModule)) {\n           compiler.report(\n               t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n-                  provided.firstModule.getName(),\n+                  providedModule.getName(),\n                   module.getName()));\n         }\n       }\n     // The node where the call was explicitly goog.provided. May be null\n     // if the namespace is always provided implicitly.\n     private Node explicitNode = null;\n+    private JSModule explicitModule = null;\n \n     // The candidate definition.\n     private Node candidateDefinition = null;\n         Preconditions.checkState(explicitNode == null);\n         Preconditions.checkArgument(NodeUtil.isExpressionNode(node));\n         explicitNode = node;\n+        explicitModule = module;\n       }\n       updateMinimumModule(module);\n     }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.Set;\n+\n+/**\n+ * A pass that analyzes side effects to determine when it is safe to move\n+ * code from one program point to another.\n+ * \n+ * In its current form, SideEffectsAnalysis is very incomplete; this is\n+ * mostly a sketch to prototype the interface and the broad strokes of\n+ * a possible implementation based on flow-insensitive MOD and REF sets.\n+ * \n+ * See:\n+ * \n+ * Banning, John. \u201cAn efficient way to find the side effects of procedure\n+ *      calls and the aliases of variables.\u201d POPL \u201879.\n+ * \n+ * For an introduction to MOD and REF sets.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class SideEffectsAnalysis implements CompilerPass {\n+\n+  /** The location abstraction used to calculate the effects of code */\n+  private LocationAbstraction locationAbstraction;\n+   \n+  @Override\n+  public void process(Node externs, Node root) {\n+    locationAbstraction = new DegenerateLocationAbstraction();\n+    \n+    // Currently performs no analysis. In the future, this method\n+    // will construct a callgraph and calculate side effects summaries\n+    // for all functions.\n+    // TODO(dcc): Add per-function side effects summaries.\n+  }\n+  \n+  /**\n+   * Determines whether it is safe to move code ({@code source}) across \n+   * an environment to another program point (immediately preceding\n+   * {@code destination}).\n+   * \n+   * <p>The notion of \"environment\" is optimization-specific, but it should \n+   * include any code that could be executed between the source program point\n+   * and the destination program point.\n+   * \n+   * {@code destination} must not be a descendant of {@code source}. \n+   *  \n+   * @param source The node that would be moved\n+   * @param environment An environment representing the code across which\n+   *    the source will be moved.\n+   * @param destination The node before which the source would be moved\n+   * @return Whether it is safe to move the source to the destination\n+   */\n+  public boolean safeToMoveBefore(Node source, \n+      AbstractMotionEnvironment environment,\n+      Node destination) {\n+    Preconditions.checkNotNull(locationAbstraction);\n+    Preconditions.checkArgument(!nodeHasAncestor(destination, source));\n+    \n+    // It is always safe to move pure code.\n+    if (isPure(source)) {\n+      return true;\n+    }\n+\n+    LocationSummary sourceLocationSummary =\n+        locationAbstraction.calculateLocationSummary(source);\n+    \n+    EffectLocation sourceModSet = sourceLocationSummary.getModSet();\n+\n+    // If the source has side effects, then we require that the source\n+    // is executed exactly as many times as the destination.\n+    if (!sourceModSet.isEmpty() &&\n+        !nodesHaveSameControlFlow(source, destination)) {\n+        return false;\n+    }\n+\n+    EffectLocation sourceRefSet = sourceLocationSummary.getRefSet();\n+\n+    Set<Node> environmentNodes = environment.calculateEnvironment();\n+    \n+    LocationSummary environmentLocationSummary =\n+        locationAbstraction.calculateLocationSummary(environmentNodes);\n+    \n+    EffectLocation environmentModSet = environmentLocationSummary.getModSet();\n+\n+    EffectLocation environmentRefSet = environmentLocationSummary.getRefSet();\n+\n+    // If MOD(environment) intersects REF(source) then moving the\n+    // source across the environment could cause the source\n+    // to read an incorrect value.\n+    // If REF(environment) intersects MOD(source) then moving the\n+    // source across the environment could cause the environment\n+    // to read an incorrect value.\n+    // If MOD(environment) intersects MOD(source) then moving the\n+    // source across the environment could cause some later code that reads\n+    // a modified location to get an incorrect value.\n+\n+    if (!environmentModSet.intersectsLocation(sourceRefSet)\n+        && !environmentRefSet.intersectsLocation(sourceModSet)\n+        && !environmentModSet.intersectsLocation(sourceModSet)) {\n+      return true;\n+    } \n+\n+    return false;\n+  }\n+  \n+  /**\n+   * Is the node pure? That is, is it side effect free and does it not depend\n+   * on its environment?\n+   */\n+  private boolean isPure(Node node) {\n+    // For now, we conservatively assume all code is not pure.\n+    // TODO(dcc): Implement isPure().\n+    return false;\n+  }\n+  \n+  /**\n+   * Do the two nodes have the same control flow properties? That is,\n+   * will node1 be executed every time node2 is executed and vice versa?\n+   */\n+  private boolean nodesHaveSameControlFlow(Node node1, Node node2) {\n+    // For now, we conservatively assume not.\n+    // TODO(dcc): Implement nodesHaveSameControlFlow().\n+    return false;\n+  }\n+  \n+  private static boolean nodeHasAncestor(Node node, Node possibleAncestor) {\n+    // Note node is not in node.getAncestors()\n+    \n+    for (Node ancestor : node.getAncestors()) {\n+      if (ancestor == possibleAncestor) {\n+        return true;\n+      }\n+    }\n+   \n+    return false;\n+  }\n+   \n+  /**\n+   * Represents an environment across which code might be moved, i.e. the set\n+   * of code that could be run in between the source and the destination.\n+   * \n+   * SideEffectAnalysis characterizes the code to be moved and the environment\n+   * in order to determine if they interact in such a way as to make the move\n+   * unsafe.\n+   * \n+   * Since determining the environment for an optimization can be tricky,\n+   * we provide several concrete subclasses that common classes of optimizations\n+   * may be able to reuse.\n+   */\n+  public abstract static class AbstractMotionEnvironment {\n+    \n+    /**\n+     * Calculates the set of nodes that this environment represnts.\n+     */\n+    public abstract Set<Node> calculateEnvironment();\n+  }\n+  \n+  /**\n+   * An environment for motion within a function. Given a\n+   * control flow graph and a source and destination node in the control\n+   * flow graph, instances of this object will calculate the environment between\n+   * the source and destination.\n+   */\n+  public static class IntraproceduralMotionEnvironment\n+      extends AbstractMotionEnvironment {\n+       \n+    /**\n+     * Creates an intraprocedural motion environment.\n+     * \n+     * @param controlFlowGraph A control flow graph for function in which\n+     * code will be moved\n+     * @param cfgSource The code to be moved\n+     * @param cfgDestination The node immediately before which cfgSource \n+     * will be moved\n+     */\n+    public IntraproceduralMotionEnvironment(\n+        ControlFlowGraph<Node> controlFlowGraph,\n+        Node cfgSource,\n+        Node cfgDestination) {\n+      \n+    }\n+    \n+    @Override\n+    public Set<Node> calculateEnvironment() {\n+      // TODO(dcc): Implement IntraproceduralMotionEnvironment\n+      return null;\n+    } \n+  }\n+  \n+  /**\n+   * An environment for motion between modules. Given a\n+   * module graph and as well as source and destination nodes and modules,\n+   * instances of this object will calculate the environment between the source\n+   * and destination.\n+   */\n+  public static class CrossModuleMotionEnvironment\n+      extends AbstractMotionEnvironment {\n+\n+    /**\n+     * Creates a cross module code motion environment.\n+     * \n+     * @param sourceNode The code to be moved\n+     * @param sourceModule The module for the code to be moved\n+     * @param destinationNode The node before which sourceNode will be inserted\n+     * @param destinationModule The module that destination is in\n+     * @param moduleGraph The module graph of the entire program\n+     */\n+    public CrossModuleMotionEnvironment(Node sourceNode,\n+        JSModule sourceModule,\n+        Node destinationNode,\n+        JSModule destinationModule,\n+        JSModuleGraph moduleGraph) {\n+      \n+    }\n+    \n+    @Override\n+    public Set<Node> calculateEnvironment() {\n+      // TODO(dcc): Implement CrossModuleMotionEnvironment\n+      return null;\n+    }\n+  }\n+    /**\n+     * A low-level concrete environment that allows the client to specify\n+     * the environment nodes directly. Clients may wish to use this environment\n+     * if none  of the higher-level environments fit their needs.\n+     */\n+  public static class RawMotionEnvironment\n+      extends AbstractMotionEnvironment {\n+    Set<Node> environment;\n+\n+    public RawMotionEnvironment(Set<Node> environment) {\n+      this.environment = environment;\n+    }\n+    \n+    @Override\n+    public Set<Node> calculateEnvironment() {\n+      return environment;\n+    }\n+  }\n+  \n+  /*\n+   * A combined representation for location set summaries.\n+   * \n+   * Basically, it is often easier to shuffle MOD/REF around together; this is\n+   * a value class for that purpose.\n+   */\n+  private static class LocationSummary {\n+    \n+    private EffectLocation modSet;\n+    private EffectLocation refSet;\n+    \n+    public LocationSummary(EffectLocation modSet, EffectLocation refSet) {\n+      this.modSet = modSet;\n+      this.refSet = refSet;\n+    }\n+    \n+    public EffectLocation getModSet() {\n+      return modSet;\n+    }\n+    \n+    public EffectLocation getRefSet() {\n+      return refSet;\n+    }   \n+  }\n+  \n+  /**\n+   * Interface representing the notion of an effect location -- an abstract\n+   * location that can be modified or referenced.\n+   * \n+   * <p>Since there are an infinite number of possible concrete locations\n+   * in a running program, this abstraction must be imprecise (i.e. there\n+   * will be some distinct concrete locations that are indistinguishable\n+   * under the abstraction).\n+   * \n+   * <p>Different location abstractions will provide their\n+   * own implementations of this interface, based on the level and kind\n+   * of precision they provide.\n+   */\n+  private static interface EffectLocation {\n+    \n+    /**\n+     * Does the receiver's effect location intersect a given effect location?\n+     * That is, could any of the concrete storage locations (fields, variables, \n+     * etc.) represented by the receiver be contained in the set of concrete\n+     * storage locations represented by the given abstract effect location.\n+     */\n+    public boolean intersectsLocation(EffectLocation otherLocation);\n+    \n+    /**\n+     * Returns the result of merging the given effect location with\n+     * the receiver. The concrete locations represented by the result must\n+     * include all the concrete locations represented by each of the merged\n+     * locations and may also possibly include more (i.e., a join may\n+     * introduce a loss of precision).\n+     */\n+    public EffectLocation join(EffectLocation otherLocation);\n+    \n+    /**\n+     * Does the effect location represent any possible concrete locations?\n+     */\n+    public boolean isEmpty();\n+  }\n+  \n+  /**\n+   * An abstract class representing a location abstraction. (Here \"abstraction\"\n+   * means an imprecise representation of concrete side effects.)\n+   * \n+   * <p>Implementations of this class will each provide own their \n+   * implementation(s) of SideEffectLocation and methods to determine the side\n+   * effect locations of a given piece of code.\n+   */\n+  private abstract static class LocationAbstraction  {\n+       \n+    /** Calculates the abstraction-specific side effects\n+     * for the node.\n+     */\n+    abstract LocationSummary calculateLocationSummary(Node node);\n+    \n+    /**\n+     * Returns an abstraction-specific EffectLocation representing\n+     * no location.\n+     * \n+     * <p>The bottom location joined with any location should return\n+     * that location.\n+     */\n+    abstract EffectLocation getBottomLocation();\n+\n+    /** \n+     * Calculates the abstraction-specific side effects\n+     * for the node.\n+     */\n+    public LocationSummary calculateLocationSummary(Set<Node> nodes) {     \n+      EffectLocation modAccumulator = getBottomLocation();\n+      EffectLocation refAccumulator = getBottomLocation();\n+          \n+      for (Node node : nodes) {\n+        LocationSummary nodeLocationSummary = calculateLocationSummary(node);\n+         \n+        modAccumulator = modAccumulator.join(nodeLocationSummary.getModSet());\n+        refAccumulator = refAccumulator.join(nodeLocationSummary.getRefSet());\n+      }\n+     \n+      return new LocationSummary(modAccumulator, refAccumulator);\n+    }\n+  }\n+  /**\n+   * A very imprecise location abstraction in which there are only two abstract\n+   * locations: one representing all concrete locations and one for bottom\n+   * (no concrete locations).\n+   * \n+   * This implementation is a thin wrapper on NodeUtil.mayHaveSideEffects()\n+   * and NodeUtil.canBeSideEffected() -- it doesn't add any real value other\n+   * than to prototype the LocationAbstraction interface.\n+   */\n+  private static class DegenerateLocationAbstraction \n+      extends LocationAbstraction {\n+    \n+    private static final EffectLocation EVERY_LOCATION =\n+        new DenegenerateEffectLocation();\n+    \n+    private static final EffectLocation NO_LOCATION =\n+        new DenegenerateEffectLocation();\n+    \n+    @Override\n+    EffectLocation getBottomLocation() {\n+      return NO_LOCATION;\n+    }\n+    \n+    @Override\n+    public LocationSummary calculateLocationSummary(Node node) {\n+      return new LocationSummary(calculateModSet(node), calculateRefSet(node));\n+    }\n+    \n+    EffectLocation calculateRefSet(Node node) {\n+      if (NodeUtil.canBeSideEffected(node)) {\n+        return EVERY_LOCATION;\n+      } else {\n+        return NO_LOCATION;\n+      }\n+    }\n+    \n+    EffectLocation calculateModSet(Node node) {\n+      if (NodeUtil.mayHaveSideEffects(node)) {\n+        return EVERY_LOCATION;\n+      } else {\n+        return NO_LOCATION;\n+      }\n+    }\n+    \n+    private static class DenegenerateEffectLocation implements EffectLocation {\n+       public EffectLocation join(EffectLocation otherLocation) {\n+        if (otherLocation == EVERY_LOCATION) {\n+          return otherLocation;\n+        } else {\n+          return this;\n+        }\n+      }\n+      \n+      public boolean intersectsLocation(EffectLocation otherLocation) {\n+        return this == EVERY_LOCATION && otherLocation == EVERY_LOCATION;\n+      }\n+      \n+      public boolean isEmpty() {\n+        return this == NO_LOCATION;\n+      }\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n   /**\n    * Resets the source map for reuse for the generation of a new source file.\n    */\n-  void reset() {\n+  public void reset() {\n     mappings = Lists.newArrayList();\n     offsetPosition = new Position(0, 0);\n     prefixPosition = new Position(0, 0);\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\",\n           \"enum key {0} must be a syntactic constant\");\n \n-  static final DiagnosticType INTERFACE_FUNCTION_MEMBERS_ONLY =\n-      DiagnosticType.warning(\n-          \"JSC_INTERFACE_FUNCTION_MEMBERS_ONLY\",\n-          \"interface members can only be plain functions or {0}\");\n+  static final DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION =\n+      DiagnosticType.warning(\n+          \"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\",\n+          \"interface members can only be empty property declarations,\"\n+          + \" empty functions{0}\");\n \n   static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY =\n       DiagnosticType.warning(\n       MULTIPLE_VAR_DEF,\n       ENUM_DUP,\n       ENUM_NOT_CONSTANT,\n-      INTERFACE_FUNCTION_MEMBERS_ONLY,\n+      INVALID_INTERFACE_MEMBER_DECLARATION,\n       INTERFACE_FUNCTION_NOT_EMPTY,\n       CONFLICTING_EXTENDED_TYPE,\n       BAD_IMPLEMENTED_TYPE,\n       String property, Node lvalue, Node rvalue) {\n \n     JSType rvalueType = getJSType(rvalue);\n+\n+    // Only 2 values are allowed for methods:\n+    //    goog.abstractMethod\n+    //    function () {};\n+    // or for properties, no assignment such as:\n+    //    InterfaceFoo.prototype.foobar;\n+\n     String abstractMethodName =\n         compiler.getCodingConvention().getAbstractMethodName();\n     if (!rvalueType.isOrdinaryFunction() &&\n         !(rvalue.isQualifiedName() &&\n           rvalue.getQualifiedName().equals(abstractMethodName))) {\n+      // This is bad i18n style but we don't localize our compiler errors.\n+      String abstractMethodMessage = (abstractMethodName != null)\n+         ? \", or \" + abstractMethodName\n+         : \"\";\n       compiler.report(\n-          t.makeError(object, INTERFACE_FUNCTION_MEMBERS_ONLY,\n-              abstractMethodName));\n+          t.makeError(object, INVALID_INTERFACE_MEMBER_DECLARATION,\n+              abstractMethodMessage));\n     }\n \n     if (assign.getLastChild().getType() == Token.FUNCTION\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n         ASSIGN         = 86,  // simple assignment  (=)\n         ASSIGN_BITOR   = 87,  // |=\n         ASSIGN_BITXOR  = 88,  // ^=\n-        ASSIGN_BITAND  = 89,  // |=\n+        ASSIGN_BITAND  = 89,  // &=\n         ASSIGN_LSH     = 90,  // <<=\n         ASSIGN_RSH     = 91,  // >>=\n         ASSIGN_URSH    = 92,  // >>>=\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n   public void testWarnDataPropertyOnInterface3() throws Exception {\n     testTypes(\"/** @interface */ u.T = function () {};\\n\" +\n         \"/** @type {number} */u.T.prototype.x = 1;\",\n-        \"interface members can only be plain functions\" +\n-        \" or goog.abstractMethod\");\n+        \"interface members can only be empty property declarations, \"\n+        + \"empty functions, or goog.abstractMethod\");\n   }\n \n   public void testWarnDataPropertyOnInterface4() throws Exception {\n     testTypes(\"/** @interface */ function T() {};\\n\" +\n         \"/** @type {number} */T.prototype.x = 1;\",\n-        \"interface members can only be plain functions\" +\n-        \" or goog.abstractMethod\");\n+        \"interface members can only be empty property declarations, \"\n+        + \"empty functions, or goog.abstractMethod\");\n   }\n \n   // TODO(user): If we want to support this syntax we should warn about the\n   public void testErrorMismatchingPropertyOnInterface6() throws Exception {\n     testTypes(\"/** @interface */ function T() {};\\n\" +\n         \"/** @return {number} */T.prototype.x = 1\",\n-        \"interface members can only be plain functions or goog.abstractMethod\"\n+        \"interface members can only be empty property declarations, \"\n+        + \"empty functions, or goog.abstractMethod\"\n         );\n   }\n \n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n         });\n   }\n \n+  public void testProvideInIndependentModules2b() {\n+    // TODO(nicksantos): Make this an error.\n+    test(\n+        createModuleStar(\n+            \"goog.provide('apps');\",\n+            \"goog.provide('apps.foo'); apps.foo = function() {};\",\n+            \"goog.provide('apps.foo.B');\"),\n+        new String[] {\n+            \"var apps = {};\",\n+            \"apps.foo = function() {};\",\n+            \"apps.foo.B = {};\",\n+        });\n+  }\n+\n+  public void testProvideInIndependentModules3() {\n+    test(\n+        createModuleStar(\n+            \"goog.provide('apps');\",\n+            \"goog.provide('apps.foo.B');\",\n+            \"goog.provide('apps.foo'); goog.require('apps.foo');\"),\n+        new String[] {\n+            \"var apps = {}; apps.foo = {};\",\n+            \"apps.foo.B = {};\",\n+            \"\",\n+        });\n+  }\n+\n+  public void testProvideInIndependentModules3b() {\n+    // TODO(nicksantos): Make this an error.\n+    test(\n+        createModuleStar(\n+            \"goog.provide('apps');\",\n+            \"goog.provide('apps.foo.B');\",\n+            \"goog.provide('apps.foo'); apps.foo = function() {}; \" +\n+            \"goog.require('apps.foo');\"),\n+        new String[] {\n+            \"var apps = {};\",\n+            \"apps.foo.B = {};\",\n+            \"apps.foo = function() {};\",\n+        });\n+  }\n+\n   public void testRequireOfBaseGoog() {\n     test(\"goog.require('goog');\",\n          \"\", MISSING_PROVIDE_ERROR);\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Tests for SideEffectsAnalysis.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ *\n+ */\n+public class SideEffectsAnalysisTest extends CompilerTestCase {\n+\n+  SideEffectsAnalysis currentProcessor = null;\n+  \n+  Compiler currentCompiler = null;\n+  \n+  Node currentJsRoot = null;\n+  \n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    currentCompiler = compiler;   \n+    currentProcessor = new SideEffectsAnalysis();\n+    \n+    return currentProcessor;\n+  }\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    currentProcessor = null;\n+  }\n+  \n+  public void testSafeToMoveConstantAcrossEmpty() {\n+    SideEffectsAnalysis analysis = compileAndRun(\"1; 2;\");\n+    \n+    Node expression1 = rootJsNodeAtIndex(0);\n+    Node expression2 = rootJsNodeAtIndex(1);\n+       \n+    assertTrue(analysis.safeToMoveBefore(expression1,\n+        environment(), expression2));\n+  }\n+  \n+  public void testSafeToMoveConstantAcrossConstants() {\n+    SideEffectsAnalysis analysis = compileAndRun(\"1; 2; 3;\");\n+    \n+    Node expression1 = rootJsNodeAtIndex(0);\n+    Node expression2 = rootJsNodeAtIndex(1);\n+    Node expression3 = rootJsNodeAtIndex(2);\n+       \n+    assertTrue(analysis.safeToMoveBefore(expression1,\n+        environment(expression2), expression3));\n+  }\n+  \n+  public void testNotSafeToMoveIncrementAcrossRead() {\n+    SideEffectsAnalysis analysis = compileAndRun(\"x++; foo(x); 3;\");\n+    \n+    Node expression1 = rootJsNodeAtIndex(0);\n+    Node expression2 = rootJsNodeAtIndex(1);\n+    Node expression3 = rootJsNodeAtIndex(2);\n+       \n+    assertFalse(analysis.safeToMoveBefore(expression1,\n+        environment(expression2), expression3));\n+  }\n+  \n+  public void testNotSafeToMoveReadAcrossIncrement() {\n+    SideEffectsAnalysis analysis = compileAndRun(\"foo(x); x++; 3;\");\n+    \n+    Node expression1 = rootJsNodeAtIndex(0);\n+    Node expression2 = rootJsNodeAtIndex(1);\n+    Node expression3 = rootJsNodeAtIndex(2);\n+       \n+    assertFalse(analysis.safeToMoveBefore(expression1,\n+        environment(expression2), expression3));\n+  }\n+  \n+  public void testNotSafeToMoveWriteAcrossWrite() {\n+    SideEffectsAnalysis analysis = compileAndRun(\"x = 7; x = 3; 3;\");\n+    \n+    Node expression1 = rootJsNodeAtIndex(0);\n+    Node expression2 = rootJsNodeAtIndex(1);\n+    Node expression3 = rootJsNodeAtIndex(2);\n+       \n+    assertFalse(analysis.safeToMoveBefore(expression1,\n+        environment(expression2), expression3));\n+  }\n+  \n+  Node rootJsNodeAtIndex(int index) {\n+    // We assume currentJsRoot is:\n+    // BLOCK\n+    //   SCRIPT\n+    //     child0\n+    //     child1\n+    Node scriptNode = currentJsRoot.getFirstChild();\n+    \n+    return scriptNode.getChildAtIndex(index);\n+  }\n+  \n+  private SideEffectsAnalysis.AbstractMotionEnvironment environment(\n+      Node ...nodes) {\n+    \n+    return new SideEffectsAnalysis.RawMotionEnvironment(\n+        ImmutableSet.copyOf(nodes));\n+  }\n+  \n+  private SideEffectsAnalysis compileAndRun(String js) {\n+    testSame(\"\", js, null);\n+    \n+    currentJsRoot = currentCompiler.jsRoot;\n+    \n+    return currentProcessor;\n+  } \n+}\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   //public void testWarningOnInterfacePrototype() throws Exception {\n   //  testTypes(\"/** @interface */ u.T = function() {};\\n\" +\n   //      \"/** @return {number} */ u.T.prototype = function() { };\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"e of its definition\");\n   //}\n   //\n   //public void testBadPropertyOnInterface1() throws Exception {\n   //      \"/** @type {number} */u.T.prototype.x;\",\n   //      \"interface members can only be plain functions\");\n   //}\n-  //\n-  //public void testWarnDataPropertyOnInterface2() throws Exception {\n-  //  testTypes(\"/** @interface */ function T() {};\\n\" +\n-  //      \"/** @type {number} */T.prototype.x;\",\n-  //      \"interface members can only be plain functions\");\n-  //}\n+\n+  public void testDataPropertyOnInterface2() throws Exception {\n+    testTypes(\"/** @interface */ function T() {};\\n\" +\n+        \"/** @type {number} */T.prototype.x;\");\n+  }\n \n   public void testWarnDataPropertyOnInterface3() throws Exception {\n     testTypes(\"/** @interface */ u.T = function () {};\\n\" +\n         \"/** @type {number} */u.T.prototype.x = 1;\",\n-        \"interface members can only be plain functions\" +\n-        \" or goog.abstractMethod\");\n+        \"interface members can only be empty property declarations, \"\n+        + \"empty functions, or goog.abstractMethod\");\n   }\n \n   public void testWarnDataPropertyOnInterface4() throws Exception {\n     testTypes(\"/** @interface */ function T() {};\\n\" +\n         \"/** @type {number} */T.prototype.x = 1;\",\n-        \"interface members can only be plain functions\" +\n-        \" or goog.abstractMethod\");\n+        \"interface members can only be empty property declarations, \"\n+        + \"empty functions, or goog.abstractMethod\");\n   }\n \n   // TODO(user): If we want to support this syntax we should warn about the\n   public void testErrorMismatchingPropertyOnInterface6() throws Exception {\n     testTypes(\"/** @interface */ function T() {};\\n\" +\n         \"/** @return {number} */T.prototype.x = 1\",\n-        \"interface members can only be plain functions or goog.abstractMethod\"\n+        \"interface members can only be empty property declarations, \"\n+        + \"empty functions, or goog.abstractMethod\"\n         );\n   }\n ", "timestamp": 1280281378, "metainfo": ""}