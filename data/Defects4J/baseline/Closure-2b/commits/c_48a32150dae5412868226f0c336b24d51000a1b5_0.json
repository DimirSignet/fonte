{"sha": "48a32150dae5412868226f0c336b24d51000a1b5", "log": "add a getDeclaration() method to all StaticSlots  R=acleung DELTA=137  (77 added, 4 deleted, 56 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2553   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n   private void validateName(Name name, boolean isDefined) {\n     // If the name is not defined, emit warnings for each reference. While\n     // we're looking through each reference, check all the module dependencies.\n-    Ref declaration = name.declaration;\n+    Ref declaration = name.getDeclaration();\n     Name parent = name.parent;\n     boolean singleGlobalParentDecl =\n         parent != null &&\n-        parent.declaration != null &&\n+        parent.getDeclaration() != null &&\n         parent.localSets == 0;\n \n     JSModuleGraph moduleGraph = compiler.getModuleGraph();\n         reportBadModuleReference(name, ref);\n       } else if (ref.scope.isGlobal() &&\n           singleGlobalParentDecl &&\n-          parent.declaration.preOrderIndex > ref.preOrderIndex) {\n+          parent.getDeclaration().preOrderIndex > ref.preOrderIndex) {\n         compiler.report(\n             JSError.make(ref.source.getName(), ref.node,\n                 NAME_DEFINED_LATE_WARNING,\n                 name.fullName(),\n                 parent.fullName(),\n-                parent.declaration.source.getName(),\n-                String.valueOf(parent.declaration.node.getLineno())));\n+                parent.getDeclaration().source.getName(),\n+                String.valueOf(parent.getDeclaration().node.getLineno())));\n       }\n     }\n   }\n     compiler.report(\n         JSError.make(ref.source.getName(), ref.node, STRICT_MODULE_DEP_QNAME,\n                      ref.getModule().getName(),\n-                     name.declaration.getModule().getName(),\n+                     name.getDeclaration().getModule().getName(),\n                      name.fullName()));\n   }\n \n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n       if (name.isNamespace() &&\n           (name.aliasingGets > 0 || name.localSets + name.globalSets > 1 ||\n            name.deleteProps > 0)) {\n-        boolean initialized = name.declaration != null;\n+        boolean initialized = name.getDeclaration() != null;\n         for (Ref ref : name.getRefs()) {\n-          if (ref == name.declaration) {\n+          if (ref == name.getDeclaration()) {\n             continue;\n           }\n \n   private void flattenReferencesTo(Name n, String alias) {\n     String originalName = n.fullName();\n     for (Ref r : n.getRefs()) {\n-      if (r == n.declaration) {\n+      if (r == n.getDeclaration()) {\n         // Declarations are handled separately.\n         continue;\n       }\n     // Only flatten the prefix of a name declaration if the name being\n     // initialized is fully qualified (i.e. not an object literal key).\n     String originalName = n.fullName();\n-    if (n.declaration != null && n.declaration.node != null &&\n-        n.declaration.node.getType() == Token.GETPROP) {\n-      flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName);\n+    Ref decl = n.getDeclaration();\n+    if (decl != null && decl.node != null &&\n+        decl.node.getType() == Token.GETPROP) {\n+      flattenNameRefAtDepth(alias, decl.node, depth, originalName);\n     }\n \n     for (Ref r : n.getRefs()) {\n-      if (r == n.declaration) {\n+      if (r == decl) {\n         // Declarations are handled separately.\n         continue;\n       }\n             p, appendPropForAlias(alias, p.getName()));\n \n         if (!p.inExterns && canCollapseChildNames &&\n-            p.declaration != null &&\n+            p.getDeclaration() != null &&\n             p.canCollapse() &&\n-            p.declaration.node != null &&\n-            p.declaration.node.getParent() != null &&\n-            p.declaration.node.getParent().getType() == Token.ASSIGN) {\n+            p.getDeclaration().node != null &&\n+            p.getDeclaration().node.getParent() != null &&\n+            p.getDeclaration().node.getParent().getType() == Token.ASSIGN) {\n           updateSimpleDeclaration(\n-              appendPropForAlias(alias, p.getName()), p, p.declaration);\n+              appendPropForAlias(alias, p.getName()), p, p.getDeclaration());\n         }\n       }\n     }\n    */\n   private void updateObjLitOrFunctionDeclaration(\n       Name n, String alias, boolean canCollapseChildNames) {\n-    if (n.declaration == null) {\n+    Ref decl = n.getDeclaration();\n+    if (decl == null) {\n       // Some names do not have declarations, because they\n       // are only defined in local scopes.\n       return;\n     }\n \n-    if (n.declaration.getTwin() != null) {\n+    if (decl.getTwin() != null) {\n       // Twin declarations will get handled when normal references\n       // are handled.\n       return;\n     }\n \n-    switch (n.declaration.node.getParent().getType()) {\n+    switch (decl.node.getParent().getType()) {\n       case Token.ASSIGN:\n         updateObjLitOrFunctionDeclarationAtAssignNode(\n             n, alias, canCollapseChildNames);\n     // (e.g. a var node before the exprstmt) because the exprstmt might be\n     // the child of an if statement that's not inside a block).\n \n-    Ref ref = n.declaration;\n+    Ref ref = n.getDeclaration();\n     Node rvalue = ref.node.getNext();\n     Node varNode = new Node(Token.VAR);\n     Node varParent = ref.node.getAncestor(3);\n             public void visit(NodeTraversal t, Node n, Node parent) {\n               if (n.getType() == Token.THIS) {\n                 compiler.report(\n-                    JSError.make(name.declaration.getSourceName(), n,\n+                    JSError.make(name.getDeclaration().getSourceName(), n,\n                         UNSAFE_THIS, name.fullName()));\n               }\n             }\n       return;\n     }\n \n-    Ref ref = n.declaration;\n+    Ref ref = n.getDeclaration();\n     String name = ref.node.getString();\n     Node rvalue = ref.node.getFirstChild();\n     Node varNode = ref.node.getParent();\n       return;\n     }\n \n-    Ref ref = n.declaration;\n+    Ref ref = n.getDeclaration();\n     String fnName = ref.node.getString();\n     addStubsForUndeclaredProperties(\n         n, fnName, ref.node.getAncestor(2), ref.node.getParent());\n       if (isJsIdentifier && p != null) {\n         if (!discardKeys) {\n           Ref newAlias =\n-              p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET);\n+              p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET);\n           newAlias.node = refNode;\n           p.addRef(newAlias);\n         }\n \n-        p.declaration.node = nameNode;\n+        p.getDeclaration().node = nameNode;\n \n         if (value.getType() == Token.FUNCTION) {\n           checkForHosedThisReferences(value, value.getJSDocInfo(), p);\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n     List<Name> props;\n \n     /** The first global assignment to a name. */\n-    Ref declaration;\n+    private Ref declaration;\n \n     /** All references to a name. This must contain {@code declaration}. */\n     private List<Ref> refs;\n     @Override\n     public String getName() {\n       return name;\n+    }\n+\n+    @Override\n+    public Ref getDeclaration() {\n+      return declaration;\n     }\n \n     @Override\n    * A global name reference. Contains references to the relevant parse tree\n    * node and its ancestors that may be affected.\n    */\n-  static class Ref implements StaticReference {\n+  static class Ref implements StaticReference<JSType> {\n     enum Type {\n       SET_FROM_GLOBAL,\n       SET_FROM_LOCAL,\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n     // Find all the global names with a @define annotation\n     List<Name> allDefines = Lists.newArrayList();\n     for (Name name : namespace.getNameIndex().values()) {\n+      Ref decl = name.getDeclaration();\n       if (name.docInfo != null && name.docInfo.isDefine()) {\n         // Process defines should not depend on check types being enabled,\n         // so we look for the JSDoc instead of the inferred type.\n           allDefines.add(name);\n         } else {\n           JSError error = JSError.make(\n-              name.declaration.getSourceName(),\n-              name.declaration.node,\n-              INVALID_DEFINE_TYPE_ERROR);\n+              decl.getSourceName(),\n+              decl.node, INVALID_DEFINE_TYPE_ERROR);\n           compiler.report(error);\n         }\n       } else {\n         for (Ref ref : name.getRefs()) {\n-          if (ref == name.declaration) {\n+          if (ref == decl) {\n             // Declarations were handled above.\n             continue;\n           }\n       // Create a map of references to defines keyed by node for easy lookup\n       allRefInfo = Maps.newHashMap();\n       for (Name name : listOfDefines) {\n-        if (name.declaration != null) {\n-          allRefInfo.put(name.declaration.node,\n-                         new RefInfo(name.declaration, name));\n+        Ref decl = name.getDeclaration();\n+        if (decl != null) {\n+          allRefInfo.put(decl.node,\n+                         new RefInfo(decl, name));\n         }\n         for (Ref ref : name.getRefs()) {\n-          if (ref == name.declaration) {\n+          if (ref == decl) {\n             // Declarations were handled above.\n             continue;\n           }\n             Node valParent = getValueParent(ref);\n             Node val = valParent.getLastChild();\n             if (valParent.getType() == Token.ASSIGN && name.isSimpleName() &&\n-                name.declaration == ref) {\n+                name.getDeclaration() == ref) {\n               // For defines, it's an error if a simple name is assigned\n               // before it's declared\n               compiler.report(\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.SimpleSourceFile;\n import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n   /**\n    * Represents a single declaration or reference to a variable.\n    */\n-  static final class Reference implements StaticReference {\n+  static final class Reference implements StaticReference<JSType> {\n \n     private static final Set<Integer> DECLARATION_PARENTS =\n         ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH);\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.util.Iterator;\n import java.util.LinkedHashMap;\n   };\n \n   /** Stores info about a variable */\n-  public static class Var implements StaticSlot<JSType> {\n+  public static class Var\n+      implements StaticSlot<JSType>, StaticReference<JSType> {\n     /** name */\n     final String name;\n \n      */\n     public String getName() {\n       return name;\n+    }\n+\n+    /**\n+     * Gets the node for the name of the variable.\n+     */\n+    @Override\n+    public Node getNode() {\n+      return nameNode;\n+    }\n+\n+    @Override\n+    public StaticSourceFile getSourceFile() {\n+      return input;\n+    }\n+\n+    @Override\n+    public Var getSymbol() {\n+      return this;\n+    }\n+\n+    @Override\n+    public Var getDeclaration() {\n+      return nameNode == null ? null : this;\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.UnionType;\n     @Override public ConcreteType getType() { return type; }\n \n     /** Whether this type was inferred rather than declared (always true). */\n-    public boolean isTypeInferred() { return true; }\n+    @Override public boolean isTypeInferred() { return true; }\n+\n+    @Override public StaticReference<ConcreteType> getDeclaration() {\n+      return null;\n+    }\n \n     /**\n      * Adds the given type to the possible concrete types for this slot.\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n   }\n \n   public String getSourceFileName() {\n-    StaticSourceFile file =\n-        ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n+    StaticSourceFile file = getStaticSourceFile();\n     return file == null ? null : file.getName();\n   }\n \n+  /** Returns the source file associated with this input. May be null */\n+  public StaticSourceFile getStaticSourceFile() {\n+    return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n+  }\n+\n   public boolean isFromExterns() {\n-    StaticSourceFile file =\n-        ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n+    StaticSourceFile file = getStaticSourceFile();\n     return file == null ? false : file.isExtern();\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n   }\n \n   private static final class Property\n-      implements Serializable, StaticSlot<JSType> {\n+      implements Serializable, StaticSlot<JSType>, StaticReference<JSType> {\n     private static final long serialVersionUID = 1L;\n \n     /**\n     }\n \n     @Override\n+    public Node getNode() {\n+      return propertyNode;\n+    }\n+\n+    @Override\n+    public StaticSourceFile getSourceFile() {\n+      return propertyNode == null ? null : propertyNode.getStaticSourceFile();\n+    }\n+\n+    @Override\n+    public Property getSymbol() {\n+      return this;\n+    }\n+\n+    @Override\n+    public Property getDeclaration() {\n+      return propertyNode == null ? null : this;\n+    }\n+\n+    @Override\n     public JSType getType() {\n       return type;\n     }\n--- a/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n   public boolean isTypeInferred() {\n     return inferred;\n   }\n+\n+  public StaticReference<JSType> getDeclaration() {\n+    return null;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/StaticReference.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticReference.java\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n-public interface StaticReference {\n+public interface StaticReference<T> {\n   /**\n    * The variable that this reference points to.\n    */\n-  StaticSlot<JSType> getSymbol();\n+  StaticSlot<T> getSymbol();\n \n   /**\n    * The node where the reference lives.\n--- a/src/com/google/javascript/rhino/jstype/StaticSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticSlot.java\n    * Returns whether the type has been inferred (as opposed to declared).\n    */\n   boolean isTypeInferred();\n+\n+  /** Gets the declaration of this symbol. May not exist. */\n+  StaticReference<T> getDeclaration();\n }\n--- a/src/com/google/javascript/rhino/jstype/StaticSymbolTable.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticSymbolTable.java\n  * @author nicksantos@google.com (Nick Santos)\n  */\n public interface StaticSymbolTable\n-    <S extends StaticSlot<JSType>, R extends StaticReference> {\n+    <S extends StaticSlot<JSType>, R extends StaticReference<JSType>> {\n   /**\n    * Returns the references that point to the given symbol.\n    */\n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.testing.TestErrorReporter;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n-\n \n /**\n  * Unit test for the the subclasses of ConcreteType.\n       this.name = name;\n     }\n \n-    /* {@inheritDoc} */\n+    @Override\n     public String getName() { return name; }\n \n-    /* {@inheritDoc} */\n+    @Override\n     public ConcreteType getType() { return ConcreteType.ALL; }\n \n-    /* {@inheritDoc} */\n+    @Override\n     public boolean isTypeInferred() { return true; }\n+\n+    @Override\n+    public StaticReference<ConcreteType> getDeclaration() { return null; }\n   }\n }\n--- a/test/com/google/javascript/jscomp/GlobalNamespaceTest.java\n+++ b/test/com/google/javascript/jscomp/GlobalNamespaceTest.java\n     n.addRef(set1);\n     n.addRef(set2);\n \n-    assertEquals(set1, n.declaration);\n+    assertEquals(set1, n.getDeclaration());\n     assertEquals(2, n.globalSets);\n     assertEquals(2, n.getRefs().size());\n \n     n.removeRef(set1);\n \n-    assertEquals(set2, n.declaration);\n+    assertEquals(set2, n.getDeclaration());\n     assertEquals(1, n.globalSets);\n     assertEquals(1, n.getRefs().size());\n   }\n     n.addRef(set1);\n     n.addRef(set2);\n \n-    assertEquals(set1, n.declaration);\n+    assertEquals(set1, n.getDeclaration());\n     assertEquals(1, n.globalSets);\n     assertEquals(1, n.localSets);\n     assertEquals(2, n.getRefs().size());\n \n     n.removeRef(set1);\n \n-    assertEquals(null, n.declaration);\n+    assertEquals(null, n.getDeclaration());\n     assertEquals(0, n.globalSets);\n   }\n \n--- a/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n     Name def = namespace.getNameIndex().get(\"DEF\");\n     assertEquals(1, def.getRefs().size());\n     assertEquals(1, def.globalSets);\n-    assertNotNull(def.declaration);\n+    assertNotNull(def.getDeclaration());\n   }\n \n   public void testSimpleReassign3() {\n     Name def = namespace.getNameIndex().get(\"DEF\");\n     assertEquals(2, def.getRefs().size());\n     assertEquals(1, def.globalSets);\n-    assertNotNull(def.declaration);\n+    assertNotNull(def.getDeclaration());\n   }\n \n   public void testReassignAfterRefInConditional() {\n     Name aDotB = namespace.getNameIndex().get(\"a.B\");\n     assertEquals(1, aDotB.getRefs().size());\n     assertEquals(1, aDotB.globalSets);\n-    assertNotNull(aDotB.declaration);\n+    assertNotNull(aDotB.getDeclaration());\n   }\n \n   public void testNamespacedDefine2a() {", "timestamp": 1310483036, "metainfo": ""}