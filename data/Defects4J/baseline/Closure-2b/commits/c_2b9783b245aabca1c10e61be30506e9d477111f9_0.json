{"sha": "2b9783b245aabca1c10e61be30506e9d477111f9", "log": "Add some in-app JVM stat reporting. Borrowed from Dartc.  R=nicksantos DELTA=278  (278 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4318   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   }\n \n   private void outputTracerReport() {\n+    JvmMetrics.maybeWriteJvmMetrics(this.err, \"verbose:pretty:all\");\n+\n     OutputStreamWriter output = new OutputStreamWriter(this.err);\n     try {\n       int runtime = 0;\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/JvmMetrics.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import java.io.PrintStream;\n+import java.lang.management.CompilationMXBean;\n+import java.lang.management.GarbageCollectorMXBean;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.MemoryUsage;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * A class to report jvm/jmx statistics.\n+ * Borrowed from:\n+ * http://code.google.com/p/dart/source/browse/trunk/dart/compiler/java/com/google/dart/compiler/metrics/JvmMetrics.java\n+ */\n+class JvmMetrics {\n+\n+  private static int TABULAR_COLON_POS = 40;\n+  private static long ONE_KILO_BYTE = 1L << 10L;\n+  private static long ONE_MEGA_BYTE = 1L << 20L;\n+  private static long ONE_GIGA_BYTE = 1L << 30L;\n+\n+  public static void maybeWriteJvmMetrics(PrintStream out, String options) {\n+    if (options == null) {\n+      return;\n+    }\n+\n+    boolean verboseMode = false;\n+    boolean prettyMode = false;\n+    StringTokenizer st = new StringTokenizer(options, \":\");\n+    // options are grouped in order 'detail:format:types'\n+    if (st.hasMoreTokens()) {\n+      String mode = st.nextToken();\n+      if (mode.equalsIgnoreCase(\"verbose\")) {\n+        verboseMode = true;\n+      }\n+    }\n+\n+    if (st.hasMoreTokens()) {\n+      String mode = st.nextToken();\n+      if (mode.equalsIgnoreCase(\"pretty\")) {\n+        prettyMode = true;\n+      }\n+    }\n+\n+    if (st.hasMoreTokens()) {\n+      while (st.hasMoreTokens()) {\n+        String types = st.nextToken();\n+        StringTokenizer typeSt = new StringTokenizer(types, \",\");\n+        while (typeSt.hasMoreElements()) {\n+          String type = typeSt.nextToken();\n+          writeMetrics(out, type, verboseMode, prettyMode);\n+        }\n+      }\n+    } else {\n+      // the default\n+      writeMetrics(out, \"all\", verboseMode, prettyMode);\n+    }\n+  }\n+\n+  private static void writeMetrics(\n+      PrintStream out, String type, boolean verbose, boolean pretty) {\n+\n+    if (type.equals(\"gc\") || type.equalsIgnoreCase(\"all\")) {\n+      writeGarbageCollectionStats(out, verbose, pretty);\n+    }\n+    if (type.equals(\"mem\") || type.equalsIgnoreCase(\"all\")) {\n+      writeMemoryMetrics(out, verbose, pretty);\n+    }\n+    if (type.equals(\"jit\") || type.equalsIgnoreCase(\"all\")) {\n+      writeJitMetrics(out, verbose, pretty);\n+    }\n+  }\n+\n+  private static void writeJitMetrics(\n+      PrintStream out, boolean verbose, boolean pretty) {\n+\n+    CompilationMXBean cBean = ManagementFactory.getCompilationMXBean();\n+\n+    String name;\n+    if (verbose) {\n+      name = cBean.getName();\n+    } else {\n+      name = \"total\";\n+    }\n+\n+    if (pretty) {\n+      out.println(\"\\nJIT Stats\");\n+      out.println(String.format(\n+          \"\\t%s jit time: %d ms\", name, cBean.getTotalCompilationTime()));\n+    } else {\n+      out.println(normalizeTabularColonPos(String.format(\"%s-jit-time-ms : %d\",\n+          normalizeName(name), cBean.getTotalCompilationTime())));\n+    }\n+  }\n+\n+  private static void writeOverallMemoryUsage(\n+      PrintStream out, MemoryUsage usage, String prefix, boolean pretty) {\n+    if (pretty) {\n+      out.format(\"\\t%s\\n\", prefix);\n+      out.format(\"\\t\\tavailable         : %s\\n\", formatBytes(usage.getMax()));\n+      out.format(\"\\t\\tcurrent           : %s\\n\", formatBytes(usage.getUsed()));\n+    } else {\n+      prefix = normalizeName(prefix);\n+      out.println(normalizeTabularColonPos(\n+          String.format(prefix + \"-available-bytes : %d\", usage.getMax())));\n+      out.println(normalizeTabularColonPos(\n+          String.format(prefix + \"-current-bytes : %d\", usage.getUsed())));\n+    }\n+  }\n+\n+  private static void writePoolMemoryUsage(PrintStream out, MemoryUsage usage,\n+      MemoryUsage peakUsage, String prefix, boolean pretty) {\n+    if (pretty) {\n+      out.format(\"\\t\\tavailable         : %s\\n\",\n+          formatBytes(usage.getMax()));\n+      out.format(\"\\t\\tpeak              : %s\\n\",\n+          formatBytes(peakUsage.getUsed()));\n+      out.format(\"\\t\\tcurrent           : %s\\n\",\n+          formatBytes(usage.getUsed()));\n+    } else {\n+      out.println(normalizeTabularColonPos(\n+          String.format(prefix + \"-available-bytes : %d\", usage.getMax())));\n+      out.println(normalizeTabularColonPos(\n+          String.format(prefix + \"-peak-bytes : %d\", peakUsage.getUsed())));\n+      out.println(normalizeTabularColonPos(\n+          String.format(prefix + \"-current-bytes : %d\",     usage.getUsed())));\n+    }\n+  }\n+\n+  private static void writeMemoryMetrics(\n+      PrintStream out, boolean verbose, boolean pretty) {\n+    if (pretty) {\n+      out.println(\"\\nMemory usage\");\n+    }\n+\n+    // only show overall stats in verbose mode\n+    if (verbose) {\n+      MemoryMXBean overallMemBean = ManagementFactory.getMemoryMXBean();\n+      MemoryUsage usage = overallMemBean.getHeapMemoryUsage();\n+      writeOverallMemoryUsage(out, usage, \"Heap\", pretty);\n+\n+      usage = overallMemBean.getNonHeapMemoryUsage();\n+      writeOverallMemoryUsage(out, usage, \"Non-heap\", pretty);\n+    }\n+\n+    if (verbose) {\n+      List<MemoryPoolMXBean> mpBeans = ManagementFactory.getMemoryPoolMXBeans();\n+      for (MemoryPoolMXBean mpBean : mpBeans) {\n+        MemoryUsage currentUsage = mpBean.getUsage();\n+        MemoryUsage peakUsage = mpBean.getPeakUsage();\n+        if (pretty) {\n+          out.println(\"\\tPool \" + mpBean.getName());\n+          writePoolMemoryUsage(out, currentUsage, peakUsage, null, true);\n+        } else {\n+          writePoolMemoryUsage(out, currentUsage, peakUsage,\n+              \"mem-pool-\" + normalizeName(mpBean.getName()), false);\n+        }\n+      }\n+    } else {\n+      long available = 0;\n+      long current = 0;\n+      long peak = 0;\n+      List<MemoryPoolMXBean> mpBeans = ManagementFactory.getMemoryPoolMXBeans();\n+      for (MemoryPoolMXBean mpBean : mpBeans) {\n+        MemoryUsage currentUsage = mpBean.getUsage();\n+        available += currentUsage.getMax();\n+        current += currentUsage.getUsed();\n+        MemoryUsage peakUsage = mpBean.getPeakUsage();\n+        peak += peakUsage.getUsed();\n+      }\n+      MemoryUsage summaryUsage = new MemoryUsage(\n+          0, current, current, available);\n+      MemoryUsage summaryPeakUsage = new MemoryUsage(0, peak, peak, peak);\n+      if (pretty) {\n+        out.format(\"\\tAggregate of %d memory pools\\n\", mpBeans.size());\n+        writePoolMemoryUsage(out, summaryUsage, summaryPeakUsage, null, true);\n+      } else {\n+        writePoolMemoryUsage(out, summaryUsage, summaryPeakUsage, \"mem\", false);\n+      }\n+    }\n+  }\n+\n+  private static void writeGarbageCollectionStats(\n+      PrintStream out, boolean verbose, boolean pretty) {\n+    List<GarbageCollectorMXBean> gcBeans =\n+        ManagementFactory.getGarbageCollectorMXBeans();\n+\n+    if (verbose) {\n+      if (pretty) {\n+        out.println(\"\\nGarbage collection stats\");\n+        for (GarbageCollectorMXBean gcBean : gcBeans) {\n+          out.println(\"\\tCollector \" + gcBean.getName());\n+          out.format(\n+              \"\\t\\tcollection count   : %d\\n\", gcBean.getCollectionCount());\n+          out.format(\n+              \"\\t\\tcollection time    : %d ms\\n\", gcBean.getCollectionTime());\n+        }\n+      } else {\n+        for (GarbageCollectorMXBean gcBean : gcBeans) {\n+          String name = normalizeName(gcBean.getName());\n+          out.println(normalizeTabularColonPos(String.format(\"gc-\" + name\n+              + \"-collection-count : %d\", gcBean.getCollectionCount())));\n+          out.println(normalizeTabularColonPos(String.format(\"gc-\" + name\n+              + \"-collection-time-ms : %d\", gcBean.getCollectionTime())));\n+        }\n+      }\n+    } else {\n+      long collectionCount = 0;\n+      long collectionTime = 0;\n+      int collectorCount = gcBeans.size();\n+      for (GarbageCollectorMXBean gcBean : gcBeans) {\n+        collectionCount += gcBean.getCollectionCount();\n+        collectionTime += gcBean.getCollectionTime();\n+      }\n+      if (pretty) {\n+        out.println(\"\\nGarbage collection stats\");\n+        out.format(\"\\tAggregate of %d collectors\\n\", collectorCount);\n+        out.format(\"\\t\\tcollection count   : %d\\n\", collectionCount);\n+        out.format(\"\\t\\tcollection time    : %d ms\\n\", collectionTime);\n+      } else {\n+        String name = normalizeName(\"aggregate\");\n+        out.println(normalizeTabularColonPos(\n+            String.format(\"gc-\" + name + \"-collection-count : %d\",\n+            collectionCount)));\n+        out.println(normalizeTabularColonPos(\n+            String.format(\"gc-\" + name + \"-collection-time-ms : %d\",\n+            collectionTime)));\n+      }\n+    }\n+  }\n+\n+  private static String normalizeName(String name) {\n+    return name.replace(\" \", \"_\").toLowerCase();\n+  }\n+\n+  private static String normalizeTabularColonPos(String string) {\n+    StringBuilder sb = new StringBuilder(string);\n+    int index = sb.indexOf(\":\");\n+    for (; index < TABULAR_COLON_POS; ++index) {\n+      sb.insert(index, ' ');\n+    }\n+    return sb.toString();\n+  }\n+\n+  private static String formatBytes(long numBytes) {\n+    if (numBytes < ONE_KILO_BYTE) {\n+      return String.format(\"%d B\", numBytes);\n+    } else if (numBytes < ONE_MEGA_BYTE) {\n+      return String.format(\"%d KB\", numBytes / ONE_KILO_BYTE);\n+    } else if (numBytes < ONE_GIGA_BYTE) {\n+      return String.format(\"%d MB\", numBytes / ONE_MEGA_BYTE);\n+    } else {\n+      return String.format(\"%d GB\", numBytes / ONE_GIGA_BYTE);\n+    }\n+  }\n+}", "timestamp": 1330736218, "metainfo": ""}