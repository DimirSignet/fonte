{"sha": "29dc33fdb1ff0545cf8490c131531166946368b4", "log": "Some corrections to the \"canCastTo\" relationship. Add some basic tests but the bulk of the tests remain in TypeCheckTest.  R=nicksantos DELTA=106  (94 added, 5 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5882   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/CanCastToVisitor.java\n+++ b/src/com/google/javascript/rhino/jstype/CanCastToVisitor.java\n /**\n  * A \"can cast to\" relationship visitor.\n  */\n-class CanCastToVisitor implements RelationshipVisitor<Boolean>{\n+class CanCastToVisitor implements RelationshipVisitor<Boolean> {\n \n   @Override\n   public Boolean caseUnknownType(JSType thisType, JSType thatType) {\n \n   boolean canCastToUnion(JSType thisType, UnionType unionType) {\n     for (JSType type : unionType.getAlternates()) {\n-      if (type.isVoidType() || type.isNullType()) {\n-        // allow cast from null or undefined to nullable/voidable types.\n-        return thisType.isEquivalentTo(type);\n-      } else {\n-        if (thisType.visit(this, type)) {\n-          return true;\n-        }\n+      if (thisType.visit(this, type)) {\n+        return true;\n       }\n     }\n     return false;\n       // TODO(johnlenz): visit function parts\n       return true;\n     } else {\n-      return false;\n+      return thisType.isSubtype(functionType)\n+          || functionType.isSubtype(thisType);\n     }\n   }\n \n \n   @Override\n   public Boolean caseUnionType(UnionType thisType, JSType thatType) {\n+    boolean visited = false;\n     for (JSType type : thisType.getAlternates()) {\n       if (type.isVoidType() || type.isNullType()) {\n         // Don't allow if the only match between the types is null or void,\n         // otherwise any nullable type would be castable to any other nullable\n         // type and we don't want that.\n       } else {\n+        visited = true;\n         if (type.visit(this, thatType)) {\n           return true;\n         }\n       }\n     }\n+\n+    // Special case the \"null|undefined\" union and allow it to be cast\n+    // to any cast to any type containing allowing either null|undefined.\n+    if (!visited) {\n+      JSType NULL_TYPE = thisType.getNativeType(JSTypeNative.NULL_TYPE);\n+      JSType VOID_TYPE = thisType.getNativeType(JSTypeNative.VOID_TYPE);\n+      return NULL_TYPE.visit(this, thatType) || VOID_TYPE.visit(this, thatType);\n+    }\n+\n     return false;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n       maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n     }\n     if (maybeTypeOfThis instanceof ObjectType) {\n-      typeOfThis = (ObjectType) maybeTypeOfThis;\n+      typeOfThis = maybeTypeOfThis;\n     }\n \n     boolean changed = false;\n--- a/src/com/google/javascript/rhino/testing/Asserts.java\n+++ b/src/com/google/javascript/rhino/testing/Asserts.java\n     assertTypeEquals(a, a.getLeastSupertype(a));\n     assertTypeEquals(a, b.getLeastSupertype(b));\n     assertTypeEquals(a, b.getLeastSupertype(a));\n+\n+    Assert.assertTrue(a.canCastTo(b));\n+    Assert.assertTrue(a.canCastTo(a));\n+    Assert.assertTrue(b.canCastTo(b));\n+    Assert.assertTrue(b.canCastTo(a));\n   }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n               proxyTypeI.isEquivalentTo(proxyTypeJ));\n         }\n \n+        assertTrue(typeJ + \" should be castable to \" + typeI,\n+            typeJ.canCastTo(typeI));\n+        assertTrue(typeJ + \" should be castable to Named \" + namedTypeI,\n+            typeJ.canCastTo(namedTypeI));\n+        assertTrue(typeJ + \" should be castable to Proxy \" + proxyTypeI,\n+            typeJ.canCastTo(proxyTypeI));\n+\n+        assertTrue(\n+            \"Named \" + typeJ + \" should be castable to \" + typeI,\n+            namedTypeJ.canCastTo(typeI));\n+        assertTrue(\n+            \"Named \" + typeJ + \" should be castable to Named \" + typeI,\n+            namedTypeJ.canCastTo(namedTypeI));\n+        assertTrue(\n+            \"Named \" + typeJ + \" should be castable to Proxy \" + typeI,\n+            namedTypeJ.canCastTo(proxyTypeI));\n+\n+        assertTrue(\n+            \"Proxy \" + typeJ + \" should be castable to \" + typeI,\n+            proxyTypeJ.canCastTo(typeI));\n+        assertTrue(\n+            \"Proxy \" + typeJ + \" should be castable to Named \" + typeI,\n+            proxyTypeJ.canCastTo(namedTypeI));\n+        assertTrue(\n+            \"Proxy \" + typeJ + \" should be castable to Proxy \" + typeI,\n+            proxyTypeJ.canCastTo(proxyTypeI));\n+\n         if (checkSubtyping) {\n           if (i <= j) {\n             assertTrue(typeJ + \" should be a subtype of \" + typeI,\n \n   /**\n    * Tests the factory method\n-   * {@link JSTypeRegistry#createAnonymousObjectType()}}.\n+   * {@link JSTypeRegistry#createAnonymousObjectType}}.\n    */\n   public void testCreateAnonymousObjectType() throws Exception {\n     // anonymous\n \n   /**\n    * Tests the factory method\n-   * {@link JSTypeRegistry#createAnonymousObjectType()}} and adds\n+   * {@link JSTypeRegistry#createAnonymousObjectType}} and adds\n    * some properties to it.\n    */\n   public void testCreateAnonymousObjectType2() throws Exception {\n     assertTrue(exceptionThrown);\n   }\n \n+  public void testCanCastTo() {\n+    assertTrue(ALL_TYPE.canCastTo(NULL_TYPE));\n+    assertTrue(ALL_TYPE.canCastTo(VOID_TYPE));\n+    assertTrue(ALL_TYPE.canCastTo(STRING_TYPE));\n+    assertTrue(ALL_TYPE.canCastTo(NUMBER_TYPE));\n+    assertTrue(ALL_TYPE.canCastTo(BOOLEAN_TYPE));\n+    assertTrue(ALL_TYPE.canCastTo(OBJECT_TYPE));\n+\n+    assertFalse(NUMBER_TYPE.canCastTo(NULL_TYPE));\n+    assertFalse(NUMBER_TYPE.canCastTo(VOID_TYPE));\n+    assertFalse(NUMBER_TYPE.canCastTo(STRING_TYPE));\n+    assertTrue(NUMBER_TYPE.canCastTo(NUMBER_TYPE));\n+    assertFalse(NUMBER_TYPE.canCastTo(BOOLEAN_TYPE));\n+    assertFalse(NUMBER_TYPE.canCastTo(OBJECT_TYPE));\n+\n+    assertFalse(STRING_TYPE.canCastTo(NULL_TYPE));\n+    assertFalse(STRING_TYPE.canCastTo(VOID_TYPE));\n+    assertTrue(STRING_TYPE.canCastTo(STRING_TYPE));\n+    assertFalse(STRING_TYPE.canCastTo(NUMBER_TYPE));\n+    assertFalse(STRING_TYPE.canCastTo(BOOLEAN_TYPE));\n+    assertFalse(STRING_TYPE.canCastTo(OBJECT_TYPE));\n+\n+    assertFalse(BOOLEAN_TYPE.canCastTo(NULL_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canCastTo(VOID_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canCastTo(STRING_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canCastTo(NUMBER_TYPE));\n+    assertTrue(BOOLEAN_TYPE.canCastTo(BOOLEAN_TYPE));\n+    assertFalse(BOOLEAN_TYPE.canCastTo(OBJECT_TYPE));\n+\n+    assertFalse(OBJECT_TYPE.canCastTo(NULL_TYPE));\n+    assertFalse(OBJECT_TYPE.canCastTo(VOID_TYPE));\n+    assertFalse(OBJECT_TYPE.canCastTo(STRING_TYPE));\n+    assertFalse(OBJECT_TYPE.canCastTo(NUMBER_TYPE));\n+    assertFalse(OBJECT_TYPE.canCastTo(BOOLEAN_TYPE));\n+    assertTrue(OBJECT_TYPE.canCastTo(OBJECT_TYPE));\n+\n+    assertFalse(BOOLEAN_TYPE.canCastTo(OBJECT_NUMBER_STRING));\n+    assertFalse(OBJECT_NUMBER_STRING.canCastTo(BOOLEAN_TYPE));\n+\n+    assertFalse(ARRAY_TYPE.canCastTo(U2U_FUNCTION_TYPE));\n+    assertFalse(U2U_FUNCTION_TYPE.canCastTo(ARRAY_TYPE));\n+\n+    assertFalse(NULL_VOID.canCastTo(ARRAY_TYPE));\n+    assertTrue(NULL_VOID.canCastTo(createUnionType(ARRAY_TYPE, NULL_TYPE)));\n+\n+    // We currently allow any function to be cast to any other function type\n+    assertTrue(ARRAY_FUNCTION_TYPE.canCastTo(BOOLEAN_OBJECT_FUNCTION_TYPE));\n+\n+  }\n+\n   private static boolean containsType(\n       Iterable<? extends JSType> types, JSType type) {\n     for (JSType alt : types) {", "timestamp": 1354154640, "metainfo": ""}