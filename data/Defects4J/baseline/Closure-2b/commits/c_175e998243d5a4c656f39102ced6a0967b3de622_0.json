{"sha": "175e998243d5a4c656f39102ced6a0967b3de622", "log": "Add --mf_map flag for JSCompiler, which reads a file that gives root path for each input file  R=laszlocsomor,nicksantos DELTA=161  (132 added, 10 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2833   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.javascript.rhino.TokenStream;\n import com.google.protobuf.CodedOutputStream;\n \n+import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.Closeable;\n import java.io.File;\n   private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null;\n   private Supplier<List<JSModule>> modulesSupplierForTesting = null;\n   private Function<Integer, Boolean> exitCodeReceiverForTesting = null;\n+  private Map<String, String> rootRelativePathsMap = null;\n \n   // Bookkeeping to measure optimal phase orderings.\n   private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n \n         inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in));\n         usingStdin = true;\n+        if (!config.outputManifests.isEmpty()) {\n+          throw new FlagUsageException(\"Manifest files cannot be generated \" +\n+              \"when the input is from stdin.\");\n+        }\n+        if (!config.outputBundles.isEmpty()) {\n+          throw new FlagUsageException(\"Bundle files cannot be generated \" +\n+              \"when the input is from stdin.\");\n+        }\n       }\n     }\n     return inputs;\n         return 0;\n       }\n     }\n+\n+    rootRelativePathsMap = constructRootRelativePathsMap();\n \n     if (config.skipNormalOutputs) {\n       // Output the manifest and bundle files if requested.\n         && output != null && output.contains(\"%outname%\");\n   }\n \n+  private void outputManifest() throws IOException {\n+    outputManifestOrBundle(config.outputManifests, true);\n+  }\n+\n+  private void outputBundle() throws IOException {\n+    outputManifestOrBundle(config.outputBundles, false);\n+  }\n+\n   /**\n    * Writes the manifest or bundle of all compiler input files that survived\n    * manage_closure_dependencies, if requested.\n    */\n-  private void outputManifest() throws IOException {\n-    outputManifestOrBundle(config.outputManifests, true);\n-  }\n-\n-  private void outputBundle() throws IOException {\n-    outputManifestOrBundle(config.outputBundles, false);\n-  }\n-\n   private void outputManifestOrBundle(List<String> outputFiles,\n       boolean isManifest) throws IOException {\n     if (outputFiles.isEmpty()) {\n    */\n   private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out)\n       throws IOException {\n-    List<String> names = Lists.newArrayList();\n     for (CompilerInput input : inputs) {\n-      names.add(input.getName());\n-    }\n-    String result = Joiner.on(\"\\n\").join(names);\n-    out.append(result);\n-    out.append(\"\\n\");\n+      String rootRelativePath = rootRelativePathsMap.get(input.getName());\n+      String displayName = rootRelativePath != null\n+                               ? rootRelativePath\n+                               : input.getName();\n+      out.append(displayName);\n+      out.append(\"\\n\");\n+    }\n   }\n \n   /**\n   private void printBundleTo(Iterable<CompilerInput> inputs, Appendable out)\n       throws IOException {\n     for (CompilerInput input : inputs) {\n-      out.append(\"//\" + input.getName() + \"\\n\");\n+      String rootRelativePath = rootRelativePathsMap.get(input.getName());\n+      String displayName = rootRelativePath != null\n+                               ? rootRelativePath\n+                               : input.getName();\n       File file = new File(input.getName());\n-      if (file.canRead()) {\n-        Files.copy(file, inputCharset, out);\n-      }\n+      out.append(\"//\");\n+      out.append(displayName);\n       out.append(\"\\n\");\n-    }\n+      Files.copy(file, inputCharset, out);\n+      out.append(\"\\n\");\n+    }\n+  }\n+\n+  /**\n+   * Construct and return the input root path map. The key is the exec path of\n+   * each input file, and the value is the corresponding root relative path.\n+   */\n+  private Map<String, String> constructRootRelativePathsMap()\n+      throws IOException {\n+    Map<String, String> rootRelativePathsMap = Maps.newLinkedHashMap();\n+    if (!config.manifestMapFile.equals(\"\")) {\n+      File mapFile = new File(config.manifestMapFile);\n+      BufferedReader br = Files.newReader(mapFile, Charsets.UTF_8);\n+      String line;\n+      while ((line = br.readLine()) != null) {\n+        int colonIndex = line.indexOf(':');\n+        Preconditions.checkState(colonIndex > 0);\n+        String execPath = line.substring(0, colonIndex);\n+        String rootRelativePath = line.substring(colonIndex + 1);\n+        Preconditions.checkState(rootRelativePath.indexOf(':') == -1);\n+        rootRelativePathsMap.put(execPath, rootRelativePath);\n+      }\n+    }\n+    return rootRelativePathsMap;\n   }\n \n   private class RunTimeStats {\n     }\n \n     /**\n-     * Set whether the normal outputs of compilation should be skipped\n+     * Sets whether the normal outputs of compilation should be skipped.\n      */\n     private boolean skipNormalOutputs = false;\n \n       this.skipNormalOutputs = skipNormalOutputs;\n       return this;\n     }\n+\n+    /**\n+     * Sets the map file that contains the root paths for input files,\n+     * used to generate human-readable file names in the bundle files.\n+     */\n+    private String manifestMapFile = \"\";\n+\n+    CommandLineConfig setManifestMapFile(String manifestMapFile) {\n+      this.manifestMapFile = manifestMapFile;\n+      return this;\n+    }\n+\n   }\n \n   /**", "timestamp": 1311960366, "metainfo": ""}