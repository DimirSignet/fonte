{"sha": "aa89d05b48332d68b8e6ebcee427b2ac3b4e3184", "log": "Only remove prototype properties defined with simple assigment statements. Fixes issue 459.  R=acleung DELTA=90  (86 added, 0 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2195   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n-      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) &&\n-          n.getType() == Token.GETPROP) {\n+      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n+          && n.getType() == Token.GETPROP\n+          && assign.getParent().getType() == Token.EXPR_RESULT) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n--- a/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n            \"var x = new e; x.a()\");\n   }\n \n-  public void testAliasing() {\n+  public void testAliasing1() {\n     // Aliasing a property is not enough for it to count as used\n     test(\"function e(){}\" +\n            \"e.prototype.method1 = function(){};\" +\n            // aliases\n            \"e.prototype.alias1 = e.prototype.method1;\" +\n            \"e.prototype.alias2 = e.prototype.method2;\" +\n-           \"var x=new e;x.alias1()\",\n+           \"var x=new e; x.alias1()\",\n          \"function e(){}\" +\n            \"e.prototype.method1 = function(){};\" +\n            \"e.prototype.alias1 = e.prototype.method1;\" +\n            \"var x = new e; x.alias1()\");\n+  }\n+\n+  public void testAliasing2() {\n+    // Aliasing a property is not enough for it to count as used\n+    test(\"function e(){}\" +\n+           \"e.prototype.method1 = function(){};\" +\n+           // aliases\n+           \"e.prototype.alias1 = e.prototype.method1;\" +\n+           \"(new e).method1()\",\n+         \"function e(){}\" +\n+           \"e.prototype.method1 = function(){};\" +\n+           \"(new e).method1()\");\n+\n+    // Using an alias should keep it\n+    test(\"function e(){}\" +\n+           \"e.prototype.method1 = function(){};\" +\n+           // aliases\n+           \"e.prototype.alias1 = e.prototype.method1;\" +\n+           \"(new e).alias1()\",\n+         \"function e(){}\" +\n+           \"e.prototype.method1 = function(){};\" +\n+           \"e.prototype.alias1 = e.prototype.method1;\" +\n+           \"(new e).alias1()\");\n+  }\n+\n+  public void testAliasing3() {\n+    // Aliasing a property is not enough for it to count as used\n+    test(\"function e(){}\" +\n+           \"e.prototype.method1 = function(){};\" +\n+           \"e.prototype.method2 = function(){};\" +\n+           // aliases\n+           \"e.prototype['alias1'] = e.prototype.method1;\" +\n+           \"e.prototype['alias2'] = e.prototype.method2;\",\n+         \"function e(){}\" +\n+           \"e.prototype.method1=function(){};\" +\n+           \"e.prototype.method2=function(){};\" +\n+           \"e.prototype[\\\"alias1\\\"]=e.prototype.method1;\" +\n+           \"e.prototype[\\\"alias2\\\"]=e.prototype.method2;\");\n+  }\n+\n+  public void testAliasing4() {\n+    // Aliasing a property is not enough for it to count as used\n+    test(\"function e(){}\" +\n+           \"e.prototype['alias1'] = e.prototype.method1 = function(){};\" +\n+           \"e.prototype['alias2'] = e.prototype.method2 = function(){};\",\n+         \"function e(){}\" +\n+           \"e.prototype[\\\"alias1\\\"]=e.prototype.method1=function(){};\" +\n+           \"e.prototype[\\\"alias2\\\"]=e.prototype.method2=function(){};\");\n+  }\n+\n+  public void testAliasing5() {\n+    // An exported alias must preserved any referenced values in the\n+    // referenced function.\n+    test(\"function e(){}\" +\n+           \"e.prototype.method1 = function(){this.method2()};\" +\n+           \"e.prototype.method2 = function(){};\" +\n+           // aliases\n+           \"e.prototype['alias1'] = e.prototype.method1;\",\n+         \"function e(){}\" +\n+           \"e.prototype.method1=function(){this.method2()};\" +\n+           \"e.prototype.method2=function(){};\" +\n+           \"e.prototype[\\\"alias1\\\"]=e.prototype.method1;\");\n+  }\n+\n+  public void testAliasing6() {\n+    // An exported alias must preserved any referenced values in the\n+    // referenced function.\n+    test(\"function e(){}\" +\n+           \"e.prototype.method1 = function(){this.method2()};\" +\n+           \"e.prototype.method2 = function(){};\" +\n+           // aliases\n+           \"window['alias1'] = e.prototype.method1;\",\n+         \"function e(){}\" +\n+           \"e.prototype.method1=function(){this.method2()};\" +\n+           \"e.prototype.method2=function(){};\" +\n+           \"window['alias1']=e.prototype.method1;\");\n+  }\n+\n+  public void testAliasing7() {\n+    // An exported alias must preserved any referenced values in the\n+    // referenced function.\n+    testSame(\"function e(){}\" +\n+           \"e.prototype['alias1'] = e.prototype.method1 = \" +\n+               \"function(){this.method2()};\" +\n+           \"e.prototype.method2 = function(){};\");\n   }\n \n   public void testStatementRestriction() {", "timestamp": 1307399777, "metainfo": ""}