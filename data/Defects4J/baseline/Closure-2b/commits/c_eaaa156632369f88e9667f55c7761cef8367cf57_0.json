{"sha": "eaaa156632369f88e9667f55c7761cef8367cf57", "log": "Create some exhaustive tests for binary ops  R=johnlenz DELTA=181  (180 added, 0 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=27   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n         break;\n \n       case Token.NAME:\n+        if (undefinedRight) {\n+          result = compareToUndefined(left, op);\n+          break;\n+        }\n+\n         if (rightLiteral) {\n           boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n           if (undefinedLeft) {\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n     public void printSummary() {}\n   }\n \n-  private Compiler createCompiler() {\n+  Compiler createCompiler() {\n     Compiler compiler = new Compiler();\n     return compiler;\n   }\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n  */\n \n package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n /**\n  * Tests for PeepholeFoldConstants in isolation. Tests for the interaction of\n   public void testFoldAdd1() {\n     foldSame(\"x=false+1\");\n   }\n+\n+  public void testFoldLiteralNames() {\n+    foldSame(\"NaN == NaN\");\n+    foldSame(\"Infinity == Infinity\");\n+    foldSame(\"Infinity == NaN\");\n+    fold(\"undefined == NaN\", \"false\");\n+    fold(\"undefined == Infinity\", \"false\");\n+\n+    foldSame(\"Infinity >= Infinity\");\n+    foldSame(\"NaN >= NaN\");\n+  }\n+\n+  private static final List<String> LITERAL_OPERANDS =\n+      ImmutableList.of(\n+          \"null\",\n+          \"undefined\",\n+          \"void 0\",\n+          \"true\",\n+          \"false\",\n+          \"0\",\n+          \"1\",\n+          \"''\",\n+          \"'abc'\",\n+          \"'def'\",\n+          \"NaN\",\n+          \"Infinity\"\n+          // TODO(nicksantos): Add more literals\n+          //\"({})\",\n+          //\"[]\",\n+          //\"[0]\",\n+          //\"Object\",\n+          //\"(function() {})\"\n+          );\n+\n+  public void testInvertibleOperators() {\n+    Map<String, String> inverses = ImmutableMap.<String, String>builder()\n+        .put(\"==\", \"!=\")\n+        .put(\"===\", \"!==\")\n+        .put(\"<=\", \">\")\n+        .put(\"<\", \">=\")\n+        .put(\">=\", \"<\")\n+        .put(\">\", \"<=\")\n+        .put(\"!=\", \"==\")\n+        .put(\"!==\", \"===\")\n+        .build();\n+    Set<String> comparators = ImmutableSet.of(\"<=\", \"<\", \">=\", \">\");\n+    Set<String> equalitors = ImmutableSet.of(\"==\", \"===\");\n+    Set<String> uncomparables = ImmutableSet.of(\"null\", \"undefined\", \"void 0\");\n+    List<String> operators = ImmutableList.copyOf(inverses.values());\n+    for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {\n+      for (int iOperandB = 0;\n+           iOperandB < LITERAL_OPERANDS.size();\n+           iOperandB++) {\n+        for (int iOp = 0; iOp < operators.size(); iOp++) {\n+          String a = LITERAL_OPERANDS.get(iOperandA);\n+          String b = LITERAL_OPERANDS.get(iOperandB);\n+          String op = operators.get(iOp);\n+          String inverse = inverses.get(op);\n+\n+          // Test invertability.\n+          if (comparators.contains(op) &&\n+              (uncomparables.contains(a) || uncomparables.contains(b))) {\n+            // TODO(nicksantos): Eventually, all cases should be collapsed.\n+            assertSameResultsOrUncollapsed(join(a, op, b), \"false\");\n+            assertSameResultsOrUncollapsed(join(a, inverse, b), \"false\");\n+          } else if (a.equals(b) && equalitors.contains(op)) {\n+            if (a.equals(\"NaN\") || a.equals(\"Infinity\")) {\n+              foldSame(join(a, op, b));\n+              foldSame(join(a, inverse, b));\n+            } else {\n+              assertSameResults(join(a, op, b), \"true\");\n+              assertSameResults(join(a, inverse, b), \"false\");\n+            }\n+          } else {\n+            assertNotSameResults(join(a, op, b), join(a, inverse, b));\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  public void testCommutativeOperators() {\n+    List<String> operators =\n+        ImmutableList.of(\n+            \"==\",\n+            \"!=\",\n+            \"===\",\n+            \"!==\",\n+            \"*\",\n+            \"|\",\n+            \"&\",\n+            \"^\");\n+    for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {\n+      for (int iOperandB = iOperandA;\n+           iOperandB < LITERAL_OPERANDS.size();\n+           iOperandB++) {\n+        for (int iOp = 0; iOp < operators.size(); iOp++) {\n+          String a = LITERAL_OPERANDS.get(iOperandA);\n+          String b = LITERAL_OPERANDS.get(iOperandB);\n+          String op = operators.get(iOp);\n+\n+          // Test commutativity.\n+          // TODO(nicksantos): Eventually, all cases should be collapsed.\n+          assertSameResultsOrUncollapsed(join(a, op, b), join(b, op, a));\n+        }\n+      }\n+    }\n+  }\n+\n+  private String join(String operandA, String op, String operandB) {\n+    return operandA + \" \" + op + \" \" + operandB;\n+  }\n+\n+  private void assertSameResultsOrUncollapsed(String exprA, String exprB) {\n+    String resultA = process(exprA);\n+    String resultB = process(exprB);\n+    if (resultA.equals(print(exprA))) {\n+      foldSame(exprA);\n+      foldSame(exprB);\n+    } else {\n+      assertSameResults(exprA, exprB);\n+    }\n+  }\n+\n+  private void assertSameResults(String exprA, String exprB) {\n+    assertEquals(\n+        \"Expressions did not fold the same\\nexprA: \" +\n+        exprA + \"\\nexprB: \" + exprB,\n+        process(exprA), process(exprB));\n+  }\n+\n+  private void assertNotSameResults(String exprA, String exprB) {\n+    assertFalse(\n+        \"Expressions folded the same\\nexprA: \" +\n+        exprA + \"\\nexprB: \" + exprB,\n+        process(exprA).equals(process(exprB)));\n+  }\n+\n+  private String process(String js) {\n+    return printHelper(js, true);\n+  }\n+\n+  private String print(String js) {\n+    return printHelper(js, false);\n+  }\n+\n+  private String printHelper(String js, boolean runProcessor) {\n+    Compiler compiler = createCompiler();\n+    CompilerOptions options = getOptions();\n+    compiler.init(\n+        new JSSourceFile[] {},\n+        new JSSourceFile[] { JSSourceFile.fromCode(\"testcode\", js) },\n+        options);\n+    Node root = compiler.parseInputs();\n+    assertTrue(\"Unexpected parse error(s): \" +\n+        Joiner.on(\"\\n\").join(compiler.getErrors()) +\n+        \"\\nEXPR: \" + js,\n+        root != null);\n+    Node externsRoot = root.getFirstChild();\n+    Node mainRoot = externsRoot.getNext();\n+    if (runProcessor) {\n+      getProcessor(compiler).process(externsRoot, mainRoot);\n+    }\n+    return compiler.toSource(mainRoot);\n+  }\n }", "timestamp": 1291147826, "metainfo": ""}