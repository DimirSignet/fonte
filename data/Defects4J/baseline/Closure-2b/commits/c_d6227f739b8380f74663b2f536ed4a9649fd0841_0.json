{"sha": "d6227f739b8380f74663b2f536ed4a9649fd0841", "log": "Add half-assed support for late-resolved typedefs of union types. The fundamental issue is that NamedType is a proxy wrapper around ObjectTypes, but has always been used for non-object types (like typedef'd unions. I eventually want to move towards the using UnresolvedTypes for type resolution. Under that system, the proxy wrapper gets thrown away. UnresolveTypes would also solve this issue. But that system breaks a whole bunch of assumptions about hash codes and referential transparency, so we're not ready for it yet.  R=johnlenz DELTA=116  (75 added, 0 deleted, 41 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=304858   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n     }\n     // named types\n     if (thatType instanceof NamedType) {\n-      return thisType.isSubtype(((NamedType)thatType).referencedType);\n+      return thisType.isSubtype(((NamedType)thatType).getReferencedType());\n     }\n     return false;\n   }\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n \n   /** Returns the type to which this refers (which is unknown if unresolved). */\n   public JSType getReferencedType() {\n-    return referencedType;\n+    return getReferencedTypeInternal();\n   }\n \n   @Override\n \n     if (resolved) {\n       super.resolveInternal(t, enclosing);\n-      return registry.isLastGeneration() ? referencedType : this;\n+      return registry.isLastGeneration() ?\n+          getReferencedType() : this;\n     }\n \n     resolveViaProperties(t, enclosing);\n     }\n \n     super.resolveInternal(t, enclosing);\n-    return registry.isLastGeneration() ? referencedType : this;\n+    return registry.isLastGeneration() ?\n+        getReferencedType() : this;\n   }\n \n   /**\n    */\n   private boolean resolveViaRegistry(\n       ErrorReporter t, StaticScope<JSType> enclosing) {\n-    ObjectType type = ObjectType.cast(registry.getType(reference));\n+    JSType type = registry.getType(reference);\n     if (type != null) {\n-      setReferencedType(type, t, enclosing);\n+      setReferencedAndResolvedType(type, t, enclosing);\n       return true;\n     }\n     return false;\n     if ((value instanceof FunctionType) &&\n         (value.isConstructor() || value.isInterface())) {\n       FunctionType functionType = (FunctionType) value;\n-      setReferencedType(functionType.getInstanceType(), t, enclosing);\n+      setReferencedAndResolvedType(\n+          functionType.getInstanceType(), t, enclosing);\n     } else if (value instanceof EnumType) {\n-      setReferencedType(((EnumType) value).getElementsType(), t, enclosing);\n+      setReferencedAndResolvedType(\n+          ((EnumType) value).getElementsType(), t, enclosing);\n     } else {\n       // We've been running into issues where people forward-declare\n       // non-named types. (This is legitimate...our dependency management\n     return value;\n   }\n \n-  private void setReferencedType(ObjectType type, ErrorReporter t,\n+  private void setReferencedAndResolvedType(JSType type, ErrorReporter t,\n       StaticScope<JSType> enclosing) {\n-    referencedType = type;\n+    setReferencedType(type);\n     checkEnumElementCycle(t);\n-    setResolvedTypeInternal(referencedType);\n+    setResolvedTypeInternal(getReferencedType());\n   }\n \n   private void handleTypeCycle(ErrorReporter t) {\n-    referencedType = registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n+    setReferencedType(\n+        registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE));\n     t.warning(\"Cycle detected in inheritance chain of type \" + reference,\n         sourceName, lineno, null, charno);\n-    setResolvedTypeInternal(referencedType);\n+    setResolvedTypeInternal(getReferencedType());\n   }\n \n   private void checkEnumElementCycle(ErrorReporter t) {\n+    JSType referencedType = getReferencedType();\n     if (referencedType instanceof EnumElementType &&\n         ((EnumElementType) referencedType).getPrimitiveType() == this) {\n       handleTypeCycle(t);\n         t.warning(\"Unknown type \" + reference, sourceName, lineno, null,\n             charno);\n       } else {\n-        referencedType = registry.getNativeObjectType(\n-            JSTypeNative.CHECKED_UNKNOWN_TYPE);\n+        setReferencedType(\n+            registry.getNativeObjectType(\n+                JSTypeNative.CHECKED_UNKNOWN_TYPE));\n       }\n \n-      setResolvedTypeInternal(referencedType);\n+      setResolvedTypeInternal(getReferencedType());\n     } else {\n       setResolvedTypeInternal(this);\n     }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n+import java.util.Collections;\n import java.util.Set;\n \n /**\n class ProxyObjectType extends ObjectType {\n   private static final long serialVersionUID = 1L;\n \n-  ObjectType referencedType;\n-\n-  ProxyObjectType(JSTypeRegistry registry, ObjectType referencedType) {\n+  private JSType referencedType;\n+  private ObjectType referencedObjType;\n+\n+  ProxyObjectType(JSTypeRegistry registry, JSType referencedType) {\n     super(registry);\n+    setReferencedType(referencedType);\n+  }\n+\n+  JSType getReferencedTypeInternal() {\n+    return referencedType;\n+  }\n+\n+  void setReferencedType(JSType referencedType) {\n     this.referencedType = referencedType;\n+    if (referencedType instanceof ObjectType) {\n+      this.referencedObjType = (ObjectType) referencedType;\n+    } else {\n+      this.referencedObjType = null;\n+    }\n   }\n \n   @Override\n   public String getReferenceName() {\n-    return referencedType.getReferenceName();\n+    return referencedObjType == null ?\n+        \"\" : referencedObjType.getReferenceName();\n   }\n \n   @Override\n   public boolean hasReferenceName() {\n-    return referencedType.hasReferenceName();\n+    return referencedObjType == null ?\n+        null : referencedObjType.hasReferenceName();\n   }\n \n   @Override public boolean matchesNumberContext() {\n \n   @Override\n   public Iterable<ObjectType> getCtorImplementedInterfaces() {\n-    return referencedType.getCtorImplementedInterfaces();\n+    return referencedObjType == null ? Collections.<ObjectType>emptyList() :\n+        referencedObjType.getCtorImplementedInterfaces();\n   }\n \n   @Override\n \n   @Override\n   public ObjectType getImplicitPrototype() {\n-    return referencedType.getImplicitPrototype();\n+    return referencedObjType == null ? null :\n+        referencedObjType.getImplicitPrototype();\n   }\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n       boolean inferred, boolean inExterns) {\n-    return referencedType.defineProperty(propertyName, type, inferred,\n-                                         inExterns);\n+    return referencedObjType == null ? true :\n+        referencedObjType.defineProperty(\n+            propertyName, type, inferred, inExterns);\n   }\n \n   @Override\n   public boolean isPropertyTypeDeclared(String propertyName) {\n-    return referencedType.isPropertyTypeDeclared(propertyName);\n+    return referencedObjType == null ? false :\n+        referencedObjType.isPropertyTypeDeclared(propertyName);\n   }\n \n   @Override\n   public boolean isPropertyTypeInferred(String propertyName) {\n-    return referencedType.isPropertyTypeInferred(propertyName);\n+    return referencedObjType == null ? false :\n+        referencedObjType.isPropertyTypeInferred(propertyName);\n   }\n \n   @Override\n   public boolean isPropertyInExterns(String propertyName) {\n-    return referencedType.isPropertyInExterns(propertyName);\n+    return referencedObjType == null ? false :\n+        referencedObjType.isPropertyInExterns(propertyName);\n   }\n \n   @Override\n   public int getPropertiesCount() {\n-    return referencedType.getPropertiesCount();\n+    return referencedObjType == null ? 0 :\n+        referencedObjType.getPropertiesCount();\n   }\n \n   @Override\n   protected void collectPropertyNames(Set<String> props) {\n-    referencedType.collectPropertyNames(props);\n+    if (referencedObjType != null) {\n+      referencedObjType.collectPropertyNames(props);\n+    }\n   }\n \n   @Override\n \n   @Override\n   public JSType getPropertyType(String propertyName) {\n-    return referencedType.getPropertyType(propertyName);\n+    return referencedObjType == null ?\n+        getNativeType(JSTypeNative.UNKNOWN_TYPE) :\n+        referencedObjType.getPropertyType(propertyName);\n   }\n \n   @Override\n \n   @Override\n   public void setJSDocInfo(JSDocInfo info) {\n-    referencedType.setJSDocInfo(info);\n+    if (referencedObjType != null) {\n+      referencedObjType.setJSDocInfo(info);\n+    }\n   }\n \n   @Override\n   public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n-    return referencedType.getOwnPropertyJSDocInfo(propertyName);\n+    return referencedObjType == null ? null :\n+        referencedObjType.getOwnPropertyJSDocInfo(propertyName);\n   }\n \n   @Override\n   public void setPropertyJSDocInfo(String propertyName, JSDocInfo info,\n       boolean inExterns) {\n-    referencedType.setPropertyJSDocInfo(propertyName, info, inExterns);\n+    if (referencedObjType != null) {\n+      referencedObjType.setPropertyJSDocInfo(propertyName, info, inExterns);\n+    }\n   }\n \n   @Override\n   public boolean hasProperty(String propertyName) {\n-    return referencedType.hasProperty(propertyName);\n+    return referencedObjType == null ? false :\n+        referencedObjType.hasProperty(propertyName);\n   }\n \n   @Override\n   public boolean hasOwnProperty(String propertyName) {\n-    return referencedType.hasOwnProperty(propertyName);\n+    return referencedObjType == null ? false :\n+        referencedObjType.hasOwnProperty(propertyName);\n   }\n \n   @Override\n   public Set<String> getOwnPropertyNames() {\n-    return referencedType.getOwnPropertyNames();\n+    return referencedObjType == null ? ImmutableSet.<String>of() :\n+        referencedObjType.getOwnPropertyNames();\n   }\n \n   @Override\n   public FunctionType getConstructor() {\n-    return referencedType.getConstructor();\n+    return referencedObjType == null ? null :\n+        referencedObjType.getConstructor();\n   }\n \n   @Override\n   public JSType getParameterType() {\n-    return referencedType.getParameterType();\n+    return referencedObjType == null ? null :\n+        referencedObjType.getParameterType();\n   }\n \n   @Override\n   public JSType getIndexType() {\n-    return referencedType.getIndexType();\n+    return referencedObjType == null ? null :\n+        referencedObjType.getIndexType();\n   }\n \n   @Override\n \n   @Override\n   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n-    referencedType = (ObjectType) referencedType.resolve(t, scope);\n+    setReferencedType(referencedType.resolve(t, scope));\n     return this;\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"required: number\");\n   }\n \n+  public void testTypeDef4() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function A() {}\" +\n+        \"/** @constructor */ function B() {}\" +\n+        \"/** @typedef {(A|B)} */ var AB;\" +\n+        \"/** @param {AB} x */ function f(x) {}\" +\n+        \"f(new A()); f(new B()); f(1);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: (A|B|null)\");\n+  }\n+\n+  public void testTypeDef5() throws Exception {\n+    // Notice that the error message is slightly different than\n+    // the one for testTypeDef4, even though they should be the same.\n+    // This is an implementation detail necessary for NamedTypes work out\n+    // ok, and it should change if NamedTypes ever go away.\n+    testTypes(\n+        \"/** @param {AB} x */ function f(x) {}\" +\n+        \"/** @constructor */ function A() {}\" +\n+        \"/** @constructor */ function B() {}\" +\n+        \"/** @typedef {(A|B)} */ var AB;\" +\n+        \"f(new A()); f(new B()); f(1);\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: (AB|null)\");\n+  }\n+\n   public void testCircularTypeDef() throws Exception {\n     testTypes(\n         \"var goog = {};\" +", "timestamp": 1286569153, "metainfo": ""}