{"sha": "1c5d6203ab1152a6dee19149fdca2ecd1d8f585f", "log": "type inference in the delete operator  R=johnlenz DELTA=34  (28 added, 0 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=717   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         n.setJSType(getNativeType(STRING_TYPE));\n         break;\n \n+      case Token.DELPROP:\n       case Token.LT:\n       case Token.LE:\n       case Token.GT:\n         if (objectType.hasProperty(propName) ||\n             !objectType.isInstanceType()) {\n           if (\"prototype\".equals(propName)) {\n-            objectType.defineDeclaredProperty(propName, rightType, false, getprop);\n+            objectType.defineDeclaredProperty(\n+                propName, rightType, false, getprop);\n           } else {\n-            objectType.defineInferredProperty(propName, rightType, false, getprop);\n+            objectType.defineInferredProperty(\n+                propName, rightType, false, getprop);\n           }\n         } else {\n           if (getprop.getFirstChild().getType() == Token.THIS &&\n               getJSType(syntacticScope.getRootNode()).isConstructor()) {\n-            objectType.defineInferredProperty(propName, rightType, false, getprop);\n+            objectType.defineInferredProperty(\n+                propName, rightType, false, getprop);\n           } else {\n             registry.registerPropertyOnType(propName, objectType);\n           }\n                         registry.createFunctionTypeWithNewThisType(\n                             jArgumentFnType, (ObjectType) iArgumentType));\n                   }\n-                  // Warn if the anonymous function literal does not reference this.\n+                  // Warn if the anonymous function literal does not\n+                  // reference this.\n                   if (!NodeUtil.referencesThis(\n                           NodeUtil.getFunctionBody(jArgument))) {\n                     compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n     }\n \n     /**\n-     * Gets the safe estimated scope without knowing if all of the subexpressions\n-     * will be evaluated.\n+     * Gets the safe estimated scope without knowing if all of the\n+     * subexpressions will be evaluated.\n      */\n     FlowScope getJoinedFlowScope() {\n       if (joinedScope == null) {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"condition always evaluates to false\\n\" +\n         \"left : function (): undefined\\n\" +\n         \"right: boolean\");\n+  }\n+\n+  public void testDeleteOperator1() throws Exception {\n+    testTypes(\n+        \"var x = {};\" +\n+        \"/** @return {string} */ function f() { return delete x['a']; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testDeleteOperator2() throws Exception {\n+    testTypes(\n+        \"var obj = {};\" +\n+        \"/** \\n\" +\n+        \" * @param {string} x\\n\" +\n+        \" * @return {Object} */ function f(x) { return obj; }\" +\n+        \"/** @param {?number} x */ function g(x) {\" +\n+        \"  if (x) { delete f(x)['a']; }\" +\n+        \"}\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n   }\n \n   public void testEnumStaticMethod1() throws Exception {", "timestamp": 1299030003, "metainfo": ""}