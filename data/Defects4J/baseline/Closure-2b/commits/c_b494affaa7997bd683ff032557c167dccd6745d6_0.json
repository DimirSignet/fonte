{"sha": "b494affaa7997bd683ff032557c167dccd6745d6", "log": "Speed improvements for CallGraph. - Avoid MultiMaps. - Combine Function and Callsite creation into one traversal. - Speeds up Maps Callgraph creation by 30%, Pinto by 50%. - Still too slow.  R=acleung DELTA=229  (98 added, 102 deleted, 29 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=116006   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CallGraph.java\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.collect.Collections2;\n-import com.google.common.collect.LinkedHashMultimap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.common.collect.Multimap;\n-import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.NameReferenceGraph.Name;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.graph.DiGraph;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.Node;\n \n import java.util.Collection;\n import java.util.Map;\n-import java.util.Set;\n \n /**\n  * A pass the uses a {@link DefinitionProvider} to compute a call graph for an\n public class CallGraph implements CompilerPass { \n   private AbstractCompiler compiler;\n   \n-  /** Maps a function to the callsites contained in that function. */\n-  private Multimap<Function, Callsite> callsitesByContainingFunction =\n-      LinkedHashMultimap.create();\n-  \n   /** \n    * Maps an AST node (with type Token.CALL or Token.NEW) to a Callsite object.\n    */\n    */\n   private boolean computeBackwardGraph;\n   \n-  /** \n-   * Maps a function to the callsites targeting that function. \n-   *\n-   * This data structure is only filled in if computeBackwardGraph is true.\n-   */\n-  private Multimap<Function, Callsite> callsitesByTargetingFunction;\n-  \n   /**\n    * Will the call graph support looking up the functions that a given callsite\n    * can call?\n    */\n   private boolean computeForwardGraph;\n  \n-  /**\n-   * Maps a callsite to the functions known to be targeted by that callsite. \n-   * \n-   * This data structure is only filled in if computeBackwardGraph if false.\n-   */\n-  private Multimap<Callsite, Function> targetFunctionsByCallsite;\n-  \n   /**\n    * If true, then the callgraph will use NameReferenceGraph as a \n    * definition provider; otherwise, use the faster SimpleDefinitionProvider.\n     \n     callsitesByNode = Maps.newLinkedHashMap();\n     functionsByNode = Maps.newLinkedHashMap();\n-    \n-    if (computeForwardGraph) {\n-      targetFunctionsByCallsite = LinkedHashMultimap.create();\n-    }\n-    \n-    if (computeBackwardGraph) {\n-      callsitesByTargetingFunction = LinkedHashMultimap.create();    \n-    }\n   }\n   \n   /**\n   @Override\n   public void process(Node externsRoot, Node jsRoot) {\n     Preconditions.checkState(alreadyRun == false);\n- \n-    createFunctions(jsRoot);\n-    \n-    // Depends on createFunctions already being called.\n-    createCallsites();\n-      \n+    \n     DefinitionProvider definitionProvider =\n         constructDefinitionProvider(externsRoot, jsRoot);\n     \n-    // Depends on createCallsites already being called\n-    connectCallsitesToTargets(definitionProvider);\n+    createFunctionsAndCallsites(jsRoot, definitionProvider);\n     \n     fillInFunctionInformation(definitionProvider);\n     \n    * Returns a collection of all callsites in the call graph.\n    */\n   public Collection<Callsite> getAllCallsites() {\n-   return callsitesByContainingFunction.values();\n+   return callsitesByNode.values();\n+  }\n+  \n+  /**\n+   * Creates {@link Function}s and {@link Callsite}s in a single\n+   * AST traversal.\n+   */\n+  private void createFunctionsAndCallsites(Node jsRoot,\n+      final DefinitionProvider provider) {\n+    // Create fake function representing global execution\n+    mainFunction = createFunction(jsRoot);\n+    \n+    NodeTraversal.traverse(compiler, jsRoot, new AbstractPostOrderCallback() {    \n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        int nodeType = n.getType();\n+        \n+        if (nodeType == Token.CALL || nodeType == Token.NEW) {\n+          Callsite callsite = createCallsite(n);\n+          \n+          Node containingFunctionNode = t.getScopeRoot();\n+          \n+          Function containingFunction =\n+              functionsByNode.get(containingFunctionNode);\n+          \n+          if (containingFunction == null) {\n+            containingFunction = createFunction(containingFunctionNode);\n+          }\n+          callsite.containingFunction = containingFunction;\n+          containingFunction.addCallsiteInFunction(callsite);\n+          \n+          connectCallsiteToTargets(callsite, provider);\n+          \n+        } else if (NodeUtil.isFunction(n)) {\n+          if (!functionsByNode.containsKey(n)) {\n+            createFunction(n);\n+          }\n+        }       \n+      }\n+    });\n   }\n   \n   /**\n     return function;\n   }\n   \n-  private void createFunctions(Node jsRoot) {\n-    // Create fake function representing global execution\n-    mainFunction = createFunction(jsRoot);\n-    \n-    for (Node n : collectAllFunctionNodesInSubtree(jsRoot)) {\n-      createFunction(n);\n-    }\n-  }\n-  \n   private Callsite createCallsite(Node callsiteNode) {\n     Callsite callsite = new Callsite(callsiteNode);   \n     callsitesByNode.put(callsiteNode, callsite);\n     return callsite;\n   }\n   \n-  private void createCallsites() {\n-    for (Function function : getAllFunctions()) {\n-      Collection<Node> callsitesInFunction =\n-          collectCallsiteNodesInShallowSubtree(function.getBodyNode());\n-          \n-      for (Node callsiteNode : callsitesInFunction) {    \n-        Callsite callsite = createCallsite(callsiteNode);\n-      \n-        callsitesByContainingFunction.put(function, callsite);       \n-        callsite.containingFunction = function;\n-      }\n-    }\n-  }\n-  \n-  /**\n-   * Maps each Callsite to the Function(s) it could call \n+  /**\n+   * Maps a Callsite to the Function(s) it could call \n    * and each Function to the Callsite(s) that could call it.\n    * \n-   * If the definitionProvider cannot determine the target of a Callsite,\n+   * If the definitionProvider cannot determine the target of the Callsite,\n    * the Callsite's hasUnknownTarget field is set to true.\n    * \n-   * If the definitionProvider determines that the target of a Callsite\n+   * If the definitionProvider determines that the target of the Callsite\n    * could be an extern-defined function, then the Callsite's hasExternTarget\n    * field is set to true.\n    * \n+   * @param callsite The callsite for which target functions should be found\n    * @param definitionProvider The DefinitionProvider used to determine\n    *    targets of callsites.\n    */\n-  private void connectCallsitesToTargets(DefinitionProvider definitionProvider)\n-      {  \n-    for (Function function : getAllFunctions()) {\n-      for (Callsite callsite : callsitesByContainingFunction.get(function)) {\n-        Collection<Definition> definitions =\n-            lookupDefinitionsForTargetsOfCall(callsite.getAstNode(),\n-                definitionProvider);\n-\n-        if (definitions == null) {\n-          callsite.hasUnknownTarget = true; \n+  private void connectCallsiteToTargets(Callsite callsite,\n+      DefinitionProvider definitionProvider) { \n+    Collection<Definition> definitions =\n+      lookupDefinitionsForTargetsOfCall(callsite.getAstNode(),\n+          definitionProvider);\n+\n+    if (definitions == null) {\n+      callsite.hasUnknownTarget = true; \n+    } else {\n+      for (Definition definition : definitions) {\n+        if (definition.isExtern()) {\n+          callsite.hasExternTarget = true;\n         } else {\n-          for (Definition definition : definitions) {\n-            if (definition.isExtern()) {\n-              callsite.hasExternTarget = true;\n-            } else {\n-              Node target = definition.getRValue();\n-\n-              if (target != null && NodeUtil.isFunction(target)) {\n-                Function targetFunction = functionsByNode.get(target);\n-                \n-                if (computeForwardGraph) {\n-                  targetFunctionsByCallsite.put(callsite, targetFunction);\n-                }\n-                \n-                if (computeBackwardGraph) {\n-                  callsitesByTargetingFunction.put(targetFunction, callsite);\n-                }\n-              } else {\n-                  callsite.hasUnknownTarget = true;                 \n-              }\n+          Node target = definition.getRValue();\n+\n+          if (target != null && NodeUtil.isFunction(target)) {\n+            Function targetFunction = functionsByNode.get(target);\n+            \n+            if (targetFunction == null) {\n+              targetFunction = createFunction(target);\n             }\n+            \n+            if (computeForwardGraph) {\n+              callsite.addPossibleTarget(targetFunction);\n+            }\n+\n+            if (computeBackwardGraph) {\n+              targetFunction.addCallsitePossiblyTargetingFunction(callsite);\n+            }\n+          } else {\n+            callsite.hasUnknownTarget = true;                 \n           }\n         }\n       }\n     return null;\n   }\n   \n-  private Set<Node> collectAllFunctionNodesInSubtree(Node subtree) {\n-    final Set<Node> functionNodes = Sets.newLinkedHashSet();\n-    \n-    NodeTraversal.traverse(compiler, subtree, new AbstractPostOrderCallback() {  \n-      @Override\n-      public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (NodeUtil.isFunction(n)) {\n-          functionNodes.add(n);\n-        }\n-      }\n-    });\n-    \n-    return functionNodes;\n-  }\n-  \n-  private Collection<Node> collectCallsiteNodesInShallowSubtree(Node subtree) {  \n-    final Collection<Node> callsites = Sets.newLinkedHashSet();\n-    \n-    NodeTraversal.traverse(compiler, subtree, new AbstractShallowCallback() {  \n-      @Override\n-      public void visit(NodeTraversal t, Node potentialCallsite, Node parent) {\n-        int nodeType = potentialCallsite.getType();       \n-        if (nodeType == Token.CALL || nodeType == Token.NEW) {\n-          callsites.add(potentialCallsite);\n-        }   \n-      }\n-    });\n-    \n-    return callsites;\n-  }\n-  \n   /**\n    * An inner class that represents functions in the call graph.\n    * A Function knows how to get its AST node and what Callsites\n     private boolean isAliased = false;\n     \n     private boolean isExposedToCallOrApply = false;\n+    \n+    private Collection<Callsite> callsitesInFunction;\n+    \n+    private Collection<Callsite> callsitesPossiblyTargetingFunction;\n     \n     private Function(Node functionAstNode) {\n       astNode = functionAstNode;\n     }\n     \n     /**\n-     * Returns the callsites in this functon.\n+     * Returns the callsites in this function.\n      */\n     public Collection<Callsite> getCallsitesInFunction() {\n-      return CallGraph.this.callsitesByContainingFunction.get(this);\n+      if (callsitesInFunction != null) {\n+        return callsitesInFunction;\n+      } else {\n+        return ImmutableList.of();\n+      }\n+    }\n+    \n+    private void addCallsiteInFunction(Callsite callsite) {\n+      if (callsitesInFunction == null) {\n+        callsitesInFunction = Lists.newLinkedList(callsite);\n+      } else {\n+        callsitesInFunction.add(callsite);\n+      }\n     }\n     \n     /**\n      */\n     public Collection<Callsite> getCallsitesPossiblyTargetingFunction() {\n       if (computeBackwardGraph) {\n-        return CallGraph.this.callsitesByTargetingFunction.get(this);\n+        if (callsitesPossiblyTargetingFunction != null) {\n+          return callsitesPossiblyTargetingFunction;\n+        } else {\n+          return ImmutableList.of();\n+        }\n       } else {\n         throw new UnsupportedOperationException(\"Cannot call \" +\n             \"getCallsitesPossiblyTargetingFunction() on a Function \"\n-            + \"from a backward-forward CallGraph\");\n+            + \"from a non-backward CallGraph\");\n+      }\n+    }\n+    \n+    private void addCallsitePossiblyTargetingFunction(Callsite callsite) {\n+      Preconditions.checkState(computeBackwardGraph);\n+      if (callsitesPossiblyTargetingFunction == null) {\n+        callsitesPossiblyTargetingFunction = Lists.newLinkedList(callsite);\n+      } else {\n+        callsitesPossiblyTargetingFunction.add(callsite);\n       }\n     }\n   \n     private boolean hasExternTarget = false;\n      \n     private Function containingFunction = null;\n+    \n+    private Collection<Function> possibleTargets;\n     \n     private Callsite(Node callsiteAstNode) {\n       astNode = callsiteAstNode;\n      */\n     public Collection<Function> getPossibleTargets() {\n       if (computeForwardGraph) {\n-        return CallGraph.this.targetFunctionsByCallsite.get(this);\n+        if (possibleTargets != null) {\n+          return possibleTargets;\n+        } else {\n+          return ImmutableList.of();\n+        }\n       } else {\n         throw new UnsupportedOperationException(\"Cannot call \" +\n             \"getPossibleTargets() on a Callsite from a non-forward \" +\n             \"CallGraph\");\n+      }\n+    }\n+    \n+    private void addPossibleTarget(Function target) {\n+      Preconditions.checkState(computeForwardGraph);\n+      \n+      if (possibleTargets == null) {\n+        possibleTargets = Lists.newLinkedList(target);\n+      } else {\n+        possibleTargets.add(target);\n       }\n     }\n     ", "timestamp": 1281727630, "metainfo": ""}