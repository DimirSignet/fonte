{"sha": "0593df4f98c349d98fd00595966477494a0bcd29", "log": "If a variable is referenced from the externs, but not declared in the externs, then create a synthetic extern for it. This prevents a compiler crash where code removal removes all references to a variable in normal code, but there are still references in the externs.  R=acleung DELTA=143  (103 added, 24 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=203478   ", "commit": "\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n+import java.util.Set;\n \n /**\n  * Checks that all variables are declared, that file-private variables are\n \n   private CompilerInput synthesizedExternsInput = null;\n   private Node synthesizedExternsRoot = null;\n+\n+  // Vars that still need to be declared in externs. These will be declared\n+  // at the end of the pass, or when we see the equivalent var declared\n+  // in the normal code.\n+  private Set<String> varsToDeclareInExterns = Sets.newHashSet();\n \n   private final AbstractCompiler compiler;\n \n     NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());\n     NodeTraversal.traverseRoots(\n         compiler, Lists.newArrayList(externs, root), this);\n+    for (String varName : varsToDeclareInExterns) {\n+      createSynthesizedExternVar(varName);\n+    }\n   }\n \n   @Override\n         t.report(n, INVALID_FUNCTION_DECL);\n       }\n       return;\n+    }\n+\n+    // Check if this is a declaration for a var that has been declared\n+    // elsewhere. If so, mark it as a duplicate.\n+    if ((parent.getType() == Token.VAR ||\n+         NodeUtil.isFunctionDeclaration(parent)) &&\n+        varsToDeclareInExterns.contains(varName)) {\n+      createSynthesizedExternVar(varName);\n+\n+      parent.addSuppression(\"duplicate\");\n     }\n \n     // Check that the var has been declared.\n         if (sanityCheck) {\n           throw new IllegalStateException(\"Unexpected variable \" + varName);\n         } else {\n-          // Create a new variable in a synthetic script. This will prevent\n-          // subsequent compiler passes from crashing.\n-          Node nameNode = Node.newString(Token.NAME, varName);\n-\n-          // Mark the variable as constant if it matches the coding convention\n-          // for constant vars.\n-          // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n-          // AFAIK, all people who use the CONST coding convention also\n-          // compile with undeclaredVars as errors. We have some test\n-          // cases for this configuration though, and it makes them happier.\n-          if (compiler.getCodingConvention().isConstant(varName)) {\n-            nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-          }\n-\n-          getSynthesizedExternsRoot().addChildToBack(\n-              new Node(Token.VAR, nameNode));\n-          scope.getGlobalScope().declare(varName, nameNode,\n+          createSynthesizedExternVar(varName);\n+          scope.getGlobalScope().declare(varName, n,\n               null, getSynthesizedExternsInput());\n         }\n       }\n   }\n \n   /**\n+   * Create a new variable in a synthetic script. This will prevent\n+   * subsequent compiler passes from crashing.\n+   */\n+  private void createSynthesizedExternVar(String varName) {\n+    Node nameNode = Node.newString(Token.NAME, varName);\n+\n+    // Mark the variable as constant if it matches the coding convention\n+    // for constant vars.\n+    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // AFAIK, all people who use the CONST coding convention also\n+    // compile with undeclaredVars as errors. We have some test\n+    // cases for this configuration though, and it makes them happier.\n+    if (compiler.getCodingConvention().isConstant(varName)) {\n+      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    }\n+\n+    getSynthesizedExternsRoot().addChildToBack(\n+        new Node(Token.VAR, nameNode));\n+    varsToDeclareInExterns.remove(varName);\n+  }\n+\n+  /**\n    * A check for name references in the externs inputs. These used to prevent\n    * a variable from getting renamed, but no longer have any effect.\n    */\n               Scope.Var var = scope.getVar(n.getString());\n               if (var == null) {\n                 t.report(n, UNDEFINED_EXTERN_VAR_ERROR, n.getString());\n+                varsToDeclareInExterns.add(n.getString());\n               }\n             }\n             break;\n           default:\n             t.report(n, NAME_REFERENCE_IN_EXTERNS_ERROR, n.getString());\n+\n+            Scope scope = t.getScope();\n+            Scope.Var var = scope.getVar(n.getString());\n+            if (var == null) {\n+              varsToDeclareInExterns.add(n.getString());\n+            }\n             break;\n         }\n       }\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n \n import java.io.Serializable;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n \n /**\n  * <p>JSDoc information describing JavaScript code. JSDoc is represented as a\n   }\n \n   /**\n+   * Add a suppressed warning.\n+   */\n+  void addSuppression(String suppression) {\n+    lazyInitInfo();\n+\n+    if (info.suppressions == null) {\n+      info.suppressions = Sets.newHashSet();\n+    }\n+    info.suppressions.add(suppression);\n+  }\n+\n+  /**\n    * Sets suppressed warnings.\n    * @param suppressions A list of suppressed warning types.\n    */\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       DIRECTIVES         = 47,    // The ES5 directives on this node.\n       DIRECT_EVAL        = 48,    // ES5 distinguishes between direct and\n                                   // indirect calls to eval.\n-      SUPPRESSIONS       = 49,    // Used by the compiler to associate\n-                                  // @suppress directly with functions\n-                                  // and scripts.\n-      FREE_CALL          = 50,    // A CALL without an explicit \"this\" value.\n+      FREE_CALL          = 49,    // A CALL without an explicit \"this\" value.\n                                   //\n-      LAST_PROP          = 50;\n+      LAST_PROP          = 49;\n \n   // values of ISNUMBER_PROP to specify\n   // which of the children are Number types\n   }\n \n   /**\n-   * Sets the warning suppressions on this node.\n-   */\n-  public void setSuppressions(Set<String> val) {\n-    Preconditions.checkState(type == Token.FUNCTION || type == Token.SCRIPT);\n-    putProp(SUPPRESSIONS, val);\n-  }\n-\n-  /**\n-   * Returns the set of supressions for this node.\n-   */\n-  @SuppressWarnings(\"unchecked\")\n-  public Set<String> getSuppressions() {\n-    return (Set<String>) getProp(SUPPRESSIONS);\n+   * Adds a warning to be suppressed. This is indistinguishable\n+   * from having a {@code @suppress} tag in the code.\n+   */\n+  public void addSuppression(String warning) {\n+    if (getJSDocInfo() == null) {\n+      setJSDocInfo(new JSDocInfo(false));\n+    }\n+    getJSDocInfo().addSuppression(warning);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n   }\n \n   @Override\n-  protected CompilerPass getProcessor(Compiler compiler) {\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+    if (!sanityCheck) {\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          new VarCheck(compiler, false).process(externs, root);\n+          if (!compiler.hasErrors()) {\n+            new VarCheck(compiler, true).process(externs, root);\n+          }\n+        }\n+      };\n+    }\n     return new VarCheck(compiler, sanityCheck);\n   }\n \n   public void testMultiplyDeclaredVars3() {\n     test(\"try { var x = 1; x *=2; } catch (x) {}\", null,\n          SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+  }\n+\n+  public void testMultiplyDeclaredVars4() {\n+    testSame(\"x;\", \"var x = 1; var x = 2;\",\n+         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR, true);\n   }\n \n   public void testVarReferenceInExterns() {\n   // Test synthesis of externs\n \n   public void testSimple() {\n-    checkSynthesizedExtern(\"x\", \"var x\");\n+    checkSynthesizedExtern(\"x\", \"var x;\");\n     checkSynthesizedExtern(\"var x\", \"\");\n   }\n \n \n   public void testNoCreateVarsForLabels() {\n     checkSynthesizedExtern(\"x:var y\", \"\");\n+  }\n+\n+  public void testVariableInNormalCodeUsedInExterns1() {\n+    checkSynthesizedExtern(\n+        \"x.foo;\", \"var x;\", \"var x; x.foo;\");\n+  }\n+\n+  public void testVariableInNormalCodeUsedInExterns2() {\n+    checkSynthesizedExtern(\n+        \"x;\", \"var x;\", \"var x; x;\");\n+  }\n+\n+  public void testVariableInNormalCodeUsedInExterns3() {\n+    checkSynthesizedExtern(\n+        \"x.foo;\", \"function x() {}\", \"var x; x.foo; \");\n+  }\n+\n+  public void testVariableInNormalCodeUsedInExterns4() {\n+    checkSynthesizedExtern(\n+        \"x;\", \"function x() {}\", \"var x; x; \");\n   }\n \n   private final static class VariableTestCheck implements CompilerPass {\n     }\n   }\n \n-  public void checkSynthesizedExtern(String input, String expectedExtern) {\n+  public void checkSynthesizedExtern(\n+      String input, String expectedExtern) {\n+    checkSynthesizedExtern(\"\", input, expectedExtern);\n+  }\n+\n+  public void checkSynthesizedExtern(\n+      String extern, String input, String expectedExtern) {\n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n     options.setWarningLevel(\n         DiagnosticGroup.forType(VarCheck.UNDEFINED_VAR_ERROR),\n         CheckLevel.OFF);\n     compiler.init(\n-        new JSSourceFile[] {},\n+        new JSSourceFile[] { JSSourceFile.fromCode(\"extern\", extern) },\n         new JSSourceFile[] { JSSourceFile.fromCode(\"input\", input) },\n         options);\n     compiler.parseInputs();", "timestamp": 1283278926, "metainfo": ""}