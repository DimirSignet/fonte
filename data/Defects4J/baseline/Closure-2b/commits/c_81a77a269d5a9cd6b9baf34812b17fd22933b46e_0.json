{"sha": "81a77a269d5a9cd6b9baf34812b17fd22933b46e", "log": "Object literal setters must have one parameter. Also, fix crash in RemoveUnusedVars in the presence of getters and setters.  R=nicksantos DELTA=157  (151 added, 5 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=157   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n       // flexibility.\n \n       switch (name.getType()) {\n+        case Token.SET:\n+        case Token.GET:\n         case Token.STRING:\n+          // TODO(johnlenz): return a GETELEM for quoted strings.\n           return new Node(Token.GETPROP,\n             new Node(Token.OBJECTLIT),\n             name.cloneNode());\n           return new Node(Token.GETELEM,\n             new Node(Token.OBJECTLIT),\n             name.cloneNode());\n-        case Token.SET:\n-        case Token.GET:\n-          // TODO(johnlenz): revisit. Not sure what to do here.\n-          throw new IllegalStateException(\"not yet implemented\");\n         default:\n           throw new IllegalStateException(\"unexpected\");\n       }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n+   * Determines whether a node represents an object literal get or set key\n+   * (e.g. key1 in {get key1() {}, set key2(a){}).\n+   *\n+   * @param node A node\n+   */\n+  static boolean isGetOrSetKey(Node node) {\n+    switch (node.getType()) {\n+      case Token.GET:\n+      case Token.SET:\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n    * Converts an operator's token value (see {@link Token}) to a string\n    * representation.\n    *\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n \n     Node function = fnScope.getRootNode();\n     Preconditions.checkState(function.getType() == Token.FUNCTION);\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n     Node argList = getFunctionArgList(function);\n     boolean modifyCallers = modifyCallSites\n         && callSiteOptimizer.canModifyCallers(function);\n--- a/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n     test(source, expected);\n   }\n \n+  public void testRewriteImplementedMethod2() throws Exception {\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype['foo'] = function(args) {return args};\",\n+        \"var o = new a;\",\n+        \"o.foo()\");\n+    testSame(source);\n+  }\n+\n+  public void testRewriteImplementedMethod3() throws Exception {\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype.foo = function(args) {return args};\",\n+        \"var o = new a;\",\n+        \"o['foo']\");\n+    testSame(source);\n+  }\n+\n+  public void testRewriteImplementedMethod4() throws Exception {\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype['foo'] = function(args) {return args};\",\n+        \"var o = new a;\",\n+        \"o['foo']\");\n+    testSame(source);\n+  }\n+\n+  public void testRewriteImplementedMethodInObj() throws Exception {\n+    // This isn't currently supported, but could be.\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype = {foo: function(args) {return args}};\",\n+        \"var o = new a;\",\n+        \"o.foo()\");\n+    testSame(source);\n+  }\n+\n+  public void testNoRewriteGet1() throws Exception {\n+    // Getters and setter require special handling.\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype = {get foo(){return f}};\",\n+        \"var o = new a;\",\n+        \"o.foo()\");\n+    testSame(source);\n+  }\n+\n+  public void testNoRewriteGet2() throws Exception {\n+    // Getters and setter require special handling.\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype = {get foo(){return 1}};\",\n+        \"var o = new a;\",\n+        \"o.foo\");\n+    testSame(source);\n+  }\n+\n+  public void testNoRewriteSet1() throws Exception {\n+    // Getters and setter require special handling.\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype = {set foo(a){}};\",\n+        \"var o = new a;\",\n+        \"o.foo()\");\n+    testSame(source);\n+  }\n+\n+  public void testNoRewriteSet2() throws Exception {\n+    // Getters and setter require special handling.\n+    String source = newlineJoin(\n+        \"function a(){}\",\n+        \"a.prototype = {set foo(a){}};\",\n+        \"var o = new a;\",\n+        \"o.foo = 1\");\n+    testSame(source);\n+  }\n+\n   public void testNoRewriteNotImplementedMethod() throws Exception {\n     testSame(newlineJoin(\"function a(){}\",\n                          \"var o = new a;\",\n       passUnderTest.process(externs, root);\n       NodeTraversal.traverse(compiler, externs, new GatherCallback());\n       NodeTraversal.traverse(compiler, root, new GatherCallback());\n+    }\n+\n+    public String getNameString(Node n) {\n+      int type = n.getType();\n+      if (type == Token.NAME) {\n+        return n.getString();\n+      } else if (type == Token.GETPROP) {\n+        String left = getNameString(n.getFirstChild());\n+        if (left == null) {\n+          return null;\n+        }\n+        return left + \".\" + n.getLastChild().getString();\n+      } else if (type == Token.GETELEM) {\n+        String left = getNameString(n.getFirstChild());\n+        if (left == null) {\n+          return null;\n+        }\n+        return left + \"[\" + n.getLastChild().getString() + \"]\";\n+      } else if (type == Token.THIS) {\n+        return \"this\";\n+      } else {\n+        return null;\n+      }\n     }\n \n     private class GatherCallback extends AbstractPostOrderCallback {\n               Joiner.on(\"\").join(\n                         Token.name(node.getType()),\n                         \" \",\n-                        nameNode.getQualifiedName(),\n+                        getNameString(nameNode),\n                         \" = \",\n                         (type != null) ? type.toString() : \"null\"));\n         }\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n          \"var b=function(c,d){return c+d};b(1,2)\");\n     test(\"var b=function(e,c,f,d,g){return c+d};b(1,2)\",\n          \"var b=function(c,d){return c+d};b(2)\");\n-    \n+\n     // multiple definitions of \"b\", the parameters can be removed but\n     // the call sites are left unmodified for now.\n     test(\"var b=function(c,d){};var b=function(e,f){};b(1,2)\",\n-         \"var b=function(){};var b=function(){};b(1,2)\");  \n-  }\n-  \n+         \"var b=function(){};var b=function(){};b(1,2)\");\n+  }\n+\n   public void testDoNotOptimizeJSCompiler_renameProperty() {\n     this.modifyCallSites = true;\n-    \n+\n     // Only the function definition can be modified, none of the call sites.\n     test(\"function JSCompiler_renameProperty(a) {};\" +\n          \"JSCompiler_renameProperty('a');\",\n          \"function JSCompiler_renameProperty() {};\" +\n          \"JSCompiler_renameProperty('a');\");\n   }\n-  \n+\n   public void testDoNotOptimizeJSCompiler_ObjectPropertyString() {\n     this.modifyCallSites = true;\n     test(\"function JSCompiler_ObjectPropertyString(a, b) {};\" +\n          \"JSCompiler_ObjectPropertyString(window,'b');\",\n          \"function JSCompiler_ObjectPropertyString() {};\" +\n          \"JSCompiler_ObjectPropertyString(window,'b');\");\n-  }  \n+  }\n+\n+  public void testDoNotOptimizeSetters() {\n+    // this.removeGlobal = false;\n+    // this.modifyCallSites = false;\n+    testSame(\"({set s(a) {}})\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n         ImmutableSet.of(\"DEF STRING null -> NUMBER\",\n                         \"USE GETPROP o.a -> [NUMBER]\"));\n \n+    // TODO(johnlenz): Fix this.\n+    checkDefinitionsInJs(\n+      \"({'a' : 1}); o['a']\",\n+      ImmutableSet.<String>of(\"DEF STRING null -> NUMBER\"));\n+\n     checkDefinitionsInJs(\n       \"({1 : 1}); o[1]\",\n       ImmutableSet.<String>of());\n-\n \n     checkDefinitionsInJs(\n         \"var a = {b : 1}; a.b\",\n                         \"DEF STRING null -> NUMBER\",\n                         \"USE NAME a -> [<null>]\",\n                         \"USE GETPROP a.b -> [NUMBER]\"));\n+  }\n+\n+  public void testDefineGet() throws Exception {\n+    // TODO(johnlenz): Add support for quoted properties\n+    checkDefinitionsInJs(\n+      \"({get a() {}}); o.a\",\n+      ImmutableSet.of(\"DEF GET null -> FUNCTION\",\n+                      \"USE GETPROP o.a -> [FUNCTION]\"));\n+  }\n+\n+  public void testDefineSet() throws Exception {\n+    // TODO(johnlenz): Add support for quoted properties\n+    checkDefinitionsInJs(\n+      \"({set a(b) {}}); o.a\",\n+      ImmutableSet.of(\"DEF NAME b -> <null>\",\n+                      \"DEF SET null -> FUNCTION\",\n+                      \"USE GETPROP o.a -> [FUNCTION]\"));\n   }\n \n   public void testDefineFunction() throws Exception {", "timestamp": 1292530653, "metainfo": ""}