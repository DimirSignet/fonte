{"sha": "458118289064379bc22acfc7fd991686a4b062f1", "log": "Move NodeTypeNormalizations into the IRFactory. (John) R=robert DELTA=42  (22 added, 7 deleted, 13 changed)  Create the DependencyInfo interface. Make CompilerInput an implementation of DependencyInfo. Open source it. (Nick) R=andrew DELTA=279  (185 added, 65 deleted, 29 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n-\n+import com.google.javascript.jscomp.deps.DependencyInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.io.IOException;\n+import java.util.Collection;\n import java.util.List;\n import java.util.Set;\n \n  *\n *\n  */\n-public class CompilerInput implements SourceAst {\n+public class CompilerInput implements SourceAst, DependencyInfo {\n   private static final long serialVersionUID = 1L;\n \n   // Info about where the file lives.\n   }\n \n   /** Returns a name for this input. Must be unique across all inputs. */\n+  @Override\n   public String getName() {\n     return name;\n+  }\n+\n+  /** Gets the path relative to closure-base, if one is available. */\n+  @Override\n+  public String getPathRelativeToClosureBase() {\n+    // TODO(nicksantos): Implement me.\n+    throw new UnsupportedOperationException();\n   }\n \n   @Override\n   }\n \n   /** Gets a list of types depended on by this input. */\n-  public Set<String> getRequires(AbstractCompiler compiler) {\n+  public Collection<String> getRequires(AbstractCompiler compiler) {\n     if (getAstRoot(compiler) != null) {\n       DepsFinder deps = new DepsFinder(compiler, true);\n       NodeTraversal.traverse(compiler, getAstRoot(compiler), deps);\n     }\n   }\n \n+  /** Gets a list of types depended on by this input. */\n+  @Override\n+  public Collection<String> getRequires() {\n+    // TODO(nicksantos): Implement me.\n+    throw new UnsupportedOperationException();\n+  }\n+\n   /** Gets a list of types provided by this input. */\n-  public Set<String> getProvides(AbstractCompiler compiler) {\n+  public Collection<String> getProvides(AbstractCompiler compiler) {\n     if (getAstRoot(compiler) != null) {\n       DepsFinder deps = new DepsFinder(compiler, false);\n       NodeTraversal.traverse(compiler, getAstRoot(compiler), deps);\n     } else {\n       return ImmutableSet.<String>of();\n     }\n+  }\n+\n+  /** Gets a list of types provided by this input. */\n+  @Override\n+  public Collection<String> getProvides() {\n+    // TODO(nicksantos): Implement me.\n+    throw new UnsupportedOperationException();\n   }\n \n   private class DepsFinder extends AbstractShallowCallback {\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n \n   @Override\n   public void process(Node externs, Node root) {\n-    normalizeNodeTypes(root);\n+    if (assertOnChange) {\n+      normalizeNodeTypes(root);\n+    }\n     if (externs != null) {\n       NodeTraversal.traverse(\n           compiler, externs, new PrepareAnnotations(compiler));\n       for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n             c.getType() != Token.BLOCK) {\n-          Node newBlock = new Node(Token.BLOCK);\n+          Node newBlock = new Node(Token.BLOCK, n.getLineno(), n.getCharno());\n           newBlock.copyInformationFrom(n);\n           n.replaceChild(c, newBlock);\n           if (c.getType() != Token.EMPTY) {\n   static class PrepareAnnotations\n       extends NodeTraversal.AbstractPostOrderCallback {\n \n-    private final AbstractCompiler compiler;\n     private final CodingConvention convention;\n \n     PrepareAnnotations(AbstractCompiler compiler) {\n-      this.compiler = compiler;\n       this.convention = compiler.getCodingConvention();\n     }\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/DependencyInfo.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * A data structure for JS dependency information for a single .js file.\n+ *\n+*\n+ */\n+public interface DependencyInfo {\n+\n+  /** Gets the unique name / path of this file. */\n+  public String getName();\n+\n+  /** Gets the path of this file relative to Closure's base.js file. */\n+  public String getPathRelativeToClosureBase();\n+\n+  /** Gets the symbols provided by this file. */\n+  public Collection<String> getProvides();\n+\n+  /** Gets the symbols required by this file. */\n+  public Collection<String> getRequires();\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * A class to hold JS dependency information for a single .js file.\n+ *\n+*\n+ */\n+public class SimpleDependencyInfo implements DependencyInfo {\n+\n+  /** A list of provided symbols. */\n+  private final List<String> provides;\n+\n+  /** A list of required symbols. */\n+  private final List<String> requires;\n+\n+  /** The path of the file relative to closure. */\n+  private final String srcPathRelativeToClosure;\n+\n+  /** The path to the file from which we extracted the dependency information.*/\n+  private final String pathOfDefiningFile;\n+\n+  /**\n+   * Constructs a DependencyInfo object with the given list of provides &\n+   * requires. This does *not* copy the given lists, but uses them directly.\n+   *\n+   * @param srcPathRelativeToClosure The closure-relative path of the file\n+   *     associated with this DependencyInfo.\n+   * @param pathOfDefiningFile The path to the file from which this dependency\n+   *     information was extracted.\n+   * @param provides List of provided symbols.\n+   * @param requires List of required symbols.\n+   */\n+  public SimpleDependencyInfo(\n+      String srcPathRelativeToClosure, String pathOfDefiningFile,\n+      List<String> provides, List<String> requires) {\n+    this.srcPathRelativeToClosure = srcPathRelativeToClosure;\n+    this.pathOfDefiningFile = pathOfDefiningFile;\n+    this.provides = provides;\n+    this.requires = requires;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return pathOfDefiningFile;\n+  }\n+\n+  @Override\n+  public String getPathRelativeToClosureBase() {\n+    return srcPathRelativeToClosure;\n+  }\n+\n+  @Override\n+  public Collection<String> getProvides() {\n+    return Collections.<String>unmodifiableList(provides);\n+  }\n+\n+  @Override\n+  public Collection<String> getRequires() {\n+    return Collections.<String>unmodifiableList(requires);\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (!(obj instanceof SimpleDependencyInfo)) {\n+      return false;\n+    }\n+    SimpleDependencyInfo other = (SimpleDependencyInfo)obj;\n+    return Objects.equal(other.srcPathRelativeToClosure,\n+            srcPathRelativeToClosure) &&\n+        Objects.equal(other.pathOfDefiningFile, pathOfDefiningFile) &&\n+        Objects.equal(other.requires, this.requires) &&\n+        Objects.equal(other.provides, this.provides);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"DependencyInfo(relativePath='%1$s', path='%2$s', \"\n+        + \"provides=%3$s, requires=%4$s)\", srcPathRelativeToClosure,\n+        pathOfDefiningFile, provides, requires);\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC;\n \n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.HashMultimap;\n import com.google.common.collect.LinkedHashMultimap;\n-import com.google.common.collect.Lists;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n \n import java.util.Collection;\n import java.util.Iterator;\n-import java.util.List;\n import java.util.Set;\n \n /**\n           fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n         }\n         irNode.setJSDocInfo(fileOverviewInfo);\n+      }\n+    }\n+    return irNode;\n+  }\n+\n+  private Node transformBlock(AstNode node) {\n+    Node irNode = transform(node);\n+    if (irNode.getType() != Token.BLOCK) {\n+      if (irNode.getType() == Token.EMPTY) {\n+        irNode.setType(Token.BLOCK);\n+        irNode.setWasEmptyNode(true);\n+      } else {\n+        Node newBlock = new Node(Token.BLOCK, irNode,\n+            irNode.getLineno(), irNode.getCharno());\n+        irNode = newBlock;\n       }\n     }\n     return irNode;\n         catchCondition.setCharno(clauseAbsolutePosition);\n         node.addChildToBack(catchCondition);\n       }\n-      node.addChildToBack(transform(clauseNode.getBody()));\n+      node.addChildToBack(transformBlock(clauseNode.getBody()));\n       return node;\n     }\n \n     Node processDoLoop(DoLoop loopNode) {\n       return new Node(\n           Token.DO,\n-          transform(loopNode.getBody()),\n+          transformBlock(loopNode.getBody()),\n           transform(loopNode.getCondition()));\n     }\n \n           Token.FOR,\n           transform(loopNode.getIterator()),\n           transform(loopNode.getIteratedObject()),\n-          transform(loopNode.getBody()));\n+          transformBlock(loopNode.getBody()));\n     }\n \n     @Override\n           transform(loopNode.getInitializer()),\n           transform(loopNode.getCondition()),\n           transform(loopNode.getIncrement()));\n-      node.addChildToBack(transform(loopNode.getBody()));\n+      node.addChildToBack(transformBlock(loopNode.getBody()));\n       return node;\n     }\n \n     Node processIfStatement(IfStatement statementNode) {\n       Node node = new Node(Token.IF);\n       node.addChildToBack(transform(statementNode.getCondition()));\n-      node.addChildToBack(transform(statementNode.getThenPart()));\n+      node.addChildToBack(transformBlock(statementNode.getThenPart()));\n       if (statementNode.getElsePart() != null) {\n-        node.addChildToBack(transform(statementNode.getElsePart()));\n+        node.addChildToBack(transformBlock(statementNode.getElsePart()));\n       }\n       return node;\n     }\n \n     @Override\n     Node processTryStatement(TryStatement statementNode) {\n-      Node node = new Node(Token.TRY, transform(statementNode.getTryBlock()));\n+      Node node = new Node(Token.TRY,\n+          transformBlock(statementNode.getTryBlock()));\n       Node block = new Node(Token.BLOCK);\n       boolean lineSet = false;\n \n \n       AstNode finallyBlock = statementNode.getFinallyBlock();\n       if (finallyBlock != null) {\n-        node.addChildToBack(transform(finallyBlock));\n+        node.addChildToBack(transformBlock(finallyBlock));\n       }\n \n       // If we didn't set the line on the catch clause, then\n       return new Node(\n           Token.WHILE,\n           transform(loopNode.getCondition()),\n-          transform(loopNode.getBody()));\n+          transformBlock(loopNode.getBody()));\n     }\n \n     @Override\n       return new Node(\n           Token.WITH,\n           transform(statementNode.getExpression()),\n-          transform(statementNode.getStatement()));\n+          transformBlock(statementNode.getStatement()));\n     }\n \n     @Override\n       case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP:\n         return Token.LOOP;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n-        return Token.EXPR_VOID;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n         return Token.EXPR_RESULT;\n       case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n   }\n \n   public void testLabel2() {\n-    parse(\"l: while (f()) { if (g()) continue l;}\");\n+    parse(\"l: while (f()) { if (g()) { continue l; } }\");\n   }\n \n   public void testLabel3() {", "timestamp": 1269629532, "metainfo": ""}