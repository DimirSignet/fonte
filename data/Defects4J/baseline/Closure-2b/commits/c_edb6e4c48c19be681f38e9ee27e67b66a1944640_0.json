{"sha": "edb6e4c48c19be681f38e9ee27e67b66a1944640", "log": "Try out the IR AST construction functions in the Peephole passes  R=nicksantos DELTA=154  (41 added, 35 deleted, 78 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3795   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n \n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         continue;\n       }\n       String alias = info.getVariableName(entry.getKey());\n-      Node value = Node.newString(Token.STRING, entry.getKey());\n-      Node name = Node.newString(Token.NAME, alias);\n-      name.addChildToBack(value);\n-      Node var = new Node(Token.VAR);\n-      var.addChildToBack(name);\n+      Node var = IR.var(IR.name(alias), IR.string(entry.getKey()));\n       if (info.siblingToInsertVarDeclBefore == null) {\n         info.parentForNewVarDecl.addChildToFront(var);\n       } else {\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n     }\n     return true;\n   }\n+\n+  static Node booleanNode(boolean value) {\n+    return value ? IR.trueNode() : IR.falseNode();\n+  }\n+\n+  static Node numberNode(double value, Node srcref) {\n+    Node result;\n+    if (Double.isNaN(value)) {\n+      result = IR.name(\"NaN\");\n+    } else if (value == Double.POSITIVE_INFINITY) {\n+      result = IR.name(\"Infinity\");\n+    } else if (value == Double.NEGATIVE_INFINITY) {\n+      result = IR.neg(IR.name(\"Infinity\"));\n+    } else {\n+      result = IR.number(value);\n+    }\n+    if (srcref != null) {\n+      result.srcrefTree(srcref);\n+    }\n+    return result;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.Node;\n \n         // Pad the array if it is sparse.\n         // So if array is [0] and integer 3 is assigned at index is 2, then\n         // we want to produce [0,,2].\n-        Node emptyNode = new Node(Token.EMPTY)\n-                         .copyInformationFrom(arrayLiteral);\n+        Node emptyNode = IR.empty().srcref(arrayLiteral);\n         arrayLiteral.addChildToBack(emptyNode);\n         ++maxIndexAssigned;\n       }\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n \n     double value = result;\n \n-    Node replacement;\n-    if (Double.isNaN(value)) {\n-      replacement = Node.newString(Token.NAME, \"NaN\");\n-    } else if (value == Double.POSITIVE_INFINITY) {\n-      replacement = Node.newString(Token.NAME, \"Infinity\");\n-    } else if (value == Double.NEGATIVE_INFINITY) {\n-      replacement = new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n-      replacement.copyInformationFromForTree(n);\n-    } else {\n-      replacement = Node.newNumber(value);\n-    }\n+    Node replacement = NodeUtil.numberNode(value, n);\n \n     n.getParent().replaceChild(n, replacement);\n     reportCodeChange();\n             return n;\n           }\n         }\n-        int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;\n-        Node replacementNode = new Node(result);\n+        Node replacementNode = NodeUtil.booleanNode(!leftVal.toBoolean(true));\n         parent.replaceChild(n, replacementNode);\n         reportCodeChange();\n         return replacementNode;\n \n       if (NodeUtil.isImmutableValue(left)) {\n         // Non-object types are never instances.\n-        replacementNode = new Node(Token.FALSE);\n+        replacementNode = IR.falseNode();\n       } else if (right.isName()\n           && \"Object\".equals(right.getString())) {\n-        replacementNode = new Node(Token.TRUE);\n+        replacementNode = IR.trueNode();\n       }\n \n       if (replacementNode != null) {\n \n     // Tries to convert x += y -> x = x + y;\n     int op = NodeUtil.getOpFromAssignmentOp(n);\n-    Node replacement = new Node(Token.ASSIGN, left.detachFromParent(),\n+    Node replacement = IR.assign(left.detachFromParent(),\n         new Node(op, left.cloneTree(), right.detachFromParent())\n-            .useSourceInfoFrom(n));\n+            .srcref(n));\n     n.getParent().replaceChild(n, replacement);\n     reportCodeChange();\n \n \n     // TODO(johnlenz): consider removing the result length check.\n     // length of the left and right value plus 1 byte for the operator.\n-    if (String.valueOf(result).length() <=\n-        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n+    if ((String.valueOf(result).length() <=\n+        String.valueOf(lval).length() + String.valueOf(rval).length() + 1\n \n         // Do not try to fold arithmetic for numbers > 2^53. After that\n         // point, fixed-point math starts to break down and become inaccurate.\n-        Math.abs(result) <= MAX_FOLD_NUMBER) {\n-      Node newNumber = Node.newNumber(result);\n-      return newNumber;\n-    } else if (Double.isNaN(result)) {\n-      return Node.newString(Token.NAME, \"NaN\");\n-    } else if (result == Double.POSITIVE_INFINITY) {\n-      return Node.newString(Token.NAME, \"Infinity\");\n-    } else if (result == Double.NEGATIVE_INFINITY) {\n-      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n-    }\n-\n+        && Math.abs(result) <= MAX_FOLD_NUMBER)\n+        || Double.isNaN(result)\n+        || result == Double.POSITIVE_INFINITY\n+        || result == Double.NEGATIVE_INFINITY) {\n+      return NodeUtil.numberNode(result, null);\n+    }\n     return null;\n   }\n \n         return n;\n     }\n \n-    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n+    Node newNode = NodeUtil.booleanNode(result);\n     n.getParent().replaceChild(n, newNode);\n     reportCodeChange();\n \n \n     Node replacement = value.detachFromParent();\n     if (key.isGetterDef()){\n-      replacement = new Node(Token.CALL, replacement);\n+      replacement = IR.call(replacement);\n       replacement.putBooleanProp(Node.FREE_CALL, true);\n     }\n \n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicates;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n       Node parent = subtree.getParent();\n       // If the EXPR_RESULT no longer has any children, remove it as well.\n       if (parent.isLabel()) {\n-        Node replacement = new Node(Token.BLOCK).copyInformationFrom(subtree);\n+        Node replacement = IR.block().srcref(subtree);\n         parent.replaceChild(subtree, replacement);\n         subtree = replacement;\n       } else {\n               } else {\n                 // Leave the side-effects in-place, simplifying it to a COMMA\n                 // expression.\n-                resultList = new Node(Token.COMMA, resultList, c)\n-                    .copyInformationFrom(c);\n+                resultList = IR.comma(resultList, c).srcref(c);\n               }\n             }\n           }\n         if (removeUnused) {\n           parent.removeChild(n);\n         } else {\n-          result = new Node(Token.EMPTY).copyInformationFrom(n);\n+          result = IR.empty().srcref(n);\n           parent.replaceChild(n, result);\n         }\n       } else {\n     if (n.hasOneChild()) {\n       Node condition = n.removeFirstChild();\n       Node parent = n.getParent();\n-      Node replacement = new Node(Token.EXPR_RESULT, condition)\n-                            .copyInformationFrom(n);\n+      Node replacement = IR.exprResult(condition).srcref(n);\n       parent.replaceChild(n, replacement);\n       reportCodeChange();\n       return replacement;\n         Node rhsAssign = getSimpleAssignmentValue(n);\n         TernaryValue value = NodeUtil.getImpureBooleanValue(rhsAssign);\n         if (value != TernaryValue.UNKNOWN) {\n-          int replacementConditionNodeType =\n-            (value.toBoolean(true)) ? Token.TRUE : Token.FALSE;\n+          Node replacementConditionNode =\n+              NodeUtil.booleanNode(value.toBoolean(true));\n           condition.getParent().replaceChild(condition,\n-              new Node(replacementConditionNodeType));\n+              replacementConditionNode);\n           reportCodeChange();\n         }\n       }\n       boolean newConditionValue = condValue == TernaryValue.TRUE;\n       // Add an elseBody if it is needed.\n       if (!newConditionValue && elseBody == null) {\n-        elseBody = new Node(Token.BLOCK).copyInformationFrom(n);\n+        elseBody = IR.block().srcref(n);\n         n.addChildToBack(elseBody);\n       }\n-      Node newCond = new Node(newConditionValue ? Token.TRUE : Token.FALSE);\n+      Node newCond = NodeUtil.booleanNode(newConditionValue);\n       n.replaceChild(cond, newCond);\n       Node branchToKeep = newConditionValue ? thenBody : elseBody;\n-      branchToKeep.addChildToFront(\n-          new Node(Token.EXPR_RESULT, cond).copyInformationFrom(cond));\n+      branchToKeep.addChildToFront(IR.exprResult(cond).srcref(cond));\n       reportCodeChange();\n       cond = newCond;\n     }\n     Node branchToKeep = condValue.toBoolean(true) ? thenBody : elseBody;\n     Node replacement;\n     if (mayHaveSideEffects(cond)) {\n-      replacement = new Node(Token.COMMA).copyInformationFrom(n);\n-      replacement.addChildToFront(cond);\n-      replacement.addChildToBack(branchToKeep);\n+      replacement = IR.comma(cond, branchToKeep).srcref(n);\n     } else {\n       replacement = branchToKeep;\n     }\n     if (!mayHaveSideEffects(cond)) {\n       NodeUtil.removeChild(n.getParent(), n);\n     } else {\n-      Node statement = new Node(Token.EXPR_RESULT, cond.detachFromParent())\n+      Node statement = IR.exprResult(cond.detachFromParent())\n           .copyInformationFrom(cond);\n       n.getParent().replaceChild(n, statement);\n     }\n     Node parent =  n.getParent();\n     parent.replaceChild(n, block);\n     if (mayHaveSideEffects(cond)) {\n-      Node condStatement = new Node(Token.EXPR_RESULT, cond.detachFromParent())\n-          .copyInformationFrom(cond);\n+      Node condStatement = IR.exprResult(cond.detachFromParent())\n+          .srcref(cond);\n       parent.addChildAfter(condStatement, block);\n     }\n     reportCodeChange();\n   private void tryFoldForCondition(Node forCondition) {\n     if (NodeUtil.getPureBooleanValue(forCondition) == TernaryValue.TRUE) {\n       forCondition.getParent().replaceChild(forCondition,\n-          new Node(Token.EMPTY));\n+          IR.empty());\n       reportCodeChange();\n     }\n   }\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.List;\n import java.util.Locale;\n \n         if (!foldedStringNode.isString()) {\n           // If the Node is not a string literal, ensure that\n           // it is coerced to a string.\n-          Node replacement = new Node(Token.ADD,\n-              Node.newString(\"\").copyInformationFrom(n),\n+          Node replacement = IR.add(\n+              IR.string(\"\").srcref(n),\n               foldedStringNode);\n           foldedStringNode = replacement;\n         }\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableSet;\n import com.google.javascript.jscomp.CodingConvention.Bind;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n         }\n \n         Node ifCondition = maybeIf.removeFirstChild();\n-        Node fixedIfCondition = new Node(Token.NOT, ifCondition)\n-            .copyInformationFrom(ifCondition);\n+        Node fixedIfCondition = IR.not(ifCondition)\n+            .srcref(ifCondition);\n \n         // Ok, join the IF expression with the FOR expression\n         Node forCondition = NodeUtil.getConditionExpression(n);\n       // Fold String(a) to ''+(a) - which allows further optimizations\n       Node value = callTarget.getNext();\n       if (value != null) {\n-        Node addition = new Node(Token.ADD);\n-        Node stringNode = Node.newString(\"\").copyInformationFrom(callTarget);\n-        addition.addChildToFront(stringNode);\n-        addition.addChildToBack(value.detachFromParent());\n+        Node addition = IR.add(\n+            IR.string(\"\").srcref(callTarget),\n+            value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n         return addition;\n       // add the this value before the parameters if necessary\n       if (bind.thisValue != null && !NodeUtil.isUndefined(bind.thisValue)) {\n         // rewrite from \"fn(a, b)\" to \"fn.call(thisValue, a, b)\"\n-        Node newCallTarget = new Node(Token.GETPROP,\n+        Node newCallTarget = IR.getprop(\n             callTarget.cloneTree(),\n-            Node.newString(\"call\").copyInformationFrom(callTarget));\n+            IR.string(\"call\").srcref(callTarget));\n         n.replaceChild(callTarget, newCallTarget);\n         n.addChildAfter(bind.thisValue.cloneTree(), newCallTarget);\n         n.putBooleanProp(Node.FREE_CALL, false);\n       // Replace the original expression with the left operand.\n       parent.replaceChild(n, left);\n       // Add the right expression afterward.\n-      Node newStatement = new Node(Token.EXPR_RESULT, right);\n+      Node newStatement = IR.exprResult(right);\n       newStatement.copyInformationFrom(n);\n \n       //This modifies outside the subtree, which is not\n             child.detachFromParent();\n             child.detachChildren();\n             Node newCond = new Node(Token.AND,\n-                new Node(Token.NOT, cond).copyInformationFrom(cond));\n+                IR.not(cond).srcref(cond));\n             nextNode.replaceChild(nextCond, newCond);\n             newCond.addChildToBack(nextCond);\n             reportCodeChange();\n           cond.detachFromParent();\n           elseExpr.detachFromParent();\n \n-          Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                              .copyInformationFrom(child);\n-          Node returnNode = new Node(Token.RETURN, hookNode);\n+          Node returnNode = IR.returnNode(\n+                                IR.hook(cond, thenExpr, elseExpr)\n+                                    .srcref(child));\n           n.replaceChild(child, returnNode);\n           n.removeChild(nextNode);\n           reportCodeChange();\n     // When follow is null, this mean the follow of a break target is the\n     // end of a function. This means a break is same as return.\n     if (follow == null || areMatchingExits(n, follow)) {\n-      Node replacement = new Node(Token.BREAK);\n+      Node replacement = IR.breakNode();\n       n.getParent().replaceChild(n, replacement);\n       this.reportCodeChange();\n       return replacement;\n             return n;\n           }\n \n-          Node or = new Node(Token.OR, cond.removeFirstChild(),\n-          expr.removeFirstChild()).copyInformationFrom(n);\n+          Node or = IR.or(\n+              cond.removeFirstChild(),\n+              expr.removeFirstChild()).srcref(n);\n           Node newExpr = NodeUtil.newExpr(or);\n           parent.replaceChild(n, newExpr);\n           reportCodeChange();\n         }\n \n         n.removeChild(cond);\n-        Node and = new Node(Token.AND, cond, expr.removeFirstChild())\n-                       .copyInformationFrom(n);\n+        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n         Node newExpr = NodeUtil.newExpr(and);\n         parent.replaceChild(n, newExpr);\n         reportCodeChange();\n                  !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                    isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n               n.detachChildren();\n-              n.addChildToBack(new Node(Token.AND, cond,\n-                  innerCond.detachFromParent()).copyInformationFrom(cond));\n+              n.addChildToBack(\n+                  IR.and(\n+                      cond,\n+                      innerCond.detachFromParent())\n+                      .srcref(cond));\n               n.addChildrenToBack(innerThenBranch.detachFromParent());\n               reportCodeChange();\n               // Not worth trying to fold the current IF-ELSE into && because\n       // note - we ignore any cases with \"return;\", technically this\n       // can be converted to \"return undefined;\" or some variant, but\n       // that does not help code size.\n-      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                          .copyInformationFrom(n);\n-      Node returnNode = new Node(Token.RETURN, hookNode);\n+      Node returnNode = IR.returnNode(\n+                            IR.hook(cond, thenExpr, elseExpr)\n+                                .srcref(n));\n       parent.replaceChild(n, returnNode);\n       reportCodeChange();\n       return returnNode;\n             Node elseExpr = elseOp.getLastChild();\n             elseOp.removeChild(elseExpr);\n \n-            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                                .copyInformationFrom(n);\n+            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n             Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .copyInformationFrom(thenOp);\n+                              .srcref(thenOp);\n             Node expr = NodeUtil.newExpr(assign);\n             parent.replaceChild(n, expr);\n             reportCodeChange();\n       n.removeChild(cond);\n       thenOp.detachFromParent();\n       elseOp.detachFromParent();\n-      Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)\n-                          .copyInformationFrom(n);\n-      Node expr = NodeUtil.newExpr(hookNode);\n+      Node expr = IR.exprResult(\n+          IR.hook(cond, thenOp, elseOp).srcref(n));\n       parent.replaceChild(n, expr);\n       reportCodeChange();\n       return expr;\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n         cond.detachFromParent();\n-        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                            .copyInformationFrom(n);\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n+                            .srcref(n);\n         var.detachFromParent();\n         name1.addChildrenToBack(hookNode);\n         parent.replaceChild(n, var);\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n         cond.detachFromParent();\n-        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                            .copyInformationFrom(n);\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n+                            .srcref(n);\n         var.detachFromParent();\n         name2.addChildrenToBack(hookNode);\n         parent.replaceChild(n, var);\n                 left = leftParent.removeFirstChild();\n               } else {\n                 leftParent.detachFromParent();\n-                left = new Node(Token.NOT, leftParent)\n-                  .copyInformationFrom(leftParent);\n+                left = IR.not(leftParent).srcref(leftParent);\n               }\n               if (rightParent.isNot()) {\n                 right = rightParent.removeFirstChild();\n               } else {\n                 rightParent.detachFromParent();\n-                right = new Node(Token.NOT, rightParent)\n-                  .copyInformationFrom(rightParent);\n+                right = IR.not(rightParent).srcref(rightParent);\n               }\n \n               int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n             && falseNodeVal == TernaryValue.TRUE) {\n           // Remove useless conditionals, keep the condition\n           condition.detachFromParent();\n-          replacement = new Node(Token.NOT, condition);\n+          replacement = IR.not(condition);\n         } else if (trueNodeVal == TernaryValue.TRUE) {\n           // Remove useless true case.\n           n.detachChildren();\n-          replacement = new Node(Token.OR, condition, falseNode);\n+          replacement = IR.or(condition, falseNode);\n         } else if (falseNodeVal == TernaryValue.FALSE) {\n           // Remove useless false case\n           n.detachChildren();\n-          replacement = new Node(Token.AND, condition, trueNode);\n+          replacement = IR.and(condition, trueNode);\n         }\n \n         if (replacement != null) {\n \n         if (\"Object\".equals(className) && !constructorHasArgs) {\n           // \"Object()\" --> \"{}\"\n-          newLiteralNode = new Node(Token.OBJECTLIT);\n+          newLiteralNode = IR.objectlit();\n         } else if (\"Array\".equals(className)) {\n           // \"Array(arg0, arg1, ...)\" --> \"[arg0, arg1, ...]\"\n           Node arg0 = constructorNameNode.getNext();\n \n           if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS ||\n               action == FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n-            newLiteralNode = new Node(Token.ARRAYLIT);\n+            newLiteralNode = IR.arraylit();\n             n.removeChildren();\n             if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n               newLiteralNode.addChildrenToFront(arg0);\n       Node regexLiteral;\n       if (null == flags || \"\".equals(flags.getString())) {\n         // fold to /foobar/\n-        regexLiteral = new Node(Token.REGEXP, pattern);\n+        regexLiteral = IR.regexp(pattern);\n       } else {\n         // fold to /foobar/gi\n         if (!areValidRegexpFlags(flags.getString())) {\n           return n;\n         }\n         n.removeChild(flags);\n-        regexLiteral = new Node(Token.REGEXP, pattern, flags);\n+        regexLiteral = IR.regexp(pattern, flags);\n       }\n \n       parent.replaceChild(n, regexLiteral);\n \n   private Node reduceTrueFalse(Node n) {\n     if (late) {\n-      Node not = new Node(Token.NOT,\n-          Node.newNumber(n.isTrue() ? 0 : 1));\n+      Node not = IR.not(IR.number(n.isTrue() ? 0 : 1));\n       not.copyInformationFromForTree(n);\n       n.getParent().replaceChild(n, not);\n       reportCodeChange();\n         }\n       }\n       String template = Joiner.on(delimiter).join(strings);\n-      Node call = new Node(Token.CALL,\n-        new Node(Token.GETPROP, Node.newString(Token.STRING,template),\n-            Node.newString(Token.STRING, \"split\")),\n-        Node.newString(Token.STRING, \"\" + delimiter));\n+      Node call = IR.call(\n+          IR.getprop(\n+              IR.string(template),\n+              IR.string(\"split\")),\n+          IR.string(\"\" + delimiter));\n       call.copyInformationFromForTree(n);\n       n.getParent().replaceChild(n, call);\n       reportCodeChange();\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     return this;\n   }\n \n+  public Node srcref(Node other) {\n+    return useSourceInfoFrom(other);\n+  }\n+\n   /**\n    * Overwrite all the source information in this node and its subtree with\n    * that of {@code other}.\n     }\n \n     return this;\n+  }\n+\n+  public Node srcrefTree(Node other) {\n+    return useSourceInfoFromForTree(other);\n   }\n \n   /**", "timestamp": 1321921735, "metainfo": ""}