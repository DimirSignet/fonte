{"sha": "c6d6e3f002b58a5934e8babbaba091514320dba2", "log": "Try to be more clever about indexing properties when type information is missing  R=johnlenz DELTA=45  (38 added, 0 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4047   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n     }\n \n     // Try to find the symbol by its fully qualified name.\n-    private void tryDefineLexicalQualifiedNameRef(String name, Node n) {\n+    private boolean tryDefineLexicalQualifiedNameRef(String name, Node n) {\n       if (name != null) {\n         Symbol lexicalSym = getEnclosingScope(n).getQualifiedSlot(name);\n         if (lexicalSym != null) {\n           lexicalSym.defineReferenceAt(n);\n-        }\n-      }\n+          return true;\n+        }\n+      }\n+      return false;\n     }\n \n     private void maybeDefineTypedReference(\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n+      // There are two ways to define a property reference:\n+      // 1) As a fully qualified lexical symbol (e.g., x.y)\n+      // 2) As a property of another object (e.g., x's y)\n+\n       if (n.isGetProp()) {\n         JSType owner = n.getFirstChild().getJSType();\n         if (owner == null || owner.isUnknownType()) {\n-          tryDefineLexicalQualifiedNameRef(n.getQualifiedName(), n);\n-          return;\n+          boolean defined = tryDefineLexicalQualifiedNameRef(\n+              n.getQualifiedName(), n);\n+\n+          // If the owner is unknown, and we haven't been able to define\n+          // this lexically, try to define it as a property (in case\n+          // the owner is just a type with an unresolved superclass).\n+          if (defined || owner == null) {\n+            return;\n+          }\n         }\n \n         maybeDefineTypedReference(n, n.getLastChild().getString(), owner);\n       } else if (NodeUtil.isObjectLitKey(n, parent) && n.isString()) {\n         JSType owner = parent.getJSType();\n         if (owner == null || owner.isUnknownType()) {\n-          tryDefineLexicalQualifiedNameRef(NodeUtil.getBestLValueName(n), n);\n-          return;\n+          boolean defined = tryDefineLexicalQualifiedNameRef(\n+              NodeUtil.getBestLValueName(n), n);\n+\n+          // See comments above.\n+          if (defined || owner == null) {\n+            return;\n+          }\n         }\n \n         maybeDefineTypedReference(n, n.getString(), owner);\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(\n         2, Iterables.size(table.getReferences(methodA)));\n   }\n+\n+  public void testMethodReferencesMissingTypeInfo() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Missing}\\n\" +\n+        \" */ var DomHelper = function(){};\\n\" +\n+        \"/** method */ DomHelper.prototype.method = function() {\\n\" +\n+        \"  this.method();\\n\" +\n+        \"};\\n\" +\n+        \"function f() { \" +\n+        \"  (new DomHelper()).method();\\n\" +\n+        \"};\");\n+\n+    Symbol method =\n+        getGlobalVar(table, \"DomHelper.prototype.method\");\n+    assertEquals(\n+        3, Iterables.size(table.getReferences(method)));\n+  }\n+\n \n   public void testFieldReferences() throws Exception {\n     SymbolTable table = createSymbolTable(", "timestamp": 1325729136, "metainfo": ""}