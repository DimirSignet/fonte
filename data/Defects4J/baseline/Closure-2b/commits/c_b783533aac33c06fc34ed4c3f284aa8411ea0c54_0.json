{"sha": "b783533aac33c06fc34ed4c3f284aa8411ea0c54", "log": "Rename NodeUtil.getFunctionInfo to NodeUtil.getFunctionJSDocInfo Rename NodeUtil.getFnParameters to NodeUtil.getFunctionParameters. NOTE: this is a pure Eclipse refactor:rename CL  R=johnlenz DELTA=18  (1 added, 0 deleted, 17 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1913   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n      */\n     private Node createExternFunction(Node exportedFunction) {\n       List<Node> externParameters = Lists.newLinkedList();\n-      for (Node param : NodeUtil.getFnParameters(exportedFunction).children()) {\n+      for (Node param :\n+          NodeUtil.getFunctionParameters(exportedFunction).children()) {\n         externParameters.add(param.cloneNode());\n       }\n \n        * in lock step getting parameter names from the first and types from the\n        * second.\n        */\n-      Node astParameterIterator = NodeUtil.getFnParameters(function)\n+      Node astParameterIterator = NodeUtil.getFunctionParameters(function)\n         .getFirstChild();\n \n       Node typeParameterIterator = functionType.getParametersNode()\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n       }\n     }\n \n-    for (Node fnArg : NodeUtil.getFnParameters(fnNode).children()) {\n+    for (Node fnArg : NodeUtil.getFunctionParameters(fnNode).children()) {\n       if (cArg != null) {\n         argMap.put(fnArg.getString(), cArg);\n         cArg = cArg.getNext();\n    */\n   private static Set<String> getFunctionParameterSet(Node fnNode) {\n     Set<String> set = Sets.newHashSet();\n-    for (Node n : NodeUtil.getFnParameters(fnNode).children()) {\n+    for (Node n : NodeUtil.getFunctionParameters(fnNode).children()) {\n       set.add(n.getString());\n     }\n     return set;\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n     }\n \n     // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n-    Node fnParam = NodeUtil.getFnParameters(fnNode).getFirstChild();\n+    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n     while (cArg != null || fnParam != null) {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n    * @param referencesThis\n    */\n   private static int estimateCallCost(Node fnNode, boolean referencesThis) {\n-    Node argsNode = NodeUtil.getFnParameters(fnNode);\n+    Node argsNode = NodeUtil.getFunctionParameters(fnNode);\n     int numArgs = argsNode.getChildCount();\n \n     int callCost = NAME_COST_ESTIMATE + PAREN_COST;\n       Node fnNode, Set<String> namesToAlias, InliningMode mode) {\n     // The part of the function that is never inlined:\n     //    \"function xx(xx,xx){}\" (15 + (param count * 3) -1;\n-    int paramCount = NodeUtil.getFnParameters(fnNode).getChildCount();\n+    int paramCount = NodeUtil.getFunctionParameters(fnNode).getChildCount();\n     int commaCount = (paramCount > 1) ? paramCount - 1 : 0;\n     int costDeltaFunctionOverhead = 15 + commaCount +\n         (paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST);\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n    */\n   private boolean hasLocalNames(Node fnNode) {\n     Node block = NodeUtil.getFunctionBody(fnNode);\n-    return NodeUtil.getFnParameters(fnNode).hasChildren()\n+    return NodeUtil.getFunctionParameters(fnNode).hasChildren()\n         || NodeUtil.has(\n              block,\n              new NodeUtil.MatchDeclaration(),\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     * @param fnNode The function.\n     * @return The Node containing the Function parameters.\n     */\n-  public static Node getFnParameters(Node fnNode) {\n+  public static Node getFunctionParameters(Node fnNode) {\n     // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n     Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);\n     return fnNode.getFirstChild().getNext();\n   /**\n    * Get the JSDocInfo for a function.\n    */\n-  public static JSDocInfo getFunctionInfo(Node n) {\n+  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n     Preconditions.checkState(n.getType() == Token.FUNCTION);\n     JSDocInfo fnInfo = n.getJSDocInfo();\n     if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n      * Annotate optional and var_arg function parameters.\n      */\n     private void annotateFunctions(Node n, Node parent) {\n-      JSDocInfo fnInfo = NodeUtil.getFunctionInfo(n);\n+      JSDocInfo fnInfo = NodeUtil.getFunctionJSDocInfo(n);\n \n       // Compute which function parameters are optional and\n       // which are var_args.\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n     private void visitFunction(NodeTraversal t, Node n) {\n       FunctionType funType = (FunctionType) n.getJSType();\n       Node block = n.getLastChild();\n-      Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n+      Node paramName = NodeUtil.getFunctionParameters(n).getFirstChild();\n       Node insertionPoint = null;\n \n       // To satisfy normalization constraints, the type checking must be\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n           Node anonymousFnNode = n.getChildAtIndex(1);\n           if (!NodeUtil.isFunction(anonymousFnNode) ||\n               NodeUtil.getFunctionName(anonymousFnNode) != null ||\n-              NodeUtil.getFnParameters(anonymousFnNode).hasChildren()) {\n+              NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n             report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n           } else {\n             scopeCalls.add(n);\n--- a/src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java\n         // dependency on the exact structure of our AST, and that seems like\n         // a bad idea.\n         if (type == Token.FUNCTION) {\n-          info = NodeUtil.getFunctionInfo(current);\n+          info = NodeUtil.getFunctionJSDocInfo(current);\n         } else if (type == Token.SCRIPT) {\n           info = current.getJSDocInfo();\n         }\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n     //     NAME param1\n     //     NAME param2\n     if (fnNode != null) {\n-      Node paramNode = NodeUtil.getFnParameters(fnNode).getFirstChild();\n+      Node paramNode = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n \n       // Param types\n       for (Node n : funType.getParameters()) {", "timestamp": 1305558880, "metainfo": ""}