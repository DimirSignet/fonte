{"sha": "87b154f89cba3c67045cd7a783b79231d0630a4c", "log": "More recursion unrolling Fixes issue 691  R=johnlenz DELTA=78  (54 added, 21 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4425   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n           \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n           opstr, childCount);\n       int p = NodeUtil.precedence(type);\n-      addExpr(first, p, context);\n-      cc.addOp(opstr, true);\n \n       // For right-hand-side of operations, only pass context if it's\n       // the IN_FOR_INIT_CLAUSE one.\n       // we can simply generate a * b * c.\n       if (last.getType() == type &&\n           NodeUtil.isAssociative(type)) {\n+        addExpr(first, p, context);\n+        cc.addOp(opstr, true);\n         addExpr(last, p, rhsContext);\n       } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n         // Assignments are the only right-associative binary operators\n+        addExpr(first, p, context);\n+        cc.addOp(opstr, true);\n         addExpr(last, p, rhsContext);\n       } else {\n-        addExpr(last, p + 1, rhsContext);\n+        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n       }\n       return;\n     }\n \n       case Token.COMMA:\n         Preconditions.checkState(childCount == 2);\n-\n-        // We could use addList recursively here, but sometimes we produce\n-        // very deeply nested commas and run out of stack space, so we\n-        // just unroll the recursion.\n-        //\n-        // We assume COMMA nodes are left-recursive.\n-        Node firstNonComma = n.getFirstChild();\n-        while (firstNonComma.getType() == Token.COMMA) {\n-          firstNonComma = firstNonComma.getFirstChild();\n-        }\n-\n-        addExpr(firstNonComma, 0, context);\n-\n-        Node current = firstNonComma;\n-        do {\n-          current = current.getParent();\n-          cc.listSeparator();\n-          addExpr(current.getFirstChild().getNext(), 0, Context.OTHER);\n-        } while (current != n);\n-\n+        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n         break;\n \n       case Token.NUMBER:\n     cc.endSourceMapping(n);\n   }\n \n+  /**\n+   * We could use addList recursively here, but sometimes we produce\n+   * very deeply nested operators and run out of stack space, so we\n+   * just unroll the recursion when possible.\n+   *\n+   * We assume nodes are left-recursive.\n+   */\n+  private void unrollBinaryOperator(\n+      Node n, int op, String opStr, Context context,\n+      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n+    Node firstNonOperator = n.getFirstChild();\n+    while (firstNonOperator.getType() == op) {\n+      firstNonOperator = firstNonOperator.getFirstChild();\n+    }\n+\n+    addExpr(firstNonOperator, leftPrecedence, context);\n+\n+    Node current = firstNonOperator;\n+    do {\n+      current = current.getParent();\n+      cc.addOp(opStr, true);\n+      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n+    } while (current != n);\n+  }\n+\n   static boolean isSimpleNumber(String s) {\n     int len = s.length();\n     for (int index = 0; index < len; index++) {\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n     @Override\n     void appendOp(String op, boolean binOp) {\n       if (binOp) {\n-        if (getLastChar() != ' ') {\n+        if (getLastChar() != ' ' && op.charAt(0) != ',') {\n           append(\" \");\n         }\n         append(op);\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     assertPrint(\"var a = { '$\\\\\\\\' : 5 };\", \"var a={\\\"$\\\\\\\\\\\":5}\");\n   }\n \n+  public void testCommaSpacing() {\n+    assertPrint(\"var a = (b = 5, c = 5);\",\n+        \"var a=(b=5,c=5)\");\n+    assertPrettyPrint(\"var a = (b = 5, c = 5);\",\n+        \"var a = (b = 5, c = 5);\\n\");\n+  }\n+\n   public void testManyCommas() {\n     int numCommas = 10000;\n     List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n     assertEquals(expected, actual);\n   }\n \n+  public void testManyAdds() {\n+    int numAdds = 10000;\n+    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n+    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));\n+    for (int i = 2; i < numAdds; i++) {\n+      current = new Node(Token.ADD, current);\n+\n+      // 1000 is printed as 1E3, and screws up our test.\n+      int num = i % 1000;\n+      numbers.add(String.valueOf(num));\n+      current.addChildToBack(Node.newNumber(num));\n+    }\n+\n+    String expected = Joiner.on(\"+\").join(numbers);\n+    String actual = printNode(current).replace(\"\\n\", \"\");\n+    assertEquals(expected, actual);\n+  }\n+\n   public void testMinusNegativeZero() {\n     // Negative zero is weird, because we have to be able to distinguish\n     // it from positive zero (there are some subtle differences in behavior).", "timestamp": 1332862690, "metainfo": ""}