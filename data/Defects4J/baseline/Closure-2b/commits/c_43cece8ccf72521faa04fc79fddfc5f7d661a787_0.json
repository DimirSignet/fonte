{"sha": "43cece8ccf72521faa04fc79fddfc5f7d661a787", "log": "Automated g4 rollback.  *** Reason for rollback ***  Breaks tests  *** Original change description ***  Tweaks to function inlining: - an unnamed function expression containing a inner unnamed function expression should not be disallow because the names are the same. - a caller that only contains the function definition to be inlined should not consider the candidate to be a capturing function. - allow inlining a function containing an inner function that references arguments. - disallow inlining a function into a function containing eval. - when inlining a function containing a function dec  ... description truncated by g4 rollback ...   Revision created by MOE tool push_codebase. MOE_MIGRATION=2930   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n     final String fnRecursionName = fnNode.getFirstChild().getString();\n     Preconditions.checkState(fnRecursionName != null);\n \n-    // If the function references \"arguments\" directly in the function\n-    boolean referencesArguments = NodeUtil.isNameReferenced(\n-        block, \"arguments\", NodeUtil.MATCH_NOT_FUNCTION);\n-\n-    // or it references \"eval\" or one of its names anywhere.\n     Predicate<Node> p = new Predicate<Node>(){\n       @Override\n       public boolean apply(Node n) {\n         if (n.getType() == Token.NAME) {\n-          return n.getString().equals(\"eval\")\n-            || (!fnName.isEmpty()\n-                && n.getString().equals(fnName))\n+          return n.getString().equals(\"arguments\")\n+            || n.getString().equals(\"eval\")\n+            || n.getString().equals(fnName)\n             || (!fnRecursionName.isEmpty()\n                 && n.getString().equals(fnRecursionName));\n         }\n       }\n     };\n \n-    return !referencesArguments\n-        && !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n+    return !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n   }\n \n   /**\n       return CanInlineResult.NO;\n     }\n \n+    // Limit where functions that contain functions can be inline.  Introducing\n+    // an inner function into another function can capture a variable and cause\n+    // a memory leak.  This isn't a problem in the global scope as those values\n+    // last until explicitly cleared.\n+    if (containsFunctions && !t.inGlobalScope()) {\n+      // TODO(johnlenz): Allow inlining into any scope without local names or\n+      // inner functions.\n+      return CanInlineResult.NO;\n+    }\n+\n     // TODO(johnlenz): Add support for 'apply'\n     if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n       // TODO(johnlenz): Allow 'this' references to be replaced with a\n       return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n       return canInlineReferenceAsStatementBlock(\n-          t, callNode, fnNode, needAliases, containsFunctions);\n+          t, callNode, fnNode, needAliases);\n     }\n   }\n \n    *    a = foo();\n    *    var a = foo();\n    * </pre>\n-   * @param containsFunctions Whether the fnNode contains inner functions.\n    */\n   private CanInlineResult canInlineReferenceAsStatementBlock(\n-      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias,\n-      boolean containsFunctions) {\n+      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n     CallSiteType callSiteType = classifyCallSite(callNode);\n     if (callSiteType == CallSiteType.UNSUPPORTED) {\n       return CanInlineResult.NO;\n     }\n \n     if (!callMeetsBlockInliningRequirements(\n-            t, callNode, fnNode, namesToAlias, containsFunctions)) {\n+            t, callNode, fnNode, namesToAlias)) {\n       return CanInlineResult.NO;\n     }\n \n    * inlining would introduce new globals.\n    */\n   private boolean callMeetsBlockInliningRequirements(\n-      NodeTraversal t, Node callNode, final Node fnNode,\n-      Set<String> namesToAlias, boolean containsFunctions) {\n+      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n     // Note: functions that contain function definitions are filtered out\n     // in isCanidateFunction.\n \n     // Don't inline functions with var declarations into a scope with inner\n     // functions as the new vars would leak into the inner function and\n     // cause memory leaks.\n-    boolean hasLocalNames = hasLocalNames(fnNode);\n-    boolean forbidTemps = false;\n+    boolean fnContainsVars = NodeUtil.has(\n+        NodeUtil.getFunctionBody(fnNode),\n+        new NodeUtil.MatchDeclaration(),\n+        new NodeUtil.MatchShallowStatement());\n+    boolean callerContainsFunction = false;\n     if (!t.inGlobalScope()) {\n       Node fnCaller = t.getScopeRoot();\n       Node fnCallerBody = fnCaller.getLastChild();\n \n-      // Don't allow any new vars in a scope that contains eval\n-      forbidTemps = NodeUtil.isNameReferenced(\n-          fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n-      if (!forbidTemps && containsFunctions) {\n-        // Don't allow any new vars in a scope that has other functions.\n-        // Don't count the function we are removing by inlining.\n-        Predicate<Node> match = new Predicate<Node>(){\n-          @Override\n-          public boolean apply(Node n) {\n-            if (n.getType() == Token.FUNCTION) {\n-              return n != fnNode;\n-            }\n-            return false;\n-          }\n-        };\n-        forbidTemps = NodeUtil.has(fnCallerBody,\n-            match, NodeUtil.MATCH_NOT_FUNCTION);\n-      }\n-    }\n-\n-    if (forbidTemps) {\n-      if (hasLocalNames) {\n-        return false;\n-      }\n-\n-      // If the caller contains functions, verify we aren't adding any\n-      // additional VAR declarations because aliasing is needed.\n+      callerContainsFunction = NodeUtil.containsFunction(fnCallerBody);\n+    }\n+\n+    if (fnContainsVars && callerContainsFunction) {\n+      return false;\n+    }\n+\n+    // If the caller contains functions, verify we aren't adding any\n+    // additional VAR declarations because aliasing is needed.\n+    if (callerContainsFunction) {\n       Map<String, Node> args =\n           FunctionArgumentInjector.getFunctionCallParameterMap(\n               fnNode, callNode, this.safeNameIdSupplier);\n     }\n \n     return true;\n-  }\n-\n-  /**\n-   * @param fnNode The function to inspect.\n-   * @return Whether the function has parameters, var, or function declarations.\n-   */\n-  private boolean hasLocalNames(Node fnNode) {\n-    Node block = NodeUtil.getFunctionBody(fnNode);\n-    return NodeUtil.getFunctionParameters(fnNode).hasChildren()\n-        || NodeUtil.has(\n-             block,\n-             new NodeUtil.MatchVarDeclaration(),\n-             new NodeUtil.MatchShallowStatement());\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n     // without causing conflicts.\n     makeLocalNamesUnique(newFnNode, isCallInLoop);\n \n-    // Function declarations must be rewritten as function expressions as\n-    // they will be within a block and normalization prevents function\n-    // declarations within block as browser implementations vary.\n-    rewriteFunctionDeclarations(newFnNode.getLastChild());\n-\n     // TODO(johnlenz): Mark NAME nodes constant for parameters that are not\n     // modified.\n     Set<String> namesToAlias =\n     return injectableBlock;\n   }\n \n-\n-  /**\n-   * @param n The node to inspect\n-   */\n-  private void rewriteFunctionDeclarations(Node n) {\n-    if (n.getType() == Token.FUNCTION) {\n-      if (NodeUtil.isFunctionDeclaration(n)) {\n-        // Rewrite: function f() {} ==> var f = function() {}\n-        Node fnNameNode = n.getFirstChild();\n-\n-        Node var = new Node(Token.VAR).copyInformationFrom(n);\n-        Node name = Node.newString(Token.NAME, fnNameNode.getString())\n-            .copyInformationFrom(fnNameNode);\n-\n-        fnNameNode.setString(\"\");\n-        // Add the VAR, remove the FUNCTION\n-        n.getParent().replaceChild(n, var);\n-        var.addChildToFront(name);\n-        // readd the function as a function expression\n-        name.addChildToFront(n);\n-      }\n-      return;\n-    }\n-\n-    for (Node c = n.getFirstChild(), next; c != null; c = next) {\n-      next = c.getNext(); // We may rewrite \"c\"\n-      rewriteFunctionDeclarations(c);\n-    }\n-  }\n \n   /**\n    *  For all VAR node with uninitialized declarations, set\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n     return NodeUtil.getFunctionParameters(fnNode).hasChildren()\n         || NodeUtil.has(\n              block,\n-             new NodeUtil.MatchVarDeclaration(),\n+             new NodeUtil.MatchDeclaration(),\n              new NodeUtil.MatchShallowStatement());\n   }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     }\n   }\n \n-  /**\n-   * A predicate for matching var\n-   */\n-  static class MatchVarDeclaration implements Predicate<Node> {\n-    @Override\n-    public boolean apply(Node n) {\n-      return n.getType() == Token.VAR;\n-    }\n-  }\n \n   /**\n    * A predicate for matching var or function declarations.\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n     helperInlineReferenceToFunction(\n         \"function foo(){function x() {var a; return true;} return x}; foo();\",\n         \"function foo(){function x(){var a;return true}return x};\" +\n-            \"{var x$$inline_1 = function(){\" +\n-            \"var a$$inline_2;return true};x$$inline_1}\",\n+            \"{function x$$inline_1(){var a$$inline_2;return true}x$$inline_1}\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n \n   private static Node parseExpected(Compiler compiler, String js) {\n     Node n = compiler.parseTestCode(js);\n-    String message = \"Unexpected errors: \";\n-    JSError[] errs = compiler.getErrors();\n-    for (int i = 0; i < errs.length; i++){\n-      message += \"\\n\" + errs[i].toString();\n-    }\n-    assertEquals(message, 0, compiler.getErrorCount());\n+    assertEquals(0, compiler.getErrorCount());\n     return n;\n   }\n \n--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n         \"foo\", null, false, callInLoop);\n   }\n \n-  public void testMutateFunctionDefinition() {\n-     // function declarations are rewritten as function\n-     // expressions\n-     helperMutate(\n-        \"function foo(a){function g(){}}; foo(1);\",\n-        \"{var g$$inline_3=function(){};}\",\n-        \"foo\", null);\n-  }\n \n   public void helperMutate(\n       String code, final String expectedResult, final String fnName) {\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n   }\n \n   public void testInlineFunctions15b() {\n-    // closure factories: don't inline closure with locals in global scope.\n+    // closure factories: don't inline closure with locals.\n     test(\"function foo(){var x;return function(a){return a+1}}\" +\n          \"var b=function(){return c};\" +\n          \"var d=b()+foo()\",\n   }\n \n   public void testInlineFunctions15c() {\n-    // closure factories: inline into non-global scope.\n+    // closure factories: don't inline into non-global scope.\n     test(\"function foo(){return function(a){return a+1}}\" +\n          \"var b=function(){return c};\" +\n          \"function _x(){ var d=b()+foo() }\",\n \n-         \"function _x(){ var d=c+function(a){return a+1}}\");\n-  }\n-\n-  public void testInlineFunctions15d() {\n-    // closure factories: don't inline functions with vars.\n-    test(\"function foo(){var x; return function(a){return a+1}}\" +\n-         \"var b=function(){return c};\" +\n-         \"function _x(){ var d=b()+foo() }\",\n-\n-         \"function foo(){var x; return function(a){return a+1}}\" +\n+         \"function foo(){return function(a){return a+1}}\" +\n          \"function _x(){ var d=c+foo() }\");\n   }\n \n-  public void testInlineFunctions16a() {\n+  public void testInlineFunctions16() {\n+    // watch out for closures that are deeper in the function\n     testSame(\"function foo(b){return window.bar(function(){c(b)})}\" +\n-         \"var d=foo(e)\");\n-  }\n-\n-  public void testInlineFunctions16b() {\n-    test(\"function foo(){return window.bar(function(){c()})}\" +\n-         \"var d=foo(e)\",\n-         \"var d=window.bar(function(){c()})\");\n+             \"var d=foo(e)\");\n   }\n \n   public void testInlineFunctions17() {\n   }\n \n   public void testComplexFunctionWithFunctionDefinition2() {\n-    // Don't inline if local names might be captured.\n+    // Don't inline if local names might need to be captured.\n     testSame(\"function f(a){call(function(){return})}f()\");\n-  }\n-\n-  public void testComplexFunctionWithFunctionDefinition2a() {\n-    // Don't inline if local names might be captured.\n-    testSame(\"(function(){\" +\n-        \"var f = function(a){call(function(){return})};f()})()\");\n-  }\n-\n-  public void testComplexFunctionWithFunctionDefinition2b() {\n-    // Don't inline if local names might be captured.\n-    test(\"(function(){function f(){call(function(){return})}f()})()\",\n-         \"{{call(function(){return})}}\");\n-  }\n-\n-  public void testComplexFunctionWithFunctionDefinition2c() {\n-    // Don't inline if local names might be captured.\n-    test(\"(function(){function f(a){call(function(){return})}f()})()\",\n-      \"{var f$$inline_1 = function(a$$inline_2){call(function(){return})};\" +\n-      \"f$$inline_1()}\"\n-      );\n   }\n \n   public void testComplexFunctionWithFunctionDefinition3() {\n     // Don't inline if local names might need to be captured.\n     testSame(\"function f(){var a; call(function(){return})}f()\");\n-  }\n-\n-  public void testComplexFunctionWithFunctionDefinition3a() {\n-    // Don't inline if local names might need to be captured.\n-    test(\"(function(){function f(){var a; call(function(){return})}f()})()\",\n-        \"{var f$$inline_1 = function() {\" +\n-        \"  var a$$inline_2; call(function(){return})\" +\n-        \"};\" +\n-        \"f$$inline_1()}\");\n   }\n \n   public void testDecomposePlusEquals() {\n   }\n \n   public void testFunctionExpressionCallInlining11c() {\n-    // Can inline, not temps needed.\n-    test(\"function _x() {\" +\n-         \"  ((function(){return function(){foo()}})())();\" +\n-         \"}\",\n-         \"function _x() {\" +\n-         \"  {foo();}\" +\n-         \"}\");\n-  }\n-\n-  public void testFunctionExpressionCallInlining11d() {\n-    // Yes, inline into a function containing eval, if\n-    // no temps are introduced.\n-    test(\"function _x() {\" +\n-         \"  eval();\" +\n-         \"  ((function(){return function(){foo()}})())();\" +\n-         \"}\",\n-         \"function _x() {\" +\n-         \"  eval();{foo();}\" +\n-         \"}\");\n-  }\n-\n-    public void testFunctionExpressionCallInlining11e() {\n-    // No, don't inline into a function containing eval,\n-    // if no temps are introduced.\n+    // Can't inline functions that return inner functions into non-global scope.\n     testSame(\"function _x() {\" +\n-         \"  eval();\" +\n-         \"  ((function(a){return function(){foo()}})())();\" +\n-         \"}\");\n+                \"((function(){return function(){foo()}})())();\" +\n+                \"}\");\n   }\n \n   public void testFunctionExpressionCallInlining12() {\n         \"})(jQuery)\");\n   }\n \n-  public void testAnonymous1() {\n-    test(\"(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();\",\n-         \"{var a$$inline_2=10;\" +\n-         \"{var b$$inline_3=a$$inline_2;\" +\n-         \"a$$inline_2++;alert(b$$inline_3)}}\");\n-  }\n-\n-  public void testAnonymous2() {\n-    testSame(\"(function(){eval();(function(){var b=a;a++;alert(b)})()})();\");\n-  }\n-\n-  public void testAnonymous3() {\n-    // Introducing a new value into is tricky\n-    testSame(\"(function(){var a=10;(function(){arguments;})()})();\");\n-    test(\"(function(){(function(){arguments;})()})();\",\n-        \"{(function(){arguments;})()}\");\n-  }\n-\n   // Inline a single reference function into deeper modules\n   public void testCrossModuleInlining1() {\n     test(createModuleChain(", "timestamp": 1312840285, "metainfo": ""}