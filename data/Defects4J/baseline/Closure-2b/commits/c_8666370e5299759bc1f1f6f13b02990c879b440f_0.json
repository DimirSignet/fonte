{"sha": "8666370e5299759bc1f1f6f13b02990c879b440f", "log": "Automated g4 rollback.  *** Reason for rollback ***  Fixed.  *** Original change description ***  Automated g4 rollback of changelist 20097784.  *** Reason for rollback ***  Breaks contacts tests  *** Original change description ***  Modify optimize parameter to fixed but mutable expressions to be moved from the call site to the function body when possible.  R=acleung DELTA=351  (303 added, 16 deleted, 32 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1002   ", "commit": "\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n \n   private final AbstractCompiler compiler;\n+  private List<Node> removedNodes = Lists.newArrayList();\n \n   OptimizeParameters(AbstractCompiler compiler) {\n     this.compiler = compiler;\n-  }\n-\n-  // TODO(johnlenz): Remove this.\n-  OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph unused) {\n-    this(compiler);\n   }\n \n   @Override\n   @VisibleForTesting\n   public void process(Node externs, Node root) {\n+    Preconditions.checkState(\n+        compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);\n     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n     defFinder.process(externs, root);\n     process(externs, root, defFinder);\n         tryEliminateConstantArgs(defSite, definitions);\n         tryEliminateOptionalArgs(defSite, definitions);\n       }\n+    }\n+\n+    // Remove any references or definitions that have been removed to keep it\n+    // in a consistent state for the next pass.\n+    for (Node n : removedNodes) {\n+      definitions.removeReferences(n);\n     }\n   }\n \n     // Build a list of parameters to remove\n     Definition definition = defSite.definition;\n     Collection<UseSite> useSites = defFinder.getUseSites(definition);\n+    boolean continueLooking = false;\n     for (UseSite site : useSites) {\n       Preconditions.checkState(SimpleDefinitionFinder.isCallOrNewSite(site));\n       Node call = site.node.getParent();\n       if (firstCall) {\n         // Use the first call to construct a list of parameters of the\n         // function.\n-        buildParameterList(parameters, cur);\n+        continueLooking = buildParameterList(parameters, cur, site.scope);\n         firstCall = false;\n       } else {\n-        findConstantParameters(parameters, cur);\n-      }\n+        continueLooking= findFixedParameters(parameters, cur);\n+      }\n+      if (!continueLooking) {\n+        return;\n+      }\n+    }\n+\n+    continueLooking = adjustForSideEffects(parameters);\n+    if (!continueLooking) {\n+      return;\n     }\n \n     // Remove the constant parameters in all the calls\n       Preconditions.checkState(SimpleDefinitionFinder.isCallOrNewSite(site));\n       Node call = site.node.getParent();\n \n-      optimizeCallSite(parameters, call);\n+      optimizeCallSite(defFinder, parameters, call);\n     }\n \n     // Remove the constant parameters in the definitions and add it as a local\n     }\n   }\n \n-  private void findConstantParameters(List<Parameter> parameters, Node cur) {\n+  /**\n+   * Adjust the parameters to move based on the side-effects seen.\n+   * @return Whether there are any movable parameters.\n+   */\n+  private boolean adjustForSideEffects(List<Parameter> parameters) {\n+    // If a parameter is moved, that has side-effect no parameters that\n+    // can be effected by side-effects can be left.\n+\n+    // A parameter can be moved if it can't be side-effected (immutable),\n+    // or there are no following side-effects, that aren't moved.\n+\n+    boolean anyMovable = false;\n+    boolean seenUnmovableSideEffects = false;\n+    boolean seenUnmoveableSideEfffected = false;\n+    for (int i = parameters.size() - 1; i >= 0; i--) {\n+      Parameter current = parameters.get(i);\n+\n+      // Preserve side-effect ordering, don't move this parameter if:\n+      // * the current parameter has side-effects and a following\n+      // parameters that will not be move can be effected.\n+      // * the current parameter can be effected and a following\n+      // parameter that will not be moved has side-effects\n+\n+      if (current.shouldRemove\n+          && ((seenUnmovableSideEffects && current.canBeSideEffected())\n+          || (seenUnmoveableSideEfffected && current.hasSideEffects()))) {\n+        current.shouldRemove = false;\n+      }\n+\n+      if (current.shouldRemove) {\n+        anyMovable = true;\n+      } else {\n+        if (current.canBeSideEffected) {\n+          seenUnmoveableSideEfffected = true;\n+        }\n+\n+        if (current.hasSideEffects) {\n+          seenUnmovableSideEffects = true;\n+        }\n+      }\n+    }\n+    return anyMovable;\n+  }\n+\n+  /**\n+   * Detemine which parameter use the same expression.\n+   * @return Whether any parameter was found that can be updated.\n+   */\n+  private boolean findFixedParameters(List<Parameter> parameters, Node cur) {\n+    boolean anyMovable = false;\n     int index = 0;\n     while ((cur = cur.getNext()) != null) {\n+      Parameter p;\n       if (index >= parameters.size()) {\n-        parameters.add(new Parameter(cur, false));\n-      } else if (parameters.get(index).shouldRemove()) {\n-        Node value = parameters.get(index).getArg();\n-        if (!nodesAreEqual(cur, value)) {\n-          parameters.get(index).setShouldRemove(false);\n+        p = new Parameter(cur, false);\n+        parameters.add(p);\n+      } else {\n+        p = parameters.get(index);\n+        if (p.shouldRemove()) {\n+          Node value = p.getArg();\n+          if (!cur.isEquivalentTo(value)) {\n+            p.setShouldRemove(false);\n+          } else {\n+            anyMovable = true;\n+          }\n         }\n       }\n+\n+      setParameterSideEffectInfo(p, cur);\n       index++;\n     }\n \n     for (;index < parameters.size(); index++) {\n       parameters.get(index).setShouldRemove(false);\n     }\n-  }\n-\n-  private void buildParameterList(List<Parameter> parameters, Node cur) {\n+\n+    return anyMovable;\n+  }\n+\n+  /**\n+   * @return Whether any parameter was movable.\n+   */\n+  private boolean buildParameterList(\n+      List<Parameter> parameters, Node cur, Scope s) {\n+    boolean anyMovable = false;\n     while ((cur = cur.getNext()) != null) {\n-      parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur, false)));\n-    }\n+      boolean movable = isMovableValue(cur, s);\n+      Parameter p = new Parameter(cur, movable);\n+      setParameterSideEffectInfo(p, cur);\n+      parameters.add(p);\n+      if (movable) {\n+        anyMovable = true;\n+      }\n+    }\n+    return anyMovable;\n+  }\n+\n+  private void setParameterSideEffectInfo(Parameter p, Node value) {\n+    if (!p.hasSideEffects()) {\n+      p.setHasSideEffects(NodeUtil.mayHaveSideEffects(value, compiler));\n+    }\n+\n+    if (!p.canBeSideEffected()) {\n+      p.setCanBeSideEffected(NodeUtil.canBeSideEffected(value));\n+    }\n+  }\n+\n+\n+  /**\n+   * @return Whether the expression can be safely moved to another function\n+   *   in another scope.\n+   */\n+  private boolean isMovableValue(Node n, Scope s) {\n+    // Things that can change value or are inaccessible can't be moved, these\n+    // are \"this\", \"arguments\", local names, and functions that capture local\n+    // values.\n+    switch (n.getType()) {\n+      case Token.THIS:\n+        return false;\n+      case Token.FUNCTION:\n+        // Don't move function closures.\n+        // TODO(johnlenz): Closure that only contain global reference can be\n+        // moved.\n+        return false;\n+      case Token.NAME:\n+        if (n.getString().equals(\"arguments\")) {\n+          return false;\n+        } else {\n+          Var v = s.getVar(n.getString());\n+          if (v != null && v.isLocal()) {\n+            return false;\n+          }\n+        }\n+        break;\n+    }\n+\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      if (!isMovableValue(c, s)) {\n+        return false;\n+      }\n+    }\n+    return true;\n   }\n \n   private void optimizeFunctionDefinition(List<Parameter> parameters,\n     }\n   }\n \n-  private void optimizeCallSite(List<Parameter> parameters, Node call) {\n+  private void optimizeCallSite(\n+      SimpleDefinitionFinder defFinder, List<Parameter> parameters, Node call) {\n     for (int index = parameters.size() - 1; index >= 0; index--) {\n-      if (parameters.get(index).shouldRemove()) {\n-        eliminateCallParamAt(call, index);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Node equality as intended by the this pass.\n-   * @param n1 A node\n-   * @param n2 A node\n-   * @return true if both node are considered equal for the purposes of this\n-   * class, false otherwise.\n-   */\n-  private boolean nodesAreEqual(Node n1, Node n2) {\n-    return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&\n-        n1.isEquivalentTo(n2);\n+      Parameter p = parameters.get(index);\n+      if (p.shouldRemove()) {\n+        eliminateCallParamAt(defFinder, p, call, index);\n+      }\n+    }\n   }\n \n   /**\n   private static class Parameter {\n     private final Node arg;\n     private boolean shouldRemove;\n+    private boolean hasSideEffects;\n+    private boolean canBeSideEffected;\n \n     public Parameter(Node arg, boolean shouldRemove) {\n       this.shouldRemove = shouldRemove;\n \n     public void setShouldRemove(boolean value) {\n       shouldRemove = value;\n+    }\n+\n+    public void setHasSideEffects(boolean hasSideEffects) {\n+      this.hasSideEffects = hasSideEffects;\n+    }\n+\n+    public boolean hasSideEffects() {\n+      return hasSideEffects;\n+    }\n+\n+    public void setCanBeSideEffected(boolean canBeSideEffected) {\n+      this.canBeSideEffected = canBeSideEffected;\n+    }\n+\n+    public boolean canBeSideEffected() {\n+      return canBeSideEffected;\n     }\n   }\n \n     Preconditions.checkArgument(block.getType() == Token.BLOCK,\n         \"Node must be a block.\");\n \n-    Node newVar = NodeUtil.newVarNode(varName.getQualifiedName(),\n-        value.cloneTree());\n+    Preconditions.checkState(value.getParent() == null);\n+    Node newVar = NodeUtil.newVarNode(varName.getString(), value);\n     block.addChildToFront(newVar);\n     compiler.reportCodeChange();\n   }\n \n   /**\n    * Eliminates the parameter from a function call.\n+   * @param defFinder\n+   * @param p\n    * @param call The function call node\n    * @param argIndex The index of the the argument to remove.\n    * @return The Node of the argument removed.\n    */\n-  private Node eliminateCallParamAt(Node call, int argIndex) {\n+  private Node eliminateCallParamAt(\n+      SimpleDefinitionFinder defFinder, Parameter p, Node call, int argIndex) {\n     Preconditions.checkArgument(\n         NodeUtil.isCallOrNew(call), \"Node must be a call or new.\");\n \n \n     if (formalArgPtr != null) {\n       call.removeChild(formalArgPtr);\n+      // The value in the parameter object is the one that is being moved into\n+      // function definition leave that one's references.  For everthing else,\n+      // remove any references.\n+      if (p.getArg() != formalArgPtr) {\n+        removedNodes.add(formalArgPtr);\n+      }\n       compiler.reportCodeChange();\n     }\n     return formalArgPtr;\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n       Preconditions.checkNotNull(name);\n       nameUseSiteMultimap.put(\n           name,\n-          new UseSite(node, traversal.getModule()));\n+          new UseSite(node, traversal.getScope(), traversal.getModule()));\n     }\n   }\n \n       }\n       String name = getSimplifiedName(useSite);\n       if (name != null) {\n-        this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null));\n+        this.nameUseSiteMultimap.remove(name, new UseSite(useSite, null, null));\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/UseSite.java\n+++ b/src/com/google/javascript/jscomp/UseSite.java\n \n class UseSite {\n   final Node node;\n+  final Scope scope;\n   final JSModule module;\n \n-  UseSite(Node node, JSModule module) {\n+  UseSite(Node node, Scope scope, JSModule module) {\n     this.node = node;\n+    this.scope = scope;\n     this.module = module;\n   }\n \n--- a/test/com/google/javascript/jscomp/OptimizeParametersTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeParametersTest.java\n \n   @Override\n   public void setUp() {\n+    super.enableNormalize();\n     super.enableLineNumberCheck(false);\n   }\n \n   }\n \n   public void testAliasMethodsDontGetOptimize4() {\n-    String src = \"function foo(bar) {};\" +\n-        \"baz = function(a) {};\" +\n-        \"baz(1);\" +\n-        \"foo(baz);\"; // Baz should be aliased.\n-    testSame(src);\n+    // Don't change the call to baz as it has been aliased.\n+\n+    test(\n+      \"function foo(bar) {};\" +\n+      \"baz = function(a) {};\" +\n+      \"baz(1);\" +\n+      \"foo(baz);\",\n+      \"function foo() {var bar = baz};\" +\n+      \"baz = function(a) {};\" +\n+      \"baz(1);\" +\n+      \"foo();\");\n   }\n \n   public void testMethodsDefinedInArraysDontGetOptimized() {\n     testSame(\"function JSCompiler_ObjectPropertyString(a, b) {return a[b]};\" +\n              \"JSCompiler_renameProperty(window,'b');\");\n   }\n+\n+  public void testMutableValues1() {\n+    test(\"function foo(p1) {} foo()\",\n+         \"function foo() {var p1} foo()\");\n+    test(\"function foo(p1) {} foo(1)\",\n+         \"function foo() {var p1=1} foo()\");\n+    test(\"function foo(p1) {} foo([])\",\n+         \"function foo() {var p1=[]} foo()\");\n+    test(\"function foo(p1) {} foo({})\",\n+         \"function foo() {var p1={}} foo()\");\n+    test(\"var x;function foo(p1) {} foo(x)\",\n+         \"var x;function foo() {var p1=x} foo()\");\n+    test(\"var x;function foo(p1) {} foo(x())\",\n+         \"var x;function foo() {var p1=x()} foo()\");\n+    test(\"var x;function foo(p1) {} foo(new x())\",\n+         \"var x;function foo() {var p1=new x()} foo()\");\n+    test(\"var x;function foo(p1) {} foo('' + x)\",\n+         \"var x;function foo() {var p1='' + x} foo()\");\n+\n+    testSame(\"function foo(p1) {} foo(this)\");\n+    testSame(\"function foo(p1) {} foo(arguments)\");\n+    testSame(\"function foo(p1) {} foo(function(){})\");\n+    testSame(\"function foo(p1) {} (function () {var x;foo(x)})()\");\n+  }\n+\n+  public void testMutableValues2() {\n+    test(\"function foo(p1, p2) {} foo(1, 2)\",\n+         \"function foo() {var p1=1; var p2 = 2} foo()\");\n+    test(\"var x; var y; function foo(p1, p2) {} foo(x(), y())\",\n+         \"var x; var y; function foo() {var p1=x(); var p2 = y()} foo()\");\n+  }\n+\n+  public void testMutableValues3() {\n+    test(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2) {}\" +\n+        \"foo(x(), y()); foo(x(),y())\",\n+        \"var x; var y; var z;\" +\n+        \"function foo() {var p1=x(); var p2=y()}\" +\n+        \"foo(); foo()\");\n+  }\n+\n+  public void testMutableValues4() {\n+    // Preserve the ordering of side-effects.\n+    // If z(), can't be moved into the function then z() may change the value\n+    // of x and y.\n+    testSame(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2, p3) {}\" +\n+        \"foo(x(), y(), z()); foo(x(),y(),3)\");\n+\n+    // If z(), can't be moved into the function then z() may change the value\n+    // of x and y.\n+    testSame(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2, p3) {}\" +\n+        \"foo(x, y(), z()); foo(x,y(),3)\");\n+\n+    // Mutable object that can not be effect by side-effects are movable,\n+    // however.\n+    test(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2, p3) {}\" +\n+        \"foo([], y(), z()); foo([],y(),3)\",\n+        \"var x; var y; var z;\" +\n+        \"function foo(p2, p3) {var p1=[]}\" +\n+        \"foo(y(), z()); foo(y(),3)\");\n+  }\n+\n+  public void testMutableValues5() {\n+    test(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2) {}\" +\n+        \"new foo(new x(), y()); new foo(new x(),y())\",\n+        \"var x; var y; var z;\" +\n+        \"function foo() {var p1=new x(); var p2=y()}\" +\n+        \"new foo(); new foo()\");\n+\n+    test(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2) {}\" +\n+        \"new foo(x(), y()); new foo(x(),y())\",\n+        \"var x; var y; var z;\" +\n+        \"function foo() {var p1=x(); var p2=y()}\" +\n+        \"new foo(); new foo()\");\n+\n+    testSame(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2, p3) {}\" +\n+        \"new foo(x(), y(), z()); new foo(x(),y(),3)\");\n+\n+    testSame(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2, p3) {}\" +\n+        \"new foo(x, y(), z()); new foo(x,y(),3)\");\n+\n+    test(\n+        \"var x; var y; var z;\" +\n+        \"function foo(p1, p2, p3) {}\" +\n+        \"new foo([], y(), z()); new foo([],y(),3)\",\n+        \"var x; var y; var z;\" +\n+        \"function foo(p2, p3) {var p1=[]}\" +\n+        \"new foo(y(), z()); new foo(y(),3)\");\n+  }\n+\n+  public void testShadows() {\n+    testSame(\"function foo(a) {}\" +\n+             \"var x;\" +\n+             \"function f() {\" +\n+             \"  var x;\" +\n+             \"  function g() {\" +\n+             \"    foo(x());\" +\n+             \"  }\" +\n+             \"};\" +\n+             \"foo(x())\");\n+  }\n+\n+  public void testCrash() {\n+    test(\n+        \"function foo(a) {}\" +\n+        \"foo({o:1});\" +\n+        \"foo({o:1})\",\n+        \"function foo() {var a = {o:1}}\" +\n+        \"foo();\" +\n+        \"foo()\");\n+  }\n+\n }", "timestamp": 1300821566, "metainfo": ""}