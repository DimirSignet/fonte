{"sha": "599e40891b9e5cb55af2dd3bb8027cee846087c1", "log": "FunctionType needs to know about proxy types.  R=nicksantos DELTA=38  (27 added, 7 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=373001   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/AllType.java\n+++ b/src/com/google/javascript/rhino/jstype/AllType.java\n \n   /**\n    * The All type is the greatest type (top) and is never a subtype of\n-   * another except itself or the Unknown type.\n+   * another except itself or the Unknown type or a named alias.\n    * @return {@code this.isEquivalentTo(that)}\n    */\n   @Override\n   public boolean isSubtype(JSType that) {\n-    return that.isAllType() || that.isUnknownType();\n+    return JSType.isSubtype(this, that);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n    */\n   @Override\n   public boolean isSubtype(JSType that) {\n-    if (this.isEquivalentTo(that)) {\n+    if (JSType.isSubtype(this, that)) {\n       return true;\n     }\n+\n     if (that.isFunctionType()) {\n       if (((FunctionType) that).isInterface()) {\n         // Any function can be assigned to an interface function.\n               this.typeOfThis.isSubtype(other.typeOfThis)) &&\n           this.call.isSubtype(other.call);\n     }\n-    if (that instanceof UnionType) {\n-      UnionType union = (UnionType) that;\n-      for (JSType element : union.alternates) {\n-        if (this.isSubtype(element)) {\n-          return true;\n-        }\n-      }\n-    }\n+\n     return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         JSType typeI = typeChain.get(i);\n         JSType typeJ = typeChain.get(j);\n \n+        JSType namedTypeI = getNamedWrapper(\"TypeI\", typeI);\n+        JSType namedTypeJ = getNamedWrapper(\"TypeJ\", typeJ);\n+\n         if (i == j) {\n           assertTrue(typeI + \" should equal itself\",\n               typeI.isEquivalentTo(typeI));\n+          assertTrue(\"Named \" + typeI + \" should equal itself\",\n+              namedTypeI.isEquivalentTo(namedTypeI));\n         } else {\n           assertFalse(typeI + \" should not equal \" + typeJ,\n               typeI.isEquivalentTo(typeJ));\n+          assertFalse(\"Named \" + typeI + \" should not equal \" + typeJ,\n+              namedTypeI.isEquivalentTo(namedTypeJ));\n         }\n \n         if (checkSubtyping) {\n           if (i <= j) {\n             assertTrue(typeJ + \" should be a subtype of \" + typeI,\n                 typeJ.isSubtype(typeI));\n+            assertTrue(\n+                \"Named \" + typeJ + \" should be a subtype of Named \" + typeI,\n+                namedTypeJ.isSubtype(namedTypeI));\n           } else {\n             assertFalse(typeJ + \" should not be a subtype of \" + typeI,\n                 typeJ.isSubtype(typeI));\n+            assertFalse(\n+                \"Named \" + typeJ + \" should not be a subtype of Named \" + typeI,\n+                namedTypeJ.isSubtype(namedTypeI));\n           }\n \n           JSType expectedSupremum = i < j ? typeI : typeJ;\n               expectedInfimum, typeI.getGreatestSubtype(typeJ));\n         }\n       }\n+    }\n+  }\n+\n+  JSType getNamedWrapper(String name, JSType jstype) {\n+    // Normally, there is no way to create a Named NoType alias so\n+    // avoid confusing things by doing it here..\n+    if (!jstype.isNoType()) {\n+      NamedType namedWrapper = new NamedType(\n+          registry, name, \"[testcode]\", -1, -1);\n+      namedWrapper.setReferencedType(jstype);\n+      return namedWrapper;\n+    } else {\n+      return jstype;\n     }\n   }\n ", "timestamp": 1287678221, "metainfo": ""}