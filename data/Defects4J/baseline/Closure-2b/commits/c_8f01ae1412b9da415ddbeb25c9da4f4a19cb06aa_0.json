{"sha": "8f01ae1412b9da415ddbeb25c9da4f4a19cb06aa", "log": "Handle another special case in the \"is this function inferred or declared?\" decision tree.  R=acleung DELTA=67  (63 added, 0 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4439   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n \n     /** Gets a list of variables in this scope that are escaped. */\n     Iterable<String> getEscapedVarNames();\n+\n+    /** Gets a list of variables whose properties are escaped. */\n+    Set<String> getEscapedQualifiedNames();\n   }\n \n   static class UnknownFunctionContents implements FunctionContents {\n     @Override\n     public Iterable<String> getEscapedVarNames() {\n       return ImmutableList.of();\n+    }\n+\n+    @Override\n+    public Set<String> getEscapedQualifiedNames() {\n+      return ImmutableSet.of();\n     }\n   }\n \n     private final Node n;\n     private boolean hasNonEmptyReturns = false;\n     private Set<String> escapedVarNames;\n+    private Set<String> escapedQualifiedNames;\n \n     AstFunctionContents(Node n) {\n       this.n = n;\n       }\n       escapedVarNames.add(name);\n     }\n+\n+    @Override\n+    public Set<String> getEscapedQualifiedNames() {\n+      return escapedQualifiedNames == null\n+          ? ImmutableSet.<String>of() : escapedQualifiedNames;\n+    }\n+\n+    void recordEscapedQualifiedName(String name) {\n+      if (escapedQualifiedNames == null) {\n+        escapedQualifiedNames = Sets.newHashSet();\n+      }\n+      escapedQualifiedNames.add(name);\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       Preconditions.checkArgument(qName != null && ownerName != null);\n \n       // Precedence of type information on GETPROPs:\n-      // 1) @type annnotation / @enum annotation\n+      // 1) @type annotation / @enum annotation\n       // 2) ASSIGN to FUNCTION literal\n       // 3) @param/@return annotation (with no function literal)\n       // 4) ASSIGN to something marked @const\n         if (info != null) {\n           inferred = false;\n         } else if (!scope.isDeclared(qName, false) &&\n-                   n.isUnscopedQualifiedName()) {\n-          inferred = false;\n+            n.isUnscopedQualifiedName()) {\n+\n+          // Check if this is assigned in an inner scope.\n+          AstFunctionContents contents =\n+              getFunctionAnalysisResults(scope.getRootNode());\n+          if (contents == null ||\n+              !contents.getEscapedQualifiedNames().contains(qName)) {\n+            inferred = false;\n+          }\n         }\n       }\n       return inferred;\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n-      } else if (n.isName() && NodeUtil.isLValue(n)) {\n+      }\n+\n+      if (t.getScopeDepth() <= 2) {\n+        // We only need to worry about escaped variables at depth 3.\n+        // An variable escaped at depth 2 is, by definition, a global variable.\n+        // We treat all global variables as escaped by default, so there's\n+        // no reason to do this extra computation for them.\n+        return;\n+      }\n+\n+      if (n.isName() && NodeUtil.isLValue(n)) {\n         String name = n.getString();\n         Scope scope = t.getScope();\n         Var var = scope.getVar(name);\n             data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n           }\n         }\n+      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n+          NodeUtil.isLValue(n)) {\n+        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(name);\n+        if (var != null) {\n+          Scope ownerScope = var.getScope();\n+          if (scope != ownerScope && ownerScope.isLocal()) {\n+            data.get(ownerScope.getRootNode())\n+                .recordEscapedQualifiedName(n.getQualifiedName());\n+          }\n+        }\n       }\n     }\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"  function F() {}\" +\n         \"  (new F());\" +\n         \"})();\");\n+  }\n+\n+  public void testQualifiedNameInference11() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"function f() {\" +\n+        \"  var x = new Foo();\" +\n+        \"  x.onload = function() {\" +\n+        \"    x.onload = null;\" +\n+        \"  };\" +\n+        \"}\");\n   }\n \n   public void testSheqRefinedScope() throws Exception {", "timestamp": 1332962511, "metainfo": ""}