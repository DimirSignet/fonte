{"sha": "5fa514bee8f76534232e4653eaf16cd416e08012", "log": "Change how Function prototypes are represented in the type system.  This fixes lots of bugs when an anonymous object is the prototype, and will make life a lot easier for IDEs.  R=johnlenz DELTA=370  (129 added, 177 deleted, 64 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3135   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n import com.google.javascript.jscomp.graph.SubGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.InstanceObjectType;\n import com.google.javascript.rhino.jstype.JSType;\n     related.set(getIntForType(type));\n \n     // A prototype is related to its instance.\n-    if (type instanceof FunctionPrototypeType) {\n-      addRelatedInstance(\n-          ((FunctionPrototypeType) type).getOwnerFunction(), related);\n+    if (type.isFunctionPrototypeType()) {\n+      addRelatedInstance(((ObjectType) type).getOwnerFunction(), related);\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n     } else if (type.isConstructor()) {\n       return (type.toMaybeFunctionType()).getInstanceType();\n     } else if (type.isFunctionPrototypeType()) {\n-      FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();\n+      FunctionType owner = ((ObjectType) type).getOwnerFunction();\n       if (owner.isConstructor()) {\n         return owner.getInstanceType();\n       }\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n     /** Returns the type of the constructor or null if this has none. */\n     ConcreteFunctionType getConstructorType() {\n       if (instanceType.isFunctionPrototypeType()) {\n-        FunctionPrototypeType protoType = (FunctionPrototypeType) instanceType;\n-        return factory.getConcreteFunction(protoType.getOwnerFunction());\n+        return factory.getConcreteFunction(instanceType.getOwnerFunction());\n       } else {\n         FunctionType constructor = instanceType.getConstructor();\n         return (constructor != null)\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n import com.google.javascript.jscomp.graph.UnionFind;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n \n     @Override public JSType getInstanceFromPrototype(JSType type) {\n       if (type.isFunctionPrototypeType()) {\n-        FunctionPrototypeType prototype = (FunctionPrototypeType) type;\n+        ObjectType prototype = (ObjectType) type;\n         FunctionType owner = prototype.getOwnerFunction();\n         if (owner.isConstructor() || owner.isInterface()) {\n-          return ((FunctionPrototypeType) type).getOwnerFunction()\n-              .getInstanceType();\n+          return prototype.getOwnerFunction().getInstanceType();\n         }\n       }\n       return null;\n         FunctionType constructor;\n         if (objType.isFunctionType()) {\n           constructor = objType.toMaybeFunctionType();\n-        } else if (objType instanceof FunctionPrototypeType) {\n-          constructor = ((FunctionPrototypeType) objType).getOwnerFunction();\n+        } else if (objType.isFunctionPrototypeType()) {\n+          constructor = objType.getOwnerFunction();\n         } else {\n           constructor = objType.getConstructor();\n         }\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n           .restrictByNotNullOrUndefined();\n       if (jsType.isPropertyInExterns(prop) && propType.isFunctionType()) {\n         ObjectType thisType = jsType;\n-        if (jsType instanceof FunctionPrototypeType) {\n-          thisType = ((FunctionPrototypeType) jsType)\n-              .getOwnerFunction().getInstanceType();\n+        if (jsType.isFunctionPrototypeType()) {\n+          thisType = thisType.getOwnerFunction().getInstanceType();\n         }\n         FunctionType callType = propType.toMaybeFunctionType();\n         Action action = createExternFunctionCall(\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n     String functionPrivateName = n.getFirstChild().getString();\n     if (functionType.isConstructor()) {\n-      FunctionType baseConstructor = functionType.\n-          getPrototype().getImplicitPrototype().getConstructor();\n+      FunctionType baseConstructor = functionType.getSuperClassConstructor();\n       if (baseConstructor != null &&\n           baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n           (baseConstructor.isInterface() && functionType.isConstructor())) {\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n \n package com.google.javascript.rhino.jstype;\n \n+import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n \n import com.google.common.base.Preconditions;\n    * graph, so some prototypes must temporarily be {@code null} during\n    * the construction of the graph.\n    */\n-  private FunctionPrototypeType prototype;\n+  private PrototypeObjectType prototype;\n \n   private SimpleSlot prototypeSlot;\n \n    * Gets the {@code prototype} property of this function type. This is\n    * equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}.\n    */\n-  public FunctionPrototypeType getPrototype() {\n+  public ObjectType getPrototype() {\n     // lazy initialization of the prototype field\n     if (prototype == null) {\n-      setPrototype(new FunctionPrototypeType(registry, this, null));\n+      setPrototype(\n+          new PrototypeObjectType(\n+              registry,\n+              this.getReferenceName() + \".prototype\",\n+              registry.getNativeObjectType(OBJECT_TYPE),\n+              isNativeObjectType()));\n     }\n     return prototype;\n   }\n    * @param baseType The base type.\n    */\n   public void setPrototypeBasedOn(ObjectType baseType) {\n-    if (prototype == null) {\n-      setPrototype(\n-          new FunctionPrototypeType(\n-              registry, this, baseType, isNativeObjectType()));\n-    } else {\n-      prototype.setImplicitPrototype(baseType);\n-    }\n+    // This is a bit weird. We need to successfully handle these\n+    // two cases:\n+    // Foo.prototype = new Bar();\n+    // and\n+    // Foo.prototype = {baz: 3};\n+    // In the first case, we do not want new properties to get\n+    // added to Bar. In the second case, we do want new properties\n+    // to get added to the type of the anonymous object.\n+    //\n+    // We handle this by breaking it into two cases:\n+    //\n+    // In the first case, we create a new PrototypeObjectType and set\n+    // its implicit prototype to the type being assigned. This ensures\n+    // that Bar will not get any properties of Foo.prototype, but properties\n+    // later assigned to Bar will get inherited properly.\n+    //\n+    // In the second case, we just use the anonymous object as the prototype.\n+    if (baseType.hasReferenceName() ||\n+        baseType.isUnknownType() ||\n+        isNativeObjectType() ||\n+        baseType.isFunctionPrototypeType() ||\n+        !(baseType instanceof PrototypeObjectType)) {\n+\n+      baseType = new PrototypeObjectType(\n+          registry, this.getReferenceName() + \".prototype\", baseType);\n+    }\n+    setPrototype((PrototypeObjectType) baseType);\n   }\n \n   /**\n    * @param prototype the prototype. If this value is {@code null} it will\n    *        silently be discarded.\n    */\n-  public boolean setPrototype(FunctionPrototypeType prototype) {\n+  public boolean setPrototype(PrototypeObjectType prototype) {\n     if (prototype == null) {\n       return false;\n     }\n     boolean replacedPrototype = prototype != null;\n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n+    this.prototype.setOwnerFunction(this);\n \n     if (isConstructor() || isInterface()) {\n       FunctionType superClass = getSuperClassConstructor();\n         if (objType.isEquivalentTo(prototype)) {\n           return true;\n         }\n-        return setPrototype(\n-            new FunctionPrototypeType(\n-                registry, this, objType, isNativeObjectType()));\n+        this.setPrototypeBasedOn(objType);\n+        return true;\n       } else {\n         return false;\n       }\n     setResolvedTypeInternal(this);\n \n     call = (ArrowType) safeResolve(call, t, scope);\n-    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    prototype = (PrototypeObjectType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n \n   @Override\n   boolean isTheObjectType() {\n-    return getConstructor().isNative() && \"Object\".equals(getReferenceName());\n+    return getConstructor().isNativeObjectType()\n+        && \"Object\".equals(getReferenceName());\n   }\n \n   @Override\n \n   @Override\n   public boolean isArrayType() {\n-    return getConstructor().isNative() && \"Array\".equals(getReferenceName());\n+    return getConstructor().isNativeObjectType()\n+        && \"Array\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isStringObjectType() {\n-    return getConstructor().isNative() && \"String\".equals(getReferenceName());\n+    return getConstructor().isNativeObjectType()\n+        && \"String\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isBooleanObjectType() {\n-    return getConstructor().isNative() && \"Boolean\".equals(getReferenceName());\n+    return getConstructor().isNativeObjectType()\n+        && \"Boolean\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isNumberObjectType() {\n-    return getConstructor().isNative() && \"Number\".equals(getReferenceName());\n+    return getConstructor().isNativeObjectType()\n+        && \"Number\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isDateType() {\n-    return getConstructor().isNative() && \"Date\".equals(getReferenceName());\n+    return getConstructor().isNativeObjectType()\n+        && \"Date\".equals(getReferenceName());\n   }\n \n   @Override\n   public boolean isRegexpType() {\n-    return getConstructor().isNative() && \"RegExp\".equals(getReferenceName());\n+    return getConstructor().isNativeObjectType()\n+        && \"RegExp\".equals(getReferenceName());\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n     // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n     // use each other's results, so at least one of them will get null\n     // instead of an actual type; however, this seems to be benign.\n-    ObjectType TOP_LEVEL_PROTOTYPE =\n-        new FunctionPrototypeType(this, null, null, true);\n+    PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n+        new PrototypeObjectType(this, null, null, true);\n     registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n \n     // Object\n         new FunctionType(this, \"Object\", null,\n             createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n             null, null, true, true);\n-    OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n-        \"prototype\", TOP_LEVEL_PROTOTYPE, null);\n+\n+    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE);\n     registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n+\n+    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n+    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n \n     ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n     registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n-\n-    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n-    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n \n     // Function\n     FunctionType FUNCTION_FUNCTION_TYPE =\n   public ObjectType createAnonymousObjectType() {\n     PrototypeObjectType type =\n         new PrototypeObjectType(this, null, null);\n+    type.setPrettyPrint(true);\n+    return type;\n+  }\n+\n+  /**\n+   * Create an anonymous object type for a native type.\n+   */\n+  ObjectType createNativeAnonymousObjectType() {\n+    PrototypeObjectType type =\n+        new PrototypeObjectType(this, null, null, true);\n     type.setPrettyPrint(true);\n     return type;\n   }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n     return type == null ? null : type.toObjectType();\n   }\n \n+  @Override\n+  public final boolean isFunctionPrototypeType() {\n+    return getOwnerFunction() != null;\n+  }\n+\n+  /** Gets the owner of this if it's a function prototype. */\n+  public FunctionType getOwnerFunction() {\n+    return null;\n+  }\n+\n   /**\n    * Gets the interfaces implemented by the ctor associated with this type.\n    * Intended to be overridden by subclasses.\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n \n import static com.google.common.base.Preconditions.checkState;\n \n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.ErrorReporter;\n   // Modelling this is a bear. Always call getImplicitPrototype(), because\n   // some subclasses override this to do special resolution handling.\n   private ObjectType implicitPrototypeFallback;\n+\n+  // If this is a function prototype, then this is the owner.\n+  // A PrototypeObjectType can only be the prototype of one function. If we try\n+  // to do this for multiple functions, then we'll have to create a new one.\n+  private FunctionType ownerFunction = null;\n \n   // Whether the toString representation of this should be pretty-printed,\n   // by printing all properties.\n    * present on the object and different from the native one.\n    */\n   private boolean hasOverridenNativeProperty(String propertyName) {\n-    if (isNative()) {\n+    if (isNativeObjectType()) {\n       return false;\n     }\n \n     return isRegexpType();\n   }\n \n-  /**\n-   * Whether this represents a native type (such as Object, Date,\n-   * RegExp, etc.).\n-   */\n-  boolean isNative() {\n-    return nativeType;\n-  }\n-\n   @Override\n   public String toString() {\n     if (hasReferenceName()) {\n   public String getReferenceName() {\n     if (className != null) {\n       return className;\n+    } else if (ownerFunction != null) {\n+      return ownerFunction.getReferenceName() + \".prototype\";\n     } else {\n       return null;\n     }\n \n   @Override\n   public boolean hasReferenceName() {\n-    return className != null;\n+    return className != null || ownerFunction != null;\n   }\n \n   @Override\n     return nativeType;\n   }\n \n+  void setOwnerFunction(FunctionType type) {\n+    Preconditions.checkState(ownerFunction == null);\n+    ownerFunction = type;\n+  }\n+\n+  @Override\n+  public FunctionType getOwnerFunction() {\n+    return ownerFunction;\n+  }\n+\n+  @Override\n+  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n+    return isFunctionPrototypeType()\n+        ? getOwnerFunction().getImplementedInterfaces()\n+        : ImmutableList.<ObjectType>of();\n+  }\n+\n+  @Override\n+  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n+    return isFunctionPrototypeType()\n+        ? getOwnerFunction().getExtendedInterfaces()\n+        : ImmutableList.<ObjectType>of();\n+  }\n+\n   @Override\n   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     setResolvedTypeInternal(this);\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public boolean isFunctionPrototypeType() {\n-    return referencedType.isFunctionPrototypeType();\n-  }\n-\n-  @Override\n   public boolean isEnumType() {\n     return referencedType.isEnumType();\n   }\n   }\n \n   @Override\n+  public boolean isNativeObjectType() {\n+    return referencedObjType == null\n+        ? false : referencedObjType.isNativeObjectType();\n+  }\n+\n+  @Override\n   public UnionType toMaybeUnionType() {\n     return referencedType.toMaybeUnionType();\n   }\n   @Override\n   public boolean isSubtype(JSType that) {\n     return referencedType.isSubtype(that);\n+  }\n+\n+  @Override\n+  public FunctionType getOwnerFunction() {\n+    return referencedObjType == null\n+        ? null : referencedObjType.getOwnerFunction();\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n     assertNull(obj.getPropertySlot(\"c\"));\n \n     // The prototype chain should be: MyObj -> MyObj.prototype -> Object ->\n-    // Object.prototype -> {...}.prototype -> null.\n-    for (int i = 0; i < 4; ++i) {\n+    // Object.prototype -> null.\n+    for (int i = 0; i < 3; ++i) {\n       assertNotNull(obj = obj.getImplicitPrototype());\n       assertTrue(obj.isInstance());\n     }\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n         + \"/** @type Foo */\\n\"\n         + \"var F = new Foo;\\n\"\n         + \"F.a = 0;\";\n-    // TODO(johnlenz): fix this. Doing nothing is safe, but\n-    // handling this would be better.\n-    String desired = \"{a=[[Foo.prototype]]}\";\n-    String expected = \"{}\";\n+    String expected = \"{a=[[Foo.prototype]]}\";\n     testSets(false, js, js, expected);\n-\n-    // Tighten types fails here.\n-    // testSets(true, js, js, expected);\n+    testSets(true, js, js, expected);\n   }\n \n   public void testOneType3() {\n         + \"/** @type Foo */\\n\"\n         + \"var F = new Foo;\\n\"\n         + \"F.a = 0;\";\n-    // TODO(johnlenz): fix this. Doing nothing is safe, but\n-    // handling this would be better.\n-    String desired = \"{a=[[Foo.prototype]]}\";\n-    String expected = \"{}\";\n+    String expected = \"{a=[[Foo.prototype]]}\";\n     testSets(false, js, js, expected);\n-\n-    // Tighten types fails here.\n-    // testSets(true, js, js, expected);\n+    testSets(true, js, js, expected);\n   }\n \n   public void testPrototypeAndInstance() {\n         + \"var B=new Bar;\"\n         + \"B.Bar_prototype$a=0\";\n \n-    // Would like it to be (but doing nothing is safe):\n-    // testSets(false, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n-    testSets(false, js, js, \"{}\");\n-    // TODO(johnlenz): If tighten types is completed, this needs to be fixed.\n-    // testSets(true, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+    testSets(false, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+    testSets(true, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n   }\n \n   public void testTwoTypes3() {\n         + \"var B=new Bar;\"\n         + \"B.Bar_prototype$a=0\";\n \n-    // Would like it to be (but doing nothing is safe):\n-    // testSets(false, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n-    testSets(false, js, js, \"{}\");\n-    // TODO(johnlenz): If tighten types is completed, this needs to be fixed.\n-    // testSets(true, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+    testSets(false, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n+    testSets(true, js, output, \"{a=[[Bar.prototype], [Foo.prototype]]}\");\n   }\n \n   public void testTwoFields() {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"function f(foo) {\" +\n         \"  return foo.x;\" +\n         \"}\");\n+  }\n+\n+  public void testAnonymousPrototype1() throws Exception {\n+    testTypes(\n+        \"var ns = {};\" +\n+        \"/** @constructor */ ns.Foo = function() {\" +\n+        \"  this.bar(3, 5);\" +\n+        \"};\" +\n+        \"ns.Foo.prototype = {\" +\n+        \"  bar: function(x) {}\" +\n+        \"};\",\n+        \"Function ns.Foo.prototype.bar: called with 2 argument(s). \" +\n+        \"Function requires at least 1 argument(s) and no more \" +\n+        \"than 1 argument(s).\");\n+  }\n+\n+  public void testAnonymousPrototype2() throws Exception {\n+    testTypes(\n+        \"/** @interface */ var Foo = function() {};\" +\n+        \"Foo.prototype = {\" +\n+        \"  foo: function(x) {}\" +\n+        \"};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @implements {Foo}\\n\" +\n+        \" */ var Bar = function() {};\",\n+        \"property foo on interface Foo is not implemented by type Bar\");\n   }\n \n   public void testAnonymousType1() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         RhinoErrorReporter.TYPE_PARSE_ERROR);\n     ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n     assertEquals(\"Foo\", x.toString());\n-    // Should be true\n-    assertFalse(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n+    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n     assertEquals(\"number\", x.getPropertyType(\"bar\").toString());\n     assertTrue(x.isPropertyTypeInferred(\"bar\"));\n   }\n         \"var x = window;\");\n     ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n     assertEquals(\"Window\", x.toString());\n-    // This should be TRUE\n-    assertFalse(x.getImplicitPrototype().hasOwnProperty(\"alert\"));\n-    /*\n-    assertEquals(\"function (this:Window, ?): undefined\",\n+    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"alert\"));\n+    assertEquals(\"function (?): undefined\",\n         x.getPropertyType(\"alert\").toString());\n-    assertTrue(x.isPropertyTypeDeclared(\"alert\"));\n+    assertFalse(x.isPropertyTypeDeclared(\"alert\"));\n \n     ObjectType y = (ObjectType) findNameType(\"y\", globalScope);\n-    assertEquals(\"function (this:Window, ?): undefined\",\n+    assertEquals(\"?\",\n         y.getPropertyType(\"alert\").toString());\n-    */\n   }\n \n   public void testAddMethodsPrototypeTwoWays() throws Exception {\n         instanceType.getPropertyType(\"m3\"));\n \n     // Verify the prototype chain.\n-    // The prototype property of a Function has to be a FunctionPrototypeType.\n-    // In order to make the type safety work out correctly, we create\n-    // a FunctionPrototypeType with the anonymous object as its implicit\n-    // prototype. Verify this behavior.\n+    // This is a special case where we want the anonymous object to\n+    // become a prototype.\n     assertFalse(instanceType.hasOwnProperty(\"m1\"));\n     assertFalse(instanceType.hasOwnProperty(\"m2\"));\n     assertFalse(instanceType.hasOwnProperty(\"m3\"));\n \n     ObjectType proto1 = instanceType.getImplicitPrototype();\n-    assertFalse(proto1.hasOwnProperty(\"m1\"));\n-    assertFalse(proto1.hasOwnProperty(\"m2\"));\n+    assertTrue(proto1.hasOwnProperty(\"m1\"));\n+    assertTrue(proto1.hasOwnProperty(\"m2\"));\n     assertTrue(proto1.hasOwnProperty(\"m3\"));\n \n     ObjectType proto2 = proto1.getImplicitPrototype();\n-    assertTrue(proto2.hasOwnProperty(\"m1\"));\n-    assertTrue(proto2.hasOwnProperty(\"m2\"));\n+    assertFalse(proto2.hasProperty(\"m1\"));\n+    assertFalse(proto2.hasProperty(\"m2\"));\n     assertFalse(proto2.hasProperty(\"m3\"));\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     assertTypeEquals(UNKNOWN_TYPE,\n         U2U_CONSTRUCTOR_TYPE.getPropertyType(\"anyProperty\"));\n \n-    assertTrue(U2U_CONSTRUCTOR_TYPE.isNative());\n     assertTrue(U2U_CONSTRUCTOR_TYPE.isNativeObjectType());\n \n     Asserts.assertResolvesToSame(U2U_CONSTRUCTOR_TYPE);\n     assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount());\n   }\n \n-  /**\n-   * Tests that the native constructor U2U_CONSTRUCTOR_TYPE is properly\n-   * implemented.\n-   */\n-  public void testFunctionCyclycity() throws Exception {\n-    FunctionPrototypeType instanceType =\n-        new FunctionPrototypeType(\n-            registry, U2U_CONSTRUCTOR_TYPE,\n-            U2U_CONSTRUCTOR_TYPE.getInstanceType());\n-    U2U_CONSTRUCTOR_TYPE.setPrototype(instanceType);\n-    U2U_CONSTRUCTOR_TYPE.detectImplicitPrototypeCycle();\n-    instanceType.detectImplicitPrototypeCycle();\n-  }\n-\n   /** Tests assigning jsdoc on a prototype property. */\n   public void testJSDocOnPrototypeProperty() throws Exception {\n     subclassCtor.setPropertyJSDocInfo(\"prototype\", new JSDocInfo());\n     assertTrue(fun.getInstanceType().isUnknownType());\n   }\n \n-  public void testInvalidSetPrototypeBasedOn() {\n+  public void testLateSetPrototypeBasedOn() {\n     FunctionType fun = registry.createConstructorType(\"fun\", null, null, null);\n     assertFalse(fun.getInstanceType().isUnknownType());\n \n-    // You cannot change the prototype chain after checking if it is unknown.\n-    try {\n-      fun.setPrototypeBasedOn(unresolvedNamedType);\n-      fail();\n-    } catch (IllegalStateException e) {\n-      e.printStackTrace();\n-    }\n+    fun.setPrototypeBasedOn(unresolvedNamedType);\n+    assertTrue(fun.getInstanceType().isUnknownType());\n   }\n \n   public void testGetTypeUnderEquality1() {", "timestamp": 1314285053, "metainfo": ""}