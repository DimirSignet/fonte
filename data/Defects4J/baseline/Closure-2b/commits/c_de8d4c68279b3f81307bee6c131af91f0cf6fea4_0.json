{"sha": "de8d4c68279b3f81307bee6c131af91f0cf6fea4", "log": "Making checkProvides and checkRequires hot-swappable.  R=nicksantos,acleung DELTA=116  (80 added, 9 deleted, 27 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1918   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckProvides.java\n+++ b/src/com/google/javascript/jscomp/CheckProvides.java\n  * Insures '@constructor X' has a 'goog.provide(\"X\")' .\n  *\n  */\n-class CheckProvides implements CompilerPass {\n+class CheckProvides implements HotSwapCompilerPass {\n   private final AbstractCompiler compiler;\n   private final CheckLevel checkLevel;\n   private final CodingConvention codingConvention;\n \n   @Override\n   public void process(Node externs, Node root) {\n+    hotSwapScript(root);\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot) {\n     CheckProvidesCallback callback =\n-      new CheckProvidesCallback(codingConvention);\n-    new NodeTraversal(compiler, callback).traverse(root);\n+        new CheckProvidesCallback(codingConvention);\n+    new NodeTraversal(compiler, callback).traverse(scriptRoot);\n   }\n \n   private class CheckProvidesCallback extends AbstractShallowCallback {\n--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n  * warning for each discrepancy.\n  *\n  */\n-class CheckRequiresForConstructors implements CompilerPass {\n+class CheckRequiresForConstructors implements HotSwapCompilerPass {\n   private final AbstractCompiler compiler;\n   private final CodingConvention codingConvention;\n   private final CheckLevel level;\n   public void process(Node externs, Node root) {\n     Callback callback = new CheckRequiresForConstructorsCallback();\n     new NodeTraversal(compiler, callback).traverseRoots(externs, root);\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot) {\n+    Callback callback = new CheckRequiresForConstructorsCallback();\n+    new NodeTraversal(compiler, callback).traverseWithScope(scriptRoot,\n+        SyntacticScopeCreator.generateUntypedTopScope(compiler));\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   };\n \n   /** Checks that all constructed classes are goog.require()d. */\n-  private final PassFactory checkRequires =\n-      new PassFactory(\"checkRequires\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  private final HotSwapPassFactory checkRequires =\n+      new HotSwapPassFactory(\"checkRequires\", true) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       return new CheckRequiresForConstructors(compiler, options.checkRequires);\n     }\n   };\n \n   /** Makes sure @constructor is paired with goog.provides(). */\n-  private final PassFactory checkProvides =\n-      new PassFactory(\"checkProvides\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  private final HotSwapPassFactory checkProvides =\n+      new HotSwapPassFactory(\"checkProvides\", true) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       return new CheckProvides(compiler, options.checkProvides);\n     }\n   };\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n \n   /**\n    * Handles a typedef definition for a goog.provided name.\n-   * @param An EXPR_RESULT node.\n+   * @param n EXPR_RESULT node.\n    */\n   private void handleTypedefDefinition(\n       NodeTraversal t, Node n, Node parent) {\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n    * Declares a variable.\n    *\n    * @param n The node corresponding to the variable name.\n-   * @param declaredType The variable's type, according to JSDoc\n    */\n   private void declareVar(Node n) {\n     Preconditions.checkState(n.getType() == Token.NAME);\n       scope.declare(name, n, null, input);\n     }\n   }\n+\n+\n+  /**\n+   * Generates an untyped global scope from the root of AST of compiler (which\n+   * includes externs).\n+   *\n+   * @param compiler The compiler for which the scope is generated.\n+   * @return The new untyped global scope generated as a result of this call.\n+   */\n+  static Scope generateUntypedTopScope(AbstractCompiler compiler) {\n+    return new SyntacticScopeCreator(compiler).createScope(compiler.getRoot(),\n+        null);\n+  }\n+\n+\n }\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n     NodeTraversal t = new NodeTraversal(compiler, this);\n     // Note we use the global scope to prevent wrong \"undefined-var errors\" on\n     // variables that are defined in other js files.\n-    //\n-    // TODO(bashir) Currently VarCheck is the only pass that its hotSwapScript\n-    // needs a global scope and cannot use global typed scope. If other passes\n-    // in future need a similar top scope we have to refactor the next scope\n-    // generation and generate such global scope only once.\n-    Scope scope = new SyntacticScopeCreator(compiler).createScope(\n-        compiler.getRoot(), null);\n-    t.traverseWithScope(scriptRoot, scope);\n+    t.traverseWithScope(scriptRoot,\n+        SyntacticScopeCreator.generateUntypedTopScope(compiler));\n     // TODO(bashir) Check if we need to createSynthesizedExternVar like process.\n   }\n ", "timestamp": 1305576845, "metainfo": ""}