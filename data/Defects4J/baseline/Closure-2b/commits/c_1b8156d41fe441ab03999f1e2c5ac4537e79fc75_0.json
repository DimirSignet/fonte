{"sha": "1b8156d41fe441ab03999f1e2c5ac4537e79fc75", "log": "Part 4, source name/input id split: Require an InputId to lookup a CompilerInput.  R=nicksantos DELTA=266  (106 added, 20 deleted, 140 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2899   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n   /**\n    * Looks up an input (possibly an externs input) by name. May return null.\n    */\n-  public abstract CompilerInput getInput(String sourceName);\n+  public abstract CompilerInput getInput(InputId inputId);\n \n   /**\n    * Creates a new externs file.\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n /**\n  * A compiler pass that checks that the programmer has obeyed all the access\n       if (docInfo != null) {\n         // If a name is private, make sure that we're in the same file.\n         Visibility visibility = docInfo.getVisibility();\n-        if (visibility == Visibility.PRIVATE &&\n-            !t.getInput().getName().equals(docInfo.getSourceName())) {\n-          if (docInfo.isConstructor() &&\n-              isValidPrivateConstructorAccess(parent)) {\n-            return;\n+        if (visibility == Visibility.PRIVATE) {\n+          StaticSourceFile varSrc = var.getSourceFile();\n+          StaticSourceFile refSrc = name.getStaticSourceFile();\n+          if (varSrc != null &&\n+              refSrc != null &&\n+              !varSrc.getName().equals(refSrc.getName())) {\n+            if (docInfo.isConstructor() &&\n+                isValidPrivateConstructorAccess(parent)) {\n+              return;\n+            }\n+\n+            compiler.report(\n+                t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n+                    name.getString(), varSrc.getName()));\n           }\n-\n-          compiler.report(\n-              t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n-                  name.getString(), docInfo.getSourceName()));\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n   Node jsRoot;\n   Node externAndJsRoot;\n \n-  private Map<String, CompilerInput> inputsByName;\n+  private Map<InputId, CompilerInput> inputsById;\n \n   /** The source code map */\n   private SourceMap sourceMap;\n     this.inputs = getAllInputsFromModules(modules);\n     initBasedOnOptions();\n \n-    initInputsByNameMap();\n+    initInputsByIdMap();\n   }\n \n   /**\n    */\n   public void rebuildInputsFromModules() {\n     inputs = getAllInputsFromModules(modules);\n-    initInputsByNameMap();\n+    initInputsByIdMap();\n   }\n \n   /**\n    * Creates a map to make looking up an input by name fast. Also checks for\n    * duplicate inputs.\n    */\n-  void initInputsByNameMap() {\n-    inputsByName = new HashMap<String, CompilerInput>();\n+  void initInputsByIdMap() {\n+    inputsById = new HashMap<InputId, CompilerInput>();\n     for (CompilerInput input : externs) {\n-      String name = input.getName();\n-      if (!inputsByName.containsKey(name)) {\n-        inputsByName.put(name, input);\n-      } else {\n-        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n+      InputId id = input.getInputId();\n+      CompilerInput previous = inputsById.put(id, input);\n+      if (previous != null) {\n+        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n       }\n     }\n     for (CompilerInput input : inputs) {\n-      String name = input.getName();\n-      if (!inputsByName.containsKey(name)) {\n-        inputsByName.put(name, input);\n-      } else {\n-        report(JSError.make(DUPLICATE_INPUT, name));\n+      InputId id = input.getInputId();\n+      CompilerInput previous = inputsById.put(id, input);\n+      if (previous != null) {\n+        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n       }\n     }\n   }\n   // interface, and which ones should always be injected.\n \n   @Override\n-  public CompilerInput getInput(String name) {\n-    return inputsByName.get(name);\n+  public CompilerInput getInput(InputId id) {\n+    return inputsById.get(id);\n   }\n \n   /**\n    * Removes an input file from AST.\n-   * @param name The name of the file to be removed.\n-   */\n-  protected void removeExternInput(String name) {\n-    CompilerInput input = getInput(name);\n+   * @param id The id of the input to be removed.\n+   */\n+  protected void removeExternInput(InputId id) {\n+    CompilerInput input = getInput(id);\n     if (input == null) {\n       return;\n     }\n     Preconditions.checkState(input.isExtern(), \"Not an extern input: \"\n         + input.getName());\n-    inputsByName.remove(name);\n+    inputsById.remove(id);\n     externs.remove(input);\n     Node root = input.getAstRoot(this);\n     if (root != null) {\n \n   @Override\n   public CompilerInput newExternInput(String name) {\n-    if (inputsByName.containsKey(name)) {\n+    SourceAst ast = new SyntheticAst(name);\n+    if (inputsById.containsKey(ast.getInputId())) {\n       throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n     }\n-    SourceAst ast = new SyntheticAst(name);\n-    CompilerInput input = new CompilerInput(ast, name, true);\n-    inputsByName.put(name, input);\n+    CompilerInput input = new CompilerInput(ast, true);\n+    inputsById.put(input.getInputId(), input);\n     externsRoot.addChildToFront(ast.getAstRoot(this));\n     externs.add(0, input);\n     return input;\n \n   /** Add a source input dynamically. Intended for incremental compilation. */\n   void addIncrementalSourceAst(JsAst ast) {\n-    String intputName = ast.getSourceFile().getName();\n+    InputId id = ast.getInputId();\n     Preconditions.checkState(\n-        getInput(intputName) == null,\n-        \"Duplicate input of name \" + intputName);\n-    inputsByName.put(intputName, new CompilerInput(ast));\n+        getInput(id) == null,\n+        \"Duplicate input \" + id.getIdName());\n+    inputsById.put(id, new CompilerInput(ast));\n   }\n \n   /**\n    * @return Whether the new AST was attached successfully.\n    */\n   boolean replaceIncrementalSourceAst(JsAst ast) {\n-    String inputName = ast.getSourceFile().getName();\n-    CompilerInput oldInput =\n-        Preconditions.checkNotNull(\n-            getInput(inputName),\n-            \"No input to replace: \" + inputName);\n+    CompilerInput oldInput = getInput(ast.getInputId());\n+    Preconditions.checkNotNull(\n+        oldInput,\n+        \"No input to replace: \" + ast.getInputId().getIdName());\n     Node newRoot = ast.getAstRoot(this);\n     if (newRoot == null) {\n       return false;\n     }\n \n     CompilerInput newInput = new CompilerInput(ast);\n-    inputsByName.put(inputName, newInput);\n+    inputsById.put(ast.getInputId(), newInput);\n \n     JSModule module = oldInput.getModule();\n     if (module != null) {\n       module.addAfter(newInput, oldInput);\n       module.remove(oldInput);\n     }\n+\n+    // Verify the input id is set properly.\n+    Preconditions.checkState(\n+        newInput.getInputId().equals(oldInput.getInputId()));\n+    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n+    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n+\n     return true;\n   }\n \n     return new JsAst(file).getAstRoot(this);\n   }\n \n+  private int syntheticCodeId = 0;\n+\n   @Override\n   Node parseSyntheticCode(String js) {\n     CompilerInput input = new CompilerInput(\n-        JSSourceFile.fromCode(\" [synthetic] \", js));\n-    inputsByName.put(input.getName(), input);\n+        JSSourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n+    inputsById.put(input.getInputId(), input);\n     return input.getAstRoot(this);\n   }\n \n     initCompilerOptionsIfTesting();\n     CompilerInput input = new CompilerInput(\n         JSSourceFile.fromCode(\" [testcode] \", js));\n-    if (inputsByName == null) {\n-      inputsByName = Maps.newHashMap();\n-    }\n-    inputsByName.put(input.getName(), input);\n+    if (inputsById == null) {\n+      inputsById = Maps.newHashMap();\n+    }\n+    inputsById.put(input.getInputId(), input);\n     return input.getAstRoot(this);\n   }\n \n   }\n \n   private SourceFile getSourceFileByName(String sourceName) {\n-    if (inputsByName.containsKey(sourceName)) {\n-      return inputsByName.get(sourceName).getSourceFile();\n+    // Here we assume that the source name is the input name, this\n+    // is try of javascript parsed from source.\n+    if (sourceName != null) {\n+      CompilerInput input = inputsById.get(new InputId(sourceName));\n+      if (input != null) {\n+        return input.getSourceFile();\n+      }\n     }\n     return null;\n   }\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n import java.io.IOException;\n import java.util.Collection;\n  *\n  */\n public class CompilerInput\n-    implements SourceAst, DependencyInfo, StaticSourceFile {\n+    implements SourceAst, DependencyInfo {\n+\n   private static final long serialVersionUID = 1L;\n \n   // Info about where the file lives.\n   private JSModule module;\n-  final private String name;\n   final private InputId id;\n \n   // The AST.\n   }\n \n   public CompilerInput(SourceAst ast, boolean isExtern) {\n-    this(ast, ast.getSourceFile().getName(), isExtern);\n-  }\n-\n-  public CompilerInput(SourceAst ast, String inputName, boolean isExtern) {\n+    this(ast, ast.getInputId(), isExtern);\n+  }\n+\n+  public CompilerInput(SourceAst ast, String inputId, boolean isExtern) {\n+    this(ast, new InputId(inputId), isExtern);\n+  }\n+\n+  public CompilerInput(SourceAst ast, InputId inputId, boolean isExtern) {\n     this.ast = ast;\n-    this.id = ast.getInputId();\n-    this.name = inputName;\n+    this.id = inputId;\n \n     // TODO(nicksantos): Add a precondition check here. People are passing\n     // in null, but they should not be.\n   }\n \n   public CompilerInput(JSSourceFile file, boolean isExtern) {\n-    this(new JsAst(file), file.getName(), isExtern);\n-  }\n-\n-  /** Returns a id for this input. Must be unique across all inputs. */\n+    this(new JsAst(file), isExtern);\n+  }\n+\n+  /** Returns a name for this input. Must be unique across all inputs. */\n   @Override\n   public InputId getInputId() {\n     return id;\n   /** Returns a name for this input. Must be unique across all inputs. */\n   @Override\n   public String getName() {\n-    return name;\n+    return id.getIdName();\n+  }\n+\n+  public SourceAst getAst() {\n+    return ast;\n   }\n \n   /** Gets the path relative to closure-base, if one is available. */\n     this.module = module;\n   }\n \n-  @Override\n   public boolean isExtern() {\n     if (ast == null || ast.getSourceFile() == null) {\n       return false;\n     ast.getSourceFile().setIsExtern(isExtern);\n   }\n \n-  @Override\n   public int getLineOffset(int lineno) {\n     return ast.getSourceFile().getLineOffset(lineno);\n   }\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n    */\n   FunctionTypeBuilder inferReturnStatementsAsLastResort(\n       @Nullable Node functionBlock) {\n-    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {\n+    if (functionBlock == null || functionBlock.isFromExterns()) {\n       return this;\n     }\n     Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n     }\n \n     Node node;\n-    final CompilerInput source;\n+    final JSModule module;\n+    final StaticSourceFile source;\n     final Name name;\n     final Type type;\n     final Scope scope;\n     Ref(NodeTraversal t, Node node, Name name, Type type, int index) {\n       this.node = node;\n       this.name = name;\n-      this.source = t.getInput();\n+      this.module = t.getInput() == null ? null : t.getInput().getModule();\n+      this.source = node.getStaticSourceFile();\n       this.type = type;\n       this.scope = t.getScope();\n       this.preOrderIndex = index;\n     private Ref(Ref original, Type type, int index) {\n       this.node = original.node;\n       this.name = original.name;\n+      this.module = original.module;\n       this.source = original.source;\n       this.type = type;\n       this.scope = original.scope;\n \n     private Ref(Type type, int index) {\n       this.type = type;\n+      this.module = null;\n       this.source = null;\n       this.scope = null;\n       this.name = null;\n     }\n \n     JSModule getModule() {\n-      return source == null ? null : source.getModule();\n+      return module;\n     }\n \n     String getSourceName() {\n--- a/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n+++ b/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n \n   private Map<String, ReferenceCollection> refMap = null;\n \n-  private final Map<String, Integer> inputOrder;\n+  private final Map<InputId, Integer> inputOrder;\n \n   /**\n    * @param inputs The ordered list of all inputs for the compiler.\n    */\n-  GlobalVarReferenceMap(List<CompilerInput> inputs,\n-      List<CompilerInput> externs) {\n+  GlobalVarReferenceMap(List<CompilerInput> inputs, List<CompilerInput> externs) {\n     inputOrder = Maps.newHashMap();\n     int ind = 0;\n     for (CompilerInput extern : externs) {\n-      inputOrder.put(extern.getName(), ind);\n+      inputOrder.put(extern.getInputId(), ind);\n       ind++;\n     }\n     for (CompilerInput input : inputs) {\n-      inputOrder.put(input.getName(), ind);\n+      inputOrder.put(input.getInputId(), ind);\n       ind++;\n     }\n   }\n       resetGlobalVarReferences(refMapPatch);\n       return;\n     }\n-    String sourceName = NodeUtil.getSourceName(root);\n-    Preconditions.checkNotNull(sourceName);\n+\n+    InputId inputId = root.getInputId();\n+    Preconditions.checkNotNull(inputId);\n     // Note there are two assumptions here (i) the order of compiler inputs\n     // has not changed and (ii) all references are in the order they appear\n     // in AST (this is enforced in ReferenceCollectionCallback).\n-    removeScriptReferences(sourceName);\n+    removeScriptReferences(inputId);\n     for (Entry<Var, ReferenceCollection> entry : refMapPatch.entrySet()) {\n       Var var = entry.getKey();\n       if (var.isGlobal()) {\n-        replaceReferences(var.getName(), sourceName, entry.getValue());\n-      }\n-    }\n-  }\n-\n-  private void removeScriptReferences(String sourceName) {\n+        replaceReferences(var.getName(), inputId, entry.getValue());\n+      }\n+    }\n+  }\n+\n+  private void removeScriptReferences(InputId inputId) {\n+    Preconditions.checkNotNull(inputId);\n+\n     // TODO(bashir): If this is too slow it is not too difficult to make it\n     // faster with keeping an index for variables accessed in sourceName.\n     for (ReferenceCollection collection : refMap.values()) {\n         continue;\n       }\n       List<Reference> oldRefs = collection.references;\n-      SourceRefRange range = findSourceRefRange(oldRefs, sourceName);\n+      SourceRefRange range = findSourceRefRange(oldRefs, inputId);\n       List<Reference> newRefs = Lists.newArrayList(range.refsBefore());\n       newRefs.addAll(range.refsAfter());\n       collection.references = newRefs;\n     }\n   }\n \n-  private void replaceReferences(String varName, String sourceName,\n+  private void replaceReferences(String varName, InputId inputId,\n       ReferenceCollection newSourceCollection) {\n     ReferenceCollection combined = new ReferenceCollection();\n     List<Reference> combinedRefs = combined.references;\n     }\n     // otherwise replace previous references that are from sourceName\n     SourceRefRange range = findSourceRefRange(oldCollection.references,\n-        sourceName);\n+      inputId);\n     combinedRefs.addAll(range.refsBefore());\n     combinedRefs.addAll(newSourceCollection.references);\n     combinedRefs.addAll(range.refsAfter());\n    * used to decide where to insert new sourceName refs.\n    */\n   private SourceRefRange findSourceRefRange(List<Reference> refList,\n-      String sourceName) {\n+      InputId inputId) {\n+    Preconditions.checkNotNull(inputId);\n+\n     // TODO(bashir): We can do binary search here, but since this is fast enough\n     // right now, we just do a linear search for simplicity.\n     int lastBefore = -1;\n     int firstAfter = refList.size();\n     int index = 0;\n-    int sourceInputOrder = inputOrder.get(sourceName);\n+\n+    Preconditions.checkState(inputOrder.containsKey(inputId), inputId.getIdName());\n+    int sourceInputOrder = inputOrder.get(inputId);\n     for (Reference ref : refList) {\n-      int order = inputOrder.get(ref.getSourceFile().getName());\n+      Preconditions.checkNotNull(ref.getInputId());\n+      int order = inputOrder.get(ref.getInputId());\n       if (order < sourceInputOrder) {\n         lastBefore = index;\n       } else if (order > sourceInputOrder) {\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n \n   /** The current source file name */\n   private String sourceName;\n+\n+  /** The current input */\n+  private InputId inputId;\n \n   /** The scope creator */\n   private ScopeCreator scopeCreator;\n       this.scopeCallback = (ScopedCallback) cb;\n     }\n     this.compiler = compiler;\n+    this.inputId = null;\n     this.sourceName = \"\";\n     this.scopeCreator = scopeCreator;\n   }\n     // TODO(user): It is possible to get more information if curNode or\n     // its parent is missing. We still have the scope stack in which it is still\n     // very useful to find out at least which function caused the exception.\n-    if (!sourceName.isEmpty()) {\n+    if (inputId != null) {\n       message =\n           unexpectedException.getMessage() + \"\\n\" +\n           formatNodeContext(\"Node\", curNode) +\n    */\n   public void traverse(Node root) {\n     try {\n+      inputId = NodeUtil.getInputId(root);\n       sourceName = \"\";\n       curNode = root;\n       pushScope(root);\n       Node scopeRoot = roots.get(0).getParent();\n       Preconditions.checkState(scopeRoot != null);\n \n+      inputId = NodeUtil.getInputId(scopeRoot);\n       sourceName = \"\";\n       curNode = scopeRoot;\n       pushScope(scopeRoot);\n   void traverseWithScope(Node root, Scope s) {\n     Preconditions.checkState(s.isGlobal());\n \n+    inputId = null;\n     sourceName = \"\";\n     curNode = root;\n     pushScope(s);\n     if (n.getType() == Token.FUNCTION) {\n       // We need to do some extra magic to make sure that the scope doesn't\n       // get re-created when we dive into the function.\n+      if (inputId == null) {\n+        inputId = NodeUtil.getInputId(n);\n+      }\n       sourceName = getSourceName(n);\n       curNode = n;\n       pushScope(s);\n    * Gets the current input source.\n    */\n   public CompilerInput getInput() {\n-    return compiler.getInput(sourceName);\n+    return compiler.getInput(inputId);\n   }\n \n   /**\n   private void traverseBranch(Node n, Node parent) {\n     int type = n.getType();\n     if (type == Token.SCRIPT) {\n+      inputId = n.getInputId();\n       sourceName = getSourceName(n);\n     }\n \n     return name == null ? \"\" : name;\n   }\n \n+  InputId getInputId() {\n+    return inputId;\n+  }\n+\n   /**\n    * Creates a JSError during NodeTraversal.\n    *\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n-import com.google.javascript.rhino.jstype.SimpleSourceFile;\n import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n import com.google.javascript.rhino.jstype.StaticSymbolTable;\n     private final Node nameNode;\n     private final BasicBlock basicBlock;\n     private final Scope scope;\n+    private final InputId inputId;\n     private final StaticSourceFile sourceFile;\n \n     Reference(Node nameNode, NodeTraversal t,\n         BasicBlock basicBlock) {\n-      this(nameNode, basicBlock, t.getScope(), t.getInput());\n+      this(nameNode, basicBlock, t.getScope(), t.getInput().getInputId());\n     }\n \n     // Bleeding functions are weird, because the declaration does\n     static Reference newBleedingFunction(NodeTraversal t,\n         BasicBlock basicBlock, Node func) {\n       return new Reference(func.getFirstChild(),\n-          basicBlock, t.getScope(), t.getInput());\n+          basicBlock, t.getScope(), t.getInput().getInputId());\n     }\n \n     /**\n      * Creates a variable reference in a given script file name, used in tests.\n      *\n-     * @param sourceName The name of the script file.\n      * @return The created reference.\n      */\n     @VisibleForTesting\n-    static Reference createRefForTest(String sourceName) {\n+    static Reference createRefForTest(CompilerInput input) {\n       return new Reference(new Node(Token.NAME), null, null,\n-          new SimpleSourceFile(sourceName, false));\n+          input.getInputId());\n     }\n \n     private Reference(Node nameNode,\n-        BasicBlock basicBlock, Scope scope, StaticSourceFile sourceFile) {\n+        BasicBlock basicBlock, Scope scope, InputId inputId) {\n       this.nameNode = nameNode;\n       this.basicBlock = basicBlock;\n       this.scope = scope;\n-      this.sourceFile = sourceFile;\n+      this.inputId = inputId;\n+      this.sourceFile = nameNode.getStaticSourceFile();\n     }\n \n     @Override\n     @Override\n     public Node getNode() {\n       return nameNode;\n+    }\n+\n+    public InputId getInputId() {\n+      return inputId;\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n import com.google.javascript.rhino.jstype.UnionType;\n \n import java.io.IOException;\n \n         String refName = objType.getReferenceName();\n \n-        String sourceName =\n-            NodeUtil.getSourceName(objType.getConstructor().getSource());\n-        CompilerInput sourceInput = compiler.getInput(sourceName);\n-        if (sourceInput == null || sourceInput.isExtern()) {\n+        StaticSourceFile sourceFile =\n+            NodeUtil.getSourceFile(objType.getConstructor().getSource());\n+        if (sourceFile == null || sourceFile.isExtern()) {\n           return new Node(Token.CALL,\n                   jsCode(\"externClassChecker\"),\n                   Node.newString(refName));\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n       return nameNode;\n     }\n \n+    CompilerInput getInput() {\n+      return input;\n+    }\n+\n     @Override\n     public StaticSourceFile getSourceFile() {\n-      return input;\n+      return nameNode.getStaticSourceFile();\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n class SyntacticScopeCreator implements ScopeCreator {\n   private final AbstractCompiler compiler;\n   private Scope scope;\n-  private String sourceName;\n+  private InputId inputId;\n   private final RedeclarationHandler redeclarationHandler;\n \n   // The arguments variable is special, in that it's declared in every local\n \n   @Override\n   public Scope createScope(Node n, Scope parent) {\n-    sourceName = null;\n+    inputId = null;\n     if (parent == null) {\n       scope = new Scope(n, compiler);\n     } else {\n \n     scanRoot(n, parent);\n \n-    sourceName = null;\n+    inputId = null;\n     Scope returnedScope = scope;\n     scope = null;\n     return returnedScope;\n \n   private void scanRoot(Node n, Scope parent) {\n     if (n.getType() == Token.FUNCTION) {\n-      sourceName = n.getSourceFileName();\n+      if (inputId == null) {\n+        inputId = NodeUtil.getInputId(n);\n+        Preconditions.checkNotNull(inputId);\n+      }\n \n       final Node fnNameNode = n.getFirstChild();\n       final Node args = fnNameNode.getNext();\n         return;  // only one child to scan\n \n       case Token.SCRIPT:\n-        sourceName = n.getSourceFileName();\n+        inputId = n.getInputId();\n+        Preconditions.checkNotNull(inputId);\n         break;\n     }\n \n \n         if (!allowDupe) {\n           compiler.report(\n-              JSError.make(sourceName, n,\n+              JSError.make(NodeUtil.getSourceName(n), n,\n                            VAR_MULTIPLY_DECLARED_ERROR,\n                            name,\n                            (origVar.input != null\n         // Disallow shadowing \"arguments\" as we can't handle with our current\n         // scope modeling.\n         compiler.report(\n-            JSError.make(sourceName, n,\n+            JSError.make(NodeUtil.getSourceName(n), n,\n                 VAR_ARGUMENTS_SHADOWED_ERROR));\n       }\n     }\n   private void declareVar(Node n) {\n     Preconditions.checkState(n.getType() == Token.NAME);\n \n-    CompilerInput input = compiler.getInput(sourceName);\n+    CompilerInput input = compiler.getInput(inputId);\n     String name = n.getString();\n     if (scope.isDeclared(name, false)\n         || (scope.isLocal() && name.equals(ARGUMENTS))) {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n      */\n     private String sourceName = null;\n \n+    /**\n+     * The InputId of the current node.\n+     */\n+    private InputId inputId;\n+\n     private AbstractScopeBuilder(Scope scope) {\n       this.scope = scope;\n     }\n     }\n \n     @Override\n-    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n+    public final boolean shouldTraverse(NodeTraversal t, Node n,\n         Node parent) {\n+      inputId = t.getInputId();\n       if (n.getType() == Token.FUNCTION ||\n           n.getType() == Token.SCRIPT) {\n+        Preconditions.checkNotNull(inputId);\n         sourceName = NodeUtil.getSourceName(n);\n       }\n \n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n+      inputId = t.getInputId();\n       attachLiteralTypes(t, n);\n \n       switch (n.getType()) {\n       JSType type = getDeclaredType(sourceName, info, name, value);\n       if (type == null) {\n         // The variable's type will be inferred.\n-        CompilerInput input = compiler.getInput(sourceName);\n-        Preconditions.checkNotNull(input, sourceName);\n-        type = input.isExtern() ?\n+        type = name.isFromExterns() ?\n             getNativeType(UNKNOWN_TYPE) : null;\n       }\n       defineSlot(name, var, type);\n         if (!inferred) {\n           setDeferredType(n, type);\n         }\n-        CompilerInput input = compiler.getInput(sourceName);\n-        boolean isExtern = input.isExtern();\n+\n+        CompilerInput input = compiler.getInput(inputId);\n+        // The input may be null if we are working with a AST snippet.\n+        boolean isExtern = n.isFromExterns();\n         Var newVar =\n             scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n \n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n \n         if (!isDeclaration && !isDeclaredInScope) {\n           // Don't check the order of refer in externs files.\n-          if (!reference.getSourceFile().isExtern()) {\n+          if (!reference.getNode().isFromExterns()) {\n             // Special case to deal with var goog = goog || {}\n             Node grandparent = reference.getGrandparent();\n             if (grandparent.getType() == Token.NAME\n--- a/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n+++ b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.Scope.Var;\n-import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.ObjectType;\n  */\n public class GlobalVarReferenceMapTest extends TestCase {\n \n-  private static final CompilerInput INPUT1 =\n+  private final CompilerInput INPUT1 =\n       new CompilerInput(JSSourceFile.fromCode(\"input1\", \"\"), false);\n-  private static final CompilerInput INPUT2 =\n+  private final CompilerInput INPUT2 =\n       new CompilerInput(JSSourceFile.fromCode(\"input2\", \"\"), false);\n-  private static final CompilerInput INPUT3 =\n+  private final CompilerInput INPUT3 =\n       new CompilerInput(JSSourceFile.fromCode(\"input3\", \"\"), false);\n-  private static final CompilerInput EXTERN1 =\n-    new CompilerInput(JSSourceFile.fromCode(\"externs1\", \"\"), true);\n+  private final CompilerInput EXTERN1 =\n+      new CompilerInput(JSSourceFile.fromCode(\"extern1\", \"\"), true);\n \n   private final GlobalVarReferenceMap map = new GlobalVarReferenceMap(\n       Lists.newArrayList(INPUT1, INPUT2, INPUT3), Lists.newArrayList(EXTERN1));\n   private final ReferenceCollection var1Refs = new ReferenceCollection();\n   private final ReferenceCollection var2Refs = new ReferenceCollection();\n   private final ReferenceCollection var3Refs = new ReferenceCollection();\n-  private final Reference var1In1Ref =  createRefForTest(INPUT1.getName());\n-  private final Reference var1In2Ref =  createRefForTest(INPUT2.getName());\n-  private final Reference var1In3Ref =  createRefForTest(INPUT3.getName());\n-  private final Reference var2In1Ref =  createRefForTest(INPUT1.getName());\n-  private final Reference var2In3Ref =  createRefForTest(INPUT3.getName());\n-  private final Reference var3In2Ref =  createRefForTest(INPUT2.getName());\n-  private final Reference var3In1Ext =  createRefForTest(EXTERN1.getName());\n+  private final Reference var1In1Ref = createRefForTest(INPUT1);\n+  private final Reference var1In2Ref = createRefForTest(INPUT2);\n+  private final Reference var1In3Ref = createRefForTest(INPUT3);\n+  private final Reference var2In1Ref = createRefForTest(INPUT1);\n+  private final Reference var2In3Ref = createRefForTest(INPUT3);\n+  private final Reference var3In2Ref = createRefForTest(INPUT2);\n+  private final Reference var3In1Ext = createRefForTest(EXTERN1);\n \n   @Override\n   protected void setUp() throws Exception {\n     globalMap.put(globalScope.getVar(VAR2), var2TempRefs);\n     globalMap.put(globalScope.getVar(VAR3), var3TempRefs);\n     map.updateGlobalVarReferences(globalMap, root);\n-    scriptRoot.setInputId(new InputId(INPUT2.getName()));\n+    scriptRoot.setInputId(INPUT2.getInputId());\n     scriptRoot.putProp(Node.SOURCENAME_PROP, INPUT2.getName());\n   }\n \n     Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap();\n \n     ReferenceCollection newVar1Refs = new ReferenceCollection();\n-    Reference newVar1In2Ref = createRefForTest(INPUT2.getName());\n+    Reference newVar1In2Ref = createRefForTest(INPUT2);\n     newVar1Refs.references = Lists.newArrayList(newVar1In2Ref);\n \n     ReferenceCollection newVar2Refs = new ReferenceCollection();\n-    Reference newVar2In2Ref = createRefForTest(INPUT2.getName());\n+    Reference newVar2In2Ref = createRefForTest(INPUT2);\n     newVar2Refs.references = Lists.newArrayList(newVar2In2Ref);\n \n     ReferenceCollection newVar3Refs = new ReferenceCollection();\n-    Reference newVar3In2Ref = createRefForTest(INPUT2.getName());\n+    Reference newVar3In2Ref = createRefForTest(INPUT2);\n     newVar3Refs.references = Lists.newArrayList(newVar3In2Ref);\n \n     scriptMap.put(globalScope.getVar(VAR1), newVar1Refs);\n     final String var4 = \"var4\";\n     globalScope.declare(var4, new Node(Token.NAME), null, INPUT2);\n     ReferenceCollection newVar3Refs = new ReferenceCollection();\n-    Reference newVar3In2Ref = createRefForTest(INPUT2.getName());\n+    Reference newVar3In2Ref = createRefForTest(INPUT2);\n     newVar3Refs.references = Lists.newArrayList(newVar3In2Ref);\n     scriptMap.put(globalScope.getVar(var4), newVar3Refs);\n     map.updateGlobalVarReferences(scriptMap, scriptRoot);\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n         compiler.getOptions());\n \n-    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n-    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n+    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n+    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n+        .getAstRoot(compiler);\n     Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n     externAndJsRoot.setIsSyntheticBlock(true);\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n         compiler.getOptions());\n \n-    Node n = compiler.getInput(\"[testcode]\").getAstRoot(compiler);\n-    Node externsNode = compiler.getInput(\"[externs]\").getAstRoot(compiler);\n+    Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n+    Node externsNode = compiler.getInput(new InputId(\"[externs]\"))\n+        .getAstRoot(compiler);\n     Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n);\n     externAndJsRoot.setIsSyntheticBlock(true);\n ", "timestamp": 1312483431, "metainfo": ""}