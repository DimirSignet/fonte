{"sha": "86caf52b53f53d8b83e9c1092f4b15ddeb6ca5bb", "log": "If a variable is doubly declared in externs and sources, we should keep around both VAR keywords. Fixes issue 290  R=johnlenz DELTA=93  (45 added, 19 deleted, 29 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=107   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n   private final Map<Node, Node> replacementMap =\n     new IdentityHashMap<Node, Node>();\n \n-  /** Map of all globals that we may aliasing */\n+  /** Map of all globals that we may alias */\n   private final Map<String, Symbol> globals = Maps.newHashMap();\n-\n-  /** Holds all of the globals that can be aliased to GLOBAL_ */\n-  private final List<Node> globalUses = Lists.newArrayList();\n \n   /** Reference to JS Compiler */\n   private final AbstractCompiler compiler;\n     }\n \n     // Change the references to the globals\n-    for (Node globalUse : globalUses) {\n-      replaceGlobalUse(globalUse);\n-    }\n-\n     for (Symbol global : globals.values()) {\n+      for (Node globalUse : global.uses) {\n+        replaceGlobalUse(globalUse);\n+      }\n       if (global.aliasAccessor) {\n         addGlobalAliasNode(global,\n                            getAddingRoot(global.deepestModuleAccess));\n \n         Symbol global = globals.get(name);\n         if (global != null) {\n+          // If a variable is declared in both externs and normal source,\n+          // don't alias it.\n+          if (n.getParent().getType() == Token.VAR ||\n+              n.getParent().getType() == Token.FUNCTION) {\n+            globals.remove(name);\n+          }\n+\n           boolean isFirst = parent.getFirstChild() == n;\n           // If a global is being assigned to or otherwise modified, then we\n           // don't want to alias it.\n             global.recordAccessor(t);\n           }\n \n-          globalUses.add(n);\n+          global.uses.add(n);\n         }\n       }\n     }\n     JSModule deepestModuleAccess = null;\n     JSModule deepestModuleMutate = null;\n \n+    List<Node> uses = Lists.newArrayList();\n+\n     private Symbol(String name, boolean isConstant) {\n       this.name = name;\n       this.isConstant = isConstant;\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.MakeDeclaredNamesUnique.BoilerplateRenamer;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Token;\n \n import java.util.Map;\n+import java.util.Set;\n \n /**\n  * The goal with this pass is to simplify the other passes,\n   private final class DuplicateDeclarationHandler implements\n       SyntacticScopeCreator.RedeclarationHandler {\n \n+    private Set<Var> hasOkDuplicateDeclaration = Sets.newHashSet();\n+\n     /**\n      * Remove duplicate VAR declarations encountered discovered during\n      * scope creation.\n      */\n     @Override\n     public void onRedeclaration(\n-        Scope s, String name, Node n, Node parent, Node gramps,\n-        Node nodeWithLineNumber) {\n+        Scope s, String name, Node n, CompilerInput input) {\n       Preconditions.checkState(n.getType() == Token.NAME);\n+      Node parent = n.getParent();\n       Var v = s.getVar(name);\n+\n+      if (v != null && s.isGlobal()) {\n+        // We allow variables to be duplicate declared if one\n+        // declaration appears in source and the other in externs.\n+        // This deals with issues where a browser built-in is declared\n+        // in one browser but not in another.\n+        if (v.isExtern() && !input.isExtern()) {\n+          if (hasOkDuplicateDeclaration.add(v)) {\n+            return;\n+          }\n+        }\n+      }\n+\n       // If name is \"arguments\", Var maybe null.\n       if (v != null && v.getParentNode().getType() == Token.CATCH) {\n         // Redeclaration of a catch expression variable is hard to model\n             name);\n         compiler.report(\n             JSError.make(\n-                NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n+                input.getName(), n,\n                 CATCH_BLOCK_VAR_ERROR, name));\n       } else if (v != null && parent.getType() == Token.FUNCTION) {\n         if (v.getParentNode().getType() == Token.VAR) {\n       } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n \n-        replaceVarWithAssignment(n, parent, gramps);\n+        replaceVarWithAssignment(n, parent, parent.getParent());\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.JSType;\n \n \n /**\n       // been declared in the outer scope.\n       String fnName = fnNameNode.getString();\n       if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n-        declareVar(fnName, fnNameNode, n, null, null, n);\n+        declareVar(fnNameNode);\n       }\n \n       // Args: Declare function variables\n       for (Node a = args.getFirstChild(); a != null;\n            a = a.getNext()) {\n         Preconditions.checkState(a.getType() == Token.NAME);\n-        declareVar(a.getString(), a, args, n, null, n);\n+        declareVar(a);\n       }\n \n       // Body\n         for (Node child = n.getFirstChild();\n              child != null;) {\n           Node next = child.getNext();\n-          Preconditions.checkState(child.getType() == Token.NAME);\n-\n-          String name = child.getString();\n-          declareVar(name, child, n, parent, null, n);\n+          declareVar(child);\n           child = next;\n         }\n         return;\n           // This is invalid, but allow it so the checks can catch it.\n           return;\n         }\n-        declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n+        declareVar(n.getFirstChild());\n         return;   // should not examine function's children\n \n       case Token.CATCH:\n         final Node var = n.getFirstChild();\n         final Node block = var.getNext();\n \n-        declareVar(var.getString(), var, n, parent, null, n);\n+        declareVar(var);\n         scanVars(block, n);\n         return;  // only one child to scan\n \n    */\n   interface RedeclarationHandler {\n     void onRedeclaration(\n-        Scope s, String name,\n-        Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n+        Scope s, String name, Node n, CompilerInput input);\n   }\n \n   /**\n    */\n   private class DefaultRedeclarationHandler implements RedeclarationHandler {\n     public void onRedeclaration(\n-        Scope s, String name,\n-        Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n+        Scope s, String name, Node n, CompilerInput input) {\n+      Node parent = n.getParent();\n+\n       // Don't allow multiple variables to be declared at the top level scope\n       if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n \n         if (!allowDupe) {\n           compiler.report(\n-              JSError.make(sourceName, nodeWithLineNumber,\n+              JSError.make(sourceName, n,\n                            VAR_MULTIPLY_DECLARED_ERROR,\n                            name,\n                            (origVar.input != null\n         // Disallow shadowing \"arguments\" as we can't handle with our current\n         // scope modeling.\n         compiler.report(\n-            JSError.make(sourceName, nodeWithLineNumber,\n+            JSError.make(sourceName, n,\n                 VAR_ARGUMENTS_SHADOWED_ERROR));\n       }\n     }\n   /**\n    * Declares a variable.\n    *\n-   * @param name The variable name\n-   * @param n The node corresponding to the variable name (usually a NAME node)\n-   * @param parent The parent node of {@code n}\n-   * @param gramps The parent node of {@code parent}\n+   * @param n The node corresponding to the variable name.\n    * @param declaredType The variable's type, according to JSDoc\n-   * @param nodeWithLineNumber The node to use to access the line number of\n-   *     the variable declaration, if needed\n-   */\n-  private void declareVar(String name, Node n, Node parent,\n-                          Node gramps, JSType declaredType,\n-                          Node nodeWithLineNumber) {\n+   */\n+  private void declareVar(Node n) {\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+\n+    CompilerInput input = compiler.getInput(sourceName);\n+    String name = n.getString();\n     if (scope.isDeclared(name, false)\n         || (scope.isLocal() && name.equals(ARGUMENTS))) {\n       redeclarationHandler.onRedeclaration(\n-          scope, name, n, parent, gramps, nodeWithLineNumber);\n+          scope, name, n, input);\n     } else {\n-      scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n+      scope.declare(name, n, null, input);\n     }\n   }\n }\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n \n   public void testDuplicateVarInExterns() {\n     test(\"var extern;\",\n-         \"/** @suppress {duplicate} */ var extern = 3;\", \"extern = 3;\",\n+         \"/** @suppress {duplicate} */ var extern = 3;\", \"var extern = 3;\",\n          null, null);\n   }\n \n     test(\"try { } catch(e) {e; try { } catch(e) {e;}};\",\n          \"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; \");\n \n-    // Verify global redefinition of extern definition is removed.\n-    test(\"/** @suppress {duplicate} */\\nvar window;\", \"\");\n+    // Verify the 1st global redefinition of extern definition is not removed.\n+    test(\"/** @suppress {duplicate} */\\nvar window;\", \"var window;\");\n+\n+    // Verify the 2nd global redefinition of extern definition is removed.\n+    test(\"/** @suppress {duplicate} */\\nvar window;\" +\n+         \"/** @suppress {duplicate} */\\nvar window;\", \"var window;\");\n \n     // Verify local masking extern made unique.\n     test(\"function f() {var window}\",", "timestamp": 1291928332, "metainfo": ""}