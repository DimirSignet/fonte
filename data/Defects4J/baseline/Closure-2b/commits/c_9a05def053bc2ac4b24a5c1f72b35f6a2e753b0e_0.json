{"sha": "9a05def053bc2ac4b24a5c1f72b35f6a2e753b0e", "log": "Throw the PureFunctionIdentifier harness out of the pass config, so that we can benchmark it more easily.  R=johnlenz DELTA=110  (66 added, 43 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=262301   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       new PassFactory(\"markPureFunctions\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new PureFunctionMarker(\n+      return new PureFunctionIdentifier.Driver(\n           compiler, options.debugFunctionSideEffectsPath, false);\n     }\n   };\n     return additionalReplacements;\n   }\n \n-  /** A compiler pass that marks pure functions. */\n-  private static class PureFunctionMarker implements CompilerPass {\n-    private final AbstractCompiler compiler;\n-    private final String reportPath;\n-    private final boolean useNameReferenceGraph;\n-\n-    PureFunctionMarker(AbstractCompiler compiler, String reportPath,\n-        boolean useNameReferenceGraph) {\n-      this.compiler = compiler;\n-      this.reportPath = reportPath;\n-      this.useNameReferenceGraph = useNameReferenceGraph;\n-    }\n-\n-    @Override\n-    public void process(Node externs, Node root) {\n-      DefinitionProvider definitionProvider = null;\n-      if (useNameReferenceGraph) {\n-        NameReferenceGraphConstruction graphBuilder =\n-            new NameReferenceGraphConstruction(compiler);\n-        graphBuilder.process(externs, root);\n-        definitionProvider = graphBuilder.getNameReferenceGraph();\n-      } else {\n-        SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n-        defFinder.process(externs, root);\n-        definitionProvider = defFinder;\n-      }\n-\n-      PureFunctionIdentifier pureFunctionIdentifier =\n-          new PureFunctionIdentifier(compiler, definitionProvider);\n-      pureFunctionIdentifier.process(externs, root);\n-\n-      if (reportPath != null) {\n-        try {\n-          Files.write(pureFunctionIdentifier.getDebugReport(),\n-              new File(reportPath),\n-              Charsets.UTF_8);\n-        } catch (IOException e) {\n-          throw new RuntimeException(e);\n-        }\n-      }\n-    }\n-  }\n-\n   private final PassFactory printNameReferenceGraph =\n     new PassFactory(\"printNameReferenceGraph\", true) {\n     @Override\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n package com.google.javascript.jscomp;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n+import com.google.common.io.Files;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n+import java.io.File;\n+import java.io.IOException;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n       return \"Side effects: \" + status.toString();\n     }\n   }\n+\n+  /**\n+   * A compiler pass that constructs a reference graph and drives\n+   * the PureFunctionIdentifier across it.\n+   */\n+  static class Driver implements CompilerPass {\n+    private final AbstractCompiler compiler;\n+    private final String reportPath;\n+    private final boolean useNameReferenceGraph;\n+\n+    Driver(AbstractCompiler compiler, String reportPath,\n+        boolean useNameReferenceGraph) {\n+      this.compiler = compiler;\n+      this.reportPath = reportPath;\n+      this.useNameReferenceGraph = useNameReferenceGraph;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      DefinitionProvider definitionProvider = null;\n+      if (useNameReferenceGraph) {\n+        NameReferenceGraphConstruction graphBuilder =\n+            new NameReferenceGraphConstruction(compiler);\n+        graphBuilder.process(externs, root);\n+        definitionProvider = graphBuilder.getNameReferenceGraph();\n+      } else {\n+        SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n+        defFinder.process(externs, root);\n+        definitionProvider = defFinder;\n+      }\n+\n+      PureFunctionIdentifier pureFunctionIdentifier =\n+          new PureFunctionIdentifier(compiler, definitionProvider);\n+      pureFunctionIdentifier.process(externs, root);\n+\n+      if (reportPath != null) {\n+        try {\n+          Files.write(pureFunctionIdentifier.getDebugReport(),\n+              new File(reportPath),\n+              Charsets.UTF_8);\n+        } catch (IOException e) {\n+          throw new RuntimeException(e);\n+        }\n+      }\n+    }\n+  }\n }", "timestamp": 1285351545, "metainfo": ""}