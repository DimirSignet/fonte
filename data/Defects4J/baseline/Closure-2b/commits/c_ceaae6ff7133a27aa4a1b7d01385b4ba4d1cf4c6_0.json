{"sha": "ceaae6ff7133a27aa4a1b7d01385b4ba4d1cf4c6", "log": "onwards to a unified symbol table api  R=acleung DELTA=106  (89 added, 5 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2501   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n               Predicates.<Var>equalTo(aliasVar));\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n-      ReferenceCollection aliasRefs =\n-          collector.getReferenceCollection(aliasVar);\n+      ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n       if (aliasRefs.isWellDefined()\n           && aliasRefs.firstReferenceIsAssigningDeclaration()\n           && aliasRefs.isAssignedOnceInLifetime()) {\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n+import com.google.javascript.rhino.jstype.StaticSymbolTable;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n  * the global scope. Also builds an index of all the references to those names.\n  *\n  */\n-class GlobalNamespace implements StaticScope<JSType> {\n+class GlobalNamespace\n+    implements StaticScope<JSType>,\n+    StaticSymbolTable<GlobalNamespace.Name, GlobalNamespace.Ref> {\n \n   private AbstractCompiler compiler;\n   private final Node root;\n     return compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n   }\n \n+  @Override\n+  public Iterable<Ref> getReferences(Name slot) {\n+    ensureGenerated();\n+    return Collections.unmodifiableList(slot.getRefs());\n+  }\n+\n+  @Override\n+  public Iterable<Name> getAllSymbols() {\n+    ensureGenerated();\n+    return Collections.unmodifiableCollection(getNameIndex().values());\n+  }\n+\n+  private void ensureGenerated() {\n+    if (!generated) {\n+      process();\n+    }\n+  }\n+\n   /**\n    * Gets a list of the roots of the forest of the global names, where the\n    * roots are the top-level names.\n    */\n   List<Name> getNameForest() {\n-    if (!generated) {\n-      process();\n-    }\n+    ensureGenerated();\n     return globalNames;\n   }\n \n    * (as in \"a\", \"a.b.c\", etc.).\n    */\n   Map<String, Name> getNameIndex() {\n-    if (!generated) {\n-      process();\n-    }\n+    ensureGenerated();\n     return nameMap;\n   }\n \n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n import com.google.javascript.rhino.jstype.SimpleSourceFile;\n import com.google.javascript.rhino.jstype.StaticReference;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n+import com.google.javascript.rhino.jstype.StaticSymbolTable;\n \n import java.util.ArrayDeque;\n import java.util.Deque;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n  * @author kushal@google.com (Kushal Dave)\n  */\n class ReferenceCollectingCallback implements ScopedCallback,\n-    HotSwapCompilerPass {\n+    HotSwapCompilerPass,\n+    StaticSymbolTable<Var, ReferenceCollectingCallback.Reference> {\n \n   /**\n    * Maps a given variable to a collection of references to that name. Note that\n   /**\n    * Gets the variables that were referenced in this callback.\n    */\n-  public Set<Var> getReferencedVariables() {\n+  @Override\n+  public Iterable<Var> getAllSymbols() {\n     return referenceMap.keySet();\n   }\n \n   /**\n    * Gets the reference collection for the given variable.\n    */\n-  public ReferenceCollection getReferenceCollection(Var v) {\n+  @Override\n+  public ReferenceCollection getReferences(Var v) {\n     return referenceMap.get(v);\n   }\n \n    * A collection of references. Can be subclassed to apply checks or\n    * store additional state when adding.\n    */\n-  static class ReferenceCollection {\n+  static class ReferenceCollection implements Iterable<Reference> {\n \n     List<Reference> references = Lists.newArrayList();\n+\n+    @Override\n+    public Iterator<Reference> iterator() {\n+      return references.iterator();\n+    }\n \n     void add(Reference reference, NodeTraversal t, Var v) {\n       references.add(reference);\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n \n       NodeTraversal.traverse(compiler, root, callback);\n \n-      for (Var variable : callback.getReferencedVariables()) {\n+      for (Var variable : callback.getAllSymbols()) {\n         ReferenceCollection referenceCollection =\n-            callback.getReferenceCollection(variable);\n+            callback.getReferences(variable);\n \n         for (Reference reference : referenceCollection.references) {\n           Node referenceNameNode = reference.getNode();\n--- a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n \n     NodeTraversal.traverse(compiler, root, callback);\n \n-    for (Var variable : callback.getReferencedVariables()) {\n+    for (Var variable : callback.getAllSymbols()) {\n       ReferenceCollection referenceCollection =\n-          callback.getReferenceCollection(variable);\n+          callback.getReferences(variable);\n \n       VariableVisibility visibility;\n \n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/StaticSymbolTable.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+/**\n+ * Lookup references by the symbols that they refer to.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public interface StaticSymbolTable\n+    <S extends StaticSlot<JSType>, R extends StaticReference> {\n+  /**\n+   * Returns the references that point to the given symbol.\n+   */\n+  Iterable<R> getReferences(S symbol);\n+\n+  /**\n+   * Returns all variables in this symbol table.\n+   */\n+  Iterable<S> getAllSymbols();\n+}", "timestamp": 1309557675, "metainfo": ""}