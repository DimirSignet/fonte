{"sha": "20c504ecbbdea3908bde81709df5a3765d1e385e", "log": "Patch up NodeUtil.getNumberValue to handle strings values like \" 12 \" and \"baz\".  R=nicksantos DELTA=123  (109 added, 2 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=260   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n         return n.getDouble();\n \n       case Token.VOID:\n-        return Double.NaN;\n+        if (mayHaveSideEffects(n.getFirstChild())) {\n+          return null;\n+        } else {\n+          return Double.NaN;\n+        }\n \n       case Token.NAME:\n+        // Check for known constants\n         String name = n.getString();\n         if (name.equals(\"undefined\")) {\n           return Double.NaN;\n         return null;\n \n       case Token.STRING:\n-        // TODO(johnlenz): handle less common string conversion cases:\n-        // '-infinity', etc.\n-        String s = n.getString();\n-\n+        String s = trimJsWhiteSpace(n.getString());\n+        // return ScriptRuntime.toNumber(s);\n         if (s.length() == 0) {\n           return 0.0;\n         }\n         if (s.length() > 2\n             && s.charAt(0) == '0'\n             && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n-            // Attempt to convert hex numbers.\n+          // Attempt to convert hex numbers.\n           try {\n             return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n           } catch (NumberFormatException e) {\n-            return null;\n+            return Double.NaN;\n           }\n+        }\n+\n+        if (s.length() > 3\n+            && (s.charAt(0) == '-' || s.charAt(0) == '+')\n+            && s.charAt(1) == '0'\n+            && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n+          // hex numbers with explicit signs vary between browsers.\n+          return null;\n+        }\n+\n+        // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n+        // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n+        if (s.equals(\"infinity\")\n+            || s.equals(\"-infinity\")\n+            || s.equals(\"+infinity\")) {\n+          return null;\n         }\n \n         try {\n           return Double.parseDouble(s);\n         } catch (NumberFormatException e) {\n-          return null;\n+          return Double.NaN;\n         }\n     }\n \n     return null;\n+  }\n+\n+  static String trimJsWhiteSpace(String s) {\n+    int start = 0;\n+    int end = s.length();\n+    while (end > 0 && isStrWhiteSpaceChar(s.charAt(end-1))) {\n+      end--;\n+    }\n+    while (start < end && isStrWhiteSpaceChar(s.charAt(start))) {\n+      start++;\n+    }\n+    return s.substring(start, end);\n+  }\n+\n+  /**\n+   * Copied from Rhino's ScriptRuntime\n+   */\n+  static boolean isStrWhiteSpaceChar(int c) {\n+    switch (c) {\n+      case ' ': // <SP>\n+      case '\\n': // <LF>\n+      case '\\r': // <CR>\n+      case '\\t': // <TAB>\n+      case '\\u00A0': // <NBSP>\n+      case '\\u000C': // <FF>\n+      case '\\u000B': // <VT>\n+      case '\\u2028': // <LS>\n+      case '\\u2029': // <PS>\n+      case '\\uFEFF': // <BOM>\n+        return true;\n+      default:\n+        return Character.getType(c) == Character.SPACE_SEPARATOR;\n+    }\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     return NodeUtil.isValidDefineValue(value, defines);\n   }\n \n-  public void testNumberValue() {\n+  public void testGetNumberValue() {\n+    // Strings\n+    assertEquals(1.0, NodeUtil.getNumberValue(getNode(\"'\\\\uFEFF1'\")));    \n     assertEquals(0.0, NodeUtil.getNumberValue(getNode(\"''\")));\n+    assertEquals(0.0, NodeUtil.getNumberValue(getNode(\"' '\")));\n+    assertEquals(0.0, NodeUtil.getNumberValue(getNode(\"' \\\\t'\")));\n+    assertEquals(0.0, NodeUtil.getNumberValue(getNode(\"'+0'\")));\n+    assertEquals(-0.0, NodeUtil.getNumberValue(getNode(\"'-0'\")));\n     assertEquals(2.0, NodeUtil.getNumberValue(getNode(\"'+2'\")));\n     assertEquals(-1.6, NodeUtil.getNumberValue(getNode(\"'-1.6'\")));\n     assertEquals(16.0, NodeUtil.getNumberValue(getNode(\"'16'\")));\n+    assertEquals(16.0, NodeUtil.getNumberValue(getNode(\"' 16 '\")));\n+    assertEquals(16.0, NodeUtil.getNumberValue(getNode(\"' 16 '\")));\n     assertEquals(12300.0, NodeUtil.getNumberValue(getNode(\"'123e2'\")));\n     assertEquals(12300.0, NodeUtil.getNumberValue(getNode(\"'123E2'\")));\n     assertEquals(1.23, NodeUtil.getNumberValue(getNode(\"'123e-2'\")));\n     assertEquals(1.23, NodeUtil.getNumberValue(getNode(\"'123E-2'\")));\n-\n-    assertEquals(16.0, NodeUtil.getNumberValue(getNode(\"'0x10'\")), 16.0);\n+    assertEquals(-1.23, NodeUtil.getNumberValue(getNode(\"'-123e-2'\")));\n+    assertEquals(-1.23, NodeUtil.getNumberValue(getNode(\"'-123E-2'\")));\n+    assertEquals(1.23, NodeUtil.getNumberValue(getNode(\"'+123e-2'\")));\n+    assertEquals(1.23, NodeUtil.getNumberValue(getNode(\"'+123E-2'\")));\n+    assertEquals(12300.0, NodeUtil.getNumberValue(getNode(\"'+123e+2'\")));\n+    assertEquals(12300.0, NodeUtil.getNumberValue(getNode(\"'+123E+2'\")));\n+\n+    assertEquals(15.0, NodeUtil.getNumberValue(getNode(\"'0xf'\")));\n+    assertEquals(15.0, NodeUtil.getNumberValue(getNode(\"'0xF'\")));\n+    \n+    // Chrome and rhino behavior differently from FF and IE. FF and IE\n+    // consider a negative hex number to be invalid\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"'-0xf'\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"'-0xF'\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"'+0xf'\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"'+0xF'\")));    \n+\n     assertEquals(16.0, NodeUtil.getNumberValue(getNode(\"'0X10'\")));\n+    assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode(\"'0X10.8'\")));\n     assertEquals(77.0, NodeUtil.getNumberValue(getNode(\"'077'\")));\n+    assertEquals(-77.0, NodeUtil.getNumberValue(getNode(\"'-077'\")));\n+    assertEquals(-77.5, NodeUtil.getNumberValue(getNode(\"'-077.5'\")));\n     assertEquals(\n         Double.NEGATIVE_INFINITY,\n         NodeUtil.getNumberValue(getNode(\"'-Infinity'\")));\n         Double.POSITIVE_INFINITY,\n         NodeUtil.getNumberValue(getNode(\"'Infinity'\")));\n     assertEquals(\n-        null,\n-        NodeUtil.getNumberValue(getNode(\"'-infinity'\")));\n+        Double.POSITIVE_INFINITY,\n+        NodeUtil.getNumberValue(getNode(\"'+Infinity'\")));\n+    // FireFox treats \"infinity\" as \"Infinity\", IE treats it as NaN\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"'-infinity'\")));\n     assertEquals(null, NodeUtil.getNumberValue(getNode(\"'infinity'\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"'+infinity'\")));    \n+\n     assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode(\"'NaN'\")));\n     assertEquals(\n-        null, NodeUtil.getNumberValue(getNode(\"'some unknown string'\")));\n+        Double.NaN, NodeUtil.getNumberValue(getNode(\"'some unknown string'\")));\n+    assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode(\"'123 blah'\")));\n+\n+    // Literals\n+    assertEquals(1.0, NodeUtil.getNumberValue(getNode(\"1\")));\n+    // \"-1\" is parsed as a literal\n+    assertEquals(-1.0, NodeUtil.getNumberValue(getNode(\"-1\")));\n+    // \"+1\" is parse as an op + literal\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"+1\")));\n+    assertEquals(22.0, NodeUtil.getNumberValue(getNode(\"22\")));\n+    assertEquals(18.0, NodeUtil.getNumberValue(getNode(\"022\")));\n+    assertEquals(34.0, NodeUtil.getNumberValue(getNode(\"0x22\")));\n \n     assertEquals(\n         1.0, NodeUtil.getNumberValue(getNode(\"true\")));\n     assertEquals(\n         Double.NaN, NodeUtil.getNumberValue(getNode(\"void 0\")));\n     assertEquals(\n+        Double.NaN, NodeUtil.getNumberValue(getNode(\"void f\")));\n+    // values with side-effects are ignored.\n+    assertEquals(\n+        null, NodeUtil.getNumberValue(getNode(\"void f()\")));\n+    assertEquals(\n         Double.NaN, NodeUtil.getNumberValue(getNode(\"NaN\")));\n     assertEquals(\n         Double.POSITIVE_INFINITY,\n     assertEquals(\n         Double.NEGATIVE_INFINITY,\n         NodeUtil.getNumberValue(getNode(\"-Infinity\")));\n+\n+    // \"infinity\" is not a known name.\n     assertEquals(null, NodeUtil.getNumberValue(getNode(\"infinity\")));\n     assertEquals(null, NodeUtil.getNumberValue(getNode(\"-infinity\")));\n+\n+    // getNumberValue only converts literals\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"x\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"x.y\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"1/2\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"1-2\")));\n+    assertEquals(null, NodeUtil.getNumberValue(getNode(\"+1\")));\n   }\n \n   public void testIsNumbericResult() {\n     assertFalse(NodeUtil.isNumericResult(getNode(\"a.b()\")));\n     assertFalse(NodeUtil.isNumericResult(getNode(\"a().b()\")));\n     assertFalse(NodeUtil.isNumericResult(getNode(\"new a()\")));\n-    \n+\n     // Definitely not numberic\n     assertFalse(NodeUtil.isNumericResult(getNode(\"([1,2])\")));\n-    assertFalse(NodeUtil.isNumericResult(getNode(\"({a:1})\")));    \n+    assertFalse(NodeUtil.isNumericResult(getNode(\"({a:1})\")));\n \n     // These are number but aren't handled yet, \"false\" here means \"unknown\".\n     assertFalse(NodeUtil.isNumericResult(getNode(\"1 && 2\")));\n     assertFalse(NodeUtil.isNumericResult(getNode(\"a,1\")));\n     assertFalse(NodeUtil.isNumericResult(getNode(\"a=1\")));\n   }\n-  \n+\n   public void testIsBooleanResult() {\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"1\")));\n     assertTrue(NodeUtil.isBooleanResult(getNode(\"true\")));\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"a.b()\")));\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"a().b()\")));\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"new a()\")));\n-    \n+\n     // Definitely not boolean\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"([true,false])\")));\n-    assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));    \n+    assertFalse(NodeUtil.isBooleanResult(getNode(\"({a:true})\")));\n \n     // These are boolean but aren't handled yet, \"false\" here means \"unknown\".\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"true && false\")));\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"a ? true : false\")));\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"a,true\")));\n     assertFalse(NodeUtil.isBooleanResult(getNode(\"a=1\")));\n-  }  \n+  }\n \n   public void testMayBeString() {\n     assertFalse(NodeUtil.mayBeString(getNode(\"1\")));", "timestamp": 1294873072, "metainfo": ""}