{"sha": "4ba374a86f76f4be48acb2491abc55952b0c1285", "log": "SANDBOX-176 - use and detect the EFS flag.  Based on submissions made by Wolfgang Glas to commons-compress and TAMURA Kent to Ant.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     public static final int STORED = java.util.zip.ZipEntry.STORED;\n \n     /**\n+     * name of the encoding UTF-8\n+     */\n+    static final String UTF8 = \"UTF8\";\n+\n+    /**\n      * default encoding for file names and comment.\n      */\n-    static final String DEFAULT_ENCODING = \"UTF8\";\n+    static final String DEFAULT_ENCODING = UTF8;\n+\n+     /**\n+     * General purpose flag, which indicates that filenames are\n+     * written in utf-8.\n+     */\n+    public static final int EFS_FLAG = 1 << 11;\n \n     /**\n      * Current entry.\n     private RandomAccessFile raf = null;\n \n     private final OutputStream out;\n+\n+    /**\n+     * whether to use the EFS flag when writing UTF-8 filenames or not.\n+     */\n+    private boolean useEFS = true; \n \n     /**\n      * Creates a new ZIP OutputStream filtering the underlying stream.\n      * for the platform's default encoding\n      * @since 1.3\n      */\n-    public void setEncoding(String encoding) {\n+    public void setEncoding(final String encoding) {\n         this.encoding = encoding;\n+        useEFS &= isUTF8(encoding);\n     }\n \n     /**\n      */\n     public String getEncoding() {\n         return encoding;\n+    }\n+\n+    /**\n+     * Whether to set the EFS flag if the file name encoding is UTF-8.\n+     *\n+     * <p>Defaults to true.</p>\n+     */\n+    public void setUseEFS(boolean b) {\n+        useEFS = b && isUTF8(encoding);\n     }\n \n     /**\n         //store method in local variable to prevent multiple method calls\n         final int zipMethod = ze.getMethod();\n \n-        // version needed to extract\n-        // general purpose bit flag\n-        // CheckStyle:MagicNumber OFF\n-        if (zipMethod == DEFLATED && raf == null) {\n-            // requires version 2 as we are going to store length info\n-            // in the data descriptor\n-            writeOut(ZipShort.getBytes(20));\n-\n-            // bit3 set to signal, we use a data descriptor\n-            writeOut(ZipShort.getBytes(8));\n-        } else {\n-            writeOut(ZipShort.getBytes(10));\n-            writeOut(ZERO);\n-        }\n-        // CheckStyle:MagicNumber ON\n+        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod);\n         written += WORD;\n \n         // compression method\n         writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n         written += SHORT;\n \n-        // version needed to extract\n-        // general purpose bit flag\n-        if (ze.getMethod() == DEFLATED && raf == null) {\n-            // requires version 2 as we are going to store length info\n-            // in the data descriptor\n-            writeOut(ZipShort.getBytes(20));\n-\n-            // bit3 set to signal, we use a data descriptor\n-            writeOut(ZipShort.getBytes(8));\n-        } else {\n-            writeOut(ZipShort.getBytes(10));\n-            writeOut(ZERO);\n-        }\n-        // CheckStyle:MagicNumber ON\n+        final int zipMethod = ze.getMethod();\n+        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod);\n         written += WORD;\n \n         // compression method\n-        writeOut(ZipShort.getBytes(ze.getMethod()));\n+        writeOut(ZipShort.getBytes(zipMethod));\n         written += SHORT;\n \n         // last mod. time and date\n      * this Stream.\n      * @param name the string to get bytes from\n      * @return the bytes as a byte array\n-     * @throws ZipException on error\n      *\n      * @since 1.3\n      */\n-    protected byte[] getBytes(String name) throws ZipException {\n+    protected byte[] getBytes(String name) {\n         if (encoding == null) {\n             return name.getBytes();\n         } else {\n-            try {\n-                return name.getBytes(encoding);\n-            } catch (UnsupportedEncodingException uee) {\n-                throw new ZipException(uee.getMessage());\n-            }\n+            return ZipEncodingHelper.encodeName(name, encoding);\n         }\n     }\n \n         }\n     }\n \n+    /**\n+     * Whether a given encoding - or the platform's default encoding\n+     * if the parameter is null - is UTF-8.\n+     */\n+    static boolean isUTF8(String encoding) {\n+        if (encoding == null) {\n+            // check platform's default encoding\n+            encoding = System.getProperty(\"file.encoding\");\n+        }\n+        return UTF8.equalsIgnoreCase(encoding)\n+            || \"utf-8\".equalsIgnoreCase(encoding);\n+    }\n+\n+    private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\n+                                                                  zipMethod)\n+        throws IOException {\n+\n+        // CheckStyle:MagicNumber OFF\n+        int versionNeededToExtract = 10;\n+        int generalPurposeFlag = useEFS ? EFS_FLAG : 0;\n+        if (zipMethod == DEFLATED && raf == null) {\n+            // requires version 2 as we are going to store length info\n+            // in the data descriptor\n+            versionNeededToExtract =  20;\n+            // bit3 set to signal, we use a data descriptor\n+            generalPurposeFlag |= 8;\n+        }\n+        // CheckStyle:MagicNumber ON\n+\n+        // version needed to extract\n+        writeOut(ZipShort.getBytes(versionNeededToExtract));\n+        // general purpose bit flag\n+        writeOut(ZipShort.getBytes(generalPurposeFlag));\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n      * @throws IOException if an error occurs while reading the file.\n      */\n     public ZipFile(File f) throws IOException {\n-        this(f, ZipArchiveOutputStream.DEFAULT_ENCODING);\n+        this(f, ZipArchiveOutputStream.UTF8);\n     }\n \n     /**\n      * @throws IOException if an error occurs while reading the file.\n      */\n     public ZipFile(String name) throws IOException {\n-        this(new File(name), ZipArchiveOutputStream.DEFAULT_ENCODING);\n+        this(new File(name), ZipArchiveOutputStream.UTF8);\n     }\n \n     /**\n             off += SHORT;\n             ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n \n-            off += WORD; // skip version info and general purpose byte\n+            off += SHORT; // skip version info\n+\n+            final int generalPurposeFlag = ZipShort.getValue(cfh, off);\n+            final String entryEncoding = \n+                (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0\n+                ? ZipArchiveOutputStream.UTF8\n+                : encoding;\n+\n+            off += SHORT;\n \n             ze.setMethod(ZipShort.getValue(cfh, off));\n             off += SHORT;\n \n             byte[] fileName = new byte[fileNameLen];\n             archive.readFully(fileName);\n-            ze.setName(getString(fileName));\n-\n+            ze.setName(getString(fileName, entryEncoding));\n \n             // LFH offset,\n             OffsetEntry offset = new OffsetEntry();\n \n             byte[] comment = new byte[commentLen];\n             archive.readFully(comment);\n-            ze.setComment(getString(comment));\n+            ze.setComment(getString(comment, entryEncoding));\n \n             archive.readFully(signatureBytes);\n             sig = ZipLong.getValue(signatureBytes);\n      * @return String obtained by using the given encoding\n      * @throws ZipException if the encoding cannot be recognized.\n      */\n-    protected String getString(byte[] bytes) throws ZipException {\n-        if (encoding == null) {\n+    protected String getString(byte[] bytes, String enc)\n+        throws ZipException {\n+        if (enc == null) {\n             return new String(bytes);\n         } else {\n             try {\n-                return new String(bytes, encoding);\n+                return new String(bytes, enc);\n             } catch (UnsupportedEncodingException uee) {\n                 throw new ZipException(uee.getMessage());\n             }", "timestamp": 1235061736, "metainfo": ""}