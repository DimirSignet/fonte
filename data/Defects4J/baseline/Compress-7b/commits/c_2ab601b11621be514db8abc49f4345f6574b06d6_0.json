{"sha": "2ab601b11621be514db8abc49f4345f6574b06d6", "log": "typo in class name  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Simple8BitZipEncoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This ZipEncoding implementation implements a simple 8bit character\n+ * set, which mets the following restrictions:\n+ * \n+ * <ul>\n+ * <li>Characters 0x0000 to 0x007f are encoded as the corresponding\n+ *        byte values 0x00 to 0x7f.</li>\n+ * <li>All byte codes from 0x80 to 0xff are mapped to a unique unicode\n+ *       character in the range 0x0080 to 0x7fff. (No support for\n+ *       UTF-16 surrogates)\n+ * </ul>\n+ * \n+ * <p>These restrictions most notably apply to the most prominent\n+ * omissions of java-1.4's {@link java.nio.charset.Charset Charset}\n+ * implementation, Cp437 and Cp850.</p>\n+ * \n+ * <p>The methods of this class are reentrant.</p>\n+ */\n+class Simple8BitZipEncoding implements ZipEncoding {\n+\n+    /**\n+     * A character entity, which is put to the reverse mapping table\n+     * of a simple encoding.\n+     */\n+    private static final class Simple8BitChar implements Comparable {\n+        public final char unicode;\n+        public final byte code;\n+\n+        Simple8BitChar(byte code, char unicode) {\n+            this.code = code;\n+            this.unicode = unicode;\n+        }\n+\n+        public int compareTo(Object o) {\n+            Simple8BitChar a = (Simple8BitChar) o;\n+\n+            return this.unicode - a.unicode;\n+        }\n+\n+        public String toString() {\n+            return \"0x\" + Integer.toHexString(0xffff & (int) unicode)\n+                + \"->0x\" + Integer.toHexString(0xff & (int) code);\n+        }\n+    }\n+\n+    /**\n+     * The characters for byte values of 128 to 255 stored as an array of\n+     * 128 chars.\n+     */\n+    private final char[] highChars;\n+\n+    /**\n+     * A list of {@see Simple8BitChar} objects sorted by the unicode\n+     * field.  This list is used to binary search reverse mapping of\n+     * unicode characters with a character code greater than 127.\n+     */\n+    private final List reverseMapping;\n+\n+    /**\n+     * @param highChars The characters for byte values of 128 to 255\n+     * stored as an array of 128 chars.\n+     */\n+    public Simple8BitZipEncoding(char[] highChars) {\n+        this.highChars = highChars;\n+        this.reverseMapping = new ArrayList(this.highChars.length);\n+\n+        byte code = 127;\n+\n+        for (int i = 0; i < this.highChars.length; ++i) {\n+            this.reverseMapping.add(new Simple8BitChar(++code,\n+                                                       this.highChars[i]));\n+        }\n+\n+        Collections.sort(this.reverseMapping);\n+    }\n+\n+    /**\n+     * Return the character code for a given encoded byte.\n+     * \n+     * @param b The byte to decode.\n+     * @return The associated character value.\n+     */\n+    public char decodeByte(byte b) {\n+        // code 0-127\n+        if (b >= 0) {\n+            return (char) b;\n+        }\n+\n+        // byte is signed, so 128 == -128 and 255 == -1\n+        return this.highChars[128 + (int) b];\n+    }\n+\n+    /**\n+     * @param c The character to encode.\n+     * @return Whether the given unicode character is covered by this encoding.\n+     */\n+    public boolean canEncodeChar(char c) {\n+\n+        if (c >= 0 && c < 128) {\n+            return true;\n+        }\n+\n+        Simple8BitChar r = this.encodeHighChar(c);\n+        return r != null;\n+    }\n+\n+    /**\n+     * Pushes the encoded form of the given character to the given byte buffer.\n+     * \n+     * @param bb The byte buffer to write to.\n+     * @param c The character to encode.\n+     * @return Whether the given unicode character is covered by this encoding.\n+     *         If <code>false</code> is returned, nothing is pushed to the\n+     *         byte buffer. \n+     */\n+    public boolean pushEncodedChar(ByteBuffer bb, char c) {\n+\n+        if (c >= 0 && c < 128) {\n+            bb.put((byte) c);\n+            return true;\n+        }\n+\n+        Simple8BitChar r = this.encodeHighChar(c);\n+        if (r == null) {\n+            return false;\n+        }\n+        bb.put(r.code);\n+        return true;\n+    }\n+\n+    /**\n+     * @param c A unicode character in the range from 0x0080 to 0x7f00\n+     * @return A Simple8BitChar, if this character is covered by this encoding.\n+     *         A <code>null</code> value is returned, if this character is not\n+     *         covered by this encoding.\n+     */\n+    private Simple8BitChar encodeHighChar(char c) {\n+        // for performance an simplicity, yet another reincarnation of\n+        // binary search...\n+        int i0 = 0;\n+        int i1 = this.reverseMapping.size();\n+\n+        while (i1 > i0) {\n+\n+            int i = i0 + (i1 - i0) / 2;\n+\n+            Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i);\n+\n+            if (m.unicode == c) {\n+                return m;\n+            }\n+\n+            if (m.unicode < c) {\n+                i0 = i + 1;\n+            } else {\n+                i1 = i;\n+            }\n+        }\n+\n+        if (i0 >= this.reverseMapping.size()) {\n+            return null;\n+        }\n+\n+        Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0);\n+\n+        if (r.unicode != c) {\n+            return null;\n+        }\n+\n+        return r;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n+     */\n+    public boolean canEncode(String name) {\n+\n+        for (int i=0;i<name.length();++i) {\n+\n+            char c = name.charAt(i);\n+\n+            if (!this.canEncodeChar(c)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n+     */\n+    public ByteBuffer encode(String name) {\n+        ByteBuffer out = ByteBuffer.allocate(name.length()\n+                                             + 6 + (name.length() + 1) / 2);\n+\n+        for (int i=0;i<name.length();++i) {\n+\n+            char c = name.charAt(i);\n+\n+            if (out.remaining() < 6) {\n+                out = ZipEncodingHelper.growBuffer(out,out.position() + 6);\n+            }\n+\n+            if (!this.pushEncodedChar(out,c)) {\n+\n+                ZipEncodingHelper.appendSurrogate(out,c);\n+            }\n+        }\n+\n+        out.limit(out.position());\n+        out.rewind();\n+        return out;\n+    }\n+\n+    /**\n+     * @see\n+     * org.apache.commons.compress.archivers.zip.ZipEncoding#decode(byte[])\n+     */\n+    public String decode(byte[] data) throws IOException {\n+        char [] ret = new char[data.length];\n+\n+        for (int i=0;i<data.length;++i) {\n+            ret[i] = this.decodeByte(data[i]);\n+        }\n+\n+        return new String(ret);\n+    }\n+\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n \n     /**\n      * A class, which holds the high characters of a simple encoding\n-     * and lazily instantiates a Simple8BitZipEnoding instance in a\n+     * and lazily instantiates a Simple8BitZipEncoding instance in a\n      * thread-safe manner.\n      */\n     private static class SimpleEncodingHolder {\n \n         private final char [] highChars;\n-        private Simple8BitZipEnoding encoding;\n+        private Simple8BitZipEncoding encoding;\n \n         /**\n          * Instantiate a simple encoding holder.\n          * \n          * @param highChars The characters for byte codes 128 to 255.\n          * \n-         * @see Simple8BitZipEnoding#Simple8BitZipEnoding(char[])\n+         * @see Simple8BitZipEncoding#Simple8BitZipEncoding(char[])\n          */\n         SimpleEncodingHolder(char [] highChars) {\n             this.highChars = highChars;\n          * @return The associated {@see Simple8BitZipEncoding}, which\n          *         is instantiated if not done so far.\n          */\n-        public synchronized Simple8BitZipEnoding getEncoding() {\n+        public synchronized Simple8BitZipEncoding getEncoding() {\n             if (this.encoding == null) {\n-                this.encoding = new Simple8BitZipEnoding(this.highChars);\n+                this.encoding = new Simple8BitZipEncoding(this.highChars);\n             }\n             return this.encoding;\n         }", "timestamp": 1236010890, "metainfo": ""}