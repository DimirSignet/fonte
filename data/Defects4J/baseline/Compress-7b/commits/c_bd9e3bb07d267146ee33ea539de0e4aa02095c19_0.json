{"sha": "bd9e3bb07d267146ee33ea539de0e4aa02095c19", "log": "whitespace only  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n \n public class ArArchiveInputStream extends ArchiveInputStream {\n \n-\tprivate final InputStream input;\n-\tprivate long offset = 0;\n-\t\n-\tpublic ArArchiveInputStream( final InputStream pInput ) {\n-\t\tinput = pInput;\n-\t}\n-\t\n-\tpublic ArchiveEntry getNextEntry() throws IOException {\n-\t\t\n-\t\tif (offset == 0) {\n-\t\t\tfinal byte[] expected = \"!<arch>\\n\".getBytes();\t\t\t\n-\t\t\tfinal byte[] realized = new byte[expected.length]; \n-\t\t\tfinal int read = read(realized);\n-\t\t\tif (read != expected.length) {\n-\t\t\t\tthrow new IOException(\"failed to read header\");\n-\t\t\t}\n-\t\t\tfor (int i = 0; i < expected.length; i++) {\n-\t\t\t\tif (expected[i] != realized[i]) {\n-\t\t\t\t\tthrow new IOException(\"invalid header \" + new String(realized));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+    private final InputStream input;\n+    private long offset = 0;\n+        \n+    public ArArchiveInputStream( final InputStream pInput ) {\n+        input = pInput;\n+    }\n+        \n+    public ArchiveEntry getNextEntry() throws IOException {\n+                \n+        if (offset == 0) {\n+            final byte[] expected = \"!<arch>\\n\".getBytes();                     \n+            final byte[] realized = new byte[expected.length]; \n+            final int read = read(realized);\n+            if (read != expected.length) {\n+                throw new IOException(\"failed to read header\");\n+            }\n+            for (int i = 0; i < expected.length; i++) {\n+                if (expected[i] != realized[i]) {\n+                    throw new IOException(\"invalid header \" + new String(realized));\n+                }\n+            }\n+        }\n \n-\t\tif (input.available() == 0) {\n-\t\t\treturn null;\n-\t\t}\n-\t\t\t\t\n-\t\tif (offset % 2 != 0) {\n-\t\t\tread();\n-\t\t}\n+        if (input.available() == 0) {\n+            return null;\n+        }\n+                                \n+        if (offset % 2 != 0) {\n+            read();\n+        }\n \n-\t\tfinal byte[] name = new byte[16];\n-\t\tfinal byte[] lastmodified = new byte[12];\n-\t\tfinal byte[] userid = new byte[6];\n-\t\tfinal byte[] groupid = new byte[6];\n-\t\tfinal byte[] filemode = new byte[8];\n-\t\tfinal byte[] length = new byte[10];\n-\t\t\n-\t\tread(name);\n-\t\tread(lastmodified);\n-\t\tread(userid);\n-\t\tread(groupid);\n-\t\tread(filemode);\n-\t\tread(length);\n+        final byte[] name = new byte[16];\n+        final byte[] lastmodified = new byte[12];\n+        final byte[] userid = new byte[6];\n+        final byte[] groupid = new byte[6];\n+        final byte[] filemode = new byte[8];\n+        final byte[] length = new byte[10];\n+                \n+        read(name);\n+        read(lastmodified);\n+        read(userid);\n+        read(groupid);\n+        read(filemode);\n+        read(length);\n \n-\t\t{\n-\t\t\tfinal byte[] expected = \"`\\012\".getBytes();\t\t\t\n-\t\t\tfinal byte[] realized = new byte[expected.length]; \n-\t\t\tfinal int read = read(realized);\n-\t\t\tif (read != expected.length) {\n-\t\t\t\tthrow new IOException(\"failed to read entry header\");\n-\t\t\t}\n-\t\t\tfor (int i = 0; i < expected.length; i++) {\n-\t\t\t\tif (expected[i] != realized[i]) {\n-\t\t\t\t\tthrow new IOException(\"invalid entry header. not read the content?\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\treturn new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim()));\n-\t\n-\t}\n-\t\n-\t\n-\tpublic int read() throws IOException {\n-\t\tfinal int ret = input.read();\n-\t\toffset++;\n-\t\treturn ret;\n-\t}\n-\t\n-\tpublic int read(byte b[]) throws IOException {\n-\t\tfinal int ret = read(b, 0, b.length);\n-\t\toffset = offset + b.length;\n-\t\treturn ret;\n-\t}\n+        {\n+            final byte[] expected = \"`\\012\".getBytes();                 \n+            final byte[] realized = new byte[expected.length]; \n+            final int read = read(realized);\n+            if (read != expected.length) {\n+                throw new IOException(\"failed to read entry header\");\n+            }\n+            for (int i = 0; i < expected.length; i++) {\n+                if (expected[i] != realized[i]) {\n+                    throw new IOException(\"invalid entry header. not read the content?\");\n+                }\n+            }\n+        }\n+                \n+        return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim()));\n+        \n+    }\n+        \n+        \n+    public int read() throws IOException {\n+        final int ret = input.read();\n+        offset++;\n+        return ret;\n+    }\n+        \n+    public int read(byte b[]) throws IOException {\n+        final int ret = read(b, 0, b.length);\n+        offset = offset + b.length;\n+        return ret;\n+    }\n \n-\tpublic int read(byte[] b, int off, int len) throws IOException {\n-\t\tfinal int ret = this.input.read(b, off, len);\n-\t\toffset = offset + off;\n-\t\treturn ret;\n-\t}\n-\t\n-\tpublic static boolean matches( byte[] signature ) {\n-\t\t// 3c21 7261 6863 0a3e\n-    \t\n-    \tif (signature[0] != 0x21) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[1] != 0x3c) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[2] != 0x61) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[3] != 0x72) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[4] != 0x63) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[5] != 0x68) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[6] != 0x3e) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[7] != 0x0a) {\n-    \t\treturn false;\n-    \t}\n-    \t\n-    \treturn true;\n-\t}\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        final int ret = this.input.read(b, off, len);\n+        offset = offset + off;\n+        return ret;\n+    }\n+        \n+    public static boolean matches( byte[] signature ) {\n+        // 3c21 7261 6863 0a3e\n+        \n+        if (signature[0] != 0x21) {\n+            return false;\n+        }\n+        if (signature[1] != 0x3c) {\n+            return false;\n+        }\n+        if (signature[2] != 0x61) {\n+            return false;\n+        }\n+        if (signature[3] != 0x72) {\n+            return false;\n+        }\n+        if (signature[4] != 0x63) {\n+            return false;\n+        }\n+        if (signature[5] != 0x68) {\n+            return false;\n+        }\n+        if (signature[6] != 0x3e) {\n+            return false;\n+        }\n+        if (signature[7] != 0x0a) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n  */\n \n public class CpioArchiveInputStream extends ArchiveInputStream implements CpioConstants {\n-\t\n+        \n     private boolean closed = false;\n \n     private CpioArchiveEntry entry;\n             byte tmp[] = new byte[6];\n             System.arraycopy(magic, 0, tmp, 0, magic.length);\n             System.arraycopy(more_magic, 0, tmp, magic.length,\n-                    more_magic.length);\n+                             more_magic.length);\n             String magicString = new String(tmp);\n             if (magicString.equals(MAGIC_NEW)) {\n                 this.entry = readNewEntry(false);\n      */\n     public int read() throws IOException {\n         return read(this.singleByteBuf, 0, 1) == -1 ? -1\n-                : this.singleByteBuf[0] & 0xff;\n+            : this.singleByteBuf[0] & 0xff;\n     }\n \n     /**\n      *                     occurred\n      */\n     public int read(final byte[] b, final int off, final int len)\n-            throws IOException {\n+        throws IOException {\n         ensureOpen();\n         if (off < 0 || len < 0 || off > b.length - len) {\n             throw new IndexOutOfBoundsException();\n             return -1;\n         }\n         int tmplength = (int) Math.min(len, this.entry.getSize()\n-                - this.entryBytesRead);\n+                                       - this.entryBytesRead);\n         if (tmplength < 0) {\n             return -1;\n         }\n     }\n \n     private final int readFully(final byte[] b, final int off, final int len)\n-            throws IOException {\n+        throws IOException {\n         if (len < 0) {\n             throw new IndexOutOfBoundsException();\n         }\n     }\n \n     private long readBinaryLong(final int length, final boolean swapHalfWord)\n-            throws IOException {\n+        throws IOException {\n         byte tmp[] = new byte[length];\n         readFully(tmp, 0, tmp.length);\n         return byteArray2long(tmp, swapHalfWord);\n     }\n \n     private long readAsciiLong(final int length, final int radix)\n-            throws IOException {\n+        throws IOException {\n         byte tmpBuffer[] = new byte[length];\n         readFully(tmpBuffer, 0, tmpBuffer.length);\n         return Long.parseLong(new String(tmpBuffer), radix);\n     }\n \n     private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)\n-            throws IOException {\n+        throws IOException {\n         CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n \n         ret.setDevice(readBinaryLong(2, swapHalfWord));\n         return total;\n     }\n \n-\tpublic ArchiveEntry getNextEntry() throws IOException {\n-\t\tCpioArchiveEntry entry = this.getNextCPIOEntry();\n-    \tif(entry == null) {\n-    \t\treturn null;\n-    \t}\n-\t\treturn (ArchiveEntry)entry;\n-\t}\n-\t\n-\tpublic static boolean matches( byte[] signature ) {\n-\t\t// 3037 3037 30\n-    \t\n-    \tif (signature[0] != 0x30) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[1] != 0x37) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[2] != 0x30) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[3] != 0x37) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[4] != 0x30) {\n-    \t\treturn false;\n-    \t}\n-    \t\n-    \treturn true;\n-\t}\n+    public ArchiveEntry getNextEntry() throws IOException {\n+        CpioArchiveEntry entry = this.getNextCPIOEntry();\n+        if(entry == null) {\n+            return null;\n+        }\n+        return (ArchiveEntry)entry;\n+    }\n+        \n+    public static boolean matches( byte[] signature ) {\n+        // 3037 3037 30\n+        \n+        if (signature[0] != 0x30) {\n+            return false;\n+        }\n+        if (signature[1] != 0x37) {\n+            return false;\n+        }\n+        if (signature[2] != 0x30) {\n+            return false;\n+        }\n+        if (signature[3] != 0x37) {\n+            return false;\n+        }\n+        if (signature[4] != 0x30) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveInputStream.java\n \n public class JarArchiveInputStream extends ZipArchiveInputStream {\n \n-\tpublic JarArchiveInputStream( final InputStream inputStream ) {\n-\t\tsuper(inputStream);\n-\t}\n-\t\n-\tpublic ArchiveEntry getNextEntry() throws IOException {\n-\t\tZipArchiveEntry entry = (ZipArchiveEntry)super.getNextEntry();\n-\t\tif(entry == null) {\n-\t\t\treturn null;\n-\t\t} else {\n-\t\t\treturn (ArchiveEntry)new JarArchiveEntry(entry);\n-\t\t}\n-\t}\n-\t\n-\tpublic static boolean matches( byte[] signature ) {\n-\t\t// 4b50 0403 0014 0008\n+    public JarArchiveInputStream( final InputStream inputStream ) {\n+        super(inputStream);\n+    }\n+        \n+    public ArchiveEntry getNextEntry() throws IOException {\n+        ZipArchiveEntry entry = (ZipArchiveEntry)super.getNextEntry();\n+        if(entry == null) {\n+            return null;\n+        } else {\n+            return (ArchiveEntry)new JarArchiveEntry(entry);\n+        }\n+    }\n+        \n+    public static boolean matches( byte[] signature ) {\n+        // 4b50 0403 0014 0008\n \n-    \tif (signature[0] != 0x50) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[1] != 0x4b) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[2] != 0x03) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[3] != 0x04) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[4] != 0x14) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[5] != 0x00) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[6] != 0x08) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[7] != 0x00) {\n-    \t\treturn false;\n-    \t}\n-    \t\n-    \treturn true;\n-\t}\n+        if (signature[0] != 0x50) {\n+            return false;\n+        }\n+        if (signature[1] != 0x4b) {\n+            return false;\n+        }\n+        if (signature[2] != 0x03) {\n+            return false;\n+        }\n+        if (signature[3] != 0x04) {\n+            return false;\n+        }\n+        if (signature[4] != 0x14) {\n+            return false;\n+        }\n+        if (signature[5] != 0x00) {\n+            return false;\n+        }\n+        if (signature[6] != 0x08) {\n+            return false;\n+        }\n+        if (signature[7] != 0x00) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n \n public class TarArchiveInputStream extends ArchiveInputStream {\n \n-\tprivate final TarInputStream in;\n+    private final TarInputStream in;\n     \n-\tpublic TarArchiveInputStream( InputStream inputStream ) {\n-\t\tin = new TarInputStream(inputStream);\n-\t}\n+    public TarArchiveInputStream( InputStream inputStream ) {\n+        in = new TarInputStream(inputStream);\n+    }\n \n     public ArchiveEntry getNextEntry() throws IOException {\n         return (ArchiveEntry)in.getNextEntry();\n     }\n     \n     public static boolean matches( byte[] signature ) {\n-    \t// 6574 7473 2e31 6d78\n-    \t\n-    \tif (signature[0] != 0x74) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[1] != 0x65) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[2] != 0x73) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[3] != 0x74) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[4] != 0x31) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[5] != 0x2e) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[6] != 0x78) {\n-    \t\treturn false;\n-    \t}\n-    \tif (signature[7] != 0x6d) {\n-    \t\treturn false;\n-    \t}\n-    \t\n-    \treturn true;\n+        // 6574 7473 2e31 6d78\n+        \n+        if (signature[0] != 0x74) {\n+            return false;\n+        }\n+        if (signature[1] != 0x65) {\n+            return false;\n+        }\n+        if (signature[2] != 0x73) {\n+            return false;\n+        }\n+        if (signature[3] != 0x74) {\n+            return false;\n+        }\n+        if (signature[4] != 0x31) {\n+            return false;\n+        }\n+        if (signature[5] != 0x2e) {\n+            return false;\n+        }\n+        if (signature[6] != 0x78) {\n+            return false;\n+        }\n+        if (signature[7] != 0x6d) {\n+            return false;\n+        }\n+        \n+        return true;\n     }\n     \n }", "timestamp": 1233910485, "metainfo": ""}