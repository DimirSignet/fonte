{"sha": "d92df029458e1edcdb93aee4b002622e75f0c35f", "log": "Replace specific methods with generic ones Remove code that is provided by the parent class  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n      * the default header format will be used if no other format is specified in\n      * the entry.\n      * \n-     * @param e\n+     * @param entry\n      *            the CPIO cpioEntry to be written\n      * @throws IOException\n      *             if an I/O error has occurred or if a CPIO file error has\n      *             occurred\n-     */\n-    public void putNextEntry(final CpioArchiveEntry e) throws IOException {\n+     * @throws ClassCastException if entry is not an instance of CpioArchiveEntry\n+     */\n+    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n+        CpioArchiveEntry e = (CpioArchiveEntry) entry;\n         ensureOpen();\n         if (this.entry != null) {\n             closeArchiveEntry(); // close previous entry\n         out.write('\\0');\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see\n-     * org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry\n-     * (org.apache.commons.compress.archivers.ArchiveEntry)\n-     */\n-    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n-        this.putNextEntry((CpioArchiveEntry) entry);\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see java.io.OutputStream#write(int)\n-     */\n-    public void write(int b) throws IOException {\n-        out.write(b);\n-    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n import java.io.IOException;\n import java.io.OutputStream;\n \n+import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.zip.JarMarker;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n         super(out);\n     }\n \n-    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n+    // @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n+    public void putArchiveEntry(ArchiveEntry ze) throws IOException {\n         if (!jarMarkerAdded) {\n-            ze.addAsFirstExtraField(JarMarker.getInstance());\n+            ((ZipArchiveEntry)ze).addAsFirstExtraField(JarMarker.getInstance());\n             jarMarkerAdded = true;\n         }\n-        super.putNextEntry(ze);\n+        super.putArchiveEntry(ze);\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n     private long      currSize;\n     private String    currName;\n     private long      currBytes;\n-    private final byte[]    oneBuf;\n     private final byte[]    recordBuf;\n     private int       assemLen;\n     private final byte[]    assemBuf;\n         this.assemLen = 0;\n         this.assemBuf = new byte[recordSize];\n         this.recordBuf = new byte[recordSize];\n-        this.oneBuf = new byte[1];\n     }\n \n     /**\n      * header record and positions the output stream for writing\n      * the contents of the entry. Once this method is called, the\n      * stream is ready for calls to write() to write the entry's\n-     * contents. Once the contents are written, closeEntry()\n+     * contents. Once the contents are written, closeArchiveEntry()\n      * <B>MUST</B> be called to ensure that all buffered data\n      * is completely written to the output stream.\n      *\n-     * @param entry The TarEntry to be written to the archive.\n-     * @throws IOException on error\n-     */\n-    public void putNextEntry(TarArchiveEntry entry) throws IOException {\n+     * @param archiveEntry The TarEntry to be written to the archive.\n+     * @throws IOException on error\n+     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n+     */\n+    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n+        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n         if (entry.getName().length() >= TarConstants.NAMELEN) {\n \n             if (longFileMode == LONGFILE_GNU) {\n                                                                     TarConstants.LF_GNUTYPE_LONGNAME);\n \n                 longLinkEntry.setSize(entry.getName().length() + 1);\n-                putNextEntry(longLinkEntry);\n+                putArchiveEntry(longLinkEntry);\n                 write(entry.getName().getBytes());\n                 write(0);\n-                closeEntry();\n+                closeArchiveEntry();\n             } else if (longFileMode != LONGFILE_TRUNCATE) {\n                 throw new RuntimeException(\"file name '\" + entry.getName()\n                                            + \"' is too long ( > \"\n      * next entry written.\n      * @throws IOException on error\n      */\n-    public void closeEntry() throws IOException {\n+    public void closeArchiveEntry() throws IOException {\n         if (assemLen > 0) {\n             for (int i = assemLen; i < assemBuf.length; ++i) {\n                 assemBuf[i] = 0;\n                                   + \"' before the '\" + currSize\n                                   + \"' bytes specified in the header were written\");\n         }\n-    }\n-\n-    /**\n-     * Writes a byte to the current tar archive entry.\n-     *\n-     * This method simply calls read( byte[], int, int ).\n-     *\n-     * @param b The byte written.\n-     * @throws IOException on error\n-     */\n-    public void write(int b) throws IOException {\n-        oneBuf[0] = (byte) b;\n-\n-        write(oneBuf, 0, 1);\n-    }\n-\n-    /**\n-     * Writes bytes to the current tar archive entry.\n-     *\n-     * This method simply calls write( byte[], int, int ).\n-     *\n-     * @param wBuf The buffer to write to the archive.\n-     * @throws IOException on error\n-     */\n-    public void write(byte[] wBuf) throws IOException {\n-        write(wBuf, 0, wBuf.length);\n     }\n \n     /**\n \n     // ArchiveOutputStream\n \n-    public void closeArchiveEntry() throws IOException {\n-        closeEntry();\n-    }\n-\n-    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n-        putNextEntry((TarArchiveEntry) entry);\n-    }\n-\n     public String getDefaultFileExtension() {\n         return \"tar\";\n     }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n  * calculate them yourself.  Unfortunately this is not possible for\n  * the {@link #STORED STORED} method, here setting the CRC and\n  * uncompressed size information is required before {@link\n- * #putNextEntry putNextEntry} can be called.</p>\n+ * #putArchiveEntry(ArchiveEntry)} can be called.</p>\n  * @NotThreadSafe\n  */\n public class ZipArchiveOutputStream extends ArchiveOutputStream {\n      *\n      * <p>For seekable streams, you don't need to calculate the CRC or\n      * uncompressed size for {@link #STORED} entries before\n-     * invoking {@link #putNextEntry}.\n+     * invoking {@link #putArchiveEntry(ArchiveEntry)}.\n      * @return true if seekable\n      */\n     public boolean isSeekable() {\n      * @throws IOException on error\n      */\n     public void finish() throws IOException {\n-        closeEntry();\n+        closeArchiveEntry();\n         cdOffset = written;\n         for (Iterator i = entries.iterator(); i.hasNext(); ) {\n             writeCentralFileHeader((ZipArchiveEntry) i.next());\n      * Writes all necessary data for this entry.\n      * @throws IOException on error\n      */\n-    public void closeEntry() throws IOException {\n+    public void closeArchiveEntry() throws IOException {\n         if (entry == null) {\n             return;\n         }\n         entry = null;\n     }\n \n-    /**\n-     * Begin writing next entry.\n-     * @param ze the entry to write\n-     * @throws IOException on error\n-     */\n-    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n-        closeEntry();\n-\n-        entry = ze;\n+    /** {@inheritDoc} */\n+ // @throws ClassCastException if entry is not an instance of ZipArchiveEntry\n+    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n+        closeArchiveEntry();\n+\n+        entry = ((ZipArchiveEntry) archiveEntry);\n         entries.add(entry);\n \n         if (entry.getMethod() == -1) { // not specified\n     }\n \n     /**\n-     * Writes a single byte to ZIP entry.\n-     *\n-     * <p>Delegates to the three arg method.</p>\n-     * @param b the byte to write\n-     * @throws IOException on error\n-     */\n-    public void write(int b) throws IOException {\n-        byte[] buff = new byte[1];\n-        buff[0] = (byte) (b & BYTE_MASK);\n-        write(buff, 0, 1);\n-    }\n-\n-    /**\n      * Closes this output stream and releases any system resources\n      * associated with the stream.\n      *\n         if (out != null) {\n             out.flush();\n         }\n-    }\n-\n-    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n-        putNextEntry((ZipArchiveEntry) entry);\n-    }\n-\n-    public void closeArchiveEntry() {\n-        // do nothing\n-    }\n-\n-    // used to be implemented via FilterOutputStream\n-    /**\n-     * Invokes the {@link #write(byte[],int,int)} three-arg version.\n-     */\n-    public void write(byte[] b) throws IOException {\n-        write(b, 0, b.length);\n     }\n \n     /*", "timestamp": 1238434347, "metainfo": ""}