{"sha": "1cef96536a04d2ea96aa251f9a7330bc64ce1a58", "log": "optionally use UnicodeExtraFields to set names and comments of entries when reading.  SANDBOX-176  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java\n      *                 <code>\"UTF-8\"</code> is supported in ZIP file\n      *                 version <code>6.3</code> or later.\n      */\n-    static final String decodeName(byte[] name, String encoding) {\n+    static final String decodeName(byte[] name, String encoding)\n+        throws java.nio.charset.CharacterCodingException {\n         Charset cs = Charset.forName(encoding);\n-        return cs.decode(ByteBuffer.wrap(name)).toString();\n+        return cs.newDecoder()\n+            .onMalformedInput(CodingErrorAction.REPORT)\n+            .onUnmappableCharacter(CodingErrorAction.REPORT)\n+            .decode(ByteBuffer.wrap(name)).toString();\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n import java.io.InputStream;\n import java.io.RandomAccessFile;\n import java.io.UnsupportedEncodingException;\n+import java.nio.charset.CharacterCodingException;\n import java.util.Calendar;\n import java.util.Collections;\n import java.util.Date;\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.zip.CRC32;\n import java.util.zip.Inflater;\n import java.util.zip.InflaterInputStream;\n import java.util.zip.ZipException;\n     private RandomAccessFile archive;\n \n     /**\n+     * Whether to look for and use Unicode extra fields.\n+     */\n+    private final boolean useUnicodeExtraFields;\n+\n+    /**\n      * Opens the given file for reading, assuming \"UTF8\" for file names.\n      *\n      * @param f the archive.\n \n     /**\n      * Opens the given file for reading, assuming the specified\n-     * encoding for file names.\n+     * encoding for file names and ignoring unicode extra fields.\n      *\n      * @param name name of the archive.\n      * @param encoding the encoding to use for file names, use null\n      * @throws IOException if an error occurs while reading the file.\n      */\n     public ZipFile(String name, String encoding) throws IOException {\n-        this(new File(name), encoding);\n+        this(new File(name), encoding, false);\n     }\n \n     /**\n      * Opens the given file for reading, assuming the specified\n-     * encoding for file names.\n+     * encoding for file names and ignoring unicode extra fields.\n      *\n      * @param f the archive.\n      * @param encoding the encoding to use for file names, use null\n      * @throws IOException if an error occurs while reading the file.\n      */\n     public ZipFile(File f, String encoding) throws IOException {\n+        this(f, encoding, false);\n+    }\n+\n+    /**\n+     * Opens the given file for reading, assuming the specified\n+     * encoding for file names.\n+     *\n+     * @param f the archive.\n+     * @param encoding the encoding to use for file names, use null\n+     * for the platform's default encoding\n+     * @param whether to use InfoZIP Unicode Extra Fields (if present)\n+     * to set the file names.\n+     *\n+     * @throws IOException if an error occurs while reading the file.\n+     */\n+    public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\n+        throws IOException {\n         this.encoding = encoding;\n+        this.useUnicodeExtraFields = useUnicodeExtraFields;\n         archive = new RandomAccessFile(f, \"r\");\n         boolean success = false;\n         try {\n-            populateFromCentralDirectory();\n-            resolveLocalFileHeaderData();\n+            Map entriesWithoutEFS = populateFromCentralDirectory();\n+            resolveLocalFileHeaderData(entriesWithoutEFS);\n             success = true;\n         } finally {\n             if (!success) {\n      * <p>The ZipArchiveEntrys will know all data that can be obtained from\n      * the central directory alone, but not the data that requires the\n      * local file header or additional data to be read.</p>\n-     */\n-    private void populateFromCentralDirectory()\n+     *\n+     * @return a Map&lt;ZipArchiveEntry, NameAndComment>&gt; of\n+     * zipentries that didn't have the language encoding flag set when\n+     * read.\n+     */\n+    private Map populateFromCentralDirectory()\n         throws IOException {\n+        HashMap noEFS = new HashMap();\n+\n         positionAtCentralDirectory();\n \n         byte[] cfh = new byte[CFH_LEN];\n             off += SHORT; // skip version info\n \n             final int generalPurposeFlag = ZipShort.getValue(cfh, off);\n-            final String entryEncoding = \n-                (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0\n-                ? ZipArchiveOutputStream.UTF8\n-                : encoding;\n+            final boolean hasEFS = \n+                (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\n+            final String entryEncoding =\n+                hasEFS ? ZipArchiveOutputStream.UTF8 : encoding;\n \n             off += SHORT;\n \n \n             archive.readFully(signatureBytes);\n             sig = ZipLong.getValue(signatureBytes);\n-        }\n+\n+            if (!hasEFS && useUnicodeExtraFields) {\n+                noEFS.put(ze, new NameAndComment(fileName, comment));\n+            }\n+        }\n+        return noEFS;\n     }\n \n     private static final int MIN_EOCD_SIZE =\n      * <p>Also records the offsets for the data to read from the\n      * entries.</p>\n      */\n-    private void resolveLocalFileHeaderData()\n+    private void resolveLocalFileHeaderData(Map entriesWithoutEFS)\n         throws IOException {\n         Enumeration e = getEntries();\n         while (e.hasMoreElements()) {\n             */\n             offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                                      + SHORT + SHORT + fileNameLen + extraFieldLen;\n+\n+            if (entriesWithoutEFS.containsKey(ze)) {\n+                setNameAndCommentFromExtraFields(ze,\n+                                                 (NameAndComment)\n+                                                 entriesWithoutEFS.get(ze));\n+            }\n         }\n     }\n \n             return new String(bytes);\n         } else {\n             try {\n-                return ZipEncodingHelper.decodeName(bytes, enc);\n+                try {\n+                    return ZipEncodingHelper.decodeName(bytes, enc);\n+                } catch (CharacterCodingException ex) {\n+                    throw new ZipException(ex.getMessage());\n+                }\n             } catch (java.nio.charset.UnsupportedCharsetException ex) {\n                 // Java 1.4's NIO doesn't recognize a few names that\n                 // String.getBytes does\n     }\n \n     /**\n+     * If the entry has Unicode*ExtraFields and the CRCs of the\n+     * names/comments match those of the extra fields, transfer the\n+     * known Unicode values from the extra field.\n+     */\n+    private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\n+                                                  NameAndComment nc) {\n+        UnicodePathExtraField name = (UnicodePathExtraField)\n+            ze.getExtraField(UnicodePathExtraField.UPATH_ID);\n+        String originalName = ze.getName();\n+        String newName = getUnicodeStringIfOriginalMatches(name, nc.name);\n+        if (newName != null && !originalName.equals(newName)) {\n+            ze.setName(newName);\n+            nameMap.remove(originalName);\n+            nameMap.put(newName, ze);\n+        }\n+\n+        if (nc.comment != null && nc.comment.length > 0) {\n+            UnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\n+                ze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\n+            String newComment =\n+                getUnicodeStringIfOriginalMatches(cmt, nc.comment);\n+            if (newComment != null) {\n+                ze.setComment(newComment);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * If the stored CRC matches the one of the given name, return the\n+     * Unicode name of the given field.\n+     *\n+     * <p>If the field is null or the CRCs don't match, return null\n+     * instead.</p>\n+     */\n+    private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\n+                                                     byte[] orig) {\n+        if (f != null) {\n+            CRC32 crc32 = new CRC32();\n+            crc32.update(orig);\n+            long origCRC32 = crc32.getValue();\n+\n+            if (origCRC32 == f.getNameCRC32()) {\n+                try {\n+                    return ZipEncodingHelper\n+                        .decodeName(f.getUnicodeName(),\n+                                    ZipArchiveOutputStream.UTF8);\n+                } catch (CharacterCodingException ex) {\n+                    // UTF-8 unsupported?  should be impossible the\n+                    // Unicode*ExtraField must contain some bad bytes\n+\n+                    // TODO log this anywhere?\n+                    return null;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n      * InputStream that delegates requests to the underlying\n      * RandomAccessFile, making sure that only bytes from a certain\n      * range can be read.\n         }\n     }\n \n+    private static final class NameAndComment {\n+        private final byte[] name;\n+        private final byte[] comment;\n+        private NameAndComment(byte[] name, byte[] comment) {\n+            this.name = name;\n+            this.comment = comment;\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java\n         }\n     }\n \n+    public void testZipFileReadsUnicodeFields() throws IOException {\n+        File file = File.createTempFile(\"unicode-test\", \".zip\");\n+        ZipFile zf = null;\n+        try {\n+            createTestFile(file, US_ASCII, false, true);\n+            zf = new ZipFile(file, US_ASCII, true);\n+            assertNotNull(zf.getEntry(ASCII_TXT));\n+            assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n+            assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n+        } finally {\n+            ZipFile.closeQuietly(zf);\n+            if (file.exists()) {\n+                file.delete();\n+            }\n+        }\n+    }\n+\n     private static void testFileRoundtrip(String encoding, boolean withEFS,\n                                           boolean withExplicitUnicodeExtra)\n         throws IOException {", "timestamp": 1235654114, "metainfo": ""}