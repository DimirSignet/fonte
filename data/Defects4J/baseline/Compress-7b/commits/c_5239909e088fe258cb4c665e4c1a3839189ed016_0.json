{"sha": "5239909e088fe258cb4c665e4c1a3839189ed016", "log": "Add option to use UTF-8 for non-encodable file names.  SANDBOX-176  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     private boolean useEFS = true; \n \n     /**\n+     * Whether to encode non-encodable file names as UTF-8.\n+     */\n+    private boolean fallbackToUTF8 = false;\n+\n+    /**\n      * whether to create UnicodePathExtraField-s for each entry.\n      */\n     private UnicodeExtraFieldPolicy createUnicodeExtraFields =\n      */\n     public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {\n         createUnicodeExtraFields = b;\n+    }\n+\n+    /**\n+     * Whether to fall back to UTF and the language encoding flag if\n+     * the file name cannot be encoded using the specified encoding.\n+     *\n+     * <p>Defaults to false.</p>\n+     */\n+    public void setFallbackToUTF8(boolean b) {\n+        fallbackToUTF8 = b;\n     }\n \n     /**\n      */\n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n \n-        boolean encodable = this.zipEncoding.canEncode(ze.getName());\n-        ByteBuffer name = this.zipEncoding.encode(ze.getName());\n+        boolean encodable = zipEncoding.canEncode(ze.getName());\n+        ByteBuffer name;\n+        if (!encodable && fallbackToUTF8) {\n+            name = ZipEncodingHelper.UTF8_ZIP_ENCODING.encode(ze.getName());\n+        } else {\n+            name = zipEncoding.encode(ze.getName());\n+        }\n \n         if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n \n         //store method in local variable to prevent multiple method calls\n         final int zipMethod = ze.getMethod();\n \n-        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod);\n+        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n+                                                         !encodable\n+                                                         && fallbackToUTF8);\n         written += WORD;\n \n         // compression method\n         written += SHORT;\n \n         final int zipMethod = ze.getMethod();\n-        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod);\n+        final boolean encodable = zipEncoding.canEncode(ze.getName());\n+        writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod,\n+                                                         !encodable\n+                                                         && fallbackToUTF8);\n         written += WORD;\n \n         // compression method\n         // CheckStyle:MagicNumber ON\n \n         // file name length\n-        ByteBuffer name = this.zipEncoding.encode(ze.getName());\n+        ByteBuffer name;\n+        if (!encodable && fallbackToUTF8) {\n+            name = ZipEncodingHelper.UTF8_ZIP_ENCODING.encode(ze.getName());\n+        } else {\n+            name = zipEncoding.encode(ze.getName());\n+        }\n         writeOut(ZipShort.getBytes(name.limit()));\n         written += SHORT;\n \n         if (comm == null) {\n             comm = \"\";\n         }\n-        ByteBuffer commentB = this.zipEncoding.encode(comm);\n+        ByteBuffer commentB;\n+        if (!encodable && fallbackToUTF8) {\n+            commentB = ZipEncodingHelper.UTF8_ZIP_ENCODING.encode(comm);\n+        } else {\n+            commentB = zipEncoding.encode(comm);\n+        }\n         writeOut(ZipShort.getBytes(commentB.limit()));\n         written += SHORT;\n \n     }\n \n     private void writeVersionNeededToExtractAndGeneralPurposeBits(final int\n-                                                                  zipMethod)\n+                                                                  zipMethod,\n+                                                                  final boolean\n+                                                                  utfFallback)\n         throws IOException {\n \n         // CheckStyle:MagicNumber OFF\n         int versionNeededToExtract = 10;\n-        int generalPurposeFlag = useEFS ? EFS_FLAG : 0;\n+        int generalPurposeFlag = (useEFS || utfFallback) ? EFS_FLAG : 0;\n         if (zipMethod == DEFLATED && raf == null) {\n             // requires version 2 as we are going to store length info\n             // in the data descriptor", "timestamp": 1236144079, "metainfo": ""}