{"sha": "bebc6eddeddb8bd40c1299fa6e468b56edd997fc", "log": "allow different strategies when parsing extra fields.  COMPRESS-73  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java\n \n     /**\n      * Split the array into ExtraFields and populate them with the\n-     * given data as local file data.\n+     * given data as local file data, throwing an exception if the\n+     * data cannot be parsed.\n      * @param data an array of bytes as it appears in local file data\n      * @return an array of ExtraFields\n      * @throws ZipException on error\n      */\n     public static ZipExtraField[] parse(byte[] data) throws ZipException {\n-        return parse(data, true);\n+        return parse(data, true, UnparseableExtraField.THROW);\n+    }\n+\n+    /**\n+     * Split the array into ExtraFields and populate them with the\n+     * given data, throwing an exception if the data cannot be parsed.\n+     * @param data an array of bytes\n+     * @param local whether data originates from the local file data\n+     * or the central directory\n+     * @return an array of ExtraFields\n+     * @throws ZipException on error\n+     */\n+    public static ZipExtraField[] parse(byte[] data, boolean local)\n+        throws ZipException {\n+        return parse(data, local, UnparseableExtraField.THROW);\n     }\n \n     /**\n      * @param data an array of bytes\n      * @param local whether data originates from the local file data\n      * or the central directory\n+     * @param onUnparseableData what to do if the extra field data\n+     * cannot be parsed.\n      * @return an array of ExtraFields\n      * @throws ZipException on error\n      */\n-    public static ZipExtraField[] parse(byte[] data, boolean local)\n+    public static ZipExtraField[] parse(byte[] data, boolean local,\n+                                        UnparseableExtraField onUnparseableData)\n         throws ZipException {\n         List v = new ArrayList();\n         int start = 0;\n+        LOOP:\n         while (start <= data.length - WORD) {\n             ZipShort headerId = new ZipShort(data, start);\n             int length = (new ZipShort(data, start + 2)).getValue();\n             if (start + WORD + length > data.length) {\n-                throw new ZipException(\"bad extra field starting at \"\n-                                       + start + \".  Block length of \"\n-                                       + length + \" bytes exceeds remaining\"\n-                                       + \" data of \"\n-                                       + (data.length - start - WORD)\n-                                       + \" bytes.\");\n+                switch(onUnparseableData.getKey()) {\n+                case UnparseableExtraField.THROW_KEY:\n+                    throw new ZipException(\"bad extra field starting at \"\n+                                           + start + \".  Block length of \"\n+                                           + length + \" bytes exceeds remaining\"\n+                                           + \" data of \"\n+                                           + (data.length - start - WORD)\n+                                           + \" bytes.\");\n+                case UnparseableExtraField.READ_KEY:\n+                    UnparseableExtraFieldData field =\n+                        new UnparseableExtraFieldData();\n+                    if (local) {\n+                        field.parseFromLocalFileData(data, start,\n+                                                     data.length - start);\n+                    } else {\n+                        field.parseFromCentralDirectoryData(data, start,\n+                                                            data.length - start);\n+                    }\n+                    v.add(field);\n+                    /*FALLTHROUGH*/\n+                case UnparseableExtraField.SKIP_KEY:\n+                    // since we cannot parse the data we must assume\n+                    // the extra field consumes the whole rest of the\n+                    // available data\n+                    break LOOP;\n+                default:\n+                    throw new ZipException(\"unknown UnparseableExtraField key: \"\n+                                           + onUnparseableData.getKey());\n+                }\n             }\n             try {\n                 ZipExtraField ze = createExtraField(headerId);\n      * @return an array of bytes\n      */\n     public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\n-        int sum = WORD * data.length;\n+        final boolean lastIsUnparseableHolder = data.length > 0\n+            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n+        int regularExtraFieldCount =\n+            lastIsUnparseableHolder ? data.length - 1 : data.length;\n+\n+        int sum = WORD * regularExtraFieldCount;\n         for (int i = 0; i < data.length; i++) {\n             sum += data[i].getLocalFileDataLength().getValue();\n         }\n+\n         byte[] result = new byte[sum];\n         int start = 0;\n-        for (int i = 0; i < data.length; i++) {\n+        for (int i = 0; i < regularExtraFieldCount; i++) {\n             System.arraycopy(data[i].getHeaderId().getBytes(),\n                              0, result, start, 2);\n             System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n             System.arraycopy(local, 0, result, start + WORD, local.length);\n             start += (local.length + WORD);\n         }\n+        if (lastIsUnparseableHolder) {\n+            byte[] local = data[data.length - 1].getLocalFileDataData();\n+            System.arraycopy(local, 0, result, start, local.length);\n+        }\n         return result;\n     }\n \n      * @return an array of bytes\n      */\n     public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {\n-        int sum = WORD * data.length;\n+        final boolean lastIsUnparseableHolder = data.length > 0\n+            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n+        int regularExtraFieldCount =\n+            lastIsUnparseableHolder ? data.length - 1 : data.length;\n+\n+        int sum = WORD * regularExtraFieldCount;\n         for (int i = 0; i < data.length; i++) {\n             sum += data[i].getCentralDirectoryLength().getValue();\n         }\n         byte[] result = new byte[sum];\n         int start = 0;\n-        for (int i = 0; i < data.length; i++) {\n+        for (int i = 0; i < regularExtraFieldCount; i++) {\n             System.arraycopy(data[i].getHeaderId().getBytes(),\n                              0, result, start, 2);\n             System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n             System.arraycopy(local, 0, result, start + WORD, local.length);\n             start += (local.length + WORD);\n         }\n+        if (lastIsUnparseableHolder) {\n+            byte[] local = data[data.length - 1].getCentralDirectoryData();\n+            System.arraycopy(local, 0, result, start, local.length);\n+        }\n         return result;\n     }\n+\n+    /**\n+     * \"enum\" for the possible actions to take if the extra field\n+     * cannot be parsed.\n+     */\n+    public static final class UnparseableExtraField {\n+        /**\n+         * Key for \"throw an exception\" action.\n+         */\n+        public static final int THROW_KEY = 0;\n+        /**\n+         * Key for \"skip\" action.\n+         */\n+        public static final int SKIP_KEY = 1;\n+        /**\n+         * Key for \"read\" action.\n+         */\n+        public static final int READ_KEY = 2;\n+\n+        /**\n+         * Throw an exception if field cannot be parsed.\n+         */\n+        public static final UnparseableExtraField THROW\n+            = new UnparseableExtraField(THROW_KEY);\n+\n+        /**\n+         * Skip the extra field entirely and don't make its data\n+         * available - effectively removing the extra field data.\n+         */\n+        public static final UnparseableExtraField SKIP\n+            = new UnparseableExtraField(SKIP_KEY);\n+\n+        /**\n+         * Read the extra field data into an instance of {@link\n+         * UnparseableExtraFieldData UnparseableExtraFieldData}.\n+         */\n+        public static final UnparseableExtraField READ\n+            = new UnparseableExtraField(READ_KEY);\n+\n+        private final int key;\n+\n+        private UnparseableExtraField(int k) {\n+            key = k;\n+        }\n+\n+        /**\n+         * Key of the action to take.\n+         */\n+        public int getKey() { return key; }\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnparseableExtraFieldData.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+/**\n+ * Wrapper for extra field data that doesn't conform to the recommended format of header-tag + size + data.\n+ *\n+ * <p>The header-id is artificial (and not listed as a know ID in\n+ * {@link http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n+ * APPNOTE.TXT}.  Since it isn't used anywhere except to satisfy the\n+ * ZipExtraField contract it shouldn't matter anyway.</p>\n+ * @NotThreadSafe\n+ */\n+public final class UnparseableExtraFieldData implements ZipExtraField {\n+    private static final ZipShort HEADER_ID = new ZipShort(0xACC1);\n+\n+    private byte[] localFileData;\n+    private byte[] centralDirectoryData;\n+\n+    /**\n+     * The Header-ID.\n+     *\n+     * @return a completely arbitrary value that should be ignored.\n+     */\n+    public ZipShort getHeaderId() {\n+        return HEADER_ID;\n+    }\n+\n+    /**\n+     * Length of the complete extra field in the local file data.\n+     *\n+     * @return The LocalFileDataLength value\n+     */\n+    public ZipShort getLocalFileDataLength() {\n+        return new ZipShort(localFileData == null ? 0 : localFileData.length);\n+    }\n+\n+    /**\n+     * Length of the complete extra field in the central directory.\n+     *\n+     * @return The CentralDirectoryLength value\n+     */\n+    public ZipShort getCentralDirectoryLength() {\n+        return centralDirectoryData == null\n+            ? getLocalFileDataLength()\n+            : new ZipShort(centralDirectoryData.length);\n+    }\n+\n+    /**\n+     * The actual data to put into local file data.\n+     *\n+     * @return The LocalFileDataData value\n+     */\n+    public byte[] getLocalFileDataData() {\n+        return ZipUtil.copy(localFileData);\n+    }\n+\n+    /**\n+     * The actual data to put into central directory.\n+     *\n+     * @return The CentralDirectoryData value\n+     */\n+    public byte[] getCentralDirectoryData() {\n+        return centralDirectoryData == null\n+            ? getLocalFileDataData() : ZipUtil.copy(centralDirectoryData);\n+    }\n+\n+    /**\n+     * Populate data from this array as if it was in local file data.\n+     *\n+     * @param buffer the buffer to read data from\n+     * @param offset offset into buffer to read data\n+     * @param length the length of data\n+     */\n+    public void parseFromLocalFileData(byte[] buffer, int offset, int length) {\n+        localFileData = new byte[length];\n+        System.arraycopy(buffer, offset, localFileData, 0, length);\n+    }\n+\n+    /**\n+     * Populate data from this array as if it was in central directory data.\n+     *\n+     * @param buffer the buffer to read data from\n+     * @param offset offset into buffer to read data\n+     * @param length the length of data\n+     * @exception ZipException on error\n+     */\n+    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n+                                              int length) {\n+        centralDirectoryData = new byte[length];\n+        System.arraycopy(buffer, offset, centralDirectoryData, 0, length);\n+        if (localFileData == null) {\n+            parseFromLocalFileData(buffer, offset, length);\n+        }\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnrecognizedExtraField.java\n      * @param data the field data to use\n      */\n     public void setLocalFileDataData(byte[] data) {\n-        localData = copy(data);\n+        localData = ZipUtil.copy(data);\n     }\n \n     /**\n      * @return the local data\n      */\n     public byte[] getLocalFileDataData() {\n-        return copy(localData);\n+        return ZipUtil.copy(localData);\n     }\n \n     /**\n      * @param data the data to use\n      */\n     public void setCentralDirectoryData(byte[] data) {\n-        centralData = copy(data);\n+        centralData = ZipUtil.copy(data);\n     }\n \n     /**\n      */\n     public byte[] getCentralDirectoryData() {\n         if (centralData != null) {\n-            return copy(centralData);\n+            return ZipUtil.copy(centralData);\n         }\n         return getLocalFileDataData();\n     }\n         }\n     }\n \n-    private static byte[] copy(byte[] from) {\n-        if (from != null) {\n-            byte[] to = new byte[from.length];\n-            System.arraycopy(from, 0, to, 0, to.length);\n-            return to;\n-        }\n-        return null;\n-    }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipUtil.java\n         return null;\n     }\n \n+    /**\n+     * Create a copy of the given array - or return null if the\n+     * argument is null.\n+     */\n+    static byte[] copy(byte[] from) {\n+        if (from != null) {\n+            byte[] to = new byte[from.length];\n+            System.arraycopy(from, 0, to, 0, to.length);\n+            return to;\n+        }\n+        return null;\n+    }\n \n }\n--- a/src/test/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtilsTest.java\n+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtilsTest.java\n \n package org.apache.commons.compress.archivers.zip;\n \n+import java.util.Arrays;\n import junit.framework.TestCase;\n \n /**\n         }\n     }\n \n+    public void testParseWithRead() throws Exception {\n+        ZipExtraField[] ze =\n+            ExtraFieldUtils.parse(data, true,\n+                                  ExtraFieldUtils.UnparseableExtraField.READ);\n+        assertEquals(\"number of fields\", 2, ze.length);\n+        assertTrue(\"type field 1\", ze[0] instanceof AsiExtraField);\n+        assertEquals(\"mode field 1\", 040755,\n+                     ((AsiExtraField) ze[0]).getMode());\n+        assertTrue(\"type field 2\", ze[1] instanceof UnrecognizedExtraField);\n+        assertEquals(\"data length field 2\", 1,\n+                     ze[1].getLocalFileDataLength().getValue());\n+\n+        byte[] data2 = new byte[data.length-1];\n+        System.arraycopy(data, 0, data2, 0, data2.length);\n+        ze = ExtraFieldUtils.parse(data2, true,\n+                                   ExtraFieldUtils.UnparseableExtraField.READ);\n+        assertEquals(\"number of fields\", 2, ze.length);\n+        assertTrue(\"type field 1\", ze[0] instanceof AsiExtraField);\n+        assertEquals(\"mode field 1\", 040755,\n+                     ((AsiExtraField) ze[0]).getMode());\n+        assertTrue(\"type field 2\", ze[1] instanceof UnparseableExtraFieldData);\n+        assertEquals(\"data length field 2\", 4,\n+                     ze[1].getLocalFileDataLength().getValue());\n+        byte[] expectedData = new byte[4];\n+        for (int i = 0; i < 4; i++) {\n+            assertEquals(\"byte number \" + i,\n+                         data2[data.length - 5 + i],\n+                         ze[1].getLocalFileDataData()[i]);\n+        }\n+    }\n+\n+    public void testParseWithSkip() throws Exception {\n+        ZipExtraField[] ze =\n+            ExtraFieldUtils.parse(data, true,\n+                                  ExtraFieldUtils.UnparseableExtraField.SKIP);\n+        assertEquals(\"number of fields\", 2, ze.length);\n+        assertTrue(\"type field 1\", ze[0] instanceof AsiExtraField);\n+        assertEquals(\"mode field 1\", 040755,\n+                     ((AsiExtraField) ze[0]).getMode());\n+        assertTrue(\"type field 2\", ze[1] instanceof UnrecognizedExtraField);\n+        assertEquals(\"data length field 2\", 1,\n+                     ze[1].getLocalFileDataLength().getValue());\n+\n+        byte[] data2 = new byte[data.length-1];\n+        System.arraycopy(data, 0, data2, 0, data2.length);\n+        ze = ExtraFieldUtils.parse(data2, true,\n+                                   ExtraFieldUtils.UnparseableExtraField.SKIP);\n+        assertEquals(\"number of fields\", 1, ze.length);\n+        assertTrue(\"type field 1\", ze[0] instanceof AsiExtraField);\n+        assertEquals(\"mode field 1\", 040755,\n+                     ((AsiExtraField) ze[0]).getMode());\n+    }\n+\n     /**\n      * Test merge methods\n      */\n         }\n \n     }\n+\n+    public void testMergeWithUnparseableData() throws Exception {\n+        ZipExtraField d = new UnparseableExtraFieldData();\n+        d.parseFromLocalFileData(new byte[] {1, 0, 1, 0}, 0, 4);\n+        byte[] local =\n+            ExtraFieldUtils.mergeLocalFileDataData(new ZipExtraField[] {a, d});\n+        assertEquals(\"local length\", data.length - 1, local.length);\n+        for (int i = 0; i < local.length; i++) {\n+            assertEquals(\"local byte \" + i, data[i], local[i]);\n+        }\n+\n+        byte[] dCentral = d.getCentralDirectoryData();\n+        byte[] data2 = new byte[4 + aLocal.length + dCentral.length];\n+        System.arraycopy(data, 0, data2, 0, 4 + aLocal.length + 2);\n+        System.arraycopy(dCentral, 0, data2,\n+                         4 + aLocal.length, dCentral.length);\n+\n+\n+        byte[] central =\n+            ExtraFieldUtils.mergeCentralDirectoryData(new ZipExtraField[] {a, d});\n+        assertEquals(\"central length\", data2.length, central.length);\n+        for (int i = 0; i < central.length; i++) {\n+            assertEquals(\"central byte \" + i, data2[i], central[i]);\n+        }\n+\n+    }\n }", "timestamp": 1266320264, "metainfo": ""}