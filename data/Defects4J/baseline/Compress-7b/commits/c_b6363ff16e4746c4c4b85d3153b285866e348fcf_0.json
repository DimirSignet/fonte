{"sha": "b6363ff16e4746c4c4b85d3153b285866e348fcf", "log": "throw an exception on CRC errors, submitted by Christian Grobmeier, SANDBOX-298  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n  * An input stream that decompresses from the BZip2 format (without the file\n  * header chars) to be read as any other stream.\n  */\n-public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants {\n-    private static void reportCRCError() throws IOException {\n-        // The clean way would be to throw an exception.\n-        //throw new IOException(\"crc error\");\n-\n-        // Just print a message, like the previous versions of this class did\n-        System.err.println(\"BZip2 CRC error\");\n-    }\n-\n-    private void makeMaps() {\n-        final boolean[] inUse   = this.data.inUse;\n-        final byte[] seqToUnseq = this.data.seqToUnseq;\n-\n-        int nInUseShadow = 0;\n-\n-        for (int i = 0; i < 256; i++) {\n-            if (inUse[i])\n-                seqToUnseq[nInUseShadow++] = (byte) i;\n-        }\n-\n-        this.nInUse = nInUseShadow;\n-    }\n+public class BZip2CompressorInputStream extends CompressorInputStream implements\n+                                                                          BZip2Constants {\n \n     /**\n      * Index of the last char in the block, so the block size == last + 1.\n      */\n-    private int  last;\n+    private int last;\n \n     /**\n      * Index in zptr[] of original string after sorting.\n      */\n-    private int  origPtr;\n+    private int origPtr;\n \n     /**\n-     * always: in the range 0 .. 9.\n-     * The current block size is 100000 * this number.\n+     * always: in the range 0 .. 9. The current block size is 100000 * this\n+     * number.\n      */\n     private int blockSize100k;\n \n \n     private int currentChar = -1;\n \n-    private static final int EOF                  = 0;\n+    private static final int EOF = 0;\n     private static final int START_BLOCK_STATE = 1;\n     private static final int RAND_PART_A_STATE = 2;\n     private static final int RAND_PART_B_STATE = 3;\n     private char su_z;\n \n     /**\n-     * All memory intensive stuff.\n-     * This field is initialized by initBlock().\n+     * All memory intensive stuff. This field is initialized by initBlock().\n      */\n     private BZip2CompressorInputStream.Data data;\n \n     /**\n-     * Constructs a new CBZip2InputStream which decompresses bytes read from\n-     * the specified stream.\n-     *\n-     * <p>Although BZip2 headers are marked with the magic\n-     * <tt>\"Bz\"</tt> this constructor expects the next byte in the\n-     * stream to be the first one after the magic.  Thus callers have\n-     * to skip the first two bytes. Otherwise this constructor will\n-     * throw an exception. </p>\n-     *\n+     * Constructs a new CBZip2InputStream which decompresses bytes read from the\n+     * specified stream.\n+     * \n+     * <p>\n+     * Although BZip2 headers are marked with the magic <tt>\"Bz\"</tt> this\n+     * constructor expects the next byte in the stream to be the first one after\n+     * the magic. Thus callers have to skip the first two bytes. Otherwise this\n+     * constructor will throw an exception.\n+     * </p>\n+     * \n      * @throws IOException\n-     *  if the stream content is malformed or an I/O error occurs.\n+     *             if the stream content is malformed or an I/O error occurs.\n      * @throws NullPointerException\n-     *  if <tt>in == null</tt>\n+     *             if <tt>in == null</tt>\n      */\n     public BZip2CompressorInputStream(final InputStream in) throws IOException {\n         super();\n         init();\n     }\n \n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.io.InputStream#read()\n+     */\n     public int read() throws IOException {\n         if (this.in != null) {\n             return read0();\n         }\n     }\n \n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.io.InputStream#read(byte[], int, int)\n+     */\n     public int read(final byte[] dest, final int offs, final int len)\n         throws IOException {\n         if (offs < 0) {\n         }\n         if (offs + len > dest.length) {\n             throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n-                                                + len + \") > dest.length(\"\n-                                                + dest.length + \").\");\n+                                                + len + \") > dest.length(\" + dest.length + \").\");\n         }\n         if (this.in == null) {\n             throw new IOException(\"stream closed\");\n         }\n \n         return (destOffs == offs) ? -1 : (destOffs - offs);\n+    }\n+\n+    private void makeMaps() {\n+        final boolean[] inUse = this.data.inUse;\n+        final byte[] seqToUnseq = this.data.seqToUnseq;\n+\n+        int nInUseShadow = 0;\n+\n+        for (int i = 0; i < 256; i++) {\n+            if (inUse[i])\n+                seqToUnseq[nInUseShadow++] = (byte) i;\n+        }\n+\n+        this.nInUse = nInUseShadow;\n     }\n \n     private int read0() throws IOException {\n         int magic = this.in.read();\n         if (magic != expected) {\n             throw new IOException(\"Stream is not BZip2 formatted: expected '\"\n-                                  + expected + \"' as \" + position\n-                                  + \" byte but got '\" + (char) magic\n-                                  + \"'\");\n+                                  + expected + \"' as \" + position + \" byte but got '\"\n+                                  + (char) magic + \"'\");\n         }\n     }\n \n         char magic4 = bsGetUByte();\n         char magic5 = bsGetUByte();\n \n-        if (magic0 == 0x17 &&\n-            magic1 == 0x72 &&\n-            magic2 == 0x45 &&\n-            magic3 == 0x38 &&\n-            magic4 == 0x50 &&\n-            magic5 == 0x90) {\n+        if (magic0 == 0x17 && magic1 == 0x72 && magic2 == 0x45\n+            && magic3 == 0x38 && magic4 == 0x50 && magic5 == 0x90) {\n             complete(); // end of file\n         } else if (magic0 != 0x31 || // '1'\n                    magic1 != 0x41 || // ')'\n                    magic2 != 0x59 || // 'Y'\n                    magic3 != 0x26 || // '&'\n                    magic4 != 0x53 || // 'S'\n-                   magic5 != 0x59   // 'Y'\n+                   magic5 != 0x59 // 'Y'\n                    ) {\n             this.currentState = EOF;\n             throw new IOException(\"bad block header\");\n             this.blockRandomised = bsR(1) == 1;\n \n             /**\n-             * Allocate data here instead in constructor, so we do not\n-             * allocate it if the input file is empty.\n+             * Allocate data here instead in constructor, so we do not allocate\n+             * it if the input file is empty.\n              */\n             if (this.data == null) {\n                 this.data = new Data(this.blockSize100k);\n         if (this.storedBlockCRC != this.computedBlockCRC) {\n             // make next blocks readable without error\n             // (repair feature, not yet documented, not tested)\n-            this.computedCombinedCRC\n-                = (this.storedCombinedCRC << 1)\n+            this.computedCombinedCRC = (this.storedCombinedCRC << 1)\n                 | (this.storedCombinedCRC >>> 31);\n             this.computedCombinedCRC ^= this.storedBlockCRC;\n \n-            reportCRCError();\n-        }\n-\n-        this.computedCombinedCRC\n-            = (this.computedCombinedCRC << 1)\n+            throw new IOException(\"BZip2 CRC error\");\n+        }\n+\n+        this.computedCombinedCRC = (this.computedCombinedCRC << 1)\n             | (this.computedCombinedCRC >>> 31);\n         this.computedCombinedCRC ^= this.computedBlockCRC;\n     }\n         this.data = null;\n \n         if (this.storedCombinedCRC != this.computedCombinedCRC) {\n-            reportCRCError();\n+            throw new IOException(\"BZip2 CRC error\");\n         }\n     }\n \n      * Called by createHuffmanDecodingTables() exclusively.\n      */\n     private static void hbCreateDecodeTables(final int[] limit,\n-                                             final int[] base,\n-                                             final int[] perm,\n-                                             final char[] length,\n-                                             final int minLen,\n-                                             final int maxLen,\n-                                             final int alphaSize) {\n+                                             final int[] base, final int[] perm, final char[] length,\n+                                             final int minLen, final int maxLen, final int alphaSize) {\n         for (int i = minLen, pp = 0; i <= maxLen; i++) {\n             for (int j = 0; j < alphaSize; j++) {\n                 if (length[j] == i) {\n     }\n \n     private void recvDecodingTables() throws IOException {\n-        final Data dataShadow     = this.data;\n-        final boolean[] inUse     = dataShadow.inUse;\n-        final byte[] pos          = dataShadow.recvDecodingTables_pos;\n-        final byte[] selector     = dataShadow.selector;\n-        final byte[] selectorMtf  = dataShadow.selectorMtf;\n+        final Data dataShadow = this.data;\n+        final boolean[] inUse = dataShadow.inUse;\n+        final byte[] pos = dataShadow.recvDecodingTables_pos;\n+        final byte[] selector = dataShadow.selector;\n+        final byte[] selectorMtf = dataShadow.selectorMtf;\n \n         int inUse16 = 0;\n \n             selector[i] = tmp;\n         }\n \n-        final char[][] len  = dataShadow.temp_charArray2d;\n+        final char[][] len = dataShadow.temp_charArray2d;\n \n         /* Now the coding tables */\n         for (int t = 0; t < nGroups; t++) {\n     private void createHuffmanDecodingTables(final int alphaSize,\n                                              final int nGroups) {\n         final Data dataShadow = this.data;\n-        final char[][] len  = dataShadow.temp_charArray2d;\n+        final char[][] len = dataShadow.temp_charArray2d;\n         final int[] minLens = dataShadow.minLens;\n         final int[][] limit = dataShadow.limit;\n-        final int[][] base  = dataShadow.base;\n-        final int[][] perm  = dataShadow.perm;\n+        final int[][] base = dataShadow.base;\n+        final int[][] perm = dataShadow.perm;\n \n         for (int t = 0; t < nGroups; t++) {\n             int minLen = 32;\n         recvDecodingTables();\n \n         final InputStream inShadow = this.in;\n-        final Data dataShadow   = this.data;\n-        final byte[] ll8        = dataShadow.ll8;\n-        final int[] unzftab     = dataShadow.unzftab;\n-        final byte[] selector   = dataShadow.selector;\n+        final Data dataShadow = this.data;\n+        final byte[] ll8 = dataShadow.ll8;\n+        final int[] unzftab = dataShadow.unzftab;\n+        final byte[] selector = dataShadow.selector;\n         final byte[] seqToUnseq = dataShadow.seqToUnseq;\n-        final char[] yy         = dataShadow.getAndMoveToFrontDecode_yy;\n-        final int[] minLens     = dataShadow.minLens;\n-        final int[][] limit     = dataShadow.limit;\n-        final int[][] base      = dataShadow.base;\n-        final int[][] perm      = dataShadow.perm;\n-        final int limitLast     = this.blockSize100k * 100000;\n+        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n+        final int[] minLens = dataShadow.minLens;\n+        final int[][] limit = dataShadow.limit;\n+        final int[][] base = dataShadow.base;\n+        final int[][] perm = dataShadow.perm;\n+        final int limitLast = this.blockSize100k * 100000;\n \n         /*\n-          Setting up the unzftab entries here is not strictly\n-          necessary, but it does save having to do it later\n-          in a separate pass, and so saves a block's worth of\n-          cache misses.\n-        */\n+         * Setting up the unzftab entries here is not strictly necessary, but it\n+         * does save having to do it later in a separate pass, and so saves a\n+         * block's worth of cache misses.\n+         */\n         for (int i = 256; --i >= 0;) {\n             yy[i] = (char) i;\n             unzftab[i] = 0;\n         }\n \n-        int groupNo     = 0;\n-        int groupPos    = G_SIZE - 1;\n-        final int eob   = this.nInUse + 1;\n-        int nextSym     = getAndMoveToFrontDecode0(0);\n-        int bsBuffShadow      = this.bsBuff;\n-        int bsLiveShadow      = this.bsLive;\n-        int lastShadow        = -1;\n-        int zt          = selector[groupNo] & 0xff;\n-        int[] base_zt   = base[zt];\n-        int[] limit_zt  = limit[zt];\n-        int[] perm_zt   = perm[zt];\n-        int minLens_zt  = minLens[zt];\n+        int groupNo = 0;\n+        int groupPos = G_SIZE - 1;\n+        final int eob = this.nInUse + 1;\n+        int nextSym = getAndMoveToFrontDecode0(0);\n+        int bsBuffShadow = this.bsBuff;\n+        int bsLiveShadow = this.bsLive;\n+        int lastShadow = -1;\n+        int zt = selector[groupNo] & 0xff;\n+        int[] base_zt = base[zt];\n+        int[] limit_zt = limit[zt];\n+        int[] perm_zt = perm[zt];\n+        int minLens_zt = minLens[zt];\n \n         while (nextSym != eob) {\n             if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                     }\n \n                     if (groupPos == 0) {\n-                        groupPos    = G_SIZE - 1;\n-                        zt          = selector[++groupNo] & 0xff;\n-                        base_zt     = base[zt];\n-                        limit_zt    = limit[zt];\n-                        perm_zt     = perm[zt];\n-                        minLens_zt  = minLens[zt];\n+                        groupPos = G_SIZE - 1;\n+                        zt = selector[++groupNo] & 0xff;\n+                        base_zt = base[zt];\n+                        limit_zt = limit[zt];\n+                        perm_zt = perm[zt];\n+                        minLens_zt = minLens[zt];\n                     } else {\n                         groupPos--;\n                     }\n                             throw new IOException(\"unexpected end of stream\");\n                         }\n                     }\n-                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);\n+                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n+                        & ((1 << zn) - 1);\n                     bsLiveShadow -= zn;\n \n                     while (zvec > limit_zt[zn]) {\n                                 bsLiveShadow += 8;\n                                 continue;\n                             } else {\n-                                throw new IOException(\"unexpected end of stream\");\n+                                throw new IOException(\n+                                                      \"unexpected end of stream\");\n                             }\n                         }\n                         bsLiveShadow--;\n-                        zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n+                        zvec = (zvec << 1)\n+                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                     }\n                     nextSym = perm_zt[zvec - base_zt[zn]];\n                 }\n                 ll8[lastShadow] = seqToUnseq[tmp];\n \n                 /*\n-                  This loop is hammered during decompression,\n-                  hence avoid native method call overhead of\n-                  System.arraycopy for very small ranges to copy.\n-                */\n+                 * This loop is hammered during decompression, hence avoid\n+                 * native method call overhead of System.arraycopy for very\n+                 * small ranges to copy.\n+                 */\n                 if (nextSym <= 16) {\n                     for (int j = nextSym - 1; j > 0;) {\n                         yy[j] = yy[--j];\n                 yy[0] = tmp;\n \n                 if (groupPos == 0) {\n-                    groupPos    = G_SIZE - 1;\n-                    zt          = selector[++groupNo] & 0xff;\n-                    base_zt     = base[zt];\n-                    limit_zt    = limit[zt];\n-                    perm_zt     = perm[zt];\n-                    minLens_zt  = minLens[zt];\n+                    groupPos = G_SIZE - 1;\n+                    zt = selector[++groupNo] & 0xff;\n+                    base_zt = base[zt];\n+                    limit_zt = limit[zt];\n+                    perm_zt = perm[zt];\n+                    minLens_zt = minLens[zt];\n                 } else {\n                     groupPos--;\n                 }\n                         throw new IOException(\"unexpected end of stream\");\n                     }\n                 }\n-                int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1);\n+                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n+                    & ((1 << zn) - 1);\n                 bsLiveShadow -= zn;\n \n                 while (zvec > limit_zt[zn]) {\n         this.bsBuff = bsBuffShadow;\n     }\n \n-    private int getAndMoveToFrontDecode0(final int groupNo)\n-        throws IOException {\n-        final InputStream inShadow  = this.in;\n-        final Data dataShadow  = this.data;\n-        final int zt          = dataShadow.selector[groupNo] & 0xff;\n-        final int[] limit_zt  = dataShadow.limit[zt];\n+    private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\n+        final InputStream inShadow = this.in;\n+        final Data dataShadow = this.data;\n+        final int zt = dataShadow.selector[groupNo] & 0xff;\n+        final int[] limit_zt = dataShadow.limit[zt];\n         int zn = dataShadow.minLens[zt];\n         int zvec = bsR(zn);\n         int bsLiveShadow = this.bsLive;\n         }\n \n         final int[] cftab = this.data.cftab;\n-        final int[] tt    = this.data.initTT(this.last + 1);\n-        final byte[] ll8  = this.data.ll8;\n+        final int[] tt = this.data.initTT(this.last + 1);\n+        final byte[] ll8 = this.data.ll8;\n         cftab[0] = 0;\n         System.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\n \n         this.su_tPos = tt[this.origPtr];\n         this.su_count = 0;\n         this.su_i2 = 0;\n-        this.su_ch2 = 256;   /* not a char and not EOF */\n+        this.su_ch2 = 256; /* not a char and not EOF */\n \n         if (this.blockRandomised) {\n             this.su_rNToGo = 0;\n     private static final class Data extends Object {\n \n         // (with blockSize 900k)\n-        final boolean[] inUse   = new boolean[256];                                   //      256 byte\n-\n-        final byte[] seqToUnseq   = new byte[256];                                    //      256 byte\n-        final byte[] selector     = new byte[MAX_SELECTORS];                          //    18002 byte\n-        final byte[] selectorMtf  = new byte[MAX_SELECTORS];                          //    18002 byte\n+        final boolean[] inUse = new boolean[256]; // 256 byte\n+\n+        final byte[] seqToUnseq = new byte[256]; // 256 byte\n+        final byte[] selector = new byte[MAX_SELECTORS]; // 18002 byte\n+        final byte[] selectorMtf = new byte[MAX_SELECTORS]; // 18002 byte\n \n         /**\n          * Freq table collected to save a pass over the data during\n          * decompression.\n          */\n-        final int[] unzftab = new int[256];                                           //     1024 byte\n-\n-        final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE];                      //     6192 byte\n-        final int[][] base  = new int[N_GROUPS][MAX_ALPHA_SIZE];                      //     6192 byte\n-        final int[][] perm  = new int[N_GROUPS][MAX_ALPHA_SIZE];                      //     6192 byte\n-        final int[] minLens = new int[N_GROUPS];                                      //       24 byte\n-\n-        final int[]     cftab     = new int[257];                                     //     1028 byte\n-        final char[]    getAndMoveToFrontDecode_yy = new char[256];                   //      512 byte\n-        final char[][]  temp_charArray2d  = new char[N_GROUPS][MAX_ALPHA_SIZE];       //     3096 byte\n-        final byte[] recvDecodingTables_pos = new byte[N_GROUPS];                     //        6 byte\n-        //---------------\n-        //    60798 byte\n-\n-        int[] tt;                                                                     //  3600000 byte\n-        byte[] ll8;                                                                   //   900000 byte\n-        //---------------\n-        //  4560782 byte\n-        //===============\n+        final int[] unzftab = new int[256]; // 1024 byte\n+\n+        final int[][] limit = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\n+        final int[][] base = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\n+        final int[][] perm = new int[N_GROUPS][MAX_ALPHA_SIZE]; // 6192 byte\n+        final int[] minLens = new int[N_GROUPS]; // 24 byte\n+\n+        final int[] cftab = new int[257]; // 1028 byte\n+        final char[] getAndMoveToFrontDecode_yy = new char[256]; // 512 byte\n+        final char[][] temp_charArray2d = new char[N_GROUPS][MAX_ALPHA_SIZE]; // 3096\n+        // byte\n+        final byte[] recvDecodingTables_pos = new byte[N_GROUPS]; // 6 byte\n+        // ---------------\n+        // 60798 byte\n+\n+        int[] tt; // 3600000 byte\n+        byte[] ll8; // 900000 byte\n+\n+        // ---------------\n+        // 4560782 byte\n+        // ===============\n \n         Data(int blockSize100k) {\n             super();\n \n         /**\n          * Initializes the {@link #tt} array.\n-         *\n-         * This method is called when the required length of the array\n-         * is known.  I don't initialize it at construction time to\n-         * avoid unneccessary memory allocation when compressing small\n-         * files.\n+         * \n+         * This method is called when the required length of the array is known.\n+         * I don't initialize it at construction time to avoid unneccessary\n+         * memory allocation when compressing small files.\n          */\n         final int[] initTT(int length) {\n             int[] ttShadow = this.tt;\n \n             // tt.length should always be >= length, but theoretically\n             // it can happen, if the compressor mixed small and large\n-            // blocks.  Normally only the last block will be smaller\n+            // blocks. Normally only the last block will be smaller\n             // than others.\n             if ((ttShadow == null) || (ttShadow.length < length)) {\n                 this.tt = ttShadow = new int[length];\n     }\n \n }\n-", "timestamp": 1237561504, "metainfo": ""}