{"sha": "6284d8ddb7aa59c75483f22eae1ca442f8537a84", "log": "rename ZipOutputStream to ZipArchiveOutputStream  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n-import org.apache.commons.compress.archivers.zip.ZipOutputStream;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n \n /**\n  * Factory to create Archive[In|Out]putStreams from names\n         if (\"ar\".equalsIgnoreCase(archiverName)) {\n             return new ArArchiveOutputStream(out);\n         } else if(\"zip\".equalsIgnoreCase(archiverName)) {\n-            return new ZipOutputStream(out);\n+            return new ZipArchiveOutputStream(out);\n         } else if(\"tar\".equalsIgnoreCase(archiverName)) {\n             return new TarArchiveOutputStream(out);\n         } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n--- a/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStream.java\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\n-import org.apache.commons.compress.archivers.zip.ZipOutputStream;\n+import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n \n-public class JarArchiveOutputStream extends ZipOutputStream {\n+public class JarArchiveOutputStream extends ZipArchiveOutputStream {\n \n \tpublic JarArchiveOutputStream( final OutputStream out ) {\n \t\tsuper(out);\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+package org.apache.commons.compress.archivers.zip;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.RandomAccessFile;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.CRC32;\n+import java.util.zip.Deflater;\n+import java.util.zip.ZipException;\n+\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n+\n+/**\n+ * Reimplementation of {@link java.util.zip.ZipOutputStream\n+ * java.util.zip.ZipOutputStream} that does handle the extended\n+ * functionality of this package, especially internal/external file\n+ * attributes and extra fields with different layouts for local file\n+ * data and central directory entries.\n+ *\n+ * <p>This class will try to use {@link java.io.RandomAccessFile\n+ * RandomAccessFile} when you know that the output is going to go to a\n+ * file.</p>\n+ *\n+ * <p>If RandomAccessFile cannot be used, this implementation will use\n+ * a Data Descriptor to store size and CRC information for {@link\n+ * #DEFLATED DEFLATED} entries, this means, you don't need to\n+ * calculate them yourself.  Unfortunately this is not possible for\n+ * the {@link #STORED STORED} method, here setting the CRC and\n+ * uncompressed size information is required before {@link\n+ * #putNextEntry putNextEntry} can be called.</p>\n+ *\n+ */\n+public class ZipArchiveOutputStream extends ArchiveOutputStream {\n+\n+    private static final int BYTE_MASK = 0xFF;\n+    private static final int SHORT = 2;\n+    private static final int WORD = 4;\n+    private static final int BUFFER_SIZE = 512;\n+    /* \n+     * Apparently Deflater.setInput gets slowed down a lot on Sun JVMs\n+     * when it gets handed a really big buffer.  See\n+     * https://issues.apache.org/bugzilla/show_bug.cgi?id=45396\n+     *\n+     * Using a buffer size of 8 kB proved to be a good compromise\n+     */\n+    private static final int DEFLATER_BLOCK_SIZE = 8192;\n+\n+    /**\n+     * Compression method for deflated entries.\n+     *\n+     * @since 1.1\n+     */\n+    public static final int DEFLATED = java.util.zip.ZipEntry.DEFLATED;\n+\n+    /**\n+     * Default compression level for deflated entries.\n+     *\n+     * @since Ant 1.7\n+     */\n+    public static final int DEFAULT_COMPRESSION = Deflater.DEFAULT_COMPRESSION;\n+\n+    /**\n+     * Compression method for stored entries.\n+     *\n+     * @since 1.1\n+     */\n+    public static final int STORED = java.util.zip.ZipEntry.STORED;\n+\n+    /**\n+     * Current entry.\n+     *\n+     * @since 1.1\n+     */\n+    private ZipArchiveEntry entry;\n+\n+    /**\n+     * The file comment.\n+     *\n+     * @since 1.1\n+     */\n+    private String comment = \"\";\n+\n+    /**\n+     * Compression level for next entry.\n+     *\n+     * @since 1.1\n+     */\n+    private int level = DEFAULT_COMPRESSION;\n+\n+    /**\n+     * Has the compression level changed when compared to the last\n+     * entry?\n+     *\n+     * @since 1.5\n+     */\n+    private boolean hasCompressionLevelChanged = false;\n+\n+    /**\n+     * Default compression method for next entry.\n+     *\n+     * @since 1.1\n+     */\n+    private int method = java.util.zip.ZipEntry.DEFLATED;\n+\n+    /**\n+     * List of ZipEntries written so far.\n+     *\n+     * @since 1.1\n+     */\n+    private final List entries = new LinkedList();\n+\n+    /**\n+     * CRC instance to avoid parsing DEFLATED data twice.\n+     *\n+     * @since 1.1\n+     */\n+    private final CRC32 crc = new CRC32();\n+\n+    /**\n+     * Count the bytes written to out.\n+     *\n+     * @since 1.1\n+     */\n+    private long written = 0;\n+\n+    /**\n+     * Data for local header data\n+     *\n+     * @since 1.1\n+     */\n+    private long dataStart = 0;\n+\n+    /**\n+     * Offset for CRC entry in the local file header data for the\n+     * current entry starts here.\n+     *\n+     * @since 1.15\n+     */\n+    private long localDataStart = 0;\n+\n+    /**\n+     * Start of central directory.\n+     *\n+     * @since 1.1\n+     */\n+    private long cdOffset = 0;\n+\n+    /**\n+     * Length of central directory.\n+     *\n+     * @since 1.1\n+     */\n+    private long cdLength = 0;\n+\n+    /**\n+     * Helper, a 0 as ZipShort.\n+     *\n+     * @since 1.1\n+     */\n+    private static final byte[] ZERO = {0, 0};\n+\n+    /**\n+     * Helper, a 0 as ZipLong.\n+     *\n+     * @since 1.1\n+     */\n+    private static final byte[] LZERO = {0, 0, 0, 0};\n+\n+    /**\n+     * Holds the offsets of the LFH starts for each entry.\n+     *\n+     * @since 1.1\n+     */\n+    private final Map offsets = new HashMap();\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * <p>For a list of possible values see <a\n+     * href=\"http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html\">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.\n+     * Defaults to the platform's default character encoding.</p>\n+     *\n+     * @since 1.3\n+     */\n+    private String encoding = null;\n+\n+    // CheckStyle:VisibilityModifier OFF - bc\n+\n+    /**\n+     * This Deflater object is used for output.\n+     *\n+     * <p>This attribute is only protected to provide a level of API\n+     * backwards compatibility.  This class used to extend {@link\n+     * java.util.zip.DeflaterOutputStream DeflaterOutputStream} up to\n+     * Revision 1.13.</p>\n+     *\n+     * @since 1.14\n+     */\n+    protected Deflater def = new Deflater(level, true);\n+\n+    /**\n+     * This buffer servers as a Deflater.\n+     *\n+     * <p>This attribute is only protected to provide a level of API\n+     * backwards compatibility.  This class used to extend {@link\n+     * java.util.zip.DeflaterOutputStream DeflaterOutputStream} up to\n+     * Revision 1.13.</p>\n+     *\n+     * @since 1.14\n+     */\n+    protected byte[] buf = new byte[BUFFER_SIZE];\n+\n+    // CheckStyle:VisibilityModifier ON\n+\n+    /**\n+     * Optional random access output.\n+     *\n+     * @since 1.14\n+     */\n+    private RandomAccessFile raf = null;\n+\n+    /**\n+     * Creates a new ZIP OutputStream filtering the underlying stream.\n+     * @param out the outputstream to zip\n+     * @since 1.1\n+     */\n+    public ZipArchiveOutputStream(OutputStream out) {\n+        super(out);\n+    }\n+\n+    /**\n+     * Creates a new ZIP OutputStream writing to a File.  Will use\n+     * random access if possible.\n+     * @param file the file to zip to\n+     * @since 1.14\n+     * @throws IOException on error\n+     */\n+    public ZipArchiveOutputStream(File file) throws IOException {\n+        super(null);\n+\n+        try {\n+            raf = new RandomAccessFile(file, \"rw\");\n+            raf.setLength(0);\n+        } catch (IOException e) {\n+            if (raf != null) {\n+                try {\n+                    raf.close();\n+                } catch (IOException inner) {\n+                    // ignore\n+                }\n+                raf = null;\n+            }\n+            out = new FileOutputStream(file);\n+        }\n+    }\n+\n+    /**\n+     * This method indicates whether this archive is writing to a seekable stream (i.e., to a random\n+     * access file).\n+     *\n+     * <p>For seekable streams, you don't need to calculate the CRC or\n+     * uncompressed size for {@link #STORED} entries before\n+     * invoking {@link #putNextEntry}.\n+     * @return true if seekable\n+     * @since 1.17\n+     */\n+    public boolean isSeekable() {\n+        return raf != null;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * <p>For a list of possible values see <a\n+     * href=\"http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html\">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.\n+     * Defaults to the platform's default character encoding.</p>\n+     * @param encoding the encoding value\n+     * @since 1.3\n+     */\n+    public void setEncoding(String encoding) {\n+        this.encoding = encoding;\n+    }\n+\n+    /**\n+     * The encoding to use for filenames and the file comment.\n+     *\n+     * @return null if using the platform's default character encoding.\n+     *\n+     * @since 1.3\n+     */\n+    public String getEncoding() {\n+        return encoding;\n+    }\n+\n+    /**\n+     * Finishs writing the contents and closes this as well as the\n+     * underlying stream.\n+     *\n+     * @since 1.1\n+     * @throws IOException on error\n+     */\n+    public void finish() throws IOException {\n+        closeEntry();\n+        cdOffset = written;\n+        for (Iterator i = entries.iterator(); i.hasNext(); ) {\n+            writeCentralFileHeader((ZipArchiveEntry) i.next());\n+        }\n+        cdLength = written - cdOffset;\n+        writeCentralDirectoryEnd();\n+        offsets.clear();\n+        entries.clear();\n+    }\n+\n+    /**\n+     * Writes all necessary data for this entry.\n+     *\n+     * @since 1.1\n+     * @throws IOException on error\n+     */\n+    public void closeEntry() throws IOException {\n+        if (entry == null) {\n+            return;\n+        }\n+\n+        long realCrc = crc.getValue();\n+        crc.reset();\n+\n+        if (entry.getMethod() == DEFLATED) {\n+            def.finish();\n+            while (!def.finished()) {\n+                deflate();\n+            }\n+\n+            entry.setSize(adjustToLong(def.getTotalIn()));\n+            entry.setCompressedSize(adjustToLong(def.getTotalOut()));\n+            entry.setCrc(realCrc);\n+\n+            def.reset();\n+\n+            written += entry.getCompressedSize();\n+        } else if (raf == null) {\n+            if (entry.getCrc() != realCrc) {\n+                throw new ZipException(\"bad CRC checksum for entry \"\n+                                       + entry.getName() + \": \"\n+                                       + Long.toHexString(entry.getCrc())\n+                                       + \" instead of \"\n+                                       + Long.toHexString(realCrc));\n+            }\n+\n+            if (entry.getSize() != written - dataStart) {\n+                throw new ZipException(\"bad size for entry \"\n+                                       + entry.getName() + \": \"\n+                                       + entry.getSize()\n+                                       + \" instead of \"\n+                                       + (written - dataStart));\n+            }\n+        } else { /* method is STORED and we used RandomAccessFile */\n+            long size = written - dataStart;\n+\n+            entry.setSize(size);\n+            entry.setCompressedSize(size);\n+            entry.setCrc(realCrc);\n+        }\n+\n+        // If random access output, write the local file header containing\n+        // the correct CRC and compressed/uncompressed sizes\n+        if (raf != null) {\n+            long save = raf.getFilePointer();\n+\n+            raf.seek(localDataStart);\n+            writeOut(ZipLong.getBytes(entry.getCrc()));\n+            writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n+            writeOut(ZipLong.getBytes(entry.getSize()));\n+            raf.seek(save);\n+        }\n+\n+        writeDataDescriptor(entry);\n+        entry = null;\n+    }\n+\n+    /**\n+     * Begin writing next entry.\n+     * @param ze the entry to write\n+     * @since 1.1\n+     * @throws IOException on error\n+     */\n+    public void putNextEntry(ZipArchiveEntry ze) throws IOException {\n+        closeEntry();\n+\n+        entry = ze;\n+        entries.add(entry);\n+\n+        if (entry.getMethod() == -1) { // not specified\n+            entry.setMethod(method);\n+        }\n+\n+        if (entry.getTime() == -1) { // not specified\n+            entry.setTime(System.currentTimeMillis());\n+        }\n+\n+        // Size/CRC not required if RandomAccessFile is used\n+        if (entry.getMethod() == STORED && raf == null) {\n+            if (entry.getSize() == -1) {\n+                throw new ZipException(\"uncompressed size is required for\"\n+                                       + \" STORED method when not writing to a\"\n+                                       + \" file\");\n+            }\n+            if (entry.getCrc() == -1) {\n+                throw new ZipException(\"crc checksum is required for STORED\"\n+                                       + \" method when not writing to a file\");\n+            }\n+            entry.setCompressedSize(entry.getSize());\n+        }\n+\n+        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\n+            def.setLevel(level);\n+            hasCompressionLevelChanged = false;\n+        }\n+        writeLocalFileHeader(entry);\n+    }\n+\n+    /**\n+     * Set the file comment.\n+     * @param comment the comment\n+     * @since 1.1\n+     */\n+    public void setComment(String comment) {\n+        this.comment = comment;\n+    }\n+\n+    /**\n+     * Sets the compression level for subsequent entries.\n+     *\n+     * <p>Default is Deflater.DEFAULT_COMPRESSION.</p>\n+     * @param level the compression level.\n+     * @throws IllegalArgumentException if an invalid compression level is specified.\n+     * @since 1.1\n+     */\n+    public void setLevel(int level) {\n+        if (level < Deflater.DEFAULT_COMPRESSION\n+            || level > Deflater.BEST_COMPRESSION) {\n+            throw new IllegalArgumentException(\n+                \"Invalid compression level: \" + level);\n+        }\n+        hasCompressionLevelChanged = (this.level != level);\n+        this.level = level;\n+    }\n+\n+    /**\n+     * Sets the default compression method for subsequent entries.\n+     *\n+     * <p>Default is DEFLATED.</p>\n+     * @param method an <code>int</code> from java.util.zip.ZipEntry\n+     * @since 1.1\n+     */\n+    public void setMethod(int method) {\n+        this.method = method;\n+    }\n+\n+    /**\n+     * Writes bytes to ZIP entry.\n+     * @param b the byte array to write\n+     * @param offset the start position to write from\n+     * @param length the number of bytes to write\n+     * @throws IOException on error\n+     */\n+    public void write(byte[] b, int offset, int length) throws IOException {\n+        if (entry.getMethod() == DEFLATED) {\n+            if (length > 0) {\n+                if (!def.finished()) {\n+                    if (length <= DEFLATER_BLOCK_SIZE) {\n+                        def.setInput(b, offset, length);\n+                        deflateUntilInputIsNeeded();\n+                    } else {\n+                        final int fullblocks = length / DEFLATER_BLOCK_SIZE;\n+                        for (int i = 0; i < fullblocks; i++) {\n+                            def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,\n+                                         DEFLATER_BLOCK_SIZE);\n+                            deflateUntilInputIsNeeded();\n+                        }\n+                        final int done = fullblocks * DEFLATER_BLOCK_SIZE;\n+                        if (done < length) {\n+                            def.setInput(b, offset + done, length - done);\n+                            deflateUntilInputIsNeeded();\n+                        }\n+                    }\n+                }\n+            }\n+        } else {\n+            writeOut(b, offset, length);\n+            written += length;\n+        }\n+        crc.update(b, offset, length);\n+    }\n+\n+    /**\n+     * Writes a single byte to ZIP entry.\n+     *\n+     * <p>Delegates to the three arg method.</p>\n+     * @param b the byte to write\n+     * @since 1.14\n+     * @throws IOException on error\n+     */\n+    public void write(int b) throws IOException {\n+        byte[] buff = new byte[1];\n+        buff[0] = (byte) (b & BYTE_MASK);\n+        write(buff, 0, 1);\n+    }\n+\n+    /**\n+     * Closes this output stream and releases any system resources\n+     * associated with the stream.\n+     *\n+     * @exception  IOException  if an I/O error occurs.\n+     * @since 1.14\n+     */\n+    public void close() throws IOException {\n+        finish();\n+\n+        if (raf != null) {\n+            raf.close();\n+        }\n+        if (out != null) {\n+            out.close();\n+        }\n+    }\n+\n+    /**\n+     * Flushes this output stream and forces any buffered output bytes\n+     * to be written out to the stream.\n+     *\n+     * @exception  IOException  if an I/O error occurs.\n+     * @since 1.14\n+     */\n+    public void flush() throws IOException {\n+        if (out != null) {\n+            out.flush();\n+        }\n+    }\n+\n+    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n+        putNextEntry((ZipArchiveEntry) entry);\n+    }\n+\n+    public void closeArchiveEntry() {\n+        // do nothing\n+    }\n+\n+    /*\n+     * Various ZIP constants\n+     */\n+    /**\n+     * local file header signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final byte[] LFH_SIG = ZipLong.getBytes(0X04034B50L);\n+    /**\n+     * data descriptor signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final byte[] DD_SIG = ZipLong.getBytes(0X08074B50L);\n+    /**\n+     * central file header signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final byte[] CFH_SIG = ZipLong.getBytes(0X02014B50L);\n+    /**\n+     * end of central dir signature\n+     *\n+     * @since 1.1\n+     */\n+    protected static final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L);\n+\n+    /**\n+     * Writes next block of compressed data to the output stream.\n+     * @throws IOException on error\n+     *\n+     * @since 1.14\n+     */\n+    protected final void deflate() throws IOException {\n+        int len = def.deflate(buf, 0, buf.length);\n+        if (len > 0) {\n+            writeOut(buf, 0, len);\n+        }\n+    }\n+\n+    /**\n+     * Writes the local file header entry\n+     * @param ze the entry to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.1\n+     */\n+    protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n+        offsets.put(ze, ZipLong.getBytes(written));\n+\n+        writeOut(LFH_SIG);\n+        written += WORD;\n+\n+        //store method in local variable to prevent multiple method calls\n+        final int zipMethod = ze.getMethod();\n+\n+        // version needed to extract\n+        // general purpose bit flag\n+        // CheckStyle:MagicNumber OFF\n+        if (zipMethod == DEFLATED && raf == null) {\n+            // requires version 2 as we are going to store length info\n+            // in the data descriptor\n+            writeOut(ZipShort.getBytes(20));\n+\n+            // bit3 set to signal, we use a data descriptor\n+            writeOut(ZipShort.getBytes(8));\n+        } else {\n+            writeOut(ZipShort.getBytes(10));\n+            writeOut(ZERO);\n+        }\n+        // CheckStyle:MagicNumber ON\n+        written += WORD;\n+\n+        // compression method\n+        writeOut(ZipShort.getBytes(zipMethod));\n+        written += SHORT;\n+\n+        // last mod. time and date\n+        writeOut(toDosTime(ze.getTime()));\n+        written += WORD;\n+\n+        // CRC\n+        // compressed length\n+        // uncompressed length\n+        localDataStart = written;\n+        if (zipMethod == DEFLATED || raf != null) {\n+            writeOut(LZERO);\n+            writeOut(LZERO);\n+            writeOut(LZERO);\n+        } else {\n+            writeOut(ZipLong.getBytes(ze.getCrc()));\n+            writeOut(ZipLong.getBytes(ze.getSize()));\n+            writeOut(ZipLong.getBytes(ze.getSize()));\n+        }\n+        // CheckStyle:MagicNumber OFF\n+        written += 12;\n+        // CheckStyle:MagicNumber ON\n+\n+        // file name length\n+        byte[] name = getBytes(ze.getName());\n+        writeOut(ZipShort.getBytes(name.length));\n+        written += SHORT;\n+\n+        // extra field length\n+        byte[] extra = ze.getLocalFileDataExtra();\n+        writeOut(ZipShort.getBytes(extra.length));\n+        written += SHORT;\n+\n+        // file name\n+        writeOut(name);\n+        written += name.length;\n+\n+        // extra field\n+        writeOut(extra);\n+        written += extra.length;\n+\n+        dataStart = written;\n+    }\n+\n+    /**\n+     * Writes the data descriptor entry.\n+     * @param ze the entry to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.1\n+     */\n+    protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {\n+        if (ze.getMethod() != DEFLATED || raf != null) {\n+            return;\n+        }\n+        writeOut(DD_SIG);\n+        writeOut(ZipLong.getBytes(entry.getCrc()));\n+        writeOut(ZipLong.getBytes(entry.getCompressedSize()));\n+        writeOut(ZipLong.getBytes(entry.getSize()));\n+        // CheckStyle:MagicNumber OFF\n+        written += 16;\n+        // CheckStyle:MagicNumber ON\n+    }\n+\n+    /**\n+     * Writes the central file header entry.\n+     * @param ze the entry to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.1\n+     */\n+    protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException {\n+        writeOut(CFH_SIG);\n+        written += WORD;\n+\n+        // version made by\n+        // CheckStyle:MagicNumber OFF\n+        writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20));\n+        written += SHORT;\n+\n+        // version needed to extract\n+        // general purpose bit flag\n+        if (ze.getMethod() == DEFLATED && raf == null) {\n+            // requires version 2 as we are going to store length info\n+            // in the data descriptor\n+            writeOut(ZipShort.getBytes(20));\n+\n+            // bit3 set to signal, we use a data descriptor\n+            writeOut(ZipShort.getBytes(8));\n+        } else {\n+            writeOut(ZipShort.getBytes(10));\n+            writeOut(ZERO);\n+        }\n+        // CheckStyle:MagicNumber ON\n+        written += WORD;\n+\n+        // compression method\n+        writeOut(ZipShort.getBytes(ze.getMethod()));\n+        written += SHORT;\n+\n+        // last mod. time and date\n+        writeOut(toDosTime(ze.getTime()));\n+        written += WORD;\n+\n+        // CRC\n+        // compressed length\n+        // uncompressed length\n+        writeOut(ZipLong.getBytes(ze.getCrc()));\n+        writeOut(ZipLong.getBytes(ze.getCompressedSize()));\n+        writeOut(ZipLong.getBytes(ze.getSize()));\n+        // CheckStyle:MagicNumber OFF\n+        written += 12;\n+        // CheckStyle:MagicNumber ON\n+\n+        // file name length\n+        byte[] name = getBytes(ze.getName());\n+        writeOut(ZipShort.getBytes(name.length));\n+        written += SHORT;\n+\n+        // extra field length\n+        byte[] extra = ze.getCentralDirectoryExtra();\n+        writeOut(ZipShort.getBytes(extra.length));\n+        written += SHORT;\n+\n+        // file comment length\n+        String comm = ze.getComment();\n+        if (comm == null) {\n+            comm = \"\";\n+        }\n+        byte[] commentB = getBytes(comm);\n+        writeOut(ZipShort.getBytes(commentB.length));\n+        written += SHORT;\n+\n+        // disk number start\n+        writeOut(ZERO);\n+        written += SHORT;\n+\n+        // internal file attributes\n+        writeOut(ZipShort.getBytes(ze.getInternalAttributes()));\n+        written += SHORT;\n+\n+        // external file attributes\n+        writeOut(ZipLong.getBytes(ze.getExternalAttributes()));\n+        written += WORD;\n+\n+        // relative offset of LFH\n+        writeOut((byte[]) offsets.get(ze));\n+        written += WORD;\n+\n+        // file name\n+        writeOut(name);\n+        written += name.length;\n+\n+        // extra field\n+        writeOut(extra);\n+        written += extra.length;\n+\n+        // file comment\n+        writeOut(commentB);\n+        written += commentB.length;\n+    }\n+\n+    /**\n+     * Writes the &quot;End of central dir record&quot;.\n+     * @throws IOException on error\n+     *\n+     * @since 1.1\n+     */\n+    protected void writeCentralDirectoryEnd() throws IOException {\n+        writeOut(EOCD_SIG);\n+\n+        // disk numbers\n+        writeOut(ZERO);\n+        writeOut(ZERO);\n+\n+        // number of entries\n+        byte[] num = ZipShort.getBytes(entries.size());\n+        writeOut(num);\n+        writeOut(num);\n+\n+        // length and location of CD\n+        writeOut(ZipLong.getBytes(cdLength));\n+        writeOut(ZipLong.getBytes(cdOffset));\n+\n+        // ZIP file comment\n+        byte[] data = getBytes(comment);\n+        writeOut(ZipShort.getBytes(data.length));\n+        writeOut(data);\n+    }\n+\n+    /**\n+     * Smallest date/time ZIP can handle.\n+     *\n+     * @since 1.1\n+     */\n+    private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field.\n+     * @param time the <code>Date</code> to convert\n+     * @return the date as a <code>ZipLong</code>\n+     * @since 1.1\n+     */\n+    protected static ZipLong toDosTime(Date time) {\n+        return new ZipLong(toDosTime(time.getTime()));\n+    }\n+\n+    /**\n+     * Convert a Date object to a DOS date/time field.\n+     *\n+     * <p>Stolen from InfoZip's <code>fileio.c</code></p>\n+     * @param t number of milliseconds since the epoch\n+     * @return the date as a byte array\n+     * @since 1.26\n+     */\n+    protected static byte[] toDosTime(long t) {\n+        Date time = new Date(t);\n+        // CheckStyle:MagicNumberCheck OFF - I do not think that using constants\n+        //                                   here will improve the readablity\n+        int year = time.getYear() + 1900;\n+        if (year < 1980) {\n+            return DOS_TIME_MIN;\n+        }\n+        int month = time.getMonth() + 1;\n+        long value =  ((year - 1980) << 25)\n+            |         (month << 21)\n+            |         (time.getDate() << 16)\n+            |         (time.getHours() << 11)\n+            |         (time.getMinutes() << 5)\n+            |         (time.getSeconds() >> 1);\n+        return ZipLong.getBytes(value);\n+        // CheckStyle:MagicNumberCheck ON\n+    }\n+\n+    /**\n+     * Retrieve the bytes for the given String in the encoding set for\n+     * this Stream.\n+     * @param name the string to get bytes from\n+     * @return the bytes as a byte array\n+     * @throws ZipException on error\n+     *\n+     * @since 1.3\n+     */\n+    protected byte[] getBytes(String name) throws ZipException {\n+        if (encoding == null) {\n+            return name.getBytes();\n+        } else {\n+            try {\n+                return name.getBytes(encoding);\n+            } catch (UnsupportedEncodingException uee) {\n+                throw new ZipException(uee.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write bytes to output or random access file.\n+     * @param data the byte array to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.14\n+     */\n+    protected final void writeOut(byte[] data) throws IOException {\n+        writeOut(data, 0, data.length);\n+    }\n+\n+    /**\n+     * Write bytes to output or random access file.\n+     * @param data the byte array to write\n+     * @param offset the start position to write from\n+     * @param length the number of bytes to write\n+     * @throws IOException on error\n+     *\n+     * @since 1.14\n+     */\n+    protected final void writeOut(byte[] data, int offset, int length)\n+        throws IOException {\n+        if (raf != null) {\n+            raf.write(data, offset, length);\n+        } else {\n+            out.write(data, offset, length);\n+        }\n+    }\n+\n+    /**\n+     * Assumes a negative integer really is a positive integer that\n+     * has wrapped around and re-creates the original value.\n+     * @param i the value to treat as unsigned int.\n+     * @return the unsigned int as a long.\n+     * @since 1.34\n+     */\n+    protected static long adjustToLong(int i) {\n+        if (i < 0) {\n+            return 2 * ((long) Integer.MAX_VALUE) + 2 + i;\n+        } else {\n+            return i;\n+        }\n+    }\n+\n+    private void deflateUntilInputIsNeeded() throws IOException {\n+        while (!def.needsInput()) {\n+            deflate();\n+        }\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n         byte[] signatureBytes = new byte[WORD];\n         archive.readFully(signatureBytes);\n         long sig = ZipLong.getValue(signatureBytes);\n-        final long cfhSig = ZipLong.getValue(ZipOutputStream.CFH_SIG);\n+        final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);\n         if (sig != cfhSig && startsWithLocalFileHeader()) {\n             throw new IOException(\"central directory is empty, can't expand\"\n                                   + \" corrupt archive.\");\n         long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE);\n         if (off >= 0) {\n             archive.seek(off);\n-            byte[] sig = ZipOutputStream.EOCD_SIG;\n+            byte[] sig = ZipArchiveOutputStream.EOCD_SIG;\n             int curr = archive.read();\n             while (off >= stopSearching && curr != -1) {\n                 if (curr == sig[POS_0]) {\n         final byte[] start = new byte[WORD];\n         archive.readFully(start);\n         for (int i = 0; i < start.length; i++) {\n-            if (start[i] != ZipOutputStream.LFH_SIG[i]) {\n+            if (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) {\n                 return false;\n             }\n         }", "timestamp": 1233941260, "metainfo": ""}