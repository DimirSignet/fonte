{"sha": "b6886eb41d060b9569bf101a017abdf89acb29f2", "log": "COMPRESS-93: Support for alternative ZIP compression methods  Allow entries with unsupported compression methods to be safely skipped if the compressed size of the entry is stored in the entry header.  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n         return true;        \n     }\n \n+    /**\n+     * Closes the current ZIP archive entry and positions the underlying\n+     * stream to the beginning of the next entry. All per-entry variables\n+     * and data structures are cleared.\n+     * <p>\n+     * If the compressed size of this entry is included in the entry header,\n+     * then any outstanding bytes are simply skipped from the underlying\n+     * stream without uncompressing them. This allows an entry to be safely\n+     * closed even if the compression method is unsupported.\n+     * <p>\n+     * In case we don't know the compressed size of this entry or have\n+     * already buffered too much data from the underlying stream to support\n+     * uncompression, then the uncompression process is completed and the\n+     * end position of the stream is adjusted based on the result of that\n+     * process.\n+     *\n+     * @throws IOException if an error occurs\n+     */\n     private void closeEntry() throws IOException {\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         if (current == null) {\n             return;\n         }\n+\n         // Ensure all entry bytes are read\n-        skip(Long.MAX_VALUE);\n-        int inB;\n-        if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n-            inB = inf.getTotalIn();\n+        if (bytesReadFromStream <= current.getCompressedSize()\n+                && !hasDataDescriptor) {\n+            long remaining = current.getCompressedSize() - bytesReadFromStream;\n+            while (remaining > 0) {\n+                long n = in.skip(remaining);\n+                if (n == 0) { // skip() may return 0, use read() as a fallback\n+                    n = in.read(buf, 0, (int) Math.min(buf.length, remaining));\n+                }\n+                if (n < 0) {\n+                    throw new EOFException(\n+                            \"Truncated ZIP entry: \" + current.getName());\n+                } else {\n+                    remaining -= n;\n+                }\n+            }\n         } else {\n-            inB = readBytesOfEntry;\n-        }\n-        int diff = 0;\n-\n-        // Pushback any required bytes\n-        if ((diff = bytesReadFromStream - inB) != 0) {\n-            ((PushbackInputStream) in).unread(buf,\n-                                              lengthOfLastRead - diff, diff);\n+            skip(Long.MAX_VALUE);\n+\n+            int inB;\n+            if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+                inB = inf.getTotalIn();\n+            } else {\n+                inB = readBytesOfEntry;\n+            }\n+            int diff = 0;\n+\n+            // Pushback any required bytes\n+            if ((diff = bytesReadFromStream - inB) != 0) {\n+                ((PushbackInputStream) in).unread(\n+                        buf,  lengthOfLastRead - diff, diff);\n+            }\n         }\n \n         if (hasDataDescriptor) {", "timestamp": 1260733477, "metainfo": ""}