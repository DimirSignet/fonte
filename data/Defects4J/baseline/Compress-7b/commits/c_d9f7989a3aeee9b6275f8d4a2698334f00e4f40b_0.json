{"sha": "d9f7989a3aeee9b6275f8d4a2698334f00e4f40b", "log": "revert part of the move, need to figure out why only the top level dir was copied first  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n \n /**\n- * Factory to create Archive[In|Out]putStreams from names\n- * or the first bytes of the InputStream. In order add other\n- * implementations you should extend ArchiveStreamFactory\n- * and override the appropriate methods (and call their implementation\n- * from super of course)\n+ * Factory to create Archive[In|Out]putStreams from names or the first bytes of\n+ * the InputStream. In order add other implementations you should extend\n+ * ArchiveStreamFactory and override the appropriate methods (and call their\n+ * implementation from super of course)\n  * \n- * TODO add example here \n+ * TODO add example here\n  * \n  */\n-\n public class ArchiveStreamFactory {\n \n-    public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in ) throws ArchiveException {\n+    /**\n+     * Create an archive input stream from an archiver name and an input stream.\n+     * \n+     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\" or \"cpio\"\n+     * @param in the input stream\n+     * @return the archive input stream\n+     * @throws ArchiveException if the archiver name is not known\n+     * @throws IllegalArgumentException if the archiver name or stream is null\n+     */\n+    public ArchiveInputStream createArchiveInputStream(\n+            final String archiverName, final InputStream in)\n+            throws ArchiveException {\n+        if (archiverName == null || in == null) {\n+            throw new IllegalArgumentException(\"Archivername must not be null.\");\n+        }\n+\n         if (\"ar\".equalsIgnoreCase(archiverName)) {\n             return new ArArchiveInputStream(in);\n-        } else if(\"zip\".equalsIgnoreCase(archiverName)) {\n+        } else if (\"zip\".equalsIgnoreCase(archiverName)) {\n             return new ZipArchiveInputStream(in);\n-        } else if(\"tar\".equalsIgnoreCase(archiverName)) {\n+        } else if (\"tar\".equalsIgnoreCase(archiverName)) {\n             return new TarArchiveInputStream(in);\n-        } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n+        } else if (\"jar\".equalsIgnoreCase(archiverName)) {\n             return new JarArchiveInputStream(in);\n-        } else if(\"cpio\".equalsIgnoreCase(archiverName)) {\n+        } else if (\"cpio\".equalsIgnoreCase(archiverName)) {\n             return new CpioArchiveInputStream(in);\n         }\n-        return null;\n+        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n     }\n \n-    public ArchiveOutputStream createArchiveOutputStream( final String archiverName, final OutputStream out ) throws ArchiveException {\n+    /**\n+     * Create an archive output stream from an archiver name and an input stream.\n+     * \n+     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\" or \"cpio\"\n+     * @param out the output stream\n+     * @return the archive output stream\n+     * @throws ArchiveException if the archiver name is not known\n+     * @throws IllegalArgumentException if the archiver name or stream is null\n+     */\n+    public ArchiveOutputStream createArchiveOutputStream(\n+            final String archiverName, final OutputStream out)\n+            throws ArchiveException {\n+        if (archiverName == null || out == null) {\n+            throw new IllegalArgumentException(\n+                    \"Archivername and stream must not be null.\");\n+        }\n+\n         if (\"ar\".equalsIgnoreCase(archiverName)) {\n             return new ArArchiveOutputStream(out);\n-        } else if(\"zip\".equalsIgnoreCase(archiverName)) {\n+        } else if (\"zip\".equalsIgnoreCase(archiverName)) {\n             return new ZipArchiveOutputStream(out);\n-        } else if(\"tar\".equalsIgnoreCase(archiverName)) {\n+        } else if (\"tar\".equalsIgnoreCase(archiverName)) {\n             return new TarArchiveOutputStream(out);\n-        } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n+        } else if (\"jar\".equalsIgnoreCase(archiverName)) {\n             return new JarArchiveOutputStream(out);\n-        } else if(\"cpio\".equalsIgnoreCase(archiverName)) {\n+        } else if (\"cpio\".equalsIgnoreCase(archiverName)) {\n             return new CpioArchiveOutputStream(out);\n         }\n-        return null;\n+        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n     }\n \n-    public ArchiveInputStream createArchiveInputStream( final InputStream input ) throws IOException {\n+    /**\n+     * Create an archive input stream from an input stream, autodetecting\n+     * the archive type from the first few bytes of the stream.\n+     * \n+     * @param in the input stream\n+     * @return the archive input stream\n+     * @throws ArchiveException if the archiver name is not known\n+     * @throws IllegalArgumentException if the stream is null or does not support mark\n+     */\n+    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n+            throws ArchiveException {\n+        if (in == null) {\n+            throw new IllegalArgumentException(\"Stream must not be null.\");\n+        }\n+\n+        if (!in.markSupported()) {\n+            throw new IllegalArgumentException(\"Mark is not supported.\");\n+        }\n \n         final byte[] signature = new byte[12];\n-        input.mark(signature.length);\n-        int signatureLength = input.read(signature);\n-        // TODO if reset is not supported pass on the IOException or return null?\n-        input.reset();\n+        in.mark(signature.length);\n+        try {\n+            int signatureLength = in.read(signature);\n+            in.reset();\n+            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n+                return new ZipArchiveInputStream(in);\n+            } else if (JarArchiveInputStream\n+                    .matches(signature, signatureLength)) {\n+                return new JarArchiveInputStream(in);\n+            } else if (TarArchiveInputStream\n+                    .matches(signature, signatureLength)) {\n+                return new TarArchiveInputStream(in);\n+            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n+                return new ArArchiveInputStream(in);\n+            } else if (CpioArchiveInputStream.matches(signature,\n+                    signatureLength)) {\n+                return new CpioArchiveInputStream(in);\n+            }\n+        } catch (IOException e) {\n+            throw new ArchiveException(\n+                    \"Could not use reset and mark operations.\", e);\n+        }\n \n-        if(ZipArchiveInputStream.matches(signature, signatureLength)) {\n-            return new ZipArchiveInputStream(input);\n-        } else if(JarArchiveInputStream.matches(signature, signatureLength)) {\n-            return new JarArchiveInputStream(input);\n-        } else if(TarArchiveInputStream.matches(signature, signatureLength)) {\n-            return new TarArchiveInputStream(input);\n-        } else if(ArArchiveInputStream.matches(signature, signatureLength)) {\n-            return new ArArchiveInputStream(input);\n-        } else if(CpioArchiveInputStream.matches(signature, signatureLength)) {\n-            return new CpioArchiveInputStream(input);\n-        } \n-        return null;\n+        throw new ArchiveException(\n+                \"No Archiver found for the stream signature\");\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveEntry.java\n \n import org.apache.commons.compress.archivers.ArchiveEntry;\n \n+/**\n+ * Represents an archive entry in the \"ar\" format.\n+ */\n public class ArArchiveEntry implements ArchiveEntry {\n \n \tprivate final String name;\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n+/**\n+ * Implements the \"ar\" archive format as an input stream\n+ */\n public class ArArchiveInputStream extends ArchiveInputStream {\n \n     private final InputStream input;\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveOutputStream.java\n import org.apache.commons.compress.archivers.ArchiveEntry;\n import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n+/**\n+ * Implements the \"ar\" archive format as an output stream\n+ */\n public class ArArchiveOutputStream extends ArchiveOutputStream {\n \n     private final OutputStream out;\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n     public TarArchiveEntry(String name) {\n         this();\n \n+        name = normalizeFileName(name);\n         boolean isDir = name.endsWith(\"/\");\n \n         this.devMajor = 0;\n \n         this.file = file;\n \n-        String fileName = file.getPath();\n-        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.US);\n-\n-        if (osname != null) {\n-\n-            // Strip off drive letters!\n-            // REVIEW Would a better check be \"(File.separator == '\\')\"?\n-\n-            if (osname.startsWith(\"windows\")) {\n-                if (fileName.length() > 2) {\n-                    char ch1 = fileName.charAt(0);\n-                    char ch2 = fileName.charAt(1);\n-\n-                    if (ch2 == ':'\n-                            && ((ch1 >= 'a' && ch1 <= 'z')\n-                                || (ch1 >= 'A' && ch1 <= 'Z'))) {\n-                        fileName = fileName.substring(2);\n-                    }\n-                }\n-            } else if (osname.indexOf(\"netware\") > -1) {\n-                int colon = fileName.indexOf(':');\n-                if (colon != -1) {\n-                    fileName = fileName.substring(colon + 1);\n-                }\n-            }\n-        }\n-\n-        fileName = fileName.replace(File.separatorChar, '/');\n-\n-        // No absolute pathnames\n-        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n-        // so we loop on starting /'s.\n-        while (fileName.startsWith(\"/\")) {\n-            fileName = fileName.substring(1);\n-        }\n-\n+        String fileName = normalizeFileName(file.getPath());\n         this.linkName = new StringBuffer(\"\");\n         this.name = new StringBuffer(fileName);\n \n             this.mode = DEFAULT_DIR_MODE;\n             this.linkFlag = LF_DIR;\n \n-            if (this.name.charAt(this.name.length() - 1) != '/') {\n+            int nameLength = name.length();\n+            if (nameLength == 0 || name.charAt(nameLength - 1) != '/') {\n                 this.name.append(\"/\");\n             }\n+            this.size = 0;\n         } else {\n             this.mode = DEFAULT_FILE_MODE;\n             this.linkFlag = LF_NORMAL;\n-        }\n-\n-        this.size = file.length();\n+            this.size = file.length();\n+        }\n+\n         this.modTime = file.lastModified() / MILLIS_PER_SECOND;\n         this.devMajor = 0;\n         this.devMinor = 0;\n      * @param name This entry's new name.\n      */\n     public void setName(String name) {\n-        this.name = new StringBuffer(name);\n+        this.name = new StringBuffer(normalizeFileName(name));\n     }\n \n     /**\n      */\n     public boolean isGNULongNameEntry() {\n         return linkFlag == LF_GNUTYPE_LONGNAME\n-                           && name.toString().equals(GNU_LONGLINK);\n+            && name.toString().equals(GNU_LONGLINK);\n     }\n \n     /**\n         offset += DEVLEN;\n         devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n     }\n+\n+    /**\n+     * Strips Windows' drive letter as well as any leading slashes,\n+     * turns path separators into forward slahes.\n+     */\n+    private static String normalizeFileName(String fileName) {\n+        String osname = System.getProperty(\"os.name\").toLowerCase(Locale.US);\n+\n+        if (osname != null) {\n+\n+            // Strip off drive letters!\n+            // REVIEW Would a better check be \"(File.separator == '\\')\"?\n+\n+            if (osname.startsWith(\"windows\")) {\n+                if (fileName.length() > 2) {\n+                    char ch1 = fileName.charAt(0);\n+                    char ch2 = fileName.charAt(1);\n+\n+                    if (ch2 == ':'\n+                        && ((ch1 >= 'a' && ch1 <= 'z')\n+                            || (ch1 >= 'A' && ch1 <= 'Z'))) {\n+                        fileName = fileName.substring(2);\n+                    }\n+                }\n+            } else if (osname.indexOf(\"netware\") > -1) {\n+                int colon = fileName.indexOf(':');\n+                if (colon != -1) {\n+                    fileName = fileName.substring(colon + 1);\n+                }\n+            }\n+        }\n+\n+        fileName = fileName.replace(File.separatorChar, '/');\n+\n+        // No absolute pathnames\n+        // Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n+        // so we loop on starting /'s.\n+        while (fileName.startsWith(\"/\")) {\n+            fileName = fileName.substring(1);\n+        }\n+        return fileName;\n+    }\n }\n \n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n         // the empty string in the current implemention (there's no setter)\n         // so it is basically draining the performance of a hashmap lookup\n         return getName().hashCode();\n-    }\n-\n-    /**\n-     * The equality method. In this case, the implementation returns 'this == o'\n-     * which is basically the equals method of the Object class.\n-     * @param o the object to compare to\n-     * @return true if this object is the same as <code>o</code>\n-     */\n-    public boolean equals(Object o) {\n-        return (this == o);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n     /**\n      * Optional random access output.\n      */\n-    private RandomAccessFile raf = null;\n+    private final RandomAccessFile raf;\n \n     private final OutputStream out;\n \n      */\n     public ZipArchiveOutputStream(OutputStream out) {\n         this.out = out;\n+        this.raf = null;\n     }\n \n     /**\n      */\n     public ZipArchiveOutputStream(File file) throws IOException {\n         OutputStream o = null;\n+        RandomAccessFile _raf = null;\n         try {\n-            raf = new RandomAccessFile(file, \"rw\");\n-            raf.setLength(0);\n+            _raf = new RandomAccessFile(file, \"rw\");\n+            _raf.setLength(0);\n         } catch (IOException e) {\n-            if (raf != null) {\n+            if (_raf != null) {\n                 try {\n-                    raf.close();\n+                    _raf.close();\n                 } catch (IOException inner) {\n                     // ignore\n                 }\n-                raf = null;\n+                _raf = null;\n             }\n             o = new FileOutputStream(file);\n         }\n         out = o;\n+        raf = _raf;\n     }\n \n     /**\n     protected void writeLocalFileHeader(ZipArchiveEntry ze) throws IOException {\n \n         boolean encodable = zipEncoding.canEncode(ze.getName());\n-        ByteBuffer name;\n+        \n+        final ZipEncoding entryEncoding;\n+        \n         if (!encodable && fallbackToUTF8) {\n-            name = ZipEncodingHelper.UTF8_ZIP_ENCODING.encode(ze.getName());\n+            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n         } else {\n-            name = zipEncoding.encode(ze.getName());\n-        }\n+            entryEncoding = zipEncoding;\n+        }\n+        \n+        ByteBuffer name = entryEncoding.encode(ze.getName());        \n \n         if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n \n \n                 if (createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS\n                     || !commentEncodable) {\n-                    ByteBuffer commentB = this.zipEncoding.encode(comm);\n+                    ByteBuffer commentB = entryEncoding.encode(comm);\n                     ze.addExtraField(new UnicodeCommentExtraField(comm,\n                                                                   commentB.array(),\n                                                                   commentB.arrayOffset(),\n         // CheckStyle:MagicNumber ON\n \n         // file name length\n-        ByteBuffer name;\n+        final ZipEncoding entryEncoding;\n+        \n         if (!encodable && fallbackToUTF8) {\n-            name = ZipEncodingHelper.UTF8_ZIP_ENCODING.encode(ze.getName());\n+            entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING;\n         } else {\n-            name = zipEncoding.encode(ze.getName());\n-        }\n+            entryEncoding = zipEncoding;\n+        }\n+        \n+        ByteBuffer name = entryEncoding.encode(ze.getName());        \n+\n         writeOut(ZipShort.getBytes(name.limit()));\n         written += SHORT;\n \n         if (comm == null) {\n             comm = \"\";\n         }\n-        ByteBuffer commentB;\n-        if (!encodable && fallbackToUTF8) {\n-            commentB = ZipEncodingHelper.UTF8_ZIP_ENCODING.encode(comm);\n-        } else {\n-            commentB = zipEncoding.encode(comm);\n-        }\n+        \n+        ByteBuffer commentB = entryEncoding.encode(comm);\n+        \n         writeOut(ZipShort.getBytes(commentB.limit()));\n         written += SHORT;\n \n          * Create Unicode extra fields for filenames that cannot be\n          * encoded using the specified encoding.\n          */\n-        public static final UnicodeExtraFieldPolicy NOT_ENCODABLE =\n-            new UnicodeExtraFieldPolicy(\"not encodable\");\n+        public static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\n+            new UnicodeExtraFieldPolicy(\"not encodeable\");\n \n         private final String name;\n         private UnicodeExtraFieldPolicy(String n) {\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n     /**\n      * The actual data source.\n      */\n-    private RandomAccessFile archive;\n+    private final RandomAccessFile archive;\n \n     /**\n      * Whether to look for and use Unicode extra fields.\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipLong.java\n     private static final long BYTE_3_MASK = 0xFF000000L;\n     private static final int BYTE_3_SHIFT = 24;\n \n-    private long value;\n+    private final long value;\n \n     /**\n      * Create instance from a number.\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipShort.java\n     private static final int BYTE_1_MASK = 0xFF00;\n     private static final int BYTE_1_SHIFT = 8;\n \n-    private int value;\n+    private final int value;\n \n     /**\n      * Create instance from a number.\n--- a/src/main/java/org/apache/commons/compress/changes/Change.java\n+++ b/src/main/java/org/apache/commons/compress/changes/Change.java\n \n \n public class Change {\n-\tprivate String targetFile = null;\n-\tprivate ArchiveEntry entry = null;\n-\tprivate InputStream input = null;\n-\tprivate int type = 0;\n+\tprivate final String targetFile;\n+\tprivate final ArchiveEntry entry;\n+\tprivate final InputStream input;\n+\tprivate final int type;\n \t\n \tstatic final int TYPE_DELETE = 1;\n \tstatic final int TYPE_ADD = 2;\n-\tstatic final int TYPE_MOVE = 3;\n+\tstatic final int TYPE_MOVE = 3; // NOT USED\n \t\n \t/**\n \t * Constructor. Takes the filename of the file to be deleted\n \t\t}\n \t\ttargetFile = pFilename;\n \t\ttype = TYPE_DELETE;\n+\t\tinput = null;\n+\t\tentry = null;\n \t}\n \t\n //\tpublic Change(final String pOldname, final ArchiveEntry pEntry) {\n \t\tthis.entry = pEntry;\n \t\tthis.input = pInput;\n \t\ttype = TYPE_ADD;\n+\t\ttargetFile = null;\n \t}\n \t\n \tpublic ArchiveEntry getEntry() {\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;\n \n /**\n- * Factory to create Compressor[In|Out]putStreams from names\n- * In order add other implementations you should extend CompressorStreamFactory\n- * and override the appropriate methods (and call their implementation\n- * from super of course)\n+ * Factory to create Compressor[In|Out]putStreams from names In order add other\n+ * implementations you should extend CompressorStreamFactory and override the\n+ * appropriate methods (and call their implementation from super of course)\n  * \n- * TODO add example here \n+ * TODO add example here\n  * \n  */\n public class CompressorStreamFactory {\n \n-\tpublic CompressorInputStream createCompressorInputStream( final String name, final InputStream in ) throws CompressorException {\n-\t\ttry {\n+    /**\n+     * Create a compressor input stream from a compressor name and an input stream.\n+     * \n+     * @param name of the compressor, i.e. \"gz\" or \"bzip2\"\n+     * @param in the input stream\n+     * @return compressor input stream\n+     * @throws CompressorException if the compressor name is not known\n+     * @throws IllegalArgumentException if the name or input stream is null\n+     */\n+    public CompressorInputStream createCompressorInputStream(final String name,\n+            final InputStream in) throws CompressorException {\n+        if (name == null || in == null) {\n+            throw new IllegalArgumentException(\n+                    \"Compressor name and stream must not be null.\");\n+        }\n \n-\t\t\tif(\"gz\".equalsIgnoreCase(name)) {\n-\t\t\t\treturn new GzipCompressorInputStream(in);\n-\t\t\t} else if(\"bzip2\".equalsIgnoreCase(name)) {\n-\t\t\t\treturn new BZip2CompressorInputStream(in);\n-\t\t\t} \n-\n-\t\t\treturn null;\n-\t\t\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new CompressorException(\"Could not create CompressorInputStream\", e);\n-\t\t}\n+        try {\n+            if (\"gz\".equalsIgnoreCase(name)) {\n+                return new GzipCompressorInputStream(in);\n+            } else if (\"bzip2\".equalsIgnoreCase(name)) {\n+                return new BZip2CompressorInputStream(in);\n+            }\n+            throw new CompressorException(\"Compressor: \" + name + \" not found.\");\n+        } catch (IOException e) {\n+            throw new CompressorException(\n+                    \"Could not create CompressorInputStream\", e);\n+        }\n     }\n \n-    public CompressorOutputStream createCompressorOutputStream( final String name, final OutputStream out ) throws CompressorException {\n-\t\ttry {\n+    public CompressorOutputStream createCompressorOutputStream(\n+            final String name, final OutputStream out)\n+            throws CompressorException {\n+        if (name == null || out == null) {\n+            throw new IllegalArgumentException(\n+                    \"Compressor name and stream must not be null.\");\n+        }\n \n-\t\t\tif(\"gz\".equalsIgnoreCase(name)) {\n-\t\t\t\t\treturn new GzipCompressorOutputStream(out);\n-\t\t\t} else if(\"bzip2\".equalsIgnoreCase(name)) {\n-\t\t\t\t\treturn new BZip2CompressorOutputStream(out);\n-\t\t\t} \n-\t\t\treturn null;\n-\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new CompressorException(\"Could not create CompressorOutputStream\", e);\n-\t\t}\n+        try {\n+            if (\"gz\".equalsIgnoreCase(name)) {\n+                return new GzipCompressorOutputStream(out);\n+            } else if (\"bzip2\".equalsIgnoreCase(name)) {\n+                return new BZip2CompressorOutputStream(out);\n+            }\n+            throw new CompressorException(\"Compressor: \" + name + \" not found.\");\n+        } catch (IOException e) {\n+            throw new CompressorException(\n+                    \"Could not create CompressorOutputStream\", e);\n+        }\n     }\n }\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n public final class IOUtils {\n \n \t/**\n+     * Copies the content of a InputStream into an OutputStream.\n+     * Uses a default buffer size of 8024 bytes.\n+     * \n+     * @param input\n+     *            the InputStream to copy\n+     * @param output\n+     *            the target Stream\n+     * @throws IOException\n+     *             if an error occurs\n+     */\n+    public static void copy(final InputStream input, final OutputStream output) throws IOException {\n+        copy(input, output, 8024);\n+    }\n+    \n+    /**\n      * Copies the content of a InputStream into an OutputStream\n      * \n      * @param input\n      *            the InputStream to copy\n      * @param output\n      *            the target Stream\n+     * @param buffersize\n+     *            the buffer size to use\n      * @throws IOException\n-     *             if the streams are interrupted\n+     *             if an error occurs\n      */\n-    public static void copy(final InputStream input, final OutputStream output) throws IOException {\n-        final byte[] buffer = new byte[8024];\n-        int n = 0;\n-        while (-1 != (n = input.read(buffer))) {\n-            output.write(buffer, 0, n);\n-        }\n-    }\n-    \n     public static void copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\n         final byte[] buffer = new byte[buffersize];\n         int n = 0;\n--- a/src/test/java/org/apache/commons/compress/AbstractTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/AbstractTestCase.java\n import java.io.FileOutputStream;\n import java.io.InputStream;\n import java.io.OutputStream;\n-import java.lang.reflect.Method;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n import java.util.Iterator;\n import java.util.List;\n \n         dir = File.createTempFile(\"dir\", \"\");\n         dir.delete();\n         dir.mkdir();\n-\n-        addURL(new File(\"src/test/resources\").toURL());\n     }\n \n     protected File getFile(String path) {\n-        return new File(getClass().getClassLoader().getResource(path).getFile());\n+        return new File(\"src/test/resources\", path);\n     }\n \n     protected void tearDown() throws Exception {\n         dir.delete();\n         dir = null;\n-    }\n-\n-    /**\n-     * Adds a URL to the classpath. This method is necessary when running junit\n-     * tests from within eclipse.\n-     * \n-     * @param url\n-     *            the url to add\n-     * @throws Exception\n-     *             if an error occurs\n-     */\n-    public void addURL(URL url) throws Exception {\n-        URLClassLoader classLoader = (URLClassLoader) ClassLoader\n-                .getSystemClassLoader();\n-        Class clazz = URLClassLoader.class;\n-\n-        Method method = clazz.getDeclaredMethod(\"addURL\",\n-                new Class[] { URL.class });\n-        method.setAccessible(true);\n-        method.invoke(classLoader, new Object[] { url });\n     }\n \n     /**\n             out.closeArchiveEntry();\n \n             entry = new ZipArchiveEntry(\"testdata/test2.xml\");\n-            entry.setSize(file1.length());\n+            entry.setSize(file2.length());\n             out.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file2), out);\n             out.closeArchiveEntry();\n \n             entry = new ZipArchiveEntry(\"test/test3.xml\");\n-            entry.setSize(file1.length());\n+            entry.setSize(file3.length());\n             out.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file3), out);\n             out.closeArchiveEntry();\n \n             entry = new ZipArchiveEntry(\"bla/test4.xml\");\n-            entry.setSize(file1.length());\n+            entry.setSize(file4.length());\n             out.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file4), out);\n             out.closeArchiveEntry();\n \n             entry = new ZipArchiveEntry(\"bla/test5.xml\");\n-            entry.setSize(file1.length());\n+            entry.setSize(file4.length());\n             out.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file4), out);\n             out.closeArchiveEntry();\n \n             entry = new ZipArchiveEntry(\"bla/blubber/test6.xml\");\n-            entry.setSize(file1.length());\n+            entry.setSize(file4.length());\n             out.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file4), out);\n             out.closeArchiveEntry();\n \n             entry = new ZipArchiveEntry(\"test.txt\");\n-            entry.setSize(file1.length());\n+            entry.setSize(file5.length());\n             out.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file5), out);\n             out.closeArchiveEntry();\n \n             entry = new ZipArchiveEntry(\"something/bla\");\n-            entry.setSize(file1.length());\n+            entry.setSize(file6.length());\n             out.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file6), out);\n             out.closeArchiveEntry();\n \n             entry = new ZipArchiveEntry(\"test with spaces.txt\");\n-            entry.setSize(file1.length());\n+            entry.setSize(file6.length());\n             out.putArchiveEntry(entry);\n             IOUtils.copy(new FileInputStream(file6), out);\n             out.closeArchiveEntry();\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/compress/archivers/tar/TarArchiveEntryTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.apache.commons.compress.archivers.tar;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Locale;\n+import junit.framework.TestCase;\n+\n+public class TarArchiveEntryTest extends TestCase {\n+\n+    private static final String OS =\n+        System.getProperty(\"os.name\").toLowerCase(Locale.US);\n+    private static final String ROOT =\n+        OS.startsWith(\"windows\") || OS.startsWith(\"netware\") ? \"C:\\\\\" : \"/\";\n+\n+    /**\n+     * JIRA issue SANDBOX-284\n+     *\n+     * @see https://issues.apache.org/jira/browse/SANDBOX-284\n+     */\n+    public void testFileSystemRoot() {\n+        TarArchiveEntry t = new TarArchiveEntry(new File(ROOT));\n+        assertEquals(\"/\", t.getName());\n+    }\n+\n+    public void testTarFileWithFSRoot() throws IOException {\n+        File f = File.createTempFile(\"taetest\", \".tar\");\n+        f.deleteOnExit();\n+        TarArchiveOutputStream tout = null;\n+        TarArchiveInputStream tin = null;\n+        try {\n+            tout = new TarArchiveOutputStream(new FileOutputStream(f));\n+            TarArchiveEntry t = new TarArchiveEntry(new File(ROOT));\n+            tout.putNextEntry(t);\n+            tout.closeEntry();\n+            t = new TarArchiveEntry(new File(new File(ROOT), \"foo.txt\"));\n+            t.setSize(6);\n+            tout.putNextEntry(t);\n+            tout.write(new byte[] {'h', 'e', 'l', 'l', 'o', ' '});\n+            tout.closeEntry();\n+            t = new TarArchiveEntry(new File(new File(ROOT), \"bar.txt\")\n+                                    .getAbsolutePath());\n+            t.setSize(5);\n+            tout.putNextEntry(t);\n+            tout.write(new byte[] {'w', 'o', 'r', 'l', 'd'});\n+            tout.closeEntry();\n+            t = new TarArchiveEntry(\"dummy\");\n+            t.setName(new File(new File(ROOT), \"baz.txt\").getAbsolutePath());\n+            t.setSize(1);\n+            tout.putNextEntry(t);\n+            tout.write(new byte[] {'!'});\n+            tout.closeEntry();\n+            tout.close();\n+            tout = null;\n+\n+            tin = new TarArchiveInputStream(new FileInputStream(f));\n+            //tin.setDebug(true);\n+            t = tin.getNextTarEntry();\n+            assertNotNull(t);\n+            assertEquals(\"/\", t.getName());\n+            t = tin.getNextTarEntry();\n+            assertNotNull(t);\n+            assertEquals(\"foo.txt\", t.getName());\n+            t = tin.getNextTarEntry();\n+            assertNotNull(t);\n+            assertEquals(\"bar.txt\", t.getName());\n+            t = tin.getNextTarEntry();\n+            assertNotNull(t);\n+            assertEquals(\"baz.txt\", t.getName());\n+        } finally {\n+            if (tin != null) {\n+                tin.close();\n+            }\n+            if (tout != null) {\n+                tout.close();\n+            }\n+        }\n+    }\n+}", "timestamp": 1237553418, "metainfo": ""}