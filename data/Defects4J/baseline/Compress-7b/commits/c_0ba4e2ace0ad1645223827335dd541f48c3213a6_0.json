{"sha": "0ba4e2ace0ad1645223827335dd541f48c3213a6", "log": "merge TarArchive*Stream with Tar*Stream  ", "commit": "\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;\n-import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n-import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\n+import org.apache.commons.compress.archivers.tar.TarInputStream;\n+import org.apache.commons.compress.archivers.tar.TarOutputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;\n \n         } else if(\"zip\".equalsIgnoreCase(archiverName)) {\n             return new ZipArchiveInputStream(in);\n         } else if(\"tar\".equalsIgnoreCase(archiverName)) {\n-            return new TarArchiveInputStream(in);\n+            return new TarInputStream(in);\n         } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n             return new JarArchiveInputStream(in);\n         } else if(\"cpio\".equalsIgnoreCase(archiverName)) {\n         } else if(\"zip\".equalsIgnoreCase(archiverName)) {\n             return new ZipArchiveOutputStream(out);\n         } else if(\"tar\".equalsIgnoreCase(archiverName)) {\n-            return new TarArchiveOutputStream(out);\n+            return new TarOutputStream(out);\n         } else if(\"jar\".equalsIgnoreCase(archiverName)) {\n             return new JarArchiveOutputStream(out);\n         } else if(\"cpio\".equalsIgnoreCase(archiverName)) {\n             return new ZipArchiveInputStream(input);\n         } else if(JarArchiveInputStream.matches(signature, signatureLength)) {\n             return new JarArchiveInputStream(input);\n-        } else if(TarArchiveInputStream.matches(signature, signatureLength)) {\n-            return new TarArchiveInputStream(input);\n+        } else if(TarInputStream.matches(signature, signatureLength)) {\n+            return new TarInputStream(input);\n         } else if(ArArchiveInputStream.matches(signature, signatureLength)) {\n             return new ArArchiveInputStream(input);\n         } else if(CpioArchiveInputStream.matches(signature, signatureLength)) {\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarInputStream.java\n \n package org.apache.commons.compress.archivers.tar;\n \n-import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveInputStream;\n \n /**\n  * The TarInputStream reads a UNIX tar archive as an InputStream.\n  * using read().\n  *\n  */\n-public class TarInputStream extends FilterInputStream {\n+public class TarInputStream extends ArchiveInputStream {\n     private static final int SMALL_BUFFER_SIZE = 256;\n     private static final int BUFFER_SIZE = 8 * 1024;\n     private static final int LARGE_BUFFER_SIZE = 32 * 1024;\n \n     // CheckStyle:VisibilityModifier ON\n \n+    private final InputStream in;\n+\n     /**\n      * Constructor for TarInputStream.\n      * @param is the input stream to use\n      * @param recordSize the record size to use\n      */\n     public TarInputStream(InputStream is, int blockSize, int recordSize) {\n-        super(is);\n+        this.in = is;\n \n         this.buffer = new TarBuffer(is, blockSize, recordSize);\n         this.readBuf = null;\n     }\n \n     /**\n-     * Since we do not support marking just yet, we return false.\n-     *\n-     * @return False.\n-     */\n-    public boolean markSupported() {\n-        return false;\n-    }\n-\n-    /**\n-     * Since we do not support marking just yet, we do nothing.\n-     *\n-     * @param markLimit The limit to mark.\n-     */\n-    public void mark(int markLimit) {\n-    }\n-\n-    /**\n      * Since we do not support marking just yet, we do nothing.\n      */\n     public void reset() {\n      * @return The next TarEntry in the archive, or null.\n      * @throws IOException on error\n      */\n-    public TarArchiveEntry getNextEntry() throws IOException {\n+    public ArchiveEntry getNextEntry() throws IOException {\n         if (hasHitEOF) {\n             return null;\n         }\n             out.write(buf, 0, numRead);\n         }\n     }\n+\n+    // used to be implemented via FilterInputStream\n+    public int read(byte[] b) throws IOException {\n+        return read(b, 0, b.length);\n+    }\n+\n+    // ArchiveInputStream\n+\n+    public static boolean matches(byte[] signature, int length) {\n+        // 6574 7473 2e31 6d78\n+        \n+        if (length < 8) {\n+            return false;\n+        }\n+\n+        if (signature[0] != 0x74) {\n+            return false;\n+        }\n+        if (signature[1] != 0x65) {\n+            return false;\n+        }\n+        if (signature[2] != 0x73) {\n+            return false;\n+        }\n+        if (signature[3] != 0x74) {\n+            return false;\n+        }\n+        if (signature[4] != 0x31) {\n+            return false;\n+        }\n+        if (signature[5] != 0x2e) {\n+            return false;\n+        }\n+        if (signature[6] != 0x78) {\n+            return false;\n+        }\n+        if (signature[7] != 0x6d) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n }\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarOutputStream.java\n  */\n package org.apache.commons.compress.archivers.tar;\n \n-import java.io.FilterOutputStream;\n import java.io.IOException;\n import java.io.OutputStream;\n+import org.apache.commons.compress.archivers.ArchiveEntry;\n+import org.apache.commons.compress.archivers.ArchiveOutputStream;\n \n /**\n  * The TarOutputStream writes a UNIX tar archive as an OutputStream.\n  * by writing to this stream using write().\n  *\n  */\n-public class TarOutputStream extends FilterOutputStream {\n+public class TarOutputStream extends ArchiveOutputStream {\n     /** Fail if a long file name is required in the archive. */\n     public static final int LONGFILE_ERROR = 0;\n \n \n     private boolean closed = false;\n \n+    private final OutputStream out;\n+\n     /**\n      * Constructor for TarInputStream.\n      * @param os the output stream to use\n      * @param recordSize the record size to use\n      */\n     public TarOutputStream(OutputStream os, int blockSize, int recordSize) {\n-        super(os);\n+        out = os;\n \n         this.buffer = new TarBuffer(os, blockSize, recordSize);\n         this.debug = false;\n \n         buffer.writeRecord(recordBuf);\n     }\n+\n+    // used to be implemented via FilterOutputStream\n+    public void flush() throws IOException {\n+        out.flush();\n+    }\n+        \n+    // ArchiveOutputStream\n+\n+    public void closeArchiveEntry() throws IOException {\n+        closeEntry();\n+    }\n+\n+    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n+        putNextEntry((TarArchiveEntry) entry);\n+    }\n+\n+    public String getDefaultFileExtension() {\n+        return \"tar\";\n+    }\n+\n+    public byte[] getHeader() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    public String getName() {\n+        return \"tar\";\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n+++ b/src/test/java/org/apache/commons/compress/DetectArchiverTestCase.java\n import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\n import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\n import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\n-import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n+import org.apache.commons.compress.archivers.tar.TarInputStream;\n import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n \n public final class DetectArchiverTestCase extends TestCase {\n \t\t\t\tnew BufferedInputStream(new FileInputStream(\n \t\t\t\t\t\tnew File(getClass().getClassLoader().getResource(\"bla.tar\").getFile()))));\n \t\tassertNotNull(tar);\n-\t\tassertTrue(tar instanceof TarArchiveInputStream);\n+\t\tassertTrue(tar instanceof TarInputStream);\n \n \t\tfinal ArchiveInputStream zip = factory.createArchiveInputStream(\n \t\t\t\tnew BufferedInputStream(new FileInputStream(", "timestamp": 1234281466, "metainfo": ""}