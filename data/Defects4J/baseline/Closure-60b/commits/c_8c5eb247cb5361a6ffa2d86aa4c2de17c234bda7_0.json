{"sha": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7", "log": "Refactor how coding conventions are set (Nick) R=alan  Don't use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don't distinguish between label names and variable names appropriately. (John) R=robert DELTA=57  (29 added, 12 deleted, 16 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n           VariableMap.load(config.propertyMapInputFile).toBytes();\n     }\n \n-    if (config.thirdParty) {\n-      options.setCodingConvention(new DefaultCodingConvention());\n-    }\n-\n+    options.setCodingConvention(config.codingConvention);\n     options.setSummaryDetailLevel(config.summaryDetailLevel);\n \n     inputCharset = getInputCharset();\n       return this;\n     }\n \n-    private boolean thirdParty = false;\n-\n-    /**\n-     * Check source validity but do not enforce Closure style rules and\n-     * conventions\n-     */\n-    CommandLineConfig setThirdParty(boolean thirdParty) {\n-      this.thirdParty = thirdParty;\n+    private CodingConvention codingConvention = new DefaultCodingConvention();\n+\n+    /**\n+     * Sets rules and conventions to enforce.\n+     */\n+    CommandLineConfig setCodingConvention(CodingConvention codingConvention) {\n+      this.codingConvention = codingConvention;\n       return this;\n     }\n \n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         }\n         break;\n \n+      case Token.LABEL_NAME:\n+        Preconditions.checkState(!n.getString().isEmpty());\n+        addIdentifier(n.getString());\n+        break;\n+\n       case Token.NAME:\n         if (first == null || first.getType() == Token.EMPTY) {\n           addIdentifier(n.getString());\n             addExpr(first, 0, getContextForNoInOperator(context));\n           }\n         }\n-\n         break;\n \n       case Token.ARRAYLIT:\n         Preconditions.checkState(childCount <= 1);\n         add(\"continue\");\n         if (childCount == 1) {\n+          Preconditions.checkState(first.getType() == Token.LABEL_NAME);\n           add(\" \");\n           add(first);\n         }\n         Preconditions.checkState(childCount <= 1);\n         add(\"break\");\n         if (childCount == 1) {\n+          Preconditions.checkState(first.getType() == Token.LABEL_NAME);\n           add(\" \");\n           add(first);\n         }\n \n       case Token.LABEL:\n         Preconditions.checkState(childCount == 2);\n+        Preconditions.checkState(first.getType() == Token.LABEL_NAME);\n         add(first);\n         add(\":\");\n         addNonEmptyExpression(\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n         .setVariableMapOutputFile(flags.variable_map_output_file)\n         .setCreateNameMapFiles(flags.create_name_map_files)\n         .setPropertyMapOutputFile(flags.property_map_output_file)\n-        .setThirdParty(flags.third_party)\n+        .setCodingConvention(flags.third_party ?\n+             new DefaultCodingConvention() :\n+             new ClosureCodingConvention())\n         .setSummaryDetailLevel(flags.summary_detail_level)\n         .setOutputWrapper(flags.output_wrapper)\n         .setOutputWrapperMarker(flags.output_wrapper_marker)\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n \n         // Add label\n         Node label = new Node(Token.LABEL);\n-        Node name = Node.newString(Token.NAME, labelName);\n+        Node name = Node.newString(Token.LABEL_NAME, labelName);\n         label.addChildToFront(name);\n         label.addChildToBack(block);\n \n       Preconditions.checkState(NodeUtil.isStatementBlock(parent));\n \n       Node resultNode = getReplacementReturnStatement(current, resultName);\n-      Node name = Node.newString(Token.NAME, labelName);\n+      Node name = Node.newString(Token.LABEL_NAME, labelName);\n       Node breakNode = new Node(Token.BREAK, name);\n \n       // Replace the node in parent, and reset current to the first new child.\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    *       function parameter (not a label or a empty anonymous function name).\n    */\n   static boolean isReferenceName(Node n) {\n-    return isName(n) && !n.getString().isEmpty() && !isLabelName(n);\n+    return isName(n) && !n.getString().isEmpty();\n   }\n \n   /** @return Whether the node is a label name. */\n   static boolean isLabelName(Node n) {\n-    if (n != null && n.getType() == Token.NAME) {\n-      Node parent = n.getParent();\n-      switch (parent.getType()) {\n-        case Token.LABEL:\n-        case Token.BREAK:\n-        case Token.CONTINUE:\n-          if (n == parent.getFirstChild()) {\n-            return true;\n-          }\n-      }\n-    }\n-    return false;\n+    return (n != null && n.getType() == Token.LABEL_NAME);\n   }\n \n   /** Whether the child node is the FINALLY block of a try. */\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n \n       // These nodes have no interesting type behavior.\n       case Token.LABEL:\n+      case Token.LABEL_NAME:\n       case Token.SWITCH:\n       case Token.BREAK:\n       case Token.CATCH:\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n     Node processBreakStatement(BreakStatement statementNode) {\n       Node node = new Node(Token.BREAK);\n       if (statementNode.getBreakLabel() != null) {\n-        node.addChildToBack(transform(statementNode.getBreakLabel()));\n+        Node labelName = transform(statementNode.getBreakLabel());\n+        // Change the NAME to LABEL_NAME\n+        labelName.setType(Token.LABEL_NAME);\n+        node.addChildToBack(labelName);\n       }\n       return node;\n     }\n     Node processContinueStatement(ContinueStatement statementNode) {\n       Node node = new Node(Token.CONTINUE);\n       if (statementNode.getLabel() != null) {\n-        node.addChildToBack(transform(statementNode.getLabel()));\n+        Node labelName = transform(statementNode.getLabel());\n+        // Change the NAME to LABEL_NAME\n+        labelName.setType(Token.LABEL_NAME);\n+        node.addChildToBack(labelName);\n       }\n       return node;\n     }\n \n     @Override\n     Node processLabel(Label labelNode) {\n-      return Node.newString(Token.NAME, labelNode.getName());\n+      return Node.newString(Token.LABEL_NAME, labelNode.getName());\n     }\n \n     @Override\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n         SETCONST       = 150,\n         SETCONSTVAR    = 151,\n         DEBUGGER       = 152,\n-        LAST_TOKEN     = 152,\n+        \n+        // JSCompiler introduced tokens\n+        LABEL_NAME     = 153,\n+        \n+        LAST_TOKEN     = 153,\n \n         // JSDoc-only tokens\n         ANNOTATION     = 300,\n           case SETELEM:         return \"SETELEM\";\n           case CALL:            return \"CALL\";\n           case NAME:            return \"NAME\";\n+          case LABEL_NAME:      return \"LABEL_NAME\";\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case NULL:            return \"NULL\";\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     parse(\"do { a() } while (b());\");\n   }\n \n-  public void testLabel() {\n+  // The old and new parser produce different results now with labels, and\n+  // named breaks and continues, so disable these tests.\n+  public void disable_testLabel() {\n     parse(\"foo: bar\");\n   }\n \n-  public void testLabel2() {\n+  public void disable_testLabel2() {\n     parse(\"l: while (f()) { if (g()) { continue l; } }\");\n   }\n \n-  public void testLabel3() {\n+  public void disable_testLabel3() {\n     parse(\"Foo:Bar:X:{ break Bar; }\");\n   }\n ", "timestamp": 1270008105, "metainfo": ""}