{"sha": "c764a46abf211d4677fadc33f7d466e5b14fa088", "log": "Change on 2010/04/13 by john          Here is a crazy thought, let's not require the JSTypeRegistry during         parsing.          There are basically two changes here:         1) The IRFactory was looking for enums to seed the JSTypeRegistry, so         we do that when we setup for type interence.         2) The JSDocParser was checking the types of @defines objects, now do         that during ProcessDefines.          R=robert,mark         DELTA=207  (82 added, 89 deleted, 36 changed)  Change on 2010/04/14 by nick          Add a debugging function for JSType hashcodes.         i found this useful, and thought others might too.          R=john         DELTA=69  (69 added, 0 deleted, 0 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=fqsoxx   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n    */\n   FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n     returnType = info != null && info.hasReturnType() ?\n-        info.getReturnType().evaluate(scope) :\n+        info.getReturnType().evaluate(scope, typeRegistry) :\n         typeRegistry.getNativeType(UNKNOWN_TYPE);\n     if (templateTypeName != null &&\n         returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n       // base type\n       if (info.hasBaseType()) {\n         if (isConstructor || isInterface) {\n-          baseType = ObjectType.cast(info.getBaseType().evaluate(scope));\n+          baseType = ObjectType.cast(info.getBaseType().evaluate(scope, typeRegistry));\n           if (baseType == null) {\n             reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString());\n           }\n       if (isConstructor || isInterface) {\n         implementedInterfaces = Lists.newArrayList();\n         for (JSTypeExpression t : info.getImplementedInterfaces()) {\n-          ObjectType interType = ObjectType.cast(t.evaluate(scope));\n+          ObjectType interType = ObjectType.cast(t.evaluate(scope, typeRegistry));\n           if (interType != null) {\n             implementedInterfaces.add(interType);\n           } else {\n       @Nullable Node owner) {\n     ObjectType maybeThisType = null;\n     if (info != null && info.hasThisType()) {\n-      maybeThisType = ObjectType.cast(info.getThisType().evaluate(scope));\n+      maybeThisType = ObjectType.cast(\n+          info.getThisType().evaluate(scope, typeRegistry));\n     }\n     if (maybeThisType != null) {\n       // TODO(user): Doing an instanceof check here is too\n       // type from JSDocInfo\n       JSType parameterType =\n           info != null && info.hasParameterType(argumentName) ?\n-          info.getParameterType(argumentName).evaluate(scope) :\n+          info.getParameterType(argumentName).evaluate(scope, typeRegistry) :\n           typeRegistry.getNativeType(UNKNOWN_TYPE);\n       if (templateTypeName != null &&\n           parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n import com.google.javascript.jscomp.GlobalNamespace.Ref;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n \n import java.text.MessageFormat;\n import java.util.ArrayDeque;\n       \"unknown @define variable {0}\");\n \n   // Errors\n+  static final DiagnosticType INVALID_DEFINE_TYPE_ERROR =\n+    DiagnosticType.error(\n+        \"JSC_INVALID_DEFINE_INIT_ERROR\",\n+        \"@define tag only permits literal types\");\n+\n   static final DiagnosticType INVALID_DEFINE_INIT_ERROR =\n       DiagnosticType.error(\n           \"JSC_INVALID_DEFINE_INIT_ERROR\",\n   }\n \n   /**\n+   * Only defines of literal number, string, or boolean are supported.\n+   */\n+  private boolean isValidDefineType(JSTypeExpression expression) {\n+    JSType type = expression.evaluate(null, compiler.getTypeRegistry());\n+    return !type.isUnknownType() && type.isSubtype(\n+        compiler.getTypeRegistry().getNativeType(\n+            JSTypeNative.NUMBER_STRING_BOOLEAN));\n+  }\n+\n+  /**\n    * Finds all defines, and creates a {@link DefineInfo} data structure for\n    * each one.\n    * @return A map of {@link DefineInfo} structures, keyed by name.\n     List<Name> allDefines = Lists.newArrayList();\n     for (Name name : namespace.getNameIndex().values()) {\n       if (name.docInfo != null && name.docInfo.isDefine()) {\n-        allDefines.add(name);\n+        // Process defines should not depend on check types being enabled,\n+        // so we look for the JSDoc instead of the inferred type.\n+        if (isValidDefineType(name.docInfo.getType())) {\n+          allDefines.add(name);\n+        } else {\n+          JSError error = JSError.make(\n+              name.declaration.sourceName,\n+              name.declaration.node,\n+              INVALID_DEFINE_TYPE_ERROR);\n+          compiler.report(error);\n+        }\n       } else if (name.refs != null) {\n         for (Ref ref : name.refs) {\n           Node n = ref.node;\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       // /** @type ... */object.name = ...;\n       if (info != null && info.hasType()) {\n         visitAnnotatedAssignGetprop(t, assign,\n-            info.getType().evaluate(t.getScope()), object,\n+            info.getType().evaluate(t.getScope(), typeRegistry), object,\n             property, rvalue);\n         return;\n       }\n       // /** @enum ... */object.name = ...;\n       if (info != null && info.hasEnumParameterType()) {\n         checkEnumInitializer(\n-            t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n+            t, rvalue, info.getEnumParameterType().evaluate(\n+                t.getScope(), typeRegistry));\n         return;\n       }\n \n           // var.getType() can never be null, this would indicate a bug in the\n           // scope creation logic.\n           checkEnumInitializer(\n-              t, value,  info.getEnumParameterType().evaluate(t.getScope()));\n+              t, value,\n+              info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n         } else if (var.isTypeInferred()) {\n           ensureTyped(t, name, valueType);\n         } else {\n     JSDocInfo info = n.getJSDocInfo();\n     if (info != null) {\n       if (info.hasType()) {\n-        JSType infoType = info.getType().evaluate(t.getScope());\n+        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n         validator.expectCanCast(t, n, infoType, type);\n         type = infoType;\n       }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     if (n.getType() != Token.FUNCTION) {\n       JSDocInfo info = n.getJSDocInfo();\n       if (info != null && info.hasType()) {\n-        JSType castType = info.getType().evaluate(syntacticScope);\n+        JSType castType = info.getType().evaluate(syntacticScope, registry);\n \n         // A stubbed type cast on a qualified name should take\n         // effect for all subsequent accesses of that name,\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n    */\n   @VisibleForTesting\n   Scope createInitialScope(Node root) {\n+\n+    NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry));\n+\n     Scope s = new Scope(root, compiler);\n     declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n     declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n     scope.declare(name, null, t, null, false);\n   }\n \n+  private static class DiscoverEnums extends AbstractShallowCallback {\n+    private final JSTypeRegistry registry;\n+\n+    DiscoverEnums(JSTypeRegistry registry) {\n+      this.registry = registry;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node node, Node parent) {\n+      Node nameNode = null;\n+      switch (node.getType()) {\n+        case Token.NAME:\n+          nameNode = node;\n+          break;\n+        case Token.VAR:\n+          if (node.hasOneChild()) {\n+            nameNode = node.getFirstChild();\n+          }\n+          break;\n+        case Token.ASSIGN:\n+          nameNode = node.getFirstChild();\n+          break;\n+      }\n+\n+      if (nameNode != null) {\n+        JSDocInfo info = node.getJSDocInfo();\n+        if (info != null && info.hasEnumParameterType()) {\n+          registry.identifyEnumName(nameNode.getQualifiedName());\n+        }\n+      }\n+    }\n+  }\n+\n   /**\n    * Given a node, determines whether that node names a prototype\n    * property, and if so, returns the qualfied name node representing\n           node.getFirstChild() : null;\n       if (info != null) {\n         if (info.hasType()) {\n-          jsType = info.getType().evaluate(scope);\n+          jsType = info.getType().evaluate(scope, typeRegistry);\n         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n           String fnName = node.getQualifiedName();\n \n           } else if (info != null && info.hasEnumParameterType()) {\n             lvalue.setJSType(\n                 getEnumType(lvalue.getQualifiedName(), n, rvalue,\n-                    info.getEnumParameterType().evaluate(scope)));\n+                    info.getEnumParameterType().evaluate(scope, typeRegistry)));\n           }\n           break;\n \n               typeRegistry.getNativeType(UNKNOWN_TYPE) : null;\n         } else if (info.hasEnumParameterType()) {\n           type = getEnumType(name.getString(), var, value,\n-              info.getEnumParameterType().evaluate(scope));\n+              info.getEnumParameterType().evaluate(scope, typeRegistry));\n         } else if (info.isConstructor()) {\n           type = getFunctionType(name.getString(), value, info, name);\n         } else {\n           rValue.getFirstChild().getNext() : null;\n \n       if (functionType == null && info != null && info.hasType()) {\n-        JSType type = info.getType().evaluate(scope);\n+        JSType type = info.getType().evaluate(scope, typeRegistry);\n \n         // Known to be not null since we have the FUNCTION token there.\n         type = type.restrictByNotNullOrUndefined();\n       // to handle these properly.\n       typeRegistry.forwardDeclareType(typedef);\n \n-      JSType realType = info.getTypedefType().evaluate(scope);\n+      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n       if (realType == null) {\n         compiler.report(\n             JSError.make(\n         JSDocInfo info = candidate.getJSDocInfo();\n         JSType realType = null;\n         if (info != null && info.getType() != null) {\n-          realType = info.getType().evaluate(scope);\n+          realType = info.getType().evaluate(scope, typeRegistry);\n         }\n \n         if (realType == null) {\n--- a/src/com/google/javascript/jscomp/parsing/Config.java\n+++ b/src/com/google/javascript/jscomp/parsing/Config.java\n package com.google.javascript.jscomp.parsing;\n \n import com.google.common.collect.ImmutableMap;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import java.util.Map;\n import java.util.Set;\n  * @author nicksantos@google.com (Nick Santos)\n  */\n public class Config {\n-\n-  /**\n-   * Central registry for type info.\n-   */\n-  final JSTypeRegistry registry;\n \n   /**\n    * Whether to parse the descriptions of jsdoc comments.\n    * Annotation names.\n    */\n \n-  Config(JSTypeRegistry registry, Set<String> annotationWhitelist,\n-      boolean isIdeMode) {\n-    this.registry = registry;\n+  Config(Set<String> annotationWhitelist, boolean isIdeMode) {\n     this.annotationNames = buildAnnotationNames(annotationWhitelist);\n     this.parseJsDocDocumentation = isIdeMode;\n     this.isIdeMode = isIdeMode;\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.ScriptOrFnNode;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import java.util.Collection;\n import java.util.Iterator;\n   private final String sourceString;\n   private final String sourceName;\n   private final Config config;\n-  private final JSTypeRegistry registry;\n   private final ErrorReporter errorReporter;\n   private final TransformDispatcher transformDispatcher;\n \n                     ErrorReporter errorReporter) {\n     this.sourceString = sourceString;\n     this.sourceName = sourceName;\n-    this.registry = config.registry;\n     this.config = config;\n     this.errorReporter = errorReporter;\n     this.transformDispatcher = new TransformDispatcher();\n     Node node = candidateIter.next().node;\n     candidateIter.remove();\n     node.setJSDocInfo(info);\n-    if (info.hasEnumParameterType()) {\n-      if (node.getType() == Token.NAME) {\n-        registry.identifyEnumName(node.getString());\n-      } else if (node.getType() == Token.VAR &&\n-            node.getChildCount() == 1) {\n-        registry.identifyEnumName(\n-            node.getFirstChild().getString());\n-      } else if (node.getType() == Token.ASSIGN) {\n-        registry.identifyEnumName(\n-            node.getFirstChild().getQualifiedName());\n-      }\n-    }\n   }\n \n   private int position2charno(int position) {\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n import com.google.javascript.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n-import com.google.javascript.rhino.jstype.JSType;\n-import com.google.javascript.rhino.jstype.JSTypeNative;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import java.util.HashSet;\n import java.util.Map;\n public final class JsDocInfoParser {\n \n   private final JsDocTokenStream stream;\n-  private final JSTypeRegistry typeRegistry;\n   private final JSDocInfoBuilder jsdocBuilder;\n   private final String sourceName;\n   private final ErrorReporter errorReporter;\n                   ErrorReporter errorReporter) {\n     this.stream = stream;\n     this.sourceName = sourceName;\n-    this.typeRegistry = config.registry;\n     this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n     this.annotationNames = config.annotationNames;\n \n    */\n   public static Node parseTypeString(String typeString) {\n     Config config = new Config(\n-        new JSTypeRegistry(NullErrorReporter.forOldRhino()),\n         Sets.<String>newHashSet(),\n         false);\n     JsDocInfoParser parser = new JsDocInfoParser(\n                   } else {\n                     switch (annotation) {\n                       case DEFINE:\n-                        if (!isValidDefineType(typeNode)) {\n-                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n-                              lineno, charno);\n-                        } else if (!jsdocBuilder.recordDefineType(type)) {\n+                        if (!jsdocBuilder.recordDefineType(type)) {\n                           parser.addWarning(\"msg.jsdoc.define\",\n                               lineno, charno);\n                         }\n   }\n \n   /**\n-   * Determines whether the given type is a valid {@code @define} type.\n-   */\n-  // TODO(nicksantos): Move this into a check pass.\n-  private boolean isValidDefineType(Node typeNode) {\n-    JSType type = typeRegistry.createFromTypeNodes(typeNode, \"\", null);\n-    return !type.isUnknownType() && type.isSubtype(\n-        typeRegistry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN));\n-  }\n-\n-  /**\n    * Converts a JSDoc token to its string representation.\n    */\n   private String toString(JsDocToken token) {\n    */\n   private JSTypeExpression createJSTypeExpression(Node n) {\n     return n == null ? null :\n-        new JSTypeExpression(n, sourceName, typeRegistry);\n+        new JSTypeExpression(n, sourceName);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n+++ b/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n \n   public static Config createConfig(\n       JSTypeRegistry typeRegistry, boolean isIdeMode) {\n-    return new Config(\n-        typeRegistry, getAnnotationNames(), isIdeMode);\n+    return new Config(getAnnotationNames(), isIdeMode);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n-import com.google.javascript.rhino.jstype.JSType;\n-import com.google.javascript.rhino.jstype.StaticScope;\n \n import java.io.Serializable;\n import java.util.Collection;\n   }\n \n   /**\n-   * Returns the description for the given thrown type, if it\n-   * exists.\n-   */\n-  public String getDescriptionForThrownType(JSType type,\n-      StaticScope<JSType> scope) {\n-    if (documentation == null || documentation.throwsDescriptions == null) {\n-      return null;\n-    }\n-\n-    for (JSTypeExpression typeExpr :\n-             documentation.throwsDescriptions.keySet()) {\n-      if (type.canAssignTo(typeExpr.evaluate(scope))) {\n-        return documentation.throwsDescriptions.get(typeExpr);\n-      }\n-    }\n-\n-    return null;\n-  }\n-\n-  /**\n    * Returns the list of authors or null if none.\n    */\n   public Collection<String> getAuthors() {\n--- a/src/com/google/javascript/rhino/JSTypeExpression.java\n+++ b/src/com/google/javascript/rhino/JSTypeExpression.java\n   /** The source name where the type expression appears. */\n   private final String sourceName;\n \n-  /** The type registry to use for resolution. */\n-  private final JSTypeRegistry registry;\n-\n-  public JSTypeExpression(Node root, String sourceName,\n-      JSTypeRegistry registry) {\n+  public JSTypeExpression(Node root, String sourceName) {\n     this.root = root;\n     this.sourceName = sourceName;\n-    this.registry = registry;\n   }\n \n   /**\n       return expr;\n     } else {\n       return new JSTypeExpression(\n-          new Node(Token.EQUALS, expr.root), expr.sourceName, expr.registry);\n+          new Node(Token.EQUALS, expr.root), expr.sourceName);\n     }\n   }\n \n   /**\n    * Evaluates the type expression into a {@code JSType} object.\n    */\n-  public JSType evaluate(StaticScope<JSType> scope) {\n+  public JSType evaluate(StaticScope<JSType> scope, JSTypeRegistry registry) {\n     JSType type = registry.createFromTypeNodes(root, sourceName, scope);\n     if (root.getBooleanProp(Node.BRACELESS_TYPE)) {\n       type.forgiveUnknownNames();\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n \n     return super.resolveInternal(t, scope);\n   }\n+\n+  @Override\n+  public String toDebugHashCodeString() {\n+    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n+      return super.toDebugHashCodeString();\n+    }\n+\n+    StringBuilder b = new StringBuilder(32);\n+    b.append(\"function (\");\n+    int paramNum = (call == null || call.parameters == null) ?\n+        0 : call.parameters.getChildCount();\n+    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();\n+    if (hasKnownTypeOfThis) {\n+      b.append(\"this:\");\n+      b.append(getDebugHashCodeStringOf(typeOfThis));\n+    }\n+    if (paramNum > 0) {\n+      if (hasKnownTypeOfThis) {\n+        b.append(\", \");\n+      }\n+      Node p = call.parameters.getFirstChild();\n+      b.append(getDebugHashCodeStringOf(p.getJSType()));\n+      p = p.getNext();\n+      while (p != null) {\n+        b.append(\", \");\n+        b.append(getDebugHashCodeStringOf(p.getJSType()));\n+        p = p.getNext();\n+      }\n+    }\n+    b.append(\")\");\n+    if (call != null && call.returnType != null) {\n+      b.append(\": \");\n+      b.append(getDebugHashCodeStringOf(call.returnType));\n+    }\n+    return b.toString();\n+  }\n+\n+  private String getDebugHashCodeStringOf(JSType type) {\n+    if (type == this) {\n+      return \"me\";\n+    } else {\n+      return type.toDebugHashCodeString();\n+    }\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n-import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n       this.typeB = typeB;\n     }\n   }\n+\n+  /**\n+   * A hash code function for diagnosing complicated issues\n+   * around type-identity.\n+   */\n+  public String toDebugHashCodeString() {\n+    return \"{\" + this.hashCode() + \"}\";\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n     referencedType = (ObjectType) referencedType.resolve(t, scope);\n     return this;\n   }\n+\n+  @Override\n+  public String toDebugHashCodeString() {\n+    return \"{proxy:\" + referencedType.toDebugHashCodeString() + \"}\";\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n import com.google.javascript.rhino.ErrorReporter;\n \n+import java.util.List;\n import java.util.Set;\n import java.util.SortedSet;\n import java.util.TreeSet;\n     }\n     return this;\n   }\n+\n+  @Override\n+  public String toDebugHashCodeString() {\n+    List<String> hashCodes = Lists.newArrayList();\n+    for (JSType a : alternates) {\n+      hashCodes.add(a.toDebugHashCodeString());\n+    }\n+    return \"{(\" + Joiner.on(\",\").join(hashCodes) + \")}\";\n+  }\n }\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n    * correct {@code JSType}.\n    */\n   protected void assertTypeEquals(JSType expected, Node actual) {\n-    assertTypeEquals(expected, new JSTypeExpression(actual, \"\", registry));\n+    assertTypeEquals(expected, new JSTypeExpression(actual, \"\"));\n   }\n \n   /**\n    */\n   protected JSType resolve(JSTypeExpression n, String... warnings) {\n     errorReporter.setWarnings(warnings);\n-    return n.evaluate(null);\n+    return n.evaluate(null, registry);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n   public void testInitialTypingScope() {\n     Scope s = new TypedScopeCreator(compiler,\n-        new DefaultCodingConvention()).createInitialScope(null);\n+        new DefaultCodingConvention()).createInitialScope(\n+            new Node(Token.BLOCK));\n \n     assertEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());\n     assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n--- a/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n     test(definitions + js, definitions + expected);\n   }\n \n-  public void testBasicDefine() {\n+  public void testBasicDefine1() {\n     test(\"/** @define {boolean} */ var DEF = true\", \"var DEF=true\");\n+  }\n+\n+  public void testBasicDefine2() {\n+    test(\"/** @define {string} */ var DEF = 'a'\", \"var DEF=\\\"a\\\"\");\n+  }\n+\n+  public void testBasicDefine3() {\n+    test(\"/** @define {number} */ var DEF = 0\", \"var DEF=0\");\n+  }\n+\n+  public void testDefineBadType() {\n+    test(\"/** @define {Object} */ var DEF = {}\",\n+        null, ProcessDefines.INVALID_DEFINE_TYPE_ERROR);\n   }\n \n   public void testDefineWithBadValue() {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n public class TypeCheckTest extends CompilerTypeTestCase {\n   public void testInitialTypingScope() {\n     Scope s = new TypedScopeCreator(compiler,\n-        new DefaultCodingConvention()).createInitialScope(null);\n+        new DefaultCodingConvention()).createInitialScope(\n+            new Node(Token.BLOCK));\n \n     assertEquals(ARRAY_FUNCTION_TYPE, s.getVar(\"Array\").getType());\n     assertEquals(BOOLEAN_OBJECT_FUNCTION_TYPE,\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     Parser p = new Parser(environment);\n     AstRoot script = p.parse(string, null, 0);\n \n-    Config config = new Config(\n-        registry, ParserRunner.getAnnotationNames(), true);\n+    Config config = new Config(ParserRunner.getAnnotationNames(), true);\n     Node root = IRFactory.transformTree(script, string, config,\n         new TestErrorReporter(null, null));\n \n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n     parse(\"@return {string}\\n @define {string} */\", \"conflicting @define tag\");\n   }\n \n-  public void testParseDefineErrors6() throws Exception {\n-    parse(\"@define {String}*/\", \"@define tag only permits literal types\");\n-  }\n-\n   public void testParseDefineErrors7() throws Exception {\n     parse(\"@define {string}\\n @const */\", \"conflicting @const tag\");\n   }\n     JSDocInfo jsdoc = parse(\"@constructor\\n@interface*/\",\n         \"cannot be both an interface and a constructor\");\n     assertTrue(jsdoc.isConstructor());\n-  }\n-\n-  public void testDocumentationThrows() throws Exception {\n-    JSDocInfo jsdoc\n-        = parse(\"@throws {number} This is a description.*/\", true);\n-\n-    assertEquals(\"This is a description.\",\n-                 jsdoc.getDescriptionForThrownType(NUMBER_TYPE, null));\n   }\n \n   public void testDocumentationParameter() throws Exception {\n     Parser p = new Parser(environment, testErrorReporter);\n     AstRoot script = p.parse(code, null, 0);\n \n-    Config config = new Config(registry, extraAnnotations, true);\n+    Config config = new Config(extraAnnotations, true);\n     for (Comment comment : script.getComments()) {\n       JsDocInfoParser jsdocParser =\n         new JsDocInfoParser(\n       boolean parseFileOverview, String... warnings) {\n     TestErrorReporter errorReporter = new TestErrorReporter(null, warnings);\n \n-    Config config = new Config(\n-        registry, extraAnnotations, parseDocumentation);\n+    Config config = new Config(extraAnnotations, parseDocumentation);\n     JsDocInfoParser jsdocParser = new JsDocInfoParser(stream(comment),\n         \"testcode\", config, errorReporter);\n \n--- a/test/com/google/javascript/rhino/JSDocInfoTest.java\n+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java\n     JSDocInfo info = new JSDocInfo();\n     info.setBaseType(\n         new JSTypeExpression(\n-            new Node(Token.BANG, Node.newString(\"Number\")), \"\", registry));\n+            new Node(Token.BANG, Node.newString(\"Number\")), \"\"));\n     info.setReturnType(fromString(\"string\"));\n \n     assertEquals(getNativeType(NUMBER_OBJECT_TYPE),\n \n   /** Gets the type expression for a simple type name. */\n   private JSTypeExpression fromString(String s) {\n-    return new JSTypeExpression(Node.newString(s), \"\", registry);\n+    return new JSTypeExpression(Node.newString(s), \"\");\n   }\n \n   private JSType resolve(JSTypeExpression n, String... warnings) {\n     errorReporter.setWarnings(warnings);\n-    return n.evaluate(null);\n+    return n.evaluate(null, registry);\n   }\n }", "timestamp": 1271261745, "metainfo": ""}