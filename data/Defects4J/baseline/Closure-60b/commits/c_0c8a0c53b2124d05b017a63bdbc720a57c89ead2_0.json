{"sha": "0c8a0c53b2124d05b017a63bdbc720a57c89ead2", "log": "Change on 2010/07/08 09:27:35 by nicksantos  \tget rid of spurious inGlobalScope check.  \tR=acleung \tDELTA=2  (0 added, 1 deleted, 1 changed)  Change on 2010/07/08 13:22:45 by dcc  \tReplace direct references to stripped types with 'void 0'.  \tR=nicksantos \tDELTA=107  (100 added, 0 deleted, 7 changed)  Change on 2010/07/08 13:28:47 by nicksantos  \tReplicate blaze's manifest file for modules.  \tR=jschorr \tDELTA=121  (105 added, 1 deleted, 15 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=48004   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n       return;\n     }\n \n+    JSModuleGraph graph = compiler.getModuleGraph();\n     if (shouldGenerateManifestPerModule()) {\n       // Generate per-module manifests.\n-      Iterable<JSModule> modules = compiler.getModuleGraph().getAllModules();\n+      Iterable<JSModule> modules = graph.getAllModules();\n       for (JSModule module : modules) {\n-        printManifestTo(module.getInputs(), expandManifest(module));\n+        PrintStream out = toPrintStream(expandManifest(module));\n+        printManifestTo(module.getInputs(), out);\n+        out.close();\n       }\n     } else {\n       // Generate a single file manifest.\n-      printManifestTo(compiler.getInputsInOrder(), expandManifest(null));\n+      PrintStream out = toPrintStream(expandManifest(null));\n+      if (graph == null) {\n+        printManifestTo(compiler.getInputsInOrder(), out);\n+      } else {\n+        printModuleGraphManifestTo(graph, out);\n+      }\n+      out.close();\n+    }\n+  }\n+\n+  /**\n+   * Prints a set of modules to the manifest file.\n+   */\n+  @VisibleForTesting\n+  void printModuleGraphManifestTo(\n+      JSModuleGraph graph, Appendable out) throws IOException {\n+    Joiner commas = Joiner.on(\",\");\n+    boolean requiresNewline = false;\n+    for (JSModule module : graph.getAllModulesInDependencyOrder()) {\n+      if (requiresNewline) {\n+        out.append(\"\\n\");\n+      }\n+\n+      // See CommandLineRunnerTest to see what the format of this\n+      // manifest looks like.\n+      String dependencies = commas.join(module.getSortedDependencyNames());\n+      out.append(\n+          String.format(\"{%s%s}\\n\",\n+              module.getName(),\n+              dependencies.isEmpty() ? \"\" : \":\" + dependencies));\n+      printManifestTo(module.getInputs(), out);\n+      requiresNewline = true;\n     }\n   }\n \n   /**\n    * Prints a list of input names, delimited by newlines, to the manifest file.\n    */\n-  private void printManifestTo(Iterable<CompilerInput> inputs, String path)\n+  private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out)\n       throws IOException {\n     List<String> names = Lists.newArrayList();\n     for (CompilerInput input : inputs) {\n       names.add(input.getName());\n     }\n     String result = Joiner.on(\"\\n\").join(names);\n-    PrintStream out = toPrintStream(path);\n     out.append(result);\n-    out.close();\n+    out.append(\"\\n\");\n   }\n \n   private class RunTimeStats {\n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n       NodeTraversal.AbstractPostOrderCallback {\n \n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (parent != null && parent.getType() == Token.SCRIPT\n-          && t.inGlobalScope()) {\n+      if (parent != null && parent.getType() == Token.SCRIPT) {\n         if (NodeUtil.isFunctionDeclaration(n)) {\n           // Check for a test function statement.\n           String functionName = NodeUtil.getFunctionName(n);\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n    */\n   public List<JSModule> getDependencies() {\n     return deps;\n+  }\n+\n+  /**\n+   * Gets the names of the modules that this module depends on,\n+   * sorted alphabetically.\n+   */\n+  List<String> getSortedDependencyNames() {\n+    List<String> names = Lists.newArrayList();\n+    for (JSModule module : getDependencies()) {\n+      names.add(module.getName());\n+    }\n+    Collections.sort(names);\n+    return names;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n   }\n \n   /**\n-   * Gets all the modules in dependency order.\n-   */\n-  private Iterable<JSModule> getAllModulesInDependencyOrder() {\n+   * Gets all the modules in dependency order. Modules with the same depth\n+   * will be ordered deterministically.\n+   */\n+  Iterable<JSModule> getAllModulesInDependencyOrder() {\n     List<JSModule> modules = Lists.newArrayList(getAllModules());\n     Collections.sort(modules, new DepthComparator());\n     return modules;\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n       \"JSC_STRIP_TYPE_INHERIT_ERROR\",\n       \"Non-strip type {0} cannot inherit from strip type {1}\");\n \n+  static final DiagnosticType STRIP_ASSIGNMENT_ERROR = DiagnosticType.error(\n+      \"JSC_STRIP_ASSIGNMENT_ERROR\",\n+      \"Unable to strip assignment to {0}\");\n   /**\n    * Creates an instance.\n    *\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n+      // Any additional types added to this switch statement should\n+      // also be added to the guard in\n+      // maybeReplaceDirectReferenceToStrippedType() to prevent\n+      // interference.\n+\n       switch (n.getType()) {\n         case Token.VAR:\n           removeVarDeclarationsByNameOrRvalue(t, n, parent);\n           break;\n \n         case Token.NAME:\n-          maybeRemoveReferenceToRemovedVariable(t, n, parent);\n+          if (qualifiedNameBeginsWithStripType(n)) {\n+            maybeReplaceDirectReferenceToStrippedType(t, n);\n+          } else {\n+            maybeRemoveReferenceToRemovedVariable(t, n, parent);\n+          }\n+          break;\n+\n+        case Token.GETPROP:\n+          maybeReplaceDirectReferenceToStrippedType(t, n);\n           break;\n \n         case Token.ASSIGN:\n       Node lvalue = n.getFirstChild();\n       if (nameEndsWithFieldNameToStrip(lvalue) ||\n           qualifiedNameBeginsWithStripType(lvalue)) {\n+\n+        // Limit to EXPR_RESULT because it is not\n+        // safe to eliminate assignment in complex expressions,\n+        // e.g. in ((x = 7) + 8)\n         if (NodeUtil.isExpressionNode(parent)) {\n           Node gramps = parent.getParent();\n           replaceWithEmpty(parent, gramps);\n-        } else {\n-          replaceWithEmpty(n, parent);\n-        }\n-        compiler.reportCodeChange();\n+          compiler.reportCodeChange();\n+        }  else {\n+          t.report(n, STRIP_ASSIGNMENT_ERROR, lvalue.getQualifiedName());\n+        }\n       }\n     }\n \n           ancestor = ancestor.getParent();\n         }\n         compiler.reportCodeChange();\n+      }\n+    }\n+\n+    /**\n+     * Replaces a reference to a stripped type with 'void 0' when it is safe\n+     * to do so. In particular, we want to avoid stepping on the toes of other\n+     * StripCode methods.\n+     *\n+     * @param t The traversal\n+     * @param n A GETPROP node or NAME node\n+     */\n+    void maybeReplaceDirectReferenceToStrippedType(NodeTraversal t, Node n) {\n+      if (stripTypes.contains(n.getQualifiedName())) {\n+        Node parent = n.getParent();\n+\n+        // Other methods already handle these cases\n+        // and we don't want to interfere with them.\n+        // This guard may need to be updated if additional\n+        // functionality is added to StripCode.\n+        if (NodeUtil.isGet(parent)\n+            || NodeUtil.isCall(parent)\n+            || NodeUtil.isNew(parent)\n+            || NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\n+          return;\n+        }\n+\n+        int parentType = parent.getType();\n+\n+        // Report error if stripping type would result in (void 0)++.\n+        if (parentType == Token.INC || parentType == Token.DEC) {\n+          t.report(n, STRIP_ASSIGNMENT_ERROR, n.getQualifiedName());\n+          return;\n+        }\n+\n+        n.getParent().replaceChild(n, NodeUtil.newUndefinedNode(n));\n+        t.getCompiler().reportCodeChange();\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   // If set to true, uses comparison by string instead of by AST.\n   private boolean useStringComparison = false;\n \n-  private boolean useModules = false;\n+  private ModulePattern useModules = ModulePattern.NONE;\n+\n+  private enum ModulePattern {\n+    NONE,\n+    CHAIN,\n+    STAR\n+  }\n \n   private List<String> args = Lists.newArrayList();\n \n     super.setUp();\n     lastCompiler = null;\n     useStringComparison = false;\n-    useModules = false;\n+    useModules = ModulePattern.NONE;\n     args.clear();\n   }\n \n   }\n \n   public void testSourceMapExpansion2() {\n-    useModules = true;\n+    useModules = ModulePattern.CHAIN;\n     args.add(\"--create_source_map=%outname%.map\");\n     args.add(\"--module_output_path_prefix=foo\");\n     testSame(new String[] {\"var x = 3;\", \"var y = 5;\"});\n   }\n \n   public void testSourceMapExpansion3() {\n-    useModules = true;\n+    useModules = ModulePattern.CHAIN;\n     args.add(\"--create_source_map=%outname%.map\");\n     args.add(\"--module_output_path_prefix=foo_\");\n     testSame(new String[] {\"var x = 3;\", \"var y = 5;\"});\n         lastCommandLineRunner.expandSourceMapPath(\n             lastCompiler.getOptions(),\n             lastCompiler.getModuleGraph().getRootModule()));\n+  }\n+\n+  public void testChainModuleManifest() throws Exception {\n+    useModules = ModulePattern.CHAIN;\n+    testSame(new String[] {\n+          \"var x = 3;\", \"var y = 5;\", \"var z = 7;\", \"var a = 9;\"});\n+\n+    StringBuilder builder = new StringBuilder();\n+    lastCommandLineRunner.printModuleGraphManifestTo(\n+        lastCompiler.getModuleGraph(), builder);\n+    assertEquals(\n+        \"{m0}\\n\" +\n+        \"i0\\n\" +\n+        \"\\n\" +\n+        \"{m1:m0}\\n\" +\n+        \"i1\\n\" +\n+        \"\\n\" +\n+        \"{m2:m1}\\n\" +\n+        \"i2\\n\" +\n+        \"\\n\" +\n+        \"{m3:m2}\\n\" +\n+        \"i3\\n\",\n+        builder.toString());\n+  }\n+\n+  public void testStarModuleManifest() throws Exception {\n+    useModules = ModulePattern.STAR;\n+    testSame(new String[] {\n+          \"var x = 3;\", \"var y = 5;\", \"var z = 7;\", \"var a = 9;\"});\n+\n+    StringBuilder builder = new StringBuilder();\n+    lastCommandLineRunner.printModuleGraphManifestTo(\n+        lastCompiler.getModuleGraph(), builder);\n+    assertEquals(\n+        \"{m0}\\n\" +\n+        \"i0\\n\" +\n+        \"\\n\" +\n+        \"{m1:m0}\\n\" +\n+        \"i1\\n\" +\n+        \"\\n\" +\n+        \"{m2:m0}\\n\" +\n+        \"i2\\n\" +\n+        \"\\n\" +\n+        \"{m3:m0}\\n\" +\n+        \"i3\\n\",\n+        builder.toString());\n   }\n \n   /* Helper functions */\n     for (int i = 0; i < original.length; i++) {\n       args.add(\"--js\");\n       args.add(\"/path/to/input\" + i + \".js\");\n-      if (useModules) {\n+      if (useModules == ModulePattern.CHAIN) {\n         args.add(\"--module\");\n         args.add(\"mod\" + i + \":1\" + (i > 0 ? (\":mod\" + (i - 1)) : \"\"));\n+      } else if (useModules == ModulePattern.STAR) {\n+        args.add(\"--module\");\n+        args.add(\"mod\" + i + \":1\" + (i > 0 ? \":mod0\" : \"\"));\n       }\n     }\n \n     } catch (IOException e) {\n       assert(false);\n     }\n-    if (useModules) {\n+    if (useModules != ModulePattern.NONE) {\n       compiler.compile(\n           externs,\n-          CompilerTestCase.createModuleChain(original),\n+          useModules == ModulePattern.STAR ?\n+              CompilerTestCase.createModuleStar(original) :\n+              CompilerTestCase.createModuleChain(original),\n           options);\n     } else {\n       JSSourceFile[] inputs = new JSSourceFile[original.length];\n--- a/test/com/google/javascript/jscomp/StripCodeTest.java\n+++ b/test/com/google/javascript/jscomp/StripCodeTest.java\n   private static final String EXTERNS = \"\";\n \n   public StripCodeTest() {\n-    super(EXTERNS, false);\n+    super(EXTERNS);\n   }\n \n   /**\n         \"goog.debug.Logger\",\n         \"goog.debug.LogManager\",\n         \"goog.debug.LogRecord\",\n-        \"goog.net.BrowserChannel.LogSaver\");\n+        \"goog.net.BrowserChannel.LogSaver\",\n+        \"TypeWithoutNamespace\");\n \n     Set<String> stripNames = Sets.newHashSet(\n         \"logger\",\n          \"  var one = this.logger_(); if (one) foo() }\",\n           \"a=function(){};a.prototype.b=function(){if(null)foo()}\");\n   }\n+\n+  public void testReplaceDirectStrippedTypeReferences() {\n+\n+    // Replace direct references with undefined\n+    test(\"if (goog.debug.Logger != null){foo()}\",\n+         \"if (void 0 != null){foo()}\");\n+\n+    // Test replacement with non-namespaced type\n+    test(\"if (TypeWithoutNamespace != null){foo()}\",\n+         \"if (void 0 != null){foo()}\");\n+\n+    // Replace is fine in RHS of assignment\n+    test(\"if ((x = goog.debug.Logger) != null) {foo()}\",\n+         \"if ((x = void 0) != null) {foo()}\");\n+    test(\"if ((x += goog.debug.Logger) != null) {foo()}\",\n+         \"if ((x += void 0) != null) {foo()}\");\n+  }\n+\n+  public void testReportErrorOnStripTypeInNestedAssignment() {\n+    // Don't replace if stripped type is LHS of assignment\n+    test(\"if ((goog.debug.Logger = bar()) != null) {foo()}\",\n+         \"if ((goog.debug.Logger = bar()) != null) {foo()}\",\n+         StripCode.STRIP_ASSIGNMENT_ERROR);\n+\n+    test(\"if ((goog.debug.Logger += bar()) != null) {foo()}\",\n+         \"if ((goog.debug.Logger += bar()) != null) {foo()}\",\n+         StripCode.STRIP_ASSIGNMENT_ERROR);\n+\n+    // Don't replace if stripped type is in increment/decrement\n+    test(\"if ((goog.debug.Logger++) != null) {foo()}\",\n+         \"if ((goog.debug.Logger++) != null) {foo()}\",\n+         StripCode.STRIP_ASSIGNMENT_ERROR);\n+\n+    test(\"if ((goog.debug.Logger--) != null) {foo()}\",\n+         \"if ((goog.debug.Logger--) != null) {foo()}\",\n+         StripCode.STRIP_ASSIGNMENT_ERROR);\n+  }\n+\n+  public void testReportErrorOnStripNameInNestedAssignment() {\n+    test(\"(foo.logger_ = 7) + 8\",\n+         \"(foo.logger_ = 7) + 8\",\n+         StripCode.STRIP_ASSIGNMENT_ERROR);\n+  }\n }", "timestamp": 1278634526, "metainfo": ""}