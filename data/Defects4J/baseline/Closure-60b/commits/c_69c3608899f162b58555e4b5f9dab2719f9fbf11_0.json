{"sha": "69c3608899f162b58555e4b5f9dab2719f9fbf11", "log": "Fix incorrect pseudo names in shadow variables.  R=nicksantos DELTA=48  (41 added, 0 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1098   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ShadowVariables.java\n+++ b/src/com/google/javascript/jscomp/ShadowVariables.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n   // All the information used for renaming.\n   private final SortedSet<Assignment> varsByFrequency;\n   private final SortedMap<String, Assignment> assignments;\n-  private final Map<Node, String> pseudoNameMap;\n+  private final Map<Node, String> oldPseudoNameMap;\n+  private final Map<Node, String> deltaPseudoNameMap;\n+\n \n   /**\n    * @param assignments Map of old variable names to its assignment Objects.\n     this.compiler = compiler;\n     this.assignments = assignments;\n     this.varsByFrequency = varsByFrequency;\n-    this.pseudoNameMap = pseudoNameMap;\n-  }\n-\n+    this.oldPseudoNameMap = pseudoNameMap;\n+    this.deltaPseudoNameMap = Maps.newLinkedHashMap();\n+  }\n \n   @Override\n   public void process(Node externs, Node root) {\n     //\n     // 2. Tries to find shadows for each variables, updates the\n     //    variable usage frequency map.\n+    //\n+    // 3. Updates the pseudo naming map if needed.\n     NodeTraversal.traverse(compiler, root, new GatherReferenceInfo());\n     NodeTraversal.traverse(compiler, root, new DoShadowVariables());\n+\n+    if (oldPseudoNameMap != null) {\n+      oldPseudoNameMap.putAll(deltaPseudoNameMap);\n+    }\n   }\n \n   private class GatherReferenceInfo extends AbstractPostOrderCallback {\n \n         doShadow(localAssignment, bestShadow, var);\n \n-        if (pseudoNameMap != null) {\n+        if (oldPseudoNameMap != null) {\n           String targetPseudoName =\n-            pseudoNameMap.get(s.getVar(bestShadow.oldName).nameNode);\n+            oldPseudoNameMap.get(s.getVar(bestShadow.oldName).nameNode);\n           for (Node use : varToNameUsage.get(var)) {\n-            pseudoNameMap.put(use, targetPseudoName);\n+            deltaPseudoNameMap.put(use, targetPseudoName);\n           }\n         }\n       }\n--- a/test/com/google/javascript/jscomp/ShadowVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/ShadowVariablesTest.java\n     test(\"function f($super) { $super();$super(); return function(a){} }\",\n          \"function a($super) { $super();$super(); return function(b){} }\");\n   }\n+\n+  public void testBug4172539() {\n+    // All the planets must line up. When we look at the 2nd inner function,\n+    // y can shadow x, also m can shadow x as well. Now all that is left for\n+    // n to shadow is 'y'. Now because y has already shadowed x, the pseudo\n+    // name maps has already updated y gets $x$$. This mean n will be updated\n+    // with \"$x$$\" in the name map which is incorrect. That is the reason\n+    // why we can't update the pseudo name map on-the-fly.\n+\n+    generatePseudoNames = true;\n+    test(\"function f(x) {\" +\n+         \"  x;x;x;\" +\n+         \"  return function (y) { y; x };\" +\n+         \"  return function (y) {\" +\n+         \"    y;\" +\n+         \"    return function (m, n) {\" +\n+         \"       m;m;m;\" +\n+         \"    };\" +\n+         \"  };\" +\n+         \"}\",\n+\n+         \"function $f$$($x$$) {\" +\n+         \"  $x$$;$x$$;$x$$;\" +\n+         \"  return function ($y$$) { $y$$; $x$$ };\" +\n+         \"  return function ($x$$) {\" +\n+         \"    $x$$;\" +\n+         \"    return function ($x$$, $y$$) {\" +\n+         \"       $x$$;$x$$;$x$$;\" +\n+         \"    };\" +\n+         \"  };\" +\n+         \"}\");\n+  }\n }", "timestamp": 1301348735, "metainfo": ""}