{"sha": "de70209098a5cb103655afede52ff428f001a59f", "log": "Merges multiple statements into one.  R=johnlenz DELTA=249  (249 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=501   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Tries to fuse all the statements in a block into a one statement by using\n+ * COMMAs.\n+ *\n+ * Because COMMAs has the lowest precedence, we never need to insert\n+ * extra () around. Once we have only one statement in a block, we can then\n+ * eliminate a pair of {}'s. Further more, we can also fold a single\n+ * statement IF into && or create further opportunities for all the other\n+ * goodies in {@link PeepholeSubstituteAlternateSyntax}.\n+ *\n+ */\n+public class StatementFusion extends AbstractPeepholeOptimization {\n+\n+  @Override\n+  Node optimizeSubtree(Node n) {\n+    // The block of a function body always need { }.\n+    if (!NodeUtil.isFunction(n.getParent()) && canFuseIntoOneStatement(n)) {\n+      fuseIntoOneStatement(n);\n+      reportCodeChange();\n+    }\n+    return n;\n+  }\n+\n+  private static boolean canFuseIntoOneStatement(Node block) {\n+    // Fold only statement block. NOT scripts block.\n+    if (block.getType() != Token.BLOCK) {\n+      return false;\n+    }\n+\n+    // Nothing to do here.\n+    if (!block.hasChildren() || block.hasOneChild()) {\n+      return false;\n+    }\n+\n+    Node last = block.getLastChild();\n+\n+    for (Node c = block.getFirstChild(); c != null; c = c.getNext()) {\n+      if (!NodeUtil.isExpressionNode(c) && c != last) {\n+        return false;\n+      }\n+    }\n+\n+    // TODO(user): Support more control statement for fusion.\n+    // FOR, FOR-IN\n+    switch(last.getType()) {\n+      case Token.IF:\n+      case Token.THROW:\n+      case Token.SWITCH:\n+      case Token.EXPR_RESULT:\n+        return true;\n+      case Token.RETURN:\n+        // We don't want to add a new return value.\n+        return last.hasChildren();\n+    }\n+\n+    return false;\n+  }\n+\n+  private void fuseIntoOneStatement(Node block) {\n+    Node cur = block.removeFirstChild();\n+\n+    // Starts building a tree.\n+    Node commaTree = cur.removeFirstChild();\n+\n+\n+    while (block.hasMoreThanOneChild()) {\n+      Node next = block.removeFirstChild().removeFirstChild();\n+      commaTree = fuseExpressionIntoExpression(commaTree, next);\n+    }\n+\n+    Preconditions.checkState(block.hasOneChild());\n+    Node last = block.getLastChild();\n+\n+    // Now we are just left with two statements. The comma tree of the first\n+    // n - 1 statements (which can be used in an expression) and the last\n+    // statement. We perform specific fusion based on the last statement's type.\n+    switch(last.getType()) {\n+      case Token.IF:\n+      case Token.RETURN:\n+      case Token.THROW:\n+      case Token.SWITCH:\n+      case Token.EXPR_RESULT:\n+        fuseExpresssonIntoFirstChild(commaTree, last);\n+        return;\n+      default:\n+        throw new IllegalStateException(\"Statement fusion missing.\");\n+    }\n+  }\n+\n+  // exp1, exp1\n+  private static Node fuseExpressionIntoExpression(Node exp1, Node exp2) {\n+    Node comma = new Node(Token.COMMA, exp1);\n+    comma.copyInformationFrom(exp2);\n+\n+    // We can just join the new comma expression with another comma but\n+    // lets keep all the comma's in a straight line. That way we can use\n+    // tree comparison.\n+    if (exp2.getType() == Token.COMMA) {\n+      Node leftMostChild = exp2;\n+      while(leftMostChild.getType() == Token.COMMA) {\n+        leftMostChild = leftMostChild.getFirstChild();\n+      }\n+      Node parent = leftMostChild.getParent();\n+      comma.addChildToBack(leftMostChild.detachFromParent());\n+      parent.addChildToFront(comma);\n+      return exp2;\n+    } else {\n+      comma.addChildToBack(exp2);\n+      return comma;\n+    }\n+  }\n+\n+  private static void fuseExpresssonIntoFirstChild(Node exp, Node stmt) {\n+    Node val = stmt.removeFirstChild();\n+    Node comma = fuseExpressionIntoExpression(exp, val);\n+    stmt.addChildToFront(comma);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/StatementFusionTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link StatementFusion}.\n+ *\n+ */\n+public class StatementFusionTest extends CompilerTestCase  {\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    PeepholeOptimizationsPass peepholePass =\n+      new PeepholeOptimizationsPass(compiler, new StatementFusion());\n+\n+    return peepholePass;\n+  }\n+\n+  public void testNothingToDo() {\n+    fuseSame(\"\");\n+    fuseSame(\"a\");\n+    fuseSame(\"a()\");\n+    fuseSame(\"if(a()){}\");\n+  }\n+\n+  public void testFoldBlockWithStatements() {\n+    fuse(\"a;b;c\", \"a,b,c\");\n+    fuse(\"a();b();c();\", \"a(),b(),c()\");\n+    fuse(\"a(),b();c(),d()\", \"a(),b(),c(),d()\");\n+    fuse(\"a();b(),c(),d()\", \"a(),b(),c(),d()\");\n+    fuse(\"a(),b(),c();d()\", \"a(),b(),c(),d()\");\n+  }\n+\n+  public void testFoldBlockIntoIf() {\n+    fuse(\"a;b;c;if(x){}\", \"if(a,b,c,x){}\");\n+    fuse(\"a;b;c;if(x,y){}else{}\", \"if(a,b,c,x,y){}else{}\");\n+    fuse(\"a;b;c;if(x,y){}\", \"if(a,b,c,x,y){}\");\n+    fuse(\"a;b;c;if(x,y,z){}\", \"if(a,b,c,x,y,z){}\");\n+\n+    // Can't fuse if there are statements after the IF.\n+    fuseSame(\"a();if(a()){}a()\");\n+  }\n+\n+  public void testFoldBlockReturn() {\n+    fuse(\"a;b;c;return x\", \"return a,b,c,x\");\n+    fuse(\"a;b;c;return x+y\", \"return a,b,c,x+y\");\n+\n+    // DeadAssignmentElimination would have cleaned it up anyways.\n+    fuseSame(\"a;b;c;return x;a;b;c\");\n+  }\n+\n+  public void testFoldBlockThrow() {\n+    fuse(\"a;b;c;throw x\", \"throw a,b,c,x\");\n+    fuse(\"a;b;c;throw x+y\", \"throw a,b,c,x+y\");\n+    fuseSame(\"a;b;c;throw x;a;b;c\");\n+  }\n+\n+  public void testFoldSwitch() {\n+    fuse(\"a;b;c;switch(x){}\", \"switch(a,b,c,x){}\");\n+  }\n+\n+  public void testNoFuseIntoWhile() {\n+    fuseSame(\"a;b;c;while(x){}\");\n+  }\n+\n+  public void testNoFuseIntoDo() {\n+    fuseSame(\"a;b;c;do{}while(x)\");\n+  }\n+\n+  public void testNoGlobalSchopeChanges() {\n+    testSame(\"a,b,c\");\n+  }\n+\n+  public void testNoFunctionBlockChanges() {\n+    testSame(\"function foo() { a,b,c }\");\n+  }\n+\n+  private void fuse(String before, String after) {\n+    test(\"function F(){if(CONDITION){\" + before + \"}}\",\n+         \"function F(){if(CONDITION){\" + after + \"}}\");\n+  }\n+\n+  private void fuseSame(String code) {\n+    fuse(code, code);\n+  }\n+}", "timestamp": 1297388760, "metainfo": ""}