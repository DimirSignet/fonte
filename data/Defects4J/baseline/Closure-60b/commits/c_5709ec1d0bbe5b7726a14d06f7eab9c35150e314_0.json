{"sha": "5709ec1d0bbe5b7726a14d06f7eab9c35150e314", "log": "Put bad type annotations behind a diagnostic group, so that they aren't reported if type-checking isn't on.  R=acleung DELTA=300  (110 added, 11 deleted, 179 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=780   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n       guards.add(new DiagnosticGroupWarningsGuard(\n           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n     }\n+\n+    // DiagnosticGroups override the plain checkTypes option.\n+    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n+      options.checkTypes = true;\n+    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n+      options.checkTypes = false;\n+    } else if (!options.checkTypes) {\n+      // If DiagnosticGroups did not override the plain checkTypes\n+      // option, and checkTypes is enabled, then turn off the\n+      // parser type warnings.\n+      guards.add(\n+          new DiagnosticGroupWarningsGuard(\n+              DiagnosticGroup.forType(\n+                  RhinoErrorReporter.TYPE_PARSE_ERROR),\n+              CheckLevel.OFF));\n+    }\n     this.warningsGuard = new ComposeWarningsGuard(guards);\n   }\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     // This pass should run before types are assigned.\n     if (options.processObjectPropertyString) {\n       checks.add(objectPropertyStringPreprocess);\n-    }\n-\n-    // DiagnosticGroups override the plain checkTypes option.\n-    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n-      options.checkTypes = true;\n-    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n-      options.checkTypes = false;\n     }\n \n     if (options.checkTypes) {\n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n   static final DiagnosticType PARSE_ERROR =\n       DiagnosticType.error(\"JSC_PARSE_ERROR\", \"Parse error. {0}\");\n \n+  static final DiagnosticType TYPE_PARSE_ERROR =\n+      DiagnosticType.warning(\"JSC_TYPE_PARSE_ERROR\", \"{0}\");\n+\n   // A special-cased error, so that it can be configured via the\n   // warnings API.\n   static final DiagnosticType EXTRA_FILEOVERVIEW =\n     DiagnosticType.warning(\"JSC_BAD_JSDOC_ANNOTATION\", \"Parse error. {0}\");\n \n   // A map of Rhino messages to their DiagnosticType.\n-  private final Map<String, DiagnosticType> typeMap;\n+  private final Map<Pattern, DiagnosticType> typeMap;\n \n   private final AbstractCompiler compiler;\n \n    * holder {0} with a wild card that matches all possible strings.\n    * Also put the any non-place-holder in quotes for regex matching later.\n    */\n-  private String replacePlaceHolders(String s) {\n+  private Pattern replacePlaceHolders(String s) {\n     s = Pattern.quote(s);\n-    return s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\");\n+    return Pattern.compile(s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\"));\n   }\n \n   private RhinoErrorReporter(AbstractCompiler compiler) {\n \n         // Unknown @annotations.\n         replacePlaceHolders(ScriptRuntime.getMessage0(\"msg.bad.jsdoc.tag\")),\n-        BAD_JSDOC_ANNOTATION);\n+        BAD_JSDOC_ANNOTATION,\n+\n+        // Type annotation errors.\n+        Pattern.compile(\"^Bad type annotation.*\"),\n+        TYPE_PARSE_ERROR);\n   }\n \n   public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter\n \n     // Try to see if the message is one of the rhino errors we want to\n     // expose as DiagnosticType by matching it with the regex key.\n-    for (Entry<String, DiagnosticType> entry : typeMap.entrySet()) {\n-      if (message.matches(entry.getKey())) {\n+    for (Entry<Pattern, DiagnosticType> entry : typeMap.entrySet()) {\n+      if (entry.getKey().matcher(message).matches()) {\n         return JSError.make(\n             sourceName, line, lineOffset, entry.getValue(), message);\n       }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       UNRESOLVED_TYPE,\n       WRONG_ARGUMENT_COUNT,\n       ILLEGAL_IMPLICIT_CAST,\n+      RhinoErrorReporter.TYPE_PARSE_ERROR,\n       TypedScopeCreator.UNKNOWN_LENDS,\n       TypedScopeCreator.LENDS_ON_NON_OBJECT,\n       TypedScopeCreator.CTOR_INITIALIZER,\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n   private final Node templateNode;\n \n   private class ErrorReporterParser {\n-    void addWarning(String messageId, String messageArg, int lineno,\n-                    int charno) {\n+    void addParserWarning(String messageId, String messageArg, int lineno,\n+        int charno) {\n       errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n           sourceName, lineno, null, charno);\n     }\n-    void addWarning(String messageId, int lineno, int charno) {\n+\n+    void addParserWarning(String messageId, int lineno, int charno) {\n       errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n+          sourceName, lineno, null, charno);\n+    }\n+\n+    void addTypeWarning(String messageId, String messageArg, int lineno,\n+                    int charno) {\n+      errorReporter.warning(\n+          \"Bad type annotation. \" +\n+          ScriptRuntime.getMessage1(messageId, messageArg),\n+          sourceName, lineno, null, charno);\n+    }\n+\n+    void addTypeWarning(String messageId, int lineno, int charno) {\n+      errorReporter.warning(\n+          \"Bad type annotation. \" +\n+          ScriptRuntime.getMessage0(messageId),\n           sourceName, lineno, null, charno);\n     }\n   }\n             String annotationName = stream.getString();\n             Annotation annotation = annotationNames.get(annotationName);\n             if (annotation == null) {\n-              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n+              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                   stream.getLineno(), stream.getCharno());\n             } else {\n               // Mark the beginning of the annotation.\n                     String author = authorInfo.string;\n \n                     if (author.length() == 0) {\n-                      parser.addWarning(\"msg.jsdoc.authormissing\",\n+                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                           stream.getLineno(), stream.getCharno());\n                     } else {\n                       jsdocBuilder.addAuthor(author);\n \n                 case CONSTANT:\n                   if (!jsdocBuilder.recordConstancy()) {\n-                    parser.addWarning(\"msg.jsdoc.const\",\n+                    parser.addParserWarning(\"msg.jsdoc.const\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n                 case CONSTRUCTOR:\n                   if (!jsdocBuilder.recordConstructor()) {\n                     if (jsdocBuilder.isInterfaceRecorded()) {\n-                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n+                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                           stream.getLineno(), stream.getCharno());\n                     } else {\n-                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n+                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                           stream.getLineno(), stream.getCharno());\n                     }\n                   }\n \n                 case DEPRECATED:\n                   if (!jsdocBuilder.recordDeprecated()) {\n-                    parser.addWarning(\"msg.jsdoc.deprecated\",\n+                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n \n                 case INTERFACE:\n                   if (!jsdocBuilder.recordInterface()) {\n                     if (jsdocBuilder.isConstructorRecorded()) {\n-                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n+                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                           stream.getLineno(), stream.getCharno());\n                     } else {\n-                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n+                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                           stream.getLineno(), stream.getCharno());\n                     }\n                   }\n \n                 case DESC:\n                   if (jsdocBuilder.isDescriptionRecorded()) {\n-                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n+                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                         stream.getLineno(), stream.getCharno());\n                     token = eatTokensUntilEOL();\n                     continue retry;\n \n                   if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                       fileOverviewJSDocInfo != null) {\n-                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n+                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   continue retry;\n                     type = createJSTypeExpression(newStringNode(\"number\"));\n                   }\n                   if (!jsdocBuilder.recordEnumParameterType(type)) {\n-                    parser.addWarning(\n+                    parser.addTypeWarning(\n                         \"msg.jsdoc.incompat.type\", lineno, charno);\n                   }\n                   token = eatTokensUntilEOL(token);\n \n                 case EXPORT:\n                   if (!jsdocBuilder.recordExport()) {\n-                    parser.addWarning(\"msg.jsdoc.export\",\n+                    parser.addParserWarning(\"msg.jsdoc.export\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case EXTERNS:\n                   if (!jsdocBuilder.recordExterns()) {\n-                    parser.addWarning(\"msg.jsdoc.externs\",\n+                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case JAVA_DISPATCH:\n                   if (!jsdocBuilder.recordJavaDispatch()) {\n-                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n+                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                     if (annotation == Annotation.EXTENDS) {\n                       if (!jsdocBuilder.recordBaseType(type)) {\n-                        parser.addWarning(\n+                        parser.addTypeWarning(\n                             \"msg.jsdoc.incompat.type\", lineno, charno);\n                       }\n                     } else {\n                       Preconditions.checkState(\n                           annotation == Annotation.IMPLEMENTS);\n                       if (!jsdocBuilder.recordImplementedInterface(type)) {\n-                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n+                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                             lineno, charno);\n                       }\n                     }\n                     token = next();\n                     if (matchingRc) {\n                       if (token != JsDocToken.RC) {\n-                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n+                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                             stream.getLineno(), stream.getCharno());\n                       }\n                     } else if (token != JsDocToken.EOL &&\n                         token != JsDocToken.EOF && token != JsDocToken.EOC) {\n-                      parser.addWarning(\"msg.end.annotation.expected\",\n+                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                           stream.getLineno(), stream.getCharno());\n                     }\n                   } else {\n-                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n+                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                   }\n                   token = eatTokensUntilEOL(token);\n                   continue retry;\n \n                 case HIDDEN:\n                   if (!jsdocBuilder.recordHiddenness()) {\n-                    parser.addWarning(\"msg.jsdoc.hidden\",\n+                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n                   if (match(JsDocToken.STRING)) {\n                     token = next();\n                     if (!jsdocBuilder.recordLends(stream.getString())) {\n-                      parser.addWarning(\"msg.jsdoc.lends.incompatible\",\n+                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                           stream.getLineno(), stream.getCharno());\n                     }\n                   } else {\n-                    parser.addWarning(\"msg.jsdoc.lends.missing\",\n+                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n \n                   if (matchingRc && !match(JsDocToken.RC)) {\n-                    parser.addWarning(\"msg.jsdoc.missing.rc\",\n+                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n                   String meaning = meaningInfo.string;\n                   token = meaningInfo.token;\n                   if (!jsdocBuilder.recordMeaning(meaning)) {\n-                    parser.addWarning(\"msg.jsdoc.meaning.extra\",\n+                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   continue retry;\n \n                 case NO_ALIAS:\n                   if (!jsdocBuilder.recordNoAlias()) {\n-                    parser.addWarning(\"msg.jsdoc.noalias\",\n+                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case NO_COMPILE:\n                   if (!jsdocBuilder.recordNoCompile()) {\n-                    parser.addWarning(\"msg.jsdoc.nocompile\",\n+                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case NO_TYPE_CHECK:\n                   if (!jsdocBuilder.recordNoTypeCheck()) {\n-                    parser.addWarning(\"msg.jsdoc.nocheck\",\n+                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n                 case INHERIT_DOC:\n                 case OVERRIDE:\n                   if (!jsdocBuilder.recordOverride()) {\n-                    parser.addWarning(\"msg.jsdoc.override\",\n+                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n                   }\n \n                   if (JsDocToken.STRING != token) {\n-                    parser.addWarning(\"msg.missing.variable.name\",\n+                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                         lineno, charno);\n                   } else {\n                     name = stream.getString();\n                       name = null;\n                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                       if (jsdocBuilder.hasParameter(name)) {\n-                        parser.addWarning(\"msg.dup.variable.name\", name,\n+                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                             lineno, charno);\n                       } else {\n-                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n+                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                             lineno, charno);\n                       }\n                     }\n \n                 case PRESERVE_TRY:\n                   if (!jsdocBuilder.recordPreserveTry()) {\n-                    parser.addWarning(\"msg.jsdoc.preservertry\",\n+                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case PRIVATE:\n                   if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n-                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n+                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case PROTECTED:\n                   if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n-                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n+                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case PUBLIC:\n                   if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n-                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n+                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case NO_SHADOW:\n                   if (!jsdocBuilder.recordNoShadow()) {\n-                    parser.addWarning(\"msg.jsdoc.noshadow\",\n+                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case NO_SIDE_EFFECTS:\n                   if (!jsdocBuilder.recordNoSideEffects()) {\n-                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n+                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n \n                 case IMPLICIT_CAST:\n                   if (!jsdocBuilder.recordImplicitCast()) {\n-                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n+                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n                   token = eatTokensUntilEOL();\n                     String reference = referenceInfo.string;\n \n                     if (reference.length() == 0) {\n-                      parser.addWarning(\"msg.jsdoc.seemissing\",\n+                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                           stream.getLineno(), stream.getCharno());\n                     } else {\n                       jsdocBuilder.addReference(reference);\n                   String templateTypeName = templateInfo.string;\n \n                   if (templateTypeName.length() == 0) {\n-                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n+                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                           stream.getLineno(), stream.getCharno());\n                   } else if (!jsdocBuilder.recordTemplateTypeName(\n                       templateTypeName)) {\n-                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n+                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n \n                   String version = versionInfo.string;\n \n                   if (version.length() == 0) {\n-                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n+                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                           stream.getLineno(), stream.getCharno());\n                   } else {\n                     if (!jsdocBuilder.recordVersion(version)) {\n-                       parser.addWarning(\"msg.jsdoc.extraversion\",\n+                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                           stream.getLineno(), stream.getCharno());\n                     }\n                   }\n                     switch (annotation) {\n                       case DEFINE:\n                         if (!jsdocBuilder.recordDefineType(type)) {\n-                          parser.addWarning(\"msg.jsdoc.define\",\n+                          parser.addParserWarning(\"msg.jsdoc.define\",\n                               lineno, charno);\n                         }\n                         break;\n \n                       case RETURN:\n                         if (!jsdocBuilder.recordReturnType(type)) {\n-                          parser.addWarning(\n+                          parser.addTypeWarning(\n                               \"msg.jsdoc.incompat.type\", lineno, charno);\n                           break;\n                         }\n \n                       case THIS:\n                         if (!jsdocBuilder.recordThisType(type)) {\n-                          parser.addWarning(\n+                          parser.addTypeWarning(\n                               \"msg.jsdoc.incompat.type\", lineno, charno);\n                         }\n                         break;\n \n                       case TYPE:\n                         if (!jsdocBuilder.recordType(type)) {\n-                          parser.addWarning(\n+                          parser.addTypeWarning(\n                               \"msg.jsdoc.incompat.type\", lineno, charno);\n                         }\n                         break;\n \n                       case TYPEDEF:\n                         if (!jsdocBuilder.recordTypedef(type)) {\n-                          parser.addWarning(\n+                          parser.addTypeWarning(\n                               \"msg.jsdoc.incompat.type\", lineno, charno);\n                         }\n                         break;\n         case EOF:\n           // discard any accumulated information\n           jsdocBuilder.build(null);\n-          parser.addWarning(\"msg.unexpected.eof\",\n+          parser.addParserWarning(\"msg.unexpected.eof\",\n               stream.getLineno(), stream.getCharno());\n           return false;\n \n         if (match(JsDocToken.STRING)) {\n           String name = stream.getString();\n           if (!suppressionNames.contains(name)) {\n-            parser.addWarning(\"msg.jsdoc.suppress.unknown\", name,\n+            parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n                 stream.getLineno(), stream.getCharno());\n           }\n \n           suppressions.add(stream.getString());\n           token = next();\n         } else {\n-          parser.addWarning(\"msg.jsdoc.suppress\",\n+          parser.addParserWarning(\"msg.jsdoc.suppress\",\n               stream.getLineno(), stream.getCharno());\n           return token;\n         }\n       }\n \n       if (!match(JsDocToken.RC)) {\n-        parser.addWarning(\"msg.jsdoc.suppress\",\n+        parser.addParserWarning(\"msg.jsdoc.suppress\",\n             stream.getLineno(), stream.getCharno());\n       } else {\n         token = next();\n         if (!jsdocBuilder.recordSuppressions(suppressions)) {\n-          parser.addWarning(\"msg.jsdoc.suppress.duplicate\",\n+          parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n               stream.getLineno(), stream.getCharno());\n         }\n       }\n           String name = stream.getString();\n           if (!modifiesAnnotationKeywords.contains(name)\n               && !jsdocBuilder.hasParameter(name)) {\n-              parser.addWarning(\"msg.jsdoc.modifies.unknown\", name,\n+              parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                   stream.getLineno(), stream.getCharno());\n           }\n \n           modifies.add(stream.getString());\n           token = next();\n         } else {\n-          parser.addWarning(\"msg.jsdoc.modifies\",\n+          parser.addParserWarning(\"msg.jsdoc.modifies\",\n               stream.getLineno(), stream.getCharno());\n           return token;\n         }\n       }\n \n       if (!match(JsDocToken.RC)) {\n-        parser.addWarning(\"msg.jsdoc.modifies\",\n+        parser.addParserWarning(\"msg.jsdoc.modifies\",\n             stream.getLineno(), stream.getCharno());\n       } else {\n         token = next();\n         if (!jsdocBuilder.recordModifies(modifies)) {\n-          parser.addWarning(\"msg.jsdoc.modifies.duplicate\",\n+          parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n               stream.getLineno(), stream.getCharno());\n         }\n       }\n   }\n \n   private Node reportTypeSyntaxWarning(String warning) {\n-    parser.addWarning(warning, stream.getLineno(), stream.getCharno());\n+    parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());\n     return null;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n           registry.isForwardDeclaredType(reference);\n       boolean beForgiving = forgiving || isForwardDeclared;\n       if (!beForgiving && registry.isLastGeneration()) {\n-        t.warning(\"Unknown type \" + reference, sourceName, lineno, null,\n-            charno);\n+        t.warning(\"Bad type annotation. Unknown type \" + reference,\n+            sourceName, lineno, null, charno);\n       } else {\n         if (isForwardDeclared) {\n           setReferencedType(\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n     test(\"function f(x) { return x; } f();\", TypeCheck.WRONG_ARGUMENT_COUNT);\n   }\n \n+  public void testTypeParsingOffByDefault() {\n+    testSame(\"/** @return {number */ function f(a) { return a; }\");\n+  }\n+\n+  public void testTypeParsingOnWithVerbose() {\n+    args.add(\"--warning_level=VERBOSE\");\n+    test(\"/** @return {number */ function f(a) { return a; }\",\n+         RhinoErrorReporter.TYPE_PARSE_ERROR);\n+    test(\"/** @return {n} */ function f(a) { return a; }\",\n+         RhinoErrorReporter.TYPE_PARSE_ERROR);\n+  }\n+\n   public void testTypeCheckOverride1() {\n     args.add(\"--warning_level=VERBOSE\");\n     args.add(\"--jscomp_off=checkTypes\");\n \n   public void testQuietMode() {\n     args.add(\"--warning_level=DEFAULT\");\n-    test(\"/** @type { not a type name } */ var x;\",\n+    test(\"/** @const \\n * @const */ var x;\",\n          RhinoErrorReporter.PARSE_ERROR);\n     args.add(\"--warning_level=QUIET\");\n-    testSame(\"/** @type { not a type name } */ var x;\");\n+    testSame(\"/** @const \\n * @const */ var x;\");\n   }\n \n   public void testProcessClosurePrimitives() {\n            \"var beer = {}; function f() {}\",\n            \"\"\n          },\n-         RhinoErrorReporter.PARSE_ERROR);\n+         RhinoErrorReporter.TYPE_PARSE_ERROR);\n   }\n \n   public void testSourceMapExpansion1() {\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n   }\n \n   public void testOptionalArgFunctionParamError() throws Exception {\n-    String expectedWarning = \"Parse error. variable length argument must be \" +\n-        \"last\";\n+    String expectedWarning =\n+        \"Bad type annotation. variable length argument must be last\";\n     testTypes(\"/** @param {function(...[number], number=)} a */\" +\n               \"function f(a) {};\", expectedWarning, false);\n   }\n   public void testBadExtends1() throws Exception {\n     testTypes(\"/** @constructor */function base() {}\\n\" +\n         \"/** @constructor\\n * @extends {not_base} */function derived() {}\\n\",\n-        \"Parse error. Unknown type not_base\");\n+        \"Bad type annotation. Unknown type not_base\");\n   }\n \n   public void testBadExtends2() throws Exception {\n         \" * @implements {nonExistent}\\n\" +\n         \" * @implements {Base2}\\n\" +\n         \" */ function derived() {}\",\n-        \"Parse error. Unknown type nonExistent\");\n+        \"Bad type annotation. Unknown type nonExistent\");\n   }\n \n   public void testBadImplements2() throws Exception {\n \n   public void testBadInterfaceExtends1() throws Exception {\n     testTypes(\"/** @interface \\n * @extends {nonExistent} */function A() {}\",\n-        \"Parse error. Unknown type nonExistent\");\n+        \"Bad type annotation. Unknown type nonExistent\");\n   }\n \n   public void testBadInterfaceExtends2() throws Exception {\n         \"/** @type {some.unknown.type} */var f1;\" +\n         \"var f2 = opt_f || f1;\" +\n         \"f2();\",\n-        \"Parse error. Unknown type some.unknown.type\");\n+        \"Bad type annotation. Unknown type some.unknown.type\");\n   }\n \n   public void testCall4() throws Exception {\n \n   public void testCast7() throws Exception {\n     testTypes(\"var x = /** @type {foo} */ (new Object());\",\n-        \"Parse error. Unknown type foo\");\n+        \"Bad type annotation. Unknown type foo\");\n   }\n \n   public void testCast8() throws Exception {\n     testTypes(\"function f() { return /** @type {foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type foo\");\n+        \"Bad type annotation. Unknown type foo\");\n   }\n \n   public void testCast9() throws Exception {\n     testTypes(\"var foo = {};\" +\n         \"function f() { return /** @type {foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type foo\");\n+        \"Bad type annotation. Unknown type foo\");\n   }\n \n   public void testCast10() throws Exception {\n     testTypes(\"var foo = function() {};\" +\n         \"function f() { return /** @type {foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type foo\");\n+        \"Bad type annotation. Unknown type foo\");\n   }\n \n   public void testCast11() throws Exception {\n     testTypes(\"var goog = {}; goog.foo = {};\" +\n         \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type goog.foo\");\n+        \"Bad type annotation. Unknown type goog.foo\");\n   }\n \n   public void testCast12() throws Exception {\n     testTypes(\"var goog = {}; goog.foo = function() {};\" +\n         \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type goog.foo\");\n+        \"Bad type annotation. Unknown type goog.foo\");\n   }\n \n   public void testCast13() throws Exception {\n         \"goog.addDependency('zzz.js', ['goog.foo'], []);\" +\n         \"goog.foo = function() {};\" +\n         \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type goog.foo\");\n+        \"Bad type annotation. Unknown type goog.foo\");\n   }\n \n   public void testCast14() throws Exception {\n         \"var goog = {};\\n\" +\n         \"/** @constructor\\n @extends {goog.Missing} */function Sub() {};\" +\n         \"/** @override */Sub.prototype.foo = function() {};\",\n-        \"Parse error. Unknown type goog.Missing\");\n+        \"Bad type annotation. Unknown type goog.Missing\");\n   }\n \n   public void testInheritanceCheck14() throws Exception {\n         \"goog.Super = function() {};\\n\" +\n         \"/** @constructor\\n @extends {goog.Super} */function Sub() {};\" +\n         \"/** @override */Sub.prototype.foo = function() {};\",\n-        \"Parse error. Unknown type goog.Missing\");\n+        \"Bad type annotation. Unknown type goog.Missing\");\n   }\n \n   // TODO(user): We should support this way of declaring properties as it is\n         \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n         \"/** @override */Sub.prototype.foo = function() {};\",\n         new String[] {\n-          \"Parse error. Unknown type Super\",\n+          \"Bad type annotation. Unknown type Super\",\n           \"property foo not defined on any superclass of Sub\"\n         });\n   }\n   public void testNoForwardTypeDeclaration() throws Exception {\n     testTypes(\n         \"/** @param {MyType} x */ function f(x) {}\",\n-        \"Parse error. Unknown type MyType\");\n+        \"Bad type annotation. Unknown type MyType\");\n   }\n \n   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   }\n \n   public void testOptionalArgFunctionParamError() throws Exception {\n-    String expectedWarning = \"Parse error. variable length argument must be \" +\n-        \"last\";\n+    String expectedWarning =\n+        \"Bad type annotation. variable length argument must be last\";\n     testTypes(\"/** @param {function(...[number], number=)} a */\" +\n               \"function f(a) {};\", expectedWarning, false);\n   }\n   public void testBadExtends1() throws Exception {\n     testTypes(\"/** @constructor */function base() {}\\n\" +\n         \"/** @constructor\\n * @extends {not_base} */function derived() {}\\n\",\n-        \"Parse error. Unknown type not_base\");\n+        \"Bad type annotation. Unknown type not_base\");\n   }\n \n   public void testBadExtends2() throws Exception {\n         \"/** @constructor \\n * @extends {Sub} */ function Sub2() {}\" +\n         \"/** @param {Sub} x */ function foo(x) {}\" +\n         \"foo(new Sub2());\",\n-        \"Parse error. Unknown type bad\");\n+        \"Bad type annotation. Unknown type bad\");\n   }\n \n   public void testLateExtends() throws Exception {\n         \" * @implements {nonExistent}\\n\" +\n         \" * @implements {Base2}\\n\" +\n         \" */ function derived() {}\",\n-        \"Parse error. Unknown type nonExistent\");\n+        \"Bad type annotation. Unknown type nonExistent\");\n   }\n \n   public void testBadImplements2() throws Exception {\n \n   public void testBadInterfaceExtends1() throws Exception {\n     testTypes(\"/** @interface \\n * @extends {nonExistent} */function A() {}\",\n-        \"Parse error. Unknown type nonExistent\");\n+        \"Bad type annotation. Unknown type nonExistent\");\n   }\n \n   public void testBadInterfaceExtends2() throws Exception {\n         \"})();\" +\n         \"/** @param {ns.Foo} x */ function f(x) {}\" +\n         \"f(new ns.Foo(true));\",\n-        \"Parse error. Unknown type ns.Foo\");\n+        \"Bad type annotation. Unknown type ns.Foo\");\n   }\n \n   public void testQualifiedNameInference9() throws Exception {\n         \"/** @type {some.unknown.type} */var f1;\" +\n         \"var f2 = opt_f || f1;\" +\n         \"f2();\",\n-        \"Parse error. Unknown type some.unknown.type\");\n+        \"Bad type annotation. Unknown type some.unknown.type\");\n   }\n \n   public void testCall4() throws Exception {\n \n   public void testCast7() throws Exception {\n     testTypes(\"var x = /** @type {foo} */ (new Object());\",\n-        \"Parse error. Unknown type foo\");\n+        \"Bad type annotation. Unknown type foo\");\n   }\n \n   public void testCast8() throws Exception {\n     testTypes(\"function f() { return /** @type {foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type foo\");\n+        \"Bad type annotation. Unknown type foo\");\n   }\n \n   public void testCast9() throws Exception {\n     testTypes(\"var foo = {};\" +\n         \"function f() { return /** @type {foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type foo\");\n+        \"Bad type annotation. Unknown type foo\");\n   }\n \n   public void testCast10() throws Exception {\n     testTypes(\"var foo = function() {};\" +\n         \"function f() { return /** @type {foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type foo\");\n+        \"Bad type annotation. Unknown type foo\");\n   }\n \n   public void testCast11() throws Exception {\n     testTypes(\"var goog = {}; goog.foo = {};\" +\n         \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type goog.foo\");\n+        \"Bad type annotation. Unknown type goog.foo\");\n   }\n \n   public void testCast12() throws Exception {\n     testTypes(\"var goog = {}; goog.foo = function() {};\" +\n         \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type goog.foo\");\n+        \"Bad type annotation. Unknown type goog.foo\");\n   }\n \n   public void testCast13() throws Exception {\n         \"goog.addDependency('zzz.js', ['goog.foo'], []);\" +\n         \"goog.foo = function() {};\" +\n         \"function f() { return /** @type {goog.foo} */ (new Object()); }\",\n-        \"Parse error. Unknown type goog.foo\");\n+        \"Bad type annotation. Unknown type goog.foo\");\n   }\n \n   public void testCast14() throws Exception {\n         \"var goog = {};\\n\" +\n         \"/** @constructor\\n @extends {goog.Missing} */function Sub() {};\" +\n         \"/** @override */Sub.prototype.foo = function() {};\",\n-        \"Parse error. Unknown type goog.Missing\");\n+        \"Bad type annotation. Unknown type goog.Missing\");\n   }\n \n   public void testInheritanceCheck14() throws Exception {\n         \"goog.Super = function() {};\\n\" +\n         \"/** @constructor\\n @extends {goog.Super} */function Sub() {};\" +\n         \"/** @override */Sub.prototype.foo = function() {};\",\n-        \"Parse error. Unknown type goog.Missing\");\n+        \"Bad type annotation. Unknown type goog.Missing\");\n   }\n \n   // TODO(user): We should support this way of declaring properties as it is\n         \"/** @constructor\\n @implements {Super} */function Sub() {};\" +\n         \"/** @override */Sub.prototype.foo = function() {};\",\n         new String[] {\n-          \"Parse error. Unknown type Super\",\n+          \"Bad type annotation. Unknown type Super\",\n           \"property foo not defined on any superclass of Sub\"\n         });\n   }\n   public void testNoForwardTypeDeclaration() throws Exception {\n     testTypes(\n         \"/** @param {MyType} x */ function f(x) {}\",\n-        \"Parse error. Unknown type MyType\");\n+        \"Bad type annotation. Unknown type MyType\");\n   }\n \n   public void testNoForwardTypeDeclarationAndNoBraces() throws Exception {\n         \"function extend(x, y) {}\" +\n         \"/** @constructor */ function Foo() {}\" +\n         \"extend(Foo, /** @lends */ ({bar: 1}));\",\n-        \"Parse error. missing object name in @lends tag\");\n+        \"Bad type annotation. missing object name in @lends tag\");\n   }\n \n   public void testLends2() throws Exception {\n         \"function extend(x, y) {}\" +\n         \"/** @constructor */ function Foo() {}\" +\n         \"extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));\",\n-        \"Parse error. expected closing }\");\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testLends8() throws Exception {\n         \"/** @constructor */ function Foo() {}\" +\n         \"extend(Foo, /** @lends {!Foo} */ ({bar: 1}));\",\n         Lists.newArrayList(\n-            \"Parse error. expected closing }\",\n-            \"Parse error. missing object name in @lends tag\"));\n+            \"Bad type annotation. expected closing }\",\n+            \"Bad type annotation. missing object name in @lends tag\"));\n   }\n \n   public void testDeclaredNativeTypeEquality() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         \"function Foo() {}\" +\n         \"Foo.prototype.bar = 1;\" +\n         \"var x = new Foo();\",\n-        RhinoErrorReporter.PARSE_ERROR);\n+        RhinoErrorReporter.TYPE_PARSE_ERROR);\n     ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n     assertEquals(\"Foo\", x.toString());\n     assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n         \"function Foo() {}\" +\n         \"Foo.prototype = {bar: 1};\" +\n         \"var x = new Foo();\",\n-        RhinoErrorReporter.PARSE_ERROR);\n+        RhinoErrorReporter.TYPE_PARSE_ERROR);\n     ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n     assertEquals(\"Foo\", x.toString());\n     // Should be true\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n   public void testParseNamedTypeError1() throws Exception {\n     // To avoid parsing ambiguities, type names must end in a '.' to\n     // get the continuation behavior.\n-    parse(\"@type {!goog\\n * .Bar} */\", \"expected closing }\");\n+    parse(\"@type {!goog\\n * .Bar} */\",\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseNamedTypeError2() throws Exception {\n-    parse(\"@type {!goog.\\n * Bar\\n * .Baz} */\", \"expected closing }\");\n+    parse(\"@type {!goog.\\n * Bar\\n * .Baz} */\",\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testTypedefType1() throws Exception {\n   }\n \n   public void testParseUnionType10() throws Exception {\n-    parse(\"@type {string|}*/\", \"type not recognized due to syntax error\");\n+    parse(\"@type {string|}*/\",\n+        \"Bad type annotation. type not recognized due to syntax error\");\n   }\n \n   public void testParseUnionType11() throws Exception {\n-    parse(\"@type {(string,)}*/\", \"type not recognized due to syntax error\");\n+    parse(\"@type {(string,)}*/\",\n+        \"Bad type annotation. type not recognized due to syntax error\");\n   }\n \n   public void testParseUnionType12() throws Exception {\n-    parse(\"@type {()}*/\", \"type not recognized due to syntax error\");\n+    parse(\"@type {()}*/\",\n+        \"Bad type annotation. type not recognized due to syntax error\");\n   }\n \n   public void testParseUnionType13() throws Exception {\n \n   public void testParseUnionTypeError1() throws Exception {\n     parse(\"@type {(string,|number)} */\",\n-        \"type not recognized due to syntax error\");\n+        \"Bad type annotation. type not recognized due to syntax error\");\n   }\n \n   public void testParseUnknownType1() throws Exception {\n   }\n \n   public void testParseFunctionalTypeError1() throws Exception {\n-    parse(\"@type {function number):string}*/\", \"missing opening (\");\n+    parse(\"@type {function number):string}*/\",\n+        \"Bad type annotation. missing opening (\");\n   }\n \n   public void testParseFunctionalTypeError2() throws Exception {\n-    parse(\"@type {function( number}*/\", \"missing closing )\");\n+    parse(\"@type {function( number}*/\",\n+        \"Bad type annotation. missing closing )\");\n   }\n \n   public void testParseFunctionalTypeError3() throws Exception {\n     parse(\"@type {function(...[number], string)}*/\",\n-        \"variable length argument must be last\");\n+        \"Bad type annotation. variable length argument must be last\");\n   }\n \n   public void testParseFunctionalTypeError4() throws Exception {\n     parse(\"@type {function(string, ...[number], boolean):string}*/\",\n-        \"variable length argument must be last\");\n+        \"Bad type annotation. variable length argument must be last\");\n   }\n \n   public void testParseFunctionalTypeError5() throws Exception {\n-    parse(\"@type {function (thi:Array)}*/\", \"missing closing )\");\n+    parse(\"@type {function (thi:Array)}*/\",\n+        \"Bad type annotation. missing closing )\");\n   }\n \n   public void testParseFunctionalTypeError6() throws Exception {\n   }\n \n   public void testParseFunctionalTypeError7() throws Exception {\n-    parse(\"@type {function(...[number)}*/\", \"missing closing ]\");\n+    parse(\"@type {function(...[number)}*/\",\n+        \"Bad type annotation. missing closing ]\");\n   }\n \n   public void testParseFunctionalTypeError8() throws Exception {\n-    parse(\"@type {function(...number])}*/\", \"missing opening [\");\n+    parse(\"@type {function(...number])}*/\",\n+        \"Bad type annotation. missing opening [\");\n   }\n \n   public void testParseFunctionalTypeError9() throws Exception {\n-    parse(\"@type {function (new:Array, this:Object)} */\", \"missing closing )\");\n+    parse(\"@type {function (new:Array, this:Object)} */\",\n+        \"Bad type annotation. missing closing )\");\n   }\n \n   public void testParseFunctionalTypeError10() throws Exception {\n-    parse(\"@type {function (this:Array, new:Object)} */\", \"missing closing )\");\n+    parse(\"@type {function (this:Array, new:Object)} */\",\n+        \"Bad type annotation. missing closing )\");\n   }\n \n   public void testParseFunctionalTypeError11() throws Exception {\n-    parse(\"@type {function (Array, new:Object)} */\", \"missing closing )\");\n+    parse(\"@type {function (Array, new:Object)} */\",\n+        \"Bad type annotation. missing closing )\");\n   }\n \n   public void testParseFunctionalTypeError12() throws Exception {\n   }\n \n   public void testParseArrayTypeError1() throws Exception {\n-    parse(\"@type {[number}*/\", \"missing closing ]\");\n+    parse(\"@type {[number}*/\",\n+        \"Bad type annotation. missing closing ]\");\n   }\n \n   public void testParseArrayTypeError2() throws Exception {\n-    parse(\"@type {number]}*/\", \"expected closing }\");\n+    parse(\"@type {number]}*/\",\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseArrayTypeError3() throws Exception {\n-    parse(\"@type {[(number,boolean,Object?])]}*/\", \"missing closing )\");\n+    parse(\"@type {[(number,boolean,Object?])]}*/\",\n+        \"Bad type annotation. missing closing )\");\n   }\n \n   public void testParseArrayTypeError4() throws Exception {\n     parse(\"@type {(number,boolean,[Object?)]}*/\",\n-        \"missing closing ]\");\n+        \"Bad type annotation. missing closing ]\");\n   }\n \n   private void testParseType(String type) throws Exception {\n \n   public void testParseThisType3() throws Exception {\n     parse(\"@type {number}\\n@this goog.foo.Bar*/\",\n-        \"type annotation incompatible with other annotations\");\n+        \"Bad type annotation. type annotation incompatible \" +\n+        \"with other annotations\");\n   }\n \n   public void testParseThisType4() throws Exception {\n \n   public void testParseParam9() throws Exception {\n     parse(\"@param {...number=} index */\",\n-        \"expected closing }\", \"expecting a variable name in a @param tag\");\n+        \"Bad type annotation. expected closing }\",\n+        \"Bad type annotation. expecting a variable name in a @param tag\");\n   }\n \n   public void testParseParam10() throws Exception {\n-    parse(\"@param {...number index */\", \"expected closing }\");\n+    parse(\"@param {...number index */\",\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseParam11() throws Exception {\n-    parse(\"@param {number= index */\", \"expected closing }\");\n+    parse(\"@param {number= index */\",\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseParam12() throws Exception {\n   }\n \n   public void testParseParam15() throws Exception {\n-    JSDocInfo info = parse(\"@param {string} [index */\", \"missing closing ]\");\n+    JSDocInfo info = parse(\"@param {string} [index */\",\n+        \"Bad type annotation. missing closing ]\");\n     assertEquals(1, info.getParameterCount());\n     assertTypeEquals(STRING_TYPE, info.getParameterType(\"index\"));\n   }\n \n   public void testParseRecordType11() throws Exception {\n     parseFull(\"/** @param {{a : b} n\\n*/\",\n-              \"expected closing }\");\n+              \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseRecordType12() throws Exception {\n     parseFull(\"/** @param {{!hello : hey}} n\\n*/\",\n-              \"type not recognized due to syntax error\");\n+              \"Bad type annotation. type not recognized due to syntax error\");\n   }\n \n   public void testParseRecordType13() throws Exception {\n \n   public void testParseParamError1() throws Exception {\n     parseFull(\"/** @param\\n*/\",\n-        \"expecting a variable name in a @param tag\");\n+        \"Bad type annotation. expecting a variable name in a @param tag\");\n   }\n \n   public void testParseParamError2() throws Exception {\n     parseFull(\"/** @param {Number}*/\",\n-        \"expecting a variable name in a @param tag\");\n+        \"Bad type annotation. expecting a variable name in a @param tag\");\n   }\n \n   public void testParseParamError3() throws Exception {\n     parseFull(\"/** @param {Number}\\n*/\",\n-        \"expecting a variable name in a @param tag\");\n+        \"Bad type annotation. expecting a variable name in a @param tag\");\n   }\n \n   public void testParseParamError4() throws Exception {\n     parseFull(\"/** @param {Number}\\n* * num */\",\n-        \"expecting a variable name in a @param tag\");\n+        \"Bad type annotation. expecting a variable name in a @param tag\");\n   }\n \n   public void testParseParamError5() throws Exception {\n     parse(\"@param {number} x \\n * @param {string} x */\",\n-        \"duplicate variable name \\\"x\\\"\");\n+        \"Bad type annotation. duplicate variable name \\\"x\\\"\");\n   }\n \n   public void testParseExtends1() throws Exception {\n \n   public void testParseExtends5() throws Exception {\n     assertTypeEquals(STRING_OBJECT_TYPE,\n-        parse(\"@extends {String*/\", \"expected closing }\").getBaseType());\n+        parse(\"@extends {String*/\",\n+              \"Bad type annotation. expected closing }\").getBaseType());\n   }\n \n   public void testParseExtends6() throws Exception {\n   }\n \n   public void testParseExtendsNullable1() throws Exception {\n-    parse(\"@extends {Base?} */\", \"expected closing }\");\n+    parse(\"@extends {Base?} */\", \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseExtendsNullable2() throws Exception {\n-    parse(\"@extends Base? */\", \"expected end of line or comment\");\n+    parse(\"@extends Base? */\",\n+        \"Bad type annotation. expected end of line or comment\");\n   }\n \n   public void testParseEnum1() throws Exception {\n   }\n \n   public void testParseLends3() throws Exception {\n-    parse(\"@lends {name */\", \"expected closing }\");\n+    parse(\"@lends {name */\", \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseLends4() throws Exception {\n-    parse(\"@lends {} */\", \"missing object name in @lends tag\");\n+    parse(\"@lends {} */\",\n+        \"Bad type annotation. missing object name in @lends tag\");\n   }\n \n   public void testParseLends5() throws Exception {\n-    parse(\"@lends } */\", \"missing object name in @lends tag\");\n+    parse(\"@lends } */\",\n+        \"Bad type annotation. missing object name in @lends tag\");\n   }\n \n   public void testParseLends6() throws Exception {\n     parse(\"@lends {string} \\n * @lends {string} */\",\n-        \"@lends tag incompatible with other annotations\");\n+        \"Bad type annotation. @lends tag incompatible with other annotations\");\n   }\n \n   public void testParseLends7() throws Exception {\n     parse(\"@type {string} \\n * @lends {string} */\",\n-        \"@lends tag incompatible with other annotations\");\n+        \"Bad type annotation. @lends tag incompatible with other annotations\");\n   }\n \n   public void testParsePreserve() throws Exception {\n \n   public void testParseDefine2() throws Exception {\n     assertTypeEquals(STRING_TYPE,\n-        parse(\"@define {string*/\", \"expected closing }\").getType());\n+        parse(\"@define {string*/\",\n+              \"Bad type annotation. expected closing }\").getType());\n   }\n \n   public void testParseDefine3() throws Exception {\n \n   public void testParseDefineErrors2() throws Exception {\n     parse(\"@define {string}\\n @enum {string} */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n \n   public void testParseDefineErrors8() throws Exception {\n     parse(\"@define {string}\\n @type string */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   }\n \n   public void testParseOverride2() throws Exception {\n-    parse(\"@override\\n@override*/\", \"extra @override/@inheritDoc tag\");\n+    parse(\"@override\\n@override*/\",\n+        \"Bad type annotation. extra @override/@inheritDoc tag\");\n   }\n \n   public void testParseInheritDoc1() throws Exception {\n   }\n \n   public void testParseInheritDoc2() throws Exception {\n-    parse(\"@override\\n@inheritDoc*/\", \"extra @override/@inheritDoc tag\");\n+    parse(\"@override\\n@inheritDoc*/\",\n+        \"Bad type annotation. extra @override/@inheritDoc tag\");\n   }\n \n   public void testParseInheritDoc3() throws Exception {\n-    parse(\"@inheritDoc\\n@inheritDoc*/\", \"extra @override/@inheritDoc tag\");\n+    parse(\"@inheritDoc\\n@inheritDoc*/\",\n+        \"Bad type annotation. extra @override/@inheritDoc tag\");\n   }\n \n   public void testParseNoAlias1() throws Exception {\n \n   public void testFullRegression1() throws Exception {\n     parseFull(\"/** @param (string,number) foo*/function bar(foo){}\",\n-        \"expecting a variable name in a @param tag\");\n+        \"Bad type annotation. expecting a variable name in a @param tag\");\n   }\n \n   public void testFullRegression2() throws Exception {\n     parseFull(\"/** @param {string,number) foo*/function bar(foo){}\",\n-        \"expected closing }\",\n-        \"expecting a variable name in a @param tag\");\n+        \"Bad type annotation. expected closing }\",\n+        \"Bad type annotation. expecting a variable name in a @param tag\");\n   }\n \n   public void testFullRegression3() throws Exception {\n \n   public void testBug907488() throws Exception {\n     parse(\"@type {number,null} */\",\n-        \"expected closing }\");\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testBug907494() throws Exception {\n     parse(\"@return {Object,undefined} */\",\n-        \"expected closing }\");\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testBug909468() throws Exception {\n     parse(\"@extends {(x)}*/\",\n-        \"expecting a type name\");\n+        \"Bad type annotation. expecting a type name\");\n   }\n \n   public void testParseInterface() throws Exception {\n \n   public void testParseDuplicateImplicitCast() throws Exception {\n     parse(\"@type {string} \\n * @implicitCast \\n * @implicitCast*/\",\n-          \"extra @implicitCast tag\");\n+          \"Bad type annotation. extra @implicitCast tag\");\n   }\n \n   public void testParseInterfaceDoubled() throws Exception {\n         \"* @interface\\n\" +\n         \"* @interface\\n\" +\n         \"*/\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n         \"* @implements {Smth}\\n\" +\n         \"* @implements {Smth}\\n\" +\n         \"*/\",\n-        \"duplicate @implements tag\");\n+        \"Bad type annotation. duplicate @implements tag\");\n   }\n \n   public void testParseImplementsNoName() throws Exception {\n     parse(\"* @implements {} */\",\n-        \"expecting a type name\");\n+        \"Bad type annotation. expecting a type name\");\n   }\n \n   public void testParseImplementsMissingRC() throws Exception {\n     parse(\"* @implements {Smth */\",\n-        \"expected closing }\");\n+        \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseImplementsNullable1() throws Exception {\n-    parse(\"@implements {Base?} */\", \"expected closing }\");\n+    parse(\"@implements {Base?} */\", \"Bad type annotation. expected closing }\");\n   }\n \n   public void testParseImplementsNullable2() throws Exception {\n-    parse(\"@implements Base? */\", \"expected end of line or comment\");\n+    parse(\"@implements Base? */\",\n+        \"Bad type annotation. expected end of line or comment\");\n   }\n \n   public void testInterfaceExtends() throws Exception {\n \n   public void testBadExtendsWithNullable() throws Exception {\n     JSDocInfo jsdoc = parse(\"@constructor\\n * @extends {Object?} */\",\n-        \"expected closing }\");\n+        \"Bad type annotation. expected closing }\");\n     assertTrue(jsdoc.isConstructor());\n     assertTypeEquals(OBJECT_TYPE, jsdoc.getBaseType());\n   }\n \n   public void testBadImplementsWithNullable() throws Exception {\n   JSDocInfo jsdoc = parse(\"@implements {Disposable?}\\n * @constructor */\",\n-      \"expected closing }\");\n+      \"Bad type annotation. expected closing }\");\n     assertTrue(jsdoc.isConstructor());\n     assertTypeEquals(registry.createNamedType(\"Disposable\", null, -1, -1),\n         jsdoc.getImplementedInterfaces().get(0));\n \n   public void testBadTypeDefInterfaceAndConstructor1() throws Exception {\n     JSDocInfo jsdoc = parse(\"@interface\\n@constructor*/\",\n-        \"cannot be both an interface and a constructor\");\n+        \"Bad type annotation. cannot be both an interface and a constructor\");\n     assertTrue(jsdoc.isInterface());\n   }\n \n   public void testBadTypeDefInterfaceAndConstructor2() throws Exception {\n     JSDocInfo jsdoc = parse(\"@constructor\\n@interface*/\",\n-        \"cannot be both an interface and a constructor\");\n+        \"Bad type annotation. cannot be both an interface and a constructor\");\n     assertTrue(jsdoc.isConstructor());\n   }\n \n \n   public void testTypeTagConflict1() throws Exception {\n     parse(\"@constructor \\n * @constructor */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict2() throws Exception {\n     parse(\"@interface \\n * @interface */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict3() throws Exception {\n     parse(\"@constructor \\n * @interface */\",\n-        \"cannot be both an interface and a constructor\");\n+        \"Bad type annotation. cannot be both an interface and a constructor\");\n   }\n \n   public void testTypeTagConflict4() throws Exception {\n     parse(\"@interface \\n * @constructor */\",\n-        \"cannot be both an interface and a constructor\");\n+        \"Bad type annotation. cannot be both an interface and a constructor\");\n   }\n \n   public void testTypeTagConflict5() throws Exception {\n     parse(\"@interface \\n * @type {string} */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict6() throws Exception {\n     parse(\"@typedef {string} \\n * @type {string} */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict7() throws Exception {\n     parse(\"@typedef {string} \\n * @constructor */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict8() throws Exception {\n     parse(\"@typedef {string} \\n * @return {boolean} */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict9() throws Exception {\n     parse(\"@enum {string} \\n * @return {boolean} */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict10() throws Exception {\n     parse(\"@this {Object} \\n * @enum {boolean} */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict11() throws Exception {\n     parse(\"@param {Object} x \\n * @type {boolean} */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict12() throws Exception {\n     parse(\"@typedef {boolean} \\n * @param {Object} x */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n   public void testTypeTagConflict13() throws Exception {\n     parse(\"@typedef {boolean} \\n * @extends {Object} */\",\n+        \"Bad type annotation. \" +\n         \"type annotation incompatible with other annotations\");\n   }\n \n-  public void testParserWithTemplateTypeNameMisisng() {\n-    parse(\"@template */\", \"@template tag missing type name\");\n-  }\n-\n   public void testParserWithTemplateTypeNameMissing() {\n-    parse(\"@template T\\n@template V */\", \"@template tag at most once\");\n+    parse(\"@template */\",\n+        \"Bad type annotation. @template tag missing type name\");\n+  }\n+\n+  public void testParserWithTemplateDuplicated() {\n+    parse(\"@template T\\n@template V */\",\n+        \"Bad type annotation. @template tag at most once\");\n   }\n \n   public void testWhitelistedNewAnnotations() {\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n       ScriptRuntime.getMessage0(\"msg.bad.prop\");\n \n   private static final String MISSING_GT_MESSAGE =\n+      \"Bad type annotation. \" +\n       com.google.javascript.rhino.ScriptRuntime.getMessage0(\n           \"msg.jsdoc.missing.gt\");\n \n         parse(\"C.prototype.say=function(nums) {alert(nums.join(','));};\"),\n         parse(\"/** @param {bool!*%E$} */\" +\n             \"C.prototype.say=function(nums) {alert(nums.join(','));};\",\n-              \"expected closing }\",\n-              \"expecting a variable name in a @param tag\"));\n+            \"Bad type annotation. expected closing }\",\n+            \"Bad type annotation. expecting a variable name in a @param tag\"));\n   }\n \n   public void testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception {", "timestamp": 1299531576, "metainfo": ""}