{"sha": "3faef1d4959a55ebd86a09cd5395afb54ab5ec25", "log": "Handle circular typedefs in a more robust way. This comes up when we switch to different type-resolution algorithms that resolve the forward-declared type later and ubox it. Sadly, i don't have a good test case for this right now.  R=johnlenz DELTA=17  (10 added, 1 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=764010   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       // TODO(nicksantos|user): This is a terrible, terrible hack\n       // to bail out on recusive typedefs. We'll eventually need\n       // to handle these properly.\n-      typeRegistry.forwardDeclareType(typedef);\n+      typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n \n       JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n       if (realType == null) {\n                 t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n       }\n \n-      typeRegistry.declareType(typedef, realType);\n+      typeRegistry.overwriteDeclaredType(typedef, realType);\n       if (candidate.getType() == Token.GETPROP) {\n         defineSlot(candidate, candidate.getParent(),\n             getNativeType(NO_TYPE), false);\n         // TODO(nicksantos|user): This is a terrible, terrible hack\n         // to bail out on recusive typedefs. We'll eventually need\n         // to handle these properly.\n-        typeRegistry.forwardDeclareType(typedef);\n+        typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n \n         JSDocInfo info = candidate.getJSDocInfo();\n         JSType realType = null;\n                   t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n         }\n \n-        typeRegistry.declareType(typedef, realType);\n+        typeRegistry.overwriteDeclaredType(typedef, realType);\n \n         // Duplicate typedefs get handled when we try to register\n         // this typedef in the scope.\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.LinkedHashMultimap;\n import com.google.common.collect.Maps;\n   }\n \n   /**\n-   * Records declared type names. Given the limited scopes of JavaScript, all\n-   * named types are dumped in a common global scope. We may need to revise this\n-   * assumption in the future.\n+   * Records declared global type names. This makes resolution faster\n+   * and more robust in the common case.\n    *\n    * @param name The name of the type to be recorded.\n    * @param t The actual type being associated with the name.\n     }\n     register(t, name);\n     return true;\n+  }\n+\n+  /**\n+   * Overrides a declared global type name. Throws an exception if this\n+   * type name hasn't been declared yet.\n+   */\n+  public void overwriteDeclaredType(String name, JSType t) {\n+    Preconditions.checkState(namesToTypes.containsKey(name));\n+    register(t, name);\n   }\n \n   /**", "timestamp": 1288197829, "metainfo": ""}