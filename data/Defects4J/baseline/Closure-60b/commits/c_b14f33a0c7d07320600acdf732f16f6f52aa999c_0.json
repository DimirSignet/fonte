{"sha": "b14f33a0c7d07320600acdf732f16f6f52aa999c", "log": "Fold more associative operations. Fixes issue 245  R=nicksantos DELTA=250  (139 added, 61 deleted, 50 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1041044   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   /**\n    * Returns true if the operator is associative.\n    * e.g. (a * b) * c = a * (b * c)\n-   * Note: \"+\" is not associative because it is also the concatentation\n+   * Note: \"+\" is not associative because it is also the concatenation\n    * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n    */\n   static boolean isAssociative(int type) {\n       case Token.MUL:\n       case Token.AND:\n       case Token.OR:\n+      case Token.BITOR:\n+      case Token.BITAND:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * Returns true if the operator is commutative.\n+   * e.g. (a * b) * c = c * (b * a)\n+   * Note 1: \"+\" is not commutative because it is also the concatenation\n+   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n+   * Note 2: only operations on literals and pure functions are commutative.\n+   */\n+  static boolean isCommutative(int type) {\n+    switch (type) {\n+      case Token.MUL:\n       case Token.BITOR:\n       case Token.BITAND:\n         return true;\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n       case Token.OR:\n         return tryFoldAndOr(subtree, left, right);\n \n-      case Token.BITAND:\n-      case Token.BITOR:\n-        return tryFoldBitAndOr(subtree, left, right);\n-\n       case Token.LSH:\n       case Token.RSH:\n       case Token.URSH:\n         return tryFoldAdd(subtree, left, right);\n \n       case Token.SUB:\n-      case Token.MUL:\n       case Token.DIV:\n       case Token.MOD:\n-        return tryFoldArithmetic(subtree, left, right);\n+        if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\n+          return tryFoldOp(subtree, left, right);\n+        } else {\n+          return subtree;\n+        }\n+\n+      case Token.MUL:\n+      case Token.BITAND:\n+      case Token.BITOR:\n+        if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\n+          return tryFoldOp(subtree, left, right);\n+        } else {\n+          return tryFoldLeftChildOp(subtree, left, right);\n+        }\n \n       case Token.LT:\n       case Token.GT:\n    *  - The left child is also and add expression\n    *  - The right child is a constant value\n    *  - The left child's right child is a STRING constant.\n-   *\n-   * WARNING: If javascript ever adds operator overloading, this will\n-   * probably stop being correct.\n    */\n   private Node tryFoldLeftChildAdd(Node n, Node left, Node right) {\n \n       }\n     } else {\n       // Try arithmetic add\n-      return tryFoldArithmetic(n, left, right);\n+      return tryFoldOp(n, left, right);\n     }\n \n     return n;\n   /**\n    * Try to fold arithmetic binary operators\n    */\n-  private Node tryFoldArithmetic(Node n, Node left, Node right) {\n-    if (left.getType() == Token.NUMBER &&\n-        right.getType() == Token.NUMBER) {\n-      double result;\n-      double lval = left.getDouble();\n-      double rval = right.getDouble();\n-\n-      switch (n.getType()) {\n-        case Token.ADD:\n-          result = lval + rval;\n-          break;\n-        case Token.SUB:\n-          result = lval - rval;\n-          break;\n-        case Token.MUL:\n-          result = lval * rval;\n-          break;\n-        case Token.MOD:\n-          if (rval == 0) {\n-            error(DIVIDE_BY_0_ERROR, right);\n-            return n;\n-          }\n-          result = lval % rval;\n-          break;\n-        case Token.DIV:\n-          if (rval == 0) {\n-            error(DIVIDE_BY_0_ERROR, right);\n-            return n;\n-          }\n-          result = lval / rval;\n-          break;\n-        default:\n-          throw new Error(\"Unknown arithmetic operator\");\n-      }\n-\n-      // length of the left and right value plus 1 byte for the operator.\n-      if (String.valueOf(result).length() <=\n-          String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n-\n-          // Do not try to fold arithmetic for numbers > 2^53. After that\n-          // point, fixed-point math starts to break down and become inaccurate.\n-          Math.abs(result) <= MAX_FOLD_NUMBER) {\n-        Node newNumber = Node.newNumber(result);\n-        n.getParent().replaceChild(n, newNumber);\n+  private Node tryFoldOp(Node n, Node left, Node right) {\n+    Node result = performArithmeticOp(n.getType(), left, right);\n+    if (result != null) {\n+      n.getParent().replaceChild(n, result);\n+      reportCodeChange();\n+      return result;\n+    }\n+    return n;\n+  }\n+\n+  /**\n+   * Try to fold arithmetic binary operators\n+   */\n+  private Node performArithmeticOp(int opType, Node left, Node right) {\n+    Preconditions.checkState(left.getType() == Token.NUMBER);\n+    Preconditions.checkState(right.getType() == Token.NUMBER);\n+    double result;\n+    double lval = left.getDouble();\n+    double rval = right.getDouble();\n+\n+    switch (opType) {\n+      case Token.BITAND:\n+        if (!areValidInts(lval, rval)) {\n+          return null;\n+        }\n+        result = (int)lval & (int)rval;\n+        break;\n+      case Token.BITOR:\n+        if (!areValidInts(lval, rval)) {\n+          return null;\n+        }\n+        result = (int)lval | (int)rval;\n+        break;\n+      case Token.ADD:\n+        result = lval + rval;\n+        break;\n+      case Token.SUB:\n+        result = lval - rval;\n+        break;\n+      case Token.MUL:\n+        result = lval * rval;\n+        break;\n+      case Token.MOD:\n+        if (rval == 0) {\n+          error(DIVIDE_BY_0_ERROR, right);\n+          return null;\n+        }\n+        result = lval % rval;\n+        break;\n+      case Token.DIV:\n+        if (rval == 0) {\n+          error(DIVIDE_BY_0_ERROR, right);\n+          return null;\n+        }\n+        result = lval / rval;\n+        break;\n+      default:\n+        throw new Error(\"Unexpected arithmetic operator\");\n+    }\n+\n+    // TODO(johnlenz): consider removing the result length check.\n+    // length of the left and right value plus 1 byte for the operator.\n+    if (String.valueOf(result).length() <=\n+        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n+\n+        // Do not try to fold arithmetic for numbers > 2^53. After that\n+        // point, fixed-point math starts to break down and become inaccurate.\n+        Math.abs(result) <= MAX_FOLD_NUMBER) {\n+      Node newNumber = Node.newNumber(result);\n+      return newNumber;\n+    }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * @return Whether the double can be precisely represented as a int.\n+   */\n+  private boolean isValidInt(double val) {\n+    return !(val < Integer.MIN_VALUE || val > Integer.MAX_VALUE)\n+        && val == (int)val;\n+  }\n+\n+  /**\n+   * @return Whether the parameters are doubles can be precisely represented\n+   * as a int.\n+   */\n+  private boolean areValidInts(double val1, double val2) {\n+    return isValidInt(val1) && isValidInt(val2);\n+  }\n+\n+  /**\n+   * Expressions such as [foo() * 10 * 20] generate parse trees\n+   * where no node has two const children ((foo() * 10) * 20), so\n+   * performArithmeticOp() won't fold it -- tryFoldLeftChildOp() will.\n+   * Specifically it folds associative expressions where:\n+   *  - The left child is also an associative expression of the same time.\n+   *  - The right child is a constant NUMBER constant.\n+   *  - The left child's right child is a NUMBER constant.\n+   */\n+  private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\n+    int opType = n.getType();\n+    // Note: ADD is not associative when used as a string concat operator.\n+    Preconditions.checkState(\n+      NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType));\n+    // TODO(johnlenz): create and use a getNumberValue.\n+    if (right.getType() == Token.NUMBER && left.getType() == opType) {\n+      Preconditions.checkState(left.getChildCount() == 2);\n+\n+      Node ll = left.getFirstChild();\n+      Node lr = ll.getNext();\n+\n+      Node valueToCombine;\n+      if (ll.getType() == Token.NUMBER) {\n+        valueToCombine = ll;\n+      } else if (lr.getType() == Token.NUMBER) {\n+        valueToCombine = lr;\n+      } else {\n+        // Nothing to do.\n+        return n;\n+      }\n+\n+      Node replacement = performArithmeticOp(opType, valueToCombine, right);\n+      if (replacement != null) {\n+        left.removeChild(valueToCombine);\n+        n.replaceChild(left, left.removeFirstChild());\n+        n.replaceChild(right, replacement);\n         reportCodeChange();\n-        return newNumber;\n-      }\n-   }\n+      }\n+    }\n+\n     return n;\n   }\n \n       // a + 7 or 6 + a\n       return tryFoldLeftChildAdd(node, left, right);\n     }\n-  }\n-\n-  /**\n-   * Try to fold arithmetic binary operators\n-   */\n-  private Node tryFoldBitAndOr(Node n, Node left, Node right) {\n-    Preconditions.checkArgument(n.getType() == Token.BITAND\n-        || n.getType() == Token.BITOR);\n-\n-    if (left.getType() != Token.NUMBER ||\n-        right.getType() != Token.NUMBER) {\n-      return n;\n-    }\n-\n-    double resultDouble;\n-    double lval = left.getDouble();\n-    double rval = right.getDouble();\n-\n-    // For now, we are being extra conservative, and only folding ints in\n-    // the range MIN_VALUE-MAX_VALUE\n-    if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE ||\n-        rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {\n-\n-      // Fall back through and let the javascript use the larger values\n-      return n;\n-    }\n-\n-    // Convert the numbers to ints\n-    int lvalInt = (int) lval;\n-    if (lvalInt != lval) {\n-      return n;\n-    }\n-\n-    int rvalInt = (int) rval;\n-    if (rvalInt != rval) {\n-      return n;\n-    }\n-\n-    switch (n.getType()) {\n-      case Token.BITAND:\n-        resultDouble = lvalInt & rvalInt;\n-        break;\n-      case Token.BITOR:\n-        resultDouble = lvalInt | rvalInt;\n-        break;\n-      default:\n-        throw new Error(\"Unknown bitwise operator\");\n-    }\n-\n-    Node newNumber = Node.newNumber(resultDouble);\n-    n.getParent().replaceChild(n, newNumber);\n-    reportCodeChange();\n-    return newNumber;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = 1 | 3\", \"x = 3\");\n     fold(\"x = 1 | 1.1\", \"x = 1|1.1\");\n     fold(\"x = 1 | 3000000000\", \"x = 1|3000000000\");\n+  }\n+\n+  public void testFoldBitwiseOp2() {\n+    fold(\"x = y & 1 & 1\", \"x = y & 1\");\n+    fold(\"x = y & 1 & 2\", \"x = y & 0\");\n+    fold(\"x = y & 3 & 1\", \"x = y & 1\");\n+    fold(\"x = 3 & y & 1\", \"x = y & 1\");\n+    fold(\"x = y & 3 & 3\", \"x = y & 3\");\n+    fold(\"x = 3 & y & 3\", \"x = y & 3\");\n+\n+    fold(\"x = y | 1 | 1\", \"x = y | 1\");\n+    fold(\"x = y | 1 | 2\", \"x = y | 3\");\n+    fold(\"x = y | 3 | 1\", \"x = y | 3\");\n+    fold(\"x = 3 | y | 1\", \"x = y | 3\");\n+    fold(\"x = y | 3 | 3\", \"x = y | 3\");\n+    fold(\"x = 3 | y | 3\", \"x = y | 3\");\n   }\n \n   public void testFoldBitwiseOpStringCompare() {\n     fold(\"x = 1 % 0\", \"\", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);\n   }\n \n+  public void testFoldArithmetic2() {\n+    foldSame(\"x = y + 10 + 20\");\n+    foldSame(\"x = y / 2 / 4\");\n+    fold(\"x = y * 2.25 * 3\", \"x = y * 6.75\");\n+    fold(\"z = x * y\", \"z = x * y\");\n+    fold(\"x = y * 5\", \"x = y * 5\");\n+    fold(\"x = y + (z * 24 * 60 * 60 * 1000)\", \"x = y + z * 864E5\");\n+  }\n+\n   public void testFoldArithmeticStringComp() {\n     // Negative Numbers.\n     assertResultString(\"x = 10 - 20\", \"x=-10\");", "timestamp": 1288629426, "metainfo": ""}