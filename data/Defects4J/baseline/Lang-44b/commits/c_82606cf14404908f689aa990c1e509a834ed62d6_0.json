{"sha": "82606cf14404908f689aa990c1e509a834ed62d6", "log": "introducing utility class from Justin Couch   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/IntHashMap.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+/**\n+ * Note: originally released under the GNU LGPL v2.1, but rereleased by the original author under the ASF license (above).\n+ */\n+package org.apache.commons.lang;\n+\n+/**\n+ * A hash map that uses primitive ints for the key rather than objects.\n+ * Note that this class is for internal optimization purposes only, and may\n+ * not be supported in future releases of Jakarta Commons Lang.  Utilities of\n+ * this sort may be included in future releases of Jakarta Commons Collections.\n+ *\n+ * @author Justin Couch\n+ * @author Alex Chaffee (alex@apache.org)\n+ * @version $Revision: 1.1 $\n+ * @see java.util.HashMap\n+ */\n+public class IntHashMap\n+{\n+    /**\n+     * The hash table data.\n+     */\n+    private transient Entry table[];\n+\n+    /**\n+     * The total number of entries in the hash table.\n+     */\n+    private transient int count;\n+\n+    /**\n+     * The table is rehashed when its size exceeds this threshold.  (The\n+     * value of this field is (int)(capacity * loadFactor).)\n+     *\n+     * @serial\n+     */\n+    private int threshold;\n+\n+    /**\n+     * The load factor for the hashtable.\n+     *\n+     * @serial\n+     */\n+    private float loadFactor;\n+\n+    /**\n+     * Innerclass that acts as a datastructure to create a new entry in the\n+     * table.\n+     */\n+    private static class Entry\n+    {\n+        int hash;\n+        int key;\n+        Object value;\n+        Entry next;\n+\n+        /**\n+         * Create a new entry with the given values.\n+         *\n+         * @param hash The code used to hash the object with\n+         * @param key The key used to enter this in the table\n+         * @param value The value for this key\n+         * @param next A reference to the next entry in the table\n+         */\n+        protected Entry(int hash, int key, Object value, Entry next)\n+        {\n+            this.hash = hash;\n+            this.key = key;\n+            this.value = value;\n+            this.next = next;\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new, empty hashtable with a default capacity and load\n+     * factor, which is <tt>20</tt> and <tt>0.75</tt> respectively.\n+     */\n+    public IntHashMap()\n+    {\n+        this(20, 0.75f);\n+    }\n+\n+    /**\n+     * Constructs a new, empty hashtable with the specified initial capacity\n+     * and default load factor, which is <tt>0.75</tt>.\n+     *\n+     * @param  initialCapacity the initial capacity of the hashtable.\n+     * @throws IllegalArgumentException if the initial capacity is less\n+     *   than zero.\n+     */\n+    public IntHashMap(int initialCapacity)\n+    {\n+        this(initialCapacity, 0.75f);\n+    }\n+\n+    /**\n+     * Constructs a new, empty hashtable with the specified initial\n+     * capacity and the specified load factor.\n+     *\n+     * @param initialCapacity the initial capacity of the hashtable.\n+     * @param loadFactor the load factor of the hashtable.\n+     * @throws IllegalArgumentException  if the initial capacity is less\n+     *             than zero, or if the load factor is nonpositive.\n+     */\n+    public IntHashMap(int initialCapacity, float loadFactor)\n+    {\n+        if (initialCapacity < 0)\n+            throw new IllegalArgumentException(\"Illegal Capacity: \" +\n+                    initialCapacity);\n+        if (loadFactor <= 0)\n+            throw new IllegalArgumentException(\"Illegal Load: \" + loadFactor);\n+\n+        if (initialCapacity == 0)\n+            initialCapacity = 1;\n+\n+        this.loadFactor = loadFactor;\n+        table = new Entry[initialCapacity];\n+        threshold = (int) (initialCapacity * loadFactor);\n+    }\n+\n+    /**\n+     * Returns the number of keys in this hashtable.\n+     *\n+     * @return  the number of keys in this hashtable.\n+     */\n+    public int size()\n+    {\n+        return count;\n+    }\n+\n+    /**\n+     * Tests if this hashtable maps no keys to values.\n+     *\n+     * @return  <code>true</code> if this hashtable maps no keys to values;\n+     *          <code>false</code> otherwise.\n+     */\n+    public boolean isEmpty()\n+    {\n+        return count == 0;\n+    }\n+\n+    /**\n+     * Tests if some key maps into the specified value in this hashtable.\n+     * This operation is more expensive than the <code>containsKey</code>\n+     * method.<p>\n+     *\n+     * Note that this method is identical in functionality to containsValue,\n+     * (which is part of the Map interface in the collections framework).\n+     *\n+     * @param      value   a value to search for.\n+     * @return     <code>true</code> if and only if some key maps to the\n+     *             <code>value</code> argument in this hashtable as\n+     *             determined by the <tt>equals</tt> method;\n+     *             <code>false</code> otherwise.\n+     * @throws  NullPointerException  if the value is <code>null</code>.\n+     * @see        #containsKey(int)\n+     * @see        #containsValue(Object)\n+     * @see        java.util.Map\n+     */\n+    public boolean contains(Object value)\n+    {\n+        if (value == null)\n+        {\n+            throw new NullPointerException();\n+        }\n+\n+        Entry tab[] = table;\n+        for (int i = tab.length; i-- > 0;)\n+        {\n+            for (Entry e = tab[i]; e != null; e = e.next)\n+            {\n+                if (e.value.equals(value))\n+                {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true if this HashMap maps one or more keys to this value.<p>\n+     *\n+     * Note that this method is identical in functionality to contains\n+     * (which predates the Map interface).\n+     *\n+     * @param value value whose presence in this HashMap is to be tested.\n+     * @see    java.util.Map\n+     * @since JDK1.2\n+     */\n+    public boolean containsValue(Object value)\n+    {\n+        return contains(value);\n+    }\n+\n+    /**\n+     * Tests if the specified object is a key in this hashtable.\n+     *\n+     * @param  key  possible key.\n+     * @return <code>true</code> if and only if the specified object is a\n+     *    key in this hashtable, as determined by the <tt>equals</tt>\n+     *    method; <code>false</code> otherwise.\n+     * @see #contains(Object)\n+     */\n+    public boolean containsKey(int key)\n+    {\n+        Entry tab[] = table;\n+        int hash = key;\n+        int index = (hash & 0x7FFFFFFF) % tab.length;\n+        for (Entry e = tab[index]; e != null; e = e.next)\n+        {\n+            if (e.hash == hash)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the value to which the specified key is mapped in this map.\n+     *\n+     * @param   key   a key in the hashtable.\n+     * @return  the value to which the key is mapped in this hashtable;\n+     *          <code>null</code> if the key is not mapped to any value in\n+     *          this hashtable.\n+     * @see     #put(int, Object)\n+     */\n+    public Object get(int key)\n+    {\n+        Entry tab[] = table;\n+        int hash = key;\n+        int index = (hash & 0x7FFFFFFF) % tab.length;\n+        for (Entry e = tab[index]; e != null; e = e.next)\n+        {\n+            if (e.hash == hash)\n+            {\n+                return e.value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Increases the capacity of and internally reorganizes this\n+     * hashtable, in order to accommodate and access its entries more\n+     * efficiently.  This method is called automatically when the\n+     * number of keys in the hashtable exceeds this hashtable's capacity\n+     * and load factor.\n+     */\n+    protected void rehash()\n+    {\n+        int oldCapacity = table.length;\n+        Entry oldMap[] = table;\n+\n+        int newCapacity = oldCapacity * 2 + 1;\n+        Entry newMap[] = new Entry[newCapacity];\n+\n+        threshold = (int) (newCapacity * loadFactor);\n+        table = newMap;\n+\n+        for (int i = oldCapacity; i-- > 0;)\n+        {\n+            for (Entry old = oldMap[i]; old != null;)\n+            {\n+                Entry e = old;\n+                old = old.next;\n+\n+                int index = (e.hash & 0x7FFFFFFF) % newCapacity;\n+                e.next = newMap[index];\n+                newMap[index] = e;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Maps the specified <code>key</code> to the specified\n+     * <code>value</code> in this hashtable. The key cannot be\n+     * <code>null</code>. <p>\n+     *\n+     * The value can be retrieved by calling the <code>get</code> method\n+     * with a key that is equal to the original key.\n+     *\n+     * @param key     the hashtable key.\n+     * @param value   the value.\n+     * @return the previous value of the specified key in this hashtable,\n+     *         or <code>null</code> if it did not have one.\n+     * @throws  NullPointerException  if the key is <code>null</code>.\n+     * @see     #get(int)\n+     */\n+    public Object put(int key, Object value)\n+    {\n+        // Makes sure the key is not already in the hashtable.\n+        Entry tab[] = table;\n+        int hash = key;\n+        int index = (hash & 0x7FFFFFFF) % tab.length;\n+        for (Entry e = tab[index]; e != null; e = e.next)\n+        {\n+            if (e.hash == hash)\n+            {\n+                Object old = e.value;\n+                e.value = value;\n+                return old;\n+            }\n+        }\n+\n+        if (count >= threshold)\n+        {\n+            // Rehash the table if the threshold is exceeded\n+            rehash();\n+\n+            tab = table;\n+            index = (hash & 0x7FFFFFFF) % tab.length;\n+        }\n+\n+        // Creates the new entry.\n+        Entry e = new Entry(hash, key, value, tab[index]);\n+        tab[index] = e;\n+        count++;\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the key (and its corresponding value) from this\n+     * hashtable. This method does nothing if the key is not in the hashtable.\n+     *\n+     * @param   key   the key that needs to be removed.\n+     * @return  the value to which the key had been mapped in this hashtable,\n+     *          or <code>null</code> if the key did not have a mapping.\n+     */\n+    public Object remove(int key)\n+    {\n+        Entry tab[] = table;\n+        int hash = key;\n+        int index = (hash & 0x7FFFFFFF) % tab.length;\n+        for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next)\n+        {\n+            if (e.hash == hash)\n+            {\n+                if (prev != null)\n+                {\n+                    prev.next = e.next;\n+                }\n+                else\n+                {\n+                    tab[index] = e.next;\n+                }\n+                count--;\n+                Object oldValue = e.value;\n+                e.value = null;\n+                return oldValue;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Clears this hashtable so that it contains no keys.\n+     */\n+    public synchronized void clear()\n+    {\n+        Entry tab[] = table;\n+        for (int index = tab.length; --index >= 0;)\n+            tab[index] = null;\n+        count = 0;\n+    }\n+}", "timestamp": 1056855917, "metainfo": ""}