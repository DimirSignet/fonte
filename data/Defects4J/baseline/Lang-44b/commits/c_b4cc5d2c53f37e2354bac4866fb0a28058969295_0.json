{"sha": "b4cc5d2c53f37e2354bac4866fb0a28058969295", "log": "[LANG-356] Add getStartTime to StopWatch.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.lang.time;\n \n /**\n- * <p><code>StopWatch</code> provides a convenient API for timings.</p>\n- * \n- * <p>To start the watch, call {@link #start()}. At this point you can:</p>\n+ * <p>\n+ * <code>StopWatch</code> provides a convenient API for timings.\n+ * </p>\n+ * \n+ * <p>\n+ * To start the watch, call {@link #start()}. At this point you can:\n+ * </p>\n  * <ul>\n- *  <li>{@link #split()} the watch to get the time whilst the watch continues in the\n- *   background. {@link #unsplit()} will remove the effect of the split. At this point,\n- *   these three options are available again.</li>\n- *  <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch\n- *   to continue. Any time between the suspend and resume will not be counted in\n- *   the total. At this point, these three options are available again.</li>\n- *  <li>{@link #stop()} the watch to complete the timing session.</li>\n+ * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n+ * remove the effect of the split. At this point, these three options are available again.</li>\n+ * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n+ * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n+ * <li>{@link #stop()} the watch to complete the timing session.</li>\n  * </ul>\n- *\n- * <p>It is intended that the output methods {@link #toString()} and {@link #getTime()}\n- * should only be called after stop, split or suspend, however a suitable result will\n- * be returned at other points.</p>\n- *\n- * <p>NOTE: As from v2.1, the methods protect against inappropriate calls.\n- * Thus you cannot now call stop before start, resume before suspend or\n- * unsplit before split.</p>\n- *\n- * <p>1. split(), suspend(), or stop() cannot be invoked twice<br />\n+ * \n+ * <p>\n+ * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n+ * split or suspend, however a suitable result will be returned at other points.\n+ * </p>\n+ * \n+ * <p>\n+ * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n+ * resume before suspend or unsplit before split.\n+ * </p>\n+ * \n+ * <p>\n+ * 1. split(), suspend(), or stop() cannot be invoked twice<br />\n  * 2. unsplit() may only be called if the watch has been split()<br />\n  * 3. resume() may only be called if the watch has been suspend()<br />\n- * 4. start() cannot be called twice without calling reset()</p>\n- *\n+ * 4. start() cannot be called twice without calling reset()\n+ * </p>\n+ * \n  * @author Stephen Colebourne\n  * @since 2.0\n  * @version $Id$\n \n     // running states\n     private static final int STATE_UNSTARTED = 0;\n-    private static final int STATE_RUNNING   = 1;\n-    private static final int STATE_STOPPED   = 2;\n+\n+    private static final int STATE_RUNNING = 1;\n+\n+    private static final int STATE_STOPPED = 2;\n+\n     private static final int STATE_SUSPENDED = 3;\n \n     // split state\n     private static final int STATE_UNSPLIT = 10;\n-    private static final int STATE_SPLIT   = 11;\n-\n-    /**\n-     *  The current running state of the StopWatch. \n+\n+    private static final int STATE_SPLIT = 11;\n+\n+    /**\n+     * The current running state of the StopWatch.\n      */\n     private int runningState = STATE_UNSTARTED;\n \n     /**\n-     * Whether the stopwatch has a split time recorded. \n-     */\n-    private int splitState   = STATE_UNSPLIT;\n+     * Whether the stopwatch has a split time recorded.\n+     */\n+    private int splitState = STATE_UNSPLIT;\n \n     /**\n      * The start time.\n      */\n     private long startTime = -1;\n+\n     /**\n      * The stop time.\n      */\n     private long stopTime = -1;\n \n     /**\n-     * <p>Constructor.</p>\n+     * <p>\n+     * Constructor.\n+     * </p>\n      */\n     public StopWatch() {\n         super();\n     }\n \n     /**\n-     * <p>Start the stopwatch.</p>\n-     * \n-     * <p>This method starts a new timing session, clearing any previous values.</p>\n-     *\n-     * @throws IllegalStateException if the StopWatch is already running.\n+     * <p>\n+     * Start the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This method starts a new timing session, clearing any previous values.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is already running.\n      */\n     public void start() {\n-        if(this.runningState == STATE_STOPPED) {\n+        if (this.runningState == STATE_STOPPED) {\n             throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n         }\n-        if(this.runningState != STATE_UNSTARTED) {\n+        if (this.runningState != STATE_UNSTARTED) {\n             throw new IllegalStateException(\"Stopwatch already started. \");\n         }\n         stopTime = -1;\n     }\n \n     /**\n-     * <p>Stop the stopwatch.</p>\n-     * \n-     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n-     *\n-     * @throws IllegalStateException if the StopWatch is not running.\n+     * <p>\n+     * Stop the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This method ends a new timing session, allowing the time to be retrieved.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not running.\n      */\n     public void stop() {\n-        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n+        if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n-        if(this.runningState == STATE_RUNNING) {\n+        if (this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n         }\n         this.runningState = STATE_STOPPED;\n     }\n \n     /**\n-     * <p>Resets the stopwatch. Stops it if need be. </p>\n-     * \n-     * <p>This method clears the internal values to allow the object to be reused.</p>\n+     * <p>\n+     * Resets the stopwatch. Stops it if need be.\n+     * </p>\n+     * \n+     * <p>\n+     * This method clears the internal values to allow the object to be reused.\n+     * </p>\n      */\n     public void reset() {\n         this.runningState = STATE_UNSTARTED;\n-        this.splitState   = STATE_UNSPLIT;\n+        this.splitState = STATE_UNSPLIT;\n         startTime = -1;\n         stopTime = -1;\n     }\n \n     /**\n-     * <p>Split the time.</p>\n-     * \n-     * <p>This method sets the stop time of the watch to allow a time to be extracted.\n-     * The start time is unaffected, enabling {@link #unsplit()} to continue the \n-     * timing from the original start point.</p>\n-     *\n-     * @throws IllegalStateException if the StopWatch is not running.\n+     * <p>\n+     * Split the time.\n+     * </p>\n+     * \n+     * <p>\n+     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n+     * enabling {@link #unsplit()} to continue the timing from the original start point.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not running.\n      */\n     public void split() {\n-        if(this.runningState != STATE_RUNNING) {\n+        if (this.runningState != STATE_RUNNING) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n         stopTime = System.currentTimeMillis();\n     }\n \n     /**\n-     * <p>Remove a split.</p>\n-     * \n-     * <p>This method clears the stop time. The start time is unaffected, enabling \n-     * timing from the original start point to continue.</p>\n-     *\n-     * @throws IllegalStateException if the StopWatch has not been split.\n+     * <p>\n+     * Remove a split.\n+     * </p>\n+     * \n+     * <p>\n+     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n+     * continue.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not been split.\n      */\n     public void unsplit() {\n-        if(this.splitState != STATE_SPLIT) {\n+        if (this.splitState != STATE_SPLIT) {\n             throw new IllegalStateException(\"Stopwatch has not been split. \");\n         }\n         stopTime = -1;\n     }\n \n     /**\n-     * <p>Suspend the stopwatch for later resumption.</p>\n-     * \n-     * <p>This method suspends the watch until it is resumed. The watch will not include\n-     * time between the suspend and resume calls in the total time.</p>\n-     *\n-     * @throws IllegalStateException if the StopWatch is not currently running.\n+     * <p>\n+     * Suspend the stopwatch for later resumption.\n+     * </p>\n+     * \n+     * <p>\n+     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n+     * resume calls in the total time.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not currently running.\n      */\n     public void suspend() {\n-        if(this.runningState != STATE_RUNNING) {\n+        if (this.runningState != STATE_RUNNING) {\n             throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n         }\n         stopTime = System.currentTimeMillis();\n     }\n \n     /**\n-     * <p>Resume the stopwatch after a suspend.</p>\n-     * \n-     * <p>This method resumes the watch after it was suspended. The watch will not include\n-     * time between the suspend and resume calls in the total time.</p>\n-     *\n-     * @throws IllegalStateException if the StopWatch has not been suspended. \n+     * <p>\n+     * Resume the stopwatch after a suspend.\n+     * </p>\n+     * \n+     * <p>\n+     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n+     * resume calls in the total time.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not been suspended.\n      */\n     public void resume() {\n-        if(this.runningState != STATE_SUSPENDED) {\n+        if (this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n         }\n         startTime += (System.currentTimeMillis() - stopTime);\n     }\n \n     /**\n-     * <p>Get the time on the stopwatch.</p>\n-     * \n-     * <p>This is either the time between the start and the moment this method \n-     * is called, or the amount of time between start and stop.</p>\n+     * <p>\n+     * Get the time on the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This is either the time between the start and the moment this method is called, or the amount of time between\n+     * start and stop.\n+     * </p>\n      * \n      * @return the time in milliseconds\n      */\n     public long getTime() {\n-        if(this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {\n+        if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {\n             return this.stopTime - this.startTime;\n-        } else\n-        if(this.runningState == STATE_UNSTARTED) {\n+        } else if (this.runningState == STATE_UNSTARTED) {\n             return 0;\n-        } else\n-        if(this.runningState == STATE_RUNNING) {\n+        } else if (this.runningState == STATE_RUNNING) {\n             return System.currentTimeMillis() - this.startTime;\n         }\n         throw new RuntimeException(\"Illegal running state has occured. \");\n     }\n \n     /**\n-     * <p>Get the split time on the stopwatch.</p>\n-     * \n-     * <p>This is the time between start and latest split. </p>\n+     * <p>\n+     * Get the split time on the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This is the time between start and latest split.\n+     * </p>\n      * \n      * @return the split time in milliseconds\n-     *\n-     * @throws IllegalStateException if the StopWatch has not yet been split.\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not yet been split.\n      * @since 2.1\n      */\n     public long getSplitTime() {\n-        if(this.splitState != STATE_SPLIT) {\n+        if (this.splitState != STATE_SPLIT) {\n             throw new IllegalStateException(\"Stopwatch must be split to get the split time. \");\n         }\n         return this.stopTime - this.startTime;\n     }\n \n     /**\n-     * <p>Gets a summary of the time that the stopwatch recorded as a string.</p>\n-     * \n-     * <p>The format used is ISO8601-like,\n-     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n+     * Returns the time this stopwatch was started.\n+     * \n+     * @return the time this stopwatch was started\n+     * @throws IllegalStateException\n+     *             if this StopWatch has not been started\n+     * @since 2.4\n+     */\n+    public long getStartTime() {\n+        if (this.runningState == STATE_UNSTARTED) {\n+            throw new IllegalStateException(\"Stopwatch has not been started\");\n+        }\n+        return this.startTime;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets a summary of the time that the stopwatch recorded as a string.\n+     * </p>\n+     * \n+     * <p>\n+     * The format used is ISO8601-like, <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n+     * </p>\n      * \n      * @return the time as a String\n      */\n     }\n \n     /**\n-     * <p>Gets a summary of the split time that the stopwatch recorded as a string.</p>\n-     * \n-     * <p>The format used is ISO8601-like,\n-     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n+     * <p>\n+     * Gets a summary of the split time that the stopwatch recorded as a string.\n+     * </p>\n+     * \n+     * <p>\n+     * The format used is ISO8601-like, <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n+     * </p>\n      * \n      * @return the split time as a String\n      * @since 2.1\n--- a/src/test/org/apache/commons/lang/time/StopWatchTest.java\n+++ b/src/test/org/apache/commons/lang/time/StopWatchTest.java\n  */\n package org.apache.commons.lang.time;\n \n+import junit.framework.Assert;\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n         } catch(IllegalStateException ise) {\n             // expected\n         }\n-\n+    }\n+\n+    public void testGetStartTime() {\n+        long beforeStopWatch = System.currentTimeMillis();\n+        StopWatch watch = new StopWatch();\n+        try {\n+            watch.getStartTime();\n+            fail(\"Calling getStartTime on an unstarted StopWatch should throw an exception\");\n+        } catch (IllegalStateException expected) {\n+            // expected\n+        }\n+        watch.start();\n+        try {\n+            watch.getStartTime();\n+            Assert.assertTrue(watch.getStartTime() >= beforeStopWatch);\n+        } catch (IllegalStateException ex) {\n+            fail(\"Start time should be available: \" + ex.getMessage());\n+        }\n+        watch.reset();\n+        try {\n+            watch.getStartTime();\n+            fail(\"Calling getStartTime on a reset, but unstarted StopWatch should throw an exception\");\n+        } catch (IllegalStateException expected) {\n+            // expected\n+        }\n     }\n \n }", "timestamp": 1192048277, "metainfo": ""}