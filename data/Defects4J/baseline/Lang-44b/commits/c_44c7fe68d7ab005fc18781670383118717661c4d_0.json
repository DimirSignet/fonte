{"sha": "44c7fe68d7ab005fc18781670383118717661c4d", "log": "removed the weak assumptions for number of millis in a month/year from DateUtils. Implemented a second format method that relies on a start and an end in DurationFormatUtils, though I found that TimeZone was very important in the overloaded millis version. The two methods hand off to each other depending on whether the time is > or < than 28 days   ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @author Phil Steitz\n  * @since 2.0\n- * @version $Id: DateUtils.java,v 1.29 2004/09/26 05:45:33 bayard Exp $\n+ * @version $Id: DateUtils.java,v 1.30 2004/09/27 03:14:15 bayard Exp $\n  */\n public class DateUtils {\n     \n      * Number of milliseconds in a standard day.\n      */\n     public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n-\n-    // hmm. not very accurate. used by DurationFormatUtils\n-    static final long MILLIS_PER_YEAR = 365 * MILLIS_PER_DAY + 6 * MILLIS_PER_HOUR;\n-    static final long MILLIS_PER_MONTH = MILLIS_PER_YEAR / 12;\n \n     /**\n      * This is half a month, so this represents whether a date is in the top\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n \n import org.apache.commons.lang.StringUtils;\n \n+import java.util.Calendar;\n+import java.util.TimeZone;\n+\n /**\n  * <p>Duration formatting utilities and constants.</p>\n  *\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @author Henri Yandell\n  * @since 2.1\n- * @version $Id: DurationFormatUtils.java,v 1.14 2004/09/26 05:45:33 bayard Exp $\n+ * @version $Id: DurationFormatUtils.java,v 1.15 2004/09/27 03:14:15 bayard Exp $\n  */\n public class DurationFormatUtils {\n \n         return format(millis, format, true);\n     }\n     public static String format(long millis, String format, boolean padWithZeros) {\n-        StringBuffer buffer = new StringBuffer();\n+        return format(millis, format, padWithZeros, TimeZone.getDefault());\n+    }\n+    public static String format(long millis, String format, boolean padWithZeros, TimeZone timezone) {\n+\n+        if(millis > 28 * DateUtils.MILLIS_PER_DAY) {\n+            Calendar c = Calendar.getInstance(timezone);\n+            c.set(1970, 0, 1, 0, 0, 0);\n+            c.set(Calendar.MILLISECOND, 0);\n+            return format(c.getTime().getTime(), millis, format, padWithZeros, timezone);\n+        }\n+\n         Token[] tokens = lexx(format);\n-        int sz = tokens.length;\n \n         int years        = 0;\n         int months       = 0;\n         int seconds      = 0;\n         int milliseconds = 0;\n \n+        /*  This will never be evaluated\n         if(Token.containsTokenWithValue(tokens, y) ) {\n             years = (int) (millis / DateUtils.MILLIS_PER_YEAR);\n             millis = millis - (years * DateUtils.MILLIS_PER_YEAR);\n                 months = 0;\n             }\n         }\n+        */\n         if(Token.containsTokenWithValue(tokens, d) ) {\n             days = (int) (millis / DateUtils.MILLIS_PER_DAY);\n             millis = millis - (days * DateUtils.MILLIS_PER_DAY);\n             milliseconds = (int) millis;\n         }\n \n-\n+        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+\n+    private static String formatDuration(Token[] tokens, int years, int months, int days, int hours, \n+                                         int minutes, int seconds, int milliseconds, boolean padWithZeros) \n+    { \n+        StringBuffer buffer = new StringBuffer();\n+        int sz = tokens.length;\n         for(int i=0; i<sz; i++) {\n             Token token = tokens[i];\n             Object value = token.getValue();\n         }\n         \n         return buffer.toString();\n+    }\n+\n+    // slower than the above I presume\n+    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros) {\n+        return format(startMillis, endMillis, format, padWithZeros, TimeZone.getDefault());\n+    }\n+    public static String format(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n+\n+        long millis = endMillis - startMillis;\n+        if(millis < 28 * DateUtils.MILLIS_PER_DAY) {\n+            return format(millis, format, padWithZeros, timezone);\n+        }\n+\n+        Token[] tokens = lexx(format);\n+\n+        // timezones get funky around 0, so normalizing everything to GMT \n+        // stops the hours being off\n+        Calendar start = Calendar.getInstance(timezone);\n+        start.setTimeInMillis(startMillis);\n+        Calendar end = Calendar.getInstance(timezone);\n+        end.setTimeInMillis(endMillis);\n+\n+        // initial estimates\n+        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n+        // each initial estimate is adjusted in case it is under 0\n+        while(months < 0) {\n+            months += 12;\n+            years -= 1;\n+        }\n+        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        while(days < 0) {\n+            days += 31;  // such overshooting is taken care of later on\n+            days -= 1;\n+        }\n+        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n+        while(hours < 0) {\n+            hours += 24;\n+            days -= 1;\n+        }\n+        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n+        while(minutes < 0) {\n+            minutes += 60;\n+            hours -= 1;\n+        }\n+        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n+        while(seconds < 0) {\n+            seconds += 60;\n+            minutes -= 1;\n+        }\n+        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n+        while(milliseconds < 0) {\n+            milliseconds += 1000;\n+            seconds -= 1;\n+        }\n+\n+        // take estimates off of end to see if we can equal start, when it overshoots recalculate\n+        milliseconds -= reduceAndCorrect( start, end, Calendar.MILLISECOND, milliseconds );\n+        seconds -= reduceAndCorrect( start, end, Calendar.SECOND, seconds );\n+        minutes -= reduceAndCorrect( start, end, Calendar.MINUTE, minutes );\n+        hours -= reduceAndCorrect( start, end, Calendar.HOUR_OF_DAY, hours );\n+        days -= reduceAndCorrect( start, end, Calendar.DAY_OF_MONTH, days );\n+        months -= reduceAndCorrect( start, end, Calendar.MONTH, months );\n+        years -= reduceAndCorrect( start, end, Calendar.YEAR, years );\n+\n+        return formatDuration(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    // Reduces by difference, then if it overshot, calculates the overshot amount and \n+    // fixes and returns the amount to change by\n+    private static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n+        end.add( field, -1 * difference );\n+        int endValue = end.get(field);\n+        int startValue = start.get(field);\n+        if(endValue < startValue) {\n+            int newdiff = startValue - endValue;\n+            end.add( field, newdiff );\n+            return newdiff;\n+        } else {\n+            return 0;\n+        }\n     }\n \n     /**\n--- a/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n         text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal);\n         assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n         // test fixture is the same as above, but now with extended format.\n-        text = DurationFormatUtils.format(cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false);\n-        // TODO: The 1H41M here should be 9H11M. Again the year/month assumption.\n-        System.err.println(\"T: \"+text);\n-        assertEquals(\"P32Y1M23DT1H41M12.1S\", text);\n+        text = DurationFormatUtils.format(cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n+        assertEquals(\"P32Y1M22DT9H11M12.1S\", text);\n         // test fixture from example in http://www.w3.org/TR/xmlschema-2/#duration\n         cal.set(1971, 1, 3, 10, 30, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n-        text = DurationFormatUtils.format(cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false);\n-        // TODO: The 2D21H here is wrong and should be larger. The Year/Month assumption in DurationFormatUtils.\n-        assertEquals(\"P1Y1M2DT21H0M0.0S\", text);\n+        text = DurationFormatUtils.format(cal.getTime().getTime(), DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, timeZone);\n+        assertEquals(\"P1Y1M2DT10H30M0.0S\", text);\n         // want a way to say 'don't print the seconds in format()' or other fields for that matter:\n         //assertEquals(\"P1Y2M3DT10H30M\", text);\n     }\n         assertEquals( \"60000\", DurationFormatUtils.format(time, \"S\") );\n         assertEquals( \"01:00\", DurationFormatUtils.format(time, \"mm:ss\") );\n \n+        /*\n         time = 3 * DateUtils.MILLIS_PER_YEAR + 7 * DateUtils.MILLIS_PER_MONTH;\n         assertEquals( \"37\", DurationFormatUtils.format(time, \"yM\") );\n         assertEquals( \"3 years 7 months\", DurationFormatUtils.format(time, \"y' years 'M' months'\") );\n         assertEquals( \"48\", DurationFormatUtils.format(time, \"M\") );\n         assertEquals( \"48\", DurationFormatUtils.format(time, \"MM\") );\n         assertEquals( \"048\", DurationFormatUtils.format(time, \"MMM\") );\n+        */\n \n     }\n ", "timestamp": 1096254855, "metainfo": ""}