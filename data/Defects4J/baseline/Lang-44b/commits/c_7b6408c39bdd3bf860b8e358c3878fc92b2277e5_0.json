{"sha": "7b6408c39bdd3bf860b8e358c3878fc92b2277e5", "log": "Null handling changes Javadoc fixes and tidying File layout grouping   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n  */\n package org.apache.commons.lang;\n \n+import java.util.ArrayList;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.StringTokenizer;\n \n import org.apache.commons.lang.math.NumberUtils;\n \n /**\n- * <p>Common <code>String</code> manipulation routines.</p>\n+ * <p>Common <code>String</code> manipulation routines that are \n+ * <code>null</code> safe.</p>\n  *\n  * <p>The <code>StringUtils</code> class defines certain words related to\n  * String handling.</p>\n  *  <li>whitespace - the characters defined by {@link Character#isWhitespace(char)}\n  * </ul>\n  * \n- * <p>The <code>StringUtils</code> tries to handle <code>null</code> input\n- * quietly. That is to say that a <code>null</code> will generally return a \n- * sensible value rather than throw an exception.\n- * Typically, <code>null</code> in gives <code>null</code> out.\n- * Each method should be consulted individually for full details.</p>\n+ * <p><code>StringUtils</code> handles <code>null</code> input Strings quietly.\n+ * That is to say that a <code>null</code> input will return <code>null</code>.\n+ * Where a <code>boolean</code> or <code>int</code> is being returned exact\n+ * details vary by method.</p>\n  * \n  * <p>A side effect of the <code>null</code> handling is that a \n  * NullPointerException should be considered a bug in <code>StringUtils</code>.\n  * @author Arun Mammen Thomas\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @since 1.0\n- * @version $Id: StringUtils.java,v 1.61 2003/07/16 23:56:45 scolebourne Exp $\n+ * @version $Id: StringUtils.java,v 1.62 2003/07/18 02:06:24 scolebourne Exp $\n  */\n public class StringUtils {\n \n     /**\n      * <p>A <code>String</code> containing all space characters (' ').</p>\n      *\n-     * <p>Used for efficient space padding.  The length of the string expands as needed.</p>\n+     * <p>Used for efficient space padding.  The length of the String expands as needed.</p>\n      */\n     private static String spaces = new String(\" \");\n \n     /**\n      * <p>An array of <code>String</code>s used for padding.</p>\n      *\n-     * <p>Used for efficient space padding. The length of each string expands as needed.</p>\n+     * <p>Used for efficient space padding. The length of each String expands as needed.</p>\n      */\n     private final static String[] padding = new String[Character.MAX_VALUE];\n        // String.concat about twice as fast as StringBuffer.append\n     }\n \n     // Empty\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n \n     /**\n      * <p>Removes control characters (char &lt;= 32) from both\n      * ends of this String, handling <code>null</code> by returning\n      * <code>null</code>.</p>\n      * \n-     * <p>The string is trimmed using {@link String#trim()}.\n+     * <p>The String is trimmed using {@link String#trim()}.\n      * Trim removes start and end characters &lt;= 32.</p>\n+     * \n+     * <p>To trim your choice of characters, use the\n+     * {@link #strip(String, String)} methods.</p>\n      * \n      * <pre>\n      * StringUtils.trim(null)          = null\n      *\n      * @see java.lang.String#trim()\n      * @param str  the String to be trimmed, may be null\n-     * @return the trimmed text, \n-     *  <code>null</code> if a null string input\n+     * @return the trimmed text, <code>null</code> if null String input\n      */\n     public static String trim(String str) {\n         return (str == null ? null : str.trim());\n \n     /** \n      * <p>Removes control characters (char &lt;= 32) from both  \n-     * ends of this string returning <code>null</code> if the string is \n+     * ends of this String returning <code>null</code> if the String is \n      * empty (\"\") after the trim or if it is <code>null</code>.\n      * \n-     * <p>The string is trimmed using {@link String#trim()}.\n+     * <p>The String is trimmed using {@link String#trim()}.\n      * Trim removes start and end characters &lt;= 32.</p>\n      * \n      * <pre>\n      *  \n      * @see java.lang.String#trim()\n      * @param str  the String to be trimmed, may be null\n-     * @return the trimmed string, \n-     *  <code>null</code> if a whitespace, empty or null string input\n+     * @return the trimmed String, \n+     *  <code>null</code> if a whitespace, empty or null String input\n      */\n     public static String trimToNull(String str) {\n         String ts = trim(str);\n \n     /** \n      * <p>Removes control characters (char &lt;= 32) from both \n-     * ends of this string returning an empty string (\"\") if the string\n+     * ends of this String returning an empty String (\"\") if the String\n      * is empty (\"\") after the trim or if it is <code>null</code>.\n      * \n-     * <p>The string is trimmed using {@link String#trim()}.\n+     * <p>The String is trimmed using {@link String#trim()}.\n      * Trim removes start and end characters &lt;= 32.</p>\n      * \n      * <pre>\n      *  \n      * @see java.lang.String#trim()\n      * @param str  the String to be trimmed, may be null\n-     * @return the trimmed string, or an empty string if null input\n+     * @return the trimmed String, or an empty String if null input\n      */\n     public static String trimToEmpty(String str) {\n         return (str == null ? \"\" : str.trim());\n     }\n+    \n+    // Delete\n+    //-----------------------------------------------------------------------\n \n     /**\n      * <p>Deletes all 'space' characters from a String as defined by\n      * {@link Character#isSpace(char)}.</p>\n+     * \n+     * <p>This is the only StringUtils method that uses the \n+     * <code>isSpace</code> definition. You are advised to use\n+     * {@link #deleteWhitespace(String)} instead as whitespace is much\n+     * better localized.</p>\n      *\n      * <pre>\n      * StringUtils.deleteSpaces(null)           = null\n      * in line with the deprecated <code>isSpace</code> method.</p>\n      *\n      * @param str  the String to delete spaces from, may be null\n-     * @return the String without spaces, <code>null</code> if null string input\n+     * @return the String without 'spaces', <code>null</code> if null String input\n      */\n     public static String deleteSpaces(String str) {\n         if (str == null) {\n      * </pre>\n      *  \n      * @param str  the String to delete whitespace from, may be null\n-     * @return the String without whitespaces, <code>null</code> if null string input\n+     * @return the String without whitespaces, <code>null</code> if null String input\n      */\n     public static String deleteWhitespace(String str) {\n         if (str == null) {\n     }\n \n     // Empty checks\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n \n     /**\n      * <p>Checks if a String is empty (\"\").\n      * <p>Checks if a trimmed String is empty (\"\").\n      * <code>null</code> returns <code>false</code></p>\n      * \n-     * <p>The string is trimmed using {@link String#trim()}.\n+     * <p>The String is trimmed using {@link String#trim()}.\n      * Trim removes start and end characters &lt;= 32.</p>\n      *\n      * <pre>\n      * <p>Checks if a trimmed String is not empty (\"\").</p>\n      * <code>null</code> returns <code>true</code></p>\n      * \n-     * <p>The string is trimmed using {@link String#trim()}.\n+     * <p>The String is trimmed using {@link String#trim()}.\n      * Trim removes start and end characters &lt;= 32.</p>\n      *\n      * <pre>\n     /**\n      * <p>Checks if a trimmed String is empty (\"\") or <code>null</code>.</p>\n      * \n-     * <p>The string is trimmed using {@link String#trim()}.\n+     * <p>The String is trimmed using {@link String#trim()}.\n      * Trim removes start and end characters &lt;= 32.</p>\n      *\n      * <pre>\n     /**\n      * <p>Checks if a trimmed String is not empty (\"\") and not <code>null</code>.</p>\n      * \n-     * <p>The string is trimmed using {@link String#trim()}.\n+     * <p>The String is trimmed using {@link String#trim()}.\n      * Trim removes start and end characters &lt;= 32.</p>\n      *\n      * <pre>\n         return (str != null && str.trim().length() > 0);\n     }\n \n-    // Equals and IndexOf\n-    //--------------------------------------------------------------------------\n+    // Equals\n+    //-----------------------------------------------------------------------\n \n     /**\n      * <p>Compares two Strings, returning <code>true</code> if they are equal.</p>\n      * </pre>\n      *  \n      * @see java.lang.String#equals(Object)\n-     * @param str1  the first string, may be null\n-     * @param str2  the second string, may be null\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n      * @return <code>true</code> if the Strings are equal, case sensitive, or\n      *  both <code>null</code>\n      */\n      * </pre>\n      * \n      * @see java.lang.String#equalsIgnoreCase(String)\n-     * @param str1  the first string, may be null\n-     * @param str2  the second string, may be null\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n      * @return <code>true</code> if the Strings are equal, case insensitive, or\n      *  both <code>null</code>\n      */\n         return (str1 == null ? str2 == null : str1.equalsIgnoreCase(str2));\n     }\n \n+    // IndexOf\n+    //-----------------------------------------------------------------------\n+    \n     /**\n      * <p>Find the first index of any of a set of potential substrings.</p>\n      *\n-     * <p><code>null</code> String will return <code>-1</code>.</p>\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search array will return <code>-1</code>.\n+     * A <code>null</code> search array entry will be ignored.</p>\n      * \n      * <pre>\n      * StringUtils.indexOfAny(null, null)                = -1\n      * @param str  the String to check, may be null\n      * @param searchStrs  the Strings to search for, may be null\n      * @return the first index of any of the searchStrs in str, -1 if no match\n-     * @throws NullPointerException if any of searchStrs[i] is <code>null</code>\n      */\n     public static int indexOfAny(String str, String[] searchStrs) {\n         if ((str == null) || (searchStrs == null)) {\n \n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            tmp = str.indexOf(searchStrs[i]);\n+            String search = searchStrs[i];\n+            if (search == null) {\n+                continue;\n+            }\n+            tmp = str.indexOf(search);\n             if (tmp == -1) {\n                 continue;\n             }\n     /**\n      * <p>Find the latest index of any of a set of potential substrings.</p>\n      *\n-     * <p><code>null</code> string will return <code>-1</code>.</p>\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search array will return <code>-1</code>.\n+     * A <code>null</code> search array entry will be ignored.</p>\n      * \n      * <pre>\n      * StringUtils.lastIndexOfAny(null, null)                = -1\n      * @param str  the String to check, may be null\n      * @param searchStrs  the Strings to search for, may be null\n      * @return the last index of any of the Strings, -1 if no match\n-     * @throws NullPointerException if any of searchStrs[i] is <code>null</code>\n      */\n     public static int lastIndexOfAny(String str, String[] searchStrs) {\n         if ((str == null) || (searchStrs == null)) {\n         int ret = -1;\n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            tmp = str.lastIndexOf(searchStrs[i]);\n+            String search = searchStrs[i];\n+            if (search == null) {\n+                continue;\n+            }\n+            tmp = str.lastIndexOf(search);\n             if (tmp > ret) {\n                 ret = tmp;\n             }\n         return ret;\n     }\n \n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     * \n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     */\n+     public static int indexOfAnyBut(String str, char[] searchChars) {\n+         if (searchChars == null) {\n+             return -1;\n+         }\n+         return indexOfAnyBut(str, new String(searchChars));\n+     }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     * \n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     */\n+    public static int indexOfAnyBut(String str, String searchChars) {\n+        if (str == null || searchChars == null) {\n+            return -1;\n+        }\n+\n+        for (int i = 0; i < str.length(); i ++) {\n+           if (searchChars.indexOf(str.charAt(i)) < 0) {\n+               return i;\n+           }\n+        }\n+\n+        return -1;\n+    }\n+\n+    // Contains\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Checks if the String contains only certain characters.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, 'abc')   = false\n+     * StringUtils.containsOnly(\"\", null)      = false\n+     * StringUtils.containsOnly(\"\", 'abc')     = true\n+     * StringUtils.containsOnly(\"\", '')        = true\n+     * StringUtils.containsOnly(\"ab\", '')      = false\n+     * StringUtils.containsOnly(\"abab\", 'abc') = true\n+     * StringUtils.containsOnly(\"ab1\", 'abc')  = false\n+     * StringUtils.containsOnly(\"abz\", 'abc')  = false\n+     * </pre>\n+     * \n+     * @param str  the String to check, may be null\n+     * @param valid  an array of valid chars, may be null\n+     * @return true if it only contains valid chars and is non-null\n+     */\n+    public static boolean containsOnly(String str, char[] valid) {\n+        // All these pre-checks are to maintain API with an older version\n+        if ( (valid == null) || (str == null) ) {\n+            return false;\n+        }\n+        if (str.length() == 0) {\n+            return true;\n+        }\n+        if (valid.length == 0) {\n+            return false;\n+        }\n+        return indexOfAnyBut(str, valid) == -1;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only certain characters.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, \"abc\")   = false\n+     * StringUtils.containsOnly(\"\", null)      = false\n+     * StringUtils.containsOnly(\"\", \"abc\")     = true\n+     * StringUtils.containsOnly(\"\", \"\")        = true\n+     * StringUtils.containsOnly(\"ab\", \"\")      = false\n+     * StringUtils.containsOnly(\"abab\", \"abc\") = true\n+     * StringUtils.containsOnly(\"ab1\", \"abc\")  = false\n+     * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n+     * </pre>\n+     * \n+     * @param str  the String to check, may be null\n+     * @param validChars  a String of valid chars, may be null\n+     * @return true if it only contains valid chars and is non-null\n+     */\n+    public static boolean containsOnly(String str, String validChars) {\n+        if (str == null || validChars == null) {\n+            return false;\n+        }\n+        return containsOnly(str, validChars.toCharArray());\n+    }\n+    \n+    /**\n+     * <p>Checks that the String does not contain certain characters.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, 'xyz')   = true\n+     * StringUtils.containsOnly(\"\", null)      = true\n+     * StringUtils.containsOnly(\"\", 'xyz')     = true\n+     * StringUtils.containsOnly(\"\", '')        = true\n+     * StringUtils.containsOnly(\"ab\", '')      = true\n+     * StringUtils.containsOnly(\"abab\", 'xyz') = true\n+     * StringUtils.containsOnly(\"ab1\", 'xyz')  = true\n+     * StringUtils.containsOnly(\"abz\", 'xyz')  = false\n+     * </pre>\n+     * \n+     * @param str  the String to check, may be null\n+     * @param invalidChars  an array of invalid chars, may be null\n+     * @return true if it contains none of the invalid chars, or is null\n+     */\n+    public static boolean containsNone(String str, char[] invalidChars) {\n+        if (str == null || invalidChars == null) {\n+            return true;\n+        }\n+        int strSize = str.length();\n+        int validSize = invalidChars.length;\n+        for (int i = 0; i < strSize; i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < validSize; j++) {\n+                if (invalidChars[j] == ch) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks that the String does not contain certain characters.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, \"xyz\")   = true\n+     * StringUtils.containsOnly(\"\", null)      = true\n+     * StringUtils.containsOnly(\"\", \"xyz\")     = true\n+     * StringUtils.containsOnly(\"\", \"\")        = true\n+     * StringUtils.containsOnly(\"ab\", \"\")      = true\n+     * StringUtils.containsOnly(\"abab\", \"xyz\") = true\n+     * StringUtils.containsOnly(\"ab1\", \"xyz\")  = true\n+     * StringUtils.containsOnly(\"abz\", \"xyz\")  = false\n+     * </pre>\n+     * \n+     * @param str  the String to check, may be null\n+     * @param invalidChars  a String of invalid chars, may be null\n+     * @return true if it contains none of the invalid chars, or is null\n+     */\n+    public static boolean containsNone(String str, String invalidChars) {\n+        if (str == null || invalidChars == null) {\n+            return true;\n+        }\n+        return containsNone(str, invalidChars.toCharArray());\n+    }\n+    \n     // Substring\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n-     * <p>Gets a substring from the specified string avoiding exceptions.</p>\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n      *\n      * <p>A negative start position can be used to start <code>n</code>\n      * characters from the end of the String.</p>\n      * @param str  the String to get the substring from, may be null\n      * @param start  the position to start from, negative means\n      *  count back from the end of the String by this many characters\n-     * @return substring from start position, <code>null</code> if null string input\n+     * @return substring from start position, <code>null</code> if null String input\n      */\n     public static String substring(String str, int start) {\n         if (str == null) {\n      * \n      * @param str  the String to get the substring from, may be null\n      * @param start  the position to start from, negative means\n-     *  count back from the end of the string by this many characters\n+     *  count back from the end of the String by this many characters\n      * @param end  the position to end at (exclusive), negative means\n      *  count back from the end of the String by this many characters\n-     * @return substring from start position to end positon, <code>null</code> if null string input\n+     * @return substring from start position to end positon,\n+     *  <code>null</code> if null String input\n      */\n     public static String substring(String str, int start, int end) {\n         if (str == null) {\n         return str.substring(start, end);\n     }\n \n-    /**\n-     * <p>Gets the leftmost <code>n</code> characters of a String.</p>\n-     *\n-     * <p>If <code>n</code> characters are not available, or the\n+    // Left/Right/Mid\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the leftmost <code>len</code> characters of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, or the\n      * String is <code>null</code>, the String will be returned without\n      * an exception.</p>\n      *\n      * \n      * @param str  the String to get the leftmost characters from, may be null\n      * @param len  the length of the required String, must be zero or positive\n-     * @return the leftmost characters, <code>null</code> if null string input\n+     * @return the leftmost characters, <code>null</code> if null String input\n      * @throws IllegalArgumentException if len is less than zero\n      */\n     public static String left(String str, int len) {\n     }\n \n     /**\n-     * <p>Gets the rightmost <code>n</code> characters of a String.</p>\n-     *\n-     * <p>If <code>n</code> characters are not available, or the String\n+     * <p>Gets the rightmost <code>len</code> characters of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, or the String\n      * is <code>null</code>, the String will be returned without an\n      * exception.</p>\n      *\n      * \n      * @param str  the String to get the rightmost characters from, may be null\n      * @param len  the length of the required String, must be zero or positive\n-     * @return the rightmost characters, <code>null</code> if null string input\n+     * @return the rightmost characters, <code>null</code> if null String input\n      * @throws IllegalArgumentException if len is less than zero\n      */\n     public static String right(String str, int len) {\n     }\n \n     /**\n-     * <p>Gets <code>n</code> characters from the middle of a String.</p>\n-     *\n-     * <p>If <code>n</code> characters are not available, the remainder\n+     * <p>Gets <code>len</code> characters from the middle of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, the remainder\n      * of the String will be returned without an exception. If the\n      * String is <code>null</code>, <code>null</code> will be returned.</p>\n      *\n      * @param str  the String to get the characters from, may be null\n      * @param pos  the position to start from, must be valid\n      * @param len  the length of the required String, must be zero or positive\n-     * @return the middle characters, <code>null</code> if null string input\n+     * @return the middle characters, <code>null</code> if null String input\n      * @throws IndexOutOfBoundsException if pos is out of bounds\n      * @throws IllegalArgumentException if len is less than zero\n      */\n     }\n \n     // Splitting\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n      * <p>Splits the provided text into an array, using whitespace as the\n-     * separator.</p>\n+     * separator.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n      *\n      * <p>The separator is not included in the returned String array.</p>\n-     *\n-     * <pre>\n-     * StringUtils.split(null)      = []\n-     * StringUtils.split(\"abc def\") = [abc, def]\n+     * \n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null)      = null\n+     * StringUtils.split(\"abc def\") = [\"abc\", \"def\"]\n      * </pre>\n      * \n      * @param str  the String to parse, may be null\n-     * @return an array of parsed Strings, empty array if null input\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n     public static String[] split(String str) {\n         return split(str, null, -1);\n     }\n \n     /**\n+     * <p>Splits the provided text into an array, using the specified separator.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators will cause an empty String to be returned (\"\").</p>\n+     * \n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, '.')      = null\n+     * StringUtils.split(\"a.b.c\", '.') = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a..b.c\", '.') = [\"a\", \"\", \"b\", \"c\"]\n+     * StringUtils.split(\"a:b:c\", '.')  = [\"a:b:c\"]\n+     * </pre>\n+     * \n+     * @param str  the String to parse, may be null\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, char separatorChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        char[] chars = str.toCharArray();\n+        List list = new ArrayList();\n+        int start = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            if (chars[i] == separatorChar) {\n+                list.add(str.substring(start, i));\n+                start = i + 1;\n+            }\n+        }\n+        list.add(str.substring(start));\n+        return (String[]) list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n      * <p>Splits the provided text into an array, using the specified separators.</p>\n      *\n      * <p>The separator is not included in the returned String array.</p>\n-     *\n-     * <pre>\n-     * StringUtils.split(null, null)      = []\n-     * StringUtils.split(\"abc def\", null) = [abc, def]\n-     * StringUtils.split(\"abc def\", \" \")  = [abc, def]\n-     * StringUtils.split(\"ab:cd:ef\", \":\") = [ab, cd, ef]\n+     * \n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, null)      = null\n+     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n      * </pre>\n      * \n      * @param str  the String to parse, may be null\n-     * @param separators  the characters used as the delimiters,\n+     * @param separatorChars  the characters used as the delimiters,\n      *  <code>null</code> splits on whitespace\n-     * @return an array of parsed Strings, empty array if null input\n-     */\n-    public static String[] split(String str, String separators) {\n-        return split(str, separators, -1);\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, String separatorChars) {\n+        return split(str, separatorChars, -1);\n     }\n \n     /**\n      * an array of tokens, instead of an enumeration of tokens (as\n      * <code>StringTokenizer</code> does).</p>\n      *\n-     * <pre>\n-     * StringUtils.split(null, null, 0)       = []\n-     * StringUtils.split(\"ab de fg\", null, 0) = [ab, cd, ef]\n-     * StringUtils.split(\"ab:cd:ef\", \":\", 0)  = [ab, cd, ef]\n-     * StringUtils.split(\"ab:cd:ef\", \":\", 2)  = [ab, cdef]\n-     * </pre>\n-     * \n-     * @param str  the string to parse, may be null\n-     * @param separators  the characters used as the delimiters,\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     * \n+     * <pre>\n+     * StringUtils.split(null, null, 0)       = null\n+     * StringUtils.split(\"ab de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 0)  = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 2)  = [\"ab\", \"cdef\"]\n+     * </pre>\n+     * \n+     * @param str  the String to parse, may be null\n+     * @param separatorChars  the characters used as the delimiters,\n      *  <code>null</code> splits on whitespace\n      * @param max  the maximum number of elements to include in the\n      *  array. A zero or negative value implies no limit.\n-     * @return an array of parsed Strings, empty array if null input\n-     */\n-    public static String[] split(String str, String separator, int max) {\n-        if (str == null) {\n-            return ArrayUtils.EMPTY_STRING_ARRAY;\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, String separatorChars, int max) {\n+        if (str == null) {\n+            return null;\n         }\n         StringTokenizer tok = null;\n-        if (separator == null) {\n+        if (separatorChars == null) {\n             // Null separator means we're using StringTokenizer's default\n             // delimiter, which comprises all whitespace characters.\n+            \n+            // TODO: StringTokenizer uses isSpace() not isWhitespace()\n             tok = new StringTokenizer(str);\n         } else {\n-            tok = new StringTokenizer(str, separator);\n+            tok = new StringTokenizer(str, separatorChars);\n         }\n \n         int listSize = tok.countTokens();\n     }\n \n     // Joining\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     /**\n      * <p>Concatenates elements of an array into a single String.</p>\n      *\n      * <p>The difference from join is that concatenate has no delimiter.</p>\n      * \n      * @param array  the array of values to concatenate, may be null\n-     * @return the concatenated string, <code>null</code> if null array input\n+     * @return the concatenated String, <code>null</code> if null array input\n      */\n     public static String concatenate(Object[] array) {\n         return join(array, null);\n     }\n     \n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null array input\n+     */\n+    public static String join(Object[] array, char separator) {\n+        if (array == null) {\n+            return null;\n+        }\n+        int arraySize = array.length;\n+        int bufSize = (arraySize == 0 ? 0 : ((array[0] == null ? 16 : array[0].toString().length()) + 1) * arraySize);\n+        StringBuffer buf = new StringBuffer(bufSize);\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            if (i > 0) {\n+                buf.append(separator);\n+            }\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n     /**\n      * <p>Joins the elements of the provided array into a single String\n      * containing the provided list of elements.</p>\n \n         // ArraySize ==  0: Len = 0\n         // ArraySize > 0:   Len = NofStrings *(len(firstString) + len(separator))\n-        //           (Assuming that all strings are roughly equally long)\n+        //           (Assuming that all Strings are roughly equally long)\n         int bufSize \n             = ((arraySize == 0) ? 0 \n                 : arraySize * ((array[0] == null ? 16 : array[0].toString().length()) \n     }\n \n     /**\n-     * <p>Joins the elements of the provided array into a single String\n-     * containing the provided list of elements.</p>\n-     *\n-     * <p>No delimiter is added before or after the list.\n-     *\n-     * @param array  the array of values to join together, may be null\n-     * @param separator  the separator character to use\n-     * @return the joined String, <code>null</code> if null array input\n-     */\n-    public static String join(Object[] array, char separator) {\n-        if (array == null) {\n-            return null;\n-        }\n-        int arraySize = array.length;\n-        int bufSize = (arraySize == 0 ? 0 : ((array[0] == null ? 16 : array[0].toString().length()) + 1) * arraySize);\n-        StringBuffer buf = new StringBuffer(bufSize);\n-\n-        for (int i = 0; i < arraySize; i++) {\n-            if (i > 0) {\n-                buf.append(separator);\n-            }\n-            if (array[i] != null) {\n-                buf.append(array[i]);\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n-    /**\n      * <p>Joins the elements of the provided <code>Iterator</code> into\n      * a single String containing the provided elements.</p>\n      *\n      * <p>No delimiter is added before or after the list.\n-     * A <code>null</code> separator is the same as an empty String (\"\").</p>\n      *\n      * @param iterator  the <code>Iterator</code> of values to join together, may be null\n-     * @param separator  the separator character to use, null treated as \"\"\n+     * @param separator  the separator character to use\n      * @return the joined String, <code>null</code> if null iterator input\n      */\n-    public static String join(Iterator iterator, String separator) {\n+    public static String join(Iterator iterator, char separator) {\n         if (iterator == null) {\n             return null;\n         }\n             if (obj != null) {\n                 buf.append(obj);\n             }\n-            if ((separator != null) && iterator.hasNext()) {\n+            if (iterator.hasNext()) {\n                 buf.append(separator);\n             }\n-         }\n+        }\n         return buf.toString();\n     }\n \n      * a single String containing the provided elements.</p>\n      *\n      * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").</p>\n      *\n      * @param iterator  the <code>Iterator</code> of values to join together, may be null\n-     * @param separator  the separator character to use\n+     * @param separator  the separator character to use, null treated as \"\"\n      * @return the joined String, <code>null</code> if null iterator input\n      */\n-    public static String join(Iterator iterator, char separator) {\n+    public static String join(Iterator iterator, String separator) {\n         if (iterator == null) {\n             return null;\n         }\n             if (obj != null) {\n                 buf.append(obj);\n             }\n-            if (iterator.hasNext()) {\n+            if ((separator != null) && iterator.hasNext()) {\n                 buf.append(separator);\n             }\n-        }\n+         }\n         return buf.toString();\n     }\n \n-\n-\n     // Replacing\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n      * <p>Replace a String with another String inside a larger String, once.</p>\n      * @param text  text to search and replace in, may be null\n      * @param repl  the String to search for, may be null\n      * @param with  the String to replace with, may be null\n-     * @return the text with any replacements processed\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n      */\n     public static String replaceOnce(String text, String repl, String with) {\n         return replace(text, repl, with, 1);\n      * @param text  text to search and replace in, may be null\n      * @param repl  the String to search for, may be null\n      * @param with  the String to replace with, may be null\n-     * @return the text with any replacements processed\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n      */\n     public static String replace(String text, String repl, String with) {\n         return replace(text, repl, with, -1);\n      * @param repl  the String to search for, may be null\n      * @param with  the String to replace with, may be null\n      * @param max  maximum number of values to replace, or <code>-1</code> if no maximum\n-     * @return the text with any replacements processed\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n      */\n     public static String replace(String text, String repl, String with, int max) {\n         if (text == null || repl == null || with == null || repl.length() == 0 || max == 0) {\n      * \n      * @param text  the String to do overlaying in, may be null\n      * @param overlay  the String to overlay, may be null\n-     * @param start  the position to start overlaying at\n-     * @param end  the position to stop overlaying before\n-     * @return overlayed string, <code>null</code> if null string input\n+     * @param start  the position to start overlaying at, must be valid\n+     * @param end  the position to stop overlaying before, must be valid\n+     * @return overlayed String, <code>null</code> if null String input\n      * @throws IndexOutOfBoundsException if either position is invalid\n      */\n     public static String overlayString(String text, String overlay, int start, int end) {\n             .toString();\n     }\n \n-    // Centering\n-    //--------------------------------------------------------------------------\n-    \n-    /**\n-     * <p>Center a String in a larger String of size <code>size</code>\n-     * using the space character (' ').<p>\n-     * \n-     * <p>If the size is less than the string length, the string is returned.\n-     * A <code>null</code> string returns <code>null</code>.\n-     * A negative size is treated as zero.</p>\n-     *\n-     * <p>Equivalent to <code>center(str, size, \" \")</code>.</p>\n-     *\n-     * <pre>\n-     * StringUtils.center(null, -1)  = null\n-     * StringUtils.center(null, 4)   = null\n-     * StringUtils.center(\"\", 4)     = \"    \"\n-     * StringUtils.center(\"ab\", 4)   = \" ab \"\n-     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n-     * StringUtils.center(\"a\", 4)    = \" a  \"\n-     * </pre>\n-     * \n-     * @param str  the String to center, may be null\n-     * @param size  the int size of new String, negative treated as zero\n-     * @return centered String, <code>null</code> if null string input\n-     */\n-    public static String center(String str, int size) {\n-        if (str == null) {\n-            return null;\n-        }\n-        if (size < 0) {\n-            size = 0;\n-        }\n-        int sz = str.length();\n-        int p = size - sz;\n-        if (p < 1) {\n-            return str;\n-        }\n-        str = leftPad(str, sz + p / 2, ' ');\n-        str = rightPad(str, size, ' ');\n-        return str;\n-    }\n-\n-    /**\n-     * <p>Center a String in a larger String of size <code>size</code>.</p>\n-     *\n-     * <p>Uses a supplied String as the value to pad the String with.</p>\n-     *\n-     * <p>If the size is less than the string length, the string is returned.\n-     * A <code>null</code> string returns <code>null</code>.\n-     * A negative size is treated as zero.</p>\n-     *\n-     * <pre>\n-     * StringUtils.center(null, -1, \" \")  = null\n-     * StringUtils.center(null, 4, \" \")   = null\n-     * StringUtils.center(\"\", 4, \" \")     = \"    \"\n-     * StringUtils.center(\"ab\", 4, \" \")   = \" ab\"\n-     * StringUtils.center(\"abcd\", 2, \" \") = \" abcd\"\n-     * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n-     * StringUtils.center(\"a\", 4, \"yz\")    = \"yayz\"\n-     * StringUtils.center(\"abc\", 4, null) = IllegalArgumentException\n-     * StringUtils.center(\"abc\", 4, \"\")   = IllegalArgumentException\n-     * </pre>\n-     * \n-     * @param str  the String to center, may be null\n-     * @param size  the int size of new String, negative treated as zero\n-     * @param padStr  the String to pad the new String with, must not be null or empty\n-     * @return centered String, <code>null</code> if null string input\n-     * @throws IllegalArgumentException if padStr is <code>null</code> or empty\n-     */\n-    public static String center(String str, int size, String padStr) {\n-        if (str == null) {\n-            return null;\n-        }\n-        if (padStr == null || padStr.length() == 0) {\n-            throw new IllegalArgumentException(\"Pad String must not be null or empty\");\n-        }\n-        if (size < 0) {\n-            size = 0;\n-        }\n-        int sz = str.length();\n-        int p = size - sz;\n-        if (p < 1) {\n-            return str;\n-        }\n-        str = leftPad(str, sz + p / 2, padStr);\n-        str = rightPad(str, size, padStr);\n-        return str;\n-    }\n-\n     // Chomping\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n \n     /**\n      * <p>Remove one newline from end of a String if it's there,\n      * For the previous behavior, use {@link #slice(String)}.</p>\n      *\n      * @param str  the String to chomp a newline from, may be null\n-     * @return String without newline, <code>null</code> if null string input\n+     * @return String without newline, <code>null</code> if null String input\n      */\n     public static String chomp(String str) {\n         if (str == null || str.length() == 0) {\n      * It now more closely matches Perl chomp.\n      * For the previous behavior, use {@link #slice(String,String)}.</p>\n      *\n-     * @param str  string to chomp from, may be null\n-     * @param separator  separator string\n-     * @return String without trailing separator, <code>null</code> if null string input\n+     * @param str  the String to chomp from, may be null\n+     * @param separator  separator String, may be null\n+     * @return String without trailing separator, <code>null</code> if null String input\n      */\n     public static String chomp(String str, String separator) {\n-        if (str == null || str.length() == 0) {\n+        if (str == null || str.length() == 0 || separator == null) {\n             return str;\n         }\n         if (str.endsWith(separator)) {\n     }\n \n     // Chopping\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n      * <p>Remove the last character from a String.</p>\n      * of them.</p>\n      *\n      * @param str  the String to chop last character from, may be null\n-     * @return String without last character, <code>null</code> if null string input\n+     * @return String without last character, <code>null</code> if null String input\n      */\n     public static String chop(String str) {\n         if (str == null) {\n \n \n     // Slicing\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n \n     /**\n      * <p>Remove the last newline, and everything after it from a String.</p>\n      * <p><em>(This method was formerly named chomp or chopNewline.)</em></p>\n      *\n      * @param str  the String to slice the newline from, may be null\n-     * @return String without sliced newline, <code>null</code> if null string input\n+     * @return String without sliced newline, <code>null</code> if null String input\n      */\n     public static String slice(String str) {\n         return slice(str, \"\\n\");\n      * <p><em>(This method was formerly named chomp.)</em></p>\n      *\n      * @param str  the String to slice from, may be null\n-     * @param sep  the String to slice, may be null\n-     * @return String without sliced ending, <code>null</code> if null string input\n-     */\n-    public static String slice(String str, String sep) {\n-        if (str == null || sep == null || str.length() == 0 || sep.length() == 0) {\n+     * @param separator  the String to slice, may be null\n+     * @return String without sliced ending, <code>null</code> if null String input\n+     */\n+    public static String slice(String str, String separator) {\n+        if (str == null || separator == null || str.length() == 0 || separator.length() == 0) {\n             return str;\n         }\n-        int idx = str.lastIndexOf(sep);\n+        int idx = str.lastIndexOf(separator);\n         if (idx != -1) {\n             return str.substring(0, idx);\n         } else {\n      * include the separator in the return value.)</em></p>\n      *\n      * @param str  the String to slice from, may be null\n-     * @param sep  the String to slice, may be null\n-     * @return String sliced, <code>null</code> if null string input\n-     */\n-    public static String sliceRemainder(String str, String sep) {\n+     * @param separator  the String to slice, may be null\n+     * @return String sliced, <code>null</code> if null String input\n+     */\n+    public static String sliceRemainder(String str, String separator) {\n         if (str == null || str.length() == 0) {\n             return str;\n         }\n-        if (sep == null || sep.length() == 0) {\n+        if (separator == null || separator.length() == 0) {\n             return \"\";\n         }\n-        int idx = str.lastIndexOf(sep);\n-        if (idx == str.length() - sep.length()) {\n+        int idx = str.lastIndexOf(separator);\n+        if (idx == str.length() - separator.length()) {\n             return \"\";\n         } else if (idx != -1) {\n-            return str.substring(idx + sep.length());\n+            return str.substring(idx + separator.length());\n         } else {\n             return \"\";\n         }\n      * it included the separator in the return value; now it does not.)</em></p>\n      *\n      * @param str  the String to slice from, may be null\n-     * @param sep  the String to slice, may be null\n-     * @return String without sliced beginning, <code>null</code> if null string input\n-     */\n-    public static String sliceFirstRemainder(String str, String sep) {\n+     * @param separator  the String to slice, may be null\n+     * @return String without sliced beginning, <code>null</code> if null String input\n+     */\n+    public static String sliceFirstRemainder(String str, String separator) {\n         if (str == null || str.length() == 0) {\n             return str;\n         }\n-        if (sep == null || sep.length() == 0) {\n+        if (separator == null || separator.length() == 0) {\n             return \"\";\n         }\n-        int idx = str.indexOf(sep);\n+        int idx = str.indexOf(separator);\n         if (idx != -1) {\n-            return str.substring(idx + sep.length());\n+            return str.substring(idx + separator.length());\n         } else {\n             return str;\n         }\n     }\n \n     /**\n-     * <p>Find the first occurence of a separator string;\n+     * <p>Find the first occurence of a separator String;\n      * return everything before it (but not including the separator).</p>\n      *\n      * <p><em>(This method was formerly named getPrechomp.  Also, it used to\n      * include the separator, but now it does not.)</em></p>\n      *\n      * @param str  the String to slice from, may be null\n-     * @param sep  the String to slice, may be null\n-     * @return String presliced, <code>null</code> if null string input\n-     */\n-    public static String sliceFirst(String str, String sep) {\n-        if (str == null || sep == null || str.length() == 0 || sep.length() == 0) {\n+     * @param separator  the String to slice, may be null\n+     * @return sliced String, <code>null</code> if null String input\n+     */\n+    public static String sliceFirst(String str, String separator) {\n+        if (str == null || separator == null || str.length() == 0 || separator.length() == 0) {\n             return str;\n         }\n-        int idx = str.indexOf(sep);\n+        int idx = str.indexOf(separator);\n         if (idx != -1) {\n             return str.substring(0, idx);\n         } else {\n     }\n \n     // Conversion\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n      * <p>Escapes any values it finds into their String form.</p>\n      * <p>So a tab becomes the characters <code>'\\\\'</code> and\n      * <code>'t'</code>.</p>\n      *\n-     * <p>As of Lang 2.0, this calls {@link StringEscapeUtils#escapeJava(java.lang.String)}\n+     * <p>As of Lang 2.0, this calls {@link StringEscapeUtils#escapeJava(String)}\n      * behind the scenes.\n      * </p>\n      * @see StringEscapeUtils#escapeJava(java.lang.String)\n      * @param str String to escape values in\n      * @return String with escaped values\n      * @throws NullPointerException if str is <code>null</code>\n-     * @deprecated Use {@link StringEscapeUtils#escapeJava(java.lang.String)}\n+     * @deprecated Use {@link StringEscapeUtils#escapeJava(String)}\n      *             This method will be removed in Commons Lang 3.0\n      */\n     public static String escape(String str) {\n     }\n \n     // Padding\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n      * <p>Repeat a String <code>repeat</code> times to form a\n-     * new string.</p>\n+     * new String.</p>\n      *\n      * <pre>\n      * StringUtils.repeat(null, 2) = null\n      * @param str  the String to repeat, may be null\n      * @param repeat  number of times to repeat str, negative treated as zero\n      * @return a new String consisting of the original String repeated,\n-     *  <code>null</code> if null string input\n+     *  <code>null</code> if null String input\n      */\n     public static String repeat(String str, int repeat) {\n         if (str == null) {\n     }\n \n     /**\n-     * <p>Returns a string containing the requested number of \n+     * <p>Returns a String containing the requested number of \n      * space characters (' ').</p>\n      * \n      * <pre>\n      * </pre>\n      *\n      * @param str  the String to pad out, may be null\n-     * @param size  the size of the returned string, padded on the right\n+     * @param size  the size to pad to\n      * @return right padded String or original String if no padding is necessary,\n-     *  <code>null</code> if null string input\n+     *  <code>null</code> if null String input\n      */\n     public static String rightPad(String str, int size) {\n         if (str == null) {\n         }\n         int pads = size - str.length();\n         if (pads <= 0) {\n-            return str; // returns original string when possible\n+            return str; // returns original String when possible\n         }\n         if (pads > PAD_LIMIT) {\n             return rightPad(str, size, ' ');\n      * @param size  the size to pad to\n      * @param padChar  the character to pad with\n      * @return right padded String or original String if no padding is necessary,\n-     *  <code>null</code> if null string input\n+     *  <code>null</code> if null String input\n      */\n     public static String rightPad(String str, int size, char padChar) {\n         if (str == null) {\n         }\n         int pads = size - str.length();\n         if (pads <= 0) {\n-            return str; // returns original string when possible\n+            return str; // returns original String when possible\n         }\n         if (pads > PAD_LIMIT) {\n             return rightPad(str, size, String.valueOf(padChar));\n     }\n \n     /**\n-     * <p>Right pad a String with a specified string.</p>\n+     * <p>Right pad a String with a specified String.</p>\n      *\n      * <p>The String is padded to the size of <code>size</code>.</p>\n      *\n      * @param size  the size to pad to\n      * @param padStr  the String to pad with, must not be null\n      * @return right padded String or original String if no padding is necessary,\n-     *  <code>null</code> if null string input\n+     *  <code>null</code> if null String input\n      * @throws IllegalArgumentException if padStr is the empty String or null\n      */\n     public static String rightPad(String str, int size, String padStr) {\n      * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @return left padded String or original String if no padding is necessary,\n-     *  <code>null</code> if null string input\n+     *  <code>null</code> if null String input\n      */\n     public static String leftPad(String str, int size) {\n         if (str == null) {\n         }\n         int pads = size - str.length();\n         if (pads <= 0) { \n-            return str; // returns original string when possible\n+            return str; // returns original String when possible\n         }\n         if (pads > PAD_LIMIT) {\n             return leftPad(str, size, ' ');\n      * @param size  the size to pad to\n      * @param padChar  the character to pad with\n      * @return left padded String or original String if no padding is necessary,\n-     *  <code>null</code> if null string input\n+     *  <code>null</code> if null String input\n      */\n     public static String leftPad(String str, int size, char padChar) {\n         if (str == null) {\n         }\n         int pads = size - str.length();\n         if (pads <= 0) {\n-            return str; // returns original string when possible\n+            return str; // returns original String when possible\n         }\n         if (pads > PAD_LIMIT) {\n             return leftPad(str, size, ' ');\n     }\n \n     /**\n-     * <p>Left pad a String with a specified string.</p>\n+     * <p>Left pad a String with a specified String.</p>\n      *\n      * <p>Pad to a size of <code>size</code>.</p>\n      *\n      * @param size  the size to pad to\n      * @param padStr  the String to pad with, must not be null\n      * @return left padded String or original String if no padding is necessary,\n-     *  <code>null</code> if null string input\n+     *  <code>null</code> if null String input\n      * @throws IllegalArgumentException if padStr is the empty String or null\n      */\n     public static String leftPad(String str, int size, String padStr) {\n         return str;\n     }\n \n+    // Centering\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>\n+     * using the space character (' ').<p>\n+     * \n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <p>Equivalent to <code>center(str, size, \" \")</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, -1)  = null\n+     * StringUtils.center(null, 4)   = null\n+     * StringUtils.center(\"\", 4)     = \"    \"\n+     * StringUtils.center(\"ab\", 4)   = \" ab \"\n+     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n+     * StringUtils.center(\"a\", 4)    = \" a  \"\n+     * </pre>\n+     * \n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @return centered String, <code>null</code> if null String input\n+     */\n+    public static String center(String str, int size) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (size < 0) {\n+            size = 0;\n+        }\n+        int sz = str.length();\n+        int p = size - sz;\n+        if (p < 1) {\n+            return str;\n+        }\n+        str = leftPad(str, sz + p / 2, ' ');\n+        str = rightPad(str, size, ' ');\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>.</p>\n+     *\n+     * <p>Uses a supplied String as the value to pad the String with.</p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, -1, \" \")  = null\n+     * StringUtils.center(null, 4, \" \")   = null\n+     * StringUtils.center(\"\", 4, \" \")     = \"    \"\n+     * StringUtils.center(\"ab\", 4, \" \")   = \" ab\"\n+     * StringUtils.center(\"abcd\", 2, \" \") = \" abcd\"\n+     * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n+     * StringUtils.center(\"a\", 4, \"yz\")    = \"yayz\"\n+     * StringUtils.center(\"abc\", 4, null) = IllegalArgumentException\n+     * StringUtils.center(\"abc\", 4, \"\")   = IllegalArgumentException\n+     * </pre>\n+     * \n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @param padStr  the String to pad the new String with, must not be null or empty\n+     * @return centered String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if padStr is <code>null</code> or empty\n+     */\n+    public static String center(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (padStr == null || padStr.length() == 0) {\n+            throw new IllegalArgumentException(\"Pad String must not be null or empty\");\n+        }\n+        if (size < 0) {\n+            size = 0;\n+        }\n+        int sz = str.length();\n+        int p = size - sz;\n+        if (p < 1) {\n+            return str;\n+        }\n+        str = leftPad(str, sz + p / 2, padStr);\n+        str = rightPad(str, size, padStr);\n+        return str;\n+    }\n+\n     // Stripping\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n-     * <p>Remove whitespace from the front and back of a String.</p>\n-     * \n-     * @param str the String to remove whitespace from\n-     * @return the stripped String\n+     * <p>Strips whitespace from the start and end of a String.\n+     * This is similar to {@link String#trim()} but instead removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     * \n+     * <p>If the input String is <code>null</code>, <code>null</code>\n+     * is returned.</p>\n+     * \n+     * <pre>\n+     * StringUtils.strip(null)     = null\n+     * StringUtils.strip(\"abc\")    = \"abc\"\n+     * StringUtils.strip(\"  abc\")  = \"abc\"\n+     * StringUtils.strip(\"abc  \")  = \"abc\"\n+     * StringUtils.strip(\" abc \")  = \"abc\"\n+     * StringUtils.strip(\" ab c \") = \"ab c\"\n+     * </pre>\n+     * \n+     * @param str  the String to remove whitespace from, may be null\n+     * @return the stripped String, <code>null</code> if null String input\n      */\n     public static String strip(String str) {\n         return strip(str, null);\n     }\n-    /**\n-     * <p>Remove a specified String from the front and back of a\n-     * String.</p>\n-     *\n-     * <p>If whitespace is wanted to be removed, used the\n-     * {@link #strip(java.lang.String)} method.</p>\n-     * \n-     * @param str the String to remove a string from\n-     * @param delim the String to remove at start and end\n-     * @return the stripped String\n-     */\n-    public static String strip(String str, String delim) {\n-        str = stripStart(str, delim);\n-        return stripEnd(str, delim);\n-    }\n-\n-    /**\n-     * <p>Strip whitespace from the front and back of every String\n-     * in the array.</p>\n-     * \n-     * @param strs the Strings to remove whitespace from\n-     * @return the stripped Strings\n+    \n+    /**\n+     * <p>Strips any of a set of characters from the start and end of a String.\n+     * This is similar to {@link String#trim()} but allows the characters\n+     * to be stripped to be controlled.</p>\n+     *\n+     * <p>If the input String is <code>null</code>, <code>null</code>\n+     * is returned.</p>\n+     * \n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.\n+     * Alternatively use {@link #strip(String)}.</p>\n+     * \n+     * <pre>\n+     * StringUtils.strip(null, null)       = null\n+     * StringUtils.strip(\"abc\", null)      = \"abc\"\n+     * StringUtils.strip(\"  abc\", null)    = \"abc\"\n+     * StringUtils.strip(\"abc  \", null)    = \"abc\"\n+     * StringUtils.strip(\" abc \", null)    = \"abc\"\n+     * StringUtils.strip(\"  abcyx\", \"xyz\") = \"  abc\"\n+     * </pre>\n+     * \n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String strip(String str, String stripChars) {\n+        str = stripStart(str, stripChars);\n+        return stripEnd(str, stripChars);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start of a String.</p>\n+     *\n+     * <p>If the input String is <code>null</code>, <code>null</code>\n+     * is returned.</p>\n+     * \n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n+     * \n+     * <pre>\n+     * StringUtils.strip(null, null)       = null\n+     * StringUtils.strip(\"abc\", null)      = \"abc\"\n+     * StringUtils.strip(\"  abc\", null)    = \"abc\"\n+     * StringUtils.strip(\"abc  \", null)    = \"abc  \"\n+     * StringUtils.strip(\" abc \", null)    = \"abc \"\n+     * StringUtils.strip(\"yxabc  \", \"xyz\") = \"abc  \"\n+     * </pre>\n+     * \n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String stripStart(String str, String stripChars) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int sz = str.length();\n+        if (sz == 0) {\n+            return str;\n+        }\n+ \n+        int start = 0;\n+        if (stripChars == null) {\n+            while ((start != sz) && Character.isWhitespace(str.charAt(start))) {\n+                start++;\n+            }\n+        } else {\n+            while ((start != sz) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n+                start++;\n+            }\n+        }\n+        return str.substring(start);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the end of a String.</p>\n+     *\n+     * <p>If the input String is <code>null</code>, <code>null</code>\n+     * is returned.</p>\n+     * \n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n+     * \n+     * <pre>\n+     * StringUtils.strip(null, null)       = null\n+     * StringUtils.strip(\"abc\", null)      = \"abc\"\n+     * StringUtils.strip(\"  abc\", null)    = \"  abc\"\n+     * StringUtils.strip(\"abc  \", null)    = \"abc\"\n+     * StringUtils.strip(\" abc \", null)    = \" abc\"\n+     * StringUtils.strip(\"  abcyx\", \"xyz\") = \"  abc\"\n+     * </pre>\n+     * \n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String stripEnd(String str, String stripChars) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int end = str.length();\n+        if (end == 0) {\n+            return str;\n+        }\n+ \n+        if (stripChars == null) {\n+            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n+                end--;\n+            }\n+        } else {\n+            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != -1)) {\n+                end--;\n+            }\n+        }\n+        return str.substring(0, end);\n+    }\n+\n+    /**\n+     * <p>Strips whitespace from the start and end of every String in an array.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A new array is returned each time, except for length zero.\n+     * A <code>null</code> array will return <code>null</code>.\n+     * An empty array will return itself.\n+     * A <code>null</code> array entry will be ignored.</p>\n+     * \n+     * <pre>\n+     * StringUtils.stripAll(null)             = null\n+     * StringUtils.stripAll([])               = []\n+     * StringUtils.stripAll([\"abc\", \"  abc\"]) = [\"abc\", \"abc\"]\n+     * StringUtils.stripAll([\"abc  \", null])  = [\"abc\", null]\n+     * </pre>\n+     * \n+     * @param str  the array to remove whitespace from, may be null\n+     * @return the stripped Strings, <code>null</code> if null array input\n      */\n     public static String[] stripAll(String[] strs) {\n         return stripAll(strs, null);\n     }\n  \n     /**\n-     * <p>Strip the specified delimiter from the front and back of\n-     * every String in the array.</p>\n-     * \n-     * @param strs the Strings to remove a String from\n-     * @param delimiter the String to remove at start and end\n-     * @return the stripped Strings\n-     */\n-    public static String[] stripAll(String[] strs, String delimiter) {\n+     * <p>Strips any of a set of characters from the start and end of every\n+     * String in an array.</p>\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A new array is returned each time, except for length zero.\n+     * A <code>null</code> array will return <code>null</code>.\n+     * An empty array will return itself.\n+     * A <code>null</code> array entry will be ignored.\n+     * A <code>null</code> stripChars will strip whitespace as defined by\n+     * {@link Character#isWhitespace(char)}.</p>\n+     * \n+     * <pre>\n+     * StringUtils.stripAll(null, null)             = null\n+     * StringUtils.stripAll([], null)               = []\n+     * StringUtils.stripAll([\"abc\", \"  abc\"], null) = [\"abc\", \"abc\"]\n+     * StringUtils.stripAll([\"abc  \", null], null)  = [\"abc\", null]\n+     * StringUtils.stripAll([\"abc  \", null], \"yz\")  = [\"abc  \", null]\n+     * StringUtils.stripAll([\"yabcz\", null], \"yz\")  = [\"abc\", null]\n+     * </pre>\n+     * \n+     * @param str  the array to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped Strings, <code>null</code> if null array input\n+     */\n+    public static String[] stripAll(String[] strs, String stripChars) {\n         if ((strs == null) || (strs.length == 0)) {\n             return strs;\n         }\n         int sz = strs.length;\n         String[] newArr = new String[sz];\n         for (int i = 0; i < sz; i++) {\n-            newArr[i] = strip(strs[i], delimiter);\n+            newArr[i] = strip(strs[i], stripChars);\n         }\n         return newArr;\n     }   \n \n-    /**\n-     * <p>Strip any of a supplied String from the end of a String.</p>\n-     *\n-     * <p>If the strip String is <code>null</code>, whitespace is\n-     * stripped.</p>\n-     * \n-     * @param str the String to remove characters from\n-     * @param strip the String to remove\n-     * @return the stripped String\n-     */\n-    public static String stripEnd(String str, String strip) {\n-        if (str == null) {\n-            return null;\n-        }\n-        int end = str.length();\n- \n-        if (strip == null) {\n-            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n-                end--;\n-            }\n-        } else {\n-            while ((end != 0) && (strip.indexOf(str.charAt(end - 1)) != -1)) {\n-                end--;\n-            }\n-        }\n-        return str.substring(0, end);\n-    }\n-\n-    /**\n-     * <p>Strip any of a supplied String from the start of a String.</p>\n-     *\n-     * <p>If the strip String is <code>null</code>, whitespace is\n-     * stripped.</p>\n-     * \n-     * @param str the String to remove characters from\n-     * @param strip the String to remove\n-     * @return the stripped String\n-     */\n-    public static String stripStart(String str, String strip) {\n-        if (str == null) {\n-            return null;\n-        }\n- \n-        int start = 0;\n- \n-        int sz = str.length();\n- \n-        if (strip == null) {\n-            while ((start != sz) && Character.isWhitespace(str.charAt(start))) {\n-                start++;\n-            }\n-        } else {\n-            while ((start != sz) && (strip.indexOf(str.charAt(start)) != -1)) {\n-                start++;\n-            }\n-        }\n-        return str.substring(start);\n-    }\n-\n     // Case conversion\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n-     * <p>Convert a String to upper case, <code>null</code> String\n-     * returns <code>null</code>.</p>\n-     * \n-     * @param str the String to uppercase\n-     * @return the upper cased String\n+     * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>\n+     * \n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.upperCase(null)  = null\n+     * StringUtils.upperCase(\"aBc\") = \"ABC\"\n+     * </pre>\n+     * \n+     * @param str  the String to upper case, may be null\n+     * @return the upper cased String, <code>null</code> if null String input\n      */\n     public static String upperCase(String str) {\n         if (str == null) {\n     }\n \n     /**\n-     * <p>Convert a String to lower case, <code>null</code> String\n-     * returns <code>null</code>.</p>\n-     * \n-     * @param str the string to lowercase\n-     * @return the lower cased String\n+     * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>\n+     * \n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.lowerCase(null)  = null\n+     * StringUtils.lowerCase(\"aBc\") = \"abc\"\n+     * </pre>\n+     * \n+     * @param str  the String to lower case, may be null\n+     * @return the lower cased String, <code>null</code> if null String input\n      */\n     public static String lowerCase(String str) {\n         if (str == null) {\n     }\n \n     /**\n-     * <p>Uncapitalise a String.</p>\n-     *\n-     * <p>That is, convert the first character into lower-case.\n-     * <code>null</code> is returned as <code>null</code>.</p>\n-     *\n-     * @param str the String to uncapitalise\n-     * @return uncapitalised String\n+     * <p>Capitalises a String changing the first letter to title case as\n+     * per {@link Character#toTitleCase()}. No other letters are changed.</p>\n+     * \n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.capitalise(null)  = null\n+     * StringUtils.capitalise(\"cat\") = \"Cat\"\n+     * StringUtils.capitalise(\"cAt\") = \"CAt\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalise, may be null\n+     * @return the capitalised String, <code>null</code> if null String input\n+     */\n+    public static String capitalise(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0) {\n+            return \"\";\n+        }\n+        return new StringBuffer(str.length())\n+            .append(Character.toTitleCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Uncapitalises a String changing the first letter to title case as\n+     * per {@link Character#toLowerCase()}. No other letters are changed.</p>\n+     * \n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.uncapitalise(null)  = null\n+     * StringUtils.uncapitalise(\"Cat\") = \"cat\"\n+     * StringUtils.uncapitalise(\"CAT\") = \"cAT\"\n+     * </pre>\n+     * \n+     * @param str  the String to uncapitalise, may be null\n+     * @return the uncapitalised String, <code>null</code> if null String input\n      */\n     public static String uncapitalise(String str) {\n         if (str == null) {\n             return null;\n         }\n-        else if (str.length() == 0) {\n+        if (str.length() == 0) {\n             return \"\";\n         }\n-        else {\n-            return new StringBuffer(str.length())\n-                .append(Character.toLowerCase(str.charAt(0)))\n-                .append(str.substring(1))\n-                .toString();\n-        }\n-    }\n-\n-    /**\n-     * <p>Capitalise a String.</p>\n-     *\n-     * <p>That is, convert the first character into title-case.\n-     * <code>null</code> is returned as <code>null</code>.</p>\n-     *\n-     * @param str the String to capitalise\n-     * @return capitalised String\n-     */\n-    public static String capitalise(String str) {\n-        if (str == null) {\n-            return null;\n-        }\n-        else if (str.length() == 0) {\n-            return \"\";\n-        }\n-        else {\n-            return new StringBuffer(str.length())\n-                .append(Character.toTitleCase(str.charAt(0)))\n-                .append(str.substring(1))\n-                .toString();\n-        }\n-    }\n-\n-    /**\n-     * <p>Swaps the case of String.</p>\n-     *\n-     * <p>Properly looks after making sure the start of words\n-     * are Titlecase and not Uppercase.</p>\n-     *\n-     * <p><code>null</code> is returned as <code>null</code>.</p>\n-     * \n-     * @param str the String to swap the case of\n-     * @return the modified String\n+        return new StringBuffer(str.length())\n+            .append(Character.toLowerCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Swaps the case of a String using a word based algorithm.</p>\n+     * \n+     * <ul>\n+     *  <li>Upper case character converts to Lower case\n+     *  <li>Title case character converts to Lower case\n+     *  <li>Lower case character after Whitespace or at start converts to Title case\n+     *  <li>Other Lower case character converts to Upper case\n+     * </ul>\n+     * \n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.swapCase(null)                 = null\n+     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n+     * </pre>\n+     * \n+     * @param str  the String to swap case, may be null\n+     * @return the changed String, <code>null</code> if null String input\n      */\n     public static String swapCase(String str) {\n         if (str == null) {\n         int sz = str.length();\n         StringBuffer buffer = new StringBuffer(sz);\n \n-        boolean whitespace = false;\n+        boolean whitespace = true;\n         char ch = 0;\n         char tmp = 0;\n \n         return buffer.toString();\n     }\n \n-\n-    /**\n-     * <p>Capitalise all the words in a String.</p>\n-     *\n-     * <p>Uses {@link Character#isWhitespace(char)} as a\n-     * separator between words.</p>\n-     *\n-     * <p><code>null</code> will return <code>null</code>.</p>\n-     *\n-     * @param str the String to capitalise\n-     * @return capitalised String\n+    /**\n+     * <p>Capitalises all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.capitaliseAllWords(null)        = null\n+     * StringUtils.capitaliseAllWords(\"i am FINE\") = \"I Am FINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalise, may be null\n+     * @return capitalised String, <code>null</code> if null String input\n      */\n     public static String capitaliseAllWords(String str) {\n         if (str == null) {\n         }\n         int sz = str.length();\n         StringBuffer buffer = new StringBuffer(sz);\n-        boolean space = true;\n+        boolean whitespace = true;\n         for (int i = 0; i < sz; i++) {\n             char ch = str.charAt(i);\n             if (Character.isWhitespace(ch)) {\n                 buffer.append(ch);\n-                space = true;\n-            } else if (space) {\n+                whitespace = true;\n+            } else if (whitespace) {\n                 buffer.append(Character.toTitleCase(ch));\n-                space = false;\n+                whitespace = false;\n             } else {\n                 buffer.append(ch);\n             }\n     }\n \n     /**\n-     * <p>Uncapitalise all the words in a string.</p>\n-     *\n-     * <p>Uses {@link Character#isWhitespace(char)} as a\n-     * separator between words.</p>\n-     *\n-     * <p><code>null</code> will return <code>null</code>.</p>\n-     *\n-     * @param str  the string to uncapitalise\n-     * @return uncapitalised string\n+     * <p>Uncapitalises all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.uncapitaliseAllWords(null)        = null\n+     * StringUtils.uncapitaliseAllWords(\"I Am FINE\") = \"i am fINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to uncapitalise, may be null\n+     * @return uncapitalised String, <code>null</code> if null String input\n      */\n     public static String uncapitaliseAllWords(String str) {\n         if (str == null) {\n     }\n \n     // Nested extraction\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n-     * <p>Get the String that is nested in between two instances of the\n+     * <p>Gets the String that is nested in between two instances of the\n      * same String.</p>\n      *\n-     * <p>If <code>str</code> is <code>null</code>, will\n-     * return <code>null</code>.</p>\n-     *\n-     * @param str the String containing nested-string\n-     * @param tag the String before and after nested-string\n-     * @return the String that was nested, or <code>null</code>\n-     * @throws NullPointerException if tag is <code>null</code>\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> tag returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.getNestedString(null, \"tag\")        = null\n+     * StringUtils.getNestedString(\"tagabctag\", null)  = null\n+     * StringUtils.getNestedString(\"tagabctag\", \"\")    = \"\"\n+     * StringUtils.getNestedString(\"tagabctag\", \"tag\") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing nested-string, may be null\n+     * @param tag  the String before and after nested-string, may be null\n+     * @return the nested String, <code>null</code> if no match\n      */\n     public static String getNestedString(String str, String tag) {\n         return getNestedString(str, tag, tag);\n     }\n     \n     /**\n-     * <p>Get the String that is nested in between two Strings.</p>\n-     *\n-     * @param str the String containing nested-string\n-     * @param open the String before nested-string\n-     * @param close the String after nested-string\n-     * @return the String that was nested, or <code>null</code>\n-     * @throws NullPointerException if open or close is <code>null</code>\n+     * <p>Gets the String that is nested in between two Strings.\n+     * Only the first match is returned.</p>\n+     * \n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> open/close returns <code>null</code> (no match).\n+     * An empty (\"\") open/close returns an empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.getNestedString(null, \"y\", \"z\")      = null\n+     * StringUtils.getNestedString(\"yabcz\", null, null) = null\n+     * StringUtils.getNestedString(\"yabcz\", \"\", \"\")     = \"\"\n+     * StringUtils.getNestedString(\"yabcz\", \"y\", \"z\")   = \"abc\"\n+     * StringUtils.getNestedString(\"yabczyabcz\", \"y\", \"z\")   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing nested-string, may be null\n+     * @param open  the String before nested-string, may be null\n+     * @param close  the String after nested-string, may be null\n+     * @return the nested String, <code>null</code> if no match\n      */\n     public static String getNestedString(String str, String open, String close) {\n-        if (str == null) {\n+        if (str == null || open == null || close == null) {\n             return null;\n         }\n         int start = str.indexOf(open);\n         return null;\n     }\n \n+    // Count matches\n+    //-----------------------------------------------------------------------\n+    \n     /**\n      * <p>How many times is the substring in the larger String.</p>\n      *\n     }\n \n     // Character Tests\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n      * <p>Checks if the String contains only unicode letters.</p>\n         return true;\n     }\n \n-    /**\n-     * <p>Checks if the String contains only certain chars.</p>\n-     *\n-     * @param str  the String to check, may be null\n-     * @param validChars  a string of valid chars, may be null\n-     * @return true if it only contains valid chars and is non-null\n-     */\n-    public static boolean containsOnly(String str, String validChars) {\n-        if (str == null || validChars == null) {\n-            return false;\n-        }\n-        return containsOnly(str, validChars.toCharArray());\n-    }\n-    \n-    /**\n-     * <p>Checks that the String does not contain certain chars.</p>\n-     *\n-     * @param str  the String to check, may be null\n-     * @param invalidChars  a string of invalid chars, may be null\n-     * @return true if it contains none of the invalid chars, or is null\n-     */\n-    public static boolean containsNone(String str, String invalidChars) {\n-        if (str == null || invalidChars == null) {\n-            return true;\n-        }\n-        return containsNone(str, invalidChars.toCharArray());\n-    }\n-    \n-    /**\n-     * <p>Checks that the String does not contain certain chars.</p>\n-     *\n-     * @param str  the String to check, may be null\n-     * @param invalidChars  an array of invalid chars, may be null\n-     * @return true if it contains none of the invalid chars, or is null\n-     */\n-    public static boolean containsNone(String str, char[] invalidChars) {\n-        if (str == null || invalidChars == null) {\n-            return true;\n-        }\n-        int strSize = str.length();\n-        int validSize = invalidChars.length;\n-        for (int i = 0; i < strSize; i++) {\n-            char ch = str.charAt(i);\n-            for (int j = 0; j < validSize; j++) {\n-                if (invalidChars[j] == ch) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * <p>Checks if the String contains only certain chars.</p>\n-     *\n-     * @param str  the String to check, may be null\n-     * @param valid  an array of valid chars, may be null\n-     * @return true if it only contains valid chars and is non-null\n-     */\n-    public static boolean containsOnly(String str, char[] valid) {\n-        // All these pre-checks are to maintain API with an older version\n-        if ( (valid == null) || (str == null) ) {\n-            return false;\n-        }\n-        if (str.length() == 0) {\n-            return true;\n-        }\n-        if (valid.length == 0) {\n-            return false;\n-        }\n-        return indexOfAnyBut(str, valid) == -1;\n-    }\n-\n-    /**\n-     * <p>Search a String to find the first index of any\n-     * character not in the given set of characters.</p>\n-     * \n-     * @param str  the String to check, may be null\n-     * @param searchChars  the chars to search for, may be null\n-     * @return the index of any of the chars, -1 if no match or null input\n-     */\n-     public static int indexOfAnyBut(String str, char[] searchChars) {\n-         if (searchChars == null) {\n-             return -1;\n-         }\n-         return indexOfAnyBut(str, new String(searchChars));\n-     }\n-\n-    /**\n-     * <p>Search a String to find the first index of any\n-     * character not in the given set of characters.</p>\n-     * \n-     * @param str  the String to check, may be null\n-     * @param searchChars  the chars to search for, may be null\n-     * @return the index of any of the chars, -1 if no match or null input\n-     */\n-    public static int indexOfAnyBut(String str, String searchChars) {\n-        if (str == null || searchChars == null) {\n-            return -1;\n-        }\n-\n-        for (int i = 0; i < str.length(); i ++) {\n-           if (searchChars.indexOf(str.charAt(i)) < 0) {\n-               return i;\n-           }\n-        }\n-\n-        return -1;\n-    }\n-\n     // Defaults\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     \n     /**\n      * <p>Returns either the passed in String, \n      * </pre>\n      * \n      * @param str  the String to check, may be null\n-     * @return the passed in String, or the empty string if it\n+     * @return the passed in String, or the empty String if it\n      *  was <code>null</code>\n      */\n     public static String defaultString(String str) {\n      * </pre>\n      * \n      * @param obj  the Object to check, using <code>toString()</code>, may be null\n-     * @return the passed in Object's toString, or the empty string if it\n+     * @return the passed in Object's toString, or the empty String if it\n      *  was <code>null</code>\n      */\n     public static String defaultString(Object obj) {\n     }\n \n     // Reversing\n-    //--------------------------------------------------------------------------\n-\n-    /**\n-     * <p>Reverse a String.</p>\n-     *\n-     * <p><code>null</code> String returns <code>null</code>.</p>\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * <p>Reverse a String as per {@link StringBuffer#reverse()}.</p>\n+     *\n+     * <p><A code>null</code> String returns <code>null</code>.</p>\n      * \n      * <pre>\n      * StringUtils.reverse(null)  = null\n      * </pre>\n      * \n      * @param str  the String to reverse, may be null\n-     * @return the reversed String, <code>null</code> if null string input\n+     * @return the reversed String, <code>null</code> if null String input\n      */\n     public static String reverse(String str) {\n         if (str == null) {\n      * Thus java.lang.String becomes String.lang.java (if the delimiter\n      * is <code>'.'</code>).</p>\n      * \n-     * @param str  the String to reverse\n-     * @param delimiter  the delimiter to use\n-     * @return the reversed String\n-     */\n-    public static String reverseDelimitedString(String str, String delimiter) {\n+     * <pre>\n+     * StringUtils.reverseDelimitedString(null, '.')    = null\n+     * StringUtils.reverseDelimitedString(\"\", '.')      = \"\"\n+     * StringUtils.reverseDelimitedString(\"a.b.c\", 'x') = \"a.b.c\"\n+     * StringUtils.reverseDelimitedString(\"a.b.c\", \".\") = \"c.b.a\"\n+     * </pre>\n+     * \n+     * @param str  the String to reverse, may be null\n+     * @param separatorChar  the separator character to use\n+     * @return the reversed String, <code>null</code> if null String input\n+     */\n+    public static String reverseDelimitedString(String str, char separatorChar) {\n+        if (str == null) {\n+            return null;\n+        }\n         // could implement manually, but simple way is to reuse other, \n         // probably slower, methods.\n-        String[] strs = split(str, delimiter);\n+        String[] strs = split(str, separatorChar);\n         ArrayUtils.reverse(strs);\n-        return join(strs, delimiter);\n+        return join(strs, separatorChar);\n+    }\n+\n+    /**\n+     * <p>Reverses a String that is delimited by a specific character.</p>\n+     *\n+     * <p>The Strings between the delimiters are not reversed.\n+     * Thus java.lang.String becomes String.lang.java (if the delimiter\n+     * is <code>\".\"</code>).</p>\n+     * \n+     * <pre>\n+     * StringUtils.reverseDelimitedString(null, null)    = null\n+     * StringUtils.reverseDelimitedString(\"\", null)      = \"\"\n+     * StringUtils.reverseDelimitedString(\"a.b.c\", null) = \"a.b.c\"\n+     * StringUtils.reverseDelimitedString(\"a.b.c\", \".\")  = \"c.b.a\"\n+     * </pre>\n+     * \n+     * @param str  the String to reverse, may be null\n+     * @param separatorChars  the separator characters to use, null treated as whitespace\n+     * @return the reversed String, <code>null</code> if null String input\n+     * @deprecated Use {@link #reverseDelimitedString(String, char)} instead.\n+     *      This method is broken as the join doesn't know which char to use.\n+     *      Method will be removed in Commons Lang 3.0.\n+     * \n+     */\n+    public static String reverseDelimitedString(String str, String separatorChars) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // could implement manually, but simple way is to reuse other, \n+        // probably slower, methods.\n+        String[] strs = split(str, separatorChars);\n+        ArrayUtils.reverse(strs);\n+        if (separatorChars == null) {\n+            return join(strs, ' ');\n+        }\n+        return join(strs, separatorChars);\n     }\n \n     // Abbreviating\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n \n     /**\n      * <p>Turn \"Now is the time for all good men\" into \"Now is the time for...\"</p>\n      *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + \"...\")</code>.</li>\n      *   <li>If <code>maxWidth</code> is less than </code>3, throw an\n      *       <code>IllegalArgumentException</code>.</li>\n-     *   <li>In no case will it return a string of length greater than\n+     *   <li>In no case will it return a String of length greater than\n      *       <code>maxWidth</code>.</li>\n      * </ul>\n      * </p>\n      *\n      * @param str  the String to check, may be null\n-     * @param maxWidth  maximum length of result string\n+     * @param maxWidth  maximum length of result String, must be at least 4\n+     * @return abbreviated String, <code>null</code> if null String input\n      * @throws IllegalArgumentException if the width is too small\n      */\n     public static String abbreviate(String str, int maxWidth) {\n      * be the leftmost character in the result, or the first character following the\n      * ellipses, but it will appear somewhere in the result.\n      *\n-     * <p>In no case will it return a string of length greater than\n+     * <p>In no case will it return a String of length greater than\n      * <code>maxWidth</code>.</p>\n      *\n      * @param str  the String to check, may be null\n-     * @param offset  left edge of source string\n-     * @param maxWidth  maximum length of result string\n+     * @param offset  left edge of source String\n+     * @param maxWidth  maximum length of result String, must be at least 4\n+     * @return abbreviated String, <code>null</code> if null String input\n      * @throws IllegalArgumentException if the width is too small\n      */\n     public static String abbreviate(String str, int offset, int maxWidth) {\n     }\n \n     // Difference\n-    //--------------------------------------------------------------------------\n-\n-    /**\n-     * <p>Compare two strings, and return the portion where they differ.\n-     * (More precisely, return the remainder of the second string,\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compare two Strings, and return the portion where they differ.\n+     * (More precisely, return the remainder of the second String,\n      * starting from where it's different from the first.)</p>\n      *\n      * <p>For example,\n      * <code>difference(\"i am a machine\", \"i am a robot\") -> \"robot\"</code>.</p>\n      *\n-     * @param str1  the first string, may be null\n-     * @param str2  the second string, may be null\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n      * @return the portion of str2 where it differs from str1; returns the \n-     * empty string if they are equal\n+     * empty String if they are equal\n      */\n     public static String difference(String str1, String str2) {\n         if (str1 == null) {\n     }\n \n     /**\n-     * <p>Compare two strings, and return the index at which the\n-     * strings begin to differ.</p>\n+     * <p>Compare two Strings, and return the index at which the\n+     * Strings begin to differ.</p>\n      * \n      * <p>For example, \n      * <code>differenceAt(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n      *\n-     * @param str1  the first string, may be null\n-     * @param str2  the second string, may be null\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n      * @return the index where str2 and str1 begin to differ; -1 if they are equal\n      */\n     public static int differenceAt(String str1, String str2) {\n \n \n     // Misc\n-    //--------------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n \n     /**\n      * <p>Find the Levenshtein distance between two Strings.</p>\n      * @param s  the first String, must not be null\n      * @param t  the second String, must not be null\n      * @return result distance\n-     * @throws IllegalArgumentException if s or t is <code>null</code>\n+     * @throws IllegalArgumentException if either String input <code>null</code>\n      */\n     public static int getLevenshteinDistance(String s, String t) {\n         if (s == null || t == null) {\n--- a/src/test/org/apache/commons/lang/StringUtilsSubstringTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsSubstringTest.java\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n- * @version $Id: StringUtilsSubstringTest.java,v 1.4 2003/07/16 23:45:39 scolebourne Exp $\n+ * @version $Id: StringUtilsSubstringTest.java,v 1.5 2003/07/18 02:06:23 scolebourne Exp $\n  */\n public class StringUtilsSubstringTest extends TestCase {\n     private static final String FOO = \"foo\";\n     }\n \n     public void testGetNestedString() {\n-        assertEquals( \"\", StringUtils.getNestedString(\"\", \"\") );\n-        assertEquals( \"\", StringUtils.getNestedString(\"    \", \" \") );\n-        assertEquals( \"bar\", StringUtils.getNestedString(\"\\nbar\\n\", \"\\n\") );\n-        assertEquals( \"\", StringUtils.getNestedString(\"\", \"\", \"\") );\n-        assertEquals( \"\", StringUtils.getNestedString(\"    \", \" \", \"  \") );\n-        assertEquals( \"bar\", StringUtils.getNestedString(\"<foo>bar</foo>\", \"<foo>\", \"</foo>\") );\n+        assertEquals(null, StringUtils.getNestedString(null, \"tag\"));\n+        assertEquals(null, StringUtils.getNestedString(\"abc\", null));\n+        assertEquals(\"\", StringUtils.getNestedString(\"abc\", \"\"));\n+        assertEquals(null, StringUtils.getNestedString(\"abc\", \"a\"));\n+        assertEquals(\"bc\", StringUtils.getNestedString(\"abca\", \"a\"));\n+        assertEquals(\"bc\", StringUtils.getNestedString(\"abcabca\", \"a\"));\n+        assertEquals(\"\", StringUtils.getNestedString(\"\", \"\"));\n+        assertEquals(\"\", StringUtils.getNestedString(\"    \", \" \"));\n+        assertEquals(\"bar\", StringUtils.getNestedString(\"\\nbar\\n\", \"\\n\"));\n+        \n+        assertEquals(\"\", StringUtils.getNestedString(\"\", \"\", \"\"));\n+        assertEquals(\"\", StringUtils.getNestedString(\"    \", \" \", \"  \"));\n+        assertEquals(\"bar\", StringUtils.getNestedString(\"<foo>bar</foo>\", \"<foo>\", \"</foo>\") );\n     }\n \n }\n--- a/src/test/org/apache/commons/lang/StringUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsTest.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n import junit.textui.TestRunner;\n+\n /**\n  * Unit tests {@link org.apache.commons.lang.StringUtils}.\n  *\n  * @author <a href=\"mailto:fredrik@westermarck.com>Fredrik Westermarck</a>\n  * @author Holger Krauth\n  * @author <a href=\"hps@intermeta.de\">Henning P. Schmiedehausen</a>\n- * @version $Id: StringUtilsTest.java,v 1.25 2003/07/16 23:56:44 scolebourne Exp $\n+ * @version $Id: StringUtilsTest.java,v 1.26 2003/07/18 02:06:23 scolebourne Exp $\n  */\n public class StringUtilsTest extends TestCase {\n \n     //-----------------------------------------------------------------------\n \n     public void testCaseFunctions() {\n+        assertEquals(null, StringUtils.upperCase(null));\n+        assertEquals(null, StringUtils.lowerCase(null));\n+        assertEquals(null, StringUtils.swapCase(null));\n+        assertEquals(null, StringUtils.capitalise(null));\n+        assertEquals(null, StringUtils.uncapitalise(null));\n+        assertEquals(null, StringUtils.capitaliseAllWords(null));\n+        assertEquals(null, StringUtils.uncapitaliseAllWords(null));\n+\n         assertEquals(\"capitalise(String) failed\",\n                      CAP_FOO, StringUtils.capitalise(FOO) );\n         assertEquals(\"capitalise(empty-string) failed\",\n     }\n \n     public void testSplit() {\n+        assertEquals(null, StringUtils.split(null));\n+        assertEquals(null, StringUtils.split(null, '.'));\n+        assertEquals(null, StringUtils.split(null, \".\"));\n+        assertEquals(null, StringUtils.split(null, \".\", 3));\n+        \n+        String[] res = StringUtils.split(\"a..b.c\", '.');\n+        assertEquals(4, res.length);\n+        assertEquals(\"a\", res[0]);\n+        assertEquals(\"\", res[1]);\n+        assertEquals(\"b\", res[2]);\n+        assertEquals(\"c\", res[3]);\n+\n         String[] result = StringUtils.split(TEXT_LIST, SEPARATOR, 2);\n         String[] expected = { \"foo\", \"bar,baz\" };\n         assertEquals(\"split(Object[], String, int) yielded unexpected length\",\n         } catch (IllegalArgumentException ex) {}\n     }\n \n-    public void testReverseFunctions() {\n+    public void testReverse() {\n+        assertEquals(null, StringUtils.reverse(null) );\n         assertEquals(\"sdrawkcab\", StringUtils.reverse(\"backwards\") );\n         assertEquals(\"\", StringUtils.reverse(\"\") );\n-        assertEquals(null, StringUtils.reverse(null) );\n+    }\n         \n+    public void testReverseDelimitedString() {\n+        assertEquals(null, StringUtils.reverseDelimitedString(null, '.') );\n+        assertEquals(\"c.b.a\", StringUtils.reverseDelimitedString(\"a.b.c\", '.') );\n+        assertEquals(\"a b c\", StringUtils.reverseDelimitedString(\"a b c\", '.') );\n+        assertEquals(\"\", StringUtils.reverseDelimitedString(\"\", '.') );\n+\n+        assertEquals(null, StringUtils.reverseDelimitedString(null, null) );\n+        assertEquals(\"a.b.c\", StringUtils.reverseDelimitedString(\"a.b.c\", null) );\n+        assertEquals(\"c b a\", StringUtils.reverseDelimitedString(\"a b c\", null) );\n         assertEquals(\"org.apache.test\",\n                        StringUtils.reverseDelimitedString(\"test.apache.org\", \".\") );\n         assertEquals(\"reverseDelimitedString(empty-string,'.') failed\",\n     }\n \n     public void testDefaultFunctions() {\n-        assertEquals(\"defaultString(empty-string) failed\",\n-                     \"\", StringUtils.defaultString(\"\") );\n-        assertEquals(\"defaultString(String) failed\",\n-                     FOO, StringUtils.defaultString(FOO) );\n-        assertEquals(\"defaultString(null) failed\",\n-                     \"\", StringUtils.defaultString(null) );\n-        assertEquals(\"defaultString(empty-string,String) failed\",\n-                     \"\", StringUtils.defaultString(\"\", BAR) );\n-        assertEquals(\"defaultString(String,String) failed\",\n-                     FOO, StringUtils.defaultString(FOO, BAR) );\n-        assertEquals(\"defaultString(null,String) failed\",\n-                     BAR, StringUtils.defaultString(null, BAR) );\n-\n-        assertEquals(\"defaultString((Object) empty-string) failed\",\n-                     \"\", StringUtils.defaultString((Object) \"\") );\n-        assertEquals(\"defaultString((Object) String) failed\",\n-                     FOO, StringUtils.defaultString((Object) FOO) );\n-        assertEquals(\"defaultString((Object) null) failed\",\n-                     \"\", StringUtils.defaultString((Object) null) );\n-        assertEquals(\"defaultString((Object) empty-string,String) failed\",\n-                     \"\", StringUtils.defaultString((Object) \"\", BAR) );\n-        assertEquals(\"defaultString((Object) String,String) failed\",\n-                     FOO, StringUtils.defaultString((Object) FOO, BAR) );\n-        assertEquals(\"defaultString((Object) null,String) failed\",\n-                     BAR, StringUtils.defaultString((Object) null, BAR) );\n-        assertEquals(\"defaultString(Boolean.TRUE,String) failed\",\n-                     Boolean.TRUE.toString(), StringUtils.defaultString(Boolean.TRUE, BAR) );\n+        assertEquals(\"\", StringUtils.defaultString(null) );\n+        assertEquals(\"\", StringUtils.defaultString(\"\") );\n+        assertEquals(FOO, StringUtils.defaultString(FOO) );\n+        \n+        assertEquals(BAR, StringUtils.defaultString(null, BAR) );\n+        assertEquals(\"\", StringUtils.defaultString(\"\", BAR) );\n+        assertEquals(FOO, StringUtils.defaultString(FOO, BAR) );\n+\n+        assertEquals(\"\", StringUtils.defaultString((Object) \"\") );\n+        assertEquals(FOO, StringUtils.defaultString((Object) FOO) );\n+        assertEquals(\"\", StringUtils.defaultString((Object) null) );\n+        \n+        assertEquals(\"\", StringUtils.defaultString((Object) \"\", BAR) );\n+        assertEquals(FOO, StringUtils.defaultString((Object) FOO, BAR) );\n+        assertEquals(BAR, StringUtils.defaultString((Object) null, BAR) );\n+        assertEquals(Boolean.TRUE.toString(), StringUtils.defaultString(Boolean.TRUE, BAR) );\n     }\n \n     public void testEscapeFunctions() {\n--- a/src/test/org/apache/commons/lang/StringUtilsTrimEmptyTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsTrimEmptyTest.java\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n- * @version $Id: StringUtilsTrimEmptyTest.java,v 1.9 2003/07/16 21:19:22 scolebourne Exp $\n+ * @version $Id: StringUtilsTrimEmptyTest.java,v 1.10 2003/07/18 02:06:23 scolebourne Exp $\n  */\n public class StringUtilsTrimEmptyTest extends TestCase {\n     private static final String FOO = \"foo\";\n         String fooRightSpace = FOO+\"    \";\n         String fooRightDots = FOO+\".........\";\n \n+        assertEquals(null, StringUtils.strip(null));\n         assertEquals(\"\", StringUtils.strip(\"\"));\n         assertEquals(\"\", StringUtils.strip(\"        \"));\n         assertEquals(FOO, StringUtils.strip(foo2Space));\n+        \n+        assertEquals(FOO, StringUtils.strip(foo2Space, null));\n         assertEquals(FOO, StringUtils.strip(foo2Dots, \".\"));\n         assertEquals(FOO, StringUtils.strip(fooRightSpace));\n         assertEquals(FOO, StringUtils.strip(fooRightDots, \".\"));\n         assertEquals(FOO, StringUtils.strip(fooLeftSpace));\n         assertEquals(FOO, StringUtils.strip(fooLeftDots, \".\"));\n \n+        assertEquals(null, StringUtils.stripStart(null, null));\n         assertEquals(\"\", StringUtils.stripStart(\"\", \" \"));\n+        assertEquals(fooRightSpace, StringUtils.stripStart(foo2Space, null));\n         assertEquals(fooRightSpace, StringUtils.stripStart(foo2Space, \" \"));\n         assertEquals(fooRightDots, StringUtils.stripStart(foo2Dots, \".\"));\n         assertEquals(fooRightSpace, StringUtils.stripStart(fooRightSpace, \" \"));\n         assertEquals(FOO, StringUtils.stripStart(fooLeftSpace, \" \"));\n         assertEquals(FOO, StringUtils.stripStart(fooLeftDots, \".\"));\n \n+        assertEquals(null, StringUtils.stripEnd(null, null));\n         assertEquals(\"\", StringUtils.stripEnd(\"\", \" \"));\n+        assertEquals(fooLeftSpace, StringUtils.stripEnd(foo2Space, null));\n         assertEquals(fooLeftSpace, StringUtils.stripEnd(foo2Space, \" \"));\n         assertEquals(fooLeftDots, StringUtils.stripEnd(foo2Dots, \".\"));\n         assertEquals(FOO, StringUtils.stripEnd(fooRightSpace, \" \"));\n         String[] fooDots = new String[] { foo2Dots, fooLeftDots, fooRightDots };\n         String[] foo = new String[] { FOO, FOO, FOO };\n \n+        assertEquals(null, StringUtils.stripAll(null));\n         assertArrayEquals(empty, StringUtils.stripAll(empty));\n         assertArrayEquals(foo, StringUtils.stripAll(fooSpace));\n+        \n+        assertEquals(null, StringUtils.stripAll(null, null));\n+        assertArrayEquals(foo, StringUtils.stripAll(fooSpace, null));\n         assertArrayEquals(foo, StringUtils.stripAll(fooDots, \".\"));\n     }\n ", "timestamp": 1058493984, "metainfo": ""}