{"sha": "e8600d357d98cbf727b573732052aba0fd7a1f69", "log": "Applying my modified version of Chris Hyzer's patch from LANG-180 - adding a replaceEach(String, String[], String[]) and replaceRepeatedly(String, String[], String[]) pair of methods. The internal code to the private replaceEach method has not been fully reviewed yet - I wanted to get more eyes focused on the algorithm  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n         return buf.toString();\n     }\n \n+    /**\n+     * <p>\n+     * Replaces all occurances of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. This will not repeat, for repeating replaces, call the\n+     * overloaded method.\n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *)        = null\n+     *  StringUtils.replaceEach(\"\", *, *)          = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0]) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null)  = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"})  = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"})  = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"})  = \"wcte\"\n+     *  (example of how it does not repeat)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"})  = \"dcte\"\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param repl\n+     *            the Strings to search for, no-op if null\n+     * @param with\n+     *            the Strings to replace with, no-op if null\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    public static String replaceEach(String text, String[] repl, String[] with) {\n+        return replaceEach(text, repl, with, false, 0);\n+    }\n+\n+    /**\n+     * <p>\n+     * Replaces all occurances of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. This will not repeat, for repeating replaces, call the\n+     * overloaded method.\n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *, *)        = null\n+     *  StringUtils.replaceEach(\"\", *, *, *)          = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  = \"wcte\"\n+     *  (example of how it repeats)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  = \"dcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  = \"tcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true)  = IllegalArgumentException\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false)  = \"dcabe\"\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param repl\n+     *            the Strings to search for, no-op if null\n+     * @param with\n+     *            the Strings to replace with, no-op if null\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IllegalArgumentException\n+     *             if the search is repeating and there is an endless loop due\n+     *             to outputs of one being inputs to another\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    public static String replaceEachRepeatedly(String text, String[] repl, String[] with) {\n+\n+        // timeToLive should be 0 if not used or nothing to replace, else it's\n+        // the length of the replace array\n+        int timeToLive = repl == null ? 0 : repl.length;\n+        return replaceEach(text, repl, with, true, timeToLive);\n+    }\n+\n+    /**\n+     * <p>\n+     * Replaces all occurances of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. \n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *, *)        = null\n+     *  StringUtils.replaceEach(\"\", *, *, *)          = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  = \"wcte\"\n+     *  (example of how it repeats)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  = \"dcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  = \"tcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  = IllegalArgumentException\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param repl\n+     *            the Strings to search for, no-op if null\n+     * @param with\n+     *            the Strings to replace with, no-op if null\n+     * @param timeToLive\n+     *            if less than 0 then there is a circular reference and endless\n+     *            loop\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IllegalArgumentException\n+     *             if the search is repeating and there is an endless loop due\n+     *             to outputs of one being inputs to another\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    private static String replaceEach(String text, String[] repl, String[] with,\n+            boolean repeat, int timeToLive) {\n+\n+        // mchyzer Performance note:  This creates very few new objects (one major goal)\n+        // let me know if there are performance requests, we can create a harness to measure\n+        \n+        if (text == null || text.length() == 0 || \n+            repl == null || repl.length == 0 || \n+            with == null || with.length == 0) \n+        {\n+            return text;\n+        }\n+\n+        // if recursing, this shouldnt be less than 0\n+        if (timeToLive < 0) {\n+            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n+        }\n+\n+        int replLength = repl.length;\n+        int withLength = with.length;\n+\n+        // make sure lengths are ok, these need to be equal\n+        if (replLength != withLength) {\n+            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + replLength + \" vs \" + withLength);\n+        }\n+\n+        // keep track of which still have matches\n+        boolean[] noMoreMatchesForReplIndex = new boolean[replLength];\n+\n+        // index on index that the match was found\n+        int textIndex = -1;\n+        int replaceIndex = -1;\n+        int tempIndex = -1;\n+\n+        // index of replace array that will replace the search string found\n+        // NOTE: logic duplicated below START\n+        for (int i = 0; i < replLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || repl[i] == null || repl[i].length() == 0 || with[i] == null) {\n+                continue;\n+            }\n+            tempIndex = text.indexOf(repl[i]);\n+            \n+            // see if we need to keep searching for this\n+            if (tempIndex == -1) {\n+                noMoreMatchesForReplIndex[i] = true;\n+            } else {\n+                if (textIndex == -1 || tempIndex < textIndex) {\n+                    textIndex = tempIndex;\n+                    replaceIndex = i;\n+                }\n+            }\n+        }\n+        // NOTE: logic mostly below END\n+\n+        // no search strings found, we are done\n+        if (textIndex == -1) {\n+            return text;\n+        }\n+\n+        int start = 0;\n+\n+        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n+        int increase = 0;\n+\n+        // count the replacement text elements that are larger than their corresponding text being replaced\n+        for (int i=0; i<repl.length; i++) {\n+            int greater = with[i].length() - repl[i].length();\n+            if(greater > 0) {\n+                increase += 3 * greater; // assume 3 matches\n+            }\n+        }\n+        // have upper-bound at 20% increase, then let Java take over\n+        increase = Math.min(increase, text.length() / 5); \n+    \n+        StringBuffer buf = new StringBuffer(text.length() + increase);\n+\n+        while (textIndex != -1) {\n+\n+            for (int i = start; i < textIndex; i++) {\n+                buf.append(text.charAt(i));\n+            }\n+            buf.append(with[replaceIndex]);\n+\n+            start = textIndex + repl[replaceIndex].length();\n+\n+            textIndex = -1;\n+            replaceIndex = -1;\n+            tempIndex = -1;\n+            // find the next earliest match\n+            // NOTE: logic mostly duplicated above START\n+            for (int i = 0; i < replLength; i++) {\n+                if (noMoreMatchesForReplIndex[i] || repl[i] == null || repl[i].length() == 0 || with[i] == null) {\n+                    continue;\n+                }\n+                tempIndex = text.indexOf(repl[i], start);\n+                \n+                //see if we need to keep searching for this\n+                if (tempIndex == -1) {\n+                    noMoreMatchesForReplIndex[i] = true;\n+                } else {\n+                    if (textIndex == -1 || tempIndex < textIndex) {\n+                        textIndex = tempIndex;\n+                        replaceIndex = i;\n+                    }\n+                }\n+            }\n+            // NOTE: logic duplicated above END\n+\n+        }\n+        int textLength = text.length();\n+        for (int i = start; i < textLength; i++) {\n+            buf.append(text.charAt(i));\n+        }\n+        String result = buf.toString();\n+        if (!repeat) {\n+            return result;\n+        }\n+\n+        return replaceEach(result, repl, with, repeat, timeToLive - 1);\n+    }\n+\n     // Replace, character based\n     //-----------------------------------------------------------------------\n     /**\n--- a/src/test/org/apache/commons/lang/StringUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsTest.java\n         assertEquals(\"foofoo\", StringUtils.replaceOnce(\"foofoofoo\", \"foo\", \"\"));\n     }\n \n+    /**\n+     * Test method for 'org.apache.commons.lang.StringUtils.replaceEach(String, String[], String[])'\n+     */\n+    public void testReplace_StringStringArrayStringArray() {\n+\n+        \n+        //JAVADOC TESTS START\n+        assertNull(StringUtils.replaceEach(null, new String[]{\"a\"}, new String[]{\"b\"}));\n+        assertEquals(StringUtils.replaceEach(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", null, null),\"aba\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", new String[0], null),\"aba\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", null, new String[0]),\"aba\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null),\"aba\");\n+\n+        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n+        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n+        assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n+        assertEquals(StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"dcte\");\n+        //JAVADOC TESTS END\n+\n+        assertEquals(\"bcc\", StringUtils.replaceEach(\"abc\", new String[]{\"a\", \"b\"}, new String[]{\"b\", \"c\"}));\n+        assertEquals(\"q651.506bera\", StringUtils.replaceEach(\"d216.102oren\",\n+            new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \n+                \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \n+                \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \n+                \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"},\n+            new String[]{\"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \n+                \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"N\", \"O\", \"P\", \"Q\", \n+                \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \n+                \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"5\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\", \"3\", \"4\"}));\n+    }\n+\n+    /**\n+     * Test method for 'org.apache.commons.lang.StringUtils.replaceEachRepeatedly(String, String[], String[])'\n+     */\n+    public void testReplace_StringStringArrayStringArrayBoolean() {\n+        //JAVADOC TESTS START\n+        assertNull(StringUtils.replaceEachRepeatedly(null, new String[]{\"a\"}, new String[]{\"b\"}));\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"\", new String[]{\"a\"}, new String[]{\"b\"}),\"\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", null, null),\"aba\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null),\"aba\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", null, new String[0]),\"aba\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[0], null),\"aba\");\n+\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[]{\"a\"}, new String[]{\"\"}),\"b\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"aba\", new String[]{null}, new String[]{\"a\"}),\"aba\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}),\"wcte\");\n+        assertEquals(StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}),\"tcte\");\n+\n+        try {\n+            StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"});\n+            fail(\"Should be a circular reference\");\n+        } catch (IllegalArgumentException e) {}\n+\n+        //JAVADOC TESTS END\n+\n+    }\n+    \n     public void testReplaceChars_StringCharChar() {\n         assertEquals(null, StringUtils.replaceChars(null, 'b', 'z'));\n         assertEquals(\"\", StringUtils.replaceChars(\"\", 'b', 'z'));", "timestamp": 1201584797, "metainfo": ""}