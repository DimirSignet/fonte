{"sha": "ed402f898868567a82f047390b4bda68b5d4a5a3", "log": "Applying my patch from LANG-257, adding Cameron Whitehead's desired splitByWholeSeparatorPreserveAllTokens methods. In addition to the patch, I've added @since 2.4 tags to the javadoc  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n      * @return an array of parsed Strings, <code>null</code> if null String was input\n      */\n     public static String[] splitByWholeSeparator(String str, String separator) {\n-        return splitByWholeSeparator( str, separator, -1 ) ;\n+        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n     }\n \n     /**\n      * @return an array of parsed Strings, <code>null</code> if null String was input\n      */\n     public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n+        return splitByWholeSeparatorWorker(str, separator, max, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified. </p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *)                 = []\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     * @since 2.4\n+     */\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n+        return splitByWholeSeparatorWorker( str, separator, -1, true ) ;\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.\n+     * Returns a maximum of <code>max</code> substrings.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *, *)                 = []\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null, 0)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     * @since 2.4\n+     */\n+    public static String[] splitByWholeSeparatorPreserveAllTokens( String str, String separator, int max ) {\n+        return splitByWholeSeparatorWorker(str, separator, max, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>splitByWholeSeparatorPreserveAllTokens</code> methods.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    private static String[] splitByWholeSeparatorWorker( String str, String separator, \n+                                                         int max, boolean preserveAllTokens ) \n+    {\n         if (str == null) {\n             return null;\n         }\n \n         if ( ( separator == null ) || ( \"\".equals( separator ) ) ) {\n             // Split on whitespace.\n-            return split( str, null, max ) ;\n+            return splitWorker( str, null, max, preserveAllTokens ) ;\n         }\n \n \n                     }\n                 } else {\n                     // We found a consecutive occurrence of the separator, so skip it.\n+                    if( preserveAllTokens ) {\n+                        numberOfSubstrings += 1 ;\n+                        if ( numberOfSubstrings == max ) {\n+                            end = len ;\n+                            substrings.add( str.substring( beg ) ) ;\n+                        } else {\n+                            substrings.add( \"\" );\n+                        }\n+                    }\n                     beg = end + separatorLength ;\n                 }\n             } else {\n--- a/src/test/org/apache/commons/lang/StringUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsTest.java\n         }\n     }\n \n+    public void testSplitByWholeSeparatorPreserveAllTokens_StringStringInt() {\n+        assertEquals( null, StringUtils.splitByWholeSeparatorPreserveAllTokens( null, \".\", -1 ) ) ;\n+\n+        assertEquals( 0, StringUtils.splitByWholeSeparatorPreserveAllTokens( \"\", \".\", -1 ).length ) ;\n+\n+        // test whitespace\n+        String input = \"ab   de fg\" ;\n+        String[] expected = new String[] { \"ab\", \"\", \"\", \"de\", \"fg\" } ;\n+\n+        String[] actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, null, -1 ) ;\n+        assertEquals( expected.length, actual.length ) ;\n+        for ( int i = 0 ; i < actual.length ; i+= 1 ) {\n+            assertEquals( expected[i], actual[i] );\n+        }\n+\n+        // test delimiter singlechar\n+        input = \"1::2:::3::::4\";\n+        expected = new String[] { \"1\", \"\", \"2\", \"\", \"\", \"3\", \"\", \"\", \"\", \"4\" };\n+\n+        actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, \":\", -1 ) ;\n+        assertEquals( expected.length, actual.length ) ;\n+        for ( int i = 0 ; i < actual.length ; i+= 1 ) {\n+            assertEquals( expected[i], actual[i] );\n+        }\n+\n+        // test delimiter multichar\n+        input = \"1::2:::3::::4\";\n+        expected = new String[] { \"1\", \"2\", \":3\", \"\", \"4\" };\n+\n+        actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, \"::\", -1 ) ;\n+        assertEquals( expected.length, actual.length ) ;\n+        for ( int i = 0 ; i < actual.length ; i+= 1 ) {\n+            assertEquals( expected[i], actual[i] );\n+        }\n+\n+        // test delimiter char with max\n+        input = \"1::2::3:4\";\n+        expected = new String[] { \"1\", \"\", \"2\", \":3:4\" };\n+\n+        actual = StringUtils.splitByWholeSeparatorPreserveAllTokens( input, \":\", 4 ) ;\n+        assertEquals( expected.length, actual.length ) ;\n+        for ( int i = 0 ; i < actual.length ; i+= 1 ) {\n+            assertEquals( expected[i], actual[i] );\n+        }\n+    }\n     \n     public void testSplitPreserveAllTokens_String() {\n         assertEquals(null, StringUtils.splitPreserveAllTokens(null));", "timestamp": 1200465810, "metainfo": ""}