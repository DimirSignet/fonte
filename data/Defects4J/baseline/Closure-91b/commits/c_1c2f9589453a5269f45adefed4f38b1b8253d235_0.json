{"sha": "1c2f9589453a5269f45adefed4f38b1b8253d235", "log": "Group Variable Declarations in Scope. Merges all variable declarations in a scope into the first var statement in that scope.  When doing the merge, only merges var statements with <= 1 var initialization (any number of declarations is acceptable). The assignment is not merged. Only the declaration is merged. (Vishal) R=robert,alan DELTA=422  (421 added, 1 deleted, 0 changed)   Remove out-of-data/bogus comment. (John) R=antonio DELTA=1  (0 added, 1 deleted, 0 changed)   Clean up some eclipse warnings. (John) R=robert DELTA=47  (10 added, 34 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Collapses multiple variable declarations into one */\n   public boolean collapseVariableDeclarations;\n+\n+  /** Group multiple variable declarations into one */\n+  public boolean groupVariableDeclarations;\n \n   /**\n    * Collapses anonymous function declarations into named function\n     removeUnusedVarsInGlobalScope = true;\n     aliasExternals = false;\n     collapseVariableDeclarations = false;\n+    groupVariableDeclarations = false;\n     collapseAnonymousFunctions = false;\n     aliasableStrings = Collections.emptySet();\n     aliasStringsBlacklist = \"\";\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(invertContextualRenaming);\n     }\n \n-\n     if (options.variableRenaming != VariableRenamingPolicy.OFF) {\n       passes.add(renameVars);\n+    }\n+\n+    if (options.groupVariableDeclarations) {\n+      passes.add(groupVariableDeclarations);\n     }\n \n     // This pass should run after names stop changing.\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       compiler.setUnnormalized();\n       return new CollapseVariableDeclarations(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Simple global collapses of variable declarations.\n+   */\n+  private final PassFactory groupVariableDeclarations =\n+      new PassFactory(\"groupVariableDeclarations\", true) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      compiler.setNormalized();\n+      return new GroupVariableDeclarations(compiler);\n     }\n   };\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * Groups multiple variable declarations (that may or may not be contiguous)\n+ * in the same scope into a single one. i.e.\n+ *\n+ * <pre>\n+ * var a, b = 10;\n+ * f1();\n+ * var c, d;\n+ * ... some other code ...\n+ * var x, y, z = 100;\n+ * ... some other code ...\n+ * var p = 200, q = 300;\n+ * </pre>\n+ *\n+ * becomes:\n+ *\n+ * <pre>\n+ * var a, b = 10, c, d, x, y, z;\n+ * f1();\n+ * ... some other code ...\n+ * z = 100;\n+ * ... some other code ...\n+ * var p = 200, q = 300;\n+ * </pre>\n+ *\n+ * This reduces the generated uncompressed code size.\n+ *\n+ * For any scope, we use the first VAR statement as the statement to collapse\n+ * the other declarations into. For other VAR statements in the scope, we only\n+ * consider ones that either (a) have no variable that is initialized in the\n+ * the statement, or (b) have exactly one variable that is initialized (e.g.\n+ * the \"var x, y, z = 100;\" statement in the example above. VAR statements\n+ * with more than one variable initialization are not collapsed. This is\n+ * because doing so would increase uncompressed code size.\n+ *\n+*\n+ */\n+class GroupVariableDeclarations implements CompilerPass, ScopedCallback {\n+  private final AbstractCompiler compiler;\n+\n+  GroupVariableDeclarations(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  public void enterScope(NodeTraversal t) {\n+    Set<Node> varNodes = Sets.newLinkedHashSet();\n+    Iterator<Var> scopeVarIter = t.getScope().getVars();\n+    while (scopeVarIter.hasNext()) {\n+      Node parentNode = scopeVarIter.next().getParentNode();\n+      if (parentNode.getType() == Token.VAR) {\n+        varNodes.add(parentNode);\n+      }\n+    }\n+    if (varNodes.size() <= 1) {\n+      return;\n+    }\n+    Iterator<Node> varNodeIter = varNodes.iterator();\n+    Node firstVarNode = varNodeIter.next();\n+    while (varNodeIter.hasNext()) {\n+      Node varNode = varNodeIter.next();\n+      applyGroupingToVar(firstVarNode, varNode);\n+    }\n+  }\n+\n+  public void exitScope(NodeTraversal t) {\n+  }\n+\n+  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n+                                Node parent) {\n+    return true;\n+  }\n+\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+  }\n+\n+  /**\n+   * Attempts to collapse groupVar. This can only happen if groupVar has at most\n+   * one variable initialization (it may have multiple variable declarations).\n+   * If successful, then detaches groupVar's children and appends them to\n+   * firstVar\n+   *\n+   * @param firstVar The first VAR {@code Node} in that scope. This is the node\n+   *                 that we want to collapse groupVar into\n+   * @param groupVar The VAR {@code Node} that we want to try collapsing\n+   *                 into the first VAR node of that scope\n+   */\n+  private void applyGroupingToVar(Node firstVar, Node groupVar) {\n+    Node child = groupVar.getFirstChild();\n+    // if some variable is initialized, then the corresponding NAME node will be\n+    // stored here\n+    Node initializedName = null;\n+    while (child != null) {\n+      if (child.hasChildren()) {\n+        // check that no more than one var is initialized\n+        if (initializedName != null) {\n+          return;\n+        }\n+        initializedName = child;\n+      }\n+      child = child.getNext();\n+    }\n+\n+    // we will be modifying the groupVar subtree so get its parent\n+    Node groupVarParent = groupVar.getParent();\n+\n+    if (initializedName != null) {\n+      // we have an initialized var in the VAR node. We will replace the\n+      // VAR node with an assignment.\n+\n+      // first create a detached childless clone of initializedName.\n+      Node clone = initializedName.cloneNode();\n+      // replace\n+      groupVar.replaceChild(initializedName, clone);\n+      // add the assignment now.\n+      Node initializedVal = initializedName.getFirstChild();\n+      initializedName.removeChild(initializedVal);\n+      Node assignmentNode = new Node(Token.ASSIGN, initializedName);\n+      assignmentNode.addChildAfter(initializedVal, initializedName);\n+      if (groupVarParent.getType() == Token.FOR) {\n+        // Handle For and For-In Loops specially. For these, we do not need\n+        // to construct an EXPR_RESULT node.\n+        groupVarParent.replaceChild(groupVar, assignmentNode);\n+      } else {\n+        Node exprNode = NodeUtil.newExpr(assignmentNode);\n+        groupVarParent.replaceChild(groupVar, exprNode);\n+      }\n+    } else {\n+      // There is no initialized var. But we need to handle FOR and\n+      // FOR-IN loops specially\n+      if (groupVarParent.getType() == Token.FOR) {\n+        if (NodeUtil.isForIn(groupVarParent)) {\n+          // In For-In loop, we replace the VAR node with a NAME node\n+          Node nameNodeClone = groupVar.getFirstChild().cloneNode();\n+          groupVarParent.replaceChild(groupVar, nameNodeClone);\n+        } else {\n+          // In For loop, we replace the VAR node with an EMPTY node\n+          Node emptyNode = new Node(Token.EMPTY);\n+          groupVarParent.replaceChild(groupVar, emptyNode);\n+        }\n+      } else {\n+        // we can safely remove the VAR node\n+        groupVarParent.removeChild(groupVar);\n+      }\n+    }\n+\n+    Node children = groupVar.removeChildren();\n+    firstVar.addChildrenToBack(children);\n+\n+    compiler.reportCodeChange();\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n \n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.Iterator;\n import java.util.List;\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n     Logger.getLogger(RemoveUnusedVars.class.getName());\n \n   private final AbstractCompiler compiler_;\n-\n-  /** Maximum number of iterations we'll allow (for safety) */\n-  private static final int MAX_ITERATIONS = 20;\n \n   /** Keeps track of the number of variables removed per instance. */\n   private int numRemoved_ = 0;\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n \n     public void addChildrenToBack(Node children) {\n         for (Node child = children; child != null; child = child.next) {\n-          // Hmmm... IRFactory doesn't remove before calling this.\n           Preconditions.checkArgument(child.parent == null);\n           child.parent = this;\n         }\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n     }\n   }\n \n-  private Compiler compile(String original) {\n-    return compile( new String[] { original });\n-  }\n-\n   private Compiler compile(String[] original) {\n     String[] argStrings = args.toArray(new String[] {});\n     CommandLineRunner runner = null;\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/GroupVariableDeclarationsTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+public class GroupVariableDeclarationsTest extends CompilerTestCase {\n+\n+  public void testGroupingUninitializedVarsInScope() {\n+    // basic with just one fn call in between\n+    test(\"var a = 1; f1(); var b;\", \"var a = 1, b; f1();\");\n+    // > 1 line of code in between\n+    test(\"var a = \\\"mangoes\\\"; f1(); alert(a); var b;\",\n+         \"var a = \\\"mangoes\\\", b; f1(); alert(a);\");\n+    // nested block in between that also contains a declaration + initialization\n+    // of the variable that needs to be collapsed\n+    test(\"var a = 1; {var c; alert(c);} var b;\",\n+         \"var a = 1, c, b; {alert(c);}\");\n+    // multiple variables\n+    test(\"var a = 1; var b = 1; f1(); f2(); var c; var d;\",\n+         \"var a = 1, b, c, d; b = 1; f1(); f2();\");\n+    test(\"var a = 1; var b = 2; var c; f1(); f2(); var d, e;\",\n+         \"var a = 1, b, c, d, e; b = 2; f1(); f2();\");\n+    test(\"var a = 1, b = 2, c; f1(); f2(); var d; var e; \" +\n+         \"f3(); f4(); var f = 10; var g; var h = a + b;\",\n+         \"var a = 1, b = 2, c, d, e, f, g, h; f1(); f2(); f3(); f4(); \" +\n+         \"f = 10; h = a + b;\");\n+  }\n+\n+  public void testGroupingInitializedVarsInScope() {\n+    // basic with just one fn call in between\n+    test(\"var a = 1; f1(); var b = 2;\", \"var a = 1, b; f1(); b = 2;\");\n+    // > 1 line of code in between\n+    test(\"var a = \\\"mangoes\\\"; f1(); alert(a); var b = 2;\",\n+         \"var a = \\\"mangoes\\\", b; f1(); alert(a); b = 2;\");\n+    // nested block in between that also contains a declaration + initialization\n+    // of the variable that needs to be collapsed\n+    test(\"var a = 1; {var c = 34; alert(c);} var b = 2;\",\n+         \"var a = 1, c, b; {c = 34; alert(c);} b = 2;\");\n+    // multiple variables\n+    test(\"var a = 1; var b = 1; f1(); f2(); var c = 3; var d = 4;\",\n+         \"var a = 1, b, c, d; b = 1; f1(); f2(); c = 3; d = 4;\");\n+    test(\"var a = 1; var b = 2; var c; f1(); f2(); var d = 4, e;\",\n+         \"var a = 1, b, c, d, e; b = 2; f1(); f2(); d = 4;\");\n+    test(\"var a = 1, b = 2, c; f1(); f2(); var d; var e = 6; \" +\n+         \"f3(); f4(); var f; var g; var h = a + b;\",\n+         \"var a = 1, b = 2, c, d, e, f, g, h; f1(); f2(); e = 6; \" +\n+         \"f3(); f4(); h = a + b;\");\n+  }\n+\n+  public void testGroupingVarsInForAndForInLoops() {\n+    // test for loop\n+    test(\"var a = 1; for (var x = 0; x < 10; ++x) {a++;} var y;\",\n+         \"var a = 1, x, y; for (x = 0; x < 10; ++x) {a++;}\");\n+    test(\"var a = 1, x; for (x = 0; x < 10; ++x) {a++;} var y;\",\n+         \"var a = 1, x, y; for (x = 0; x < 10; ++x) {a++;}\");\n+    test(\"var a = 1, x; for (x; x < 10; ++x) {a++;} var y;\",\n+         \"var a = 1, x, y; for (x; x < 10; ++x) {a++;}\");\n+    test(\"var a = 1; for (; a < 10; ++a) {alert(a);} var y;\",\n+         \"var a = 1, y; for (; a < 10; ++a) {alert(a);}\");\n+    test(\"var a = 1; for (var x; x < 10; ++x) {a += 2;} var y = 5;\",\n+         \"var a = 1, x, y; for (; x < 10; ++x) {a += 2;} y = 5;\");\n+    // multiple loop-control variables in for loop\n+    test(\"var a = 1; \" +\n+         \"for (var a1 = 0, a2 = 10; a1 < 10 && a2 > 0; ++a1, --a2) {}\" +\n+         \"var x = 5;\",\n+         \"var a = 1, x;\" +\n+         \"for (var a1 = 0, a2 = 10; a1 < 10 && a2 > 0; ++a1, --a2) {} \" +\n+         \"x = 5;\");\n+    test(\"var a = 1; \" +\n+         \"for (var a1 = 0, a2; a1 < 10 && a2 > 0; ++a1, --a2) {}\" +\n+         \"var x = 5;\",\n+         \"var a = 1, a1, a2, x;\" +\n+         \"for (a1 = 0; a1 < 10 && a2 > 0; ++a1, --a2) {}\" +\n+         \"x = 5;\");\n+    test(\"var a = 1; \" +\n+         \"for (var a1, a2; a1 < 10 && a2 > 0; ++a1, --a2) {}\" +\n+         \"var x = 5;\",\n+         \"var a = 1, a1, a2, x;\" +\n+         \"for (; a1 < 10 && a2 > 0; ++a1, --a2) {}\" +\n+         \"x = 5;\");\n+\n+    // test for-in loop\n+    test(\"var a = [1, 2, 3, 4]; for (var z in a) {alert(z);} var y;\",\n+         \"var a = [1, 2, 3, 4], z, y; for (z in a) {alert(z);}\");\n+    test(\"var a = [1, 2, 3, 4]; for (var z in a) {alert(z);} var y = 5;\",\n+         \"var a = [1, 2, 3, 4], z, y; for (z in a) {alert(z);} y = 5;\");\n+    test(\"var a; for (var z in a = [1, 2, 3, 4]) {alert(z);} var y, x = 5;\",\n+         \"var a, z, y, x; for (z in a = [1, 2, 3, 4]) {alert(z);} x = 5;\");\n+    test(\"var a; for (var z = 1 in a = [1, 2, 3, 4]) {alert(z);} var y, x = 5;\",\n+         \"var a, z, y, x; for (z = 1 in a = [1, 2, 3, 4]) {alert(z);} x = 5;\");\n+    test(\"var a, z; for (z in a = [1, 2, 3, 4]) {alert(z);} var y, x = 5;\",\n+         \"var a, z, y, x; for (z in a = [1, 2, 3, 4]) {alert(z);} x = 5;\");\n+  }\n+\n+  public void testGroupingVarsNestedFunction() {\n+    test(\"function f(b) {var x; function g() {var x; a = x; var y;} var a;}\",\n+         \"function f(b) {var x, a; function g() {var x, y; a = x;}}\");\n+  }\n+\n+  public void testGroupingVarsInnerFunction() {\n+    test(\"function f(b) {var x; h = x * x; var myfn = function() \" +\n+         \"{var x; a = x; var y;}; var a;}\",\n+         \"function f(b) {var x, myfn, a; h = x * x; myfn = function() \" +\n+         \"{var x, y; a = x;};}\");\n+  }\n+\n+  public void testGroupingVarsFirstStatementNotVar() {\n+    test(\"f(); var a; g(); var b;\", \"f(); var a, b; g();\");\n+  }\n+\n+  public void testGroupingVarsInScopeRegtest() {\n+    // regtest with lots of different scopes\n+    test(\"var x = 0, y = 1, z;\" +\n+         \"function f1(aa, bb) {\" +\n+         \"  if (y) {\" +\n+         \"    if (x === 0) {\" +\n+         \"      var h, r = 999;\" +\n+         \"    }\" +\n+         \"  } else {\" +\n+         \"    r = 1000;\" +\n+         \"  }\" +\n+         \"  var mylist = [1, 2, 3, 4];\" +\n+         \"  var k1 = 200, k2 = 400;\" +\n+         \"  for (var i1 = 0; i1 < 10; ++i1) {\" +\n+         \"    for (var i2 in mylist) {\" +\n+         \"      alert(i1);\" +\n+         \"    }\" +\n+         \"  }\" +\n+         \"  var jam, q = 100;\" +\n+         \"  var myfn = function() {\" +\n+         \"    var x = 1;\" +\n+         \"    f5();\" +\n+         \"    var z = 5;\" +\n+         \"  };\" +\n+         \"  function f5() {\" +\n+         \"    var aa = 5;\" +\n+         \"    if (y === 1) {\" +\n+         \"      var x = 100;\" +\n+         \"    }\" +\n+         \"  }\" +\n+         \"}\" +\n+         \"var h = x + y;\" +\n+         \"function g() {\" +\n+         \"  y = 0;\" +\n+         \"  { var x = 200;}\" +\n+         \"  var h = y + x;\" +\n+         \"}\" +\n+         \"var ggg = 0;\",  // End of input\n+         \"var x = 0, y = 1, z, h, ggg;\" +\n+         \"function f1(aa, bb) {\" +\n+         \"  if (y) {\" +\n+         \"    if (x === 0) {\" +\n+         \"      var h, r = 999, mylist, i1, i2, jam, q, myfn;\" +\n+         \"    }\" +\n+         \"  } else {\" +\n+         \"    r = 1000;\" +\n+         \"  }\" +\n+         \"  mylist = [1, 2, 3, 4];\" +\n+         \"  var k1 = 200, k2 = 400;\" +\n+         \"  for (i1 = 0; i1 < 10; ++i1) {\" +\n+         \"    for (i2 in mylist) {\" +\n+         \"      alert(i1);\" +\n+         \"    }\" +\n+         \"  }\" +\n+         \"  q = 100; \" +\n+         \"  myfn = function() {\" +\n+         \"    var x = 1, z;\" +\n+         \"    f5();\" +\n+         \"    z = 5;\" +\n+         \"  };\" +\n+         \"  function f5() {\" +\n+         \"    var aa = 5, x;\" +\n+         \"    if (y === 1) {\" +\n+         \"      x = 100;\" +\n+         \"    }\" +\n+         \"  }\" +\n+         \"}\" +\n+         \"h = x + y;\" +\n+         \"function g() {\" +\n+         \"  y = 0;\" +\n+         \"  { var x = 200, h;}\" +\n+         \"  h = y + x;\" +\n+         \"}\" +\n+         \"ggg = 0;\");\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new GroupVariableDeclarations(compiler);\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n+++ b/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n \n   private JSTypeRegistry registry;\n   private Scope globalScope;\n-  private Scope lastLocalScope;\n \n   @Override\n   public int getNumRepetitions() {\n       Scope s = t.getScope();\n       if (s.isGlobal()) {\n         globalScope = s;\n-      } else {\n-        lastLocalScope = s;\n       }\n     }\n   };\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n \n /**\n  * Inline function tests.\n--- a/test/com/google/javascript/jscomp/VariableMapTest.java\n+++ b/test/com/google/javascript/jscomp/VariableMapTest.java\n \n import com.google.common.base.Charsets;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.Maps;\n \n-import junit.framework.*;\n+import junit.framework.TestCase;\n \n-import java.text.*;\n-import java.util.*;\n+import java.text.ParseException;\n+import java.util.Arrays;\n+import java.util.List;\n \n /**\n  * Tests for {@link VariableMap}.", "timestamp": 1269986463, "metainfo": ""}