{"sha": "541402929a600a95bf099513908b4efd8b0e1c5b", "log": "Change on 2010/06/28 16:56:22 by dhans          Array(arg0, arg1, ...) folds into [arg0, arg1, ...] if         possible.          R=johnlenz         DELTA=126  (101 added, 0 deleted, 25 changed)  Change on 2010/06/28 17:36:40 by johnlenz          Modify the AST construction so that \"-2\" is a single Node instead of a         \"NEG\" and a \"NUMBER\" node. Simplifies unit testing in some cases.         Update and enable a couple of disable tests while I'm here.          R=bowdidge         DELTA=82  (63 added, 3 deleted, 16 changed)  Change on 2010/06/29 00:59:44 by lukaszo          Adding adoptNode to the Document prototype.          R=acleung         DELTA=7  (7 added, 0 deleted, 0 changed)  Change on 2010/06/29 08:30:43 by dcc          Remove the (now empty) FoldConstants pass and all references to it.          R=acleung         DELTA=64  (0 added, 64 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=46001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     if (options.foldConstants) {\n       // These used to be one pass.\n       passes.add(minimizeExitPoints);\n-      passes.add(foldConstants);\n       passes.add(peepholeOptimizations);\n     }\n \n       return new CreateSyntheticBlocks(compiler,\n           options.syntheticBlockStartMarker,\n           options.syntheticBlockEndMarker);\n-    }\n-  };\n-\n-  /** Local constant folding */\n-  static final PassFactory foldConstants =\n-      new PassFactory(\"foldConstants\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new FoldConstants(compiler);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n     Node constructorNameNode = n.getFirstChild();\n     \n     Node newLiteralNode = null;\n-    \n+\n     // We require the AST to be normalized to ensure that, say,\n     // Object() really refers to the built-in Object constructor\n     // and not a user-defined constructor with the same name.\n         // \"RegExp(\"boo\", \"g\")\" --> /boo/g\n         return tryFoldRegularExpressionConstructor(n);\n       } else {\n-        boolean constructorHasArguments = constructorNameNode.getNext() != null;\n-\n-        if (!constructorHasArguments) {\n-          if (\"Array\".equals(className)) {\n-            // \"Array()\" --> \"[]\"\n+        boolean constructorHasArgs = constructorNameNode.getNext() != null;\n+\n+        if (\"Object\".equals(className) && !constructorHasArgs) {\n+          // \"Object()\" --> \"{}\"\n+          newLiteralNode = new Node(Token.OBJECTLIT);\n+        } else if (\"Array\".equals(className)) {\n+          // \"Array(arg0, arg1, ...)\" --> \"[arg0, arg1, ...]\"\n+          Node arg0 = constructorNameNode.getNext();\n+          FoldArrayAction action = isSafeToFoldArrayConstructor(arg0);\n+\n+          if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS ||\n+              action == FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n             newLiteralNode = new Node(Token.ARRAYLIT);\n-          } else if (\"Object\".equals(className)) {\n-            // \"Object()\" --> \"{}\"\n-            newLiteralNode = new Node(Token.OBJECTLIT);\n+            n.removeChildren();\n+            if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n+              newLiteralNode.addChildrenToFront(arg0);\n+            }\n           }\n         }\n+\n         if (newLiteralNode != null) {\n           n.getParent().replaceChild(n, newLiteralNode);\n           reportCodeChange();\n     }\n     return n;\n   } \n+\n+  private static enum FoldArrayAction {\n+    NOT_SAFE_TO_FOLD, SAFE_TO_FOLD_WITH_ARGS, SAFE_TO_FOLD_WITHOUT_ARGS}\n+\n+  /**\n+   * Checks if it is safe to fold Array() constructor into []. It can be\n+   * obviously done, if the initial constructor has either no arguments or\n+   * at least two. The remaining case may be unsafe since Array(number)\n+   * actually reserves memory for an empty array which contains number elements. \n+   */\n+  private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n+    FoldArrayAction action = FoldArrayAction.NOT_SAFE_TO_FOLD;\n+\n+    if (arg == null) {\n+      action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n+    } else if (arg.getNext() != null) {\n+      action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n+    } else {\n+      switch (arg.getType()) {\n+        case (Token.STRING):\n+          // \"Array('a')\" --> \"['a']\"\n+          action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n+          break;\n+        case (Token.NUMBER):\n+          // \"Array(0)\" --> \"[]\"\n+          if (arg.getDouble() == 0) {\n+            action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n+          }\n+          break;\n+        case (Token.ARRAYLIT):\n+          // \"Array([args])\" --> \"[[args]]\"\n+          action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n+          break;\n+        default:\n+      }\n+    }\n+    return action;\n+  }\n \n   private Node tryFoldRegularExpressionConstructor(Node n) { \n     Node parent = n.getParent();\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n     @Override\n     Node processUnaryExpression(UnaryExpression exprNode) {\n-      Node node = new Node(transformTokenType(exprNode.getType()),\n-                           transform(exprNode.getOperand()));\n-      if (exprNode.isPostfix()) {\n-        node.putBooleanProp(Node.INCRDECR_PROP, true);\n-      }\n-      return node;\n+      int type = transformTokenType(exprNode.getType());\n+      Node operand = transform(exprNode.getOperand());\n+      if (type == Token.NEG && operand.getType() == Token.NUMBER) {\n+        operand.setDouble(-operand.getDouble());\n+        return operand;\n+      } else {\n+        Node node = new Node(type, operand);\n+        if (exprNode.isPostfix()) {\n+          node.putBooleanProp(Node.INCRDECR_PROP, true);\n+        }\n+        return node;\n+      }\n     }\n \n     @Override\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n             CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true));\n   }\n \n-  /**\n-   * This test case is more involved since we need to run a constant folding\n-   * pass to get the -4 converted to a negative number, as opposed to a\n-   * number node with a number 4 attached to the negation unary operator.\n-   */\n   public void testSubtraction() {\n     Compiler compiler = new Compiler();\n     Node n = compiler.parseTestCode(\"x - -4\");\n     assertEquals(0, compiler.getErrorCount());\n-    NodeTraversal.traverse(compiler, n, new FoldConstants(compiler));\n \n     assertEquals(\n         \"x- -4\",\n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n       public void process(Node externs, Node js) {\n         new CreateSyntheticBlocks(compiler, START_MARKER, END_MARKER).process(\n             externs, js);\n-        NodeTraversal.traverse(compiler, js, new FoldConstants(compiler));\n         NodeTraversal.traverse(compiler, js, new MinimizeExitPoints(compiler));\n-        NodeTraversal.traverse(compiler, js, new FoldConstants(compiler));\n                 \n         new PeepholeOptimizationsPass(compiler, new \n             PeepholeRemoveDeadCode()).process(externs, js);\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n public class PeepholeSubstituteAlternateSyntaxTest extends CompilerTestCase {\n   \n   // Externs for builtin constructors\n-  // Needed for testFoldLiteralConstructors() and testFoldRegExp...()\n+  // Needed for testFoldLiteralObjectConstructors(),\n+  // testFoldLiteralArrayConstructors() and testFoldRegExp...()\n   private static final String FOLD_CONSTANTS_TEST_EXTERNS = \n       \"var Object = function(){};\\n\" +\n       \"var RegExp = function(a){};\\n\" +\n             \"foo\\\\\\\\u2028bar\\\\u2028\"));\n   }\n \n-  public void testFoldLiteralConstructors() {\n+  public void testFoldLiteralObjectConstructors() {\n     enableNormalize();\n     \n     // Can fold when normalized\n+    fold(\"x = new Object\", \"x = ({})\");\n+    fold(\"x = new Object()\", \"x = ({})\");\n+    fold(\"x = Object()\", \"x = ({})\");\n+\n+    disableNormalize();\n+    // Cannot fold above when not normalized\n+    foldSame(\"x = new Object\");\n+    foldSame(\"x = new Object()\");\n+    foldSame(\"x = Object()\");\n+\n+    enableNormalize();\n+\n+    // Cannot fold, the constructor being used is actually a local function\n+    foldSame(\"x = \" +\n+         \"(function(){function Object(){this.x=4};return new Object();})();\");\n+  }\n+\n+  public void testFoldLiteralArrayConstructors() {\n+    enableNormalize();\n+\n+    // No arguments - can fold when normalized\n     fold(\"x = new Array\", \"x = []\");\n     fold(\"x = new Array()\", \"x = []\");\n     fold(\"x = Array()\", \"x = []\");\n-    fold(\"x = new Object\", \"x = ({})\");\n-    fold(\"x = new Object()\", \"x = ({})\");\n-    fold(\"x = Object()\", \"x = ({})\");\n-\n+\n+    // One argument - can be fold when normalized\n+    fold(\"x = new Array(0)\", \"x = []\");\n+    fold(\"x = Array(0)\", \"x = []\");\n+    fold(\"x = new Array(\\\"a\\\")\", \"x = [\\\"a\\\"]\");\n+    fold(\"x = Array(\\\"a\\\")\", \"x = [\\\"a\\\"]\");\n+\n+    // One argument - cannot be fold when normalized\n+    fold(\"x = new Array(7)\", \"x = Array(7)\");\n+    fold(\"x = Array(7)\", \"x = Array(7)\");\n+    fold(\"x = new Array(y)\", \"x = Array(y)\");\n+    fold(\"x = Array(y)\", \"x = Array(y)\");\n+    fold(\"x = new Array(foo())\", \"x = Array(foo())\");\n+    fold(\"x = Array(foo())\", \"x = Array(foo())\");\n+\n+    // More than one argument - can be fold when normalized\n+    fold(\"x = new Array(1, 2, 3, 4)\", \"x = [1, 2, 3, 4]\");\n+    fold(\"x = Array(1, 2, 3, 4)\", \"x = [1, 2, 3, 4]\");\n+    fold(\"x = new Array('a', 1, 2, 'bc', 3, {}, 'abc')\",\n+         \"x = ['a', 1, 2, 'bc', 3, {}, 'abc']\");\n+    fold(\"x = Array('a', 1, 2, 'bc', 3, {}, 'abc')\",\n+         \"x = ['a', 1, 2, 'bc', 3, {}, 'abc']\");\n+    fold(\"x = new Array(Array(1, '2', 3, '4'))\", \"x = [[1, '2', 3, '4']]\");\n+    fold(\"x = Array(Array(1, '2', 3, '4'))\", \"x = [[1, '2', 3, '4']]\");\n+    fold(\"x = new Array(Object(), Array(\\\"abc\\\", Object(), Array(Array())))\",\n+         \"x = [{}, [\\\"abc\\\", {}, [[]]]\");\n+    fold(\"x = new Array(Object(), Array(\\\"abc\\\", Object(), Array(Array())))\",\n+         \"x = [{}, [\\\"abc\\\", {}, [[]]]\");\n+    \n     disableNormalize();\n     // Cannot fold above when not normalized\n     foldSame(\"x = new Array\");\n     foldSame(\"x = new Array()\");\n     foldSame(\"x = Array()\");\n-    foldSame(\"x = new Object\");\n-    foldSame(\"x = new Object()\");\n-    foldSame(\"x = Object()\");\n-    \n-    enableNormalize();\n-    // Cannot fold, there are arguments\n-    fold(\"x = new Array(7)\", \"x = Array(7)\");\n-\n-    // Cannot fold, the constructor being used is actually a local function\n-    foldSame(\"x = \" +\n-         \"(function(){function Object(){this.x=4};return new Object();})();\");\n-  }\n- \n+\n+    foldSame(\"x = new Array(0)\");\n+    foldSame(\"x = Array(0)\");\n+    foldSame(\"x = new Array(\\\"a\\\")\");\n+    foldSame(\"x = Array(\\\"a\\\")\");\n+    foldSame(\"x = new Array(7)\");\n+    foldSame(\"x = Array(7)\");\n+    foldSame(\"x = new Array(foo())\");\n+    foldSame(\"x = Array(foo())\");\n+\n+    foldSame(\"x = new Array(1, 2, 3, 4)\");\n+    foldSame(\"x = Array(1, 2, 3, 4)\");\n+    foldSame(\"x = new Array('a', 1, 2, 'bc', 3, {}, 'abc')\");\n+    foldSame(\"x = Array('a', 1, 2, 'bc', 3, {}, 'abc')\");\n+    foldSame(\"x = new Array(Array(1, '2', 3, '4'))\");\n+    foldSame(\"x = Array(Array(1, '2', 3, '4'))\");\n+    foldSame(\"x = new Array(Object(), Array(\\\"abc\\\", Object(), Array(Array())))\");\n+    foldSame(\"x = new Array(Object(), Array(\\\"abc\\\", Object(), Array(Array())))\");\n+  }\n+\n   public void testMinimizeCondition() {\n     // This test uses constant folding logic, so is only here for completeness.\n     fold(\"while(!!true) foo()\", \"while(1) foo()\");\n     fold(\"var x = new Object('a')\", \"var x = Object('a')\");\n     fold(\"var x = new RegExp('')\", \"var x = RegExp('')\");\n     fold(\"var x = new Error('20')\", \"var x = Error(\\\"20\\\")\");\n-    fold(\"var x = new Array('20')\", \"var x = Array(\\\"20\\\")\");\n+    fold(\"var x = new Array(20)\", \"var x = Array(20)\");\n   }\n }\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n \n   // The old and new parser produce different results now with labels, and\n   // named breaks and continues, so disable these tests.\n-  public void disable_testLabel() {\n-    parse(\"foo: bar\");\n-  }\n-\n-  public void disable_testLabel2() {\n-    parse(\"l: while (f()) { if (g()) { continue l; } }\");\n-  }\n-\n-  public void disable_testLabel3() {\n-    parse(\"Foo:Bar:X:{ break Bar; }\");\n+  public void testLabel() {\n+    testNewParser(\"foo: bar\",\n+      \"SCRIPT 0\\n\" +\n+      \"    LABEL 0\\n\" +\n+      \"        LABEL_NAME foo 0\\n\" +\n+      \"        EXPR_RESULT 0\\n\" +\n+      \"            NAME bar 0\\n\");\n+  }\n+\n+  public void testLabel2() {\n+    testNewParser(\"l: while (f()) { if (g()) { continue l; } }\",\n+      \"SCRIPT 0\\n\" +\n+      \"    LABEL 0\\n\" +\n+      \"        LABEL_NAME l 0\\n\" +\n+      \"        WHILE 0\\n\" +\n+      \"            CALL 0\\n\" +\n+      \"                NAME f 0\\n\" +\n+      \"            BLOCK 0\\n\" +\n+      \"                IF 0\\n\" +\n+      \"                    CALL 0\\n\" +\n+      \"                        NAME g 0\\n\" +\n+      \"                    BLOCK 0\\n\" +\n+      \"                        CONTINUE 0\\n\" +\n+      \"                            LABEL_NAME l 0\\n\");\n+  }\n+\n+  public void testLabel3() {\n+    testNewParser(\"Foo:Bar:X:{ break Bar; }\",\n+      \"SCRIPT 0\\n\" +\n+      \"    LABEL 0\\n\" +\n+      \"        LABEL_NAME Foo 0\\n\" +\n+      \"        LABEL 0\\n\" +\n+      \"            LABEL_NAME Bar 0\\n\" +\n+      \"            LABEL 0\\n\" +\n+      \"                LABEL_NAME X 0\\n\" +\n+      \"                BLOCK 0\\n\" +\n+      \"                    BREAK 0\\n\" +\n+      \"                        LABEL_NAME Bar 0\\n\");\n+  }\n+\n+  public void testNegation1() {\n+    testNewParser(\"-a\",\n+      \"SCRIPT 0\\n\" +\n+      \"    EXPR_RESULT 0\\n\" +\n+      \"        NEG 0\\n\" +\n+      \"            NAME a 0\\n\");\n+  }\n+\n+  public void testNegation2() {\n+    testNewParser(\"-2\",\n+      \"SCRIPT 0\\n\" +\n+      \"    EXPR_RESULT 0\\n\" +\n+      \"        NUMBER -2.0 0\\n\");\n+  }\n+\n+  public void testNegation3() {\n+    testNewParser(\"1 - -2\",\n+      \"SCRIPT 0\\n\" +\n+      \"    EXPR_RESULT 0\\n\" +\n+      \"        SUB 0\\n\" +\n+      \"            NUMBER 1.0 0\\n\" +\n+      \"            NUMBER -2.0 0\\n\");\n   }\n \n   public void testSwitch() {\n     assertEquals(\"Column position\", charno, n.getCharno());\n   }\n \n+  private void testNewParser(String code, String expected) {\n+    String actual = newParse(code).toStringTree();\n+    assertEquals(expected, actual);\n+  }\n+\n   private void parse(String string) {\n     String compare = newParse(string).checkTreeEquals(oldParse(string));\n     assertTrue(compare, compare == null);", "timestamp": 1277845855, "metainfo": ""}